/*
 * Apicurio Registry API [v2]
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v2` by default. Therefore you must prefix all API operation paths with `../apis/registry/v2` in this case. For example: `../apis/registry/v2/ids/globalIds/{globalId}`. 
 *
 * The version of the OpenAPI document: 2.4.x
 * Contact: apicurio@lists.jboss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ArtifactContent;
import org.openapitools.client.model.ArtifactMetaData;
import org.openapitools.client.model.ArtifactReference;
import org.openapitools.client.model.ArtifactSearchResults;
import org.openapitools.client.model.Error;
import java.io.File;
import org.openapitools.client.model.IfExists;
import org.openapitools.client.model.RuleViolationError;
import org.openapitools.client.model.SortBy;
import org.openapitools.client.model.SortOrder;
import org.openapitools.client.model.UpdateState;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ArtifactsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ArtifactsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ArtifactsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createArtifact
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param body The content of the artifact being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  (required)
     * @param xRegistryArtifactType Specifies the type of the artifact being added. Possible values include:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) (optional)
     * @param xRegistryArtifactId A client-provided, globally unique identifier for the new artifact. (optional)
     * @param xRegistryVersion Specifies the version number of this initial version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically (starting with version &#x60;1&#x60;). (optional)
     * @param ifExists Set this option to instruct the server on what to do if the artifact already exists. (optional)
     * @param canonical Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner. (optional)
     * @param xRegistryDescription Specifies the description of artifact being added. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryDescriptionEncoded Specifies the description of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryName Specifies the name of artifact being added. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryNameEncoded Specifies the name of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryContentHash Specifies the (optional) hash of the artifact to be verified. (optional)
     * @param xRegistryHashAlgorithm The algorithm to use when checking the content validity. (available: SHA256, MD5; default: SHA256) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Artifact was successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Common response for all operations that can return a &#x60;400&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Common response used when an input conflicts with existing data. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createArtifactCall(String groupId, File body, String xRegistryArtifactType, String xRegistryArtifactId, String xRegistryVersion, IfExists ifExists, Boolean canonical, String xRegistryDescription, String xRegistryDescriptionEncoded, String xRegistryName, String xRegistryNameEncoded, String xRegistryContentHash, String xRegistryHashAlgorithm, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/groups/{groupId}/artifacts"
            .replace("{" + "groupId" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (ifExists != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ifExists", ifExists));
        }

        if (canonical != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("canonical", canonical));
        }

        if (xRegistryArtifactType != null) {
            localVarHeaderParams.put("X-Registry-ArtifactType", localVarApiClient.parameterToString(xRegistryArtifactType));
        }

        if (xRegistryArtifactId != null) {
            localVarHeaderParams.put("X-Registry-ArtifactId", localVarApiClient.parameterToString(xRegistryArtifactId));
        }

        if (xRegistryVersion != null) {
            localVarHeaderParams.put("X-Registry-Version", localVarApiClient.parameterToString(xRegistryVersion));
        }

        if (xRegistryDescription != null) {
            localVarHeaderParams.put("X-Registry-Description", localVarApiClient.parameterToString(xRegistryDescription));
        }

        if (xRegistryDescriptionEncoded != null) {
            localVarHeaderParams.put("X-Registry-Description-Encoded", localVarApiClient.parameterToString(xRegistryDescriptionEncoded));
        }

        if (xRegistryName != null) {
            localVarHeaderParams.put("X-Registry-Name", localVarApiClient.parameterToString(xRegistryName));
        }

        if (xRegistryNameEncoded != null) {
            localVarHeaderParams.put("X-Registry-Name-Encoded", localVarApiClient.parameterToString(xRegistryNameEncoded));
        }

        if (xRegistryContentHash != null) {
            localVarHeaderParams.put("X-Registry-Content-Hash", localVarApiClient.parameterToString(xRegistryContentHash));
        }

        if (xRegistryHashAlgorithm != null) {
            localVarHeaderParams.put("X-Registry-Hash-Algorithm", localVarApiClient.parameterToString(xRegistryHashAlgorithm));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/create.extended+json",
            "application/vnd.create.extended+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createArtifactValidateBeforeCall(String groupId, File body, String xRegistryArtifactType, String xRegistryArtifactId, String xRegistryVersion, IfExists ifExists, Boolean canonical, String xRegistryDescription, String xRegistryDescriptionEncoded, String xRegistryName, String xRegistryNameEncoded, String xRegistryContentHash, String xRegistryHashAlgorithm, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling createArtifact(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling createArtifact(Async)");
        }

        return createArtifactCall(groupId, body, xRegistryArtifactType, xRegistryArtifactId, xRegistryVersion, ifExists, canonical, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryName, xRegistryNameEncoded, xRegistryContentHash, xRegistryHashAlgorithm, _callback);

    }

    /**
     * Create artifact
     * Creates a new artifact by posting the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the  supported types, but may be in another format for a few (for example, &#x60;PROTOBUF&#x60;).  The registry attempts to figure out what kind of artifact is being added from the following supported list:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  Alternatively, you can specify the artifact type using the &#x60;X-Registry-ArtifactType&#x60;  HTTP request header, or include a hint in the request&#39;s &#x60;Content-Type&#x60;.  For example:  &#x60;&#x60;&#x60; Content-Type: application/json; artifactType&#x3D;AVRO &#x60;&#x60;&#x60;  An artifact is created using the content provided in the body of the request.  This content is created under a unique artifact ID that can be provided in the request using the &#x60;X-Registry-ArtifactId&#x60; request header.  If not provided in the request, the server generates a unique ID for the artifact.  It is typically recommended that callers provide the ID, because this is typically a meaningful identifier,  and for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the &#x60;ifExists&#x60; query parameter to alter this default behavior. The &#x60;ifExists&#x60; query parameter can have one of the following values:  * &#x60;FAIL&#x60; (*default*) - server rejects the content with a 409 error * &#x60;UPDATE&#x60; - server updates the existing artifact and returns the new metadata * &#x60;RETURN&#x60; - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * &#x60;RETURN_OR_UPDATE&#x60; - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid &#x60;ArtifactType&#x60; was indicated (HTTP error &#x60;400&#x60;) * No &#x60;ArtifactType&#x60; was indicated and the server could not determine one from the content (HTTP error &#x60;400&#x60;) * Provided content (request body) was empty (HTTP error &#x60;400&#x60;) * An artifact with the provided ID already exists (HTTP error &#x60;409&#x60;) * The content violates one of the configured global rules (HTTP error &#x60;409&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param body The content of the artifact being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  (required)
     * @param xRegistryArtifactType Specifies the type of the artifact being added. Possible values include:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) (optional)
     * @param xRegistryArtifactId A client-provided, globally unique identifier for the new artifact. (optional)
     * @param xRegistryVersion Specifies the version number of this initial version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically (starting with version &#x60;1&#x60;). (optional)
     * @param ifExists Set this option to instruct the server on what to do if the artifact already exists. (optional)
     * @param canonical Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner. (optional)
     * @param xRegistryDescription Specifies the description of artifact being added. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryDescriptionEncoded Specifies the description of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryName Specifies the name of artifact being added. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryNameEncoded Specifies the name of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryContentHash Specifies the (optional) hash of the artifact to be verified. (optional)
     * @param xRegistryHashAlgorithm The algorithm to use when checking the content validity. (available: SHA256, MD5; default: SHA256) (optional)
     * @return ArtifactMetaData
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Artifact was successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Common response for all operations that can return a &#x60;400&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Common response used when an input conflicts with existing data. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ArtifactMetaData createArtifact(String groupId, File body, String xRegistryArtifactType, String xRegistryArtifactId, String xRegistryVersion, IfExists ifExists, Boolean canonical, String xRegistryDescription, String xRegistryDescriptionEncoded, String xRegistryName, String xRegistryNameEncoded, String xRegistryContentHash, String xRegistryHashAlgorithm) throws ApiException {
        ApiResponse<ArtifactMetaData> localVarResp = createArtifactWithHttpInfo(groupId, body, xRegistryArtifactType, xRegistryArtifactId, xRegistryVersion, ifExists, canonical, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryName, xRegistryNameEncoded, xRegistryContentHash, xRegistryHashAlgorithm);
        return localVarResp.getData();
    }

    /**
     * Create artifact
     * Creates a new artifact by posting the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the  supported types, but may be in another format for a few (for example, &#x60;PROTOBUF&#x60;).  The registry attempts to figure out what kind of artifact is being added from the following supported list:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  Alternatively, you can specify the artifact type using the &#x60;X-Registry-ArtifactType&#x60;  HTTP request header, or include a hint in the request&#39;s &#x60;Content-Type&#x60;.  For example:  &#x60;&#x60;&#x60; Content-Type: application/json; artifactType&#x3D;AVRO &#x60;&#x60;&#x60;  An artifact is created using the content provided in the body of the request.  This content is created under a unique artifact ID that can be provided in the request using the &#x60;X-Registry-ArtifactId&#x60; request header.  If not provided in the request, the server generates a unique ID for the artifact.  It is typically recommended that callers provide the ID, because this is typically a meaningful identifier,  and for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the &#x60;ifExists&#x60; query parameter to alter this default behavior. The &#x60;ifExists&#x60; query parameter can have one of the following values:  * &#x60;FAIL&#x60; (*default*) - server rejects the content with a 409 error * &#x60;UPDATE&#x60; - server updates the existing artifact and returns the new metadata * &#x60;RETURN&#x60; - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * &#x60;RETURN_OR_UPDATE&#x60; - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid &#x60;ArtifactType&#x60; was indicated (HTTP error &#x60;400&#x60;) * No &#x60;ArtifactType&#x60; was indicated and the server could not determine one from the content (HTTP error &#x60;400&#x60;) * Provided content (request body) was empty (HTTP error &#x60;400&#x60;) * An artifact with the provided ID already exists (HTTP error &#x60;409&#x60;) * The content violates one of the configured global rules (HTTP error &#x60;409&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param body The content of the artifact being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  (required)
     * @param xRegistryArtifactType Specifies the type of the artifact being added. Possible values include:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) (optional)
     * @param xRegistryArtifactId A client-provided, globally unique identifier for the new artifact. (optional)
     * @param xRegistryVersion Specifies the version number of this initial version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically (starting with version &#x60;1&#x60;). (optional)
     * @param ifExists Set this option to instruct the server on what to do if the artifact already exists. (optional)
     * @param canonical Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner. (optional)
     * @param xRegistryDescription Specifies the description of artifact being added. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryDescriptionEncoded Specifies the description of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryName Specifies the name of artifact being added. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryNameEncoded Specifies the name of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryContentHash Specifies the (optional) hash of the artifact to be verified. (optional)
     * @param xRegistryHashAlgorithm The algorithm to use when checking the content validity. (available: SHA256, MD5; default: SHA256) (optional)
     * @return ApiResponse&lt;ArtifactMetaData&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Artifact was successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Common response for all operations that can return a &#x60;400&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Common response used when an input conflicts with existing data. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ArtifactMetaData> createArtifactWithHttpInfo(String groupId, File body, String xRegistryArtifactType, String xRegistryArtifactId, String xRegistryVersion, IfExists ifExists, Boolean canonical, String xRegistryDescription, String xRegistryDescriptionEncoded, String xRegistryName, String xRegistryNameEncoded, String xRegistryContentHash, String xRegistryHashAlgorithm) throws ApiException {
        okhttp3.Call localVarCall = createArtifactValidateBeforeCall(groupId, body, xRegistryArtifactType, xRegistryArtifactId, xRegistryVersion, ifExists, canonical, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryName, xRegistryNameEncoded, xRegistryContentHash, xRegistryHashAlgorithm, null);
        Type localVarReturnType = new TypeToken<ArtifactMetaData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create artifact (asynchronously)
     * Creates a new artifact by posting the artifact content.  The body of the request should be the raw content of the artifact.  This is typically in JSON format for *most* of the  supported types, but may be in another format for a few (for example, &#x60;PROTOBUF&#x60;).  The registry attempts to figure out what kind of artifact is being added from the following supported list:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  Alternatively, you can specify the artifact type using the &#x60;X-Registry-ArtifactType&#x60;  HTTP request header, or include a hint in the request&#39;s &#x60;Content-Type&#x60;.  For example:  &#x60;&#x60;&#x60; Content-Type: application/json; artifactType&#x3D;AVRO &#x60;&#x60;&#x60;  An artifact is created using the content provided in the body of the request.  This content is created under a unique artifact ID that can be provided in the request using the &#x60;X-Registry-ArtifactId&#x60; request header.  If not provided in the request, the server generates a unique ID for the artifact.  It is typically recommended that callers provide the ID, because this is typically a meaningful identifier,  and for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the &#x60;ifExists&#x60; query parameter to alter this default behavior. The &#x60;ifExists&#x60; query parameter can have one of the following values:  * &#x60;FAIL&#x60; (*default*) - server rejects the content with a 409 error * &#x60;UPDATE&#x60; - server updates the existing artifact and returns the new metadata * &#x60;RETURN&#x60; - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * &#x60;RETURN_OR_UPDATE&#x60; - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid &#x60;ArtifactType&#x60; was indicated (HTTP error &#x60;400&#x60;) * No &#x60;ArtifactType&#x60; was indicated and the server could not determine one from the content (HTTP error &#x60;400&#x60;) * Provided content (request body) was empty (HTTP error &#x60;400&#x60;) * An artifact with the provided ID already exists (HTTP error &#x60;409&#x60;) * The content violates one of the configured global rules (HTTP error &#x60;409&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param body The content of the artifact being created. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  (required)
     * @param xRegistryArtifactType Specifies the type of the artifact being added. Possible values include:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;) (optional)
     * @param xRegistryArtifactId A client-provided, globally unique identifier for the new artifact. (optional)
     * @param xRegistryVersion Specifies the version number of this initial version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically (starting with version &#x60;1&#x60;). (optional)
     * @param ifExists Set this option to instruct the server on what to do if the artifact already exists. (optional)
     * @param canonical Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner. (optional)
     * @param xRegistryDescription Specifies the description of artifact being added. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryDescriptionEncoded Specifies the description of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryName Specifies the name of artifact being added. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryNameEncoded Specifies the name of artifact being added. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryContentHash Specifies the (optional) hash of the artifact to be verified. (optional)
     * @param xRegistryHashAlgorithm The algorithm to use when checking the content validity. (available: SHA256, MD5; default: SHA256) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Artifact was successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Common response for all operations that can return a &#x60;400&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Common response used when an input conflicts with existing data. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createArtifactAsync(String groupId, File body, String xRegistryArtifactType, String xRegistryArtifactId, String xRegistryVersion, IfExists ifExists, Boolean canonical, String xRegistryDescription, String xRegistryDescriptionEncoded, String xRegistryName, String xRegistryNameEncoded, String xRegistryContentHash, String xRegistryHashAlgorithm, final ApiCallback<ArtifactMetaData> _callback) throws ApiException {

        okhttp3.Call localVarCall = createArtifactValidateBeforeCall(groupId, body, xRegistryArtifactType, xRegistryArtifactId, xRegistryVersion, ifExists, canonical, xRegistryDescription, xRegistryDescriptionEncoded, xRegistryName, xRegistryNameEncoded, xRegistryContentHash, xRegistryHashAlgorithm, _callback);
        Type localVarReturnType = new TypeToken<ArtifactMetaData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteArtifact
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned when the artifact was successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteArtifactCall(String groupId, String artifactId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{groupId}/artifacts/{artifactId}"
            .replace("{" + "groupId" + "}", localVarApiClient.escapeString(groupId.toString()))
            .replace("{" + "artifactId" + "}", localVarApiClient.escapeString(artifactId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteArtifactValidateBeforeCall(String groupId, String artifactId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling deleteArtifact(Async)");
        }

        // verify the required parameter 'artifactId' is set
        if (artifactId == null) {
            throw new ApiException("Missing the required parameter 'artifactId' when calling deleteArtifact(Async)");
        }

        return deleteArtifactCall(groupId, artifactId, _callback);

    }

    /**
     * Delete artifact
     * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the &#x60;artifactId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;)
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned when the artifact was successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteArtifact(String groupId, String artifactId) throws ApiException {
        deleteArtifactWithHttpInfo(groupId, artifactId);
    }

    /**
     * Delete artifact
     * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the &#x60;artifactId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;)
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned when the artifact was successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteArtifactWithHttpInfo(String groupId, String artifactId) throws ApiException {
        okhttp3.Call localVarCall = deleteArtifactValidateBeforeCall(groupId, artifactId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete artifact (asynchronously)
     * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the &#x60;artifactId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;)
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned when the artifact was successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteArtifactAsync(String groupId, String artifactId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteArtifactValidateBeforeCall(groupId, artifactId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteArtifactsInGroup
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> When the delete operation is successful, a simple 204 is returned. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteArtifactsInGroupCall(String groupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{groupId}/artifacts"
            .replace("{" + "groupId" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteArtifactsInGroupValidateBeforeCall(String groupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling deleteArtifactsInGroup(Async)");
        }

        return deleteArtifactsInGroupCall(groupId, _callback);

    }

    /**
     * Delete artifacts in group
     * Deletes all of the artifacts that exist in a given group.
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> When the delete operation is successful, a simple 204 is returned. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteArtifactsInGroup(String groupId) throws ApiException {
        deleteArtifactsInGroupWithHttpInfo(groupId);
    }

    /**
     * Delete artifacts in group
     * Deletes all of the artifacts that exist in a given group.
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> When the delete operation is successful, a simple 204 is returned. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteArtifactsInGroupWithHttpInfo(String groupId) throws ApiException {
        okhttp3.Call localVarCall = deleteArtifactsInGroupValidateBeforeCall(groupId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete artifacts in group (asynchronously)
     * Deletes all of the artifacts that exist in a given group.
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> When the delete operation is successful, a simple 204 is returned. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteArtifactsInGroupAsync(String groupId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteArtifactsInGroupValidateBeforeCall(groupId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getContentByGlobalId
     * @param globalId Global identifier for an artifact version. (required)
     * @param dereference Allows the user to specify if the content should be dereferenced when being returned (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getContentByGlobalIdCall(Long globalId, Boolean dereference, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ids/globalIds/{globalId}"
            .replace("{" + "globalId" + "}", localVarApiClient.escapeString(globalId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dereference != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dereference", dereference));
        }

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getContentByGlobalIdValidateBeforeCall(Long globalId, Boolean dereference, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'globalId' is set
        if (globalId == null) {
            throw new ApiException("Missing the required parameter 'globalId' when calling getContentByGlobalId(Async)");
        }

        return getContentByGlobalIdCall(globalId, dereference, _callback);

    }

    /**
     * Get artifact by global ID
     * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this &#x60;globalId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param globalId Global identifier for an artifact version. (required)
     * @param dereference Allows the user to specify if the content should be dereferenced when being returned (optional)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public File getContentByGlobalId(Long globalId, Boolean dereference) throws ApiException {
        ApiResponse<File> localVarResp = getContentByGlobalIdWithHttpInfo(globalId, dereference);
        return localVarResp.getData();
    }

    /**
     * Get artifact by global ID
     * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this &#x60;globalId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param globalId Global identifier for an artifact version. (required)
     * @param dereference Allows the user to specify if the content should be dereferenced when being returned (optional)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getContentByGlobalIdWithHttpInfo(Long globalId, Boolean dereference) throws ApiException {
        okhttp3.Call localVarCall = getContentByGlobalIdValidateBeforeCall(globalId, dereference, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get artifact by global ID (asynchronously)
     * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this &#x60;globalId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param globalId Global identifier for an artifact version. (required)
     * @param dereference Allows the user to specify if the content should be dereferenced when being returned (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getContentByGlobalIdAsync(Long globalId, Boolean dereference, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getContentByGlobalIdValidateBeforeCall(globalId, dereference, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getContentByHash
     * @param contentHash SHA-256 content hash for a single artifact content. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getContentByHashCall(String contentHash, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ids/contentHashes/{contentHash}/"
            .replace("{" + "contentHash" + "}", localVarApiClient.escapeString(contentHash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getContentByHashValidateBeforeCall(String contentHash, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'contentHash' is set
        if (contentHash == null) {
            throw new ApiException("Missing the required parameter 'contentHash' when calling getContentByHash(Async)");
        }

        return getContentByHashCall(contentHash, _callback);

    }

    /**
     * Get artifact content by SHA-256 hash
     * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this &#x60;contentHash&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param contentHash SHA-256 content hash for a single artifact content. (required)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public File getContentByHash(String contentHash) throws ApiException {
        ApiResponse<File> localVarResp = getContentByHashWithHttpInfo(contentHash);
        return localVarResp.getData();
    }

    /**
     * Get artifact content by SHA-256 hash
     * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this &#x60;contentHash&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param contentHash SHA-256 content hash for a single artifact content. (required)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getContentByHashWithHttpInfo(String contentHash) throws ApiException {
        okhttp3.Call localVarCall = getContentByHashValidateBeforeCall(contentHash, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get artifact content by SHA-256 hash (asynchronously)
     * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this &#x60;contentHash&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param contentHash SHA-256 content hash for a single artifact content. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getContentByHashAsync(String contentHash, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getContentByHashValidateBeforeCall(contentHash, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getContentById
     * @param contentId Global identifier for a single artifact content. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getContentByIdCall(Long contentId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ids/contentIds/{contentId}/"
            .replace("{" + "contentId" + "}", localVarApiClient.escapeString(contentId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getContentByIdValidateBeforeCall(Long contentId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'contentId' is set
        if (contentId == null) {
            throw new ApiException("Missing the required parameter 'contentId' when calling getContentById(Async)");
        }

        return getContentByIdCall(contentId, _callback);

    }

    /**
     * Get artifact content by ID
     * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this &#x60;contentId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param contentId Global identifier for a single artifact content. (required)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public File getContentById(Long contentId) throws ApiException {
        ApiResponse<File> localVarResp = getContentByIdWithHttpInfo(contentId);
        return localVarResp.getData();
    }

    /**
     * Get artifact content by ID
     * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this &#x60;contentId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param contentId Global identifier for a single artifact content. (required)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getContentByIdWithHttpInfo(Long contentId) throws ApiException {
        okhttp3.Call localVarCall = getContentByIdValidateBeforeCall(contentId, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get artifact content by ID (asynchronously)
     * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this &#x60;contentId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param contentId Global identifier for a single artifact content. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getContentByIdAsync(Long contentId, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getContentByIdValidateBeforeCall(contentId, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getLatestArtifact
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param dereference Allows the user to specify if the content should be dereferenced when being returned (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLatestArtifactCall(String groupId, String artifactId, Boolean dereference, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{groupId}/artifacts/{artifactId}"
            .replace("{" + "groupId" + "}", localVarApiClient.escapeString(groupId.toString()))
            .replace("{" + "artifactId" + "}", localVarApiClient.escapeString(artifactId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dereference != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dereference", dereference));
        }

        final String[] localVarAccepts = {
            "*/*",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getLatestArtifactValidateBeforeCall(String groupId, String artifactId, Boolean dereference, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling getLatestArtifact(Async)");
        }

        // verify the required parameter 'artifactId' is set
        if (artifactId == null) {
            throw new ApiException("Missing the required parameter 'artifactId' when calling getLatestArtifact(Async)");
        }

        return getLatestArtifactCall(groupId, artifactId, dereference, _callback);

    }

    /**
     * Get latest artifact
     * Returns the latest version of the artifact in its raw form.  The &#x60;Content-Type&#x60; of the response depends on the artifact type.  In most cases, this is &#x60;application/json&#x60;, but  for some types it may be different (for example, &#x60;PROTOBUF&#x60;). If the latest version of the artifact is marked as &#x60;DISABLED&#x60;, the next available non-disabled version will be used.  This operation may fail for one of the following reasons:  * No artifact with this &#x60;artifactId&#x60; exists or all versions are &#x60;DISABLED&#x60; (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param dereference Allows the user to specify if the content should be dereferenced when being returned (optional)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public File getLatestArtifact(String groupId, String artifactId, Boolean dereference) throws ApiException {
        ApiResponse<File> localVarResp = getLatestArtifactWithHttpInfo(groupId, artifactId, dereference);
        return localVarResp.getData();
    }

    /**
     * Get latest artifact
     * Returns the latest version of the artifact in its raw form.  The &#x60;Content-Type&#x60; of the response depends on the artifact type.  In most cases, this is &#x60;application/json&#x60;, but  for some types it may be different (for example, &#x60;PROTOBUF&#x60;). If the latest version of the artifact is marked as &#x60;DISABLED&#x60;, the next available non-disabled version will be used.  This operation may fail for one of the following reasons:  * No artifact with this &#x60;artifactId&#x60; exists or all versions are &#x60;DISABLED&#x60; (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param dereference Allows the user to specify if the content should be dereferenced when being returned (optional)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> getLatestArtifactWithHttpInfo(String groupId, String artifactId, Boolean dereference) throws ApiException {
        okhttp3.Call localVarCall = getLatestArtifactValidateBeforeCall(groupId, artifactId, dereference, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get latest artifact (asynchronously)
     * Returns the latest version of the artifact in its raw form.  The &#x60;Content-Type&#x60; of the response depends on the artifact type.  In most cases, this is &#x60;application/json&#x60;, but  for some types it may be different (for example, &#x60;PROTOBUF&#x60;). If the latest version of the artifact is marked as &#x60;DISABLED&#x60;, the next available non-disabled version will be used.  This operation may fail for one of the following reasons:  * No artifact with this &#x60;artifactId&#x60; exists or all versions are &#x60;DISABLED&#x60; (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param dereference Allows the user to specify if the content should be dereferenced when being returned (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The content of one version of one artifact. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLatestArtifactAsync(String groupId, String artifactId, Boolean dereference, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = getLatestArtifactValidateBeforeCall(groupId, artifactId, dereference, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listArtifactsInGroup
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional)
     * @param offset The number of artifacts to skip before starting the result set.  Defaults to 0. (optional)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a bounded set of artifacts. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listArtifactsInGroupCall(String groupId, Integer limit, Integer offset, SortOrder order, SortBy orderby, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{groupId}/artifacts"
            .replace("{" + "groupId" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (orderby != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderby", orderby));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listArtifactsInGroupValidateBeforeCall(String groupId, Integer limit, Integer offset, SortOrder order, SortBy orderby, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling listArtifactsInGroup(Async)");
        }

        return listArtifactsInGroupCall(groupId, limit, offset, order, orderby, _callback);

    }

    /**
     * List artifacts in group
     * Returns a list of all artifacts in the group.  This list is paged.
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional)
     * @param offset The number of artifacts to skip before starting the result set.  Defaults to 0. (optional)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @return ArtifactSearchResults
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a bounded set of artifacts. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ArtifactSearchResults listArtifactsInGroup(String groupId, Integer limit, Integer offset, SortOrder order, SortBy orderby) throws ApiException {
        ApiResponse<ArtifactSearchResults> localVarResp = listArtifactsInGroupWithHttpInfo(groupId, limit, offset, order, orderby);
        return localVarResp.getData();
    }

    /**
     * List artifacts in group
     * Returns a list of all artifacts in the group.  This list is paged.
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional)
     * @param offset The number of artifacts to skip before starting the result set.  Defaults to 0. (optional)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @return ApiResponse&lt;ArtifactSearchResults&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a bounded set of artifacts. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ArtifactSearchResults> listArtifactsInGroupWithHttpInfo(String groupId, Integer limit, Integer offset, SortOrder order, SortBy orderby) throws ApiException {
        okhttp3.Call localVarCall = listArtifactsInGroupValidateBeforeCall(groupId, limit, offset, order, orderby, null);
        Type localVarReturnType = new TypeToken<ArtifactSearchResults>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List artifacts in group (asynchronously)
     * Returns a list of all artifacts in the group.  This list is paged.
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional)
     * @param offset The number of artifacts to skip before starting the result set.  Defaults to 0. (optional)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a bounded set of artifacts. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listArtifactsInGroupAsync(String groupId, Integer limit, Integer offset, SortOrder order, SortBy orderby, final ApiCallback<ArtifactSearchResults> _callback) throws ApiException {

        okhttp3.Call localVarCall = listArtifactsInGroupValidateBeforeCall(groupId, limit, offset, order, orderby, _callback);
        Type localVarReturnType = new TypeToken<ArtifactSearchResults>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for referencesByContentHash
     * @param contentHash SHA-256 content hash for a single artifact content. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given content hash. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call referencesByContentHashCall(String contentHash, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ids/contentHashes/{contentHash}/references"
            .replace("{" + "contentHash" + "}", localVarApiClient.escapeString(contentHash.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call referencesByContentHashValidateBeforeCall(String contentHash, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'contentHash' is set
        if (contentHash == null) {
            throw new ApiException("Missing the required parameter 'contentHash' when calling referencesByContentHash(Async)");
        }

        return referencesByContentHashCall(contentHash, _callback);

    }

    /**
     * List artifact references by hash
     * Returns a list containing all the artifact references using the artifact content hash.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param contentHash SHA-256 content hash for a single artifact content. (required)
     * @return List&lt;ArtifactReference&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given content hash. </td><td>  -  </td></tr>
     </table>
     */
    public List<ArtifactReference> referencesByContentHash(String contentHash) throws ApiException {
        ApiResponse<List<ArtifactReference>> localVarResp = referencesByContentHashWithHttpInfo(contentHash);
        return localVarResp.getData();
    }

    /**
     * List artifact references by hash
     * Returns a list containing all the artifact references using the artifact content hash.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param contentHash SHA-256 content hash for a single artifact content. (required)
     * @return ApiResponse&lt;List&lt;ArtifactReference&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given content hash. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ArtifactReference>> referencesByContentHashWithHttpInfo(String contentHash) throws ApiException {
        okhttp3.Call localVarCall = referencesByContentHashValidateBeforeCall(contentHash, null);
        Type localVarReturnType = new TypeToken<List<ArtifactReference>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List artifact references by hash (asynchronously)
     * Returns a list containing all the artifact references using the artifact content hash.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param contentHash SHA-256 content hash for a single artifact content. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given content hash. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call referencesByContentHashAsync(String contentHash, final ApiCallback<List<ArtifactReference>> _callback) throws ApiException {

        okhttp3.Call localVarCall = referencesByContentHashValidateBeforeCall(contentHash, _callback);
        Type localVarReturnType = new TypeToken<List<ArtifactReference>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for referencesByContentId
     * @param contentId Global identifier for a single artifact content. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given content id. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call referencesByContentIdCall(Long contentId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ids/contentIds/{contentId}/references"
            .replace("{" + "contentId" + "}", localVarApiClient.escapeString(contentId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call referencesByContentIdValidateBeforeCall(Long contentId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'contentId' is set
        if (contentId == null) {
            throw new ApiException("Missing the required parameter 'contentId' when calling referencesByContentId(Async)");
        }

        return referencesByContentIdCall(contentId, _callback);

    }

    /**
     * List artifact references by content ID
     * Returns a list containing all the artifact references using the artifact content ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error &#x60;500&#x60;)
     * @param contentId Global identifier for a single artifact content. (required)
     * @return List&lt;ArtifactReference&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given content id. </td><td>  -  </td></tr>
     </table>
     */
    public List<ArtifactReference> referencesByContentId(Long contentId) throws ApiException {
        ApiResponse<List<ArtifactReference>> localVarResp = referencesByContentIdWithHttpInfo(contentId);
        return localVarResp.getData();
    }

    /**
     * List artifact references by content ID
     * Returns a list containing all the artifact references using the artifact content ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error &#x60;500&#x60;)
     * @param contentId Global identifier for a single artifact content. (required)
     * @return ApiResponse&lt;List&lt;ArtifactReference&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given content id. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ArtifactReference>> referencesByContentIdWithHttpInfo(Long contentId) throws ApiException {
        okhttp3.Call localVarCall = referencesByContentIdValidateBeforeCall(contentId, null);
        Type localVarReturnType = new TypeToken<List<ArtifactReference>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List artifact references by content ID (asynchronously)
     * Returns a list containing all the artifact references using the artifact content ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error &#x60;500&#x60;)
     * @param contentId Global identifier for a single artifact content. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given content id. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call referencesByContentIdAsync(Long contentId, final ApiCallback<List<ArtifactReference>> _callback) throws ApiException {

        okhttp3.Call localVarCall = referencesByContentIdValidateBeforeCall(contentId, _callback);
        Type localVarReturnType = new TypeToken<List<ArtifactReference>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for referencesByGlobalId
     * @param globalId Global identifier for an artifact version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given global id. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call referencesByGlobalIdCall(Long globalId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ids/globalIds/{globalId}/references"
            .replace("{" + "globalId" + "}", localVarApiClient.escapeString(globalId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call referencesByGlobalIdValidateBeforeCall(Long globalId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'globalId' is set
        if (globalId == null) {
            throw new ApiException("Missing the required parameter 'globalId' when calling referencesByGlobalId(Async)");
        }

        return referencesByGlobalIdCall(globalId, _callback);

    }

    /**
     * List artifact references by global ID
     * Returns a list containing all the artifact references using the artifact global ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error &#x60;500&#x60;)
     * @param globalId Global identifier for an artifact version. (required)
     * @return List&lt;ArtifactReference&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given global id. </td><td>  -  </td></tr>
     </table>
     */
    public List<ArtifactReference> referencesByGlobalId(Long globalId) throws ApiException {
        ApiResponse<List<ArtifactReference>> localVarResp = referencesByGlobalIdWithHttpInfo(globalId);
        return localVarResp.getData();
    }

    /**
     * List artifact references by global ID
     * Returns a list containing all the artifact references using the artifact global ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error &#x60;500&#x60;)
     * @param globalId Global identifier for an artifact version. (required)
     * @return ApiResponse&lt;List&lt;ArtifactReference&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given global id. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ArtifactReference>> referencesByGlobalIdWithHttpInfo(Long globalId) throws ApiException {
        okhttp3.Call localVarCall = referencesByGlobalIdValidateBeforeCall(globalId, null);
        Type localVarReturnType = new TypeToken<List<ArtifactReference>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List artifact references by global ID (asynchronously)
     * Returns a list containing all the artifact references using the artifact global ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error &#x60;500&#x60;)
     * @param globalId Global identifier for an artifact version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list containing all the references for the artifact with the given global id. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call referencesByGlobalIdAsync(Long globalId, final ApiCallback<List<ArtifactReference>> _callback) throws ApiException {

        okhttp3.Call localVarCall = referencesByGlobalIdValidateBeforeCall(globalId, _callback);
        Type localVarReturnType = new TypeToken<List<ArtifactReference>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchArtifactsByContent_0
     * @param body The content to search for. (required)
     * @param canonical Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter. (optional)
     * @param artifactType Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts. (optional)
     * @param offset The number of artifacts to skip before starting to collect the result set.  Defaults to 0. (optional, default to 0)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional, default to 20)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a result set of artifacts - one for each artifact in the registry that matches the criteria. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchArtifactsByContent_0Call(File body, Boolean canonical, String artifactType, Integer offset, Integer limit, String order, String orderby, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/search/artifacts";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (canonical != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("canonical", canonical));
        }

        if (artifactType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("artifactType", artifactType));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (orderby != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderby", orderby));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchArtifactsByContent_0ValidateBeforeCall(File body, Boolean canonical, String artifactType, Integer offset, Integer limit, String order, String orderby, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling searchArtifactsByContent_0(Async)");
        }

        return searchArtifactsByContent_0Call(body, canonical, artifactType, offset, limit, order, orderby, _callback);

    }

    /**
     * Search for artifacts by content
     * Returns a paginated list of all artifacts with at least one version that matches the posted content. 
     * @param body The content to search for. (required)
     * @param canonical Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter. (optional)
     * @param artifactType Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts. (optional)
     * @param offset The number of artifacts to skip before starting to collect the result set.  Defaults to 0. (optional, default to 0)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional, default to 20)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @return ArtifactSearchResults
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a result set of artifacts - one for each artifact in the registry that matches the criteria. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ArtifactSearchResults searchArtifactsByContent_0(File body, Boolean canonical, String artifactType, Integer offset, Integer limit, String order, String orderby) throws ApiException {
        ApiResponse<ArtifactSearchResults> localVarResp = searchArtifactsByContent_0WithHttpInfo(body, canonical, artifactType, offset, limit, order, orderby);
        return localVarResp.getData();
    }

    /**
     * Search for artifacts by content
     * Returns a paginated list of all artifacts with at least one version that matches the posted content. 
     * @param body The content to search for. (required)
     * @param canonical Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter. (optional)
     * @param artifactType Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts. (optional)
     * @param offset The number of artifacts to skip before starting to collect the result set.  Defaults to 0. (optional, default to 0)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional, default to 20)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @return ApiResponse&lt;ArtifactSearchResults&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a result set of artifacts - one for each artifact in the registry that matches the criteria. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ArtifactSearchResults> searchArtifactsByContent_0WithHttpInfo(File body, Boolean canonical, String artifactType, Integer offset, Integer limit, String order, String orderby) throws ApiException {
        okhttp3.Call localVarCall = searchArtifactsByContent_0ValidateBeforeCall(body, canonical, artifactType, offset, limit, order, orderby, null);
        Type localVarReturnType = new TypeToken<ArtifactSearchResults>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search for artifacts by content (asynchronously)
     * Returns a paginated list of all artifacts with at least one version that matches the posted content. 
     * @param body The content to search for. (required)
     * @param canonical Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter. (optional)
     * @param artifactType Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts. (optional)
     * @param offset The number of artifacts to skip before starting to collect the result set.  Defaults to 0. (optional, default to 0)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional, default to 20)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a result set of artifacts - one for each artifact in the registry that matches the criteria. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchArtifactsByContent_0Async(File body, Boolean canonical, String artifactType, Integer offset, Integer limit, String order, String orderby, final ApiCallback<ArtifactSearchResults> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchArtifactsByContent_0ValidateBeforeCall(body, canonical, artifactType, offset, limit, order, orderby, _callback);
        Type localVarReturnType = new TypeToken<ArtifactSearchResults>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchArtifacts_0
     * @param name Filter by artifact name. (optional)
     * @param offset The number of artifacts to skip before starting to collect the result set.  Defaults to 0. (optional, default to 0)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional, default to 20)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @param labels Filter by label.  Include one or more label to only return artifacts containing all of the specified labels. (optional)
     * @param properties Filter by one or more name/value property.  Separate each name/value pair using a colon.  For example &#x60;properties&#x3D;foo:bar&#x60; will return only artifacts with a custom property named &#x60;foo&#x60; and value &#x60;bar&#x60;. (optional)
     * @param description Filter by description. (optional)
     * @param group Filter by artifact group. (optional)
     * @param globalId Filter by globalId. (optional)
     * @param contentId Filter by contentId. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a result set of artifacts - one for each artifact in the registry that matches the criteria. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchArtifacts_0Call(String name, Integer offset, Integer limit, SortOrder order, SortBy orderby, List<String> labels, List<String> properties, String description, String group, Long globalId, Long contentId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/search/artifacts";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (orderby != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderby", orderby));
        }

        if (labels != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "labels", labels));
        }

        if (properties != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "properties", properties));
        }

        if (description != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("description", description));
        }

        if (group != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group", group));
        }

        if (globalId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("globalId", globalId));
        }

        if (contentId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("contentId", contentId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchArtifacts_0ValidateBeforeCall(String name, Integer offset, Integer limit, SortOrder order, SortBy orderby, List<String> labels, List<String> properties, String description, String group, Long globalId, Long contentId, final ApiCallback _callback) throws ApiException {
        return searchArtifacts_0Call(name, offset, limit, order, orderby, labels, properties, description, group, globalId, contentId, _callback);

    }

    /**
     * Search for artifacts
     * Returns a paginated list of all artifacts that match the provided filter criteria. 
     * @param name Filter by artifact name. (optional)
     * @param offset The number of artifacts to skip before starting to collect the result set.  Defaults to 0. (optional, default to 0)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional, default to 20)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @param labels Filter by label.  Include one or more label to only return artifacts containing all of the specified labels. (optional)
     * @param properties Filter by one or more name/value property.  Separate each name/value pair using a colon.  For example &#x60;properties&#x3D;foo:bar&#x60; will return only artifacts with a custom property named &#x60;foo&#x60; and value &#x60;bar&#x60;. (optional)
     * @param description Filter by description. (optional)
     * @param group Filter by artifact group. (optional)
     * @param globalId Filter by globalId. (optional)
     * @param contentId Filter by contentId. (optional)
     * @return ArtifactSearchResults
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a result set of artifacts - one for each artifact in the registry that matches the criteria. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ArtifactSearchResults searchArtifacts_0(String name, Integer offset, Integer limit, SortOrder order, SortBy orderby, List<String> labels, List<String> properties, String description, String group, Long globalId, Long contentId) throws ApiException {
        ApiResponse<ArtifactSearchResults> localVarResp = searchArtifacts_0WithHttpInfo(name, offset, limit, order, orderby, labels, properties, description, group, globalId, contentId);
        return localVarResp.getData();
    }

    /**
     * Search for artifacts
     * Returns a paginated list of all artifacts that match the provided filter criteria. 
     * @param name Filter by artifact name. (optional)
     * @param offset The number of artifacts to skip before starting to collect the result set.  Defaults to 0. (optional, default to 0)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional, default to 20)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @param labels Filter by label.  Include one or more label to only return artifacts containing all of the specified labels. (optional)
     * @param properties Filter by one or more name/value property.  Separate each name/value pair using a colon.  For example &#x60;properties&#x3D;foo:bar&#x60; will return only artifacts with a custom property named &#x60;foo&#x60; and value &#x60;bar&#x60;. (optional)
     * @param description Filter by description. (optional)
     * @param group Filter by artifact group. (optional)
     * @param globalId Filter by globalId. (optional)
     * @param contentId Filter by contentId. (optional)
     * @return ApiResponse&lt;ArtifactSearchResults&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a result set of artifacts - one for each artifact in the registry that matches the criteria. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ArtifactSearchResults> searchArtifacts_0WithHttpInfo(String name, Integer offset, Integer limit, SortOrder order, SortBy orderby, List<String> labels, List<String> properties, String description, String group, Long globalId, Long contentId) throws ApiException {
        okhttp3.Call localVarCall = searchArtifacts_0ValidateBeforeCall(name, offset, limit, order, orderby, labels, properties, description, group, globalId, contentId, null);
        Type localVarReturnType = new TypeToken<ArtifactSearchResults>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search for artifacts (asynchronously)
     * Returns a paginated list of all artifacts that match the provided filter criteria. 
     * @param name Filter by artifact name. (optional)
     * @param offset The number of artifacts to skip before starting to collect the result set.  Defaults to 0. (optional, default to 0)
     * @param limit The number of artifacts to return.  Defaults to 20. (optional, default to 20)
     * @param order Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;). (optional)
     * @param orderby The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60;  (optional)
     * @param labels Filter by label.  Include one or more label to only return artifacts containing all of the specified labels. (optional)
     * @param properties Filter by one or more name/value property.  Separate each name/value pair using a colon.  For example &#x60;properties&#x3D;foo:bar&#x60; will return only artifacts with a custom property named &#x60;foo&#x60; and value &#x60;bar&#x60;. (optional)
     * @param description Filter by description. (optional)
     * @param group Filter by artifact group. (optional)
     * @param globalId Filter by globalId. (optional)
     * @param contentId Filter by contentId. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> On a successful response, returns a result set of artifacts - one for each artifact in the registry that matches the criteria. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchArtifacts_0Async(String name, Integer offset, Integer limit, SortOrder order, SortBy orderby, List<String> labels, List<String> properties, String description, String group, Long globalId, Long contentId, final ApiCallback<ArtifactSearchResults> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchArtifacts_0ValidateBeforeCall(name, offset, limit, order, orderby, labels, properties, description, group, globalId, contentId, _callback);
        Type localVarReturnType = new TypeToken<ArtifactSearchResults>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateArtifact
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param body The new content of the artifact being updated. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  (required)
     * @param xRegistryVersion Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically. (optional)
     * @param xRegistryName Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryNameEncoded Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryDescription Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryDescriptionEncoded Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> When successful, returns the updated artifact metadata. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Common response used when an input conflicts with existing data. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateArtifactCall(String groupId, String artifactId, File body, String xRegistryVersion, String xRegistryName, String xRegistryNameEncoded, String xRegistryDescription, String xRegistryDescriptionEncoded, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/groups/{groupId}/artifacts/{artifactId}"
            .replace("{" + "groupId" + "}", localVarApiClient.escapeString(groupId.toString()))
            .replace("{" + "artifactId" + "}", localVarApiClient.escapeString(artifactId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRegistryVersion != null) {
            localVarHeaderParams.put("X-Registry-Version", localVarApiClient.parameterToString(xRegistryVersion));
        }

        if (xRegistryName != null) {
            localVarHeaderParams.put("X-Registry-Name", localVarApiClient.parameterToString(xRegistryName));
        }

        if (xRegistryNameEncoded != null) {
            localVarHeaderParams.put("X-Registry-Name-Encoded", localVarApiClient.parameterToString(xRegistryNameEncoded));
        }

        if (xRegistryDescription != null) {
            localVarHeaderParams.put("X-Registry-Description", localVarApiClient.parameterToString(xRegistryDescription));
        }

        if (xRegistryDescriptionEncoded != null) {
            localVarHeaderParams.put("X-Registry-Description-Encoded", localVarApiClient.parameterToString(xRegistryDescriptionEncoded));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/create.extended+json",
            "application/vnd.create.extended+json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateArtifactValidateBeforeCall(String groupId, String artifactId, File body, String xRegistryVersion, String xRegistryName, String xRegistryNameEncoded, String xRegistryDescription, String xRegistryDescriptionEncoded, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling updateArtifact(Async)");
        }

        // verify the required parameter 'artifactId' is set
        if (artifactId == null) {
            throw new ApiException("Missing the required parameter 'artifactId' when calling updateArtifact(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling updateArtifact(Async)");
        }

        return updateArtifactCall(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryNameEncoded, xRegistryDescription, xRegistryDescriptionEncoded, _callback);

    }

    /**
     * Update artifact
     * Updates an artifact by uploading new content.  The body of the request can be the raw content of the artifact or a JSON object containing both the raw content and a set of references to other artifacts..  This is typically in JSON format for *most* of the supported types, but may be in another format for a few (for example, &#x60;PROTOBUF&#x60;). The type of the content should be compatible with the artifact&#39;s type (it would be an error to update an &#x60;AVRO&#x60; artifact with new &#x60;OPENAPI&#x60; content, for example).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error &#x60;400&#x60;) * No artifact with the &#x60;artifactId&#x60; exists (HTTP error &#x60;404&#x60;) * The new content violates one of the rules configured for the artifact (HTTP error &#x60;409&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;)  When successful, this creates a new version of the artifact, making it the most recent (and therefore official) version of the artifact.
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param body The new content of the artifact being updated. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  (required)
     * @param xRegistryVersion Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically. (optional)
     * @param xRegistryName Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryNameEncoded Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryDescription Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryDescriptionEncoded Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @return ArtifactMetaData
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> When successful, returns the updated artifact metadata. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Common response used when an input conflicts with existing data. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ArtifactMetaData updateArtifact(String groupId, String artifactId, File body, String xRegistryVersion, String xRegistryName, String xRegistryNameEncoded, String xRegistryDescription, String xRegistryDescriptionEncoded) throws ApiException {
        ApiResponse<ArtifactMetaData> localVarResp = updateArtifactWithHttpInfo(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryNameEncoded, xRegistryDescription, xRegistryDescriptionEncoded);
        return localVarResp.getData();
    }

    /**
     * Update artifact
     * Updates an artifact by uploading new content.  The body of the request can be the raw content of the artifact or a JSON object containing both the raw content and a set of references to other artifacts..  This is typically in JSON format for *most* of the supported types, but may be in another format for a few (for example, &#x60;PROTOBUF&#x60;). The type of the content should be compatible with the artifact&#39;s type (it would be an error to update an &#x60;AVRO&#x60; artifact with new &#x60;OPENAPI&#x60; content, for example).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error &#x60;400&#x60;) * No artifact with the &#x60;artifactId&#x60; exists (HTTP error &#x60;404&#x60;) * The new content violates one of the rules configured for the artifact (HTTP error &#x60;409&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;)  When successful, this creates a new version of the artifact, making it the most recent (and therefore official) version of the artifact.
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param body The new content of the artifact being updated. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  (required)
     * @param xRegistryVersion Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically. (optional)
     * @param xRegistryName Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryNameEncoded Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryDescription Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryDescriptionEncoded Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @return ApiResponse&lt;ArtifactMetaData&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> When successful, returns the updated artifact metadata. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Common response used when an input conflicts with existing data. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ArtifactMetaData> updateArtifactWithHttpInfo(String groupId, String artifactId, File body, String xRegistryVersion, String xRegistryName, String xRegistryNameEncoded, String xRegistryDescription, String xRegistryDescriptionEncoded) throws ApiException {
        okhttp3.Call localVarCall = updateArtifactValidateBeforeCall(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryNameEncoded, xRegistryDescription, xRegistryDescriptionEncoded, null);
        Type localVarReturnType = new TypeToken<ArtifactMetaData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update artifact (asynchronously)
     * Updates an artifact by uploading new content.  The body of the request can be the raw content of the artifact or a JSON object containing both the raw content and a set of references to other artifacts..  This is typically in JSON format for *most* of the supported types, but may be in another format for a few (for example, &#x60;PROTOBUF&#x60;). The type of the content should be compatible with the artifact&#39;s type (it would be an error to update an &#x60;AVRO&#x60; artifact with new &#x60;OPENAPI&#x60; content, for example).  The update could fail for a number of reasons including:  * Provided content (request body) was empty (HTTP error &#x60;400&#x60;) * No artifact with the &#x60;artifactId&#x60; exists (HTTP error &#x60;404&#x60;) * The new content violates one of the rules configured for the artifact (HTTP error &#x60;409&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;)  When successful, this creates a new version of the artifact, making it the most recent (and therefore official) version of the artifact.
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param body The new content of the artifact being updated. This is often, but not always, JSON data representing one of the supported artifact types:  * Avro (&#x60;AVRO&#x60;) * Protobuf (&#x60;PROTOBUF&#x60;) * JSON Schema (&#x60;JSON&#x60;) * Kafka Connect (&#x60;KCONNECT&#x60;) * OpenAPI (&#x60;OPENAPI&#x60;) * AsyncAPI (&#x60;ASYNCAPI&#x60;) * GraphQL (&#x60;GRAPHQL&#x60;) * Web Services Description Language (&#x60;WSDL&#x60;) * XML Schema (&#x60;XSD&#x60;)  (required)
     * @param xRegistryVersion Specifies the version number of this new version of the artifact content.  This would typically be a simple integer or a SemVer value.  If not provided, the server will assign a version number automatically. (optional)
     * @param xRegistryName Specifies the artifact name of this new version of the artifact content. Name must be ASCII-only string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryNameEncoded Specifies the artifact name of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the name from the artifact content. (optional)
     * @param xRegistryDescription Specifies the artifact description of this new version of the artifact content. Description must be ASCII-only string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param xRegistryDescriptionEncoded Specifies the artifact description of this new version of the artifact content. Value of this must be Base64 encoded string. If this is not provided, the server will extract the description from the artifact content. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> When successful, returns the updated artifact metadata. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Common response used when an input conflicts with existing data. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateArtifactAsync(String groupId, String artifactId, File body, String xRegistryVersion, String xRegistryName, String xRegistryNameEncoded, String xRegistryDescription, String xRegistryDescriptionEncoded, final ApiCallback<ArtifactMetaData> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateArtifactValidateBeforeCall(groupId, artifactId, body, xRegistryVersion, xRegistryName, xRegistryNameEncoded, xRegistryDescription, xRegistryDescriptionEncoded, _callback);
        Type localVarReturnType = new TypeToken<ArtifactMetaData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateArtifactState
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param updateState  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned when the operation was successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Common response for all operations that can return a &#x60;400&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateArtifactStateCall(String groupId, String artifactId, UpdateState updateState, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateState;

        // create path and map variables
        String localVarPath = "/groups/{groupId}/artifacts/{artifactId}/state"
            .replace("{" + "groupId" + "}", localVarApiClient.escapeString(groupId.toString()))
            .replace("{" + "artifactId" + "}", localVarApiClient.escapeString(artifactId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateArtifactStateValidateBeforeCall(String groupId, String artifactId, UpdateState updateState, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling updateArtifactState(Async)");
        }

        // verify the required parameter 'artifactId' is set
        if (artifactId == null) {
            throw new ApiException("Missing the required parameter 'artifactId' when calling updateArtifactState(Async)");
        }

        // verify the required parameter 'updateState' is set
        if (updateState == null) {
            throw new ApiException("Missing the required parameter 'updateState' when calling updateArtifactState(Async)");
        }

        return updateArtifactStateCall(groupId, artifactId, updateState, _callback);

    }

    /**
     * Update artifact state
     * Updates the state of the artifact.  For example, you can use this to mark the latest version of an artifact as &#x60;DEPRECATED&#x60;. The operation changes the state of the latest version of the artifact, even if this version is &#x60;DISABLED&#x60;. If multiple versions exist, only the most recent is changed.  This operation can fail for the following reasons:  * No artifact with this &#x60;artifactId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param updateState  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned when the operation was successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Common response for all operations that can return a &#x60;400&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public void updateArtifactState(String groupId, String artifactId, UpdateState updateState) throws ApiException {
        updateArtifactStateWithHttpInfo(groupId, artifactId, updateState);
    }

    /**
     * Update artifact state
     * Updates the state of the artifact.  For example, you can use this to mark the latest version of an artifact as &#x60;DEPRECATED&#x60;. The operation changes the state of the latest version of the artifact, even if this version is &#x60;DISABLED&#x60;. If multiple versions exist, only the most recent is changed.  This operation can fail for the following reasons:  * No artifact with this &#x60;artifactId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param updateState  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned when the operation was successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Common response for all operations that can return a &#x60;400&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> updateArtifactStateWithHttpInfo(String groupId, String artifactId, UpdateState updateState) throws ApiException {
        okhttp3.Call localVarCall = updateArtifactStateValidateBeforeCall(groupId, artifactId, updateState, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update artifact state (asynchronously)
     * Updates the state of the artifact.  For example, you can use this to mark the latest version of an artifact as &#x60;DEPRECATED&#x60;. The operation changes the state of the latest version of the artifact, even if this version is &#x60;DISABLED&#x60;. If multiple versions exist, only the most recent is changed.  This operation can fail for the following reasons:  * No artifact with this &#x60;artifactId&#x60; exists (HTTP error &#x60;404&#x60;) * A server error occurred (HTTP error &#x60;500&#x60;) 
     * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. (required)
     * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. (required)
     * @param updateState  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned when the operation was successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Common response for all operations that can return a &#x60;400&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Common response for all operations that can return a &#x60;404&#x60; error. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Common response for all operations that can fail with an unexpected server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateArtifactStateAsync(String groupId, String artifactId, UpdateState updateState, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateArtifactStateValidateBeforeCall(groupId, artifactId, updateState, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
