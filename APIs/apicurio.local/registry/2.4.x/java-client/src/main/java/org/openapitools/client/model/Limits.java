/*
 * Apicurio Registry API [v2]
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v2` by default. Therefore you must prefix all API operation paths with `../apis/registry/v2` in this case. For example: `../apis/registry/v2/ids/globalIds/{globalId}`. 
 *
 * The version of the OpenAPI document: 2.4.x
 * Contact: apicurio@lists.jboss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * List of limitations on used resources, that are applied on the current instance of Registry. Keys represent the resource type and are suffixed by the corresponding unit. Values are integers. Only non-negative values are allowed, with the exception of -1, which means that the limit is not applied.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:29:28.619448-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Limits {
  public static final String SERIALIZED_NAME_MAX_ARTIFACT_DESCRIPTION_LENGTH_CHARS = "maxArtifactDescriptionLengthChars";
  @SerializedName(SERIALIZED_NAME_MAX_ARTIFACT_DESCRIPTION_LENGTH_CHARS)
  private Long maxArtifactDescriptionLengthChars;

  public static final String SERIALIZED_NAME_MAX_ARTIFACT_LABELS_COUNT = "maxArtifactLabelsCount";
  @SerializedName(SERIALIZED_NAME_MAX_ARTIFACT_LABELS_COUNT)
  private Long maxArtifactLabelsCount;

  public static final String SERIALIZED_NAME_MAX_ARTIFACT_NAME_LENGTH_CHARS = "maxArtifactNameLengthChars";
  @SerializedName(SERIALIZED_NAME_MAX_ARTIFACT_NAME_LENGTH_CHARS)
  private Long maxArtifactNameLengthChars;

  public static final String SERIALIZED_NAME_MAX_ARTIFACT_PROPERTIES_COUNT = "maxArtifactPropertiesCount";
  @SerializedName(SERIALIZED_NAME_MAX_ARTIFACT_PROPERTIES_COUNT)
  private Long maxArtifactPropertiesCount;

  public static final String SERIALIZED_NAME_MAX_ARTIFACTS_COUNT = "maxArtifactsCount";
  @SerializedName(SERIALIZED_NAME_MAX_ARTIFACTS_COUNT)
  private Long maxArtifactsCount;

  public static final String SERIALIZED_NAME_MAX_LABEL_SIZE_BYTES = "maxLabelSizeBytes";
  @SerializedName(SERIALIZED_NAME_MAX_LABEL_SIZE_BYTES)
  private Long maxLabelSizeBytes;

  public static final String SERIALIZED_NAME_MAX_PROPERTY_KEY_SIZE_BYTES = "maxPropertyKeySizeBytes";
  @SerializedName(SERIALIZED_NAME_MAX_PROPERTY_KEY_SIZE_BYTES)
  private Long maxPropertyKeySizeBytes;

  public static final String SERIALIZED_NAME_MAX_PROPERTY_VALUE_SIZE_BYTES = "maxPropertyValueSizeBytes";
  @SerializedName(SERIALIZED_NAME_MAX_PROPERTY_VALUE_SIZE_BYTES)
  private Long maxPropertyValueSizeBytes;

  public static final String SERIALIZED_NAME_MAX_REQUESTS_PER_SECOND_COUNT = "maxRequestsPerSecondCount";
  @SerializedName(SERIALIZED_NAME_MAX_REQUESTS_PER_SECOND_COUNT)
  private Long maxRequestsPerSecondCount;

  public static final String SERIALIZED_NAME_MAX_SCHEMA_SIZE_BYTES = "maxSchemaSizeBytes";
  @SerializedName(SERIALIZED_NAME_MAX_SCHEMA_SIZE_BYTES)
  private Long maxSchemaSizeBytes;

  public static final String SERIALIZED_NAME_MAX_TOTAL_SCHEMAS_COUNT = "maxTotalSchemasCount";
  @SerializedName(SERIALIZED_NAME_MAX_TOTAL_SCHEMAS_COUNT)
  private Long maxTotalSchemasCount;

  public static final String SERIALIZED_NAME_MAX_VERSIONS_PER_ARTIFACT_COUNT = "maxVersionsPerArtifactCount";
  @SerializedName(SERIALIZED_NAME_MAX_VERSIONS_PER_ARTIFACT_COUNT)
  private Long maxVersionsPerArtifactCount;

  public Limits() {
  }

  public Limits maxArtifactDescriptionLengthChars(Long maxArtifactDescriptionLengthChars) {
    this.maxArtifactDescriptionLengthChars = maxArtifactDescriptionLengthChars;
    return this;
  }

  /**
   * Get maxArtifactDescriptionLengthChars
   * @return maxArtifactDescriptionLengthChars
   */
  @javax.annotation.Nullable
  public Long getMaxArtifactDescriptionLengthChars() {
    return maxArtifactDescriptionLengthChars;
  }

  public void setMaxArtifactDescriptionLengthChars(Long maxArtifactDescriptionLengthChars) {
    this.maxArtifactDescriptionLengthChars = maxArtifactDescriptionLengthChars;
  }


  public Limits maxArtifactLabelsCount(Long maxArtifactLabelsCount) {
    this.maxArtifactLabelsCount = maxArtifactLabelsCount;
    return this;
  }

  /**
   * Get maxArtifactLabelsCount
   * @return maxArtifactLabelsCount
   */
  @javax.annotation.Nullable
  public Long getMaxArtifactLabelsCount() {
    return maxArtifactLabelsCount;
  }

  public void setMaxArtifactLabelsCount(Long maxArtifactLabelsCount) {
    this.maxArtifactLabelsCount = maxArtifactLabelsCount;
  }


  public Limits maxArtifactNameLengthChars(Long maxArtifactNameLengthChars) {
    this.maxArtifactNameLengthChars = maxArtifactNameLengthChars;
    return this;
  }

  /**
   * Get maxArtifactNameLengthChars
   * @return maxArtifactNameLengthChars
   */
  @javax.annotation.Nullable
  public Long getMaxArtifactNameLengthChars() {
    return maxArtifactNameLengthChars;
  }

  public void setMaxArtifactNameLengthChars(Long maxArtifactNameLengthChars) {
    this.maxArtifactNameLengthChars = maxArtifactNameLengthChars;
  }


  public Limits maxArtifactPropertiesCount(Long maxArtifactPropertiesCount) {
    this.maxArtifactPropertiesCount = maxArtifactPropertiesCount;
    return this;
  }

  /**
   * Get maxArtifactPropertiesCount
   * @return maxArtifactPropertiesCount
   */
  @javax.annotation.Nullable
  public Long getMaxArtifactPropertiesCount() {
    return maxArtifactPropertiesCount;
  }

  public void setMaxArtifactPropertiesCount(Long maxArtifactPropertiesCount) {
    this.maxArtifactPropertiesCount = maxArtifactPropertiesCount;
  }


  public Limits maxArtifactsCount(Long maxArtifactsCount) {
    this.maxArtifactsCount = maxArtifactsCount;
    return this;
  }

  /**
   * Get maxArtifactsCount
   * @return maxArtifactsCount
   */
  @javax.annotation.Nullable
  public Long getMaxArtifactsCount() {
    return maxArtifactsCount;
  }

  public void setMaxArtifactsCount(Long maxArtifactsCount) {
    this.maxArtifactsCount = maxArtifactsCount;
  }


  public Limits maxLabelSizeBytes(Long maxLabelSizeBytes) {
    this.maxLabelSizeBytes = maxLabelSizeBytes;
    return this;
  }

  /**
   * Get maxLabelSizeBytes
   * @return maxLabelSizeBytes
   */
  @javax.annotation.Nullable
  public Long getMaxLabelSizeBytes() {
    return maxLabelSizeBytes;
  }

  public void setMaxLabelSizeBytes(Long maxLabelSizeBytes) {
    this.maxLabelSizeBytes = maxLabelSizeBytes;
  }


  public Limits maxPropertyKeySizeBytes(Long maxPropertyKeySizeBytes) {
    this.maxPropertyKeySizeBytes = maxPropertyKeySizeBytes;
    return this;
  }

  /**
   * Get maxPropertyKeySizeBytes
   * @return maxPropertyKeySizeBytes
   */
  @javax.annotation.Nullable
  public Long getMaxPropertyKeySizeBytes() {
    return maxPropertyKeySizeBytes;
  }

  public void setMaxPropertyKeySizeBytes(Long maxPropertyKeySizeBytes) {
    this.maxPropertyKeySizeBytes = maxPropertyKeySizeBytes;
  }


  public Limits maxPropertyValueSizeBytes(Long maxPropertyValueSizeBytes) {
    this.maxPropertyValueSizeBytes = maxPropertyValueSizeBytes;
    return this;
  }

  /**
   * Get maxPropertyValueSizeBytes
   * @return maxPropertyValueSizeBytes
   */
  @javax.annotation.Nullable
  public Long getMaxPropertyValueSizeBytes() {
    return maxPropertyValueSizeBytes;
  }

  public void setMaxPropertyValueSizeBytes(Long maxPropertyValueSizeBytes) {
    this.maxPropertyValueSizeBytes = maxPropertyValueSizeBytes;
  }


  public Limits maxRequestsPerSecondCount(Long maxRequestsPerSecondCount) {
    this.maxRequestsPerSecondCount = maxRequestsPerSecondCount;
    return this;
  }

  /**
   * Get maxRequestsPerSecondCount
   * @return maxRequestsPerSecondCount
   */
  @javax.annotation.Nullable
  public Long getMaxRequestsPerSecondCount() {
    return maxRequestsPerSecondCount;
  }

  public void setMaxRequestsPerSecondCount(Long maxRequestsPerSecondCount) {
    this.maxRequestsPerSecondCount = maxRequestsPerSecondCount;
  }


  public Limits maxSchemaSizeBytes(Long maxSchemaSizeBytes) {
    this.maxSchemaSizeBytes = maxSchemaSizeBytes;
    return this;
  }

  /**
   * Get maxSchemaSizeBytes
   * @return maxSchemaSizeBytes
   */
  @javax.annotation.Nullable
  public Long getMaxSchemaSizeBytes() {
    return maxSchemaSizeBytes;
  }

  public void setMaxSchemaSizeBytes(Long maxSchemaSizeBytes) {
    this.maxSchemaSizeBytes = maxSchemaSizeBytes;
  }


  public Limits maxTotalSchemasCount(Long maxTotalSchemasCount) {
    this.maxTotalSchemasCount = maxTotalSchemasCount;
    return this;
  }

  /**
   * Get maxTotalSchemasCount
   * @return maxTotalSchemasCount
   */
  @javax.annotation.Nullable
  public Long getMaxTotalSchemasCount() {
    return maxTotalSchemasCount;
  }

  public void setMaxTotalSchemasCount(Long maxTotalSchemasCount) {
    this.maxTotalSchemasCount = maxTotalSchemasCount;
  }


  public Limits maxVersionsPerArtifactCount(Long maxVersionsPerArtifactCount) {
    this.maxVersionsPerArtifactCount = maxVersionsPerArtifactCount;
    return this;
  }

  /**
   * Get maxVersionsPerArtifactCount
   * @return maxVersionsPerArtifactCount
   */
  @javax.annotation.Nullable
  public Long getMaxVersionsPerArtifactCount() {
    return maxVersionsPerArtifactCount;
  }

  public void setMaxVersionsPerArtifactCount(Long maxVersionsPerArtifactCount) {
    this.maxVersionsPerArtifactCount = maxVersionsPerArtifactCount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Limits limits = (Limits) o;
    return Objects.equals(this.maxArtifactDescriptionLengthChars, limits.maxArtifactDescriptionLengthChars) &&
        Objects.equals(this.maxArtifactLabelsCount, limits.maxArtifactLabelsCount) &&
        Objects.equals(this.maxArtifactNameLengthChars, limits.maxArtifactNameLengthChars) &&
        Objects.equals(this.maxArtifactPropertiesCount, limits.maxArtifactPropertiesCount) &&
        Objects.equals(this.maxArtifactsCount, limits.maxArtifactsCount) &&
        Objects.equals(this.maxLabelSizeBytes, limits.maxLabelSizeBytes) &&
        Objects.equals(this.maxPropertyKeySizeBytes, limits.maxPropertyKeySizeBytes) &&
        Objects.equals(this.maxPropertyValueSizeBytes, limits.maxPropertyValueSizeBytes) &&
        Objects.equals(this.maxRequestsPerSecondCount, limits.maxRequestsPerSecondCount) &&
        Objects.equals(this.maxSchemaSizeBytes, limits.maxSchemaSizeBytes) &&
        Objects.equals(this.maxTotalSchemasCount, limits.maxTotalSchemasCount) &&
        Objects.equals(this.maxVersionsPerArtifactCount, limits.maxVersionsPerArtifactCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxArtifactDescriptionLengthChars, maxArtifactLabelsCount, maxArtifactNameLengthChars, maxArtifactPropertiesCount, maxArtifactsCount, maxLabelSizeBytes, maxPropertyKeySizeBytes, maxPropertyValueSizeBytes, maxRequestsPerSecondCount, maxSchemaSizeBytes, maxTotalSchemasCount, maxVersionsPerArtifactCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Limits {\n");
    sb.append("    maxArtifactDescriptionLengthChars: ").append(toIndentedString(maxArtifactDescriptionLengthChars)).append("\n");
    sb.append("    maxArtifactLabelsCount: ").append(toIndentedString(maxArtifactLabelsCount)).append("\n");
    sb.append("    maxArtifactNameLengthChars: ").append(toIndentedString(maxArtifactNameLengthChars)).append("\n");
    sb.append("    maxArtifactPropertiesCount: ").append(toIndentedString(maxArtifactPropertiesCount)).append("\n");
    sb.append("    maxArtifactsCount: ").append(toIndentedString(maxArtifactsCount)).append("\n");
    sb.append("    maxLabelSizeBytes: ").append(toIndentedString(maxLabelSizeBytes)).append("\n");
    sb.append("    maxPropertyKeySizeBytes: ").append(toIndentedString(maxPropertyKeySizeBytes)).append("\n");
    sb.append("    maxPropertyValueSizeBytes: ").append(toIndentedString(maxPropertyValueSizeBytes)).append("\n");
    sb.append("    maxRequestsPerSecondCount: ").append(toIndentedString(maxRequestsPerSecondCount)).append("\n");
    sb.append("    maxSchemaSizeBytes: ").append(toIndentedString(maxSchemaSizeBytes)).append("\n");
    sb.append("    maxTotalSchemasCount: ").append(toIndentedString(maxTotalSchemasCount)).append("\n");
    sb.append("    maxVersionsPerArtifactCount: ").append(toIndentedString(maxVersionsPerArtifactCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("maxArtifactDescriptionLengthChars");
    openapiFields.add("maxArtifactLabelsCount");
    openapiFields.add("maxArtifactNameLengthChars");
    openapiFields.add("maxArtifactPropertiesCount");
    openapiFields.add("maxArtifactsCount");
    openapiFields.add("maxLabelSizeBytes");
    openapiFields.add("maxPropertyKeySizeBytes");
    openapiFields.add("maxPropertyValueSizeBytes");
    openapiFields.add("maxRequestsPerSecondCount");
    openapiFields.add("maxSchemaSizeBytes");
    openapiFields.add("maxTotalSchemasCount");
    openapiFields.add("maxVersionsPerArtifactCount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Limits
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Limits.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Limits is not found in the empty JSON string", Limits.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Limits.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Limits` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Limits.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Limits' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Limits> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Limits.class));

       return (TypeAdapter<T>) new TypeAdapter<Limits>() {
           @Override
           public void write(JsonWriter out, Limits value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Limits read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Limits given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Limits
   * @throws IOException if the JSON string is invalid with respect to Limits
   */
  public static Limits fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Limits.class);
  }

  /**
   * Convert an instance of Limits to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

