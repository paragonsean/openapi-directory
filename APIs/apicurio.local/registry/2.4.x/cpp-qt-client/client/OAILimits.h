/**
 * Apicurio Registry API [v2]
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v2` by default. Therefore you must prefix all API operation paths with `../apis/registry/v2` in this case. For example: `../apis/registry/v2/ids/globalIds/{globalId}`. 
 *
 * The version of the OpenAPI document: 2.4.x
 * Contact: apicurio@lists.jboss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * OAILimits.h
 *
 * List of limitations on used resources, that are applied on the current instance of Registry. Keys represent the resource type and are suffixed by the corresponding unit. Values are integers. Only non-negative values are allowed, with the exception of -1, which means that the limit is not applied.
 */

#ifndef OAILimits_H
#define OAILimits_H

#include <QJsonObject>


#include "OAIEnum.h"
#include "OAIObject.h"

namespace OpenAPI {

class OAILimits : public OAIObject {
public:
    OAILimits();
    OAILimits(QString json);
    ~OAILimits() override;

    QString asJson() const override;
    QJsonObject asJsonObject() const override;
    void fromJsonObject(QJsonObject json) override;
    void fromJson(QString jsonString) override;

    qint64 getMaxArtifactDescriptionLengthChars() const;
    void setMaxArtifactDescriptionLengthChars(const qint64 &max_artifact_description_length_chars);
    bool is_max_artifact_description_length_chars_Set() const;
    bool is_max_artifact_description_length_chars_Valid() const;

    qint64 getMaxArtifactLabelsCount() const;
    void setMaxArtifactLabelsCount(const qint64 &max_artifact_labels_count);
    bool is_max_artifact_labels_count_Set() const;
    bool is_max_artifact_labels_count_Valid() const;

    qint64 getMaxArtifactNameLengthChars() const;
    void setMaxArtifactNameLengthChars(const qint64 &max_artifact_name_length_chars);
    bool is_max_artifact_name_length_chars_Set() const;
    bool is_max_artifact_name_length_chars_Valid() const;

    qint64 getMaxArtifactPropertiesCount() const;
    void setMaxArtifactPropertiesCount(const qint64 &max_artifact_properties_count);
    bool is_max_artifact_properties_count_Set() const;
    bool is_max_artifact_properties_count_Valid() const;

    qint64 getMaxArtifactsCount() const;
    void setMaxArtifactsCount(const qint64 &max_artifacts_count);
    bool is_max_artifacts_count_Set() const;
    bool is_max_artifacts_count_Valid() const;

    qint64 getMaxLabelSizeBytes() const;
    void setMaxLabelSizeBytes(const qint64 &max_label_size_bytes);
    bool is_max_label_size_bytes_Set() const;
    bool is_max_label_size_bytes_Valid() const;

    qint64 getMaxPropertyKeySizeBytes() const;
    void setMaxPropertyKeySizeBytes(const qint64 &max_property_key_size_bytes);
    bool is_max_property_key_size_bytes_Set() const;
    bool is_max_property_key_size_bytes_Valid() const;

    qint64 getMaxPropertyValueSizeBytes() const;
    void setMaxPropertyValueSizeBytes(const qint64 &max_property_value_size_bytes);
    bool is_max_property_value_size_bytes_Set() const;
    bool is_max_property_value_size_bytes_Valid() const;

    qint64 getMaxRequestsPerSecondCount() const;
    void setMaxRequestsPerSecondCount(const qint64 &max_requests_per_second_count);
    bool is_max_requests_per_second_count_Set() const;
    bool is_max_requests_per_second_count_Valid() const;

    qint64 getMaxSchemaSizeBytes() const;
    void setMaxSchemaSizeBytes(const qint64 &max_schema_size_bytes);
    bool is_max_schema_size_bytes_Set() const;
    bool is_max_schema_size_bytes_Valid() const;

    qint64 getMaxTotalSchemasCount() const;
    void setMaxTotalSchemasCount(const qint64 &max_total_schemas_count);
    bool is_max_total_schemas_count_Set() const;
    bool is_max_total_schemas_count_Valid() const;

    qint64 getMaxVersionsPerArtifactCount() const;
    void setMaxVersionsPerArtifactCount(const qint64 &max_versions_per_artifact_count);
    bool is_max_versions_per_artifact_count_Set() const;
    bool is_max_versions_per_artifact_count_Valid() const;

    virtual bool isSet() const override;
    virtual bool isValid() const override;

private:
    void initializeModel();

    qint64 m_max_artifact_description_length_chars;
    bool m_max_artifact_description_length_chars_isSet;
    bool m_max_artifact_description_length_chars_isValid;

    qint64 m_max_artifact_labels_count;
    bool m_max_artifact_labels_count_isSet;
    bool m_max_artifact_labels_count_isValid;

    qint64 m_max_artifact_name_length_chars;
    bool m_max_artifact_name_length_chars_isSet;
    bool m_max_artifact_name_length_chars_isValid;

    qint64 m_max_artifact_properties_count;
    bool m_max_artifact_properties_count_isSet;
    bool m_max_artifact_properties_count_isValid;

    qint64 m_max_artifacts_count;
    bool m_max_artifacts_count_isSet;
    bool m_max_artifacts_count_isValid;

    qint64 m_max_label_size_bytes;
    bool m_max_label_size_bytes_isSet;
    bool m_max_label_size_bytes_isValid;

    qint64 m_max_property_key_size_bytes;
    bool m_max_property_key_size_bytes_isSet;
    bool m_max_property_key_size_bytes_isValid;

    qint64 m_max_property_value_size_bytes;
    bool m_max_property_value_size_bytes_isSet;
    bool m_max_property_value_size_bytes_isValid;

    qint64 m_max_requests_per_second_count;
    bool m_max_requests_per_second_count_isSet;
    bool m_max_requests_per_second_count_isValid;

    qint64 m_max_schema_size_bytes;
    bool m_max_schema_size_bytes_isSet;
    bool m_max_schema_size_bytes_isValid;

    qint64 m_max_total_schemas_count;
    bool m_max_total_schemas_count_isSet;
    bool m_max_total_schemas_count_isValid;

    qint64 m_max_versions_per_artifact_count;
    bool m_max_versions_per_artifact_count_isSet;
    bool m_max_versions_per_artifact_count_isValid;
};

} // namespace OpenAPI

Q_DECLARE_METATYPE(OpenAPI::OAILimits)

#endif // OAILimits_H
