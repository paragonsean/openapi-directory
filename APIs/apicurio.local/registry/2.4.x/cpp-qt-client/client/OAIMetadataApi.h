/**
 * Apicurio Registry API [v2]
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v2` by default. Therefore you must prefix all API operation paths with `../apis/registry/v2` in this case. For example: `../apis/registry/v2/ids/globalIds/{globalId}`. 
 *
 * The version of the OpenAPI document: 2.4.x
 * Contact: apicurio@lists.jboss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAIMetadataApi_H
#define OAI_OAIMetadataApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include "OAIArtifactContent.h"
#include "OAIArtifactMetaData.h"
#include "OAIArtifactOwner.h"
#include "OAIEditableMetaData.h"
#include "OAIError.h"
#include "OAIHttpFileElement.h"
#include "OAIVersionMetaData.h"
#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAIMetadataApi : public QObject {
    Q_OBJECT

public:
    OAIMetadataApi(const int timeOut = 0);
    ~OAIMetadataApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);

    /**
    * @param[in]  group_id QString [required]
    * @param[in]  artifact_id QString [required]
    * @param[in]  version QString [required]
    */
    virtual void deleteArtifactVersionMetaData(const QString &group_id, const QString &artifact_id, const QString &version);

    /**
    * @param[in]  group_id QString [required]
    * @param[in]  artifact_id QString [required]
    */
    virtual void getArtifactMetaData(const QString &group_id, const QString &artifact_id);

    /**
    * @param[in]  group_id QString [required]
    * @param[in]  artifact_id QString [required]
    */
    virtual void getArtifactOwner(const QString &group_id, const QString &artifact_id);

    /**
    * @param[in]  group_id QString [required]
    * @param[in]  artifact_id QString [required]
    * @param[in]  version QString [required]
    */
    virtual void getArtifactVersionMetaData(const QString &group_id, const QString &artifact_id, const QString &version);

    /**
    * @param[in]  group_id QString [required]
    * @param[in]  artifact_id QString [required]
    * @param[in]  body OAIHttpFileElement [required]
    * @param[in]  canonical bool [optional]
    */
    virtual void getArtifactVersionMetaDataByContent(const QString &group_id, const QString &artifact_id, const OAIHttpFileElement &body, const ::OpenAPI::OptionalParam<bool> &canonical = ::OpenAPI::OptionalParam<bool>());

    /**
    * @param[in]  group_id QString [required]
    * @param[in]  artifact_id QString [required]
    * @param[in]  oai_editable_meta_data OAIEditableMetaData [required]
    */
    virtual void updateArtifactMetaData(const QString &group_id, const QString &artifact_id, const OAIEditableMetaData &oai_editable_meta_data);

    /**
    * @param[in]  group_id QString [required]
    * @param[in]  artifact_id QString [required]
    * @param[in]  oai_artifact_owner OAIArtifactOwner [required]
    */
    virtual void updateArtifactOwner(const QString &group_id, const QString &artifact_id, const OAIArtifactOwner &oai_artifact_owner);

    /**
    * @param[in]  group_id QString [required]
    * @param[in]  artifact_id QString [required]
    * @param[in]  version QString [required]
    * @param[in]  oai_editable_meta_data OAIEditableMetaData [required]
    */
    virtual void updateArtifactVersionMetaData(const QString &group_id, const QString &artifact_id, const QString &version, const OAIEditableMetaData &oai_editable_meta_data);


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void deleteArtifactVersionMetaDataCallback(OAIHttpRequestWorker *worker);
    void getArtifactMetaDataCallback(OAIHttpRequestWorker *worker);
    void getArtifactOwnerCallback(OAIHttpRequestWorker *worker);
    void getArtifactVersionMetaDataCallback(OAIHttpRequestWorker *worker);
    void getArtifactVersionMetaDataByContentCallback(OAIHttpRequestWorker *worker);
    void updateArtifactMetaDataCallback(OAIHttpRequestWorker *worker);
    void updateArtifactOwnerCallback(OAIHttpRequestWorker *worker);
    void updateArtifactVersionMetaDataCallback(OAIHttpRequestWorker *worker);

Q_SIGNALS:

    void deleteArtifactVersionMetaDataSignal();
    void getArtifactMetaDataSignal(OAIArtifactMetaData summary);
    void getArtifactOwnerSignal(OAIArtifactOwner summary);
    void getArtifactVersionMetaDataSignal(OAIVersionMetaData summary);
    void getArtifactVersionMetaDataByContentSignal(OAIVersionMetaData summary);
    void updateArtifactMetaDataSignal();
    void updateArtifactOwnerSignal();
    void updateArtifactVersionMetaDataSignal();


    void deleteArtifactVersionMetaDataSignalFull(OAIHttpRequestWorker *worker);
    void getArtifactMetaDataSignalFull(OAIHttpRequestWorker *worker, OAIArtifactMetaData summary);
    void getArtifactOwnerSignalFull(OAIHttpRequestWorker *worker, OAIArtifactOwner summary);
    void getArtifactVersionMetaDataSignalFull(OAIHttpRequestWorker *worker, OAIVersionMetaData summary);
    void getArtifactVersionMetaDataByContentSignalFull(OAIHttpRequestWorker *worker, OAIVersionMetaData summary);
    void updateArtifactMetaDataSignalFull(OAIHttpRequestWorker *worker);
    void updateArtifactOwnerSignalFull(OAIHttpRequestWorker *worker);
    void updateArtifactVersionMetaDataSignalFull(OAIHttpRequestWorker *worker);

    Q_DECL_DEPRECATED_X("Use deleteArtifactVersionMetaDataSignalError() instead")
    void deleteArtifactVersionMetaDataSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void deleteArtifactVersionMetaDataSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArtifactMetaDataSignalError() instead")
    void getArtifactMetaDataSignalE(OAIArtifactMetaData summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getArtifactMetaDataSignalError(OAIArtifactMetaData summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArtifactOwnerSignalError() instead")
    void getArtifactOwnerSignalE(OAIArtifactOwner summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getArtifactOwnerSignalError(OAIArtifactOwner summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArtifactVersionMetaDataSignalError() instead")
    void getArtifactVersionMetaDataSignalE(OAIVersionMetaData summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getArtifactVersionMetaDataSignalError(OAIVersionMetaData summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArtifactVersionMetaDataByContentSignalError() instead")
    void getArtifactVersionMetaDataByContentSignalE(OAIVersionMetaData summary, QNetworkReply::NetworkError error_type, QString error_str);
    void getArtifactVersionMetaDataByContentSignalError(OAIVersionMetaData summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use updateArtifactMetaDataSignalError() instead")
    void updateArtifactMetaDataSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void updateArtifactMetaDataSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use updateArtifactOwnerSignalError() instead")
    void updateArtifactOwnerSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void updateArtifactOwnerSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use updateArtifactVersionMetaDataSignalError() instead")
    void updateArtifactVersionMetaDataSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void updateArtifactVersionMetaDataSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);

    Q_DECL_DEPRECATED_X("Use deleteArtifactVersionMetaDataSignalErrorFull() instead")
    void deleteArtifactVersionMetaDataSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void deleteArtifactVersionMetaDataSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArtifactMetaDataSignalErrorFull() instead")
    void getArtifactMetaDataSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getArtifactMetaDataSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArtifactOwnerSignalErrorFull() instead")
    void getArtifactOwnerSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getArtifactOwnerSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArtifactVersionMetaDataSignalErrorFull() instead")
    void getArtifactVersionMetaDataSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getArtifactVersionMetaDataSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use getArtifactVersionMetaDataByContentSignalErrorFull() instead")
    void getArtifactVersionMetaDataByContentSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void getArtifactVersionMetaDataByContentSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use updateArtifactMetaDataSignalErrorFull() instead")
    void updateArtifactMetaDataSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void updateArtifactMetaDataSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use updateArtifactOwnerSignalErrorFull() instead")
    void updateArtifactOwnerSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void updateArtifactOwnerSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use updateArtifactVersionMetaDataSignalErrorFull() instead")
    void updateArtifactVersionMetaDataSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void updateArtifactVersionMetaDataSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public Q_SLOTS:
    void tokenAvailable();
};

} // namespace OpenAPI
#endif
