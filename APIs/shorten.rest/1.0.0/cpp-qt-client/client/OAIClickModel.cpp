/**
 * Shorten.REST API Documentation
 * ## Introduction   The Shorten.rest API allows you to programmatically create short URLs (an &apos;alias&apos;) for longer URL (a &apos;destination&apos;).  Each alias you create can be used to redirect the end user (person clicking on the link) to one or more destination URLs  A default destination is always set and specific destinations can be set to redirect the end user to preferred destinations based on the user&apos;s geographical location (country) and device Operating System.  In order to use the Shorten.Rest URL Shortening API you can choose to bind your own branded domain, sub-domain or to use our default domain - Short.FYI    ### Destination Matching    When creating or editing a short URL (&apos;alias&apos;) you can choose to specify a destination for each country and OS ([Supported OSes list](#tag/OperatingSystems)) combination.    When a user clicks on the short link, Shorten.rest will examine the end user's country (determined by User's IP) and OS (User agent) and match the most suitable destination for each user.    (*) If no destination is set for a specific request combination Shorten.rest will use the default destination that exists within each short URL    (**) BRANDED DOMAINS: If the requested alias does not exist in our database - Shorten.rest will redirect the user to the default fallback you set within your dashboard under the ‘Alias Not Found Page Url’ value for a custom domain.    (***) Operating System (OS) destinations are stronger than a country destination!   For example - if you have a custom landing page that is targeting people in the USA and a second landing page that is hyper focused for people who use iOS devices - a person clicking on your link in the USA that is on an iPhone will be redirected to the iOS landing page, while all other devices will be redirected to the USA landing page.    | OS  | Country  | Destination | | :------------: |:---------------:| -----| | iOS      |  | YourDestination.com/ios | |       | US        |   YourDestination.com/usa |    Shorten.rest will choose the YourDestination.com/ios url as the most suitable destination.   ### Branded Domain Attributes    When setting up your custom domain you can include optional metatags and snippets ([Supported snippets list](#tag/Snippets)). These parameters (such as retargeting, tracking and conversion pixels) are populated and fired on click - at the time of the redirect.    By default the parameters you set in the domain setting will be included in all Short URLs associated with that domain.    You can always override the domain defaults for each URL by passing the appropriate variables when creating or updating a short URL    ### Setting a Custom string for an Alias (short.fyi/alias)    While creating a short URL you can specify which domain to use. You can choose to use your own branded domain or our default domain - Short.fyi.    Each Alias is unique within a domain they are related to. This means that if multiple accounts use you the same domain (for example short.fyi), if an alias is already taken you may not create a new destination for it.   That said - If you would like to use a specific alias which is already taken - the only way to do so is to create it on a new domain you own and have attached to your Shorten.rest account.    ### Random Aliases    By default - unless you specify a vanity URI for your alias each URL that is shortened on our platform will have a random string generated by the API. This means that if the &apos;alias&apos; attribute of a /aliases POST request is not provided, or is an empty string, a random string of seven characters will be generated and returned as part of the POST response.    You can also place the @**rnd** macro within the alias field when you create a new alias, for example /vanity/@rnd, which might return an alias like /vanity/ZMAefRt, or /vanity@rnd, which might produce something like /vanityMRtvxadf. Only the first @rnd in an alias attribute will be replaced.    ### NOTES    ( * ) All methods of the Shorten.REST API require that your API key be provided in **x-api-key** header.    (**) All API parameters are case sensitive
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIClickModel.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIClickModel::OAIClickModel(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIClickModel::OAIClickModel() {
    this->initializeModel();
}

OAIClickModel::~OAIClickModel() {}

void OAIClickModel::initializeModel() {

    m_alias_isSet = false;
    m_alias_isValid = false;

    m_alias_id_isSet = false;
    m_alias_id_isValid = false;

    m_browser_isSet = false;
    m_browser_isValid = false;

    m_country_isSet = false;
    m_country_isValid = false;

    m_created_at_isSet = false;
    m_created_at_isValid = false;

    m_destination_isSet = false;
    m_destination_isValid = false;

    m_domain_isSet = false;
    m_domain_isValid = false;

    m_os_isSet = false;
    m_os_isValid = false;

    m_referrer_isSet = false;
    m_referrer_isValid = false;

    m_user_agent_isSet = false;
    m_user_agent_isValid = false;
}

void OAIClickModel::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIClickModel::fromJsonObject(QJsonObject json) {

    m_alias_isValid = ::OpenAPI::fromJsonValue(m_alias, json[QString("alias")]);
    m_alias_isSet = !json[QString("alias")].isNull() && m_alias_isValid;

    m_alias_id_isValid = ::OpenAPI::fromJsonValue(m_alias_id, json[QString("aliasId")]);
    m_alias_id_isSet = !json[QString("aliasId")].isNull() && m_alias_id_isValid;

    m_browser_isValid = ::OpenAPI::fromJsonValue(m_browser, json[QString("browser")]);
    m_browser_isSet = !json[QString("browser")].isNull() && m_browser_isValid;

    m_country_isValid = ::OpenAPI::fromJsonValue(m_country, json[QString("country")]);
    m_country_isSet = !json[QString("country")].isNull() && m_country_isValid;

    m_created_at_isValid = ::OpenAPI::fromJsonValue(m_created_at, json[QString("createdAt")]);
    m_created_at_isSet = !json[QString("createdAt")].isNull() && m_created_at_isValid;

    m_destination_isValid = ::OpenAPI::fromJsonValue(m_destination, json[QString("destination")]);
    m_destination_isSet = !json[QString("destination")].isNull() && m_destination_isValid;

    m_domain_isValid = ::OpenAPI::fromJsonValue(m_domain, json[QString("domain")]);
    m_domain_isSet = !json[QString("domain")].isNull() && m_domain_isValid;

    m_os_isValid = ::OpenAPI::fromJsonValue(m_os, json[QString("os")]);
    m_os_isSet = !json[QString("os")].isNull() && m_os_isValid;

    m_referrer_isValid = ::OpenAPI::fromJsonValue(m_referrer, json[QString("referrer")]);
    m_referrer_isSet = !json[QString("referrer")].isNull() && m_referrer_isValid;

    m_user_agent_isValid = ::OpenAPI::fromJsonValue(m_user_agent, json[QString("userAgent")]);
    m_user_agent_isSet = !json[QString("userAgent")].isNull() && m_user_agent_isValid;
}

QString OAIClickModel::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIClickModel::asJsonObject() const {
    QJsonObject obj;
    if (m_alias_isSet) {
        obj.insert(QString("alias"), ::OpenAPI::toJsonValue(m_alias));
    }
    if (m_alias_id_isSet) {
        obj.insert(QString("aliasId"), ::OpenAPI::toJsonValue(m_alias_id));
    }
    if (m_browser_isSet) {
        obj.insert(QString("browser"), ::OpenAPI::toJsonValue(m_browser));
    }
    if (m_country_isSet) {
        obj.insert(QString("country"), ::OpenAPI::toJsonValue(m_country));
    }
    if (m_created_at_isSet) {
        obj.insert(QString("createdAt"), ::OpenAPI::toJsonValue(m_created_at));
    }
    if (m_destination_isSet) {
        obj.insert(QString("destination"), ::OpenAPI::toJsonValue(m_destination));
    }
    if (m_domain_isSet) {
        obj.insert(QString("domain"), ::OpenAPI::toJsonValue(m_domain));
    }
    if (m_os_isSet) {
        obj.insert(QString("os"), ::OpenAPI::toJsonValue(m_os));
    }
    if (m_referrer_isSet) {
        obj.insert(QString("referrer"), ::OpenAPI::toJsonValue(m_referrer));
    }
    if (m_user_agent_isSet) {
        obj.insert(QString("userAgent"), ::OpenAPI::toJsonValue(m_user_agent));
    }
    return obj;
}

QString OAIClickModel::getAlias() const {
    return m_alias;
}
void OAIClickModel::setAlias(const QString &alias) {
    m_alias = alias;
    m_alias_isSet = true;
}

bool OAIClickModel::is_alias_Set() const{
    return m_alias_isSet;
}

bool OAIClickModel::is_alias_Valid() const{
    return m_alias_isValid;
}

QString OAIClickModel::getAliasId() const {
    return m_alias_id;
}
void OAIClickModel::setAliasId(const QString &alias_id) {
    m_alias_id = alias_id;
    m_alias_id_isSet = true;
}

bool OAIClickModel::is_alias_id_Set() const{
    return m_alias_id_isSet;
}

bool OAIClickModel::is_alias_id_Valid() const{
    return m_alias_id_isValid;
}

QString OAIClickModel::getBrowser() const {
    return m_browser;
}
void OAIClickModel::setBrowser(const QString &browser) {
    m_browser = browser;
    m_browser_isSet = true;
}

bool OAIClickModel::is_browser_Set() const{
    return m_browser_isSet;
}

bool OAIClickModel::is_browser_Valid() const{
    return m_browser_isValid;
}

QString OAIClickModel::getCountry() const {
    return m_country;
}
void OAIClickModel::setCountry(const QString &country) {
    m_country = country;
    m_country_isSet = true;
}

bool OAIClickModel::is_country_Set() const{
    return m_country_isSet;
}

bool OAIClickModel::is_country_Valid() const{
    return m_country_isValid;
}

qint64 OAIClickModel::getCreatedAt() const {
    return m_created_at;
}
void OAIClickModel::setCreatedAt(const qint64 &created_at) {
    m_created_at = created_at;
    m_created_at_isSet = true;
}

bool OAIClickModel::is_created_at_Set() const{
    return m_created_at_isSet;
}

bool OAIClickModel::is_created_at_Valid() const{
    return m_created_at_isValid;
}

QString OAIClickModel::getDestination() const {
    return m_destination;
}
void OAIClickModel::setDestination(const QString &destination) {
    m_destination = destination;
    m_destination_isSet = true;
}

bool OAIClickModel::is_destination_Set() const{
    return m_destination_isSet;
}

bool OAIClickModel::is_destination_Valid() const{
    return m_destination_isValid;
}

QString OAIClickModel::getDomain() const {
    return m_domain;
}
void OAIClickModel::setDomain(const QString &domain) {
    m_domain = domain;
    m_domain_isSet = true;
}

bool OAIClickModel::is_domain_Set() const{
    return m_domain_isSet;
}

bool OAIClickModel::is_domain_Valid() const{
    return m_domain_isValid;
}

QString OAIClickModel::getOs() const {
    return m_os;
}
void OAIClickModel::setOs(const QString &os) {
    m_os = os;
    m_os_isSet = true;
}

bool OAIClickModel::is_os_Set() const{
    return m_os_isSet;
}

bool OAIClickModel::is_os_Valid() const{
    return m_os_isValid;
}

QString OAIClickModel::getReferrer() const {
    return m_referrer;
}
void OAIClickModel::setReferrer(const QString &referrer) {
    m_referrer = referrer;
    m_referrer_isSet = true;
}

bool OAIClickModel::is_referrer_Set() const{
    return m_referrer_isSet;
}

bool OAIClickModel::is_referrer_Valid() const{
    return m_referrer_isValid;
}

QString OAIClickModel::getUserAgent() const {
    return m_user_agent;
}
void OAIClickModel::setUserAgent(const QString &user_agent) {
    m_user_agent = user_agent;
    m_user_agent_isSet = true;
}

bool OAIClickModel::is_user_agent_Set() const{
    return m_user_agent_isSet;
}

bool OAIClickModel::is_user_agent_Valid() const{
    return m_user_agent_isValid;
}

bool OAIClickModel::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_alias_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_alias_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_browser_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_country_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_destination_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_domain_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_os_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_referrer_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_agent_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIClickModel::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
