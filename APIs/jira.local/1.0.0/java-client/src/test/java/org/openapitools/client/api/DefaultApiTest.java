/*
 * JIRA 7.6.1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for DefaultApi
 */
@Disabled
public class DefaultApiTest {

    private final DefaultApi api = new DefaultApi();

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void acknowledgeErrorsTest() throws ApiException {
        api.acknowledgeErrors();
        // TODO: test validations
    }

    /**
     * Adds an actor (user or group) to a project role.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addActorUsersTest() throws ApiException {
        String projectIdOrKey = null;
        Long id = null;
        api.addActorUsers(projectIdOrKey, id);
        // TODO: test validations
    }

    /**
     * Add one or more attachments to an issue.  &lt;p&gt;  This resource expects a multipart post. The media-type multipart/form-data is defined in RFC 1867. Most client  libraries have classes that make dealing with multipart posts simple. For instance, in Java the Apache HTTP Components  library provides a  &lt;a href&#x3D;\&quot;http://hc.apache.org/httpcomponents-client-ga/httpmime/apidocs/org/apache/http/entity/mime/MultipartEntity.html\&quot;&gt;MultiPartEntity&lt;/a&gt;  that makes it simple to submit a multipart POST.  &lt;p&gt;  In order to protect against XSRF attacks, because this method accepts multipart/form-data, it has XSRF protection  on it.  This means you must submit a header of X-Atlassian-Token: no-check with the request, otherwise it will be  blocked.  &lt;p&gt;  The name of the multipart/form-data parameter that contains attachments must be \&quot;file\&quot;  &lt;p&gt;  A simple example to upload a file called \&quot;myfile.txt\&quot; to issue REST-123:  &lt;pre&gt;curl -D- -u admin:admin -X POST -H \&quot;X-Atlassian-Token: no-check\&quot; -F \&quot;file&#x3D;@myfile.txt\&quot; http://myhost/rest/api/2/issue/TEST-123/attachments&lt;/pre&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addAttachmentTest() throws ApiException {
        String issueIdOrKey = null;
        api.addAttachment(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Adds a new comment to an issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addCommentTest() throws ApiException {
        String issueIdOrKey = null;
        String expand = null;
        api.addComment(issueIdOrKey, expand);
        // TODO: test validations
    }

    /**
     * Adds field to the given tab.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addFieldTest() throws ApiException {
        Long screenId = null;
        Long tabId = null;
        api.addField(screenId, tabId);
        // TODO: test validations
    }

    /**
     * Adds field or custom field to the default tab
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addFieldToDefaultScreenTest() throws ApiException {
        String fieldId = null;
        api.addFieldToDefaultScreen(fieldId);
        // TODO: test validations
    }

    /**
     * Adds default actors to the given role. The request data should contain a list of usernames or a list of groups to add.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addProjectRoleActorsToRoleTest() throws ApiException {
        Long id = null;
        api.addProjectRoleActorsToRole(id);
        // TODO: test validations
    }

    /**
     * Store a record in Audit Log
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addRecordTest() throws ApiException {
        api.addRecord();
        // TODO: test validations
    }

    /**
     * Adds a share permissions to the given filter. Adding a global permission removes all previous permissions from the filter.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addSharePermissionTest() throws ApiException {
        Long id = null;
        api.addSharePermission(id);
        // TODO: test validations
    }

    /**
     * Creates tab for given screen
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addTabTest() throws ApiException {
        Long screenId = null;
        api.addTab(screenId);
        // TODO: test validations
    }

    /**
     * Add user to given application. Admin permission will be required to perform this operation.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addUserToApplicationTest() throws ApiException {
        String username = null;
        String applicationKey = null;
        api.addUserToApplication(username, applicationKey);
        // TODO: test validations
    }

    /**
     * Adds given user to a group.  &lt;p&gt;  Returns the current state of the group.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addUserToGroupTest() throws ApiException {
        String groupname = null;
        api.addUserToGroup(groupname);
        // TODO: test validations
    }

    /**
     * Cast your vote in favour of an issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addVoteTest() throws ApiException {
        String issueIdOrKey = null;
        api.addVote(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Adds a user to an issue&#39;s watcher list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addWatcherTest() throws ApiException {
        String issueIdOrKey = null;
        api.addWatcher(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Adds a new worklog entry to an issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addWorklogTest() throws ApiException {
        String issueIdOrKey = null;
        String adjustEstimate = null;
        String newEstimate = null;
        String reduceBy = null;
        api.addWorklog(issueIdOrKey, adjustEstimate, newEstimate, reduceBy);
        // TODO: test validations
    }

    /**
     * Returns an application property.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ApplicationPropertiesGetTest() throws ApiException {
        String key = null;
        String permissionLevel = null;
        String keyFilter = null;
        api.api2ApplicationPropertiesGet(key, permissionLevel, keyFilter);
        // TODO: test validations
    }

    /**
     * Updates the cropping instructions of the temporary avatar.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2AvatarTypeTemporaryCropPostTest() throws ApiException {
        String type = null;
        api.api2AvatarTypeTemporaryCropPost(type);
        // TODO: test validations
    }

    /**
     * Returns the keys of all properties for the comment identified by the key or by the id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2CommentCommentIdPropertiesGetTest() throws ApiException {
        String commentId = null;
        api.api2CommentCommentIdPropertiesGet(commentId);
        // TODO: test validations
    }

    /**
     * Removes the property from the comment identified by the key or by the id. Ths user removing the property is required  to have permissions to administer the comment.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2CommentCommentIdPropertiesPropertyKeyDeleteTest() throws ApiException {
        String commentId = null;
        String propertyKey = null;
        api.api2CommentCommentIdPropertiesPropertyKeyDelete(commentId, propertyKey);
        // TODO: test validations
    }

    /**
     * Returns the value of the property with a given key from the comment identified by the key or by the id. The user who retrieves  the property is required to have permissions to read the comment.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2CommentCommentIdPropertiesPropertyKeyGetTest() throws ApiException {
        String commentId = null;
        String propertyKey = null;
        api.api2CommentCommentIdPropertiesPropertyKeyGet(commentId, propertyKey);
        // TODO: test validations
    }

    /**
     * Sets the value of the specified comment&#39;s property.  &lt;p&gt;  You can use this resource to store a custom data against the comment identified by the key or by the id. The user  who stores the data is required to have permissions to administer the comment.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2CommentCommentIdPropertiesPropertyKeyPutTest() throws ApiException {
        String commentId = null;
        String propertyKey = null;
        api.api2CommentCommentIdPropertiesPropertyKeyPut(commentId, propertyKey);
        // TODO: test validations
    }

    /**
     * Delete a project component.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ComponentIdDeleteTest() throws ApiException {
        String id = null;
        String moveIssuesTo = null;
        api.api2ComponentIdDelete(id, moveIssuesTo);
        // TODO: test validations
    }

    /**
     * Returns the keys of all properties for the dashboard item identified by the id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2DashboardDashboardIdItemsItemIdPropertiesGetTest() throws ApiException {
        String itemId = null;
        String dashboardId = null;
        api.api2DashboardDashboardIdItemsItemIdPropertiesGet(itemId, dashboardId);
        // TODO: test validations
    }

    /**
     * Removes the property from the dashboard item identified by the key or by the id. Ths user removing the property is required  to have permissions to administer the dashboard item.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2DashboardDashboardIdItemsItemIdPropertiesPropertyKeyDeleteTest() throws ApiException {
        String itemId = null;
        String dashboardId = null;
        String propertyKey = null;
        api.api2DashboardDashboardIdItemsItemIdPropertiesPropertyKeyDelete(itemId, dashboardId, propertyKey);
        // TODO: test validations
    }

    /**
     * Returns the value of the property with a given key from the dashboard item identified by the id.  The user who retrieves the property is required to have permissions to read the dashboard item.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2DashboardDashboardIdItemsItemIdPropertiesPropertyKeyGetTest() throws ApiException {
        String itemId = null;
        String dashboardId = null;
        String propertyKey = null;
        api.api2DashboardDashboardIdItemsItemIdPropertiesPropertyKeyGet(itemId, dashboardId, propertyKey);
        // TODO: test validations
    }

    /**
     * Sets the value of the specified dashboard item&#39;s property.  &lt;p&gt;  You can use this resource to store a custom data against the dashboard item identified by the id.  The user who stores the data is required to have permissions to administer the dashboard item.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2DashboardDashboardIdItemsItemIdPropertiesPropertyKeyPutTest() throws ApiException {
        String itemId = null;
        String dashboardId = null;
        String propertyKey = null;
        api.api2DashboardDashboardIdItemsItemIdPropertiesPropertyKeyPut(itemId, dashboardId, propertyKey);
        // TODO: test validations
    }

    /**
     * Resets the columns for the given filter such that the filter no longer has its own column config.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2FilterIdColumnsDeleteTest() throws ApiException {
        Long id = null;
        api.api2FilterIdColumnsDelete(id);
        // TODO: test validations
    }

    /**
     * Returns the default columns for the given filter. Currently logged in user will be used as  the user making such request.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2FilterIdColumnsGetTest() throws ApiException {
        Long id = null;
        api.api2FilterIdColumnsGet(id);
        // TODO: test validations
    }

    /**
     * Sets the default columns for the given filter.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2FilterIdColumnsPutTest() throws ApiException {
        Long id = null;
        api.api2FilterIdColumnsPut(id);
        // TODO: test validations
    }

    /**
     * Returns the keys of all properties for the issue identified by the key or by the id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssueIssueIdOrKeyPropertiesGetTest() throws ApiException {
        String issueIdOrKey = null;
        api.api2IssueIssueIdOrKeyPropertiesGet(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Removes the property from the issue identified by the key or by the id. Ths user removing the property is required  to have permissions to edit the issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssueIssueIdOrKeyPropertiesPropertyKeyDeleteTest() throws ApiException {
        String issueIdOrKey = null;
        String propertyKey = null;
        api.api2IssueIssueIdOrKeyPropertiesPropertyKeyDelete(issueIdOrKey, propertyKey);
        // TODO: test validations
    }

    /**
     * Returns the value of the property with a given key from the issue identified by the key or by the id. The user who retrieves  the property is required to have permissions to read the issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssueIssueIdOrKeyPropertiesPropertyKeyGetTest() throws ApiException {
        String issueIdOrKey = null;
        String propertyKey = null;
        api.api2IssueIssueIdOrKeyPropertiesPropertyKeyGet(issueIdOrKey, propertyKey);
        // TODO: test validations
    }

    /**
     * Sets the value of the specified issue&#39;s property.  &lt;p&gt;  You can use this resource to store a custom data against the issue identified by the key or by the id. The user  who stores the data is required to have permissions to edit the issue.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssueIssueIdOrKeyPropertiesPropertyKeyPutTest() throws ApiException {
        String issueIdOrKey = null;
        String propertyKey = null;
        api.api2IssueIssueIdOrKeyPropertiesPropertyKeyPut(issueIdOrKey, propertyKey);
        // TODO: test validations
    }

    /**
     * Returns the issue security scheme along with that are defined.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssuesecurityschemesIdGetTest() throws ApiException {
        Long id = null;
        api.api2IssuesecurityschemesIdGet(id);
        // TODO: test validations
    }

    /**
     * Converts temporary avatar into a real avatar
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssuetypeIdAvatarPostTest() throws ApiException {
        String id = null;
        api.api2IssuetypeIdAvatarPost(id);
        // TODO: test validations
    }

    /**
     * Creates temporary avatar using multipart. The response is sent back as JSON stored in a textarea. This is because  the client uses remote iframing to submit avatars using multipart. So we must send them a valid HTML page back from  which the client parses the JSON from.  &lt;p&gt;  Creating a temporary avatar is part of a 3-step process in uploading a new  avatar for an issue type: upload, crop, confirm. This endpoint allows you to use a multipart upload  instead of sending the image directly as the request body.  &lt;/p&gt;  &lt;p&gt;  You *must* use \&quot;avatar\&quot; as the name of the upload parameter:&lt;/p&gt;  &lt;p&gt;  &lt;pre&gt;  curl -c cookiejar.txt -X POST -u admin:admin -H \&quot;X-Atlassian-Token: no-check\&quot; \\    -F \&quot;avatar&#x3D;@mynewavatar.png;type&#x3D;image/png\&quot; \\    &#39;http://localhost:8090/jira/rest/api/2/issuetype/1/avatar/temporary&#39;  &lt;/pre&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssuetypeIdAvatarTemporaryPostTest() throws ApiException {
        String id = null;
        api.api2IssuetypeIdAvatarTemporaryPost(id);
        // TODO: test validations
    }

    /**
     * Deletes the specified issue type. If the issue type has any associated issues, these issues will be migrated to  the alternative issue type specified in the parameter. You can determine the alternative issue types by calling  the &lt;b&gt;/rest/api/2/issuetype/{id}/alternatives&lt;/b&gt; resource.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssuetypeIdDeleteTest() throws ApiException {
        String id = null;
        String alternativeIssueTypeId = null;
        api.api2IssuetypeIdDelete(id, alternativeIssueTypeId);
        // TODO: test validations
    }

    /**
     * Returns a full representation of the issue type that has the given id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssuetypeIdGetTest() throws ApiException {
        String id = null;
        api.api2IssuetypeIdGet(id);
        // TODO: test validations
    }

    /**
     * Removes the property from the issue type identified by the id. Ths user removing the property is required  to have permissions to edit the issue type.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssuetypeIssueTypeIdPropertiesPropertyKeyDeleteTest() throws ApiException {
        String issueTypeId = null;
        String propertyKey = null;
        api.api2IssuetypeIssueTypeIdPropertiesPropertyKeyDelete(issueTypeId, propertyKey);
        // TODO: test validations
    }

    /**
     * Returns the value of the property with a given key from the issue type identified by the id. The user who retrieves  the property is required to have permissions to view the issue type.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssuetypeIssueTypeIdPropertiesPropertyKeyGetTest() throws ApiException {
        String issueTypeId = null;
        String propertyKey = null;
        api.api2IssuetypeIssueTypeIdPropertiesPropertyKeyGet(issueTypeId, propertyKey);
        // TODO: test validations
    }

    /**
     * Sets the value of the specified issue type&#39;s property.  &lt;p&gt;  You can use this resource to store a custom data against an issue type identified by the id. The user  who stores the data is required to have permissions to edit an issue type.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2IssuetypeIssueTypeIdPropertiesPropertyKeyPutTest() throws ApiException {
        String issueTypeId = null;
        String propertyKey = null;
        api.api2IssuetypeIssueTypeIdPropertiesPropertyKeyPut(issueTypeId, propertyKey);
        // TODO: test validations
    }

    /**
     * Returns currently logged user. This resource cannot be accessed anonymously.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2MyselfGetTest() throws ApiException {
        api.api2MyselfGet();
        // TODO: test validations
    }

    /**
     * Modify currently logged user. The \&quot;value\&quot; fields present will override the existing value.  Fields skipped in request will not be changed. Only email and display name can be change that way.  Requires user password.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2MyselfPutTest() throws ApiException {
        api.api2MyselfPut();
        // TODO: test validations
    }

    /**
     * Returns a full representation of the notification scheme for the given id. This resource will return a  notification scheme containing a list of events and recipient configured to receive notifications for these events. Consumer  should allow events without recipients to appear in response. User accessing  the data is required to have permissions to administer at least one project associated with the requested notification scheme.  &lt;p&gt;  Notification recipients can be:  &lt;ul&gt;  &lt;li&gt;current assignee - the value of the notificationType is CurrentAssignee&lt;/li&gt;  &lt;li&gt;issue reporter - the value of the notificationType is Reporter&lt;/li&gt;  &lt;li&gt;current user - the value of the notificationType is CurrentUser&lt;/li&gt;  &lt;li&gt;project lead - the value of the notificationType is ProjectLead&lt;/li&gt;  &lt;li&gt;component lead - the value of the notificationType is ComponentLead&lt;/li&gt;  &lt;li&gt;all watchers - the value of the notification type is AllWatchers&lt;/li&gt;  &lt;li&gt;configured user - the value of the notification type is User. Parameter will contain key of the user. Information about the user will be provided  if &lt;b&gt;user&lt;/b&gt; expand parameter is used. &lt;/li&gt;  &lt;li&gt;configured group - the value of the notification type is Group. Parameter will contain name of the group. Information about the group will be provided  if &lt;b&gt;group&lt;/b&gt; expand parameter is used. &lt;/li&gt;  &lt;li&gt;configured email address - the value of the notification type is EmailAddress, additionally information about the email will be provided.&lt;/li&gt;  &lt;li&gt;users or users in groups in the configured custom fields - the value of the notification type is UserCustomField or GroupCustomField. Parameter  will contain id of the custom field. Information about the field will be provided if &lt;b&gt;field&lt;/b&gt; expand parameter is used. &lt;/li&gt;  &lt;li&gt;configured project role - the value of the notification type is ProjectRole. Parameter will contain project role id. Information about the project role  will be provided if &lt;b&gt;projectRole&lt;/b&gt; expand parameter is used. &lt;/li&gt;  &lt;/ul&gt;  Please see the example for reference.  &lt;/p&gt;  The events can be JIRA system events or events configured by administrator. In case of the system events, data about theirs  ids, names and descriptions is provided. In case of custom events, the template event is included as well.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2NotificationschemeIdGetTest() throws ApiException {
        Long id = null;
        String expand = null;
        api.api2NotificationschemeIdGet(id, expand);
        // TODO: test validations
    }

    /**
     * Deletes avatar
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyAvatarIdDeleteTest() throws ApiException {
        String projectIdOrKey = null;
        Long id = null;
        api.api2ProjectProjectIdOrKeyAvatarIdDelete(projectIdOrKey, id);
        // TODO: test validations
    }

    /**
     * Converts temporary avatar into a real avatar
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyAvatarPostTest() throws ApiException {
        String projectIdOrKey = null;
        api.api2ProjectProjectIdOrKeyAvatarPost(projectIdOrKey);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyAvatarPutTest() throws ApiException {
        String projectIdOrKey = null;
        api.api2ProjectProjectIdOrKeyAvatarPut(projectIdOrKey);
        // TODO: test validations
    }

    /**
     * Creates temporary avatar using multipart. The response is sent back as JSON stored in a textarea. This is because  the client uses remote iframing to submit avatars using multipart. So we must send them a valid HTML page back from  which the client parses the JSON.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyAvatarTemporaryPostTest() throws ApiException {
        String projectIdOrKey = null;
        api.api2ProjectProjectIdOrKeyAvatarTemporaryPost(projectIdOrKey);
        // TODO: test validations
    }

    /**
     * Returns all avatars which are visible for the currently logged in user.  The avatars are grouped into  system and custom.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyAvatarsGetTest() throws ApiException {
        String projectIdOrKey = null;
        api.api2ProjectProjectIdOrKeyAvatarsGet(projectIdOrKey);
        // TODO: test validations
    }

    /**
     * Contains a full representation of a project in JSON format.  &lt;p&gt;  All project keys associated with the project will only be returned if &lt;code&gt;expand&#x3D;projectKeys&lt;/code&gt;.  &lt;p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyGetTest() throws ApiException {
        String projectIdOrKey = null;
        String expand = null;
        api.api2ProjectProjectIdOrKeyGet(projectIdOrKey, expand);
        // TODO: test validations
    }

    /**
     * Returns the keys of all properties for the project identified by the key or by the id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyPropertiesGetTest() throws ApiException {
        String projectIdOrKey = null;
        api.api2ProjectProjectIdOrKeyPropertiesGet(projectIdOrKey);
        // TODO: test validations
    }

    /**
     * Removes the property from the project identified by the key or by the id. Ths user removing the property is required  to have permissions to administer the project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyPropertiesPropertyKeyDeleteTest() throws ApiException {
        String projectIdOrKey = null;
        String propertyKey = null;
        api.api2ProjectProjectIdOrKeyPropertiesPropertyKeyDelete(projectIdOrKey, propertyKey);
        // TODO: test validations
    }

    /**
     * Returns the value of the property with a given key from the project identified by the key or by the id. The user who retrieves  the property is required to have permissions to read the project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyPropertiesPropertyKeyGetTest() throws ApiException {
        String projectIdOrKey = null;
        String propertyKey = null;
        api.api2ProjectProjectIdOrKeyPropertiesPropertyKeyGet(projectIdOrKey, propertyKey);
        // TODO: test validations
    }

    /**
     * Sets the value of the specified project&#39;s property.  &lt;p&gt;  You can use this resource to store a custom data against the project identified by the key or by the id. The user  who stores the data is required to have permissions to administer the project.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyPropertiesPropertyKeyPutTest() throws ApiException {
        String projectIdOrKey = null;
        String propertyKey = null;
        api.api2ProjectProjectIdOrKeyPropertiesPropertyKeyPut(projectIdOrKey, propertyKey);
        // TODO: test validations
    }

    /**
     * Returns all roles in the given project Id or key, with links to full details on each role.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectIdOrKeyRoleGetTest() throws ApiException {
        String projectIdOrKey = null;
        api.api2ProjectProjectIdOrKeyRoleGet(projectIdOrKey);
        // TODO: test validations
    }

    /**
     * Returns the issue security scheme for project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectKeyOrIdIssuesecuritylevelschemeGetTest() throws ApiException {
        String projectKeyOrId = null;
        api.api2ProjectProjectKeyOrIdIssuesecuritylevelschemeGet(projectKeyOrId);
        // TODO: test validations
    }

    /**
     * Gets a notification scheme associated with the project.  Follow the documentation of /notificationscheme/{id} resource for all details about returned value.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectProjectKeyOrIdNotificationschemeGetTest() throws ApiException {
        String projectKeyOrId = null;
        String expand = null;
        api.api2ProjectProjectKeyOrIdNotificationschemeGet(projectKeyOrId, expand);
        // TODO: test validations
    }

    /**
     * Validates a project key.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2ProjectvalidateKeyGetTest() throws ApiException {
        String key = null;
        api.api2ProjectvalidateKeyGet(key);
        // TODO: test validations
    }

    /**
     * Get all the ProjectRoles available in JIRA. Currently this list is global.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2RoleGetTest() throws ApiException {
        api.api2RoleGet();
        // TODO: test validations
    }

    /**
     * Deletes avatar
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UniversalAvatarTypeTypeOwnerOwningObjectIdAvatarIdDeleteTest() throws ApiException {
        Long id = null;
        String type = null;
        String owningObjectId = null;
        api.api2UniversalAvatarTypeTypeOwnerOwningObjectIdAvatarIdDelete(id, type, owningObjectId);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UniversalAvatarTypeTypeOwnerOwningObjectIdAvatarPostTest() throws ApiException {
        String type = null;
        String owningObjectId = null;
        api.api2UniversalAvatarTypeTypeOwnerOwningObjectIdAvatarPost(type, owningObjectId);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UniversalAvatarTypeTypeOwnerOwningObjectIdTempPostTest() throws ApiException {
        String type = null;
        String owningObjectId = null;
        api.api2UniversalAvatarTypeTypeOwnerOwningObjectIdTempPost(type, owningObjectId);
        // TODO: test validations
    }

    /**
     * Deletes avatar
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserAvatarIdDeleteTest() throws ApiException {
        Long id = null;
        String username = null;
        api.api2UserAvatarIdDelete(id, username);
        // TODO: test validations
    }

    /**
     * Converts temporary avatar into a real avatar
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserAvatarPostTest() throws ApiException {
        String username = null;
        api.api2UserAvatarPost(username);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserAvatarPutTest() throws ApiException {
        String username = null;
        api.api2UserAvatarPut(username);
        // TODO: test validations
    }

    /**
     * Creates temporary avatar using multipart. The response is sent back as JSON stored in a textarea. This is because  the client uses remote iframing to submit avatars using multipart. So we must send them a valid HTML page back from  which the client parses the JSON from.  &lt;p&gt;  Creating a temporary avatar is part of a 3-step process in uploading a new  avatar for a user: upload, crop, confirm. This endpoint allows you to use a multipart upload  instead of sending the image directly as the request body.  &lt;/p&gt;  &lt;p&gt;  You *must* use \&quot;avatar\&quot; as the name of the upload parameter:&lt;/p&gt;  &lt;p/&gt;  &lt;pre&gt;  curl -c cookiejar.txt -X POST -u admin:admin -H \&quot;X-Atlassian-Token: no-check\&quot; \\    -F \&quot;avatar&#x3D;@mynewavatar.png;type&#x3D;image/png\&quot; \\    &#39;http://localhost:8090/jira/rest/api/2/user/avatar/temporary?username&#x3D;admin&#39;  &lt;/pre&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserAvatarTemporaryPostTest() throws ApiException {
        String username = null;
        api.api2UserAvatarTemporaryPost(username);
        // TODO: test validations
    }

    /**
     * Returns all avatars which are visible for the currently logged in user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserAvatarsGetTest() throws ApiException {
        String username = null;
        api.api2UserAvatarsGet(username);
        // TODO: test validations
    }

    /**
     * Reset the default columns for the given user to the system default. Admin permission will be required to get  columns for a user other than the currently logged in user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserColumnsDeleteTest() throws ApiException {
        String username = null;
        api.api2UserColumnsDelete(username);
        // TODO: test validations
    }

    /**
     * Returns the default columns for the given user. Admin permission will be required to get columns for a user  other than the currently logged in user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserColumnsGetTest() throws ApiException {
        String username = null;
        api.api2UserColumnsGet(username);
        // TODO: test validations
    }

    /**
     * Sets the default columns for the given user.  Admin permission will be required to get columns for a user  other than the currently logged in user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserColumnsPutTest() throws ApiException {
        api.api2UserColumnsPut();
        // TODO: test validations
    }

    /**
     * Returns a user. This resource cannot be accessed anonymously.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserGetTest() throws ApiException {
        String username = null;
        String key = null;
        api.api2UserGet(username, key);
        // TODO: test validations
    }

    /**
     * Returns the keys of all properties for the user identified by the key or by the id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserPropertiesGetTest() throws ApiException {
        String userKey = null;
        String username = null;
        api.api2UserPropertiesGet(userKey, username);
        // TODO: test validations
    }

    /**
     * Removes the property from the user identified by the key or by the id. Ths user removing the property is required  to have permissions to administer the user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserPropertiesPropertyKeyDeleteTest() throws ApiException {
        String propertyKey = null;
        String userKey = null;
        String username = null;
        api.api2UserPropertiesPropertyKeyDelete(propertyKey, userKey, username);
        // TODO: test validations
    }

    /**
     * Returns the value of the property with a given key from the user identified by the key or by the id. The user who retrieves  the property is required to have permissions to read the user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserPropertiesPropertyKeyGetTest() throws ApiException {
        String propertyKey = null;
        String userKey = null;
        String username = null;
        api.api2UserPropertiesPropertyKeyGet(propertyKey, userKey, username);
        // TODO: test validations
    }

    /**
     * Sets the value of the specified user&#39;s property.  &lt;p&gt;  You can use this resource to store a custom data against the user identified by the key or by the id. The user  who stores the data is required to have permissions to administer the user.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserPropertiesPropertyKeyPutTest() throws ApiException {
        String propertyKey = null;
        String userKey = null;
        String username = null;
        api.api2UserPropertiesPropertyKeyPut(propertyKey, userKey, username);
        // TODO: test validations
    }

    /**
     * Modify user. The \&quot;value\&quot; fields present will override the existing value.  Fields skipped in request will not be changed.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2UserPutTest() throws ApiException {
        String username = null;
        String key = null;
        api.api2UserPut(username, key);
        // TODO: test validations
    }

    /**
     * Delete a project version.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2VersionIdDeleteTest() throws ApiException {
        String id = null;
        String moveFixIssuesTo = null;
        String moveAffectedIssuesTo = null;
        api.api2VersionIdDelete(id, moveFixIssuesTo, moveAffectedIssuesTo);
        // TODO: test validations
    }

    /**
     * Delete a project version.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2VersionIdRemoveAndSwapPostTest() throws ApiException {
        String id = null;
        api.api2VersionIdRemoveAndSwapPost(id);
        // TODO: test validations
    }

    /**
     * Create a remote version link via POST.  The link&#39;s global ID will be taken from the  JSON payload if provided; otherwise, it will be generated.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2VersionVersionIdRemotelinkGlobalIdPostTest() throws ApiException {
        String versionId = null;
        String globalId = null;
        api.api2VersionVersionIdRemotelinkGlobalIdPost(versionId, globalId);
        // TODO: test validations
    }

    /**
     * Create a remote version link via POST.  The link&#39;s global ID will be taken from the  JSON payload if provided; otherwise, it will be generated.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2VersionVersionIdRemotelinkPostTest() throws ApiException {
        String versionId = null;
        api.api2VersionVersionIdRemotelinkPost(versionId);
        // TODO: test validations
    }

    /**
     * Delete a property from the passed transition on the passed workflow. It is not an error to delete a property that  does not exist.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2WorkflowApi2TransitionsIdPropertiesDeleteTest() throws ApiException {
        Long id = null;
        String key = null;
        String workflowName = null;
        String workflowMode = null;
        api.api2WorkflowApi2TransitionsIdPropertiesDelete(id, key, workflowName, workflowMode);
        // TODO: test validations
    }

    /**
     * Remove the specified issue type mapping from the scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2WorkflowschemeIdIssuetypeIssueTypeDeleteTest() throws ApiException {
        String issueType = null;
        Long id = null;
        Boolean updateDraftIfNeeded = null;
        api.api2WorkflowschemeIdIssuetypeIssueTypeDelete(issueType, id, updateDraftIfNeeded);
        // TODO: test validations
    }

    /**
     * Returns the issue type mapping for the passed workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void api2WorkflowschemeIdIssuetypeIssueTypeGetTest() throws ApiException {
        String issueType = null;
        Long id = null;
        Boolean returnDraftIfExists = null;
        api.api2WorkflowschemeIdIssuetypeIssueTypeGet(issueType, id, returnDraftIfExists);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void approveUpgradeTest() throws ApiException {
        api.approveUpgrade();
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void areMetricsExposedTest() throws ApiException {
        api.areMetricsExposed();
        // TODO: test validations
    }

    /**
     * Assigns an issue to a user.  You can use this resource to assign issues when the user submitting the request has the assign permission but not the  edit issue permission.  If the name is \&quot;-1\&quot; automatic assignee is used.  A null name will remove the assignee.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void assignTest() throws ApiException {
        String issueIdOrKey = null;
        api.assign(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Assigns a permission scheme with a project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void assignPermissionSchemeTest() throws ApiException {
        String projectKeyOrId = null;
        String expand = null;
        api.assignPermissionScheme(projectKeyOrId, expand);
        // TODO: test validations
    }

    /**
     * Returns a list of all dashboards, optionally filtering them.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void callListTest() throws ApiException {
        String filter = null;
        Integer startAt = null;
        Integer maxResults = null;
        api.callList(filter, startAt, maxResults);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void canMoveSubTaskTest() throws ApiException {
        String issueIdOrKey = null;
        api.canMoveSubTask(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelUpgradeTest() throws ApiException {
        api.cancelUpgrade();
        // TODO: test validations
    }

    /**
     * Modify caller password.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeMyPasswordTest() throws ApiException {
        api.changeMyPassword();
        // TODO: test validations
    }

    /**
     * Modify user password.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeUserPasswordTest() throws ApiException {
        String username = null;
        String key = null;
        api.changeUserPassword(username, key);
        // TODO: test validations
    }

    /**
     * Create a component via POST.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createComponentTest() throws ApiException {
        api.createComponent();
        // TODO: test validations
    }

    /**
     * Creates a custom field using a definition (object encapsulating custom field data)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createCustomFieldTest() throws ApiException {
        api.createCustomField();
        // TODO: test validations
    }

    /**
     * Create a draft for the passed scheme. The draft will be a copy of the state of the parent.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createDraftForParentTest() throws ApiException {
        Long id = null;
        api.createDraftForParent(id);
        // TODO: test validations
    }

    /**
     * Creates a new filter, and returns newly created filter.  Currently sets permissions just using the users default sharing permissions
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createFilterTest() throws ApiException {
        String expand = null;
        api.createFilter(expand);
        // TODO: test validations
    }

    /**
     * Creates a group by given group parameter  &lt;p&gt;  Returns REST representation for the requested group.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createGroupTest() throws ApiException {
        api.createGroup();
        // TODO: test validations
    }

    /**
     * Creates an issue or a sub-task from a JSON representation.  &lt;p/&gt;  The fields that can be set on create, in either the fields parameter or the update parameter can be determined  using the &lt;b&gt;/rest/api/2/issue/createmeta&lt;/b&gt; resource.  If a field is not configured to appear on the create screen, then it will not be in the createmeta, and a field  validation error will occur if it is submitted.  &lt;p/&gt;  Creating a sub-task is similar to creating a regular issue, with two important differences:  &lt;ul&gt;  &lt;li&gt;the &lt;code&gt;issueType&lt;/code&gt; field must correspond to a sub-task issue type (you can use  &lt;code&gt;/issue/createmeta&lt;/code&gt; to discover sub-task issue types), and&lt;/li&gt;  &lt;li&gt;you must provide a &lt;code&gt;parent&lt;/code&gt; field in the issue create request containing the id or key of the  parent issue.&lt;/li&gt;  &lt;/ul&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createIssueTest() throws ApiException {
        api.createIssue();
        // TODO: test validations
    }

    /**
     * Create a new issue link type.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createIssueLinkTypeTest() throws ApiException {
        api.createIssueLinkType();
        // TODO: test validations
    }

    /**
     * Creates an issue type from a JSON representation and adds the issue newly created issue type to the default issue  type scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createIssueTypeTest() throws ApiException {
        api.createIssueType();
        // TODO: test validations
    }

    /**
     * Creates issues or sub-tasks from a JSON representation.  &lt;p/&gt;  Creates many issues in one bulk operation.  &lt;p/&gt;  Creating a sub-task is similar to creating a regular issue. More details can be found in createIssue section:  {@link IssueResource#createIssue(IssueUpdateBean)}}
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createIssuesTest() throws ApiException {
        api.createIssues();
        // TODO: test validations
    }

    /**
     * Creates or updates a remote issue link from a JSON representation. If a globalId is provided and a remote issue link  exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createOrUpdateRemoteIssueLinkTest() throws ApiException {
        String issueIdOrKey = null;
        api.createOrUpdateRemoteIssueLink(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Creates a permission grant in a permission scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createPermissionGrantTest() throws ApiException {
        Long schemeId = null;
        String expand = null;
        api.createPermissionGrant(schemeId, expand);
        // TODO: test validations
    }

    /**
     * Create a new permission scheme.  This method can create schemes with a defined permission set, or without.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createPermissionSchemeTest() throws ApiException {
        String expand = null;
        api.createPermissionScheme(expand);
        // TODO: test validations
    }

    /**
     * Creates a new project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createProjectTest() throws ApiException {
        api.createProject();
        // TODO: test validations
    }

    /**
     * Create a project category via POST.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createProjectCategoryTest() throws ApiException {
        api.createProjectCategory();
        // TODO: test validations
    }

    /**
     * Creates a new ProjectRole to be available in JIRA.  The created role does not have any default actors assigned.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createProjectRoleTest() throws ApiException {
        api.createProjectRole();
        // TODO: test validations
    }

    /**
     * Add a new property to a transition. Trying to add a property that already  exists will fail.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createPropertyTest() throws ApiException {
        Long id = null;
        String key = null;
        String workflowName = null;
        String workflowMode = null;
        api.createProperty(id, key, workflowName, workflowMode);
        // TODO: test validations
    }

    /**
     * Create a new workflow scheme.  &lt;p/&gt;  The body contains a representation of the new scheme. Values not passed are assumed to be set to their defaults.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createSchemeTest() throws ApiException {
        api.createScheme();
        // TODO: test validations
    }

    /**
     * Create user. By default created user will not be notified with email.  If password field is not set then password will be randomly generated.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createUserTest() throws ApiException {
        api.createUser();
        // TODO: test validations
    }

    /**
     * Create a version via POST.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createVersionTest() throws ApiException {
        api.createVersion();
        // TODO: test validations
    }

    /**
     * Returns information about the currently authenticated user&#39;s session. If the caller is not authenticated they  will get a 401 Unauthorized status code.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void currentUserTest() throws ApiException {
        api.currentUser();
        // TODO: test validations
    }

    /**
     * Deletes actors (users or groups) from a project role.  &lt;p&gt;  &lt;ul&gt;  &lt;li&gt;Delete a user from the role: &lt;code&gt;/rest/api/2/project/{projectIdOrKey}/role/{roleId}?user&#x3D;{username}&lt;/code&gt;&lt;/li&gt;  &lt;li&gt;Delete a group from the role: &lt;code&gt;/rest/api/2/project/{projectIdOrKey}/role/{roleId}?group&#x3D;{groupname}&lt;/code&gt;&lt;/li&gt;  &lt;/ul&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteActorTest() throws ApiException {
        String projectIdOrKey = null;
        Long id = null;
        String user = null;
        String group = null;
        api.deleteActor(projectIdOrKey, id, user, group);
        // TODO: test validations
    }

    /**
     * Deletes an existing comment .
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteCommentTest() throws ApiException {
        String issueIdOrKey = null;
        String id = null;
        api.deleteComment(issueIdOrKey, id);
        // TODO: test validations
    }

    /**
     * Remove the default workflow from the passed workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteDefaultTest() throws ApiException {
        Long id = null;
        Boolean updateDraftIfNeeded = null;
        api.deleteDefault(id, updateDraftIfNeeded);
        // TODO: test validations
    }

    /**
     * Delete the passed draft workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteDraftByIdTest() throws ApiException {
        Long id = null;
        api.deleteDraftById(id);
        // TODO: test validations
    }

    /**
     * Remove the default workflow from the passed draft workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteDraftDefaultTest() throws ApiException {
        Long id = null;
        api.deleteDraftDefault(id);
        // TODO: test validations
    }

    /**
     * Remove the specified issue type mapping from the draft scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteDraftIssueTypeTest() throws ApiException {
        String issueType = null;
        Long id = null;
        api.deleteDraftIssueType(issueType, id);
        // TODO: test validations
    }

    /**
     * Delete the passed workflow from the draft workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteDraftWorkflowMappingTest() throws ApiException {
        Long id = null;
        String workflowName = null;
        api.deleteDraftWorkflowMapping(id, workflowName);
        // TODO: test validations
    }

    /**
     * Delete a filter.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteFilterTest() throws ApiException {
        Long id = null;
        api.deleteFilter(id);
        // TODO: test validations
    }

    /**
     * Delete an issue.  &lt;p/&gt;  If the issue has subtasks you must set the parameter deleteSubtasks&#x3D;true to delete the issue.  You cannot delete an issue without its subtasks also being deleted.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteIssueTest() throws ApiException {
        String issueIdOrKey = null;
        String deleteSubtasks = null;
        api.deleteIssue(issueIdOrKey, deleteSubtasks);
        // TODO: test validations
    }

    /**
     * Deletes an issue link with the specified id.  To be able to delete an issue link you must be able to view both issues and must have the link issue permission  for at least one of the issues.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteIssueLinkTest() throws ApiException {
        String linkId = null;
        api.deleteIssueLink(linkId);
        // TODO: test validations
    }

    /**
     * Delete the specified issue link type.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteIssueLinkTypeTest() throws ApiException {
        String issueLinkTypeId = null;
        api.deleteIssueLinkType(issueLinkTypeId);
        // TODO: test validations
    }

    /**
     * Deletes a permission scheme identified by the given id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deletePermissionSchemeTest() throws ApiException {
        Long schemeId = null;
        api.deletePermissionScheme(schemeId);
        // TODO: test validations
    }

    /**
     * Deletes a permission grant from a permission scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deletePermissionSchemeEntityTest() throws ApiException {
        Long permissionId = null;
        Long schemeId = null;
        api.deletePermissionSchemeEntity(permissionId, schemeId);
        // TODO: test validations
    }

    /**
     * Deletes a project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteProjectTest() throws ApiException {
        String projectIdOrKey = null;
        api.deleteProject(projectIdOrKey);
        // TODO: test validations
    }

    /**
     * Deletes a role. May return 403 in the future
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteProjectRoleTest() throws ApiException {
        Long id = null;
        Long swap = null;
        api.deleteProjectRole(id, swap);
        // TODO: test validations
    }

    /**
     * Removes default actor from the given role.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteProjectRoleActorsFromRoleTest() throws ApiException {
        Long id = null;
        String user = null;
        String group = null;
        api.deleteProjectRoleActorsFromRole(id, user, group);
        // TODO: test validations
    }

    /**
     * Delete the remote issue link with the given global id on the issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteRemoteIssueLinkByGlobalIdTest() throws ApiException {
        String issueIdOrKey = null;
        String globalId = null;
        api.deleteRemoteIssueLinkByGlobalId(issueIdOrKey, globalId);
        // TODO: test validations
    }

    /**
     * Delete the remote issue link with the given id on the issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteRemoteIssueLinkByIdTest() throws ApiException {
        String linkId = null;
        String issueIdOrKey = null;
        api.deleteRemoteIssueLinkById(linkId, issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Delete a specific remote version link with the given version ID and global ID.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteRemoteVersionLinkTest() throws ApiException {
        String versionId = null;
        String globalId = null;
        api.deleteRemoteVersionLink(versionId, globalId);
        // TODO: test validations
    }

    /**
     * Delete all remote version links for a given version ID.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteRemoteVersionLinksByVersionIdTest() throws ApiException {
        String versionId = null;
        api.deleteRemoteVersionLinksByVersionId(versionId);
        // TODO: test validations
    }

    /**
     * Delete the passed workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteSchemeTest() throws ApiException {
        Long id = null;
        api.deleteScheme(id);
        // TODO: test validations
    }

    /**
     * Removes a share permissions from the given filter.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteSharePermissionTest() throws ApiException {
        Long id = null;
        Long permissionId = null;
        api.deleteSharePermission(id, permissionId);
        // TODO: test validations
    }

    /**
     * Deletes tab to give screen
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteTabTest() throws ApiException {
        Long screenId = null;
        Long tabId = null;
        api.deleteTab(screenId, tabId);
        // TODO: test validations
    }

    /**
     * Delete the passed workflow from the workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteWorkflowMappingTest() throws ApiException {
        Long id = null;
        String workflowName = null;
        Boolean updateDraftIfNeeded = null;
        api.deleteWorkflowMapping(id, workflowName, updateDraftIfNeeded);
        // TODO: test validations
    }

    /**
     * Deletes an existing worklog entry.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteWorklogTest() throws ApiException {
        String issueIdOrKey = null;
        String id = null;
        String adjustEstimate = null;
        String newEstimate = null;
        String increaseBy = null;
        api.deleteWorklog(issueIdOrKey, id, adjustEstimate, newEstimate, increaseBy);
        // TODO: test validations
    }

    /**
     * Perform a transition on an issue.  When performing the transition you can update or set other issue fields.  &lt;p/&gt;  The fields that can be set on transtion, in either the fields parameter or the update parameter can be determined  using the &lt;b&gt;/rest/api/2/issue/{issueIdOrKey}/transitions?expand&#x3D;transitions.fields&lt;/b&gt; resource.  If a field is not configured to appear on the transition screen, then it will not be in the transition metadata, and a field  validation error will occur if it is submitted.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void doTransitionTest() throws ApiException {
        String issueIdOrKey = null;
        api.doTransition(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Updates an existing filter, and returns its new value.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void editFilterTest() throws ApiException {
        Long id = null;
        String expand = null;
        api.editFilter(id, expand);
        // TODO: test validations
    }

    /**
     * Edits an issue from a JSON representation.  &lt;p/&gt;  The issue can either be updated by setting explicit the field value(s)  or by using an operation to change the field value.  &lt;p/&gt;  The fields that can be updated, in either the fields parameter or the update parameter, can be determined  using the &lt;b&gt;/rest/api/2/issue/{issueIdOrKey}/editmeta&lt;/b&gt; resource.&lt;br&gt;  If a field is not configured to appear on the edit screen, then it will not be in the editmeta, and a field  validation error will occur if it is submitted.  &lt;p/&gt;  Specifying a \&quot;field_id\&quot;: field_value in the \&quot;fields\&quot; is a shorthand for a \&quot;set\&quot; operation in the \&quot;update\&quot; section.&lt;br&gt;  Field should appear either in \&quot;fields\&quot; or \&quot;update\&quot;, not in both.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void editIssueTest() throws ApiException {
        String issueIdOrKey = null;
        Boolean notifyUsers = null;
        api.editIssue(issueIdOrKey, notifyUsers);
        // TODO: test validations
    }

    /**
     * Tries to expand an attachment. Output is human-readable and subject to change.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void expandForHumansTest() throws ApiException {
        String id = null;
        api.expandForHumans(id);
        // TODO: test validations
    }

    /**
     * Tries to expand an attachment. Output is raw and should be backwards-compatible through the course of time.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void expandForMachinesTest() throws ApiException {
        String id = null;
        api.expandForMachines(id);
        // TODO: test validations
    }

    /**
     * Returns a list of users that match the search string. This resource cannot be accessed anonymously.  Please note that this resource should be called with an issue key when a list of assignable users is retrieved  for editing.  For create only a project key should be supplied.  The list of assignable users may be incorrect  if it&#39;s called with the project key for editing.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void findAssignableUsersTest() throws ApiException {
        String username = null;
        String project = null;
        String issueKey = null;
        Integer startAt = null;
        Integer maxResults = null;
        Integer actionDescriptorId = null;
        api.findAssignableUsers(username, project, issueKey, startAt, maxResults, actionDescriptorId);
        // TODO: test validations
    }

    /**
     * Returns a list of users that match the search string and can be assigned issues for all the given projects.  This resource cannot be accessed anonymously.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void findBulkAssignableUsersTest() throws ApiException {
        String username = null;
        String projectKeys = null;
        Integer startAt = null;
        Integer maxResults = null;
        api.findBulkAssignableUsers(username, projectKeys, startAt, maxResults);
        // TODO: test validations
    }

    /**
     * Returns groups with substrings matching a given query. This is mainly for use with  the group picker, so the returned groups contain html to be used as picker suggestions.  The groups are also wrapped in a single response object that also contains a header for  use in the picker, specifically &lt;i&gt;Showing X of Y matching groups&lt;/i&gt;.  &lt;p&gt;  The number of groups returned is limited by the system property \&quot;jira.ajax.autocomplete.limit\&quot;  &lt;p&gt;  The groups will be unique and sorted.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void findGroupsTest() throws ApiException {
        String query = null;
        String exclude = null;
        Integer maxResults = null;
        String userName = null;
        api.findGroups(query, exclude, maxResults, userName);
        // TODO: test validations
    }

    /**
     * Returns a list of users that match the search string. This resource cannot be accessed anonymously.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void findUsersTest() throws ApiException {
        String username = null;
        Integer startAt = null;
        Integer maxResults = null;
        Boolean includeActive = null;
        Boolean includeInactive = null;
        api.findUsers(username, startAt, maxResults, includeActive, includeInactive);
        // TODO: test validations
    }

    /**
     * Returns a list of users and groups matching query with highlighting. This resource cannot be accessed  anonymously.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void findUsersAndGroupsTest() throws ApiException {
        String query = null;
        Integer maxResults = null;
        Boolean showAvatar = null;
        String fieldId = null;
        String projectId = null;
        String issueTypeId = null;
        api.findUsersAndGroups(query, maxResults, showAvatar, fieldId, projectId, issueTypeId);
        // TODO: test validations
    }

    /**
     * Returns a list of users matching query with highlighting. This resource cannot be accessed anonymously.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void findUsersForPickerTest() throws ApiException {
        String query = null;
        Integer maxResults = null;
        Boolean showAvatar = null;
        String exclude = null;
        api.findUsersForPicker(query, maxResults, showAvatar, exclude);
        // TODO: test validations
    }

    /**
     * Returns a list of active users that match the search string and have all specified permissions for the project or issue.&lt;br&gt;  This resource can be accessed by users with ADMINISTER_PROJECT permission for the project or global ADMIN or SYSADMIN rights.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void findUsersWithAllPermissionsTest() throws ApiException {
        String username = null;
        String permissions = null;
        String issueKey = null;
        String projectKey = null;
        Integer startAt = null;
        Integer maxResults = null;
        api.findUsersWithAllPermissions(username, permissions, issueKey, projectKey, startAt, maxResults);
        // TODO: test validations
    }

    /**
     * Returns a list of active users that match the search string. This resource cannot be accessed anonymously   and requires the Browse Users global permission.  Given an issue key this resource will provide a list of users that match the search string and have  the browse issue permission for the issue provided.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void findUsersWithBrowsePermissionTest() throws ApiException {
        String username = null;
        String issueKey = null;
        String projectKey = null;
        Integer startAt = null;
        Integer maxResults = null;
        api.findUsersWithBrowsePermission(username, issueKey, projectKey, startAt, maxResults);
        // TODO: test validations
    }

    /**
     * Fully updates a roles. Both name and description must be given.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fullyUpdateProjectRoleTest() throws ApiException {
        Long id = null;
        api.fullyUpdateProjectRole(id);
        // TODO: test validations
    }

    /**
     * Returns the ApplicationRole with passed key if it exists.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getTest() throws ApiException {
        String key = null;
        api.get(key);
        // TODO: test validations
    }

    /**
     * Returns the project type with the given key, if it is accessible to the logged in user.  This takes into account whether the user is licensed on the Application that defines the project type.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAccessibleProjectTypeByKeyTest() throws ApiException {
        String projectTypeKey = null;
        api.getAccessibleProjectTypeByKey(projectTypeKey);
        // TODO: test validations
    }

    /**
     * Returns the properties that are displayed on the \&quot;General Configuration &gt; Advanced Settings\&quot; page.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAdvancedSettingsTest() throws ApiException {
        api.getAdvancedSettings();
        // TODO: test validations
    }

    /**
     * Returns all ApplicationRoles in the system. Will also return an ETag header containing a version hash of the  collection of ApplicationRoles.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllTest() throws ApiException {
        api.getAll();
        // TODO: test validations
    }

    /**
     * Gets all fields for a given tab
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllFieldsTest() throws ApiException {
        Long screenId = null;
        Long tabId = null;
        String projectKey = null;
        api.getAllFields(screenId, tabId, projectKey);
        // TODO: test validations
    }

    /**
     * Returns all permissions that are present in the JIRA instance - Global, Project and the global ones added by plugins
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllPermissionsTest() throws ApiException {
        api.getAllPermissions();
        // TODO: test validations
    }

    /**
     * Returns all project categories
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllProjectCategoriesTest() throws ApiException {
        api.getAllProjectCategories();
        // TODO: test validations
    }

    /**
     * Returns all the project types defined on the JIRA instance, not taking into account whether  the license to use those project types is valid or not.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllProjectTypesTest() throws ApiException {
        api.getAllProjectTypes();
        // TODO: test validations
    }

    /**
     * Returns all projects which are visible for the currently logged in user. If no user is logged in, it returns the  list of projects that are visible when using anonymous access.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllProjectsTest() throws ApiException {
        String expand = null;
        Integer recent = null;
        api.getAllProjects(expand, recent);
        // TODO: test validations
    }

    /**
     * Get all issue types with valid status values for a project
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllStatusesTest() throws ApiException {
        String projectIdOrKey = null;
        api.getAllStatuses(projectIdOrKey);
        // TODO: test validations
    }

    /**
     * Returns all system avatars of the given type.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllSystemAvatarsTest() throws ApiException {
        String type = null;
        api.getAllSystemAvatars(type);
        // TODO: test validations
    }

    /**
     * Returns a list of all tabs for the given screen
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllTabsTest() throws ApiException {
        Long screenId = null;
        String projectKey = null;
        api.getAllTabs(screenId, projectKey);
        // TODO: test validations
    }

    /**
     * Returns all workflows.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllWorkflowsTest() throws ApiException {
        String workflowName = null;
        api.getAllWorkflows(workflowName);
        // TODO: test validations
    }

    /**
     * Returns a list of all alternative issue types for the given issue type id. The list will contain these issues types, to which  issues assigned to the given issue type can be migrated. The suitable alternatives are issue types which are assigned  to the same workflow, the same field configuration and the same screen scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAlternativeIssueTypesTest() throws ApiException {
        String id = null;
        api.getAlternativeIssueTypes(id);
        // TODO: test validations
    }

    /**
     * Gets a permission scheme assigned with a project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAssignedPermissionSchemeTest() throws ApiException {
        String projectKeyOrId = null;
        String expand = null;
        api.getAssignedPermissionScheme(projectKeyOrId, expand);
        // TODO: test validations
    }

    /**
     * Returns the meta-data for an attachment, including the URI of the actual attached file.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAttachmentTest() throws ApiException {
        String id = null;
        api.getAttachment(id);
        // TODO: test validations
    }

    /**
     * Returns the meta information for an attachments, specifically if they are enabled and the maximum upload size  allowed.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAttachmentMetaTest() throws ApiException {
        api.getAttachmentMeta();
        // TODO: test validations
    }

    /**
     * Returns the auto complete data required for JQL searches.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAutoCompleteTest() throws ApiException {
        api.getAutoComplete();
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAvailableMetricsTest() throws ApiException {
        api.getAvailableMetrics();
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAvatarsTest() throws ApiException {
        String type = null;
        String owningObjectId = null;
        api.getAvatars(type, owningObjectId);
        // TODO: test validations
    }

    /**
     * Returns the requested workflow scheme to the caller.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getByIdTest() throws ApiException {
        Long id = null;
        Boolean returnDraftIfExists = null;
        api.getById(id, returnDraftIfExists);
        // TODO: test validations
    }

    /**
     * Returns a single comment.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCommentTest() throws ApiException {
        String issueIdOrKey = null;
        String id = null;
        String expand = null;
        api.getComment(issueIdOrKey, id, expand);
        // TODO: test validations
    }

    /**
     * Returns all comments for an issue.  &lt;p&gt;  Results can be ordered by the \&quot;created\&quot; field which means the date a comment was added.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCommentsTest() throws ApiException {
        String issueIdOrKey = null;
        Long startAt = null;
        Integer maxResults = null;
        String orderBy = null;
        String expand = null;
        api.getComments(issueIdOrKey, startAt, maxResults, orderBy, expand);
        // TODO: test validations
    }

    /**
     * Returns a project component.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getComponentTest() throws ApiException {
        String id = null;
        api.getComponent(id);
        // TODO: test validations
    }

    /**
     * Returns counts of issues related to this component.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getComponentRelatedIssuesTest() throws ApiException {
        String id = null;
        api.getComponentRelatedIssues(id);
        // TODO: test validations
    }

    /**
     * Returns the information if the optional features in JIRA are enabled or disabled. If the time tracking is enabled,  it also returns the detailed information about time tracking configuration.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getConfigurationTest() throws ApiException {
        api.getConfiguration();
        // TODO: test validations
    }

    /**
     * Returns the meta data for creating issues. This includes the available projects, issue types and fields,  including field types and whether or not those fields are required.  Projects will not be returned if the user does not have permission to create issues in that project.  &lt;p/&gt;  The fields in the createmeta correspond to the fields in the create screen for the project/issuetype.  Fields not in the screen will not be in the createmeta.  &lt;p/&gt;  Fields will only be returned if &lt;code&gt;expand&#x3D;projects.issuetypes.fields&lt;/code&gt;.  &lt;p/&gt;  The results can be filtered by project and/or issue type, given by the query params.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCreateIssueMetaTest() throws ApiException {
        String projectIds = null;
        String projectKeys = null;
        String issuetypeIds = null;
        String issuetypeNames = null;
        api.getCreateIssueMeta(projectIds, projectKeys, issuetypeIds, issuetypeNames);
        // TODO: test validations
    }

    /**
     * Returns a full representation of the Custom Field Option that has the given id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCustomFieldOptionTest() throws ApiException {
        String id = null;
        api.getCustomFieldOption(id);
        // TODO: test validations
    }

    /**
     * Returns a single dashboard.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDashboardTest() throws ApiException {
        String id = null;
        api.getDashboard(id);
        // TODO: test validations
    }

    /**
     * Return the default workflow from the passed workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDefaultTest() throws ApiException {
        Long id = null;
        Boolean returnDraftIfExists = null;
        api.getDefault(id, returnDraftIfExists);
        // TODO: test validations
    }

    /**
     * Returns the default share scope of the logged-in user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDefaultShareScopeTest() throws ApiException {
        api.getDefaultShareScope();
        // TODO: test validations
    }

    /**
     * Returns the requested draft workflow scheme to the caller.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDraftByIdTest() throws ApiException {
        Long id = null;
        api.getDraftById(id);
        // TODO: test validations
    }

    /**
     * Return the default workflow from the passed draft workflow scheme to the caller.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDraftDefaultTest() throws ApiException {
        Long id = null;
        api.getDraftDefault(id);
        // TODO: test validations
    }

    /**
     * Returns the issue type mapping for the passed draft workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDraftIssueTypeTest() throws ApiException {
        String issueType = null;
        Long id = null;
        api.getDraftIssueType(issueType, id);
        // TODO: test validations
    }

    /**
     * Returns the draft workflow mappings or requested mapping to the caller.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDraftWorkflowTest() throws ApiException {
        Long id = null;
        String workflowName = null;
        api.getDraftWorkflow(id, workflowName);
        // TODO: test validations
    }

    /**
     * Returns the meta data for editing an issue.  &lt;p/&gt;  The fields in the editmeta correspond to the fields in the edit screen for the issue.  Fields not in the screen will not be in the editmeta.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEditIssueMetaTest() throws ApiException {
        String issueIdOrKey = null;
        api.getEditIssueMeta(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Returns the favourite filters of the logged-in user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFavouriteFiltersTest() throws ApiException {
        String expand = null;
        Boolean enableSharedUsers = null;
        api.getFavouriteFilters(expand, enableSharedUsers);
        // TODO: test validations
    }

    /**
     * Returns auto complete suggestions for JQL search.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFieldAutoCompleteForQueryStringTest() throws ApiException {
        String fieldName = null;
        String fieldValue = null;
        String predicateName = null;
        String predicateValue = null;
        api.getFieldAutoCompleteForQueryString(fieldName, fieldValue, predicateName, predicateValue);
        // TODO: test validations
    }

    /**
     * Returns a list of all fields, both System and Custom
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFieldsTest() throws ApiException {
        api.getFields();
        // TODO: test validations
    }

    /**
     * Gets available fields for screen. i.e ones that haven&#39;t already been added.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFieldsToAddTest() throws ApiException {
        Long screenId = null;
        api.getFieldsToAdd(screenId);
        // TODO: test validations
    }

    /**
     * Returns a filter given an id
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFilterTest() throws ApiException {
        Long id = null;
        String expand = null;
        Boolean enableSharedUsers = null;
        api.getFilter(id, expand, enableSharedUsers);
        // TODO: test validations
    }

    /**
     * Returns REST representation for the requested group. Allows to get list of active users belonging to the  specified group and its subgroups if \&quot;users\&quot; expand option is provided. You can page through users list by using  indexes in expand param. For example to get users from index 10 to index 15 use \&quot;users[10:15]\&quot; expand value. This  will return 6 users (if there are at least 16 users in this group). Indexes are 0-based and inclusive.  &lt;p&gt;  This resource is deprecated, please use group/member API instead.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getGroupTest() throws ApiException {
        String groupname = null;
        String expand = null;
        api.getGroup(groupname, expand);
        // TODO: test validations
    }

    /**
     * Returns worklogs id and delete time of worklogs that was deleted since given time.  The returns set of worklogs is limited to 1000 elements.  This API will not return worklogs deleted during last minute.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIdsOfWorklogsDeletedSinceTest() throws ApiException {
        Long since = null;
        api.getIdsOfWorklogsDeletedSince(since);
        // TODO: test validations
    }

    /**
     * Returns worklogs id and update time of worklogs that was updated since given time.  The returns set of worklogs is limited to 1000 elements.  This API will not return worklogs updated during last minute.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIdsOfWorklogsModifiedSinceTest() throws ApiException {
        Long since = null;
        api.getIdsOfWorklogsModifiedSince(since);
        // TODO: test validations
    }

    /**
     * Summarizes index condition of current node.  &lt;p/&gt;  Returned data consists of:  &lt;ul&gt;  &lt;li&gt;&lt;code&gt;nodeId&lt;/code&gt; - Node identifier.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;reportTime&lt;/code&gt; - Time of this report creation.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;issueIndex&lt;/code&gt; - Summary of issue index status.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;replicationQueues&lt;/code&gt; - Map of index replication queues, where  keys represent nodes from which replication operations came from.&lt;/li&gt;  &lt;/ul&gt;  &lt;p/&gt;  &lt;code&gt;issueIndex&lt;/code&gt; can contain:  &lt;ul&gt;  &lt;li&gt;&lt;code&gt;indexReadable&lt;/code&gt; - If &lt;code&gt;false&lt;/code&gt; the end point failed to read data from issue index  (check JIRA logs for detailed stack trace), otherwise &lt;code&gt;true&lt;/code&gt;.  When &lt;code&gt;false&lt;/code&gt; other fields of &lt;code&gt;issueIndex&lt;/code&gt; can be not visible.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;countInDatabase&lt;/code&gt; - Count of issues found in database.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;countInIndex&lt;/code&gt; - Count of issues found while querying index.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;lastUpdatedInDatabase&lt;/code&gt; - Time of last update of issue found in database.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;lastUpdatedInIndex&lt;/code&gt; - Time of last update of issue found while querying index.&lt;/li&gt;  &lt;/ul&gt;  &lt;p/&gt;  &lt;code&gt;replicationQueues&lt;/code&gt;&#39;s map values can contain:  &lt;ul&gt;  &lt;li&gt;&lt;code&gt;lastConsumedOperation&lt;/code&gt; - Last executed index replication operation by current node from sending node&#39;s queue.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;lastConsumedOperation.id&lt;/code&gt; - Identifier of the operation.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;lastConsumedOperation.replicationTime&lt;/code&gt; - Time when the operation was sent to other nodes.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;lastOperationInQueue&lt;/code&gt; - Last index replication operation in sending node&#39;s queue.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;lastOperationInQueue.id&lt;/code&gt; - Identifier of the operation.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;lastOperationInQueue.replicationTime&lt;/code&gt; - Time when the operation was sent to other nodes.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;queueSize&lt;/code&gt; - Number of operations in queue from sending node to current node.&lt;/li&gt;  &lt;/ul&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIndexSummaryTest() throws ApiException {
        api.getIndexSummary();
        // TODO: test validations
    }

    /**
     * Returns a full representation of the issue for the given issue key.  &lt;p&gt;  An issue JSON consists of the issue key, a collection of fields,  a link to the workflow transition sub-resource, and (optionally) the HTML rendered values of any fields that support it  (e.g. if wiki syntax is enabled for the description or comments).  &lt;p&gt;  The &lt;code&gt;fields&lt;/code&gt; param (which can be specified multiple times) gives a comma-separated list of fields  to include in the response. This can be used to retrieve a subset of fields.  A particular field can be excluded by prefixing it with a minus.  &lt;p&gt;  By default, all (&lt;code&gt;*all&lt;/code&gt;) fields are returned in this get-issue resource. Note: the default is different  when doing a jql search -- the default there is just navigable fields (&lt;code&gt;*navigable&lt;/code&gt;).  &lt;ul&gt;  &lt;li&gt;&lt;code&gt;*all&lt;/code&gt; - include all fields&lt;/li&gt;  &lt;li&gt;&lt;code&gt;*navigable&lt;/code&gt; - include just navigable fields&lt;/li&gt;  &lt;li&gt;&lt;code&gt;summary,comment&lt;/code&gt; - include just the summary and comments&lt;/li&gt;  &lt;li&gt;&lt;code&gt;-comment&lt;/code&gt; - include everything except comments (the default is &lt;code&gt;*all&lt;/code&gt; for get-issue)&lt;/li&gt;  &lt;li&gt;&lt;code&gt;*all,-comment&lt;/code&gt; - include everything except comments&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;  The {@code properties} param is similar to {@code fields} and specifies a comma-separated list of issue  properties to include. Unlike {@code fields}, properties are not included by default. To include them all  send {@code ?properties&#x3D;*all}. You can also include only specified properties or exclude some properties  with a minus (-) sign.  &lt;p&gt;  &lt;ul&gt;  &lt;li&gt;{@code *all} - include all properties&lt;/li&gt;  &lt;li&gt;{@code *all, -prop1} - include all properties except {@code prop1} &lt;/li&gt;  &lt;li&gt;{@code prop1, prop1} - include {@code prop1} and {@code prop2} properties &lt;/li&gt;  &lt;/ul&gt;  &lt;/p&gt;  &lt;p/&gt;  JIRA will attempt to identify the issue by the &lt;code&gt;issueIdOrKey&lt;/code&gt; path parameter. This can be an issue id,  or an issue key. If the issue cannot be found via an exact match, JIRA will also look for the issue in a case-insensitive way, or  by looking to see if the issue was moved. In either of these cases, the request will proceed as normal (a 302 or other redirect  will &lt;b&gt;not&lt;/b&gt; be returned). The issue key contained in the response will indicate the current value of issue&#39;s key.  &lt;p/&gt;  The &lt;code&gt;expand&lt;/code&gt; param is used to include, hidden by default, parts of response. This can be used to include:  &lt;ul&gt;  &lt;li&gt;&lt;code&gt;renderedFields&lt;/code&gt; - field values in HTML format&lt;/li&gt;  &lt;li&gt;&lt;code&gt;names&lt;/code&gt; - display name of each field&lt;/li&gt;  &lt;li&gt;&lt;code&gt;schema&lt;/code&gt; - schema for each field which describes a type of the field&lt;/li&gt;  &lt;li&gt;&lt;code&gt;transitions&lt;/code&gt; - all possible transitions for the given issue&lt;/li&gt;  &lt;li&gt;&lt;code&gt;operations&lt;/code&gt; - all possibles operations which may be applied on issue&lt;/li&gt;  &lt;li&gt;&lt;code&gt;editmeta&lt;/code&gt; - information about how each field may be edited. It contains field&#39;s schema as well.&lt;/li&gt;  &lt;li&gt;&lt;code&gt;changelog&lt;/code&gt; - history of all changes of the given issue&lt;/li&gt;  &lt;li&gt;&lt;code&gt;versionedRepresentations&lt;/code&gt; -  REST representations of all fields. Some field may contain more recent versions. RESET representations are numbered.  The greatest number always represents the most recent version. It is recommended that the most recent version is used.  version for these fields which provide a more recent REST representation.  After including &lt;code&gt;versionedRepresentations&lt;/code&gt; \&quot;fields\&quot; field become hidden.&lt;/li&gt;  &lt;/ul&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssueTest() throws ApiException {
        String issueIdOrKey = null;
        String fields = null;
        String expand = null;
        String properties = null;
        api.getIssue(issueIdOrKey, fields, expand, properties);
        // TODO: test validations
    }

    /**
     * Returns a list of all issue types visible to the user
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssueAllTypesTest() throws ApiException {
        api.getIssueAllTypes();
        // TODO: test validations
    }

    /**
     * Returns an issue link with the specified id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssueLinkTest() throws ApiException {
        String linkId = null;
        api.getIssueLink(linkId);
        // TODO: test validations
    }

    /**
     * Returns for a given issue link type id all information about this issue link type.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssueLinkTypeTest() throws ApiException {
        String issueLinkTypeId = null;
        api.getIssueLinkType(issueLinkTypeId);
        // TODO: test validations
    }

    /**
     * Returns a list of available issue link types, if issue linking is enabled.  Each issue link type has an id, a name and a label for the outward and inward link relationship.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssueLinkTypesTest() throws ApiException {
        api.getIssueLinkTypes();
        // TODO: test validations
    }

    /**
     * Returns the default system columns for issue navigator. Admin permission will be required.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssueNavigatorDefaultColumnsTest() throws ApiException {
        api.getIssueNavigatorDefaultColumns();
        // TODO: test validations
    }

    /**
     * Returns suggested issues which match the auto-completion query for the user which executes this request. This REST  method will check the user&#39;s history and the user&#39;s browsing context and select this issues, which match the query.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssuePickerResourceTest() throws ApiException {
        String query = null;
        String currentJQL = null;
        String currentIssueKey = null;
        String currentProjectId = null;
        Boolean showSubTasks = null;
        Boolean showSubTaskParent = null;
        api.getIssuePickerResource(query, currentJQL, currentIssueKey, currentProjectId, showSubTasks, showSubTaskParent);
        // TODO: test validations
    }

    /**
     * Returns all issue security schemes that are defined.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssueSecuritySchemesTest() throws ApiException {
        api.getIssueSecuritySchemes();
        // TODO: test validations
    }

    /**
     * Returns the list of watchers for the issue with the given key.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssueWatchersTest() throws ApiException {
        String issueIdOrKey = null;
        api.getIssueWatchers(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Returns all work logs for an issue. &lt;br/&gt;  &lt;strong&gt;Note:&lt;/strong&gt; Work logs won&#39;t be returned if the Log work field is hidden for the project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssueWorklogTest() throws ApiException {
        String issueIdOrKey = null;
        api.getIssueWorklog(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Returns a full representation of the security level that has the given id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIssuesecuritylevelTest() throws ApiException {
        String id = null;
        api.getIssuesecuritylevel(id);
        // TODO: test validations
    }

    /**
     * Returns a &lt;a href&#x3D;\&quot;#pagination\&quot;&gt;paginated&lt;/a&gt; list of notification schemes. In order to access notification scheme, the calling user is  required to have permissions to administer at least one project associated with the requested notification scheme. Each scheme contains  a list of events and recipient configured to receive notifications for these events. Consumer should allow events without recipients to appear in response.  The list is ordered by the scheme&#39;s name.  Follow the documentation of /notificationscheme/{id} resource for all details about returned value.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getNotificationSchemesTest() throws ApiException {
        Long startAt = null;
        Integer maxResults = null;
        String expand = null;
        api.getNotificationSchemes(startAt, maxResults, expand);
        // TODO: test validations
    }

    /**
     * Returns the list of requirements for the current password policy. For example, \&quot;The password must have at least 10 characters.\&quot;,  \&quot;The password must not be similar to the user&#39;s name or email address.\&quot;, etc.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPasswordPolicyTest() throws ApiException {
        Boolean hasOldPassword = null;
        api.getPasswordPolicy(hasOldPassword);
        // TODO: test validations
    }

    /**
     * Returns a permission scheme identified by the given id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPermissionSchemeTest() throws ApiException {
        Long schemeId = null;
        String expand = null;
        api.getPermissionScheme(schemeId, expand);
        // TODO: test validations
    }

    /**
     * Returns a permission grant identified by the given id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPermissionSchemeGrantTest() throws ApiException {
        Long permissionId = null;
        Long schemeId = null;
        String expand = null;
        api.getPermissionSchemeGrant(permissionId, schemeId, expand);
        // TODO: test validations
    }

    /**
     * Returns all permission grants of the given permission scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPermissionSchemeGrantsTest() throws ApiException {
        Long schemeId = null;
        String expand = null;
        api.getPermissionSchemeGrants(schemeId, expand);
        // TODO: test validations
    }

    /**
     * Returns a list of all permission schemes.  &lt;p&gt;  By default only shortened beans are returned. If you want to include permissions of all the schemes,  then specify the &lt;b&gt;permissions&lt;/b&gt; expand parameter. Permissions will be included also if you specify  any other expand parameter.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPermissionSchemesTest() throws ApiException {
        String expand = null;
        api.getPermissionSchemes(expand);
        // TODO: test validations
    }

    /**
     * Returns all permissions in the system and whether the currently logged in user has them. You can optionally provide a specific context to get permissions for  (projectKey OR projectId OR issueKey OR issueId)  &lt;ul&gt;  &lt;li&gt; When no context supplied the project related permissions will return true if the user has that permission in ANY project &lt;/li&gt;  &lt;li&gt; If a project context is provided, project related permissions will return true if the user has the permissions in the specified project.  For permissions that are determined using issue data (e.g Current Assignee), true will be returned if the user meets the permission criteria in ANY issue in that project &lt;/li&gt;  &lt;li&gt; If an issue context is provided, it will return whether or not the user has each permission in that specific issue&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;  NB: The above means that for issue-level permissions (EDIT_ISSUE for example), hasPermission may be true when no context is provided, or when a project context is provided,  &lt;b&gt;but&lt;/b&gt; may be false for any given (or all) issues. This would occur (for example) if Reporters were given the EDIT_ISSUE permission. This is because  any user could be a reporter, except in the context of a concrete issue, where the reporter is known.  &lt;/p&gt;  &lt;p&gt;  Global permissions will still be returned for all scopes.  &lt;/p&gt;  &lt;p&gt;  Prior to version 6.4 this service returned project permissions with keys corresponding to com.atlassian.jira.security.Permissions.Permission constants.  Since 6.4 those keys are considered deprecated and this service returns system project permission keys corresponding to constants defined in com.atlassian.jira.permission.ProjectPermissions.  Permissions with legacy keys are still also returned for backwards compatibility, they are marked with an attribute deprecatedKey&#x3D;true.  The attribute is missing for project permissions with the current keys.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPermissionsTest() throws ApiException {
        String projectKey = null;
        String projectId = null;
        String issueKey = null;
        String issueId = null;
        api.getPermissions(projectKey, projectId, issueKey, issueId);
        // TODO: test validations
    }

    /**
     * Returns preference of the currently logged in user. Preference key must be provided as input parameter (key). The  value is returned exactly as it is. If key parameter is not provided or wrong - status code 404. If value is  found  - status code 200.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPreferenceTest() throws ApiException {
        String key = null;
        api.getPreference(key);
        // TODO: test validations
    }

    /**
     * Returns a list of all issue priorities.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPrioritiesTest() throws ApiException {
        api.getPriorities();
        // TODO: test validations
    }

    /**
     * Returns an issue priority.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPriorityTest() throws ApiException {
        String id = null;
        api.getPriority(id);
        // TODO: test validations
    }

    /**
     * Retrieves the progress of a single reindex request.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProgressTest() throws ApiException {
        Long requestId = null;
        api.getProgress(requestId);
        // TODO: test validations
    }

    /**
     * Retrieves the progress of a multiple reindex requests.  Only reindex requests that actually exist will be returned  in the results.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProgressBulkTest() throws ApiException {
        String requestId = null;
        api.getProgressBulk(requestId);
        // TODO: test validations
    }

    /**
     * Contains a representation of a project category in JSON format.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProjectCategoryByIdTest() throws ApiException {
        Long id = null;
        api.getProjectCategoryById(id);
        // TODO: test validations
    }

    /**
     * Contains a full representation of a the specified project&#39;s components.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProjectComponentsTest() throws ApiException {
        String projectIdOrKey = null;
        api.getProjectComponents(projectIdOrKey);
        // TODO: test validations
    }

    /**
     * Returns the details for a given project role in a project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProjectRoleTest() throws ApiException {
        String projectIdOrKey = null;
        Long id = null;
        api.getProjectRole(projectIdOrKey, id);
        // TODO: test validations
    }

    /**
     * Gets default actors for the given role.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProjectRoleActorsForRoleTest() throws ApiException {
        Long id = null;
        api.getProjectRoleActorsForRole(id);
        // TODO: test validations
    }

    /**
     * Get a specific ProjectRole available in JIRA.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProjectRolesByIdTest() throws ApiException {
        Long id = null;
        api.getProjectRolesById(id);
        // TODO: test validations
    }

    /**
     * Returns the project type with the given key.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProjectTypeByKeyTest() throws ApiException {
        String projectTypeKey = null;
        api.getProjectTypeByKey(projectTypeKey);
        // TODO: test validations
    }

    /**
     * Contains a full representation of a the specified project&#39;s versions.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProjectVersionsTest() throws ApiException {
        String projectIdOrKey = null;
        String expand = null;
        api.getProjectVersions(projectIdOrKey, expand);
        // TODO: test validations
    }

    /**
     * Returns all versions for the specified project. Results are &lt;a href&#x3D;\&quot;#pagination\&quot;&gt;paginated&lt;/a&gt;.  &lt;p&gt;  Results can be ordered by the following fields:  &lt;ul&gt;  &lt;li&gt;sequence&lt;/li&gt;  &lt;li&gt;name&lt;/li&gt;  &lt;li&gt;startDate&lt;/li&gt;  &lt;li&gt;releaseDate&lt;/li&gt;  &lt;/ul&gt;  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProjectVersionsPaginatedTest() throws ApiException {
        String projectIdOrKey = null;
        Long startAt = null;
        Integer maxResults = null;
        String orderBy = null;
        String expand = null;
        api.getProjectVersionsPaginated(projectIdOrKey, startAt, maxResults, orderBy, expand);
        // TODO: test validations
    }

    /**
     * Return the property or properties associated with a transition.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPropertiesTest() throws ApiException {
        Long id = null;
        Boolean includeReservedKeys = null;
        String key = null;
        String workflowName = null;
        String workflowMode = null;
        api.getProperties(id, includeReservedKeys, key, workflowName, workflowMode);
        // TODO: test validations
    }

    /**
     * Returns the keys of all properties for the issue type identified by the id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPropertyKeysTest() throws ApiException {
        String issueTypeId = null;
        api.getPropertyKeys(issueTypeId);
        // TODO: test validations
    }

    /**
     * Returns auditing records filtered using provided parameters
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getRecordsTest() throws ApiException {
        Integer offset = null;
        Integer limit = null;
        String filter = null;
        String from = null;
        String to = null;
        String projectIds = null;
        String userIds = null;
        api.getRecords(offset, limit, filter, from, to, projectIds, userIds);
        // TODO: test validations
    }

    /**
     * Returns information on the system reindexes.  If a reindex is currently taking place then information about this reindex is returned.  If there is no active index task, then returns information about the latest reindex task run, otherwise returns a 404  indicating that no reindex has taken place.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getReindexInfoTest() throws ApiException {
        Long taskId = null;
        api.getReindexInfo(taskId);
        // TODO: test validations
    }

    /**
     * Returns information on the system reindexes.  If a reindex is currently taking place then information about this reindex is returned.  If there is no active index task, then returns information about the latest reindex task run, otherwise returns a 404  indicating that no reindex has taken place.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getReindexProgressTest() throws ApiException {
        Long taskId = null;
        api.getReindexProgress(taskId);
        // TODO: test validations
    }

    /**
     * Get the remote issue link with the given id on the issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getRemoteIssueLinkByIdTest() throws ApiException {
        String linkId = null;
        String issueIdOrKey = null;
        api.getRemoteIssueLinkById(linkId, issueIdOrKey);
        // TODO: test validations
    }

    /**
     * A REST sub-resource representing the remote issue links on the issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getRemoteIssueLinksTest() throws ApiException {
        String issueIdOrKey = null;
        String globalId = null;
        api.getRemoteIssueLinks(issueIdOrKey, globalId);
        // TODO: test validations
    }

    /**
     * A REST sub-resource representing a remote version link
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getRemoteVersionLinkTest() throws ApiException {
        String versionId = null;
        String globalId = null;
        api.getRemoteVersionLink(versionId, globalId);
        // TODO: test validations
    }

    /**
     * Returns the remote version links for a given global ID.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getRemoteVersionLinksTest() throws ApiException {
        String globalId = null;
        api.getRemoteVersionLinks(globalId);
        // TODO: test validations
    }

    /**
     * Returns the remote version links associated with the given version ID.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getRemoteVersionLinksByVersionIdTest() throws ApiException {
        String versionId = null;
        api.getRemoteVersionLinksByVersionId(versionId);
        // TODO: test validations
    }

    /**
     * Returns a resolution.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getResolutionTest() throws ApiException {
        String id = null;
        api.getResolution(id);
        // TODO: test validations
    }

    /**
     * Returns a list of all resolutions.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getResolutionsTest() throws ApiException {
        api.getResolutions();
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSchemeAttributeTest() throws ApiException {
        Long permissionSchemeId = null;
        String attributeKey = null;
        api.getSchemeAttribute(permissionSchemeId, attributeKey);
        // TODO: test validations
    }

    /**
     * Returns all security levels for the project that the current logged in user has access to.  If the user does not have the Set Issue Security permission, the list will be empty.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSecurityLevelsForProjectTest() throws ApiException {
        String projectKeyOrId = null;
        api.getSecurityLevelsForProject(projectKeyOrId);
        // TODO: test validations
    }

    /**
     * Returns general information about the current JIRA server.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getServerInfoTest() throws ApiException {
        Boolean doHealthCheck = null;
        api.getServerInfo(doHealthCheck);
        // TODO: test validations
    }

    /**
     * Returns a single share permission of the given filter.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSharePermissionTest() throws ApiException {
        Long permissionId = null;
        Long id = null;
        api.getSharePermission(permissionId, id);
        // TODO: test validations
    }

    /**
     * Returns all share permissions of the given filter.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSharePermissionsTest() throws ApiException {
        Long id = null;
        api.getSharePermissions(id);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getStateTest() throws ApiException {
        api.getState();
        // TODO: test validations
    }

    /**
     * Returns a full representation of the Status having the given id or name.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getStatusTest() throws ApiException {
        String idOrName = null;
        api.getStatus(idOrName);
        // TODO: test validations
    }

    /**
     * Returns a list of all status categories
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getStatusCategoriesTest() throws ApiException {
        api.getStatusCategories();
        // TODO: test validations
    }

    /**
     * Returns a full representation of the StatusCategory having the given id or key
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getStatusCategoryTest() throws ApiException {
        String idOrKey = null;
        api.getStatusCategory(idOrKey);
        // TODO: test validations
    }

    /**
     * Returns a list of all statuses
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getStatusesTest() throws ApiException {
        api.getStatuses();
        // TODO: test validations
    }

    /**
     * Returns an issue&#39;s subtask list
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSubTasksTest() throws ApiException {
        String issueIdOrKey = null;
        api.getSubTasks(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Get a list of the transitions possible for this issue by the current user, along with fields that are required and their types.  &lt;p/&gt;  Fields will only be returned if &lt;code&gt;expand&#x3D;transitions.fields&lt;/code&gt;.  &lt;p/&gt;  The fields in the metadata correspond to the fields in the transition screen for that transition.  Fields not in the screen will not be in the metadata.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getTransitionsTest() throws ApiException {
        String issueIdOrKey = null;
        String transitionId = null;
        api.getTransitions(issueIdOrKey, transitionId);
        // TODO: test validations
    }

    /**
     * Returns the result of the last upgrade task.   Returns {@link javax.ws.rs.core.Response#seeOther(java.net.URI)} if still running.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUpgradeResultTest() throws ApiException {
        api.getUpgradeResult();
        // TODO: test validations
    }

    /**
     * This resource returns a &lt;a href&#x3D;\&quot;#pagination\&quot;&gt;paginated&lt;/a&gt; list of users who are members of the specified group and its subgroups.  Users in the page are ordered by user names. User of this resource is required to have sysadmin or admin permissions.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUsersFromGroupTest() throws ApiException {
        String groupname = null;
        Boolean includeInactiveUsers = null;
        Long startAt = null;
        Integer maxResults = null;
        api.getUsersFromGroup(groupname, includeInactiveUsers, startAt, maxResults);
        // TODO: test validations
    }

    /**
     * Returns a project version.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getVersionTest() throws ApiException {
        String id = null;
        String expand = null;
        api.getVersion(id, expand);
        // TODO: test validations
    }

    /**
     * Returns a bean containing the number of fixed in and affected issues for the given version.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getVersionRelatedIssuesTest() throws ApiException {
        String id = null;
        api.getVersionRelatedIssues(id);
        // TODO: test validations
    }

    /**
     * Returns the number of unresolved issues for the given version
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getVersionUnresolvedIssuesTest() throws ApiException {
        String id = null;
        api.getVersionUnresolvedIssues(id);
        // TODO: test validations
    }

    /**
     * A REST sub-resource representing the voters on the issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getVotesTest() throws ApiException {
        String issueIdOrKey = null;
        api.getVotes(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Returns the workflow mappings or requested mapping to the caller for the passed scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWorkflowTest() throws ApiException {
        Long id = null;
        String workflowName = null;
        Boolean returnDraftIfExists = null;
        api.getWorkflow(id, workflowName, returnDraftIfExists);
        // TODO: test validations
    }

    /**
     * Returns a specific worklog. &lt;br/&gt;  &lt;strong&gt;Note:&lt;/strong&gt; The work log won&#39;t be returned if the Log work field is hidden for the project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWorklogTest() throws ApiException {
        String issueIdOrKey = null;
        String id = null;
        api.getWorklog(issueIdOrKey, id);
        // TODO: test validations
    }

    /**
     * Returns worklogs for given worklog ids. Only worklogs to which the calling user has permissions, will be included in the result.  The returns set of worklogs is limited to 1000 elements.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWorklogsForIdsTest() throws ApiException {
        api.getWorklogsForIds();
        // TODO: test validations
    }

    /**
     * Creates an issue link between two issues.  The user requires the link issue permission for the issue which will be linked to another issue.  The specified link type in the request is used to create the link and will create a link from the first issue  to the second issue using the outward description. It also create a link from the second issue to the first issue using the  inward description of the issue link type.  It will add the supplied comment to the first issue. The comment can have a restriction who can view it.  If group is specified, only users of this group can view this comment, if roleLevel is specified only users who have the specified role can view this comment.  The user who creates the issue link needs to belong to the specified group or have the specified role.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void linkIssuesTest() throws ApiException {
        api.linkIssues();
        // TODO: test validations
    }

    /**
     * Creates a new session for a user in JIRA. Once a session has been successfully created it can be used to access  any of JIRA&#39;s remote APIs and also the web UI by passing the appropriate HTTP Cookie header.  &lt;p&gt;  Note that it is generally preferrable to use HTTP BASIC authentication with the REST API. However, this resource  may be used to mimic the behaviour of JIRA&#39;s log-in page (e.g. to display log-in errors to a user).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void loginTest() throws ApiException {
        api.login();
        // TODO: test validations
    }

    /**
     * Logs the current user out of JIRA, destroying the existing session, if any.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void logoutTest() throws ApiException {
        api.logout();
        // TODO: test validations
    }

    /**
     * Merge versions
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void mergeTest() throws ApiException {
        String moveIssuesTo = null;
        String id = null;
        api.merge(moveIssuesTo, id);
        // TODO: test validations
    }

    /**
     * Moves field on the given tab
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void moveFieldTest() throws ApiException {
        Long screenId = null;
        Long tabId = null;
        String id = null;
        api.moveField(screenId, tabId, id);
        // TODO: test validations
    }

    /**
     * Reorders an issue&#39;s subtasks by moving the subtask at index \&quot;from\&quot;  to index \&quot;to\&quot;.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void moveSubTasksTest() throws ApiException {
        String issueIdOrKey = null;
        api.moveSubTasks(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Moves tab position
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void moveTabTest() throws ApiException {
        Long screenId = null;
        Long tabId = null;
        Integer pos = null;
        api.moveTab(screenId, tabId, pos);
        // TODO: test validations
    }

    /**
     * Modify a version&#39;s sequence within a project.  &lt;p/&gt;  The move version bean has 2 alternative field value pairs:  &lt;dl&gt;  &lt;dt&gt;position&lt;/dt&gt;&lt;dd&gt;An absolute position, which may have a value of &#39;First&#39;, &#39;Last&#39;, &#39;Earlier&#39; or &#39;Later&#39;&lt;/dd&gt;  &lt;dt&gt;after&lt;/dt&gt;&lt;dd&gt;A version to place this version after.  The value should be the self link of another version&lt;/dd&gt;  &lt;/dl&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void moveVersionTest() throws ApiException {
        String id = null;
        api.moveVersion(id);
        // TODO: test validations
    }

    /**
     * Sends a notification (email) to the list or recipients defined in the request.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void notifyTest() throws ApiException {
        String issueIdOrKey = null;
        api.notify(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Partially updates a roles name or description.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void partialUpdateProjectRoleTest() throws ApiException {
        Long id = null;
        api.partialUpdateProjectRole(id);
        // TODO: test validations
    }

    /**
     * Returns a list of statements explaining why the password policy would disallow a proposed password for a new user.  &lt;p&gt;  You can use this method to test the password policy validation. This could be done prior to an action   where a new user and related password are created, using methods like the ones in   &lt;a href&#x3D;\&quot;https://docs.atlassian.com/jira/latest/com/atlassian/jira/bc/user/UserService.html\&quot;&gt;UserService&lt;/a&gt;.        For example, you could use this to validate a password in a create user form in the user interface, as the user enters it.&lt;br/&gt;  The username and new password must be not empty to perform the validation.&lt;br/&gt;  Note, this method will help you validate against the policy only. It won&#39;t check any other validations that might be performed   when creating a new user, e.g. checking whether a user with the same name already exists.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void policyCheckCreateUserTest() throws ApiException {
        api.policyCheckCreateUser();
        // TODO: test validations
    }

    /**
     * Returns a list of statements explaining why the password policy would disallow a proposed new password for a user with an existing password.  &lt;p&gt;  You can use this method to test the password policy validation. This could be done prior to an action where the password   is actually updated, using methods like &lt;a href&#x3D;\&quot;https://docs.atlassian.com/jira/latest/com/atlassian/jira/web/action/user/ChangePassword.html\&quot;&gt;ChangePassword&lt;/a&gt;        or &lt;a href&#x3D;\&quot;https://docs.atlassian.com/jira/latest/com/atlassian/jira/web/action/user/ResetPassword.html\&quot;&gt;ResetPassword&lt;/a&gt;.   For example, you could use this to validate a password in a change password form in the user interface, as the user enters it.&lt;br/&gt;  The user must exist and the username and new password must be not empty, to perform the validation.&lt;br/&gt;  Note, this method will help you validate against the policy only. It won&#39;t check any other validations that might be performed   when submitting a password change/reset request, e.g. verifying whether the old password is valid.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void policyCheckUpdateUserTest() throws ApiException {
        api.policyCheckUpdateUser();
        // TODO: test validations
    }

    /**
     * Executes any pending reindex requests.  Returns a JSON array containing the IDs of the reindex requests  that are being processed.  Execution is asynchronous - progress of the returned tasks can be monitored through  other REST calls.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void processRequestsTest() throws ApiException {
        api.processRequests();
        // TODO: test validations
    }

    /**
     * Updates the ApplicationRole with the passed data. Only the groups and default groups setting of the  role may be updated. Requests to change the key or the name of the role will be silently ignored.  &lt;p&gt;  Optional: If versionHash is passed through the If-Match header the request will be rejected if not the  same as server
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void putTest() throws ApiException {
        String key = null;
        String ifMatch = null;
        api.put(key, ifMatch);
        // TODO: test validations
    }

    /**
     * Updates the ApplicationRoles with the passed data if the version hash is the same as the server.  Only the groups and default groups setting of the role may be updated. Requests to change the key  or the name of the role will be silently ignored. It is acceptable to pass only the roles that are updated  as roles that are present in the server but not in data to update with, will not be deleted.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void putBulkTest() throws ApiException {
        String ifMatch = null;
        api.putBulk(ifMatch);
        // TODO: test validations
    }

    /**
     * Kicks off a reindex.  Need Admin permissions to perform this reindex.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void reindexTest() throws ApiException {
        String type = null;
        Boolean indexComments = null;
        Boolean indexChangeHistory = null;
        Boolean indexWorklogs = null;
        api.reindex(type, indexComments, indexChangeHistory, indexWorklogs);
        // TODO: test validations
    }

    /**
     * Reindexes one or more individual issues.  Indexing is performed synchronously - the call returns when indexing of  the issues has completed or a failure occurs.  &lt;p&gt;  Use either explicitly specified issue IDs or a JQL query to select issues to reindex.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void reindexIssuesTest() throws ApiException {
        String issueId = null;
        Boolean indexComments = null;
        Boolean indexChangeHistory = null;
        Boolean indexWorklogs = null;
        api.reindexIssues(issueId, indexComments, indexChangeHistory, indexWorklogs);
        // TODO: test validations
    }

    /**
     * This method invalidates the any current WebSudo session.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void releaseTest() throws ApiException {
        api.release();
        // TODO: test validations
    }

    /**
     * Remove an attachment from an issue.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeAttachmentTest() throws ApiException {
        String id = null;
        api.removeAttachment(id);
        // TODO: test validations
    }

    /**
     * Removes field from given tab
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeFieldTest() throws ApiException {
        Long screenId = null;
        Long tabId = null;
        String id = null;
        api.removeField(screenId, tabId, id);
        // TODO: test validations
    }

    /**
     * Deletes a group by given group parameter.  &lt;p&gt;  Returns no content
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeGroupTest() throws ApiException {
        String groupname = null;
        String swapGroup = null;
        api.removeGroup(groupname, swapGroup);
        // TODO: test validations
    }

    /**
     * Removes preference of the currently logged in user. Preference key must be provided as input parameters (key). If  key parameter is not provided or wrong - status code 404. If preference is unset - status code 204.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removePreferenceTest() throws ApiException {
        String key = null;
        api.removePreference(key);
        // TODO: test validations
    }

    /**
     * Delete a project category.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeProjectCategoryTest() throws ApiException {
        Long id = null;
        api.removeProjectCategory(id);
        // TODO: test validations
    }

    /**
     * Removes user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeUserTest() throws ApiException {
        String username = null;
        String key = null;
        api.removeUser(username, key);
        // TODO: test validations
    }

    /**
     * Remove user from given application. Admin permission will be required to perform this operation.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeUserFromApplicationTest() throws ApiException {
        String username = null;
        String applicationKey = null;
        api.removeUserFromApplication(username, applicationKey);
        // TODO: test validations
    }

    /**
     * Removes given user from a group.  &lt;p&gt;  Returns no content
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeUserFromGroupTest() throws ApiException {
        String groupname = null;
        String username = null;
        api.removeUserFromGroup(groupname, username);
        // TODO: test validations
    }

    /**
     * Remove your vote from an issue. (i.e. \&quot;unvote\&quot;)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeVoteTest() throws ApiException {
        String issueIdOrKey = null;
        api.removeVote(issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Removes a user from an issue&#39;s watcher list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeWatcherTest() throws ApiException {
        String issueIdOrKey = null;
        String username = null;
        api.removeWatcher(issueIdOrKey, username);
        // TODO: test validations
    }

    /**
     * Renames tab on given screen
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void renameTabTest() throws ApiException {
        Long screenId = null;
        Long tabId = null;
        api.renameTab(screenId, tabId);
        // TODO: test validations
    }

    /**
     * Runs any pending delayed upgrade tasks.  Need Admin permissions to do this.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void runUpgradesNowTest() throws ApiException {
        api.runUpgradesNow();
        // TODO: test validations
    }

    /**
     * Searches for issues using JQL.  &lt;p&gt;  &lt;b&gt;Sorting&lt;/b&gt;  the &lt;code&gt;jql&lt;/code&gt; parameter is a full &lt;a href&#x3D;\&quot;http://confluence.atlassian.com/display/JIRA/Advanced+Searching\&quot;&gt;JQL&lt;/a&gt;  expression, and includes an &lt;code&gt;ORDER BY&lt;/code&gt; clause.  &lt;/p&gt;  &lt;p&gt;  The &lt;code&gt;fields&lt;/code&gt; param (which can be specified multiple times) gives a comma-separated list of fields  to include in the response. This can be used to retrieve a subset of fields.  A particular field can be excluded by prefixing it with a minus.  &lt;p&gt;  By default, only navigable (&lt;code&gt;*navigable&lt;/code&gt;) fields are returned in this search resource. Note: the default is different  in the get-issue resource -- the default there all fields (&lt;code&gt;*all&lt;/code&gt;).  &lt;ul&gt;  &lt;li&gt;&lt;code&gt;*all&lt;/code&gt; - include all fields&lt;/li&gt;  &lt;li&gt;&lt;code&gt;*navigable&lt;/code&gt; - include just navigable fields&lt;/li&gt;  &lt;li&gt;&lt;code&gt;summary,comment&lt;/code&gt; - include just the summary and comments&lt;/li&gt;  &lt;li&gt;&lt;code&gt;-description&lt;/code&gt; - include navigable fields except the description (the default is &lt;code&gt;*navigable&lt;/code&gt; for search)&lt;/li&gt;  &lt;li&gt;&lt;code&gt;*all,-comment&lt;/code&gt; - include everything except comments&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;  &lt;/p&gt;  &lt;p&gt;&lt;b&gt;GET vs POST:&lt;/b&gt;  If the JQL query is too large to be encoded as a query param you should instead  POST to this resource.  &lt;/p&gt;  &lt;p&gt;  &lt;b&gt;Expanding Issues in the Search Result:&lt;/b&gt;  It is possible to expand the issues returned by directly specifying the expansion on the expand parameter passed  in to this resources.  &lt;/p&gt;  &lt;p&gt;  For instance, to expand the &amp;quot;changelog&amp;quot; for all the issues on the search result, it is neccesary to  specify &amp;quot;changelog&amp;quot; as one of the values to expand.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void searchTest() throws ApiException {
        String jql = null;
        Integer startAt = null;
        Integer maxResults = null;
        Boolean validateQuery = null;
        String fields = null;
        String expand = null;
        api.search(jql, startAt, maxResults, validateQuery, fields, expand);
        // TODO: test validations
    }

    /**
     * Performs a search using JQL.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void searchUsingSearchRequestTest() throws ApiException {
        api.searchUsingSearchRequest();
        // TODO: test validations
    }

    /**
     * Updates a project role to include the specified actors (users or groups).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setActorsTest() throws ApiException {
        String projectIdOrKey = null;
        Long id = null;
        api.setActors(projectIdOrKey, id);
        // TODO: test validations
    }

    /**
     * Sets the base URL that is configured for this JIRA instance.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setBaseURLTest() throws ApiException {
        api.setBaseURL();
        // TODO: test validations
    }

    /**
     * Sets the default share scope of the logged-in user. Available values are GLOBAL and PRIVATE.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setDefaultShareScopeTest() throws ApiException {
        api.setDefaultShareScope();
        // TODO: test validations
    }

    /**
     * Set the issue type mapping for the passed draft scheme.  &lt;p/&gt;  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that  the draft should be created/updated when the actual scheme cannot be edited.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setDraftIssueTypeTest() throws ApiException {
        String issueType = null;
        Long id = null;
        api.setDraftIssueType(issueType, id);
        // TODO: test validations
    }

    /**
     * Sets the default system columns for issue navigator. Admin permission will be required.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setIssueNavigatorDefaultColumnsTest() throws ApiException {
        api.setIssueNavigatorDefaultColumns();
        // TODO: test validations
    }

    /**
     * Set the issue type mapping for the passed scheme.  &lt;p/&gt;  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that  the draft should be created/updated when the actual scheme cannot be edited.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setIssueTypeTest() throws ApiException {
        String issueType = null;
        Long id = null;
        api.setIssueType(issueType, id);
        // TODO: test validations
    }

    /**
     * Sets preference of the currently logged in user. Preference key must be provided as input parameters (key). Value  must be provided as post body. If key or value parameter is not provided - status code 404. If preference is set  - status code 204.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setPreferenceTest() throws ApiException {
        String key = null;
        api.setPreference(key);
        // TODO: test validations
    }

    /**
     * Modify an application property via PUT. The \&quot;value\&quot; field present in the PUT will override the existing value.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setPropertyViaRestfulTableTest() throws ApiException {
        String id = null;
        api.setPropertyViaRestfulTable(id);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setReadyToUpgradeTest() throws ApiException {
        api.setReadyToUpgrade();
        // TODO: test validations
    }

    /**
     * Updates or inserts the attribute for a permission scheme specified by permission scheme id.  The attribute consists of the key and the value. The value will be converted to Boolean using Boolean#valueOf.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setSchemeAttributeTest() throws ApiException {
        Long permissionSchemeId = null;
        String key = null;
        api.setSchemeAttribute(permissionSchemeId, key);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void startTest() throws ApiException {
        api.start();
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void stopTest() throws ApiException {
        api.stop();
        // TODO: test validations
    }

    /**
     * Creates temporary avatar
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void storeTemporaryAvatarTest() throws ApiException {
        String type = null;
        String filename = null;
        Long size = null;
        api.storeTemporaryAvatar(type, filename, size);
        // TODO: test validations
    }

    /**
     * Update the passed workflow scheme.  &lt;p/&gt;  The body of the request is a representation of the workflow scheme. Values not passed are assumed to indicate  no change for that field.  &lt;p/&gt;  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that the draft  should be created and/or updated when the actual scheme cannot be edited (e.g. when the scheme is being used by  a project). Values not appearing the body will not be touched.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateTest() throws ApiException {
        Long id = null;
        api.update(id);
        // TODO: test validations
    }

    /**
     * Updates an existing comment using its JSON representation.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateCommentTest() throws ApiException {
        String issueIdOrKey = null;
        String id = null;
        String expand = null;
        api.updateComment(issueIdOrKey, id, expand);
        // TODO: test validations
    }

    /**
     * Modify a component via PUT. Any fields present in the PUT will override existing values. As a convenience, if a field  is not present, it is silently ignored.  &lt;p&gt;  If leadUserName is an empty string (\&quot;\&quot;) the component lead will be removed.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateComponentTest() throws ApiException {
        String id = null;
        api.updateComponent(id);
        // TODO: test validations
    }

    /**
     * Set the default workflow for the passed workflow scheme.  &lt;p/&gt;  The passed representation can have its  updateDraftIfNeeded flag set to true to indicate that the draft should be created/updated when the actual scheme  cannot be edited.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateDefaultTest() throws ApiException {
        Long id = null;
        api.updateDefault(id);
        // TODO: test validations
    }

    /**
     * Update a draft workflow scheme. The draft will created if necessary.  &lt;p/&gt;  The body is a representation of the workflow scheme. Values not passed are assumed to indicate no change for that field.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateDraftTest() throws ApiException {
        Long id = null;
        api.updateDraft(id);
        // TODO: test validations
    }

    /**
     * Set the default workflow for the passed draft workflow scheme.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateDraftDefaultTest() throws ApiException {
        Long id = null;
        api.updateDraftDefault(id);
        // TODO: test validations
    }

    /**
     * Update the draft scheme to include the passed mapping.  &lt;p/&gt;  The body is a representation of the workflow mapping.  Values not passed are assumed to indicate no change for that field.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateDraftWorkflowMappingTest() throws ApiException {
        Long id = null;
        String workflowName = null;
        api.updateDraftWorkflowMapping(id, workflowName);
        // TODO: test validations
    }

    /**
     * Update the specified issue link type.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateIssueLinkTypeTest() throws ApiException {
        String issueLinkTypeId = null;
        api.updateIssueLinkType(issueLinkTypeId);
        // TODO: test validations
    }

    /**
     * Updates the specified issue type from a JSON representation.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateIssueTypeTest() throws ApiException {
        String id = null;
        api.updateIssueType(id);
        // TODO: test validations
    }

    /**
     * Updates a permission scheme.  &lt;p&gt;  If the permissions list is present then it will be set in the permission scheme, which basically means it will overwrite any permission grants that  existed in the permission scheme. Sending an empty list will remove all permission grants from the permission scheme.  &lt;/p&gt;  &lt;p&gt;  To update just the name and description, do not send permissions list at all.  &lt;/p&gt;  &lt;p&gt;  To add or remove a single permission grant instead of updating the whole list at once use the &lt;b&gt;{schemeId}/permission/&lt;/b&gt; resource.  &lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updatePermissionSchemeTest() throws ApiException {
        Long schemeId = null;
        String expand = null;
        api.updatePermissionScheme(schemeId, expand);
        // TODO: test validations
    }

    /**
     * Updates a project.  &lt;p&gt;  Only non null values sent in JSON will be updated in the project.&lt;/p&gt;  &lt;p&gt;  Values available for the assigneeType field are: \&quot;PROJECT_LEAD\&quot; and \&quot;UNASSIGNED\&quot;.&lt;/p&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateProjectTest() throws ApiException {
        String projectIdOrKey = null;
        String expand = null;
        api.updateProject(projectIdOrKey, expand);
        // TODO: test validations
    }

    /**
     * Modify a project category via PUT. Any fields present in the PUT will override existing values. As a convenience, if a field  is not present, it is silently ignored.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateProjectCategoryTest() throws ApiException {
        Long id = null;
        api.updateProjectCategory(id);
        // TODO: test validations
    }

    /**
     * Updates the type of a project.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateProjectTypeTest() throws ApiException {
        String projectIdOrKey = null;
        String newProjectTypeKey = null;
        api.updateProjectType(projectIdOrKey, newProjectTypeKey);
        // TODO: test validations
    }

    /**
     * Update/add new property to a transition. Trying to update a property that does  not exist will result in a new property being added.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updatePropertyTest() throws ApiException {
        Long id = null;
        String key = null;
        String workflowName = null;
        String workflowMode = null;
        api.updateProperty(id, key, workflowName, workflowMode);
        // TODO: test validations
    }

    /**
     * Updates a remote issue link from a JSON representation. Any fields not provided are set to null.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateRemoteIssueLinkTest() throws ApiException {
        String linkId = null;
        String issueIdOrKey = null;
        api.updateRemoteIssueLink(linkId, issueIdOrKey);
        // TODO: test validations
    }

    /**
     * Modify a version via PUT. Any fields present in the PUT will override existing values. As a convenience, if a field  is not present, it is silently ignored.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateVersionTest() throws ApiException {
        String id = null;
        api.updateVersion(id);
        // TODO: test validations
    }

    /**
     * Update the scheme to include the passed mapping.  &lt;p/&gt;  The body is a representation of the workflow mapping.  Values not passed are assumed to indicate no change for that field.  &lt;p/&gt;  The passed representation can have its updateDraftIfNeeded flag set to true to indicate that the draft  should be created/updated when the actual scheme cannot be edited.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateWorkflowMappingTest() throws ApiException {
        Long id = null;
        String workflowName = null;
        api.updateWorkflowMapping(id, workflowName);
        // TODO: test validations
    }

    /**
     * Updates an existing worklog entry.  &lt;p&gt;Note that:&lt;/p&gt;   &lt;ul&gt;       &lt;li&gt;Fields possible for editing are: comment, visibility, started, timeSpent and timeSpentSeconds.&lt;/li&gt;       &lt;li&gt;Either timeSpent or timeSpentSeconds can be set.&lt;/li&gt;       &lt;li&gt;Fields which are not set will not be updated.&lt;/li&gt;       &lt;li&gt;For a request to be valid, it has to have at least one field change.&lt;/li&gt;   &lt;/ul&gt;
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateWorklogTest() throws ApiException {
        String issueIdOrKey = null;
        String id = null;
        String adjustEstimate = null;
        String newEstimate = null;
        api.updateWorklog(issueIdOrKey, id, adjustEstimate, newEstimate);
        // TODO: test validations
    }

    /**
     * @throws ApiException if the Api call fails
     */
    @Test
    public void validateTest() throws ApiException {
        api.validate();
        // TODO: test validations
    }

}
