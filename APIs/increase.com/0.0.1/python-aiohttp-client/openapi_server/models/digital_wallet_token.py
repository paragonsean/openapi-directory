# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class DigitalWalletToken(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, card_id: str=None, card_profile_id: str=None, decision: str=None, digital_wallet: str=None):
        """DigitalWalletToken - a model defined in OpenAPI

        :param card_id: The card_id of this DigitalWalletToken.
        :param card_profile_id: The card_profile_id of this DigitalWalletToken.
        :param decision: The decision of this DigitalWalletToken.
        :param digital_wallet: The digital_wallet of this DigitalWalletToken.
        """
        self.openapi_types = {
            'card_id': str,
            'card_profile_id': str,
            'decision': str,
            'digital_wallet': str
        }

        self.attribute_map = {
            'card_id': 'card_id',
            'card_profile_id': 'card_profile_id',
            'decision': 'decision',
            'digital_wallet': 'digital_wallet'
        }

        self._card_id = card_id
        self._card_profile_id = card_profile_id
        self._decision = decision
        self._digital_wallet = digital_wallet

    @classmethod
    def from_dict(cls, dikt: dict) -> 'DigitalWalletToken':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Digital_Wallet_Token of this DigitalWalletToken.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def card_id(self):
        """Gets the card_id of this DigitalWalletToken.

        The identifier of the Card that is being tokenized.

        :return: The card_id of this DigitalWalletToken.
        :rtype: str
        """
        return self._card_id

    @card_id.setter
    def card_id(self, card_id):
        """Sets the card_id of this DigitalWalletToken.

        The identifier of the Card that is being tokenized.

        :param card_id: The card_id of this DigitalWalletToken.
        :type card_id: str
        """
        if card_id is None:
            raise ValueError("Invalid value for `card_id`, must not be `None`")

        self._card_id = card_id

    @property
    def card_profile_id(self):
        """Gets the card_profile_id of this DigitalWalletToken.

        The identifier of the Card Profile that was set via the real time decision. This will be null until the real time decision is responded to or if the real time decision did not set a card profile.

        :return: The card_profile_id of this DigitalWalletToken.
        :rtype: str
        """
        return self._card_profile_id

    @card_profile_id.setter
    def card_profile_id(self, card_profile_id):
        """Sets the card_profile_id of this DigitalWalletToken.

        The identifier of the Card Profile that was set via the real time decision. This will be null until the real time decision is responded to or if the real time decision did not set a card profile.

        :param card_profile_id: The card_profile_id of this DigitalWalletToken.
        :type card_profile_id: str
        """
        if card_profile_id is None:
            raise ValueError("Invalid value for `card_profile_id`, must not be `None`")

        self._card_profile_id = card_profile_id

    @property
    def decision(self):
        """Gets the decision of this DigitalWalletToken.

        Whether or not the provisioning request was approved. This will be null until the real time decision is responded to.

        :return: The decision of this DigitalWalletToken.
        :rtype: str
        """
        return self._decision

    @decision.setter
    def decision(self, decision):
        """Sets the decision of this DigitalWalletToken.

        Whether or not the provisioning request was approved. This will be null until the real time decision is responded to.

        :param decision: The decision of this DigitalWalletToken.
        :type decision: str
        """
        allowed_values = [None,"approve", "decline"]  # noqa: E501
        if decision not in allowed_values:
            raise ValueError(
                "Invalid value for `decision` ({0}), must be one of {1}"
                .format(decision, allowed_values)
            )

        self._decision = decision

    @property
    def digital_wallet(self):
        """Gets the digital_wallet of this DigitalWalletToken.

        The digital wallet app being used.

        :return: The digital_wallet of this DigitalWalletToken.
        :rtype: str
        """
        return self._digital_wallet

    @digital_wallet.setter
    def digital_wallet(self, digital_wallet):
        """Sets the digital_wallet of this DigitalWalletToken.

        The digital wallet app being used.

        :param digital_wallet: The digital_wallet of this DigitalWalletToken.
        :type digital_wallet: str
        """
        allowed_values = ["apple_pay", "google_pay"]  # noqa: E501
        if digital_wallet not in allowed_values:
            raise ValueError(
                "Invalid value for `digital_wallet` ({0}), must be one of {1}"
                .format(digital_wallet, allowed_values)
            )

        self._digital_wallet = digital_wallet
