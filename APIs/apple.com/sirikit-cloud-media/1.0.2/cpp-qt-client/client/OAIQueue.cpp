/**
 * SiriKit Cloud Media
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIQueue.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIQueue::OAIQueue(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIQueue::OAIQueue() {
    this->initializeModel();
}

OAIQueue::~OAIQueue() {}

void OAIQueue::initializeModel() {

    m_content_isSet = false;
    m_content_isValid = false;

    m_content_items_count_isSet = false;
    m_content_items_count_isValid = false;

    m_controls_isSet = false;
    m_controls_isValid = false;

    m_identifier_isSet = false;
    m_identifier_isValid = false;

    m_insert_pointer_isSet = false;
    m_insert_pointer_isValid = false;

    m_next_content_url_isSet = false;
    m_next_content_url_isValid = false;

    m_play_pointer_isSet = false;
    m_play_pointer_isValid = false;

    m_preroll_seconds_isSet = false;
    m_preroll_seconds_isValid = false;

    m_previous_content_url_isSet = false;
    m_previous_content_url_isValid = false;

    m_skips_remaining_isSet = false;
    m_skips_remaining_isValid = false;

    m_version_isSet = false;
    m_version_isValid = false;
}

void OAIQueue::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIQueue::fromJsonObject(QJsonObject json) {

    m_content_isValid = ::OpenAPI::fromJsonValue(m_content, json[QString("content")]);
    m_content_isSet = !json[QString("content")].isNull() && m_content_isValid;

    m_content_items_count_isValid = ::OpenAPI::fromJsonValue(m_content_items_count, json[QString("contentItemsCount")]);
    m_content_items_count_isSet = !json[QString("contentItemsCount")].isNull() && m_content_items_count_isValid;

    m_controls_isValid = ::OpenAPI::fromJsonValue(m_controls, json[QString("controls")]);
    m_controls_isSet = !json[QString("controls")].isNull() && m_controls_isValid;

    m_identifier_isValid = ::OpenAPI::fromJsonValue(m_identifier, json[QString("identifier")]);
    m_identifier_isSet = !json[QString("identifier")].isNull() && m_identifier_isValid;

    m_insert_pointer_isValid = ::OpenAPI::fromJsonValue(m_insert_pointer, json[QString("insertPointer")]);
    m_insert_pointer_isSet = !json[QString("insertPointer")].isNull() && m_insert_pointer_isValid;

    m_next_content_url_isValid = ::OpenAPI::fromJsonValue(m_next_content_url, json[QString("nextContentUrl")]);
    m_next_content_url_isSet = !json[QString("nextContentUrl")].isNull() && m_next_content_url_isValid;

    m_play_pointer_isValid = ::OpenAPI::fromJsonValue(m_play_pointer, json[QString("playPointer")]);
    m_play_pointer_isSet = !json[QString("playPointer")].isNull() && m_play_pointer_isValid;

    m_preroll_seconds_isValid = ::OpenAPI::fromJsonValue(m_preroll_seconds, json[QString("prerollSeconds")]);
    m_preroll_seconds_isSet = !json[QString("prerollSeconds")].isNull() && m_preroll_seconds_isValid;

    m_previous_content_url_isValid = ::OpenAPI::fromJsonValue(m_previous_content_url, json[QString("previousContentUrl")]);
    m_previous_content_url_isSet = !json[QString("previousContentUrl")].isNull() && m_previous_content_url_isValid;

    m_skips_remaining_isValid = ::OpenAPI::fromJsonValue(m_skips_remaining, json[QString("skipsRemaining")]);
    m_skips_remaining_isSet = !json[QString("skipsRemaining")].isNull() && m_skips_remaining_isValid;

    m_version_isValid = ::OpenAPI::fromJsonValue(m_version, json[QString("version")]);
    m_version_isSet = !json[QString("version")].isNull() && m_version_isValid;
}

QString OAIQueue::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIQueue::asJsonObject() const {
    QJsonObject obj;
    if (m_content.size() > 0) {
        obj.insert(QString("content"), ::OpenAPI::toJsonValue(m_content));
    }
    if (m_content_items_count_isSet) {
        obj.insert(QString("contentItemsCount"), ::OpenAPI::toJsonValue(m_content_items_count));
    }
    if (m_controls.isSet()) {
        obj.insert(QString("controls"), ::OpenAPI::toJsonValue(m_controls));
    }
    if (m_identifier_isSet) {
        obj.insert(QString("identifier"), ::OpenAPI::toJsonValue(m_identifier));
    }
    if (m_insert_pointer.isSet()) {
        obj.insert(QString("insertPointer"), ::OpenAPI::toJsonValue(m_insert_pointer));
    }
    if (m_next_content_url_isSet) {
        obj.insert(QString("nextContentUrl"), ::OpenAPI::toJsonValue(m_next_content_url));
    }
    if (m_play_pointer.isSet()) {
        obj.insert(QString("playPointer"), ::OpenAPI::toJsonValue(m_play_pointer));
    }
    if (m_preroll_seconds_isSet) {
        obj.insert(QString("prerollSeconds"), ::OpenAPI::toJsonValue(m_preroll_seconds));
    }
    if (m_previous_content_url_isSet) {
        obj.insert(QString("previousContentUrl"), ::OpenAPI::toJsonValue(m_previous_content_url));
    }
    if (m_skips_remaining_isSet) {
        obj.insert(QString("skipsRemaining"), ::OpenAPI::toJsonValue(m_skips_remaining));
    }
    if (m_version_isSet) {
        obj.insert(QString("version"), ::OpenAPI::toJsonValue(m_version));
    }
    return obj;
}

QList<OAIContent> OAIQueue::getContent() const {
    return m_content;
}
void OAIQueue::setContent(const QList<OAIContent> &content) {
    m_content = content;
    m_content_isSet = true;
}

bool OAIQueue::is_content_Set() const{
    return m_content_isSet;
}

bool OAIQueue::is_content_Valid() const{
    return m_content_isValid;
}

qint32 OAIQueue::getContentItemsCount() const {
    return m_content_items_count;
}
void OAIQueue::setContentItemsCount(const qint32 &content_items_count) {
    m_content_items_count = content_items_count;
    m_content_items_count_isSet = true;
}

bool OAIQueue::is_content_items_count_Set() const{
    return m_content_items_count_isSet;
}

bool OAIQueue::is_content_items_count_Valid() const{
    return m_content_items_count_isValid;
}

OAIQueueControlMapping OAIQueue::getControls() const {
    return m_controls;
}
void OAIQueue::setControls(const OAIQueueControlMapping &controls) {
    m_controls = controls;
    m_controls_isSet = true;
}

bool OAIQueue::is_controls_Set() const{
    return m_controls_isSet;
}

bool OAIQueue::is_controls_Valid() const{
    return m_controls_isValid;
}

QString OAIQueue::getIdentifier() const {
    return m_identifier;
}
void OAIQueue::setIdentifier(const QString &identifier) {
    m_identifier = identifier;
    m_identifier_isSet = true;
}

bool OAIQueue::is_identifier_Set() const{
    return m_identifier_isSet;
}

bool OAIQueue::is_identifier_Valid() const{
    return m_identifier_isValid;
}

OAIQueueInsertPointer OAIQueue::getInsertPointer() const {
    return m_insert_pointer;
}
void OAIQueue::setInsertPointer(const OAIQueueInsertPointer &insert_pointer) {
    m_insert_pointer = insert_pointer;
    m_insert_pointer_isSet = true;
}

bool OAIQueue::is_insert_pointer_Set() const{
    return m_insert_pointer_isSet;
}

bool OAIQueue::is_insert_pointer_Valid() const{
    return m_insert_pointer_isValid;
}

QString OAIQueue::getNextContentUrl() const {
    return m_next_content_url;
}
void OAIQueue::setNextContentUrl(const QString &next_content_url) {
    m_next_content_url = next_content_url;
    m_next_content_url_isSet = true;
}

bool OAIQueue::is_next_content_url_Set() const{
    return m_next_content_url_isSet;
}

bool OAIQueue::is_next_content_url_Valid() const{
    return m_next_content_url_isValid;
}

OAIQueuePlayPointer OAIQueue::getPlayPointer() const {
    return m_play_pointer;
}
void OAIQueue::setPlayPointer(const OAIQueuePlayPointer &play_pointer) {
    m_play_pointer = play_pointer;
    m_play_pointer_isSet = true;
}

bool OAIQueue::is_play_pointer_Set() const{
    return m_play_pointer_isSet;
}

bool OAIQueue::is_play_pointer_Valid() const{
    return m_play_pointer_isValid;
}

double OAIQueue::getPrerollSeconds() const {
    return m_preroll_seconds;
}
void OAIQueue::setPrerollSeconds(const double &preroll_seconds) {
    m_preroll_seconds = preroll_seconds;
    m_preroll_seconds_isSet = true;
}

bool OAIQueue::is_preroll_seconds_Set() const{
    return m_preroll_seconds_isSet;
}

bool OAIQueue::is_preroll_seconds_Valid() const{
    return m_preroll_seconds_isValid;
}

QString OAIQueue::getPreviousContentUrl() const {
    return m_previous_content_url;
}
void OAIQueue::setPreviousContentUrl(const QString &previous_content_url) {
    m_previous_content_url = previous_content_url;
    m_previous_content_url_isSet = true;
}

bool OAIQueue::is_previous_content_url_Set() const{
    return m_previous_content_url_isSet;
}

bool OAIQueue::is_previous_content_url_Valid() const{
    return m_previous_content_url_isValid;
}

qint32 OAIQueue::getSkipsRemaining() const {
    return m_skips_remaining;
}
void OAIQueue::setSkipsRemaining(const qint32 &skips_remaining) {
    m_skips_remaining = skips_remaining;
    m_skips_remaining_isSet = true;
}

bool OAIQueue::is_skips_remaining_Set() const{
    return m_skips_remaining_isSet;
}

bool OAIQueue::is_skips_remaining_Valid() const{
    return m_skips_remaining_isValid;
}

QString OAIQueue::getVersion() const {
    return m_version;
}
void OAIQueue::setVersion(const QString &version) {
    m_version = version;
    m_version_isSet = true;
}

bool OAIQueue::is_version_Set() const{
    return m_version_isSet;
}

bool OAIQueue::is_version_Valid() const{
    return m_version_isValid;
}

bool OAIQueue::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_content.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_items_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_controls.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_identifier_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_insert_pointer.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_next_content_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_play_pointer.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_preroll_seconds_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_previous_content_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_skips_remaining_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_version_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIQueue::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_content_isValid && m_identifier_isValid && m_version_isValid && true;
}

} // namespace OpenAPI
