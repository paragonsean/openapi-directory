/**
 * App Store Connect API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.4.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAppEncryptionDeclaration_attributes.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAppEncryptionDeclaration_attributes::OAIAppEncryptionDeclaration_attributes(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAppEncryptionDeclaration_attributes::OAIAppEncryptionDeclaration_attributes() {
    this->initializeModel();
}

OAIAppEncryptionDeclaration_attributes::~OAIAppEncryptionDeclaration_attributes() {}

void OAIAppEncryptionDeclaration_attributes::initializeModel() {

    m_app_encryption_declaration_state_isSet = false;
    m_app_encryption_declaration_state_isValid = false;

    m_available_on_french_store_isSet = false;
    m_available_on_french_store_isValid = false;

    m_code_value_isSet = false;
    m_code_value_isValid = false;

    m_contains_proprietary_cryptography_isSet = false;
    m_contains_proprietary_cryptography_isValid = false;

    m_contains_third_party_cryptography_isSet = false;
    m_contains_third_party_cryptography_isValid = false;

    m_document_name_isSet = false;
    m_document_name_isValid = false;

    m_document_type_isSet = false;
    m_document_type_isValid = false;

    m_document_url_isSet = false;
    m_document_url_isValid = false;

    m_exempt_isSet = false;
    m_exempt_isValid = false;

    m_platform_isSet = false;
    m_platform_isValid = false;

    m_uploaded_date_isSet = false;
    m_uploaded_date_isValid = false;

    m_uses_encryption_isSet = false;
    m_uses_encryption_isValid = false;
}

void OAIAppEncryptionDeclaration_attributes::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAppEncryptionDeclaration_attributes::fromJsonObject(QJsonObject json) {

    m_app_encryption_declaration_state_isValid = ::OpenAPI::fromJsonValue(m_app_encryption_declaration_state, json[QString("appEncryptionDeclarationState")]);
    m_app_encryption_declaration_state_isSet = !json[QString("appEncryptionDeclarationState")].isNull() && m_app_encryption_declaration_state_isValid;

    m_available_on_french_store_isValid = ::OpenAPI::fromJsonValue(m_available_on_french_store, json[QString("availableOnFrenchStore")]);
    m_available_on_french_store_isSet = !json[QString("availableOnFrenchStore")].isNull() && m_available_on_french_store_isValid;

    m_code_value_isValid = ::OpenAPI::fromJsonValue(m_code_value, json[QString("codeValue")]);
    m_code_value_isSet = !json[QString("codeValue")].isNull() && m_code_value_isValid;

    m_contains_proprietary_cryptography_isValid = ::OpenAPI::fromJsonValue(m_contains_proprietary_cryptography, json[QString("containsProprietaryCryptography")]);
    m_contains_proprietary_cryptography_isSet = !json[QString("containsProprietaryCryptography")].isNull() && m_contains_proprietary_cryptography_isValid;

    m_contains_third_party_cryptography_isValid = ::OpenAPI::fromJsonValue(m_contains_third_party_cryptography, json[QString("containsThirdPartyCryptography")]);
    m_contains_third_party_cryptography_isSet = !json[QString("containsThirdPartyCryptography")].isNull() && m_contains_third_party_cryptography_isValid;

    m_document_name_isValid = ::OpenAPI::fromJsonValue(m_document_name, json[QString("documentName")]);
    m_document_name_isSet = !json[QString("documentName")].isNull() && m_document_name_isValid;

    m_document_type_isValid = ::OpenAPI::fromJsonValue(m_document_type, json[QString("documentType")]);
    m_document_type_isSet = !json[QString("documentType")].isNull() && m_document_type_isValid;

    m_document_url_isValid = ::OpenAPI::fromJsonValue(m_document_url, json[QString("documentUrl")]);
    m_document_url_isSet = !json[QString("documentUrl")].isNull() && m_document_url_isValid;

    m_exempt_isValid = ::OpenAPI::fromJsonValue(m_exempt, json[QString("exempt")]);
    m_exempt_isSet = !json[QString("exempt")].isNull() && m_exempt_isValid;

    m_platform_isValid = ::OpenAPI::fromJsonValue(m_platform, json[QString("platform")]);
    m_platform_isSet = !json[QString("platform")].isNull() && m_platform_isValid;

    m_uploaded_date_isValid = ::OpenAPI::fromJsonValue(m_uploaded_date, json[QString("uploadedDate")]);
    m_uploaded_date_isSet = !json[QString("uploadedDate")].isNull() && m_uploaded_date_isValid;

    m_uses_encryption_isValid = ::OpenAPI::fromJsonValue(m_uses_encryption, json[QString("usesEncryption")]);
    m_uses_encryption_isSet = !json[QString("usesEncryption")].isNull() && m_uses_encryption_isValid;
}

QString OAIAppEncryptionDeclaration_attributes::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAppEncryptionDeclaration_attributes::asJsonObject() const {
    QJsonObject obj;
    if (m_app_encryption_declaration_state.isSet()) {
        obj.insert(QString("appEncryptionDeclarationState"), ::OpenAPI::toJsonValue(m_app_encryption_declaration_state));
    }
    if (m_available_on_french_store_isSet) {
        obj.insert(QString("availableOnFrenchStore"), ::OpenAPI::toJsonValue(m_available_on_french_store));
    }
    if (m_code_value_isSet) {
        obj.insert(QString("codeValue"), ::OpenAPI::toJsonValue(m_code_value));
    }
    if (m_contains_proprietary_cryptography_isSet) {
        obj.insert(QString("containsProprietaryCryptography"), ::OpenAPI::toJsonValue(m_contains_proprietary_cryptography));
    }
    if (m_contains_third_party_cryptography_isSet) {
        obj.insert(QString("containsThirdPartyCryptography"), ::OpenAPI::toJsonValue(m_contains_third_party_cryptography));
    }
    if (m_document_name_isSet) {
        obj.insert(QString("documentName"), ::OpenAPI::toJsonValue(m_document_name));
    }
    if (m_document_type_isSet) {
        obj.insert(QString("documentType"), ::OpenAPI::toJsonValue(m_document_type));
    }
    if (m_document_url_isSet) {
        obj.insert(QString("documentUrl"), ::OpenAPI::toJsonValue(m_document_url));
    }
    if (m_exempt_isSet) {
        obj.insert(QString("exempt"), ::OpenAPI::toJsonValue(m_exempt));
    }
    if (m_platform.isSet()) {
        obj.insert(QString("platform"), ::OpenAPI::toJsonValue(m_platform));
    }
    if (m_uploaded_date_isSet) {
        obj.insert(QString("uploadedDate"), ::OpenAPI::toJsonValue(m_uploaded_date));
    }
    if (m_uses_encryption_isSet) {
        obj.insert(QString("usesEncryption"), ::OpenAPI::toJsonValue(m_uses_encryption));
    }
    return obj;
}

OAIAppEncryptionDeclarationState OAIAppEncryptionDeclaration_attributes::getAppEncryptionDeclarationState() const {
    return m_app_encryption_declaration_state;
}
void OAIAppEncryptionDeclaration_attributes::setAppEncryptionDeclarationState(const OAIAppEncryptionDeclarationState &app_encryption_declaration_state) {
    m_app_encryption_declaration_state = app_encryption_declaration_state;
    m_app_encryption_declaration_state_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_app_encryption_declaration_state_Set() const{
    return m_app_encryption_declaration_state_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_app_encryption_declaration_state_Valid() const{
    return m_app_encryption_declaration_state_isValid;
}

bool OAIAppEncryptionDeclaration_attributes::isAvailableOnFrenchStore() const {
    return m_available_on_french_store;
}
void OAIAppEncryptionDeclaration_attributes::setAvailableOnFrenchStore(const bool &available_on_french_store) {
    m_available_on_french_store = available_on_french_store;
    m_available_on_french_store_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_available_on_french_store_Set() const{
    return m_available_on_french_store_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_available_on_french_store_Valid() const{
    return m_available_on_french_store_isValid;
}

QString OAIAppEncryptionDeclaration_attributes::getCodeValue() const {
    return m_code_value;
}
void OAIAppEncryptionDeclaration_attributes::setCodeValue(const QString &code_value) {
    m_code_value = code_value;
    m_code_value_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_code_value_Set() const{
    return m_code_value_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_code_value_Valid() const{
    return m_code_value_isValid;
}

bool OAIAppEncryptionDeclaration_attributes::isContainsProprietaryCryptography() const {
    return m_contains_proprietary_cryptography;
}
void OAIAppEncryptionDeclaration_attributes::setContainsProprietaryCryptography(const bool &contains_proprietary_cryptography) {
    m_contains_proprietary_cryptography = contains_proprietary_cryptography;
    m_contains_proprietary_cryptography_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_contains_proprietary_cryptography_Set() const{
    return m_contains_proprietary_cryptography_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_contains_proprietary_cryptography_Valid() const{
    return m_contains_proprietary_cryptography_isValid;
}

bool OAIAppEncryptionDeclaration_attributes::isContainsThirdPartyCryptography() const {
    return m_contains_third_party_cryptography;
}
void OAIAppEncryptionDeclaration_attributes::setContainsThirdPartyCryptography(const bool &contains_third_party_cryptography) {
    m_contains_third_party_cryptography = contains_third_party_cryptography;
    m_contains_third_party_cryptography_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_contains_third_party_cryptography_Set() const{
    return m_contains_third_party_cryptography_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_contains_third_party_cryptography_Valid() const{
    return m_contains_third_party_cryptography_isValid;
}

QString OAIAppEncryptionDeclaration_attributes::getDocumentName() const {
    return m_document_name;
}
void OAIAppEncryptionDeclaration_attributes::setDocumentName(const QString &document_name) {
    m_document_name = document_name;
    m_document_name_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_document_name_Set() const{
    return m_document_name_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_document_name_Valid() const{
    return m_document_name_isValid;
}

QString OAIAppEncryptionDeclaration_attributes::getDocumentType() const {
    return m_document_type;
}
void OAIAppEncryptionDeclaration_attributes::setDocumentType(const QString &document_type) {
    m_document_type = document_type;
    m_document_type_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_document_type_Set() const{
    return m_document_type_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_document_type_Valid() const{
    return m_document_type_isValid;
}

QString OAIAppEncryptionDeclaration_attributes::getDocumentUrl() const {
    return m_document_url;
}
void OAIAppEncryptionDeclaration_attributes::setDocumentUrl(const QString &document_url) {
    m_document_url = document_url;
    m_document_url_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_document_url_Set() const{
    return m_document_url_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_document_url_Valid() const{
    return m_document_url_isValid;
}

bool OAIAppEncryptionDeclaration_attributes::isExempt() const {
    return m_exempt;
}
void OAIAppEncryptionDeclaration_attributes::setExempt(const bool &exempt) {
    m_exempt = exempt;
    m_exempt_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_exempt_Set() const{
    return m_exempt_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_exempt_Valid() const{
    return m_exempt_isValid;
}

OAIPlatform OAIAppEncryptionDeclaration_attributes::getPlatform() const {
    return m_platform;
}
void OAIAppEncryptionDeclaration_attributes::setPlatform(const OAIPlatform &platform) {
    m_platform = platform;
    m_platform_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_platform_Set() const{
    return m_platform_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_platform_Valid() const{
    return m_platform_isValid;
}

QDateTime OAIAppEncryptionDeclaration_attributes::getUploadedDate() const {
    return m_uploaded_date;
}
void OAIAppEncryptionDeclaration_attributes::setUploadedDate(const QDateTime &uploaded_date) {
    m_uploaded_date = uploaded_date;
    m_uploaded_date_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_uploaded_date_Set() const{
    return m_uploaded_date_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_uploaded_date_Valid() const{
    return m_uploaded_date_isValid;
}

bool OAIAppEncryptionDeclaration_attributes::isUsesEncryption() const {
    return m_uses_encryption;
}
void OAIAppEncryptionDeclaration_attributes::setUsesEncryption(const bool &uses_encryption) {
    m_uses_encryption = uses_encryption;
    m_uses_encryption_isSet = true;
}

bool OAIAppEncryptionDeclaration_attributes::is_uses_encryption_Set() const{
    return m_uses_encryption_isSet;
}

bool OAIAppEncryptionDeclaration_attributes::is_uses_encryption_Valid() const{
    return m_uses_encryption_isValid;
}

bool OAIAppEncryptionDeclaration_attributes::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_app_encryption_declaration_state.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_available_on_french_store_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_code_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_contains_proprietary_cryptography_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_contains_third_party_cryptography_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_document_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_document_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_document_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_exempt_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_platform.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_uploaded_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_uses_encryption_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAppEncryptionDeclaration_attributes::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
