/*
 * App Store Connect API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.4.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.App;
import org.openapitools.client.model.AppEncryptionDeclaration;
import org.openapitools.client.model.AppStoreVersion;
import org.openapitools.client.model.AppStoreVersionRelationships;
import org.openapitools.client.model.BetaAppReviewSubmission;
import org.openapitools.client.model.BetaBuildLocalization;
import org.openapitools.client.model.BetaTester;
import org.openapitools.client.model.BuildBetaDetail;
import org.openapitools.client.model.BuildIcon;
import org.openapitools.client.model.DiagnosticSignature;
import org.openapitools.client.model.DiagnosticSignatureAttributes;
import org.openapitools.client.model.PerfPowerMetric;
import org.openapitools.client.model.PrereleaseVersion;
import org.openapitools.client.model.ResourceLinks;



import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;

import org.openapitools.client.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:33:02.423773-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BuildResponseIncludedInner extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(BuildResponseIncludedInner.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!BuildResponseIncludedInner.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'BuildResponseIncludedInner' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<PrereleaseVersion> adapterPrereleaseVersion = gson.getDelegateAdapter(this, TypeToken.get(PrereleaseVersion.class));
            final TypeAdapter<BetaTester> adapterBetaTester = gson.getDelegateAdapter(this, TypeToken.get(BetaTester.class));
            final TypeAdapter<BetaBuildLocalization> adapterBetaBuildLocalization = gson.getDelegateAdapter(this, TypeToken.get(BetaBuildLocalization.class));
            final TypeAdapter<AppEncryptionDeclaration> adapterAppEncryptionDeclaration = gson.getDelegateAdapter(this, TypeToken.get(AppEncryptionDeclaration.class));
            final TypeAdapter<BetaAppReviewSubmission> adapterBetaAppReviewSubmission = gson.getDelegateAdapter(this, TypeToken.get(BetaAppReviewSubmission.class));
            final TypeAdapter<App> adapterApp = gson.getDelegateAdapter(this, TypeToken.get(App.class));
            final TypeAdapter<BuildBetaDetail> adapterBuildBetaDetail = gson.getDelegateAdapter(this, TypeToken.get(BuildBetaDetail.class));
            final TypeAdapter<AppStoreVersion> adapterAppStoreVersion = gson.getDelegateAdapter(this, TypeToken.get(AppStoreVersion.class));
            final TypeAdapter<BuildIcon> adapterBuildIcon = gson.getDelegateAdapter(this, TypeToken.get(BuildIcon.class));
            final TypeAdapter<PerfPowerMetric> adapterPerfPowerMetric = gson.getDelegateAdapter(this, TypeToken.get(PerfPowerMetric.class));
            final TypeAdapter<DiagnosticSignature> adapterDiagnosticSignature = gson.getDelegateAdapter(this, TypeToken.get(DiagnosticSignature.class));

            return (TypeAdapter<T>) new TypeAdapter<BuildResponseIncludedInner>() {
                @Override
                public void write(JsonWriter out, BuildResponseIncludedInner value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `PrereleaseVersion`
                    if (value.getActualInstance() instanceof PrereleaseVersion) {
                        JsonElement element = adapterPrereleaseVersion.toJsonTree((PrereleaseVersion)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `BetaTester`
                    if (value.getActualInstance() instanceof BetaTester) {
                        JsonElement element = adapterBetaTester.toJsonTree((BetaTester)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `BetaBuildLocalization`
                    if (value.getActualInstance() instanceof BetaBuildLocalization) {
                        JsonElement element = adapterBetaBuildLocalization.toJsonTree((BetaBuildLocalization)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `AppEncryptionDeclaration`
                    if (value.getActualInstance() instanceof AppEncryptionDeclaration) {
                        JsonElement element = adapterAppEncryptionDeclaration.toJsonTree((AppEncryptionDeclaration)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `BetaAppReviewSubmission`
                    if (value.getActualInstance() instanceof BetaAppReviewSubmission) {
                        JsonElement element = adapterBetaAppReviewSubmission.toJsonTree((BetaAppReviewSubmission)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `App`
                    if (value.getActualInstance() instanceof App) {
                        JsonElement element = adapterApp.toJsonTree((App)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `BuildBetaDetail`
                    if (value.getActualInstance() instanceof BuildBetaDetail) {
                        JsonElement element = adapterBuildBetaDetail.toJsonTree((BuildBetaDetail)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `AppStoreVersion`
                    if (value.getActualInstance() instanceof AppStoreVersion) {
                        JsonElement element = adapterAppStoreVersion.toJsonTree((AppStoreVersion)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `BuildIcon`
                    if (value.getActualInstance() instanceof BuildIcon) {
                        JsonElement element = adapterBuildIcon.toJsonTree((BuildIcon)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `PerfPowerMetric`
                    if (value.getActualInstance() instanceof PerfPowerMetric) {
                        JsonElement element = adapterPerfPowerMetric.toJsonTree((PerfPowerMetric)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `DiagnosticSignature`
                    if (value.getActualInstance() instanceof DiagnosticSignature) {
                        JsonElement element = adapterDiagnosticSignature.toJsonTree((DiagnosticSignature)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: App, AppEncryptionDeclaration, AppStoreVersion, BetaAppReviewSubmission, BetaBuildLocalization, BetaTester, BuildBetaDetail, BuildIcon, DiagnosticSignature, PerfPowerMetric, PrereleaseVersion");
                }

                @Override
                public BuildResponseIncludedInner read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonElement jsonElement = elementAdapter.read(in);

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize PrereleaseVersion
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PrereleaseVersion.validateJsonElement(jsonElement);
                        actualAdapter = adapterPrereleaseVersion;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PrereleaseVersion'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PrereleaseVersion failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PrereleaseVersion'", e);
                    }
                    // deserialize BetaTester
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BetaTester.validateJsonElement(jsonElement);
                        actualAdapter = adapterBetaTester;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'BetaTester'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for BetaTester failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'BetaTester'", e);
                    }
                    // deserialize BetaBuildLocalization
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BetaBuildLocalization.validateJsonElement(jsonElement);
                        actualAdapter = adapterBetaBuildLocalization;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'BetaBuildLocalization'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for BetaBuildLocalization failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'BetaBuildLocalization'", e);
                    }
                    // deserialize AppEncryptionDeclaration
                    try {
                        // validate the JSON object to see if any exception is thrown
                        AppEncryptionDeclaration.validateJsonElement(jsonElement);
                        actualAdapter = adapterAppEncryptionDeclaration;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'AppEncryptionDeclaration'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for AppEncryptionDeclaration failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'AppEncryptionDeclaration'", e);
                    }
                    // deserialize BetaAppReviewSubmission
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BetaAppReviewSubmission.validateJsonElement(jsonElement);
                        actualAdapter = adapterBetaAppReviewSubmission;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'BetaAppReviewSubmission'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for BetaAppReviewSubmission failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'BetaAppReviewSubmission'", e);
                    }
                    // deserialize App
                    try {
                        // validate the JSON object to see if any exception is thrown
                        App.validateJsonElement(jsonElement);
                        actualAdapter = adapterApp;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'App'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for App failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'App'", e);
                    }
                    // deserialize BuildBetaDetail
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BuildBetaDetail.validateJsonElement(jsonElement);
                        actualAdapter = adapterBuildBetaDetail;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'BuildBetaDetail'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for BuildBetaDetail failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'BuildBetaDetail'", e);
                    }
                    // deserialize AppStoreVersion
                    try {
                        // validate the JSON object to see if any exception is thrown
                        AppStoreVersion.validateJsonElement(jsonElement);
                        actualAdapter = adapterAppStoreVersion;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'AppStoreVersion'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for AppStoreVersion failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'AppStoreVersion'", e);
                    }
                    // deserialize BuildIcon
                    try {
                        // validate the JSON object to see if any exception is thrown
                        BuildIcon.validateJsonElement(jsonElement);
                        actualAdapter = adapterBuildIcon;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'BuildIcon'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for BuildIcon failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'BuildIcon'", e);
                    }
                    // deserialize PerfPowerMetric
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PerfPowerMetric.validateJsonElement(jsonElement);
                        actualAdapter = adapterPerfPowerMetric;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PerfPowerMetric'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PerfPowerMetric failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PerfPowerMetric'", e);
                    }
                    // deserialize DiagnosticSignature
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DiagnosticSignature.validateJsonElement(jsonElement);
                        actualAdapter = adapterDiagnosticSignature;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'DiagnosticSignature'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for DiagnosticSignature failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'DiagnosticSignature'", e);
                    }

                    if (match == 1) {
                        BuildResponseIncludedInner ret = new BuildResponseIncludedInner();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for BuildResponseIncludedInner: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonElement.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();

    public BuildResponseIncludedInner() {
        super("oneOf", Boolean.FALSE);
    }

    public BuildResponseIncludedInner(Object o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("PrereleaseVersion", PrereleaseVersion.class);
        schemas.put("BetaTester", BetaTester.class);
        schemas.put("BetaBuildLocalization", BetaBuildLocalization.class);
        schemas.put("AppEncryptionDeclaration", AppEncryptionDeclaration.class);
        schemas.put("BetaAppReviewSubmission", BetaAppReviewSubmission.class);
        schemas.put("App", App.class);
        schemas.put("BuildBetaDetail", BuildBetaDetail.class);
        schemas.put("AppStoreVersion", AppStoreVersion.class);
        schemas.put("BuildIcon", BuildIcon.class);
        schemas.put("PerfPowerMetric", PerfPowerMetric.class);
        schemas.put("DiagnosticSignature", DiagnosticSignature.class);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return BuildResponseIncludedInner.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * App, AppEncryptionDeclaration, AppStoreVersion, BetaAppReviewSubmission, BetaBuildLocalization, BetaTester, BuildBetaDetail, BuildIcon, DiagnosticSignature, PerfPowerMetric, PrereleaseVersion
     *
     * It could be an instance of the 'oneOf' schemas.
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof PrereleaseVersion) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BetaTester) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BetaBuildLocalization) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof AppEncryptionDeclaration) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BetaAppReviewSubmission) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof App) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BuildBetaDetail) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof AppStoreVersion) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof BuildIcon) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof PerfPowerMetric) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DiagnosticSignature) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be App, AppEncryptionDeclaration, AppStoreVersion, BetaAppReviewSubmission, BetaBuildLocalization, BetaTester, BuildBetaDetail, BuildIcon, DiagnosticSignature, PerfPowerMetric, PrereleaseVersion");
    }

    /**
     * Get the actual instance, which can be the following:
     * App, AppEncryptionDeclaration, AppStoreVersion, BetaAppReviewSubmission, BetaBuildLocalization, BetaTester, BuildBetaDetail, BuildIcon, DiagnosticSignature, PerfPowerMetric, PrereleaseVersion
     *
     * @return The actual instance (App, AppEncryptionDeclaration, AppStoreVersion, BetaAppReviewSubmission, BetaBuildLocalization, BetaTester, BuildBetaDetail, BuildIcon, DiagnosticSignature, PerfPowerMetric, PrereleaseVersion)
     */
    @SuppressWarnings("unchecked")
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `PrereleaseVersion`. If the actual instance is not `PrereleaseVersion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PrereleaseVersion`
     * @throws ClassCastException if the instance is not `PrereleaseVersion`
     */
    public PrereleaseVersion getPrereleaseVersion() throws ClassCastException {
        return (PrereleaseVersion)super.getActualInstance();
    }
    /**
     * Get the actual instance of `BetaTester`. If the actual instance is not `BetaTester`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BetaTester`
     * @throws ClassCastException if the instance is not `BetaTester`
     */
    public BetaTester getBetaTester() throws ClassCastException {
        return (BetaTester)super.getActualInstance();
    }
    /**
     * Get the actual instance of `BetaBuildLocalization`. If the actual instance is not `BetaBuildLocalization`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BetaBuildLocalization`
     * @throws ClassCastException if the instance is not `BetaBuildLocalization`
     */
    public BetaBuildLocalization getBetaBuildLocalization() throws ClassCastException {
        return (BetaBuildLocalization)super.getActualInstance();
    }
    /**
     * Get the actual instance of `AppEncryptionDeclaration`. If the actual instance is not `AppEncryptionDeclaration`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AppEncryptionDeclaration`
     * @throws ClassCastException if the instance is not `AppEncryptionDeclaration`
     */
    public AppEncryptionDeclaration getAppEncryptionDeclaration() throws ClassCastException {
        return (AppEncryptionDeclaration)super.getActualInstance();
    }
    /**
     * Get the actual instance of `BetaAppReviewSubmission`. If the actual instance is not `BetaAppReviewSubmission`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BetaAppReviewSubmission`
     * @throws ClassCastException if the instance is not `BetaAppReviewSubmission`
     */
    public BetaAppReviewSubmission getBetaAppReviewSubmission() throws ClassCastException {
        return (BetaAppReviewSubmission)super.getActualInstance();
    }
    /**
     * Get the actual instance of `App`. If the actual instance is not `App`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `App`
     * @throws ClassCastException if the instance is not `App`
     */
    public App getApp() throws ClassCastException {
        return (App)super.getActualInstance();
    }
    /**
     * Get the actual instance of `BuildBetaDetail`. If the actual instance is not `BuildBetaDetail`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BuildBetaDetail`
     * @throws ClassCastException if the instance is not `BuildBetaDetail`
     */
    public BuildBetaDetail getBuildBetaDetail() throws ClassCastException {
        return (BuildBetaDetail)super.getActualInstance();
    }
    /**
     * Get the actual instance of `AppStoreVersion`. If the actual instance is not `AppStoreVersion`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AppStoreVersion`
     * @throws ClassCastException if the instance is not `AppStoreVersion`
     */
    public AppStoreVersion getAppStoreVersion() throws ClassCastException {
        return (AppStoreVersion)super.getActualInstance();
    }
    /**
     * Get the actual instance of `BuildIcon`. If the actual instance is not `BuildIcon`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BuildIcon`
     * @throws ClassCastException if the instance is not `BuildIcon`
     */
    public BuildIcon getBuildIcon() throws ClassCastException {
        return (BuildIcon)super.getActualInstance();
    }
    /**
     * Get the actual instance of `PerfPowerMetric`. If the actual instance is not `PerfPowerMetric`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PerfPowerMetric`
     * @throws ClassCastException if the instance is not `PerfPowerMetric`
     */
    public PerfPowerMetric getPerfPowerMetric() throws ClassCastException {
        return (PerfPowerMetric)super.getActualInstance();
    }
    /**
     * Get the actual instance of `DiagnosticSignature`. If the actual instance is not `DiagnosticSignature`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DiagnosticSignature`
     * @throws ClassCastException if the instance is not `DiagnosticSignature`
     */
    public DiagnosticSignature getDiagnosticSignature() throws ClassCastException {
        return (DiagnosticSignature)super.getActualInstance();
    }

    /**
     * Validates the JSON Element and throws an exception if issues found
     *
     * @param jsonElement JSON Element
     * @throws IOException if the JSON Element is invalid with respect to BuildResponseIncludedInner
     */
    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
        // validate oneOf schemas one by one
        int validCount = 0;
        ArrayList<String> errorMessages = new ArrayList<>();
        // validate the json string with PrereleaseVersion
        try {
            PrereleaseVersion.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PrereleaseVersion failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with BetaTester
        try {
            BetaTester.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for BetaTester failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with BetaBuildLocalization
        try {
            BetaBuildLocalization.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for BetaBuildLocalization failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with AppEncryptionDeclaration
        try {
            AppEncryptionDeclaration.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for AppEncryptionDeclaration failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with BetaAppReviewSubmission
        try {
            BetaAppReviewSubmission.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for BetaAppReviewSubmission failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with App
        try {
            App.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for App failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with BuildBetaDetail
        try {
            BuildBetaDetail.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for BuildBetaDetail failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with AppStoreVersion
        try {
            AppStoreVersion.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for AppStoreVersion failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with BuildIcon
        try {
            BuildIcon.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for BuildIcon failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with PerfPowerMetric
        try {
            PerfPowerMetric.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PerfPowerMetric failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with DiagnosticSignature
        try {
            DiagnosticSignature.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for DiagnosticSignature failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        if (validCount != 1) {
            throw new IOException(String.format("The JSON string is invalid for BuildResponseIncludedInner with oneOf schemas: App, AppEncryptionDeclaration, AppStoreVersion, BetaAppReviewSubmission, BetaBuildLocalization, BetaTester, BuildBetaDetail, BuildIcon, DiagnosticSignature, PerfPowerMetric, PrereleaseVersion. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonElement.toString()));
        }
    }

    /**
     * Create an instance of BuildResponseIncludedInner given an JSON string
     *
     * @param jsonString JSON string
     * @return An instance of BuildResponseIncludedInner
     * @throws IOException if the JSON string is invalid with respect to BuildResponseIncludedInner
     */
    public static BuildResponseIncludedInner fromJson(String jsonString) throws IOException {
        return JSON.getGson().fromJson(jsonString, BuildResponseIncludedInner.class);
    }

    /**
     * Convert an instance of BuildResponseIncludedInner to an JSON string
     *
     * @return JSON string
     */
    public String toJson() {
        return JSON.getGson().toJson(this);
    }
}

