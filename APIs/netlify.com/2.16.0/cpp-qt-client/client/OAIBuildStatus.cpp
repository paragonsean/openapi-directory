/**
 * Netlify's API documentation
 * Netlify is a hosting service for the programmable web. It understands your documents and provides an API to handle atomic deploys of websites, manage form submissions, inject JavaScript snippets, and much more. This is a REST-style API that uses JSON for serialization and OAuth 2 for authentication.  This document is an OpenAPI reference for the Netlify API that you can explore. For more detailed instructions for common uses, please visit the [online documentation](https://www.netlify.com/docs/api/). Visit our Community forum to join the conversation about [understanding and using Netlifyâ€™s API](https://community.netlify.com/t/common-issue-understanding-and-using-netlifys-api/160).  Additionally, we have two API clients for your convenience: - [Go Client](https://github.com/netlify/open-api#go-client) - [JS Client](https://github.com/netlify/build/tree/main/packages/js-client)
 *
 * The version of the OpenAPI document: 2.16.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIBuildStatus.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIBuildStatus::OAIBuildStatus(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIBuildStatus::OAIBuildStatus() {
    this->initializeModel();
}

OAIBuildStatus::~OAIBuildStatus() {}

void OAIBuildStatus::initializeModel() {

    m_active_isSet = false;
    m_active_isValid = false;

    m_build_count_isSet = false;
    m_build_count_isValid = false;

    m_enqueued_isSet = false;
    m_enqueued_isValid = false;

    m_minutes_isSet = false;
    m_minutes_isValid = false;

    m_pending_concurrency_isSet = false;
    m_pending_concurrency_isValid = false;
}

void OAIBuildStatus::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIBuildStatus::fromJsonObject(QJsonObject json) {

    m_active_isValid = ::OpenAPI::fromJsonValue(m_active, json[QString("active")]);
    m_active_isSet = !json[QString("active")].isNull() && m_active_isValid;

    m_build_count_isValid = ::OpenAPI::fromJsonValue(m_build_count, json[QString("build_count")]);
    m_build_count_isSet = !json[QString("build_count")].isNull() && m_build_count_isValid;

    m_enqueued_isValid = ::OpenAPI::fromJsonValue(m_enqueued, json[QString("enqueued")]);
    m_enqueued_isSet = !json[QString("enqueued")].isNull() && m_enqueued_isValid;

    m_minutes_isValid = ::OpenAPI::fromJsonValue(m_minutes, json[QString("minutes")]);
    m_minutes_isSet = !json[QString("minutes")].isNull() && m_minutes_isValid;

    m_pending_concurrency_isValid = ::OpenAPI::fromJsonValue(m_pending_concurrency, json[QString("pending_concurrency")]);
    m_pending_concurrency_isSet = !json[QString("pending_concurrency")].isNull() && m_pending_concurrency_isValid;
}

QString OAIBuildStatus::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIBuildStatus::asJsonObject() const {
    QJsonObject obj;
    if (m_active_isSet) {
        obj.insert(QString("active"), ::OpenAPI::toJsonValue(m_active));
    }
    if (m_build_count_isSet) {
        obj.insert(QString("build_count"), ::OpenAPI::toJsonValue(m_build_count));
    }
    if (m_enqueued_isSet) {
        obj.insert(QString("enqueued"), ::OpenAPI::toJsonValue(m_enqueued));
    }
    if (m_minutes.isSet()) {
        obj.insert(QString("minutes"), ::OpenAPI::toJsonValue(m_minutes));
    }
    if (m_pending_concurrency_isSet) {
        obj.insert(QString("pending_concurrency"), ::OpenAPI::toJsonValue(m_pending_concurrency));
    }
    return obj;
}

qint32 OAIBuildStatus::getActive() const {
    return m_active;
}
void OAIBuildStatus::setActive(const qint32 &active) {
    m_active = active;
    m_active_isSet = true;
}

bool OAIBuildStatus::is_active_Set() const{
    return m_active_isSet;
}

bool OAIBuildStatus::is_active_Valid() const{
    return m_active_isValid;
}

qint32 OAIBuildStatus::getBuildCount() const {
    return m_build_count;
}
void OAIBuildStatus::setBuildCount(const qint32 &build_count) {
    m_build_count = build_count;
    m_build_count_isSet = true;
}

bool OAIBuildStatus::is_build_count_Set() const{
    return m_build_count_isSet;
}

bool OAIBuildStatus::is_build_count_Valid() const{
    return m_build_count_isValid;
}

qint32 OAIBuildStatus::getEnqueued() const {
    return m_enqueued;
}
void OAIBuildStatus::setEnqueued(const qint32 &enqueued) {
    m_enqueued = enqueued;
    m_enqueued_isSet = true;
}

bool OAIBuildStatus::is_enqueued_Set() const{
    return m_enqueued_isSet;
}

bool OAIBuildStatus::is_enqueued_Valid() const{
    return m_enqueued_isValid;
}

OAIBuildStatus_minutes OAIBuildStatus::getMinutes() const {
    return m_minutes;
}
void OAIBuildStatus::setMinutes(const OAIBuildStatus_minutes &minutes) {
    m_minutes = minutes;
    m_minutes_isSet = true;
}

bool OAIBuildStatus::is_minutes_Set() const{
    return m_minutes_isSet;
}

bool OAIBuildStatus::is_minutes_Valid() const{
    return m_minutes_isValid;
}

qint32 OAIBuildStatus::getPendingConcurrency() const {
    return m_pending_concurrency;
}
void OAIBuildStatus::setPendingConcurrency(const qint32 &pending_concurrency) {
    m_pending_concurrency = pending_concurrency;
    m_pending_concurrency_isSet = true;
}

bool OAIBuildStatus::is_pending_concurrency_Set() const{
    return m_pending_concurrency_isSet;
}

bool OAIBuildStatus::is_pending_concurrency_Valid() const{
    return m_pending_concurrency_isValid;
}

bool OAIBuildStatus::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_active_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_build_count_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enqueued_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_minutes.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_pending_concurrency_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIBuildStatus::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
