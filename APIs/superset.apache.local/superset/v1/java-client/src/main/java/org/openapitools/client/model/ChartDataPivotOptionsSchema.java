/*
 * Superset
 * Superset
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ChartDataPivotOptionsSchema
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:28:21.510964-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ChartDataPivotOptionsSchema {
  public static final String SERIALIZED_NAME_AGGREGATES = "aggregates";
  @SerializedName(SERIALIZED_NAME_AGGREGATES)
  private Object aggregates;

  public static final String SERIALIZED_NAME_COLUMN_FILL_VALUE = "column_fill_value";
  @SerializedName(SERIALIZED_NAME_COLUMN_FILL_VALUE)
  private String columnFillValue;

  public static final String SERIALIZED_NAME_COLUMNS = "columns";
  @SerializedName(SERIALIZED_NAME_COLUMNS)
  private List<String> columns = new ArrayList<>();

  public static final String SERIALIZED_NAME_DROP_MISSING_COLUMNS = "drop_missing_columns";
  @SerializedName(SERIALIZED_NAME_DROP_MISSING_COLUMNS)
  private Boolean dropMissingColumns;

  public static final String SERIALIZED_NAME_MARGINAL_DISTRIBUTION_NAME = "marginal_distribution_name";
  @SerializedName(SERIALIZED_NAME_MARGINAL_DISTRIBUTION_NAME)
  private String marginalDistributionName;

  public static final String SERIALIZED_NAME_MARGINAL_DISTRIBUTIONS = "marginal_distributions";
  @SerializedName(SERIALIZED_NAME_MARGINAL_DISTRIBUTIONS)
  private Boolean marginalDistributions;

  public static final String SERIALIZED_NAME_METRIC_FILL_VALUE = "metric_fill_value";
  @SerializedName(SERIALIZED_NAME_METRIC_FILL_VALUE)
  private BigDecimal metricFillValue;

  public ChartDataPivotOptionsSchema() {
  }

  public ChartDataPivotOptionsSchema aggregates(Object aggregates) {
    this.aggregates = aggregates;
    return this;
  }

  /**
   * The keys are the name of the aggregate column to be created, and the values specify the details of how to apply the aggregation. If an operator requires additional options, these can be passed here to be unpacked in the operator call. The following numpy operators are supported: average, argmin, argmax, cumsum, cumprod, max, mean, median, nansum, nanmin, nanmax, nanmean, nanmedian, min, percentile, prod, product, std, sum, var. Any options required by the operator can be passed to the &#x60;options&#x60; object.  In the example, a new column &#x60;first_quantile&#x60; is created based on values in the column &#x60;my_col&#x60; using the &#x60;percentile&#x60; operator with the &#x60;q&#x3D;0.25&#x60; parameter.
   * @return aggregates
   */
  @javax.annotation.Nullable
  public Object getAggregates() {
    return aggregates;
  }

  public void setAggregates(Object aggregates) {
    this.aggregates = aggregates;
  }


  public ChartDataPivotOptionsSchema columnFillValue(String columnFillValue) {
    this.columnFillValue = columnFillValue;
    return this;
  }

  /**
   * Value to replace missing pivot columns names with.
   * @return columnFillValue
   */
  @javax.annotation.Nullable
  public String getColumnFillValue() {
    return columnFillValue;
  }

  public void setColumnFillValue(String columnFillValue) {
    this.columnFillValue = columnFillValue;
  }


  public ChartDataPivotOptionsSchema columns(List<String> columns) {
    this.columns = columns;
    return this;
  }

  public ChartDataPivotOptionsSchema addColumnsItem(String columnsItem) {
    if (this.columns == null) {
      this.columns = new ArrayList<>();
    }
    this.columns.add(columnsItem);
    return this;
  }

  /**
   * Get columns
   * @return columns
   */
  @javax.annotation.Nullable
  public List<String> getColumns() {
    return columns;
  }

  public void setColumns(List<String> columns) {
    this.columns = columns;
  }


  public ChartDataPivotOptionsSchema dropMissingColumns(Boolean dropMissingColumns) {
    this.dropMissingColumns = dropMissingColumns;
    return this;
  }

  /**
   * Do not include columns whose entries are all missing (default: &#x60;true&#x60;).
   * @return dropMissingColumns
   */
  @javax.annotation.Nullable
  public Boolean getDropMissingColumns() {
    return dropMissingColumns;
  }

  public void setDropMissingColumns(Boolean dropMissingColumns) {
    this.dropMissingColumns = dropMissingColumns;
  }


  public ChartDataPivotOptionsSchema marginalDistributionName(String marginalDistributionName) {
    this.marginalDistributionName = marginalDistributionName;
    return this;
  }

  /**
   * Name of marginal distribution row/column. (default: &#x60;All&#x60;)
   * @return marginalDistributionName
   */
  @javax.annotation.Nullable
  public String getMarginalDistributionName() {
    return marginalDistributionName;
  }

  public void setMarginalDistributionName(String marginalDistributionName) {
    this.marginalDistributionName = marginalDistributionName;
  }


  public ChartDataPivotOptionsSchema marginalDistributions(Boolean marginalDistributions) {
    this.marginalDistributions = marginalDistributions;
    return this;
  }

  /**
   * Add totals for row/column. (default: &#x60;false&#x60;)
   * @return marginalDistributions
   */
  @javax.annotation.Nullable
  public Boolean getMarginalDistributions() {
    return marginalDistributions;
  }

  public void setMarginalDistributions(Boolean marginalDistributions) {
    this.marginalDistributions = marginalDistributions;
  }


  public ChartDataPivotOptionsSchema metricFillValue(BigDecimal metricFillValue) {
    this.metricFillValue = metricFillValue;
    return this;
  }

  /**
   * Value to replace missing values with in aggregate calculations.
   * @return metricFillValue
   */
  @javax.annotation.Nullable
  public BigDecimal getMetricFillValue() {
    return metricFillValue;
  }

  public void setMetricFillValue(BigDecimal metricFillValue) {
    this.metricFillValue = metricFillValue;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ChartDataPivotOptionsSchema chartDataPivotOptionsSchema = (ChartDataPivotOptionsSchema) o;
    return Objects.equals(this.aggregates, chartDataPivotOptionsSchema.aggregates) &&
        Objects.equals(this.columnFillValue, chartDataPivotOptionsSchema.columnFillValue) &&
        Objects.equals(this.columns, chartDataPivotOptionsSchema.columns) &&
        Objects.equals(this.dropMissingColumns, chartDataPivotOptionsSchema.dropMissingColumns) &&
        Objects.equals(this.marginalDistributionName, chartDataPivotOptionsSchema.marginalDistributionName) &&
        Objects.equals(this.marginalDistributions, chartDataPivotOptionsSchema.marginalDistributions) &&
        Objects.equals(this.metricFillValue, chartDataPivotOptionsSchema.metricFillValue);
  }

  @Override
  public int hashCode() {
    return Objects.hash(aggregates, columnFillValue, columns, dropMissingColumns, marginalDistributionName, marginalDistributions, metricFillValue);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ChartDataPivotOptionsSchema {\n");
    sb.append("    aggregates: ").append(toIndentedString(aggregates)).append("\n");
    sb.append("    columnFillValue: ").append(toIndentedString(columnFillValue)).append("\n");
    sb.append("    columns: ").append(toIndentedString(columns)).append("\n");
    sb.append("    dropMissingColumns: ").append(toIndentedString(dropMissingColumns)).append("\n");
    sb.append("    marginalDistributionName: ").append(toIndentedString(marginalDistributionName)).append("\n");
    sb.append("    marginalDistributions: ").append(toIndentedString(marginalDistributions)).append("\n");
    sb.append("    metricFillValue: ").append(toIndentedString(metricFillValue)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("aggregates");
    openapiFields.add("column_fill_value");
    openapiFields.add("columns");
    openapiFields.add("drop_missing_columns");
    openapiFields.add("marginal_distribution_name");
    openapiFields.add("marginal_distributions");
    openapiFields.add("metric_fill_value");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ChartDataPivotOptionsSchema
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ChartDataPivotOptionsSchema.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ChartDataPivotOptionsSchema is not found in the empty JSON string", ChartDataPivotOptionsSchema.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ChartDataPivotOptionsSchema.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ChartDataPivotOptionsSchema` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("column_fill_value") != null && !jsonObj.get("column_fill_value").isJsonNull()) && !jsonObj.get("column_fill_value").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `column_fill_value` to be a primitive type in the JSON string but got `%s`", jsonObj.get("column_fill_value").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("columns") != null && !jsonObj.get("columns").isJsonNull() && !jsonObj.get("columns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `columns` to be an array in the JSON string but got `%s`", jsonObj.get("columns").toString()));
      }
      if ((jsonObj.get("marginal_distribution_name") != null && !jsonObj.get("marginal_distribution_name").isJsonNull()) && !jsonObj.get("marginal_distribution_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `marginal_distribution_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("marginal_distribution_name").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ChartDataPivotOptionsSchema.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ChartDataPivotOptionsSchema' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ChartDataPivotOptionsSchema> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ChartDataPivotOptionsSchema.class));

       return (TypeAdapter<T>) new TypeAdapter<ChartDataPivotOptionsSchema>() {
           @Override
           public void write(JsonWriter out, ChartDataPivotOptionsSchema value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ChartDataPivotOptionsSchema read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ChartDataPivotOptionsSchema given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ChartDataPivotOptionsSchema
   * @throws IOException if the JSON string is invalid with respect to ChartDataPivotOptionsSchema
   */
  public static ChartDataPivotOptionsSchema fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ChartDataPivotOptionsSchema.class);
  }

  /**
   * Convert an instance of ChartDataPivotOptionsSchema to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

