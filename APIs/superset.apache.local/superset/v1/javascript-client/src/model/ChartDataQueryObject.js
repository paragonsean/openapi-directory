/**
 * Superset
 * Superset
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import AnnotationLayer from './AnnotationLayer';
import ChartDataDatasource from './ChartDataDatasource';
import ChartDataExtras from './ChartDataExtras';
import ChartDataFilter from './ChartDataFilter';
import ChartDataPostProcessingOperation from './ChartDataPostProcessingOperation';

/**
 * The ChartDataQueryObject model module.
 * @module model/ChartDataQueryObject
 * @version v1
 */
class ChartDataQueryObject {
    /**
     * Constructs a new <code>ChartDataQueryObject</code>.
     * @alias module:model/ChartDataQueryObject
     */
    constructor() { 
        
        ChartDataQueryObject.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>ChartDataQueryObject</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ChartDataQueryObject} obj Optional instance to populate.
     * @return {module:model/ChartDataQueryObject} The populated <code>ChartDataQueryObject</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ChartDataQueryObject();

            if (data.hasOwnProperty('annotation_layers')) {
                obj['annotation_layers'] = ApiClient.convertToType(data['annotation_layers'], [AnnotationLayer]);
            }
            if (data.hasOwnProperty('applied_time_extras')) {
                obj['applied_time_extras'] = ApiClient.convertToType(data['applied_time_extras'], Object);
            }
            if (data.hasOwnProperty('apply_fetch_values_predicate')) {
                obj['apply_fetch_values_predicate'] = ApiClient.convertToType(data['apply_fetch_values_predicate'], 'Boolean');
            }
            if (data.hasOwnProperty('columns')) {
                obj['columns'] = ApiClient.convertToType(data['columns'], ['String']);
            }
            if (data.hasOwnProperty('datasource')) {
                obj['datasource'] = ApiClient.convertToType(data['datasource'], ChartDataDatasource);
            }
            if (data.hasOwnProperty('druid_time_origin')) {
                obj['druid_time_origin'] = ApiClient.convertToType(data['druid_time_origin'], 'String');
            }
            if (data.hasOwnProperty('extras')) {
                obj['extras'] = ApiClient.convertToType(data['extras'], ChartDataExtras);
            }
            if (data.hasOwnProperty('filters')) {
                obj['filters'] = ApiClient.convertToType(data['filters'], [ChartDataFilter]);
            }
            if (data.hasOwnProperty('granularity')) {
                obj['granularity'] = ApiClient.convertToType(data['granularity'], 'String');
            }
            if (data.hasOwnProperty('granularity_sqla')) {
                obj['granularity_sqla'] = ApiClient.convertToType(data['granularity_sqla'], 'String');
            }
            if (data.hasOwnProperty('groupby')) {
                obj['groupby'] = ApiClient.convertToType(data['groupby'], ['String']);
            }
            if (data.hasOwnProperty('having')) {
                obj['having'] = ApiClient.convertToType(data['having'], 'String');
            }
            if (data.hasOwnProperty('having_filters')) {
                obj['having_filters'] = ApiClient.convertToType(data['having_filters'], [ChartDataFilter]);
            }
            if (data.hasOwnProperty('is_rowcount')) {
                obj['is_rowcount'] = ApiClient.convertToType(data['is_rowcount'], 'Boolean');
            }
            if (data.hasOwnProperty('is_timeseries')) {
                obj['is_timeseries'] = ApiClient.convertToType(data['is_timeseries'], 'Boolean');
            }
            if (data.hasOwnProperty('metrics')) {
                obj['metrics'] = ApiClient.convertToType(data['metrics'], [Object]);
            }
            if (data.hasOwnProperty('order_desc')) {
                obj['order_desc'] = ApiClient.convertToType(data['order_desc'], 'Boolean');
            }
            if (data.hasOwnProperty('orderby')) {
                obj['orderby'] = ApiClient.convertToType(data['orderby'], [Object]);
            }
            if (data.hasOwnProperty('post_processing')) {
                obj['post_processing'] = ApiClient.convertToType(data['post_processing'], [ChartDataPostProcessingOperation]);
            }
            if (data.hasOwnProperty('result_type')) {
                obj['result_type'] = ApiClient.convertToType(data['result_type'], Object);
            }
            if (data.hasOwnProperty('row_limit')) {
                obj['row_limit'] = ApiClient.convertToType(data['row_limit'], 'Number');
            }
            if (data.hasOwnProperty('row_offset')) {
                obj['row_offset'] = ApiClient.convertToType(data['row_offset'], 'Number');
            }
            if (data.hasOwnProperty('time_offsets')) {
                obj['time_offsets'] = ApiClient.convertToType(data['time_offsets'], ['String']);
            }
            if (data.hasOwnProperty('time_range')) {
                obj['time_range'] = ApiClient.convertToType(data['time_range'], 'String');
            }
            if (data.hasOwnProperty('time_shift')) {
                obj['time_shift'] = ApiClient.convertToType(data['time_shift'], 'String');
            }
            if (data.hasOwnProperty('timeseries_limit')) {
                obj['timeseries_limit'] = ApiClient.convertToType(data['timeseries_limit'], 'Number');
            }
            if (data.hasOwnProperty('timeseries_limit_metric')) {
                obj['timeseries_limit_metric'] = ApiClient.convertToType(data['timeseries_limit_metric'], Object);
            }
            if (data.hasOwnProperty('url_params')) {
                obj['url_params'] = ApiClient.convertToType(data['url_params'], {'String': 'String'});
            }
            if (data.hasOwnProperty('where')) {
                obj['where'] = ApiClient.convertToType(data['where'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ChartDataQueryObject</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ChartDataQueryObject</code>.
     */
    static validateJSON(data) {
        if (data['annotation_layers']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['annotation_layers'])) {
                throw new Error("Expected the field `annotation_layers` to be an array in the JSON data but got " + data['annotation_layers']);
            }
            // validate the optional field `annotation_layers` (array)
            for (const item of data['annotation_layers']) {
                AnnotationLayer.validateJSON(item);
            };
        }
        // ensure the json data is an array
        if (!Array.isArray(data['columns'])) {
            throw new Error("Expected the field `columns` to be an array in the JSON data but got " + data['columns']);
        }
        // validate the optional field `datasource`
        if (data['datasource']) { // data not null
          ChartDataDatasource.validateJSON(data['datasource']);
        }
        // ensure the json data is a string
        if (data['druid_time_origin'] && !(typeof data['druid_time_origin'] === 'string' || data['druid_time_origin'] instanceof String)) {
            throw new Error("Expected the field `druid_time_origin` to be a primitive type in the JSON string but got " + data['druid_time_origin']);
        }
        // validate the optional field `extras`
        if (data['extras']) { // data not null
          ChartDataExtras.validateJSON(data['extras']);
        }
        if (data['filters']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['filters'])) {
                throw new Error("Expected the field `filters` to be an array in the JSON data but got " + data['filters']);
            }
            // validate the optional field `filters` (array)
            for (const item of data['filters']) {
                ChartDataFilter.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['granularity'] && !(typeof data['granularity'] === 'string' || data['granularity'] instanceof String)) {
            throw new Error("Expected the field `granularity` to be a primitive type in the JSON string but got " + data['granularity']);
        }
        // ensure the json data is a string
        if (data['granularity_sqla'] && !(typeof data['granularity_sqla'] === 'string' || data['granularity_sqla'] instanceof String)) {
            throw new Error("Expected the field `granularity_sqla` to be a primitive type in the JSON string but got " + data['granularity_sqla']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['groupby'])) {
            throw new Error("Expected the field `groupby` to be an array in the JSON data but got " + data['groupby']);
        }
        // ensure the json data is a string
        if (data['having'] && !(typeof data['having'] === 'string' || data['having'] instanceof String)) {
            throw new Error("Expected the field `having` to be a primitive type in the JSON string but got " + data['having']);
        }
        if (data['having_filters']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['having_filters'])) {
                throw new Error("Expected the field `having_filters` to be an array in the JSON data but got " + data['having_filters']);
            }
            // validate the optional field `having_filters` (array)
            for (const item of data['having_filters']) {
                ChartDataFilter.validateJSON(item);
            };
        }
        // ensure the json data is an array
        if (!Array.isArray(data['metrics'])) {
            throw new Error("Expected the field `metrics` to be an array in the JSON data but got " + data['metrics']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['orderby'])) {
            throw new Error("Expected the field `orderby` to be an array in the JSON data but got " + data['orderby']);
        }
        if (data['post_processing']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['post_processing'])) {
                throw new Error("Expected the field `post_processing` to be an array in the JSON data but got " + data['post_processing']);
            }
            // validate the optional field `post_processing` (array)
            for (const item of data['post_processing']) {
                ChartDataPostProcessingOperation.validateJSON(item);
            };
        }
        // ensure the json data is an array
        if (!Array.isArray(data['time_offsets'])) {
            throw new Error("Expected the field `time_offsets` to be an array in the JSON data but got " + data['time_offsets']);
        }
        // ensure the json data is a string
        if (data['time_range'] && !(typeof data['time_range'] === 'string' || data['time_range'] instanceof String)) {
            throw new Error("Expected the field `time_range` to be a primitive type in the JSON string but got " + data['time_range']);
        }
        // ensure the json data is a string
        if (data['time_shift'] && !(typeof data['time_shift'] === 'string' || data['time_shift'] instanceof String)) {
            throw new Error("Expected the field `time_shift` to be a primitive type in the JSON string but got " + data['time_shift']);
        }
        // ensure the json data is a string
        if (data['where'] && !(typeof data['where'] === 'string' || data['where'] instanceof String)) {
            throw new Error("Expected the field `where` to be a primitive type in the JSON string but got " + data['where']);
        }

        return true;
    }


}



/**
 * Annotation layers to apply to chart
 * @member {Array.<module:model/AnnotationLayer>} annotation_layers
 */
ChartDataQueryObject.prototype['annotation_layers'] = undefined;

/**
 * A mapping of temporal extras that have been applied to the query
 * @member {Object} applied_time_extras
 */
ChartDataQueryObject.prototype['applied_time_extras'] = undefined;

/**
 * Add fetch values predicate (where clause) to query if defined in datasource
 * @member {Boolean} apply_fetch_values_predicate
 */
ChartDataQueryObject.prototype['apply_fetch_values_predicate'] = undefined;

/**
 * Columns which to select in the query.
 * @member {Array.<String>} columns
 */
ChartDataQueryObject.prototype['columns'] = undefined;

/**
 * @member {module:model/ChartDataDatasource} datasource
 */
ChartDataQueryObject.prototype['datasource'] = undefined;

/**
 * Starting point for time grain counting on legacy Druid datasources. Used to change e.g. Monday/Sunday first-day-of-week. This field is deprecated and should be passed to `extras` as `druid_time_origin`.
 * @member {String} druid_time_origin
 */
ChartDataQueryObject.prototype['druid_time_origin'] = undefined;

/**
 * Extra parameters to add to the query.
 * @member {module:model/ChartDataExtras} extras
 */
ChartDataQueryObject.prototype['extras'] = undefined;

/**
 * @member {Array.<module:model/ChartDataFilter>} filters
 */
ChartDataQueryObject.prototype['filters'] = undefined;

/**
 * Name of temporal column used for time filtering. For legacy Druid datasources this defines the time grain.
 * @member {String} granularity
 */
ChartDataQueryObject.prototype['granularity'] = undefined;

/**
 * Name of temporal column used for time filtering for SQL datasources. This field is deprecated, use `granularity` instead.
 * @member {String} granularity_sqla
 */
ChartDataQueryObject.prototype['granularity_sqla'] = undefined;

/**
 * @member {Array.<String>} groupby
 */
ChartDataQueryObject.prototype['groupby'] = undefined;

/**
 * HAVING clause to be added to aggregate queries using AND operator. This field is deprecated and should be passed to `extras`.
 * @member {String} having
 */
ChartDataQueryObject.prototype['having'] = undefined;

/**
 * HAVING filters to be added to legacy Druid datasource queries. This field is deprecated and should be passed to `extras` as `having_druid`.
 * @member {Array.<module:model/ChartDataFilter>} having_filters
 */
ChartDataQueryObject.prototype['having_filters'] = undefined;

/**
 * Should the rowcount of the actual query be returned
 * @member {Boolean} is_rowcount
 */
ChartDataQueryObject.prototype['is_rowcount'] = undefined;

/**
 * Is the `query_object` a timeseries.
 * @member {Boolean} is_timeseries
 */
ChartDataQueryObject.prototype['is_timeseries'] = undefined;

/**
 * Aggregate expressions. Metrics can be passed as both references to datasource metrics (strings), or ad-hoc metricswhich are defined only within the query object. See `ChartDataAdhocMetricSchema` for the structure of ad-hoc metrics.
 * @member {Array.<Object>} metrics
 */
ChartDataQueryObject.prototype['metrics'] = undefined;

/**
 * Reverse order. Default: `false`
 * @member {Boolean} order_desc
 */
ChartDataQueryObject.prototype['order_desc'] = undefined;

/**
 * Expects a list of lists where the first element is the column name which to sort by, and the second element is a boolean.
 * @member {Array.<Object>} orderby
 */
ChartDataQueryObject.prototype['orderby'] = undefined;

/**
 * Post processing operations to be applied to the result set. Operations are applied to the result set in sequential order.
 * @member {Array.<module:model/ChartDataPostProcessingOperation>} post_processing
 */
ChartDataQueryObject.prototype['post_processing'] = undefined;

/**
 * @member {Object} result_type
 */
ChartDataQueryObject.prototype['result_type'] = undefined;

/**
 * Maximum row count (0=disabled). Default: `config[\"ROW_LIMIT\"]`
 * @member {Number} row_limit
 */
ChartDataQueryObject.prototype['row_limit'] = undefined;

/**
 * Number of rows to skip. Default: `0`
 * @member {Number} row_offset
 */
ChartDataQueryObject.prototype['row_offset'] = undefined;

/**
 * @member {Array.<String>} time_offsets
 */
ChartDataQueryObject.prototype['time_offsets'] = undefined;

/**
 * A time rage, either expressed as a colon separated string `since : until` or human readable freeform. Valid formats for `since` and `until` are:  - ISO 8601 - X days/years/hours/day/year/weeks - X days/years/hours/day/year/weeks ago - X days/years/hours/day/year/weeks from now  Additionally, the following freeform can be used:  - Last day - Last week - Last month - Last quarter - Last year - No filter - Last X seconds/minutes/hours/days/weeks/months/years - Next X seconds/minutes/hours/days/weeks/months/years 
 * @member {String} time_range
 */
ChartDataQueryObject.prototype['time_range'] = undefined;

/**
 * A human-readable date/time string. Please refer to [parsdatetime](https://github.com/bear/parsedatetime) documentation for details on valid values.
 * @member {String} time_shift
 */
ChartDataQueryObject.prototype['time_shift'] = undefined;

/**
 * Maximum row count for timeseries queries. Default: `0`
 * @member {Number} timeseries_limit
 */
ChartDataQueryObject.prototype['timeseries_limit'] = undefined;

/**
 * Metric used to limit timeseries queries by.
 * @member {Object} timeseries_limit_metric
 */
ChartDataQueryObject.prototype['timeseries_limit_metric'] = undefined;

/**
 * Optional query parameters passed to a dashboard or Explore view
 * @member {Object.<String, String>} url_params
 */
ChartDataQueryObject.prototype['url_params'] = undefined;

/**
 * WHERE clause to be added to queries using AND operator.This field is deprecated and should be passed to `extras`.
 * @member {String} where
 */
ChartDataQueryObject.prototype['where'] = undefined;






export default ChartDataQueryObject;

