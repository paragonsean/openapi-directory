/**
 * Superset
 * Superset
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import ChartDataFilter from './ChartDataFilter';

/**
 * The ChartDataExtras model module.
 * @module model/ChartDataExtras
 * @version v1
 */
class ChartDataExtras {
    /**
     * Constructs a new <code>ChartDataExtras</code>.
     * @alias module:model/ChartDataExtras
     */
    constructor() { 
        
        ChartDataExtras.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>ChartDataExtras</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ChartDataExtras} obj Optional instance to populate.
     * @return {module:model/ChartDataExtras} The populated <code>ChartDataExtras</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ChartDataExtras();

            if (data.hasOwnProperty('druid_time_origin')) {
                obj['druid_time_origin'] = ApiClient.convertToType(data['druid_time_origin'], 'String');
            }
            if (data.hasOwnProperty('having')) {
                obj['having'] = ApiClient.convertToType(data['having'], 'String');
            }
            if (data.hasOwnProperty('having_druid')) {
                obj['having_druid'] = ApiClient.convertToType(data['having_druid'], [ChartDataFilter]);
            }
            if (data.hasOwnProperty('relative_end')) {
                obj['relative_end'] = ApiClient.convertToType(data['relative_end'], 'String');
            }
            if (data.hasOwnProperty('relative_start')) {
                obj['relative_start'] = ApiClient.convertToType(data['relative_start'], 'String');
            }
            if (data.hasOwnProperty('time_grain_sqla')) {
                obj['time_grain_sqla'] = ApiClient.convertToType(data['time_grain_sqla'], 'String');
            }
            if (data.hasOwnProperty('time_range_endpoints')) {
                obj['time_range_endpoints'] = ApiClient.convertToType(data['time_range_endpoints'], [Object]);
            }
            if (data.hasOwnProperty('where')) {
                obj['where'] = ApiClient.convertToType(data['where'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ChartDataExtras</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ChartDataExtras</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['druid_time_origin'] && !(typeof data['druid_time_origin'] === 'string' || data['druid_time_origin'] instanceof String)) {
            throw new Error("Expected the field `druid_time_origin` to be a primitive type in the JSON string but got " + data['druid_time_origin']);
        }
        // ensure the json data is a string
        if (data['having'] && !(typeof data['having'] === 'string' || data['having'] instanceof String)) {
            throw new Error("Expected the field `having` to be a primitive type in the JSON string but got " + data['having']);
        }
        if (data['having_druid']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['having_druid'])) {
                throw new Error("Expected the field `having_druid` to be an array in the JSON data but got " + data['having_druid']);
            }
            // validate the optional field `having_druid` (array)
            for (const item of data['having_druid']) {
                ChartDataFilter.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['relative_end'] && !(typeof data['relative_end'] === 'string' || data['relative_end'] instanceof String)) {
            throw new Error("Expected the field `relative_end` to be a primitive type in the JSON string but got " + data['relative_end']);
        }
        // ensure the json data is a string
        if (data['relative_start'] && !(typeof data['relative_start'] === 'string' || data['relative_start'] instanceof String)) {
            throw new Error("Expected the field `relative_start` to be a primitive type in the JSON string but got " + data['relative_start']);
        }
        // ensure the json data is a string
        if (data['time_grain_sqla'] && !(typeof data['time_grain_sqla'] === 'string' || data['time_grain_sqla'] instanceof String)) {
            throw new Error("Expected the field `time_grain_sqla` to be a primitive type in the JSON string but got " + data['time_grain_sqla']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['time_range_endpoints'])) {
            throw new Error("Expected the field `time_range_endpoints` to be an array in the JSON data but got " + data['time_range_endpoints']);
        }
        // ensure the json data is a string
        if (data['where'] && !(typeof data['where'] === 'string' || data['where'] instanceof String)) {
            throw new Error("Expected the field `where` to be a primitive type in the JSON string but got " + data['where']);
        }

        return true;
    }


}



/**
 * Starting point for time grain counting on legacy Druid datasources. Used to change e.g. Monday/Sunday first-day-of-week.
 * @member {String} druid_time_origin
 */
ChartDataExtras.prototype['druid_time_origin'] = undefined;

/**
 * HAVING clause to be added to aggregate queries using AND operator.
 * @member {String} having
 */
ChartDataExtras.prototype['having'] = undefined;

/**
 * HAVING filters to be added to legacy Druid datasource queries.
 * @member {Array.<module:model/ChartDataFilter>} having_druid
 */
ChartDataExtras.prototype['having_druid'] = undefined;

/**
 * End time for relative time deltas. Default: `config[\"DEFAULT_RELATIVE_START_TIME\"]`
 * @member {module:model/ChartDataExtras.RelativeEndEnum} relative_end
 */
ChartDataExtras.prototype['relative_end'] = undefined;

/**
 * Start time for relative time deltas. Default: `config[\"DEFAULT_RELATIVE_START_TIME\"]`
 * @member {module:model/ChartDataExtras.RelativeStartEnum} relative_start
 */
ChartDataExtras.prototype['relative_start'] = undefined;

/**
 * To what level of granularity should the temporal column be aggregated. Supports [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) durations.
 * @member {module:model/ChartDataExtras.TimeGrainSqlaEnum} time_grain_sqla
 */
ChartDataExtras.prototype['time_grain_sqla'] = undefined;

/**
 * @member {Array.<Object>} time_range_endpoints
 */
ChartDataExtras.prototype['time_range_endpoints'] = undefined;

/**
 * WHERE clause to be added to queries using AND operator.
 * @member {String} where
 */
ChartDataExtras.prototype['where'] = undefined;





/**
 * Allowed values for the <code>relative_end</code> property.
 * @enum {String}
 * @readonly
 */
ChartDataExtras['RelativeEndEnum'] = {

    /**
     * value: "today"
     * @const
     */
    "today": "today",

    /**
     * value: "now"
     * @const
     */
    "now": "now"
};


/**
 * Allowed values for the <code>relative_start</code> property.
 * @enum {String}
 * @readonly
 */
ChartDataExtras['RelativeStartEnum'] = {

    /**
     * value: "today"
     * @const
     */
    "today": "today",

    /**
     * value: "now"
     * @const
     */
    "now": "now"
};


/**
 * Allowed values for the <code>time_grain_sqla</code> property.
 * @enum {String}
 * @readonly
 */
ChartDataExtras['TimeGrainSqlaEnum'] = {

    /**
     * value: "PT1S"
     * @const
     */
    "PT1S": "PT1S",

    /**
     * value: "PT5S"
     * @const
     */
    "PT5S": "PT5S",

    /**
     * value: "PT30S"
     * @const
     */
    "PT30S": "PT30S",

    /**
     * value: "PT1M"
     * @const
     */
    "PT1M": "PT1M",

    /**
     * value: "PT5M"
     * @const
     */
    "PT5M": "PT5M",

    /**
     * value: "PT10M"
     * @const
     */
    "PT10M": "PT10M",

    /**
     * value: "PT15M"
     * @const
     */
    "PT15M": "PT15M",

    /**
     * value: "PT0.5H"
     * @const
     */
    "PT0.5H": "PT0.5H",

    /**
     * value: "PT1H"
     * @const
     */
    "PT1H": "PT1H",

    /**
     * value: "PT6H"
     * @const
     */
    "PT6H": "PT6H",

    /**
     * value: "P1D"
     * @const
     */
    "P1D": "P1D",

    /**
     * value: "P1W"
     * @const
     */
    "P1W": "P1W",

    /**
     * value: "P1M"
     * @const
     */
    "P1M": "P1M",

    /**
     * value: "P0.25Y"
     * @const
     */
    "P0.25Y": "P0.25Y",

    /**
     * value: "P1Y"
     * @const
     */
    "P1Y": "P1Y",

    /**
     * value: "1969-12-28T00:00:00Z/P1W"
     * @const
     */
    "1969-12-28T00:00:00Z/P1W": "1969-12-28T00:00:00Z/P1W",

    /**
     * value: "1969-12-29T00:00:00Z/P1W"
     * @const
     */
    "1969-12-29T00:00:00Z/P1W": "1969-12-29T00:00:00Z/P1W",

    /**
     * value: "P1W/1970-01-03T00:00:00Z"
     * @const
     */
    "P1W/1970-01-03T00:00:00Z": "P1W/1970-01-03T00:00:00Z",

    /**
     * value: "P1W/1970-01-04T00:00:00Z"
     * @const
     */
    "P1W/1970-01-04T00:00:00Z": "P1W/1970-01-04T00:00:00Z"
};



export default ChartDataExtras;

