/**
 * Superset
 * Superset
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import ChartDataColumn from './ChartDataColumn';

/**
 * The ChartDataAdhocMetricSchema model module.
 * @module model/ChartDataAdhocMetricSchema
 * @version v1
 */
class ChartDataAdhocMetricSchema {
    /**
     * Constructs a new <code>ChartDataAdhocMetricSchema</code>.
     * @alias module:model/ChartDataAdhocMetricSchema
     * @param expressionType {module:model/ChartDataAdhocMetricSchema.ExpressionTypeEnum} Simple or SQL metric
     */
    constructor(expressionType) { 
        
        ChartDataAdhocMetricSchema.initialize(this, expressionType);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, expressionType) { 
        obj['expressionType'] = expressionType;
    }

    /**
     * Constructs a <code>ChartDataAdhocMetricSchema</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ChartDataAdhocMetricSchema} obj Optional instance to populate.
     * @return {module:model/ChartDataAdhocMetricSchema} The populated <code>ChartDataAdhocMetricSchema</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ChartDataAdhocMetricSchema();

            if (data.hasOwnProperty('aggregate')) {
                obj['aggregate'] = ApiClient.convertToType(data['aggregate'], 'String');
            }
            if (data.hasOwnProperty('column')) {
                obj['column'] = ChartDataColumn.constructFromObject(data['column']);
            }
            if (data.hasOwnProperty('expressionType')) {
                obj['expressionType'] = ApiClient.convertToType(data['expressionType'], 'String');
            }
            if (data.hasOwnProperty('hasCustomLabel')) {
                obj['hasCustomLabel'] = ApiClient.convertToType(data['hasCustomLabel'], 'Boolean');
            }
            if (data.hasOwnProperty('label')) {
                obj['label'] = ApiClient.convertToType(data['label'], 'String');
            }
            if (data.hasOwnProperty('optionName')) {
                obj['optionName'] = ApiClient.convertToType(data['optionName'], 'String');
            }
            if (data.hasOwnProperty('sqlExpression')) {
                obj['sqlExpression'] = ApiClient.convertToType(data['sqlExpression'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ChartDataAdhocMetricSchema</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ChartDataAdhocMetricSchema</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of ChartDataAdhocMetricSchema.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['aggregate'] && !(typeof data['aggregate'] === 'string' || data['aggregate'] instanceof String)) {
            throw new Error("Expected the field `aggregate` to be a primitive type in the JSON string but got " + data['aggregate']);
        }
        // validate the optional field `column`
        if (data['column']) { // data not null
          ChartDataColumn.validateJSON(data['column']);
        }
        // ensure the json data is a string
        if (data['expressionType'] && !(typeof data['expressionType'] === 'string' || data['expressionType'] instanceof String)) {
            throw new Error("Expected the field `expressionType` to be a primitive type in the JSON string but got " + data['expressionType']);
        }
        // ensure the json data is a string
        if (data['label'] && !(typeof data['label'] === 'string' || data['label'] instanceof String)) {
            throw new Error("Expected the field `label` to be a primitive type in the JSON string but got " + data['label']);
        }
        // ensure the json data is a string
        if (data['optionName'] && !(typeof data['optionName'] === 'string' || data['optionName'] instanceof String)) {
            throw new Error("Expected the field `optionName` to be a primitive type in the JSON string but got " + data['optionName']);
        }
        // ensure the json data is a string
        if (data['sqlExpression'] && !(typeof data['sqlExpression'] === 'string' || data['sqlExpression'] instanceof String)) {
            throw new Error("Expected the field `sqlExpression` to be a primitive type in the JSON string but got " + data['sqlExpression']);
        }

        return true;
    }


}

ChartDataAdhocMetricSchema.RequiredProperties = ["expressionType"];

/**
 * Aggregation operator. Only required for simple expression types.
 * @member {module:model/ChartDataAdhocMetricSchema.AggregateEnum} aggregate
 */
ChartDataAdhocMetricSchema.prototype['aggregate'] = undefined;

/**
 * @member {module:model/ChartDataColumn} column
 */
ChartDataAdhocMetricSchema.prototype['column'] = undefined;

/**
 * Simple or SQL metric
 * @member {module:model/ChartDataAdhocMetricSchema.ExpressionTypeEnum} expressionType
 */
ChartDataAdhocMetricSchema.prototype['expressionType'] = undefined;

/**
 * When false, the label will be automatically generated based on the aggregate expression. When true, a custom label has to be specified.
 * @member {Boolean} hasCustomLabel
 */
ChartDataAdhocMetricSchema.prototype['hasCustomLabel'] = undefined;

/**
 * Label for the metric. Is automatically generated unless hasCustomLabel is true, in which case label must be defined.
 * @member {String} label
 */
ChartDataAdhocMetricSchema.prototype['label'] = undefined;

/**
 * Unique identifier. Can be any string value, as long as all metrics have a unique identifier. If undefined, a random name will be generated.
 * @member {String} optionName
 */
ChartDataAdhocMetricSchema.prototype['optionName'] = undefined;

/**
 * The metric as defined by a SQL aggregate expression. Only required for SQL expression type.
 * @member {String} sqlExpression
 */
ChartDataAdhocMetricSchema.prototype['sqlExpression'] = undefined;





/**
 * Allowed values for the <code>aggregate</code> property.
 * @enum {String}
 * @readonly
 */
ChartDataAdhocMetricSchema['AggregateEnum'] = {

    /**
     * value: "AVG"
     * @const
     */
    "AVG": "AVG",

    /**
     * value: "COUNT"
     * @const
     */
    "COUNT": "COUNT",

    /**
     * value: "COUNT_DISTINCT"
     * @const
     */
    "COUNT_DISTINCT": "COUNT_DISTINCT",

    /**
     * value: "MAX"
     * @const
     */
    "MAX": "MAX",

    /**
     * value: "MIN"
     * @const
     */
    "MIN": "MIN",

    /**
     * value: "SUM"
     * @const
     */
    "SUM": "SUM"
};


/**
 * Allowed values for the <code>expressionType</code> property.
 * @enum {String}
 * @readonly
 */
ChartDataAdhocMetricSchema['ExpressionTypeEnum'] = {

    /**
     * value: "SIMPLE"
     * @const
     */
    "SIMPLE": "SIMPLE",

    /**
     * value: "SQL"
     * @const
     */
    "SQL": "SQL"
};



export default ChartDataAdhocMetricSchema;

