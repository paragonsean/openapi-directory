/**
 * Superset
 * Superset
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIChartDataResponseResult.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIChartDataResponseResult::OAIChartDataResponseResult(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIChartDataResponseResult::OAIChartDataResponseResult() {
    this->initializeModel();
}

OAIChartDataResponseResult::~OAIChartDataResponseResult() {}

void OAIChartDataResponseResult::initializeModel() {

    m_annotation_data_isSet = false;
    m_annotation_data_isValid = false;

    m_applied_filters_isSet = false;
    m_applied_filters_isValid = false;

    m_cache_key_isSet = false;
    m_cache_key_isValid = false;

    m_cache_timeout_isSet = false;
    m_cache_timeout_isValid = false;

    m_cached_dttm_isSet = false;
    m_cached_dttm_isValid = false;

    m_data_isSet = false;
    m_data_isValid = false;

    m_error_isSet = false;
    m_error_isValid = false;

    m_is_cached_isSet = false;
    m_is_cached_isValid = false;

    m_query_isSet = false;
    m_query_isValid = false;

    m_rejected_filters_isSet = false;
    m_rejected_filters_isValid = false;

    m_rowcount_isSet = false;
    m_rowcount_isValid = false;

    m_stacktrace_isSet = false;
    m_stacktrace_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;
}

void OAIChartDataResponseResult::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIChartDataResponseResult::fromJsonObject(QJsonObject json) {

    if(json["annotation_data"].isArray()){
        auto arr = json["annotation_data"].toArray();
        m_annotation_data_isValid = true;
        if(arr.count() > 0) {
            for (const QJsonValue jval : arr) {
                QMap<QString, QString> item;
                m_annotation_data_isValid &= ::OpenAPI::fromJsonValue(item, jval);
                m_annotation_data_isSet = !jval.isNull() && m_annotation_data_isValid;
                m_annotation_data.push_back(item);
            }
        }
    }

    m_applied_filters_isValid = ::OpenAPI::fromJsonValue(m_applied_filters, json[QString("applied_filters")]);
    m_applied_filters_isSet = !json[QString("applied_filters")].isNull() && m_applied_filters_isValid;

    m_cache_key_isValid = ::OpenAPI::fromJsonValue(m_cache_key, json[QString("cache_key")]);
    m_cache_key_isSet = !json[QString("cache_key")].isNull() && m_cache_key_isValid;

    m_cache_timeout_isValid = ::OpenAPI::fromJsonValue(m_cache_timeout, json[QString("cache_timeout")]);
    m_cache_timeout_isSet = !json[QString("cache_timeout")].isNull() && m_cache_timeout_isValid;

    m_cached_dttm_isValid = ::OpenAPI::fromJsonValue(m_cached_dttm, json[QString("cached_dttm")]);
    m_cached_dttm_isSet = !json[QString("cached_dttm")].isNull() && m_cached_dttm_isValid;

    m_data_isValid = ::OpenAPI::fromJsonValue(m_data, json[QString("data")]);
    m_data_isSet = !json[QString("data")].isNull() && m_data_isValid;

    m_error_isValid = ::OpenAPI::fromJsonValue(m_error, json[QString("error")]);
    m_error_isSet = !json[QString("error")].isNull() && m_error_isValid;

    m_is_cached_isValid = ::OpenAPI::fromJsonValue(m_is_cached, json[QString("is_cached")]);
    m_is_cached_isSet = !json[QString("is_cached")].isNull() && m_is_cached_isValid;

    m_query_isValid = ::OpenAPI::fromJsonValue(m_query, json[QString("query")]);
    m_query_isSet = !json[QString("query")].isNull() && m_query_isValid;

    m_rejected_filters_isValid = ::OpenAPI::fromJsonValue(m_rejected_filters, json[QString("rejected_filters")]);
    m_rejected_filters_isSet = !json[QString("rejected_filters")].isNull() && m_rejected_filters_isValid;

    m_rowcount_isValid = ::OpenAPI::fromJsonValue(m_rowcount, json[QString("rowcount")]);
    m_rowcount_isSet = !json[QString("rowcount")].isNull() && m_rowcount_isValid;

    m_stacktrace_isValid = ::OpenAPI::fromJsonValue(m_stacktrace, json[QString("stacktrace")]);
    m_stacktrace_isSet = !json[QString("stacktrace")].isNull() && m_stacktrace_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;
}

QString OAIChartDataResponseResult::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIChartDataResponseResult::asJsonObject() const {
    QJsonObject obj;
    if (m_annotation_data.size() > 0) {
        
        obj.insert(QString("annotation_data"), toJsonValue(m_annotation_data));
    }
    if (m_applied_filters.size() > 0) {
        obj.insert(QString("applied_filters"), ::OpenAPI::toJsonValue(m_applied_filters));
    }
    if (m_cache_key_isSet) {
        obj.insert(QString("cache_key"), ::OpenAPI::toJsonValue(m_cache_key));
    }
    if (m_cache_timeout_isSet) {
        obj.insert(QString("cache_timeout"), ::OpenAPI::toJsonValue(m_cache_timeout));
    }
    if (m_cached_dttm_isSet) {
        obj.insert(QString("cached_dttm"), ::OpenAPI::toJsonValue(m_cached_dttm));
    }
    if (m_data.size() > 0) {
        obj.insert(QString("data"), ::OpenAPI::toJsonValue(m_data));
    }
    if (m_error_isSet) {
        obj.insert(QString("error"), ::OpenAPI::toJsonValue(m_error));
    }
    if (m_is_cached_isSet) {
        obj.insert(QString("is_cached"), ::OpenAPI::toJsonValue(m_is_cached));
    }
    if (m_query_isSet) {
        obj.insert(QString("query"), ::OpenAPI::toJsonValue(m_query));
    }
    if (m_rejected_filters.size() > 0) {
        obj.insert(QString("rejected_filters"), ::OpenAPI::toJsonValue(m_rejected_filters));
    }
    if (m_rowcount_isSet) {
        obj.insert(QString("rowcount"), ::OpenAPI::toJsonValue(m_rowcount));
    }
    if (m_stacktrace_isSet) {
        obj.insert(QString("stacktrace"), ::OpenAPI::toJsonValue(m_stacktrace));
    }
    if (m_status_isSet) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    return obj;
}

QList<QMap<QString, QString>> OAIChartDataResponseResult::getAnnotationData() const {
    return m_annotation_data;
}
void OAIChartDataResponseResult::setAnnotationData(const QList<QMap<QString, QString>> &annotation_data) {
    m_annotation_data = annotation_data;
    m_annotation_data_isSet = true;
}

bool OAIChartDataResponseResult::is_annotation_data_Set() const{
    return m_annotation_data_isSet;
}

bool OAIChartDataResponseResult::is_annotation_data_Valid() const{
    return m_annotation_data_isValid;
}

QList<OAIObject> OAIChartDataResponseResult::getAppliedFilters() const {
    return m_applied_filters;
}
void OAIChartDataResponseResult::setAppliedFilters(const QList<OAIObject> &applied_filters) {
    m_applied_filters = applied_filters;
    m_applied_filters_isSet = true;
}

bool OAIChartDataResponseResult::is_applied_filters_Set() const{
    return m_applied_filters_isSet;
}

bool OAIChartDataResponseResult::is_applied_filters_Valid() const{
    return m_applied_filters_isValid;
}

QString OAIChartDataResponseResult::getCacheKey() const {
    return m_cache_key;
}
void OAIChartDataResponseResult::setCacheKey(const QString &cache_key) {
    m_cache_key = cache_key;
    m_cache_key_isSet = true;
}

bool OAIChartDataResponseResult::is_cache_key_Set() const{
    return m_cache_key_isSet;
}

bool OAIChartDataResponseResult::is_cache_key_Valid() const{
    return m_cache_key_isValid;
}

qint32 OAIChartDataResponseResult::getCacheTimeout() const {
    return m_cache_timeout;
}
void OAIChartDataResponseResult::setCacheTimeout(const qint32 &cache_timeout) {
    m_cache_timeout = cache_timeout;
    m_cache_timeout_isSet = true;
}

bool OAIChartDataResponseResult::is_cache_timeout_Set() const{
    return m_cache_timeout_isSet;
}

bool OAIChartDataResponseResult::is_cache_timeout_Valid() const{
    return m_cache_timeout_isValid;
}

QString OAIChartDataResponseResult::getCachedDttm() const {
    return m_cached_dttm;
}
void OAIChartDataResponseResult::setCachedDttm(const QString &cached_dttm) {
    m_cached_dttm = cached_dttm;
    m_cached_dttm_isSet = true;
}

bool OAIChartDataResponseResult::is_cached_dttm_Set() const{
    return m_cached_dttm_isSet;
}

bool OAIChartDataResponseResult::is_cached_dttm_Valid() const{
    return m_cached_dttm_isValid;
}

QList<OAIObject> OAIChartDataResponseResult::getData() const {
    return m_data;
}
void OAIChartDataResponseResult::setData(const QList<OAIObject> &data) {
    m_data = data;
    m_data_isSet = true;
}

bool OAIChartDataResponseResult::is_data_Set() const{
    return m_data_isSet;
}

bool OAIChartDataResponseResult::is_data_Valid() const{
    return m_data_isValid;
}

QString OAIChartDataResponseResult::getError() const {
    return m_error;
}
void OAIChartDataResponseResult::setError(const QString &error) {
    m_error = error;
    m_error_isSet = true;
}

bool OAIChartDataResponseResult::is_error_Set() const{
    return m_error_isSet;
}

bool OAIChartDataResponseResult::is_error_Valid() const{
    return m_error_isValid;
}

bool OAIChartDataResponseResult::isIsCached() const {
    return m_is_cached;
}
void OAIChartDataResponseResult::setIsCached(const bool &is_cached) {
    m_is_cached = is_cached;
    m_is_cached_isSet = true;
}

bool OAIChartDataResponseResult::is_is_cached_Set() const{
    return m_is_cached_isSet;
}

bool OAIChartDataResponseResult::is_is_cached_Valid() const{
    return m_is_cached_isValid;
}

QString OAIChartDataResponseResult::getQuery() const {
    return m_query;
}
void OAIChartDataResponseResult::setQuery(const QString &query) {
    m_query = query;
    m_query_isSet = true;
}

bool OAIChartDataResponseResult::is_query_Set() const{
    return m_query_isSet;
}

bool OAIChartDataResponseResult::is_query_Valid() const{
    return m_query_isValid;
}

QList<OAIObject> OAIChartDataResponseResult::getRejectedFilters() const {
    return m_rejected_filters;
}
void OAIChartDataResponseResult::setRejectedFilters(const QList<OAIObject> &rejected_filters) {
    m_rejected_filters = rejected_filters;
    m_rejected_filters_isSet = true;
}

bool OAIChartDataResponseResult::is_rejected_filters_Set() const{
    return m_rejected_filters_isSet;
}

bool OAIChartDataResponseResult::is_rejected_filters_Valid() const{
    return m_rejected_filters_isValid;
}

qint32 OAIChartDataResponseResult::getRowcount() const {
    return m_rowcount;
}
void OAIChartDataResponseResult::setRowcount(const qint32 &rowcount) {
    m_rowcount = rowcount;
    m_rowcount_isSet = true;
}

bool OAIChartDataResponseResult::is_rowcount_Set() const{
    return m_rowcount_isSet;
}

bool OAIChartDataResponseResult::is_rowcount_Valid() const{
    return m_rowcount_isValid;
}

QString OAIChartDataResponseResult::getStacktrace() const {
    return m_stacktrace;
}
void OAIChartDataResponseResult::setStacktrace(const QString &stacktrace) {
    m_stacktrace = stacktrace;
    m_stacktrace_isSet = true;
}

bool OAIChartDataResponseResult::is_stacktrace_Set() const{
    return m_stacktrace_isSet;
}

bool OAIChartDataResponseResult::is_stacktrace_Valid() const{
    return m_stacktrace_isValid;
}

QString OAIChartDataResponseResult::getStatus() const {
    return m_status;
}
void OAIChartDataResponseResult::setStatus(const QString &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIChartDataResponseResult::is_status_Set() const{
    return m_status_isSet;
}

bool OAIChartDataResponseResult::is_status_Valid() const{
    return m_status_isValid;
}

bool OAIChartDataResponseResult::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_annotation_data.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_applied_filters.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_cache_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cache_timeout_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cached_dttm_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_error_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_cached_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_query_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rejected_filters.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_rowcount_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stacktrace_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIChartDataResponseResult::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_cache_key_isValid && m_cache_timeout_isValid && m_cached_dttm_isValid && m_is_cached_isValid && m_query_isValid && true;
}

} // namespace OpenAPI
