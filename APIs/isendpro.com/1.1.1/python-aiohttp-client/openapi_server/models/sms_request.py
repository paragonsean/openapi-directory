# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class SMSRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, date_envoi: str=None, emetteur: str=None, gmt_zone: str=None, keyid: str=None, nostop: str=None, num: List[str]=None, num_azur: str=None, repertoire_id: str=None, sms: List[str]=None, smslong: str=None, tracker: List[str]=None, ucs2: str=None):
        """SMSRequest - a model defined in OpenAPI

        :param date_envoi: The date_envoi of this SMSRequest.
        :param emetteur: The emetteur of this SMSRequest.
        :param gmt_zone: The gmt_zone of this SMSRequest.
        :param keyid: The keyid of this SMSRequest.
        :param nostop: The nostop of this SMSRequest.
        :param num: The num of this SMSRequest.
        :param num_azur: The num_azur of this SMSRequest.
        :param repertoire_id: The repertoire_id of this SMSRequest.
        :param sms: The sms of this SMSRequest.
        :param smslong: The smslong of this SMSRequest.
        :param tracker: The tracker of this SMSRequest.
        :param ucs2: The ucs2 of this SMSRequest.
        """
        self.openapi_types = {
            'date_envoi': str,
            'emetteur': str,
            'gmt_zone': str,
            'keyid': str,
            'nostop': str,
            'num': List[str],
            'num_azur': str,
            'repertoire_id': str,
            'sms': List[str],
            'smslong': str,
            'tracker': List[str],
            'ucs2': str
        }

        self.attribute_map = {
            'date_envoi': 'date_envoi',
            'emetteur': 'emetteur',
            'gmt_zone': 'gmt_zone',
            'keyid': 'keyid',
            'nostop': 'nostop',
            'num': 'num',
            'num_azur': 'numAzur',
            'repertoire_id': 'repertoireId',
            'sms': 'sms',
            'smslong': 'smslong',
            'tracker': 'tracker',
            'ucs2': 'ucs2'
        }

        self._date_envoi = date_envoi
        self._emetteur = emetteur
        self._gmt_zone = gmt_zone
        self._keyid = keyid
        self._nostop = nostop
        self._num = num
        self._num_azur = num_azur
        self._repertoire_id = repertoire_id
        self._sms = sms
        self._smslong = smslong
        self._tracker = tracker
        self._ucs2 = ucs2

    @classmethod
    def from_dict(cls, dikt: dict) -> 'SMSRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The SMSRequest of this SMSRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def date_envoi(self):
        """Gets the date_envoi of this SMSRequest.

        Paramètre optionnel, date d'envoi au format YYYY-MM-DD hh:mm

        :return: The date_envoi of this SMSRequest.
        :rtype: str
        """
        return self._date_envoi

    @date_envoi.setter
    def date_envoi(self, date_envoi):
        """Sets the date_envoi of this SMSRequest.

        Paramètre optionnel, date d'envoi au format YYYY-MM-DD hh:mm

        :param date_envoi: The date_envoi of this SMSRequest.
        :type date_envoi: str
        """

        self._date_envoi = date_envoi

    @property
    def emetteur(self):
        """Gets the emetteur of this SMSRequest.

        L'emetteur doit être une chaîne alphanumérique comprise entre 4 et 11 caractères. Les caractères acceptés sont les chiffres entre 0 et 9, les lettres entre A et Z et l’espace. Il ne peut pas comporter uniquement des chiffres. Pour la modification de l’émetteur et dans le cadre de campagnes commerciales, les opérateurs imposent contractuellement d’ajouter en fin de message le texte suivant : STOP XXXXX De ce fait, le message envoyé ne pourra excéder une longueur de 148 caractères au lieu des 160 caractères, le « STOP » étant rajouté automatiquement.

        :return: The emetteur of this SMSRequest.
        :rtype: str
        """
        return self._emetteur

    @emetteur.setter
    def emetteur(self, emetteur):
        """Sets the emetteur of this SMSRequest.

        L'emetteur doit être une chaîne alphanumérique comprise entre 4 et 11 caractères. Les caractères acceptés sont les chiffres entre 0 et 9, les lettres entre A et Z et l’espace. Il ne peut pas comporter uniquement des chiffres. Pour la modification de l’émetteur et dans le cadre de campagnes commerciales, les opérateurs imposent contractuellement d’ajouter en fin de message le texte suivant : STOP XXXXX De ce fait, le message envoyé ne pourra excéder une longueur de 148 caractères au lieu des 160 caractères, le « STOP » étant rajouté automatiquement.

        :param emetteur: The emetteur of this SMSRequest.
        :type emetteur: str
        """

        self._emetteur = emetteur

    @property
    def gmt_zone(self):
        """Gets the gmt_zone of this SMSRequest.

        Fuseau horaire de la date d'envoi

        :return: The gmt_zone of this SMSRequest.
        :rtype: str
        """
        return self._gmt_zone

    @gmt_zone.setter
    def gmt_zone(self, gmt_zone):
        """Sets the gmt_zone of this SMSRequest.

        Fuseau horaire de la date d'envoi

        :param gmt_zone: The gmt_zone of this SMSRequest.
        :type gmt_zone: str
        """
        allowed_values = ["Pacific/Midway", "America/Adak", "Etc/GMT+10", "Pacific/Marquesas", "Pacific/Gambier", "America/Anchorage", "America/Ensenada", "Etc/GMT+8", "America/Los_Angeles", "America/Denver", "America/Chihuahua", "America/Dawson_Creek", "America/Belize", "America/Cancun", "Chile/EasterIsland", "America/Chicago", "America/New_York", "America/Havana", "America/Bogota", "America/Caracas", "America/Santiago", "America/La_Paz", "Atlantic/Stanley", "America/Campo_Grande", "America/Goose_Bay", "America/Glace_Bay", "America/St_Johns", "America/Araguaina", "America/Montevideo", "America/Miquelon", "America/Godthab", "America/Argentina/Buenos_Aires", "America/Sao_Paulo", "America/Noronha", "Atlantic/Cape_Verde", "Atlantic/Azores", "Europe/Belfast", "Europe/Dublin", "Europe/Lisbon", "Europe/London", "Africa/Abidjan", "Europe/Amsterdam", "Europe/Belgrade", "Europe/Brussels", "Africa/Algiers", "Africa/Windhoek", "Asia/Beirut", "Africa/Cairo", "Asia/Gaza", "Africa/Blantyre", "Asia/Jerusalem", "Europe/Minsk", "Asia/Damascus", "Europe/Moscow", "Africa/Addis_Ababa", "Asia/Tehran", "Asia/Dubai", "Asia/Yerevan", "Asia/Kabul", "Asia/Yekaterinburg", "Asia/Tashkent", "Asia/Kolkata", "Asia/Katmandu", "Asia/Dhaka", "Asia/Novosibirsk", "Asia/Rangoon", "Asia/Bangkok", "Asia/Krasnoyarsk", "Asia/Hong_Kong", "Asia/Irkutsk", "Australia/Perth", "Australia/Eucla", "Asia/Tokyo", "Asia/Seoul", "Asia/Yakutsk", "Australia/Adelaide", "Australia/Darwin", "Australia/Brisbane", "Australia/Hobart", "Asia/Vladivostok", "Australia/Lord_Howe", "Etc/GMT-11", "Asia/Magadan", "Pacific/Norfolk", "Asia/Anadyr", "Pacific/Auckland", "Etc/GMT-12", "Pacific/Chatham", "Pacific/Tongatapu", "Pacific/Kiritimati"]  # noqa: E501
        if gmt_zone not in allowed_values:
            raise ValueError(
                "Invalid value for `gmt_zone` ({0}), must be one of {1}"
                .format(gmt_zone, allowed_values)
            )

        self._gmt_zone = gmt_zone

    @property
    def keyid(self):
        """Gets the keyid of this SMSRequest.

        Clé API

        :return: The keyid of this SMSRequest.
        :rtype: str
        """
        return self._keyid

    @keyid.setter
    def keyid(self, keyid):
        """Sets the keyid of this SMSRequest.

        Clé API

        :param keyid: The keyid of this SMSRequest.
        :type keyid: str
        """
        if keyid is None:
            raise ValueError("Invalid value for `keyid`, must not be `None`")

        self._keyid = keyid

    @property
    def nostop(self):
        """Gets the nostop of this SMSRequest.

        Si le message n’est pas à but commercial, vous pouvez faire une demande pour retirer l’obligation du STOP. Une fois votre demande validée par nos services, vous pourrez supprimer la mention STOP SMS en ajoutant nostop = \"1\"

        :return: The nostop of this SMSRequest.
        :rtype: str
        """
        return self._nostop

    @nostop.setter
    def nostop(self, nostop):
        """Sets the nostop of this SMSRequest.

        Si le message n’est pas à but commercial, vous pouvez faire une demande pour retirer l’obligation du STOP. Une fois votre demande validée par nos services, vous pourrez supprimer la mention STOP SMS en ajoutant nostop = \"1\"

        :param nostop: The nostop of this SMSRequest.
        :type nostop: str
        """

        self._nostop = nostop

    @property
    def num(self):
        """Gets the num of this SMSRequest.


        :return: The num of this SMSRequest.
        :rtype: List[str]
        """
        return self._num

    @num.setter
    def num(self, num):
        """Sets the num of this SMSRequest.


        :param num: The num of this SMSRequest.
        :type num: List[str]
        """
        if num is None:
            raise ValueError("Invalid value for `num`, must not be `None`")

        self._num = num

    @property
    def num_azur(self):
        """Gets the num_azur of this SMSRequest.


        :return: The num_azur of this SMSRequest.
        :rtype: str
        """
        return self._num_azur

    @num_azur.setter
    def num_azur(self, num_azur):
        """Sets the num_azur of this SMSRequest.


        :param num_azur: The num_azur of this SMSRequest.
        :type num_azur: str
        """
        allowed_values = ["1"]  # noqa: E501
        if num_azur not in allowed_values:
            raise ValueError(
                "Invalid value for `num_azur` ({0}), must be one of {1}"
                .format(num_azur, allowed_values)
            )

        self._num_azur = num_azur

    @property
    def repertoire_id(self):
        """Gets the repertoire_id of this SMSRequest.

        Id du repertoire

        :return: The repertoire_id of this SMSRequest.
        :rtype: str
        """
        return self._repertoire_id

    @repertoire_id.setter
    def repertoire_id(self, repertoire_id):
        """Sets the repertoire_id of this SMSRequest.

        Id du repertoire

        :param repertoire_id: The repertoire_id of this SMSRequest.
        :type repertoire_id: str
        """

        self._repertoire_id = repertoire_id

    @property
    def sms(self):
        """Gets the sms of this SMSRequest.


        :return: The sms of this SMSRequest.
        :rtype: List[str]
        """
        return self._sms

    @sms.setter
    def sms(self, sms):
        """Sets the sms of this SMSRequest.


        :param sms: The sms of this SMSRequest.
        :type sms: List[str]
        """
        if sms is None:
            raise ValueError("Invalid value for `sms`, must not be `None`")

        self._sms = sms

    @property
    def smslong(self):
        """Gets the smslong of this SMSRequest.

        Le SMS long permet de dépasser la limite de 160 caractères en envoyant un message constitué de plusieurs SMS. Il est possible d’envoyer jusqu’à 6 SMS concaténés pour une longueur totale maximale de 918 caractères par message. Pour des raisons technique, la limite par SMS concaténé étant de 153 caractères. En cas de modification de l’émetteur, il faut considérer l’ajout automatique de 12 caractères du « STOP SMS ». Pour envoyer un smslong, il faut ajouter le paramètre smslong aux appels. La valeur de SMS doit être le nombre maximum de sms concaténé autorisé.   Pour ne pas avoir ce message d’erreur et obtenir un calcul dynamique du nombre de SMS alors il faut renseigner smslong = \"999\" 

        :return: The smslong of this SMSRequest.
        :rtype: str
        """
        return self._smslong

    @smslong.setter
    def smslong(self, smslong):
        """Sets the smslong of this SMSRequest.

        Le SMS long permet de dépasser la limite de 160 caractères en envoyant un message constitué de plusieurs SMS. Il est possible d’envoyer jusqu’à 6 SMS concaténés pour une longueur totale maximale de 918 caractères par message. Pour des raisons technique, la limite par SMS concaténé étant de 153 caractères. En cas de modification de l’émetteur, il faut considérer l’ajout automatique de 12 caractères du « STOP SMS ». Pour envoyer un smslong, il faut ajouter le paramètre smslong aux appels. La valeur de SMS doit être le nombre maximum de sms concaténé autorisé.   Pour ne pas avoir ce message d’erreur et obtenir un calcul dynamique du nombre de SMS alors il faut renseigner smslong = \"999\" 

        :param smslong: The smslong of this SMSRequest.
        :type smslong: str
        """

        self._smslong = smslong

    @property
    def tracker(self):
        """Gets the tracker of this SMSRequest.


        :return: The tracker of this SMSRequest.
        :rtype: List[str]
        """
        return self._tracker

    @tracker.setter
    def tracker(self, tracker):
        """Sets the tracker of this SMSRequest.


        :param tracker: The tracker of this SMSRequest.
        :type tracker: List[str]
        """

        self._tracker = tracker

    @property
    def ucs2(self):
        """Gets the ucs2 of this SMSRequest.

        Il est également possible d’envoyer des SMS en alphabet non latin (russe, chinois, arabe, etc) sur les numéros hors France métropolitaine. Pour ce faire, la requête devrait être encodée au format UTF-8 et contenir l’argument ucs2 = \"1\" Du fait de contraintes techniques, 1 SMS unique ne pourra pas dépasser 70 caractères (au lieu des 160 usuels) et dans le cas de SMS long, chaque sms ne pourra dépasser 67 caractères.

        :return: The ucs2 of this SMSRequest.
        :rtype: str
        """
        return self._ucs2

    @ucs2.setter
    def ucs2(self, ucs2):
        """Sets the ucs2 of this SMSRequest.

        Il est également possible d’envoyer des SMS en alphabet non latin (russe, chinois, arabe, etc) sur les numéros hors France métropolitaine. Pour ce faire, la requête devrait être encodée au format UTF-8 et contenir l’argument ucs2 = \"1\" Du fait de contraintes techniques, 1 SMS unique ne pourra pas dépasser 70 caractères (au lieu des 160 usuels) et dans le cas de SMS long, chaque sms ne pourra dépasser 67 caractères.

        :param ucs2: The ucs2 of this SMSRequest.
        :type ucs2: str
        """

        self._ucs2 = ucs2
