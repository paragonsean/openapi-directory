/*
 * elmah.io API
 * This is the public REST API for elmah.io. All of the integrations communicates with elmah.io through this API.<br/><br/>For additional help getting started with the API, visit the following help articles:<br/><ul><li>[Using the REST API](https://docs.elmah.io/using-the-rest-api/)</li><li>[Where is my API key?](https://docs.elmah.io/where-is-my-api-key/)</li><li>[Where is my log ID?](https://docs.elmah.io/where-is-my-log-id/)</li><li>[How to configure API key permissions](https://docs.elmah.io/how-to-configure-api-key-permissions/)</li></ul>
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CreateHeartbeat
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:29:31.892058-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CreateHeartbeat {
  public static final String SERIALIZED_NAME_APPLICATION = "application";
  @SerializedName(SERIALIZED_NAME_APPLICATION)
  private String application;

  public static final String SERIALIZED_NAME_REASON = "reason";
  @SerializedName(SERIALIZED_NAME_REASON)
  private String reason;

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  private String result;

  public static final String SERIALIZED_NAME_TOOK = "took";
  @SerializedName(SERIALIZED_NAME_TOOK)
  private Long took;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public CreateHeartbeat() {
  }

  public CreateHeartbeat application(String application) {
    this.application = application;
    return this;
  }

  /**
   * Optional string to identify which application logged this message. You can use this if you have multiple applications and services logging to the same log.  If not set, the application name \&quot;Heartbeats\&quot; will be set on all log messages generated from this heartbeat.
   * @return application
   */
  @javax.annotation.Nullable
  public String getApplication() {
    return application;
  }

  public void setApplication(String application) {
    this.application = application;
  }


  public CreateHeartbeat reason(String reason) {
    this.reason = reason;
    return this;
  }

  /**
   * If result is \&quot;Degraded\&quot; or \&quot;Unhealthy\&quot; you can use this property to specify why.
   * @return reason
   */
  @javax.annotation.Nullable
  public String getReason() {
    return reason;
  }

  public void setReason(String reason) {
    this.reason = reason;
  }


  public CreateHeartbeat result(String result) {
    this.result = result;
    return this;
  }

  /**
   * The result of this heartbeat. Can be \&quot;Healthy, \&quot;Degraded\&quot;, or \&quot;Unhealthy\&quot;. Defaults to \&quot;Healthy\&quot;
   * @return result
   */
  @javax.annotation.Nullable
  public String getResult() {
    return result;
  }

  public void setResult(String result) {
    this.result = result;
  }


  public CreateHeartbeat took(Long took) {
    this.took = took;
    return this;
  }

  /**
   * Optional long for specifying how many milliseconds it took to execute the task resulting in this heartbeat. This can be used to get a better overview  of how long a scheduled task or service is running or to figure out if the grace period should be increased.
   * @return took
   */
  @javax.annotation.Nullable
  public Long getTook() {
    return took;
  }

  public void setTook(Long took) {
    this.took = took;
  }


  public CreateHeartbeat version(String version) {
    this.version = version;
    return this;
  }

  /**
   * Optional string to identify which version of your application logged this message. If not specified, any errors, warnings, or information messages will get  the newest version number created through deployment tracking as with normal log messages.
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateHeartbeat createHeartbeat = (CreateHeartbeat) o;
    return Objects.equals(this.application, createHeartbeat.application) &&
        Objects.equals(this.reason, createHeartbeat.reason) &&
        Objects.equals(this.result, createHeartbeat.result) &&
        Objects.equals(this.took, createHeartbeat.took) &&
        Objects.equals(this.version, createHeartbeat.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(application, reason, result, took, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateHeartbeat {\n");
    sb.append("    application: ").append(toIndentedString(application)).append("\n");
    sb.append("    reason: ").append(toIndentedString(reason)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    took: ").append(toIndentedString(took)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("application");
    openapiFields.add("reason");
    openapiFields.add("result");
    openapiFields.add("took");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateHeartbeat
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateHeartbeat.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateHeartbeat is not found in the empty JSON string", CreateHeartbeat.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateHeartbeat.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateHeartbeat` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("application") != null && !jsonObj.get("application").isJsonNull()) && !jsonObj.get("application").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `application` to be a primitive type in the JSON string but got `%s`", jsonObj.get("application").toString()));
      }
      if ((jsonObj.get("reason") != null && !jsonObj.get("reason").isJsonNull()) && !jsonObj.get("reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reason").toString()));
      }
      if ((jsonObj.get("result") != null && !jsonObj.get("result").isJsonNull()) && !jsonObj.get("result").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `result` to be a primitive type in the JSON string but got `%s`", jsonObj.get("result").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateHeartbeat.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateHeartbeat' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateHeartbeat> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateHeartbeat.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateHeartbeat>() {
           @Override
           public void write(JsonWriter out, CreateHeartbeat value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateHeartbeat read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateHeartbeat given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateHeartbeat
   * @throws IOException if the JSON string is invalid with respect to CreateHeartbeat
   */
  public static CreateHeartbeat fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateHeartbeat.class);
  }

  /**
   * Convert an instance of CreateHeartbeat to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

