/**
 * Adyen Stored Value API
 * A set of API endpoints to manage stored value products.
 *
 * The version of the OpenAPI document: 46
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Amount from './Amount';

/**
 * The StoredValueBalanceMergeRequest model module.
 * @module model/StoredValueBalanceMergeRequest
 * @version 46
 */
class StoredValueBalanceMergeRequest {
    /**
     * Constructs a new <code>StoredValueBalanceMergeRequest</code>.
     * @alias module:model/StoredValueBalanceMergeRequest
     * @param merchantAccount {String} The merchant account identifier, with which you want to process the transaction.
     * @param paymentMethod {Object.<String, String>} The collection that contains the type of the payment method and its specific information if available
     * @param reference {String} The reference to uniquely identify a payment. This reference is used in all communication with you about the payment status. We recommend using a unique value per payment; however, it is not a requirement. If you need to provide multiple references for a transaction, separate them with hyphens (\"-\"). Maximum length: 80 characters.
     * @param sourcePaymentMethod {Object.<String, String>} The collection that contains the source payment method and its specific information if available. Note that type should not be included since it is inferred from the (target) payment method
     */
    constructor(merchantAccount, paymentMethod, reference, sourcePaymentMethod) { 
        
        StoredValueBalanceMergeRequest.initialize(this, merchantAccount, paymentMethod, reference, sourcePaymentMethod);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, merchantAccount, paymentMethod, reference, sourcePaymentMethod) { 
        obj['merchantAccount'] = merchantAccount;
        obj['paymentMethod'] = paymentMethod;
        obj['reference'] = reference;
        obj['sourcePaymentMethod'] = sourcePaymentMethod;
    }

    /**
     * Constructs a <code>StoredValueBalanceMergeRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/StoredValueBalanceMergeRequest} obj Optional instance to populate.
     * @return {module:model/StoredValueBalanceMergeRequest} The populated <code>StoredValueBalanceMergeRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new StoredValueBalanceMergeRequest();

            if (data.hasOwnProperty('amount')) {
                obj['amount'] = Amount.constructFromObject(data['amount']);
            }
            if (data.hasOwnProperty('merchantAccount')) {
                obj['merchantAccount'] = ApiClient.convertToType(data['merchantAccount'], 'String');
            }
            if (data.hasOwnProperty('paymentMethod')) {
                obj['paymentMethod'] = ApiClient.convertToType(data['paymentMethod'], {'String': 'String'});
            }
            if (data.hasOwnProperty('recurringDetailReference')) {
                obj['recurringDetailReference'] = ApiClient.convertToType(data['recurringDetailReference'], 'String');
            }
            if (data.hasOwnProperty('reference')) {
                obj['reference'] = ApiClient.convertToType(data['reference'], 'String');
            }
            if (data.hasOwnProperty('shopperInteraction')) {
                obj['shopperInteraction'] = ApiClient.convertToType(data['shopperInteraction'], 'String');
            }
            if (data.hasOwnProperty('shopperReference')) {
                obj['shopperReference'] = ApiClient.convertToType(data['shopperReference'], 'String');
            }
            if (data.hasOwnProperty('sourcePaymentMethod')) {
                obj['sourcePaymentMethod'] = ApiClient.convertToType(data['sourcePaymentMethod'], {'String': 'String'});
            }
            if (data.hasOwnProperty('store')) {
                obj['store'] = ApiClient.convertToType(data['store'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>StoredValueBalanceMergeRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>StoredValueBalanceMergeRequest</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of StoredValueBalanceMergeRequest.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // validate the optional field `amount`
        if (data['amount']) { // data not null
          Amount.validateJSON(data['amount']);
        }
        // ensure the json data is a string
        if (data['merchantAccount'] && !(typeof data['merchantAccount'] === 'string' || data['merchantAccount'] instanceof String)) {
            throw new Error("Expected the field `merchantAccount` to be a primitive type in the JSON string but got " + data['merchantAccount']);
        }
        // ensure the json data is a string
        if (data['recurringDetailReference'] && !(typeof data['recurringDetailReference'] === 'string' || data['recurringDetailReference'] instanceof String)) {
            throw new Error("Expected the field `recurringDetailReference` to be a primitive type in the JSON string but got " + data['recurringDetailReference']);
        }
        // ensure the json data is a string
        if (data['reference'] && !(typeof data['reference'] === 'string' || data['reference'] instanceof String)) {
            throw new Error("Expected the field `reference` to be a primitive type in the JSON string but got " + data['reference']);
        }
        // ensure the json data is a string
        if (data['shopperInteraction'] && !(typeof data['shopperInteraction'] === 'string' || data['shopperInteraction'] instanceof String)) {
            throw new Error("Expected the field `shopperInteraction` to be a primitive type in the JSON string but got " + data['shopperInteraction']);
        }
        // ensure the json data is a string
        if (data['shopperReference'] && !(typeof data['shopperReference'] === 'string' || data['shopperReference'] instanceof String)) {
            throw new Error("Expected the field `shopperReference` to be a primitive type in the JSON string but got " + data['shopperReference']);
        }
        // ensure the json data is a string
        if (data['store'] && !(typeof data['store'] === 'string' || data['store'] instanceof String)) {
            throw new Error("Expected the field `store` to be a primitive type in the JSON string but got " + data['store']);
        }

        return true;
    }


}

StoredValueBalanceMergeRequest.RequiredProperties = ["merchantAccount", "paymentMethod", "reference", "sourcePaymentMethod"];

/**
 * The amount information for the transaction.
 * @member {module:model/Amount} amount
 */
StoredValueBalanceMergeRequest.prototype['amount'] = undefined;

/**
 * The merchant account identifier, with which you want to process the transaction.
 * @member {String} merchantAccount
 */
StoredValueBalanceMergeRequest.prototype['merchantAccount'] = undefined;

/**
 * The collection that contains the type of the payment method and its specific information if available
 * @member {Object.<String, String>} paymentMethod
 */
StoredValueBalanceMergeRequest.prototype['paymentMethod'] = undefined;

/**
 * @member {String} recurringDetailReference
 */
StoredValueBalanceMergeRequest.prototype['recurringDetailReference'] = undefined;

/**
 * The reference to uniquely identify a payment. This reference is used in all communication with you about the payment status. We recommend using a unique value per payment; however, it is not a requirement. If you need to provide multiple references for a transaction, separate them with hyphens (\"-\"). Maximum length: 80 characters.
 * @member {String} reference
 */
StoredValueBalanceMergeRequest.prototype['reference'] = undefined;

/**
 * Specifies the sales channel, through which the shopper gives their card details, and whether the shopper is a returning customer. For the web service API, Adyen assumes Ecommerce shopper interaction by default.  This field has the following possible values: * `Ecommerce` - Online transactions where the cardholder is present (online). For better authorisation rates, we recommend sending the card security code (CSC) along with the request. * `ContAuth` - Card on file and/or subscription transactions, where the cardholder is known to the merchant (returning customer). If the shopper is present (online), you can supply also the CSC to improve authorisation (one-click payment). * `Moto` - Mail-order and telephone-order transactions where the shopper is in contact with the merchant via email or telephone. * `POS` - Point-of-sale transactions where the shopper is physically present to make a payment using a secure payment terminal.
 * @member {module:model/StoredValueBalanceMergeRequest.ShopperInteractionEnum} shopperInteraction
 */
StoredValueBalanceMergeRequest.prototype['shopperInteraction'] = undefined;

/**
 * @member {String} shopperReference
 */
StoredValueBalanceMergeRequest.prototype['shopperReference'] = undefined;

/**
 * The collection that contains the source payment method and its specific information if available. Note that type should not be included since it is inferred from the (target) payment method
 * @member {Object.<String, String>} sourcePaymentMethod
 */
StoredValueBalanceMergeRequest.prototype['sourcePaymentMethod'] = undefined;

/**
 * The physical store, for which this payment is processed.
 * @member {String} store
 */
StoredValueBalanceMergeRequest.prototype['store'] = undefined;





/**
 * Allowed values for the <code>shopperInteraction</code> property.
 * @enum {String}
 * @readonly
 */
StoredValueBalanceMergeRequest['ShopperInteractionEnum'] = {

    /**
     * value: "Ecommerce"
     * @const
     */
    "Ecommerce": "Ecommerce",

    /**
     * value: "ContAuth"
     * @const
     */
    "ContAuth": "ContAuth",

    /**
     * value: "Moto"
     * @const
     */
    "Moto": "Moto",

    /**
     * value: "POS"
     * @const
     */
    "POS": "POS"
};



export default StoredValueBalanceMergeRequest;

