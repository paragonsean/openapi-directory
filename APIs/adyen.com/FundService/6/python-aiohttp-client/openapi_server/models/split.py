# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.split_amount import SplitAmount
from openapi_server import util


class Split(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, account: str=None, amount: SplitAmount=None, description: str=None, reference: str=None, type: str=None):
        """Split - a model defined in OpenAPI

        :param account: The account of this Split.
        :param amount: The amount of this Split.
        :param description: The description of this Split.
        :param reference: The reference of this Split.
        :param type: The type of this Split.
        """
        self.openapi_types = {
            'account': str,
            'amount': SplitAmount,
            'description': str,
            'reference': str,
            'type': str
        }

        self.attribute_map = {
            'account': 'account',
            'amount': 'amount',
            'description': 'description',
            'reference': 'reference',
            'type': 'type'
        }

        self._account = account
        self._amount = amount
        self._description = description
        self._reference = reference
        self._type = type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Split':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Split of this Split.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def account(self):
        """Gets the account of this Split.

        Unique identifier of the account where the split amount should be sent. This is required if `type` is **MarketPlace** or **BalanceAccount**.  

        :return: The account of this Split.
        :rtype: str
        """
        return self._account

    @account.setter
    def account(self, account):
        """Sets the account of this Split.

        Unique identifier of the account where the split amount should be sent. This is required if `type` is **MarketPlace** or **BalanceAccount**.  

        :param account: The account of this Split.
        :type account: str
        """

        self._account = account

    @property
    def amount(self):
        """Gets the amount of this Split.

        The amount of this split.

        :return: The amount of this Split.
        :rtype: SplitAmount
        """
        return self._amount

    @amount.setter
    def amount(self, amount):
        """Sets the amount of this Split.

        The amount of this split.

        :param amount: The amount of this Split.
        :type amount: SplitAmount
        """
        if amount is None:
            raise ValueError("Invalid value for `amount`, must not be `None`")

        self._amount = amount

    @property
    def description(self):
        """Gets the description of this Split.

        A description of this split.

        :return: The description of this Split.
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this Split.

        A description of this split.

        :param description: The description of this Split.
        :type description: str
        """

        self._description = description

    @property
    def reference(self):
        """Gets the reference of this Split.

        Your reference for the split, which you can use to link the split to other operations such as captures and refunds.  This is required if `type` is **MarketPlace** or **BalanceAccount**. For the other types, we also recommend sending a reference so you can reconcile the split and the associated payment in the transaction overview and in the reports. If the reference is not provided, the split is reported as part of the aggregated [TransferBalance record type](https://docs.adyen.com/reporting/marketpay-payments-accounting-report) in Adyen for Platforms.

        :return: The reference of this Split.
        :rtype: str
        """
        return self._reference

    @reference.setter
    def reference(self, reference):
        """Sets the reference of this Split.

        Your reference for the split, which you can use to link the split to other operations such as captures and refunds.  This is required if `type` is **MarketPlace** or **BalanceAccount**. For the other types, we also recommend sending a reference so you can reconcile the split and the associated payment in the transaction overview and in the reports. If the reference is not provided, the split is reported as part of the aggregated [TransferBalance record type](https://docs.adyen.com/reporting/marketpay-payments-accounting-report) in Adyen for Platforms.

        :param reference: The reference of this Split.
        :type reference: str
        """

        self._reference = reference

    @property
    def type(self):
        """Gets the type of this Split.

        The type of split. Possible values: **Default**, **PaymentFee**, **VAT**, **Commission**, **MarketPlace**, **BalanceAccount**, **Remainder**, **Surcharge**, **Tip**.

        :return: The type of this Split.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this Split.

        The type of split. Possible values: **Default**, **PaymentFee**, **VAT**, **Commission**, **MarketPlace**, **BalanceAccount**, **Remainder**, **Surcharge**, **Tip**.

        :param type: The type of this Split.
        :type type: str
        """
        allowed_values = ["BalanceAccount", "Commission", "Default", "MarketPlace", "PaymentFee", "PaymentFeeAcquiring", "PaymentFeeAdyen", "PaymentFeeAdyenCommission", "PaymentFeeAdyenMarkup", "PaymentFeeInterchange", "PaymentFeeSchemeFee", "Remainder", "Surcharge", "Tip", "VAT", "Verification"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"
                .format(type, allowed_values)
            )

        self._type = type
