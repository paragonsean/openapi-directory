/**
 * Payment webhooks (deprecated)
 * The payment webhooks are deprecated. Use the [accounting webhooks](https://docs.adyen.com/api-explorer/transfer-webhooks/latest/overview) instead.  Adyen sends webhooks to inform your system about the creation of payment resources and money movements in your platform.  You can use these webhooks to build your implementation. For example, you can use this information to update balances in your own dashboards or to keep track of incoming funds.
 *
 * The version of the OpenAPI document: 1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITransactionEventViolation.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITransactionEventViolation::OAITransactionEventViolation(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITransactionEventViolation::OAITransactionEventViolation() {
    this->initializeModel();
}

OAITransactionEventViolation::~OAITransactionEventViolation() {}

void OAITransactionEventViolation::initializeModel() {

    m_reason_isSet = false;
    m_reason_isValid = false;

    m_transaction_rule_isSet = false;
    m_transaction_rule_isValid = false;

    m_transaction_rule_source_isSet = false;
    m_transaction_rule_source_isValid = false;
}

void OAITransactionEventViolation::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITransactionEventViolation::fromJsonObject(QJsonObject json) {

    m_reason_isValid = ::OpenAPI::fromJsonValue(m_reason, json[QString("reason")]);
    m_reason_isSet = !json[QString("reason")].isNull() && m_reason_isValid;

    m_transaction_rule_isValid = ::OpenAPI::fromJsonValue(m_transaction_rule, json[QString("transactionRule")]);
    m_transaction_rule_isSet = !json[QString("transactionRule")].isNull() && m_transaction_rule_isValid;

    m_transaction_rule_source_isValid = ::OpenAPI::fromJsonValue(m_transaction_rule_source, json[QString("transactionRuleSource")]);
    m_transaction_rule_source_isSet = !json[QString("transactionRuleSource")].isNull() && m_transaction_rule_source_isValid;
}

QString OAITransactionEventViolation::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITransactionEventViolation::asJsonObject() const {
    QJsonObject obj;
    if (m_reason_isSet) {
        obj.insert(QString("reason"), ::OpenAPI::toJsonValue(m_reason));
    }
    if (m_transaction_rule.isSet()) {
        obj.insert(QString("transactionRule"), ::OpenAPI::toJsonValue(m_transaction_rule));
    }
    if (m_transaction_rule_source.isSet()) {
        obj.insert(QString("transactionRuleSource"), ::OpenAPI::toJsonValue(m_transaction_rule_source));
    }
    return obj;
}

QString OAITransactionEventViolation::getReason() const {
    return m_reason;
}
void OAITransactionEventViolation::setReason(const QString &reason) {
    m_reason = reason;
    m_reason_isSet = true;
}

bool OAITransactionEventViolation::is_reason_Set() const{
    return m_reason_isSet;
}

bool OAITransactionEventViolation::is_reason_Valid() const{
    return m_reason_isValid;
}

OAITransactionRuleReference OAITransactionEventViolation::getTransactionRule() const {
    return m_transaction_rule;
}
void OAITransactionEventViolation::setTransactionRule(const OAITransactionRuleReference &transaction_rule) {
    m_transaction_rule = transaction_rule;
    m_transaction_rule_isSet = true;
}

bool OAITransactionEventViolation::is_transaction_rule_Set() const{
    return m_transaction_rule_isSet;
}

bool OAITransactionEventViolation::is_transaction_rule_Valid() const{
    return m_transaction_rule_isValid;
}

OAITransactionRuleSource OAITransactionEventViolation::getTransactionRuleSource() const {
    return m_transaction_rule_source;
}
void OAITransactionEventViolation::setTransactionRuleSource(const OAITransactionRuleSource &transaction_rule_source) {
    m_transaction_rule_source = transaction_rule_source;
    m_transaction_rule_source_isSet = true;
}

bool OAITransactionEventViolation::is_transaction_rule_source_Set() const{
    return m_transaction_rule_source_isSet;
}

bool OAITransactionEventViolation::is_transaction_rule_source_Valid() const{
    return m_transaction_rule_source_isValid;
}

bool OAITransactionEventViolation::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_transaction_rule.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_transaction_rule_source.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITransactionEventViolation::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
