/*
 * Adyen Terminal API
 * The Adyen Terminal API lets you make payments, issue refunds, collect shopper information, and perform other shopper-terminal interactions using a payment terminal supplied by Adyen.
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Alignment;
import org.openapitools.client.model.CharacterHeight;
import org.openapitools.client.model.CharacterStyle;
import org.openapitools.client.model.CharacterWidth;
import org.openapitools.client.model.Color;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * It conveys Information related to the content of the text message and its format. All the data elements related to the format of the text to display or print are parameters valid for the whole Text content. Content of text message to display or print.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:13:30.341990-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class OutputText {
  public static final String SERIALIZED_NAME_ALIGNMENT = "Alignment";
  @SerializedName(SERIALIZED_NAME_ALIGNMENT)
  private Alignment alignment;

  public static final String SERIALIZED_NAME_CHARACTER_HEIGHT = "CharacterHeight";
  @SerializedName(SERIALIZED_NAME_CHARACTER_HEIGHT)
  private CharacterHeight characterHeight;

  public static final String SERIALIZED_NAME_CHARACTER_SET = "CharacterSet";
  @SerializedName(SERIALIZED_NAME_CHARACTER_SET)
  private Integer characterSet;

  public static final String SERIALIZED_NAME_CHARACTER_STYLE = "CharacterStyle";
  @SerializedName(SERIALIZED_NAME_CHARACTER_STYLE)
  private CharacterStyle characterStyle;

  public static final String SERIALIZED_NAME_CHARACTER_WIDTH = "CharacterWidth";
  @SerializedName(SERIALIZED_NAME_CHARACTER_WIDTH)
  private CharacterWidth characterWidth;

  public static final String SERIALIZED_NAME_COLOR = "Color";
  @SerializedName(SERIALIZED_NAME_COLOR)
  private Color color;

  public static final String SERIALIZED_NAME_END_OF_LINE_FLAG = "EndOfLineFlag";
  @SerializedName(SERIALIZED_NAME_END_OF_LINE_FLAG)
  private Boolean endOfLineFlag = true;

  public static final String SERIALIZED_NAME_FONT = "Font";
  @SerializedName(SERIALIZED_NAME_FONT)
  private String font;

  public static final String SERIALIZED_NAME_START_COLUMN = "StartColumn";
  @SerializedName(SERIALIZED_NAME_START_COLUMN)
  private Integer startColumn;

  public static final String SERIALIZED_NAME_START_ROW = "StartRow";
  @SerializedName(SERIALIZED_NAME_START_ROW)
  private Integer startRow;

  public static final String SERIALIZED_NAME_TEXT = "Text";
  @SerializedName(SERIALIZED_NAME_TEXT)
  private String text;

  public OutputText() {
  }

  public OutputText alignment(Alignment alignment) {
    this.alignment = alignment;
    return this;
  }

  /**
   * Get alignment
   * @return alignment
   */
  @javax.annotation.Nullable
  public Alignment getAlignment() {
    return alignment;
  }

  public void setAlignment(Alignment alignment) {
    this.alignment = alignment;
  }


  public OutputText characterHeight(CharacterHeight characterHeight) {
    this.characterHeight = characterHeight;
    return this;
  }

  /**
   * Get characterHeight
   * @return characterHeight
   */
  @javax.annotation.Nullable
  public CharacterHeight getCharacterHeight() {
    return characterHeight;
  }

  public void setCharacterHeight(CharacterHeight characterHeight) {
    this.characterHeight = characterHeight;
  }


  public OutputText characterSet(Integer characterSet) {
    this.characterSet = characterSet;
    return this;
  }

  /**
   * Get characterSet
   * @return characterSet
   */
  @javax.annotation.Nullable
  public Integer getCharacterSet() {
    return characterSet;
  }

  public void setCharacterSet(Integer characterSet) {
    this.characterSet = characterSet;
  }


  public OutputText characterStyle(CharacterStyle characterStyle) {
    this.characterStyle = characterStyle;
    return this;
  }

  /**
   * Get characterStyle
   * @return characterStyle
   */
  @javax.annotation.Nullable
  public CharacterStyle getCharacterStyle() {
    return characterStyle;
  }

  public void setCharacterStyle(CharacterStyle characterStyle) {
    this.characterStyle = characterStyle;
  }


  public OutputText characterWidth(CharacterWidth characterWidth) {
    this.characterWidth = characterWidth;
    return this;
  }

  /**
   * Get characterWidth
   * @return characterWidth
   */
  @javax.annotation.Nullable
  public CharacterWidth getCharacterWidth() {
    return characterWidth;
  }

  public void setCharacterWidth(CharacterWidth characterWidth) {
    this.characterWidth = characterWidth;
  }


  public OutputText color(Color color) {
    this.color = color;
    return this;
  }

  /**
   * Get color
   * @return color
   */
  @javax.annotation.Nullable
  public Color getColor() {
    return color;
  }

  public void setColor(Color color) {
    this.color = color;
  }


  public OutputText endOfLineFlag(Boolean endOfLineFlag) {
    this.endOfLineFlag = endOfLineFlag;
    return this;
  }

  /**
   * Get endOfLineFlag
   * @return endOfLineFlag
   */
  @javax.annotation.Nullable
  public Boolean getEndOfLineFlag() {
    return endOfLineFlag;
  }

  public void setEndOfLineFlag(Boolean endOfLineFlag) {
    this.endOfLineFlag = endOfLineFlag;
  }


  public OutputText font(String font) {
    this.font = font;
    return this;
  }

  /**
   * Get font
   * @return font
   */
  @javax.annotation.Nullable
  public String getFont() {
    return font;
  }

  public void setFont(String font) {
    this.font = font;
  }


  public OutputText startColumn(Integer startColumn) {
    this.startColumn = startColumn;
    return this;
  }

  /**
   * Get startColumn
   * minimum: 1
   * maximum: 500
   * @return startColumn
   */
  @javax.annotation.Nullable
  public Integer getStartColumn() {
    return startColumn;
  }

  public void setStartColumn(Integer startColumn) {
    this.startColumn = startColumn;
  }


  public OutputText startRow(Integer startRow) {
    this.startRow = startRow;
    return this;
  }

  /**
   * Get startRow
   * minimum: 1
   * maximum: 500
   * @return startRow
   */
  @javax.annotation.Nullable
  public Integer getStartRow() {
    return startRow;
  }

  public void setStartRow(Integer startRow) {
    this.startRow = startRow;
  }


  public OutputText text(String text) {
    this.text = text;
    return this;
  }

  /**
   * Get text
   * @return text
   */
  @javax.annotation.Nonnull
  public String getText() {
    return text;
  }

  public void setText(String text) {
    this.text = text;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OutputText outputText = (OutputText) o;
    return Objects.equals(this.alignment, outputText.alignment) &&
        Objects.equals(this.characterHeight, outputText.characterHeight) &&
        Objects.equals(this.characterSet, outputText.characterSet) &&
        Objects.equals(this.characterStyle, outputText.characterStyle) &&
        Objects.equals(this.characterWidth, outputText.characterWidth) &&
        Objects.equals(this.color, outputText.color) &&
        Objects.equals(this.endOfLineFlag, outputText.endOfLineFlag) &&
        Objects.equals(this.font, outputText.font) &&
        Objects.equals(this.startColumn, outputText.startColumn) &&
        Objects.equals(this.startRow, outputText.startRow) &&
        Objects.equals(this.text, outputText.text);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alignment, characterHeight, characterSet, characterStyle, characterWidth, color, endOfLineFlag, font, startColumn, startRow, text);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OutputText {\n");
    sb.append("    alignment: ").append(toIndentedString(alignment)).append("\n");
    sb.append("    characterHeight: ").append(toIndentedString(characterHeight)).append("\n");
    sb.append("    characterSet: ").append(toIndentedString(characterSet)).append("\n");
    sb.append("    characterStyle: ").append(toIndentedString(characterStyle)).append("\n");
    sb.append("    characterWidth: ").append(toIndentedString(characterWidth)).append("\n");
    sb.append("    color: ").append(toIndentedString(color)).append("\n");
    sb.append("    endOfLineFlag: ").append(toIndentedString(endOfLineFlag)).append("\n");
    sb.append("    font: ").append(toIndentedString(font)).append("\n");
    sb.append("    startColumn: ").append(toIndentedString(startColumn)).append("\n");
    sb.append("    startRow: ").append(toIndentedString(startRow)).append("\n");
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Alignment");
    openapiFields.add("CharacterHeight");
    openapiFields.add("CharacterSet");
    openapiFields.add("CharacterStyle");
    openapiFields.add("CharacterWidth");
    openapiFields.add("Color");
    openapiFields.add("EndOfLineFlag");
    openapiFields.add("Font");
    openapiFields.add("StartColumn");
    openapiFields.add("StartRow");
    openapiFields.add("Text");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("Text");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to OutputText
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!OutputText.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in OutputText is not found in the empty JSON string", OutputText.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!OutputText.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `OutputText` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : OutputText.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `Alignment`
      if (jsonObj.get("Alignment") != null && !jsonObj.get("Alignment").isJsonNull()) {
        Alignment.validateJsonElement(jsonObj.get("Alignment"));
      }
      // validate the optional field `CharacterHeight`
      if (jsonObj.get("CharacterHeight") != null && !jsonObj.get("CharacterHeight").isJsonNull()) {
        CharacterHeight.validateJsonElement(jsonObj.get("CharacterHeight"));
      }
      // validate the optional field `CharacterStyle`
      if (jsonObj.get("CharacterStyle") != null && !jsonObj.get("CharacterStyle").isJsonNull()) {
        CharacterStyle.validateJsonElement(jsonObj.get("CharacterStyle"));
      }
      // validate the optional field `CharacterWidth`
      if (jsonObj.get("CharacterWidth") != null && !jsonObj.get("CharacterWidth").isJsonNull()) {
        CharacterWidth.validateJsonElement(jsonObj.get("CharacterWidth"));
      }
      // validate the optional field `Color`
      if (jsonObj.get("Color") != null && !jsonObj.get("Color").isJsonNull()) {
        Color.validateJsonElement(jsonObj.get("Color"));
      }
      if ((jsonObj.get("Font") != null && !jsonObj.get("Font").isJsonNull()) && !jsonObj.get("Font").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Font` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Font").toString()));
      }
      if (!jsonObj.get("Text").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Text` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Text").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!OutputText.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'OutputText' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<OutputText> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(OutputText.class));

       return (TypeAdapter<T>) new TypeAdapter<OutputText>() {
           @Override
           public void write(JsonWriter out, OutputText value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public OutputText read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of OutputText given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of OutputText
   * @throws IOException if the JSON string is invalid with respect to OutputText
   */
  public static OutputText fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OutputText.class);
  }

  /**
   * Convert an instance of OutputText to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

