/*
 * Legal Entity Management API
 * The Legal Entity Management API enables you to manage legal entities that contain information required for verification.  ## Authentication Your Adyen contact will provide your API credential and an API key. To connect to the API, add an `X-API-Key` header with the API key as the value. For example:  ``` curl -H \"X-API-Key: YOUR_API_KEY\" \\ -H \"Content-Type: application/json\" \\ ... ``` Alternatively, you can use the username and password of your API credential to connect to the API using basic authentication. For example:  ``` curl -U \"ws_123456@Scope.Company_YOUR_COMPANY_ACCOUNT\":\"YourWsPassword\" \\ -H \"Content-Type: application/json\" \\ ... ``` ## Versioning The Legal Entity Management API supports [versioning](https://docs.adyen.com/development-resources/versioning) using a version suffix in the endpoint URL. This suffix has the following format: \"vXX\", where XX is the version number.  For example: ``` https://kyc-test.adyen.com/lem/v3/legalEntities ``` >If you are using hosted onboarding and just beginning your integration, use v3 for your API requests. Otherwise, use v2.  ## Going live When going live, your Adyen contact will provide your API credential for the live environment. You can then use the API key or the username and password to send requests to `https://kyc-live.adyen.com/lem/v3`.  
 *
 * The version of the OpenAPI document: 3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AULocalAccountIdentification;
import org.openapitools.client.model.AdditionalBankIdentification;
import org.openapitools.client.model.CALocalAccountIdentification;
import org.openapitools.client.model.CZLocalAccountIdentification;
import org.openapitools.client.model.DKLocalAccountIdentification;
import org.openapitools.client.model.HKLocalAccountIdentification;
import org.openapitools.client.model.HULocalAccountIdentification;
import org.openapitools.client.model.IbanAccountIdentification;
import org.openapitools.client.model.NOLocalAccountIdentification;
import org.openapitools.client.model.NZLocalAccountIdentification;
import org.openapitools.client.model.NumberAndBicAccountIdentification;
import org.openapitools.client.model.PLLocalAccountIdentification;
import org.openapitools.client.model.SELocalAccountIdentification;
import org.openapitools.client.model.SGLocalAccountIdentification;
import org.openapitools.client.model.UKLocalAccountIdentification;
import org.openapitools.client.model.USLocalAccountIdentification;



import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;

import org.openapitools.client.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:15:01.634402-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BankAccountInfoAccountIdentification extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(BankAccountInfoAccountIdentification.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!BankAccountInfoAccountIdentification.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'BankAccountInfoAccountIdentification' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<AULocalAccountIdentification> adapterAULocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(AULocalAccountIdentification.class));
            final TypeAdapter<CALocalAccountIdentification> adapterCALocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(CALocalAccountIdentification.class));
            final TypeAdapter<CZLocalAccountIdentification> adapterCZLocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(CZLocalAccountIdentification.class));
            final TypeAdapter<DKLocalAccountIdentification> adapterDKLocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(DKLocalAccountIdentification.class));
            final TypeAdapter<HKLocalAccountIdentification> adapterHKLocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(HKLocalAccountIdentification.class));
            final TypeAdapter<HULocalAccountIdentification> adapterHULocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(HULocalAccountIdentification.class));
            final TypeAdapter<IbanAccountIdentification> adapterIbanAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(IbanAccountIdentification.class));
            final TypeAdapter<NOLocalAccountIdentification> adapterNOLocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(NOLocalAccountIdentification.class));
            final TypeAdapter<NZLocalAccountIdentification> adapterNZLocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(NZLocalAccountIdentification.class));
            final TypeAdapter<NumberAndBicAccountIdentification> adapterNumberAndBicAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(NumberAndBicAccountIdentification.class));
            final TypeAdapter<PLLocalAccountIdentification> adapterPLLocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(PLLocalAccountIdentification.class));
            final TypeAdapter<SELocalAccountIdentification> adapterSELocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(SELocalAccountIdentification.class));
            final TypeAdapter<SGLocalAccountIdentification> adapterSGLocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(SGLocalAccountIdentification.class));
            final TypeAdapter<UKLocalAccountIdentification> adapterUKLocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(UKLocalAccountIdentification.class));
            final TypeAdapter<USLocalAccountIdentification> adapterUSLocalAccountIdentification = gson.getDelegateAdapter(this, TypeToken.get(USLocalAccountIdentification.class));

            return (TypeAdapter<T>) new TypeAdapter<BankAccountInfoAccountIdentification>() {
                @Override
                public void write(JsonWriter out, BankAccountInfoAccountIdentification value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `AULocalAccountIdentification`
                    if (value.getActualInstance() instanceof AULocalAccountIdentification) {
                        JsonElement element = adapterAULocalAccountIdentification.toJsonTree((AULocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CALocalAccountIdentification`
                    if (value.getActualInstance() instanceof CALocalAccountIdentification) {
                        JsonElement element = adapterCALocalAccountIdentification.toJsonTree((CALocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CZLocalAccountIdentification`
                    if (value.getActualInstance() instanceof CZLocalAccountIdentification) {
                        JsonElement element = adapterCZLocalAccountIdentification.toJsonTree((CZLocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `DKLocalAccountIdentification`
                    if (value.getActualInstance() instanceof DKLocalAccountIdentification) {
                        JsonElement element = adapterDKLocalAccountIdentification.toJsonTree((DKLocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `HKLocalAccountIdentification`
                    if (value.getActualInstance() instanceof HKLocalAccountIdentification) {
                        JsonElement element = adapterHKLocalAccountIdentification.toJsonTree((HKLocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `HULocalAccountIdentification`
                    if (value.getActualInstance() instanceof HULocalAccountIdentification) {
                        JsonElement element = adapterHULocalAccountIdentification.toJsonTree((HULocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `IbanAccountIdentification`
                    if (value.getActualInstance() instanceof IbanAccountIdentification) {
                        JsonElement element = adapterIbanAccountIdentification.toJsonTree((IbanAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `NOLocalAccountIdentification`
                    if (value.getActualInstance() instanceof NOLocalAccountIdentification) {
                        JsonElement element = adapterNOLocalAccountIdentification.toJsonTree((NOLocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `NZLocalAccountIdentification`
                    if (value.getActualInstance() instanceof NZLocalAccountIdentification) {
                        JsonElement element = adapterNZLocalAccountIdentification.toJsonTree((NZLocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `NumberAndBicAccountIdentification`
                    if (value.getActualInstance() instanceof NumberAndBicAccountIdentification) {
                        JsonElement element = adapterNumberAndBicAccountIdentification.toJsonTree((NumberAndBicAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `PLLocalAccountIdentification`
                    if (value.getActualInstance() instanceof PLLocalAccountIdentification) {
                        JsonElement element = adapterPLLocalAccountIdentification.toJsonTree((PLLocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `SELocalAccountIdentification`
                    if (value.getActualInstance() instanceof SELocalAccountIdentification) {
                        JsonElement element = adapterSELocalAccountIdentification.toJsonTree((SELocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `SGLocalAccountIdentification`
                    if (value.getActualInstance() instanceof SGLocalAccountIdentification) {
                        JsonElement element = adapterSGLocalAccountIdentification.toJsonTree((SGLocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `UKLocalAccountIdentification`
                    if (value.getActualInstance() instanceof UKLocalAccountIdentification) {
                        JsonElement element = adapterUKLocalAccountIdentification.toJsonTree((UKLocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `USLocalAccountIdentification`
                    if (value.getActualInstance() instanceof USLocalAccountIdentification) {
                        JsonElement element = adapterUSLocalAccountIdentification.toJsonTree((USLocalAccountIdentification)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: AULocalAccountIdentification, CALocalAccountIdentification, CZLocalAccountIdentification, DKLocalAccountIdentification, HKLocalAccountIdentification, HULocalAccountIdentification, IbanAccountIdentification, NOLocalAccountIdentification, NZLocalAccountIdentification, NumberAndBicAccountIdentification, PLLocalAccountIdentification, SELocalAccountIdentification, SGLocalAccountIdentification, UKLocalAccountIdentification, USLocalAccountIdentification");
                }

                @Override
                public BankAccountInfoAccountIdentification read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonElement jsonElement = elementAdapter.read(in);

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize AULocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        AULocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterAULocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'AULocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for AULocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'AULocalAccountIdentification'", e);
                    }
                    // deserialize CALocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CALocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterCALocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'CALocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CALocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CALocalAccountIdentification'", e);
                    }
                    // deserialize CZLocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CZLocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterCZLocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'CZLocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CZLocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CZLocalAccountIdentification'", e);
                    }
                    // deserialize DKLocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DKLocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterDKLocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'DKLocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for DKLocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'DKLocalAccountIdentification'", e);
                    }
                    // deserialize HKLocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        HKLocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterHKLocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'HKLocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for HKLocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'HKLocalAccountIdentification'", e);
                    }
                    // deserialize HULocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        HULocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterHULocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'HULocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for HULocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'HULocalAccountIdentification'", e);
                    }
                    // deserialize IbanAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        IbanAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterIbanAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'IbanAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for IbanAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'IbanAccountIdentification'", e);
                    }
                    // deserialize NOLocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        NOLocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterNOLocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'NOLocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for NOLocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'NOLocalAccountIdentification'", e);
                    }
                    // deserialize NZLocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        NZLocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterNZLocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'NZLocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for NZLocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'NZLocalAccountIdentification'", e);
                    }
                    // deserialize NumberAndBicAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        NumberAndBicAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterNumberAndBicAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'NumberAndBicAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for NumberAndBicAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'NumberAndBicAccountIdentification'", e);
                    }
                    // deserialize PLLocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        PLLocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterPLLocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'PLLocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for PLLocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'PLLocalAccountIdentification'", e);
                    }
                    // deserialize SELocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        SELocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterSELocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'SELocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for SELocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'SELocalAccountIdentification'", e);
                    }
                    // deserialize SGLocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        SGLocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterSGLocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'SGLocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for SGLocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'SGLocalAccountIdentification'", e);
                    }
                    // deserialize UKLocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        UKLocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterUKLocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'UKLocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for UKLocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'UKLocalAccountIdentification'", e);
                    }
                    // deserialize USLocalAccountIdentification
                    try {
                        // validate the JSON object to see if any exception is thrown
                        USLocalAccountIdentification.validateJsonElement(jsonElement);
                        actualAdapter = adapterUSLocalAccountIdentification;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'USLocalAccountIdentification'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for USLocalAccountIdentification failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'USLocalAccountIdentification'", e);
                    }

                    if (match == 1) {
                        BankAccountInfoAccountIdentification ret = new BankAccountInfoAccountIdentification();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for BankAccountInfoAccountIdentification: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonElement.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();

    public BankAccountInfoAccountIdentification() {
        super("oneOf", Boolean.FALSE);
    }

    public BankAccountInfoAccountIdentification(Object o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("AULocalAccountIdentification", AULocalAccountIdentification.class);
        schemas.put("CALocalAccountIdentification", CALocalAccountIdentification.class);
        schemas.put("CZLocalAccountIdentification", CZLocalAccountIdentification.class);
        schemas.put("DKLocalAccountIdentification", DKLocalAccountIdentification.class);
        schemas.put("HKLocalAccountIdentification", HKLocalAccountIdentification.class);
        schemas.put("HULocalAccountIdentification", HULocalAccountIdentification.class);
        schemas.put("IbanAccountIdentification", IbanAccountIdentification.class);
        schemas.put("NOLocalAccountIdentification", NOLocalAccountIdentification.class);
        schemas.put("NZLocalAccountIdentification", NZLocalAccountIdentification.class);
        schemas.put("NumberAndBicAccountIdentification", NumberAndBicAccountIdentification.class);
        schemas.put("PLLocalAccountIdentification", PLLocalAccountIdentification.class);
        schemas.put("SELocalAccountIdentification", SELocalAccountIdentification.class);
        schemas.put("SGLocalAccountIdentification", SGLocalAccountIdentification.class);
        schemas.put("UKLocalAccountIdentification", UKLocalAccountIdentification.class);
        schemas.put("USLocalAccountIdentification", USLocalAccountIdentification.class);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return BankAccountInfoAccountIdentification.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * AULocalAccountIdentification, CALocalAccountIdentification, CZLocalAccountIdentification, DKLocalAccountIdentification, HKLocalAccountIdentification, HULocalAccountIdentification, IbanAccountIdentification, NOLocalAccountIdentification, NZLocalAccountIdentification, NumberAndBicAccountIdentification, PLLocalAccountIdentification, SELocalAccountIdentification, SGLocalAccountIdentification, UKLocalAccountIdentification, USLocalAccountIdentification
     *
     * It could be an instance of the 'oneOf' schemas.
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof AULocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CALocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CZLocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DKLocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof HKLocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof HULocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof IbanAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof NOLocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof NZLocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof NumberAndBicAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof PLLocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof SELocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof SGLocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof UKLocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof USLocalAccountIdentification) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AULocalAccountIdentification, CALocalAccountIdentification, CZLocalAccountIdentification, DKLocalAccountIdentification, HKLocalAccountIdentification, HULocalAccountIdentification, IbanAccountIdentification, NOLocalAccountIdentification, NZLocalAccountIdentification, NumberAndBicAccountIdentification, PLLocalAccountIdentification, SELocalAccountIdentification, SGLocalAccountIdentification, UKLocalAccountIdentification, USLocalAccountIdentification");
    }

    /**
     * Get the actual instance, which can be the following:
     * AULocalAccountIdentification, CALocalAccountIdentification, CZLocalAccountIdentification, DKLocalAccountIdentification, HKLocalAccountIdentification, HULocalAccountIdentification, IbanAccountIdentification, NOLocalAccountIdentification, NZLocalAccountIdentification, NumberAndBicAccountIdentification, PLLocalAccountIdentification, SELocalAccountIdentification, SGLocalAccountIdentification, UKLocalAccountIdentification, USLocalAccountIdentification
     *
     * @return The actual instance (AULocalAccountIdentification, CALocalAccountIdentification, CZLocalAccountIdentification, DKLocalAccountIdentification, HKLocalAccountIdentification, HULocalAccountIdentification, IbanAccountIdentification, NOLocalAccountIdentification, NZLocalAccountIdentification, NumberAndBicAccountIdentification, PLLocalAccountIdentification, SELocalAccountIdentification, SGLocalAccountIdentification, UKLocalAccountIdentification, USLocalAccountIdentification)
     */
    @SuppressWarnings("unchecked")
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `AULocalAccountIdentification`. If the actual instance is not `AULocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AULocalAccountIdentification`
     * @throws ClassCastException if the instance is not `AULocalAccountIdentification`
     */
    public AULocalAccountIdentification getAULocalAccountIdentification() throws ClassCastException {
        return (AULocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CALocalAccountIdentification`. If the actual instance is not `CALocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CALocalAccountIdentification`
     * @throws ClassCastException if the instance is not `CALocalAccountIdentification`
     */
    public CALocalAccountIdentification getCALocalAccountIdentification() throws ClassCastException {
        return (CALocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `CZLocalAccountIdentification`. If the actual instance is not `CZLocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CZLocalAccountIdentification`
     * @throws ClassCastException if the instance is not `CZLocalAccountIdentification`
     */
    public CZLocalAccountIdentification getCZLocalAccountIdentification() throws ClassCastException {
        return (CZLocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `DKLocalAccountIdentification`. If the actual instance is not `DKLocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DKLocalAccountIdentification`
     * @throws ClassCastException if the instance is not `DKLocalAccountIdentification`
     */
    public DKLocalAccountIdentification getDKLocalAccountIdentification() throws ClassCastException {
        return (DKLocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `HKLocalAccountIdentification`. If the actual instance is not `HKLocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `HKLocalAccountIdentification`
     * @throws ClassCastException if the instance is not `HKLocalAccountIdentification`
     */
    public HKLocalAccountIdentification getHKLocalAccountIdentification() throws ClassCastException {
        return (HKLocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `HULocalAccountIdentification`. If the actual instance is not `HULocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `HULocalAccountIdentification`
     * @throws ClassCastException if the instance is not `HULocalAccountIdentification`
     */
    public HULocalAccountIdentification getHULocalAccountIdentification() throws ClassCastException {
        return (HULocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `IbanAccountIdentification`. If the actual instance is not `IbanAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `IbanAccountIdentification`
     * @throws ClassCastException if the instance is not `IbanAccountIdentification`
     */
    public IbanAccountIdentification getIbanAccountIdentification() throws ClassCastException {
        return (IbanAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `NOLocalAccountIdentification`. If the actual instance is not `NOLocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `NOLocalAccountIdentification`
     * @throws ClassCastException if the instance is not `NOLocalAccountIdentification`
     */
    public NOLocalAccountIdentification getNOLocalAccountIdentification() throws ClassCastException {
        return (NOLocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `NZLocalAccountIdentification`. If the actual instance is not `NZLocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `NZLocalAccountIdentification`
     * @throws ClassCastException if the instance is not `NZLocalAccountIdentification`
     */
    public NZLocalAccountIdentification getNZLocalAccountIdentification() throws ClassCastException {
        return (NZLocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `NumberAndBicAccountIdentification`. If the actual instance is not `NumberAndBicAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `NumberAndBicAccountIdentification`
     * @throws ClassCastException if the instance is not `NumberAndBicAccountIdentification`
     */
    public NumberAndBicAccountIdentification getNumberAndBicAccountIdentification() throws ClassCastException {
        return (NumberAndBicAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `PLLocalAccountIdentification`. If the actual instance is not `PLLocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `PLLocalAccountIdentification`
     * @throws ClassCastException if the instance is not `PLLocalAccountIdentification`
     */
    public PLLocalAccountIdentification getPLLocalAccountIdentification() throws ClassCastException {
        return (PLLocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `SELocalAccountIdentification`. If the actual instance is not `SELocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SELocalAccountIdentification`
     * @throws ClassCastException if the instance is not `SELocalAccountIdentification`
     */
    public SELocalAccountIdentification getSELocalAccountIdentification() throws ClassCastException {
        return (SELocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `SGLocalAccountIdentification`. If the actual instance is not `SGLocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SGLocalAccountIdentification`
     * @throws ClassCastException if the instance is not `SGLocalAccountIdentification`
     */
    public SGLocalAccountIdentification getSGLocalAccountIdentification() throws ClassCastException {
        return (SGLocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `UKLocalAccountIdentification`. If the actual instance is not `UKLocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `UKLocalAccountIdentification`
     * @throws ClassCastException if the instance is not `UKLocalAccountIdentification`
     */
    public UKLocalAccountIdentification getUKLocalAccountIdentification() throws ClassCastException {
        return (UKLocalAccountIdentification)super.getActualInstance();
    }
    /**
     * Get the actual instance of `USLocalAccountIdentification`. If the actual instance is not `USLocalAccountIdentification`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `USLocalAccountIdentification`
     * @throws ClassCastException if the instance is not `USLocalAccountIdentification`
     */
    public USLocalAccountIdentification getUSLocalAccountIdentification() throws ClassCastException {
        return (USLocalAccountIdentification)super.getActualInstance();
    }

    /**
     * Validates the JSON Element and throws an exception if issues found
     *
     * @param jsonElement JSON Element
     * @throws IOException if the JSON Element is invalid with respect to BankAccountInfoAccountIdentification
     */
    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
        // validate oneOf schemas one by one
        int validCount = 0;
        ArrayList<String> errorMessages = new ArrayList<>();
        // validate the json string with AULocalAccountIdentification
        try {
            AULocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for AULocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CALocalAccountIdentification
        try {
            CALocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CALocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CZLocalAccountIdentification
        try {
            CZLocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CZLocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with DKLocalAccountIdentification
        try {
            DKLocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for DKLocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with HKLocalAccountIdentification
        try {
            HKLocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for HKLocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with HULocalAccountIdentification
        try {
            HULocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for HULocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with IbanAccountIdentification
        try {
            IbanAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for IbanAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with NOLocalAccountIdentification
        try {
            NOLocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for NOLocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with NZLocalAccountIdentification
        try {
            NZLocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for NZLocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with NumberAndBicAccountIdentification
        try {
            NumberAndBicAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for NumberAndBicAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with PLLocalAccountIdentification
        try {
            PLLocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for PLLocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with SELocalAccountIdentification
        try {
            SELocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for SELocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with SGLocalAccountIdentification
        try {
            SGLocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for SGLocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with UKLocalAccountIdentification
        try {
            UKLocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for UKLocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with USLocalAccountIdentification
        try {
            USLocalAccountIdentification.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for USLocalAccountIdentification failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        if (validCount != 1) {
            throw new IOException(String.format("The JSON string is invalid for BankAccountInfoAccountIdentification with oneOf schemas: AULocalAccountIdentification, CALocalAccountIdentification, CZLocalAccountIdentification, DKLocalAccountIdentification, HKLocalAccountIdentification, HULocalAccountIdentification, IbanAccountIdentification, NOLocalAccountIdentification, NZLocalAccountIdentification, NumberAndBicAccountIdentification, PLLocalAccountIdentification, SELocalAccountIdentification, SGLocalAccountIdentification, UKLocalAccountIdentification, USLocalAccountIdentification. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonElement.toString()));
        }
    }

    /**
     * Create an instance of BankAccountInfoAccountIdentification given an JSON string
     *
     * @param jsonString JSON string
     * @return An instance of BankAccountInfoAccountIdentification
     * @throws IOException if the JSON string is invalid with respect to BankAccountInfoAccountIdentification
     */
    public static BankAccountInfoAccountIdentification fromJson(String jsonString) throws IOException {
        return JSON.getGson().fromJson(jsonString, BankAccountInfoAccountIdentification.class);
    }

    /**
     * Convert an instance of BankAccountInfoAccountIdentification to an JSON string
     *
     * @return JSON string
     */
    public String toJson() {
        return JSON.getGson().toJson(this);
    }
}

