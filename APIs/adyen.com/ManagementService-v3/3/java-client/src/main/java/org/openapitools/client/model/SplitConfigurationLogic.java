/*
 * Management API
 * Configure and manage your Adyen company and merchant accounts, stores, and payment terminals. ## Authentication Each request to the Management API must be signed with an API key. [Generate your API key](https://docs.adyen.com/development-resources/api-credentials#generate-api-key) in the Customer Area and then set this key to the `X-API-Key` header value.  To access the live endpoints, you need to generate a new API key in your live Customer Area. ## Versioning  Management API handles versioning as part of the endpoint URL. For example, to send a request to this version of the `/companies/{companyId}/webhooks` endpoint, use:  ```text https://management-test.adyen.com/v3/companies/{companyId}/webhooks ```  ## Going live  To access the live endpoints, you need an API key from your live Customer Area. Use this API key to make requests to:  ```text https://management-live.adyen.com/v3 ```  ## Release notes Have a look at the [release notes](https://docs.adyen.com/release-notes/management-api) to find out what changed in this version!
 *
 * The version of the OpenAPI document: 3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AdditionalCommission;
import org.openapitools.client.model.Commission;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * SplitConfigurationLogic
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:15:33.121604-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SplitConfigurationLogic {
  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with adyenFees.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   */
  @JsonAdapter(AcquiringFeesEnum.Adapter.class)
  public enum AcquiringFeesEnum {
    DEDUCT_FROM_LIABLE_ACCOUNT("deductFromLiableAccount"),
    
    DEDUCT_FROM_ONE_BALANCE_ACCOUNT("deductFromOneBalanceAccount");

    private String value;

    AcquiringFeesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AcquiringFeesEnum fromValue(String value) {
      for (AcquiringFeesEnum b : AcquiringFeesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AcquiringFeesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AcquiringFeesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AcquiringFeesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AcquiringFeesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AcquiringFeesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ACQUIRING_FEES = "acquiringFees";
  @SerializedName(SERIALIZED_NAME_ACQUIRING_FEES)
  private AcquiringFeesEnum acquiringFees;

  public static final String SERIALIZED_NAME_ADDITIONAL_COMMISSION = "additionalCommission";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_COMMISSION)
  private AdditionalCommission additionalCommission;

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with schemeFee, interchange &amp; adyenMarkup.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   */
  @JsonAdapter(AdyenCommissionEnum.Adapter.class)
  public enum AdyenCommissionEnum {
    DEDUCT_FROM_LIABLE_ACCOUNT("deductFromLiableAccount"),
    
    DEDUCT_FROM_ONE_BALANCE_ACCOUNT("deductFromOneBalanceAccount");

    private String value;

    AdyenCommissionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AdyenCommissionEnum fromValue(String value) {
      for (AdyenCommissionEnum b : AdyenCommissionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AdyenCommissionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AdyenCommissionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AdyenCommissionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AdyenCommissionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AdyenCommissionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ADYEN_COMMISSION = "adyenCommission";
  @SerializedName(SERIALIZED_NAME_ADYEN_COMMISSION)
  private AdyenCommissionEnum adyenCommission;

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with acquiringFees.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   */
  @JsonAdapter(AdyenFeesEnum.Adapter.class)
  public enum AdyenFeesEnum {
    DEDUCT_FROM_LIABLE_ACCOUNT("deductFromLiableAccount"),
    
    DEDUCT_FROM_ONE_BALANCE_ACCOUNT("deductFromOneBalanceAccount");

    private String value;

    AdyenFeesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AdyenFeesEnum fromValue(String value) {
      for (AdyenFeesEnum b : AdyenFeesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AdyenFeesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AdyenFeesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AdyenFeesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AdyenFeesEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AdyenFeesEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ADYEN_FEES = "adyenFees";
  @SerializedName(SERIALIZED_NAME_ADYEN_FEES)
  private AdyenFeesEnum adyenFees;

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with schemeFee, adyenCommission &amp; interchange.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   */
  @JsonAdapter(AdyenMarkupEnum.Adapter.class)
  public enum AdyenMarkupEnum {
    DEDUCT_FROM_LIABLE_ACCOUNT("deductFromLiableAccount"),
    
    DEDUCT_FROM_ONE_BALANCE_ACCOUNT("deductFromOneBalanceAccount");

    private String value;

    AdyenMarkupEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AdyenMarkupEnum fromValue(String value) {
      for (AdyenMarkupEnum b : AdyenMarkupEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AdyenMarkupEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AdyenMarkupEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AdyenMarkupEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AdyenMarkupEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AdyenMarkupEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ADYEN_MARKUP = "adyenMarkup";
  @SerializedName(SERIALIZED_NAME_ADYEN_MARKUP)
  private AdyenMarkupEnum adyenMarkup;

  /**
   * Specifies the logic to apply when booking the chargeback amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**.
   */
  @JsonAdapter(ChargebackEnum.Adapter.class)
  public enum ChargebackEnum {
    DEDUCT_FROM_LIABLE_ACCOUNT("deductFromLiableAccount"),
    
    DEDUCT_FROM_ONE_BALANCE_ACCOUNT("deductFromOneBalanceAccount"),
    
    DEDUCT_ACCORDING_TO_SPLIT_RATIO("deductAccordingToSplitRatio");

    private String value;

    ChargebackEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ChargebackEnum fromValue(String value) {
      for (ChargebackEnum b : ChargebackEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ChargebackEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ChargebackEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ChargebackEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ChargebackEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ChargebackEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CHARGEBACK = "chargeback";
  @SerializedName(SERIALIZED_NAME_CHARGEBACK)
  private ChargebackEnum chargeback;

  /**
   * Specifies the logic to apply when allocating the chargeback costs.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**
   */
  @JsonAdapter(ChargebackCostAllocationEnum.Adapter.class)
  public enum ChargebackCostAllocationEnum {
    DEDUCT_FROM_LIABLE_ACCOUNT("deductFromLiableAccount"),
    
    DEDUCT_FROM_ONE_BALANCE_ACCOUNT("deductFromOneBalanceAccount");

    private String value;

    ChargebackCostAllocationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ChargebackCostAllocationEnum fromValue(String value) {
      for (ChargebackCostAllocationEnum b : ChargebackCostAllocationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ChargebackCostAllocationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ChargebackCostAllocationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ChargebackCostAllocationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ChargebackCostAllocationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ChargebackCostAllocationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CHARGEBACK_COST_ALLOCATION = "chargebackCostAllocation";
  @SerializedName(SERIALIZED_NAME_CHARGEBACK_COST_ALLOCATION)
  private ChargebackCostAllocationEnum chargebackCostAllocation;

  public static final String SERIALIZED_NAME_COMMISSION = "commission";
  @SerializedName(SERIALIZED_NAME_COMMISSION)
  private Commission commission;

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with schemeFee, adyenCommission &amp; adyenMarkup.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   */
  @JsonAdapter(InterchangeEnum.Adapter.class)
  public enum InterchangeEnum {
    DEDUCT_FROM_LIABLE_ACCOUNT("deductFromLiableAccount"),
    
    DEDUCT_FROM_ONE_BALANCE_ACCOUNT("deductFromOneBalanceAccount");

    private String value;

    InterchangeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InterchangeEnum fromValue(String value) {
      for (InterchangeEnum b : InterchangeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InterchangeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InterchangeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InterchangeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InterchangeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      InterchangeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INTERCHANGE = "interchange";
  @SerializedName(SERIALIZED_NAME_INTERCHANGE)
  private InterchangeEnum interchange;

  /**
   * Specifies the logic to apply when booking the transaction fees. Cannot be combined with other fees.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   */
  @JsonAdapter(PaymentFeeEnum.Adapter.class)
  public enum PaymentFeeEnum {
    DEDUCT_FROM_LIABLE_ACCOUNT("deductFromLiableAccount"),
    
    DEDUCT_FROM_ONE_BALANCE_ACCOUNT("deductFromOneBalanceAccount");

    private String value;

    PaymentFeeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PaymentFeeEnum fromValue(String value) {
      for (PaymentFeeEnum b : PaymentFeeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PaymentFeeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PaymentFeeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PaymentFeeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PaymentFeeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PaymentFeeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PAYMENT_FEE = "paymentFee";
  @SerializedName(SERIALIZED_NAME_PAYMENT_FEE)
  private PaymentFeeEnum paymentFee;

  /**
   * Specifies the logic to apply when booking the amount left over after currency conversion.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
   */
  @JsonAdapter(RemainderEnum.Adapter.class)
  public enum RemainderEnum {
    ADD_TO_LIABLE_ACCOUNT("addToLiableAccount"),
    
    ADD_TO_ONE_BALANCE_ACCOUNT("addToOneBalanceAccount");

    private String value;

    RemainderEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RemainderEnum fromValue(String value) {
      for (RemainderEnum b : RemainderEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RemainderEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RemainderEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RemainderEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RemainderEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RemainderEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REMAINDER = "remainder";
  @SerializedName(SERIALIZED_NAME_REMAINDER)
  private RemainderEnum remainder;

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with interchange, adyenCommission &amp; adyenMarkup.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   */
  @JsonAdapter(SchemeFeeEnum.Adapter.class)
  public enum SchemeFeeEnum {
    DEDUCT_FROM_LIABLE_ACCOUNT("deductFromLiableAccount"),
    
    DEDUCT_FROM_ONE_BALANCE_ACCOUNT("deductFromOneBalanceAccount");

    private String value;

    SchemeFeeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SchemeFeeEnum fromValue(String value) {
      for (SchemeFeeEnum b : SchemeFeeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SchemeFeeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SchemeFeeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SchemeFeeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SchemeFeeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SchemeFeeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SCHEME_FEE = "schemeFee";
  @SerializedName(SERIALIZED_NAME_SCHEME_FEE)
  private SchemeFeeEnum schemeFee;

  public static final String SERIALIZED_NAME_SPLIT_LOGIC_ID = "splitLogicId";
  @SerializedName(SERIALIZED_NAME_SPLIT_LOGIC_ID)
  private String splitLogicId;

  /**
   * Specifies the logic to apply when booking the surcharge amount.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**
   */
  @JsonAdapter(SurchargeEnum.Adapter.class)
  public enum SurchargeEnum {
    ADD_TO_LIABLE_ACCOUNT("addToLiableAccount"),
    
    ADD_TO_ONE_BALANCE_ACCOUNT("addToOneBalanceAccount");

    private String value;

    SurchargeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SurchargeEnum fromValue(String value) {
      for (SurchargeEnum b : SurchargeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SurchargeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SurchargeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SurchargeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SurchargeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SurchargeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SURCHARGE = "surcharge";
  @SerializedName(SERIALIZED_NAME_SURCHARGE)
  private SurchargeEnum surcharge;

  /**
   * Specifies the logic to apply when booking tips (gratuity).  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
   */
  @JsonAdapter(TipEnum.Adapter.class)
  public enum TipEnum {
    ADD_TO_LIABLE_ACCOUNT("addToLiableAccount"),
    
    ADD_TO_ONE_BALANCE_ACCOUNT("addToOneBalanceAccount");

    private String value;

    TipEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TipEnum fromValue(String value) {
      for (TipEnum b : TipEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TipEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TipEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TipEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TipEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TipEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TIP = "tip";
  @SerializedName(SERIALIZED_NAME_TIP)
  private TipEnum tip;

  public SplitConfigurationLogic() {
  }

  public SplitConfigurationLogic(
     String splitLogicId
  ) {
    this();
    this.splitLogicId = splitLogicId;
  }

  public SplitConfigurationLogic acquiringFees(AcquiringFeesEnum acquiringFees) {
    this.acquiringFees = acquiringFees;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with adyenFees.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   * @return acquiringFees
   */
  @javax.annotation.Nullable
  public AcquiringFeesEnum getAcquiringFees() {
    return acquiringFees;
  }

  public void setAcquiringFees(AcquiringFeesEnum acquiringFees) {
    this.acquiringFees = acquiringFees;
  }


  public SplitConfigurationLogic additionalCommission(AdditionalCommission additionalCommission) {
    this.additionalCommission = additionalCommission;
    return this;
  }

  /**
   * Contains the logic used to calculate your user&#39;s commission, booked directly to their balance account.
   * @return additionalCommission
   */
  @javax.annotation.Nullable
  public AdditionalCommission getAdditionalCommission() {
    return additionalCommission;
  }

  public void setAdditionalCommission(AdditionalCommission additionalCommission) {
    this.additionalCommission = additionalCommission;
  }


  public SplitConfigurationLogic adyenCommission(AdyenCommissionEnum adyenCommission) {
    this.adyenCommission = adyenCommission;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with schemeFee, interchange &amp; adyenMarkup.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   * @return adyenCommission
   */
  @javax.annotation.Nullable
  public AdyenCommissionEnum getAdyenCommission() {
    return adyenCommission;
  }

  public void setAdyenCommission(AdyenCommissionEnum adyenCommission) {
    this.adyenCommission = adyenCommission;
  }


  public SplitConfigurationLogic adyenFees(AdyenFeesEnum adyenFees) {
    this.adyenFees = adyenFees;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with acquiringFees.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   * @return adyenFees
   */
  @javax.annotation.Nullable
  public AdyenFeesEnum getAdyenFees() {
    return adyenFees;
  }

  public void setAdyenFees(AdyenFeesEnum adyenFees) {
    this.adyenFees = adyenFees;
  }


  public SplitConfigurationLogic adyenMarkup(AdyenMarkupEnum adyenMarkup) {
    this.adyenMarkup = adyenMarkup;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with schemeFee, adyenCommission &amp; interchange.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   * @return adyenMarkup
   */
  @javax.annotation.Nullable
  public AdyenMarkupEnum getAdyenMarkup() {
    return adyenMarkup;
  }

  public void setAdyenMarkup(AdyenMarkupEnum adyenMarkup) {
    this.adyenMarkup = adyenMarkup;
  }


  public SplitConfigurationLogic chargeback(ChargebackEnum chargeback) {
    this.chargeback = chargeback;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the chargeback amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**.
   * @return chargeback
   */
  @javax.annotation.Nullable
  public ChargebackEnum getChargeback() {
    return chargeback;
  }

  public void setChargeback(ChargebackEnum chargeback) {
    this.chargeback = chargeback;
  }


  public SplitConfigurationLogic chargebackCostAllocation(ChargebackCostAllocationEnum chargebackCostAllocation) {
    this.chargebackCostAllocation = chargebackCostAllocation;
    return this;
  }

  /**
   * Specifies the logic to apply when allocating the chargeback costs.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**
   * @return chargebackCostAllocation
   */
  @javax.annotation.Nullable
  public ChargebackCostAllocationEnum getChargebackCostAllocation() {
    return chargebackCostAllocation;
  }

  public void setChargebackCostAllocation(ChargebackCostAllocationEnum chargebackCostAllocation) {
    this.chargebackCostAllocation = chargebackCostAllocation;
  }


  public SplitConfigurationLogic commission(Commission commission) {
    this.commission = commission;
    return this;
  }

  /**
   * Contains the logic used to the calculate your platform&#39;s commission, booked to your liable balance account.
   * @return commission
   */
  @javax.annotation.Nonnull
  public Commission getCommission() {
    return commission;
  }

  public void setCommission(Commission commission) {
    this.commission = commission;
  }


  public SplitConfigurationLogic interchange(InterchangeEnum interchange) {
    this.interchange = interchange;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with schemeFee, adyenCommission &amp; adyenMarkup.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   * @return interchange
   */
  @javax.annotation.Nullable
  public InterchangeEnum getInterchange() {
    return interchange;
  }

  public void setInterchange(InterchangeEnum interchange) {
    this.interchange = interchange;
  }


  public SplitConfigurationLogic paymentFee(PaymentFeeEnum paymentFee) {
    this.paymentFee = paymentFee;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the transaction fees. Cannot be combined with other fees.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   * @return paymentFee
   */
  @javax.annotation.Nullable
  public PaymentFeeEnum getPaymentFee() {
    return paymentFee;
  }

  public void setPaymentFee(PaymentFeeEnum paymentFee) {
    this.paymentFee = paymentFee;
  }


  public SplitConfigurationLogic remainder(RemainderEnum remainder) {
    this.remainder = remainder;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the amount left over after currency conversion.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
   * @return remainder
   */
  @javax.annotation.Nullable
  public RemainderEnum getRemainder() {
    return remainder;
  }

  public void setRemainder(RemainderEnum remainder) {
    this.remainder = remainder;
  }


  public SplitConfigurationLogic schemeFee(SchemeFeeEnum schemeFee) {
    this.schemeFee = schemeFee;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the transaction fees. Should be combined with interchange, adyenCommission &amp; adyenMarkup.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
   * @return schemeFee
   */
  @javax.annotation.Nullable
  public SchemeFeeEnum getSchemeFee() {
    return schemeFee;
  }

  public void setSchemeFee(SchemeFeeEnum schemeFee) {
    this.schemeFee = schemeFee;
  }


  /**
   * Unique identifier of the split logic that is applied when the split configuration conditions are met.
   * @return splitLogicId
   */
  @javax.annotation.Nullable
  public String getSplitLogicId() {
    return splitLogicId;
  }



  public SplitConfigurationLogic surcharge(SurchargeEnum surcharge) {
    this.surcharge = surcharge;
    return this;
  }

  /**
   * Specifies the logic to apply when booking the surcharge amount.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**
   * @return surcharge
   */
  @javax.annotation.Nullable
  public SurchargeEnum getSurcharge() {
    return surcharge;
  }

  public void setSurcharge(SurchargeEnum surcharge) {
    this.surcharge = surcharge;
  }


  public SplitConfigurationLogic tip(TipEnum tip) {
    this.tip = tip;
    return this;
  }

  /**
   * Specifies the logic to apply when booking tips (gratuity).  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
   * @return tip
   */
  @javax.annotation.Nullable
  public TipEnum getTip() {
    return tip;
  }

  public void setTip(TipEnum tip) {
    this.tip = tip;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SplitConfigurationLogic splitConfigurationLogic = (SplitConfigurationLogic) o;
    return Objects.equals(this.acquiringFees, splitConfigurationLogic.acquiringFees) &&
        Objects.equals(this.additionalCommission, splitConfigurationLogic.additionalCommission) &&
        Objects.equals(this.adyenCommission, splitConfigurationLogic.adyenCommission) &&
        Objects.equals(this.adyenFees, splitConfigurationLogic.adyenFees) &&
        Objects.equals(this.adyenMarkup, splitConfigurationLogic.adyenMarkup) &&
        Objects.equals(this.chargeback, splitConfigurationLogic.chargeback) &&
        Objects.equals(this.chargebackCostAllocation, splitConfigurationLogic.chargebackCostAllocation) &&
        Objects.equals(this.commission, splitConfigurationLogic.commission) &&
        Objects.equals(this.interchange, splitConfigurationLogic.interchange) &&
        Objects.equals(this.paymentFee, splitConfigurationLogic.paymentFee) &&
        Objects.equals(this.remainder, splitConfigurationLogic.remainder) &&
        Objects.equals(this.schemeFee, splitConfigurationLogic.schemeFee) &&
        Objects.equals(this.splitLogicId, splitConfigurationLogic.splitLogicId) &&
        Objects.equals(this.surcharge, splitConfigurationLogic.surcharge) &&
        Objects.equals(this.tip, splitConfigurationLogic.tip);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acquiringFees, additionalCommission, adyenCommission, adyenFees, adyenMarkup, chargeback, chargebackCostAllocation, commission, interchange, paymentFee, remainder, schemeFee, splitLogicId, surcharge, tip);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SplitConfigurationLogic {\n");
    sb.append("    acquiringFees: ").append(toIndentedString(acquiringFees)).append("\n");
    sb.append("    additionalCommission: ").append(toIndentedString(additionalCommission)).append("\n");
    sb.append("    adyenCommission: ").append(toIndentedString(adyenCommission)).append("\n");
    sb.append("    adyenFees: ").append(toIndentedString(adyenFees)).append("\n");
    sb.append("    adyenMarkup: ").append(toIndentedString(adyenMarkup)).append("\n");
    sb.append("    chargeback: ").append(toIndentedString(chargeback)).append("\n");
    sb.append("    chargebackCostAllocation: ").append(toIndentedString(chargebackCostAllocation)).append("\n");
    sb.append("    commission: ").append(toIndentedString(commission)).append("\n");
    sb.append("    interchange: ").append(toIndentedString(interchange)).append("\n");
    sb.append("    paymentFee: ").append(toIndentedString(paymentFee)).append("\n");
    sb.append("    remainder: ").append(toIndentedString(remainder)).append("\n");
    sb.append("    schemeFee: ").append(toIndentedString(schemeFee)).append("\n");
    sb.append("    splitLogicId: ").append(toIndentedString(splitLogicId)).append("\n");
    sb.append("    surcharge: ").append(toIndentedString(surcharge)).append("\n");
    sb.append("    tip: ").append(toIndentedString(tip)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acquiringFees");
    openapiFields.add("additionalCommission");
    openapiFields.add("adyenCommission");
    openapiFields.add("adyenFees");
    openapiFields.add("adyenMarkup");
    openapiFields.add("chargeback");
    openapiFields.add("chargebackCostAllocation");
    openapiFields.add("commission");
    openapiFields.add("interchange");
    openapiFields.add("paymentFee");
    openapiFields.add("remainder");
    openapiFields.add("schemeFee");
    openapiFields.add("splitLogicId");
    openapiFields.add("surcharge");
    openapiFields.add("tip");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("commission");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SplitConfigurationLogic
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SplitConfigurationLogic.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SplitConfigurationLogic is not found in the empty JSON string", SplitConfigurationLogic.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SplitConfigurationLogic.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SplitConfigurationLogic` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : SplitConfigurationLogic.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("acquiringFees") != null && !jsonObj.get("acquiringFees").isJsonNull()) && !jsonObj.get("acquiringFees").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `acquiringFees` to be a primitive type in the JSON string but got `%s`", jsonObj.get("acquiringFees").toString()));
      }
      // validate the optional field `acquiringFees`
      if (jsonObj.get("acquiringFees") != null && !jsonObj.get("acquiringFees").isJsonNull()) {
        AcquiringFeesEnum.validateJsonElement(jsonObj.get("acquiringFees"));
      }
      // validate the optional field `additionalCommission`
      if (jsonObj.get("additionalCommission") != null && !jsonObj.get("additionalCommission").isJsonNull()) {
        AdditionalCommission.validateJsonElement(jsonObj.get("additionalCommission"));
      }
      if ((jsonObj.get("adyenCommission") != null && !jsonObj.get("adyenCommission").isJsonNull()) && !jsonObj.get("adyenCommission").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `adyenCommission` to be a primitive type in the JSON string but got `%s`", jsonObj.get("adyenCommission").toString()));
      }
      // validate the optional field `adyenCommission`
      if (jsonObj.get("adyenCommission") != null && !jsonObj.get("adyenCommission").isJsonNull()) {
        AdyenCommissionEnum.validateJsonElement(jsonObj.get("adyenCommission"));
      }
      if ((jsonObj.get("adyenFees") != null && !jsonObj.get("adyenFees").isJsonNull()) && !jsonObj.get("adyenFees").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `adyenFees` to be a primitive type in the JSON string but got `%s`", jsonObj.get("adyenFees").toString()));
      }
      // validate the optional field `adyenFees`
      if (jsonObj.get("adyenFees") != null && !jsonObj.get("adyenFees").isJsonNull()) {
        AdyenFeesEnum.validateJsonElement(jsonObj.get("adyenFees"));
      }
      if ((jsonObj.get("adyenMarkup") != null && !jsonObj.get("adyenMarkup").isJsonNull()) && !jsonObj.get("adyenMarkup").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `adyenMarkup` to be a primitive type in the JSON string but got `%s`", jsonObj.get("adyenMarkup").toString()));
      }
      // validate the optional field `adyenMarkup`
      if (jsonObj.get("adyenMarkup") != null && !jsonObj.get("adyenMarkup").isJsonNull()) {
        AdyenMarkupEnum.validateJsonElement(jsonObj.get("adyenMarkup"));
      }
      if ((jsonObj.get("chargeback") != null && !jsonObj.get("chargeback").isJsonNull()) && !jsonObj.get("chargeback").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chargeback` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chargeback").toString()));
      }
      // validate the optional field `chargeback`
      if (jsonObj.get("chargeback") != null && !jsonObj.get("chargeback").isJsonNull()) {
        ChargebackEnum.validateJsonElement(jsonObj.get("chargeback"));
      }
      if ((jsonObj.get("chargebackCostAllocation") != null && !jsonObj.get("chargebackCostAllocation").isJsonNull()) && !jsonObj.get("chargebackCostAllocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chargebackCostAllocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chargebackCostAllocation").toString()));
      }
      // validate the optional field `chargebackCostAllocation`
      if (jsonObj.get("chargebackCostAllocation") != null && !jsonObj.get("chargebackCostAllocation").isJsonNull()) {
        ChargebackCostAllocationEnum.validateJsonElement(jsonObj.get("chargebackCostAllocation"));
      }
      // validate the required field `commission`
      Commission.validateJsonElement(jsonObj.get("commission"));
      if ((jsonObj.get("interchange") != null && !jsonObj.get("interchange").isJsonNull()) && !jsonObj.get("interchange").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `interchange` to be a primitive type in the JSON string but got `%s`", jsonObj.get("interchange").toString()));
      }
      // validate the optional field `interchange`
      if (jsonObj.get("interchange") != null && !jsonObj.get("interchange").isJsonNull()) {
        InterchangeEnum.validateJsonElement(jsonObj.get("interchange"));
      }
      if ((jsonObj.get("paymentFee") != null && !jsonObj.get("paymentFee").isJsonNull()) && !jsonObj.get("paymentFee").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `paymentFee` to be a primitive type in the JSON string but got `%s`", jsonObj.get("paymentFee").toString()));
      }
      // validate the optional field `paymentFee`
      if (jsonObj.get("paymentFee") != null && !jsonObj.get("paymentFee").isJsonNull()) {
        PaymentFeeEnum.validateJsonElement(jsonObj.get("paymentFee"));
      }
      if ((jsonObj.get("remainder") != null && !jsonObj.get("remainder").isJsonNull()) && !jsonObj.get("remainder").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `remainder` to be a primitive type in the JSON string but got `%s`", jsonObj.get("remainder").toString()));
      }
      // validate the optional field `remainder`
      if (jsonObj.get("remainder") != null && !jsonObj.get("remainder").isJsonNull()) {
        RemainderEnum.validateJsonElement(jsonObj.get("remainder"));
      }
      if ((jsonObj.get("schemeFee") != null && !jsonObj.get("schemeFee").isJsonNull()) && !jsonObj.get("schemeFee").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `schemeFee` to be a primitive type in the JSON string but got `%s`", jsonObj.get("schemeFee").toString()));
      }
      // validate the optional field `schemeFee`
      if (jsonObj.get("schemeFee") != null && !jsonObj.get("schemeFee").isJsonNull()) {
        SchemeFeeEnum.validateJsonElement(jsonObj.get("schemeFee"));
      }
      if ((jsonObj.get("splitLogicId") != null && !jsonObj.get("splitLogicId").isJsonNull()) && !jsonObj.get("splitLogicId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `splitLogicId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("splitLogicId").toString()));
      }
      if ((jsonObj.get("surcharge") != null && !jsonObj.get("surcharge").isJsonNull()) && !jsonObj.get("surcharge").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `surcharge` to be a primitive type in the JSON string but got `%s`", jsonObj.get("surcharge").toString()));
      }
      // validate the optional field `surcharge`
      if (jsonObj.get("surcharge") != null && !jsonObj.get("surcharge").isJsonNull()) {
        SurchargeEnum.validateJsonElement(jsonObj.get("surcharge"));
      }
      if ((jsonObj.get("tip") != null && !jsonObj.get("tip").isJsonNull()) && !jsonObj.get("tip").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tip` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tip").toString()));
      }
      // validate the optional field `tip`
      if (jsonObj.get("tip") != null && !jsonObj.get("tip").isJsonNull()) {
        TipEnum.validateJsonElement(jsonObj.get("tip"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SplitConfigurationLogic.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SplitConfigurationLogic' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SplitConfigurationLogic> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SplitConfigurationLogic.class));

       return (TypeAdapter<T>) new TypeAdapter<SplitConfigurationLogic>() {
           @Override
           public void write(JsonWriter out, SplitConfigurationLogic value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SplitConfigurationLogic read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SplitConfigurationLogic given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SplitConfigurationLogic
   * @throws IOException if the JSON string is invalid with respect to SplitConfigurationLogic
   */
  public static SplitConfigurationLogic fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SplitConfigurationLogic.class);
  }

  /**
   * Convert an instance of SplitConfigurationLogic to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

