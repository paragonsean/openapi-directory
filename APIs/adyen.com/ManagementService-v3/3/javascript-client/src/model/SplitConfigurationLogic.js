/**
 * Management API
 * Configure and manage your Adyen company and merchant accounts, stores, and payment terminals. ## Authentication Each request to the Management API must be signed with an API key. [Generate your API key](https://docs.adyen.com/development-resources/api-credentials#generate-api-key) in the Customer Area and then set this key to the `X-API-Key` header value.  To access the live endpoints, you need to generate a new API key in your live Customer Area. ## Versioning  Management API handles versioning as part of the endpoint URL. For example, to send a request to this version of the `/companies/{companyId}/webhooks` endpoint, use:  ```text https://management-test.adyen.com/v3/companies/{companyId}/webhooks ```  ## Going live  To access the live endpoints, you need an API key from your live Customer Area. Use this API key to make requests to:  ```text https://management-live.adyen.com/v3 ```  ## Release notes Have a look at the [release notes](https://docs.adyen.com/release-notes/management-api) to find out what changed in this version!
 *
 * The version of the OpenAPI document: 3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import AdditionalCommission from './AdditionalCommission';
import Commission from './Commission';

/**
 * The SplitConfigurationLogic model module.
 * @module model/SplitConfigurationLogic
 * @version 3
 */
class SplitConfigurationLogic {
    /**
     * Constructs a new <code>SplitConfigurationLogic</code>.
     * @alias module:model/SplitConfigurationLogic
     * @param commission {module:model/Commission} Contains the logic used to the calculate your platform's commission, booked to your liable balance account.
     */
    constructor(commission) { 
        
        SplitConfigurationLogic.initialize(this, commission);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, commission) { 
        obj['commission'] = commission;
    }

    /**
     * Constructs a <code>SplitConfigurationLogic</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/SplitConfigurationLogic} obj Optional instance to populate.
     * @return {module:model/SplitConfigurationLogic} The populated <code>SplitConfigurationLogic</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new SplitConfigurationLogic();

            if (data.hasOwnProperty('acquiringFees')) {
                obj['acquiringFees'] = ApiClient.convertToType(data['acquiringFees'], 'String');
            }
            if (data.hasOwnProperty('additionalCommission')) {
                obj['additionalCommission'] = AdditionalCommission.constructFromObject(data['additionalCommission']);
            }
            if (data.hasOwnProperty('adyenCommission')) {
                obj['adyenCommission'] = ApiClient.convertToType(data['adyenCommission'], 'String');
            }
            if (data.hasOwnProperty('adyenFees')) {
                obj['adyenFees'] = ApiClient.convertToType(data['adyenFees'], 'String');
            }
            if (data.hasOwnProperty('adyenMarkup')) {
                obj['adyenMarkup'] = ApiClient.convertToType(data['adyenMarkup'], 'String');
            }
            if (data.hasOwnProperty('chargeback')) {
                obj['chargeback'] = ApiClient.convertToType(data['chargeback'], 'String');
            }
            if (data.hasOwnProperty('chargebackCostAllocation')) {
                obj['chargebackCostAllocation'] = ApiClient.convertToType(data['chargebackCostAllocation'], 'String');
            }
            if (data.hasOwnProperty('commission')) {
                obj['commission'] = Commission.constructFromObject(data['commission']);
            }
            if (data.hasOwnProperty('interchange')) {
                obj['interchange'] = ApiClient.convertToType(data['interchange'], 'String');
            }
            if (data.hasOwnProperty('paymentFee')) {
                obj['paymentFee'] = ApiClient.convertToType(data['paymentFee'], 'String');
            }
            if (data.hasOwnProperty('remainder')) {
                obj['remainder'] = ApiClient.convertToType(data['remainder'], 'String');
            }
            if (data.hasOwnProperty('schemeFee')) {
                obj['schemeFee'] = ApiClient.convertToType(data['schemeFee'], 'String');
            }
            if (data.hasOwnProperty('splitLogicId')) {
                obj['splitLogicId'] = ApiClient.convertToType(data['splitLogicId'], 'String');
            }
            if (data.hasOwnProperty('surcharge')) {
                obj['surcharge'] = ApiClient.convertToType(data['surcharge'], 'String');
            }
            if (data.hasOwnProperty('tip')) {
                obj['tip'] = ApiClient.convertToType(data['tip'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>SplitConfigurationLogic</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>SplitConfigurationLogic</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of SplitConfigurationLogic.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['acquiringFees'] && !(typeof data['acquiringFees'] === 'string' || data['acquiringFees'] instanceof String)) {
            throw new Error("Expected the field `acquiringFees` to be a primitive type in the JSON string but got " + data['acquiringFees']);
        }
        // validate the optional field `additionalCommission`
        if (data['additionalCommission']) { // data not null
          AdditionalCommission.validateJSON(data['additionalCommission']);
        }
        // ensure the json data is a string
        if (data['adyenCommission'] && !(typeof data['adyenCommission'] === 'string' || data['adyenCommission'] instanceof String)) {
            throw new Error("Expected the field `adyenCommission` to be a primitive type in the JSON string but got " + data['adyenCommission']);
        }
        // ensure the json data is a string
        if (data['adyenFees'] && !(typeof data['adyenFees'] === 'string' || data['adyenFees'] instanceof String)) {
            throw new Error("Expected the field `adyenFees` to be a primitive type in the JSON string but got " + data['adyenFees']);
        }
        // ensure the json data is a string
        if (data['adyenMarkup'] && !(typeof data['adyenMarkup'] === 'string' || data['adyenMarkup'] instanceof String)) {
            throw new Error("Expected the field `adyenMarkup` to be a primitive type in the JSON string but got " + data['adyenMarkup']);
        }
        // ensure the json data is a string
        if (data['chargeback'] && !(typeof data['chargeback'] === 'string' || data['chargeback'] instanceof String)) {
            throw new Error("Expected the field `chargeback` to be a primitive type in the JSON string but got " + data['chargeback']);
        }
        // ensure the json data is a string
        if (data['chargebackCostAllocation'] && !(typeof data['chargebackCostAllocation'] === 'string' || data['chargebackCostAllocation'] instanceof String)) {
            throw new Error("Expected the field `chargebackCostAllocation` to be a primitive type in the JSON string but got " + data['chargebackCostAllocation']);
        }
        // validate the optional field `commission`
        if (data['commission']) { // data not null
          Commission.validateJSON(data['commission']);
        }
        // ensure the json data is a string
        if (data['interchange'] && !(typeof data['interchange'] === 'string' || data['interchange'] instanceof String)) {
            throw new Error("Expected the field `interchange` to be a primitive type in the JSON string but got " + data['interchange']);
        }
        // ensure the json data is a string
        if (data['paymentFee'] && !(typeof data['paymentFee'] === 'string' || data['paymentFee'] instanceof String)) {
            throw new Error("Expected the field `paymentFee` to be a primitive type in the JSON string but got " + data['paymentFee']);
        }
        // ensure the json data is a string
        if (data['remainder'] && !(typeof data['remainder'] === 'string' || data['remainder'] instanceof String)) {
            throw new Error("Expected the field `remainder` to be a primitive type in the JSON string but got " + data['remainder']);
        }
        // ensure the json data is a string
        if (data['schemeFee'] && !(typeof data['schemeFee'] === 'string' || data['schemeFee'] instanceof String)) {
            throw new Error("Expected the field `schemeFee` to be a primitive type in the JSON string but got " + data['schemeFee']);
        }
        // ensure the json data is a string
        if (data['splitLogicId'] && !(typeof data['splitLogicId'] === 'string' || data['splitLogicId'] instanceof String)) {
            throw new Error("Expected the field `splitLogicId` to be a primitive type in the JSON string but got " + data['splitLogicId']);
        }
        // ensure the json data is a string
        if (data['surcharge'] && !(typeof data['surcharge'] === 'string' || data['surcharge'] instanceof String)) {
            throw new Error("Expected the field `surcharge` to be a primitive type in the JSON string but got " + data['surcharge']);
        }
        // ensure the json data is a string
        if (data['tip'] && !(typeof data['tip'] === 'string' || data['tip'] instanceof String)) {
            throw new Error("Expected the field `tip` to be a primitive type in the JSON string but got " + data['tip']);
        }

        return true;
    }


}

SplitConfigurationLogic.RequiredProperties = ["commission"];

/**
 * Specifies the logic to apply when booking the transaction fees. Should be combined with adyenFees.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
 * @member {module:model/SplitConfigurationLogic.AcquiringFeesEnum} acquiringFees
 */
SplitConfigurationLogic.prototype['acquiringFees'] = undefined;

/**
 * Contains the logic used to calculate your user's commission, booked directly to their balance account.
 * @member {module:model/AdditionalCommission} additionalCommission
 */
SplitConfigurationLogic.prototype['additionalCommission'] = undefined;

/**
 * Specifies the logic to apply when booking the transaction fees. Should be combined with schemeFee, interchange & adyenMarkup.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
 * @member {module:model/SplitConfigurationLogic.AdyenCommissionEnum} adyenCommission
 */
SplitConfigurationLogic.prototype['adyenCommission'] = undefined;

/**
 * Specifies the logic to apply when booking the transaction fees. Should be combined with acquiringFees.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
 * @member {module:model/SplitConfigurationLogic.AdyenFeesEnum} adyenFees
 */
SplitConfigurationLogic.prototype['adyenFees'] = undefined;

/**
 * Specifies the logic to apply when booking the transaction fees. Should be combined with schemeFee, adyenCommission & interchange.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
 * @member {module:model/SplitConfigurationLogic.AdyenMarkupEnum} adyenMarkup
 */
SplitConfigurationLogic.prototype['adyenMarkup'] = undefined;

/**
 * Specifies the logic to apply when booking the chargeback amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**.
 * @member {module:model/SplitConfigurationLogic.ChargebackEnum} chargeback
 */
SplitConfigurationLogic.prototype['chargeback'] = undefined;

/**
 * Specifies the logic to apply when allocating the chargeback costs.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**
 * @member {module:model/SplitConfigurationLogic.ChargebackCostAllocationEnum} chargebackCostAllocation
 */
SplitConfigurationLogic.prototype['chargebackCostAllocation'] = undefined;

/**
 * Contains the logic used to the calculate your platform's commission, booked to your liable balance account.
 * @member {module:model/Commission} commission
 */
SplitConfigurationLogic.prototype['commission'] = undefined;

/**
 * Specifies the logic to apply when booking the transaction fees. Should be combined with schemeFee, adyenCommission & adyenMarkup.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
 * @member {module:model/SplitConfigurationLogic.InterchangeEnum} interchange
 */
SplitConfigurationLogic.prototype['interchange'] = undefined;

/**
 * Specifies the logic to apply when booking the transaction fees. Cannot be combined with other fees.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
 * @member {module:model/SplitConfigurationLogic.PaymentFeeEnum} paymentFee
 */
SplitConfigurationLogic.prototype['paymentFee'] = undefined;

/**
 * Specifies the logic to apply when booking the amount left over after currency conversion.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
 * @member {module:model/SplitConfigurationLogic.RemainderEnum} remainder
 */
SplitConfigurationLogic.prototype['remainder'] = undefined;

/**
 * Specifies the logic to apply when booking the transaction fees. Should be combined with interchange, adyenCommission & adyenMarkup.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
 * @member {module:model/SplitConfigurationLogic.SchemeFeeEnum} schemeFee
 */
SplitConfigurationLogic.prototype['schemeFee'] = undefined;

/**
 * Unique identifier of the split logic that is applied when the split configuration conditions are met.
 * @member {String} splitLogicId
 */
SplitConfigurationLogic.prototype['splitLogicId'] = undefined;

/**
 * Specifies the logic to apply when booking the surcharge amount.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**
 * @member {module:model/SplitConfigurationLogic.SurchargeEnum} surcharge
 */
SplitConfigurationLogic.prototype['surcharge'] = undefined;

/**
 * Specifies the logic to apply when booking tips (gratuity).  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
 * @member {module:model/SplitConfigurationLogic.TipEnum} tip
 */
SplitConfigurationLogic.prototype['tip'] = undefined;





/**
 * Allowed values for the <code>acquiringFees</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['AcquiringFeesEnum'] = {

    /**
     * value: "deductFromLiableAccount"
     * @const
     */
    "deductFromLiableAccount": "deductFromLiableAccount",

    /**
     * value: "deductFromOneBalanceAccount"
     * @const
     */
    "deductFromOneBalanceAccount": "deductFromOneBalanceAccount"
};


/**
 * Allowed values for the <code>adyenCommission</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['AdyenCommissionEnum'] = {

    /**
     * value: "deductFromLiableAccount"
     * @const
     */
    "deductFromLiableAccount": "deductFromLiableAccount",

    /**
     * value: "deductFromOneBalanceAccount"
     * @const
     */
    "deductFromOneBalanceAccount": "deductFromOneBalanceAccount"
};


/**
 * Allowed values for the <code>adyenFees</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['AdyenFeesEnum'] = {

    /**
     * value: "deductFromLiableAccount"
     * @const
     */
    "deductFromLiableAccount": "deductFromLiableAccount",

    /**
     * value: "deductFromOneBalanceAccount"
     * @const
     */
    "deductFromOneBalanceAccount": "deductFromOneBalanceAccount"
};


/**
 * Allowed values for the <code>adyenMarkup</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['AdyenMarkupEnum'] = {

    /**
     * value: "deductFromLiableAccount"
     * @const
     */
    "deductFromLiableAccount": "deductFromLiableAccount",

    /**
     * value: "deductFromOneBalanceAccount"
     * @const
     */
    "deductFromOneBalanceAccount": "deductFromOneBalanceAccount"
};


/**
 * Allowed values for the <code>chargeback</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['ChargebackEnum'] = {

    /**
     * value: "deductFromLiableAccount"
     * @const
     */
    "deductFromLiableAccount": "deductFromLiableAccount",

    /**
     * value: "deductFromOneBalanceAccount"
     * @const
     */
    "deductFromOneBalanceAccount": "deductFromOneBalanceAccount",

    /**
     * value: "deductAccordingToSplitRatio"
     * @const
     */
    "deductAccordingToSplitRatio": "deductAccordingToSplitRatio"
};


/**
 * Allowed values for the <code>chargebackCostAllocation</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['ChargebackCostAllocationEnum'] = {

    /**
     * value: "deductFromLiableAccount"
     * @const
     */
    "deductFromLiableAccount": "deductFromLiableAccount",

    /**
     * value: "deductFromOneBalanceAccount"
     * @const
     */
    "deductFromOneBalanceAccount": "deductFromOneBalanceAccount"
};


/**
 * Allowed values for the <code>interchange</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['InterchangeEnum'] = {

    /**
     * value: "deductFromLiableAccount"
     * @const
     */
    "deductFromLiableAccount": "deductFromLiableAccount",

    /**
     * value: "deductFromOneBalanceAccount"
     * @const
     */
    "deductFromOneBalanceAccount": "deductFromOneBalanceAccount"
};


/**
 * Allowed values for the <code>paymentFee</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['PaymentFeeEnum'] = {

    /**
     * value: "deductFromLiableAccount"
     * @const
     */
    "deductFromLiableAccount": "deductFromLiableAccount",

    /**
     * value: "deductFromOneBalanceAccount"
     * @const
     */
    "deductFromOneBalanceAccount": "deductFromOneBalanceAccount"
};


/**
 * Allowed values for the <code>remainder</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['RemainderEnum'] = {

    /**
     * value: "addToLiableAccount"
     * @const
     */
    "addToLiableAccount": "addToLiableAccount",

    /**
     * value: "addToOneBalanceAccount"
     * @const
     */
    "addToOneBalanceAccount": "addToOneBalanceAccount"
};


/**
 * Allowed values for the <code>schemeFee</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['SchemeFeeEnum'] = {

    /**
     * value: "deductFromLiableAccount"
     * @const
     */
    "deductFromLiableAccount": "deductFromLiableAccount",

    /**
     * value: "deductFromOneBalanceAccount"
     * @const
     */
    "deductFromOneBalanceAccount": "deductFromOneBalanceAccount"
};


/**
 * Allowed values for the <code>surcharge</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['SurchargeEnum'] = {

    /**
     * value: "addToLiableAccount"
     * @const
     */
    "addToLiableAccount": "addToLiableAccount",

    /**
     * value: "addToOneBalanceAccount"
     * @const
     */
    "addToOneBalanceAccount": "addToOneBalanceAccount"
};


/**
 * Allowed values for the <code>tip</code> property.
 * @enum {String}
 * @readonly
 */
SplitConfigurationLogic['TipEnum'] = {

    /**
     * value: "addToLiableAccount"
     * @const
     */
    "addToLiableAccount": "addToLiableAccount",

    /**
     * value: "addToOneBalanceAccount"
     * @const
     */
    "addToOneBalanceAccount": "addToOneBalanceAccount"
};



export default SplitConfigurationLogic;

