/**
 * Classic Platforms - Notifications
 * This API is used for the classic integration. If you are just starting your implementation, refer to our [new integration guide](https://docs.adyen.com/marketplaces-and-platforms) instead.  The Notification API sends notifications to the endpoints specified in a given subscription.  Subscriptions are managed through the Notification Configuration API. The API specifications listed here detail the format of each notification.  For more information, refer to our [documentation](https://docs.adyen.com/marketplaces-and-platforms/classic/notifications).
 *
 * The version of the OpenAPI document: 4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import SplitAmount from './SplitAmount';

/**
 * The Split model module.
 * @module model/Split
 * @version 4
 */
class Split {
    /**
     * Constructs a new <code>Split</code>.
     * @alias module:model/Split
     * @param amount {module:model/SplitAmount} The amount of this split.
     * @param type {module:model/Split.TypeEnum} The type of split. Possible values: **Default**, **PaymentFee**, **VAT**, **Commission**, **MarketPlace**, **BalanceAccount**, **Remainder**, **Surcharge**, **Tip**.
     */
    constructor(amount, type) { 
        
        Split.initialize(this, amount, type);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, amount, type) { 
        obj['amount'] = amount;
        obj['type'] = type;
    }

    /**
     * Constructs a <code>Split</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Split} obj Optional instance to populate.
     * @return {module:model/Split} The populated <code>Split</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Split();

            if (data.hasOwnProperty('account')) {
                obj['account'] = ApiClient.convertToType(data['account'], 'String');
            }
            if (data.hasOwnProperty('amount')) {
                obj['amount'] = SplitAmount.constructFromObject(data['amount']);
            }
            if (data.hasOwnProperty('description')) {
                obj['description'] = ApiClient.convertToType(data['description'], 'String');
            }
            if (data.hasOwnProperty('reference')) {
                obj['reference'] = ApiClient.convertToType(data['reference'], 'String');
            }
            if (data.hasOwnProperty('type')) {
                obj['type'] = ApiClient.convertToType(data['type'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Split</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Split</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of Split.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['account'] && !(typeof data['account'] === 'string' || data['account'] instanceof String)) {
            throw new Error("Expected the field `account` to be a primitive type in the JSON string but got " + data['account']);
        }
        // validate the optional field `amount`
        if (data['amount']) { // data not null
          SplitAmount.validateJSON(data['amount']);
        }
        // ensure the json data is a string
        if (data['description'] && !(typeof data['description'] === 'string' || data['description'] instanceof String)) {
            throw new Error("Expected the field `description` to be a primitive type in the JSON string but got " + data['description']);
        }
        // ensure the json data is a string
        if (data['reference'] && !(typeof data['reference'] === 'string' || data['reference'] instanceof String)) {
            throw new Error("Expected the field `reference` to be a primitive type in the JSON string but got " + data['reference']);
        }
        // ensure the json data is a string
        if (data['type'] && !(typeof data['type'] === 'string' || data['type'] instanceof String)) {
            throw new Error("Expected the field `type` to be a primitive type in the JSON string but got " + data['type']);
        }

        return true;
    }


}

Split.RequiredProperties = ["amount", "type"];

/**
 * Unique identifier of the account where the split amount should be sent. This is required if `type` is **MarketPlace** or **BalanceAccount**.  
 * @member {String} account
 */
Split.prototype['account'] = undefined;

/**
 * The amount of this split.
 * @member {module:model/SplitAmount} amount
 */
Split.prototype['amount'] = undefined;

/**
 * A description of this split.
 * @member {String} description
 */
Split.prototype['description'] = undefined;

/**
 * Your reference for the split, which you can use to link the split to other operations such as captures and refunds.  This is required if `type` is **MarketPlace** or **BalanceAccount**. For the other types, we also recommend sending a reference so you can reconcile the split and the associated payment in the transaction overview and in the reports. If the reference is not provided, the split is reported as part of the aggregated [TransferBalance record type](https://docs.adyen.com/reporting/marketpay-payments-accounting-report) in Adyen for Platforms.
 * @member {String} reference
 */
Split.prototype['reference'] = undefined;

/**
 * The type of split. Possible values: **Default**, **PaymentFee**, **VAT**, **Commission**, **MarketPlace**, **BalanceAccount**, **Remainder**, **Surcharge**, **Tip**.
 * @member {module:model/Split.TypeEnum} type
 */
Split.prototype['type'] = undefined;





/**
 * Allowed values for the <code>type</code> property.
 * @enum {String}
 * @readonly
 */
Split['TypeEnum'] = {

    /**
     * value: "BalanceAccount"
     * @const
     */
    "BalanceAccount": "BalanceAccount",

    /**
     * value: "Commission"
     * @const
     */
    "Commission": "Commission",

    /**
     * value: "Default"
     * @const
     */
    "Default": "Default",

    /**
     * value: "MarketPlace"
     * @const
     */
    "MarketPlace": "MarketPlace",

    /**
     * value: "PaymentFee"
     * @const
     */
    "PaymentFee": "PaymentFee",

    /**
     * value: "PaymentFeeAcquiring"
     * @const
     */
    "PaymentFeeAcquiring": "PaymentFeeAcquiring",

    /**
     * value: "PaymentFeeAdyen"
     * @const
     */
    "PaymentFeeAdyen": "PaymentFeeAdyen",

    /**
     * value: "PaymentFeeAdyenCommission"
     * @const
     */
    "PaymentFeeAdyenCommission": "PaymentFeeAdyenCommission",

    /**
     * value: "PaymentFeeAdyenMarkup"
     * @const
     */
    "PaymentFeeAdyenMarkup": "PaymentFeeAdyenMarkup",

    /**
     * value: "PaymentFeeInterchange"
     * @const
     */
    "PaymentFeeInterchange": "PaymentFeeInterchange",

    /**
     * value: "PaymentFeeSchemeFee"
     * @const
     */
    "PaymentFeeSchemeFee": "PaymentFeeSchemeFee",

    /**
     * value: "Remainder"
     * @const
     */
    "Remainder": "Remainder",

    /**
     * value: "Surcharge"
     * @const
     */
    "Surcharge": "Surcharge",

    /**
     * value: "Tip"
     * @const
     */
    "Tip": "Tip",

    /**
     * value: "VAT"
     * @const
     */
    "VAT": "VAT",

    /**
     * value: "Verification"
     * @const
     */
    "Verification": "Verification"
};



export default Split;

