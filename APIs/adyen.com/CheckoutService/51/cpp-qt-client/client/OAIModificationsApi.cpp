/**
 * Adyen Checkout API
 * Adyen Checkout API provides a simple and flexible way to initiate and authorise online payments. You can use the same integration for payments made with cards (including 3D Secure), mobile wallets, and local payment methods (for example, iDEAL and Sofort).  This API reference provides information on available endpoints and how to interact with them. To learn more about the API, visit [online payments documentation](https://docs.adyen.com/online-payments).  ## Authentication Each request to Checkout API must be signed with an API key. For this, [get your API key](https://docs.adyen.com/development-resources/api-credentials#generate-api-key) from your Customer Area, and set this key to the `X-API-Key` header value, for example:  ``` curl -H \"Content-Type: application/json\" \\ -H \"X-API-Key: YOUR_API_KEY\" \\ ... ``` ## Versioning Checkout API supports [versioning](https://docs.adyen.com/development-resources/versioning) using a version suffix in the endpoint URL. This suffix has the following format: \"vXX\", where XX is the version number.  For example: ``` https://checkout-test.adyen.com/v51/payments ```  ## Going live  To access the live endpoints, you need an API key from your live Customer Area.  The live endpoint URLs contain a prefix which is unique to your company account, for example: ``` https://{PREFIX}-checkout-live.adyenpayments.com/checkout/v51/payments ```  Get your `{PREFIX}` from your live Customer Area under **Developers** > **API URLs** > **Prefix**.  When preparing to do live transactions with Checkout API, follow the [go-live checklist](https://docs.adyen.com/online-payments/go-live-checklist) to make sure you've got all the required configuration in place.  ## Release notes Have a look at the [release notes](https://docs.adyen.com/online-payments/release-notes?integration_type=api&version=51) to find out what changed in this version!
 *
 * The version of the OpenAPI document: 51
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIModificationsApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIModificationsApi::OAIModificationsApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIModificationsApi::~OAIModificationsApi() {
}

void OAIModificationsApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://checkout-test.adyen.com/v51"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("postCancels", defaultConf);
    _serverIndices.insert("postCancels", 0);
    _serverConfigs.insert("postPaymentsPaymentPspReferenceAmountUpdates", defaultConf);
    _serverIndices.insert("postPaymentsPaymentPspReferenceAmountUpdates", 0);
    _serverConfigs.insert("postPaymentsPaymentPspReferenceCancels", defaultConf);
    _serverIndices.insert("postPaymentsPaymentPspReferenceCancels", 0);
    _serverConfigs.insert("postPaymentsPaymentPspReferenceCaptures", defaultConf);
    _serverIndices.insert("postPaymentsPaymentPspReferenceCaptures", 0);
    _serverConfigs.insert("postPaymentsPaymentPspReferenceRefunds", defaultConf);
    _serverIndices.insert("postPaymentsPaymentPspReferenceRefunds", 0);
    _serverConfigs.insert("postPaymentsPaymentPspReferenceReversals", defaultConf);
    _serverIndices.insert("postPaymentsPaymentPspReferenceReversals", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIModificationsApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIModificationsApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIModificationsApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIModificationsApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIModificationsApi::setUsername(const QString &username) {
    _username = username;
}

void OAIModificationsApi::setPassword(const QString &password) {
    _password = password;
}


void OAIModificationsApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIModificationsApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIModificationsApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIModificationsApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIModificationsApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIModificationsApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIModificationsApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIModificationsApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIModificationsApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIModificationsApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIModificationsApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIModificationsApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIModificationsApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIModificationsApi::postCancels(const ::OpenAPI::OptionalParam<QString> &idempotency_key, const ::OpenAPI::OptionalParam<OAIStandalonePaymentCancelRequest> &oai_standalone_payment_cancel_request) {
    QString fullPath = QString(_serverConfigs["postCancels"][_serverIndices.value("postCancels")].URL()+"/cancels");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    if (_apiKeys.contains("ApiKeyAuth")) {
        addHeaders("ApiKeyAuth",_apiKeys.find("ApiKeyAuth").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_standalone_payment_cancel_request.hasValue()){

        
        QByteArray output = oai_standalone_payment_cancel_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("Idempotency-Key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIModificationsApi::postCancelsCallback);
    connect(this, &OAIModificationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIModificationsApi::postCancelsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStandalonePaymentCancelResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postCancelsSignal(output);
        Q_EMIT postCancelsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postCancelsSignalE(output, error_type, error_str);
        Q_EMIT postCancelsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postCancelsSignalError(output, error_type, error_str);
        Q_EMIT postCancelsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceAmountUpdates(const QString &payment_psp_reference, const ::OpenAPI::OptionalParam<QString> &idempotency_key, const ::OpenAPI::OptionalParam<OAIPaymentAmountUpdateRequest> &oai_payment_amount_update_request) {
    QString fullPath = QString(_serverConfigs["postPaymentsPaymentPspReferenceAmountUpdates"][_serverIndices.value("postPaymentsPaymentPspReferenceAmountUpdates")].URL()+"/payments/{paymentPspReference}/amountUpdates");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    if (_apiKeys.contains("ApiKeyAuth")) {
        addHeaders("ApiKeyAuth",_apiKeys.find("ApiKeyAuth").value());
    }
    
    
    {
        QString payment_psp_referencePathParam("{");
        payment_psp_referencePathParam.append("paymentPspReference").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "paymentPspReference", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"paymentPspReference"+pathSuffix : pathPrefix;
        fullPath.replace(payment_psp_referencePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(payment_psp_reference)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_payment_amount_update_request.hasValue()){

        
        QByteArray output = oai_payment_amount_update_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("Idempotency-Key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIModificationsApi::postPaymentsPaymentPspReferenceAmountUpdatesCallback);
    connect(this, &OAIModificationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceAmountUpdatesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentAmountUpdateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postPaymentsPaymentPspReferenceAmountUpdatesSignal(output);
        Q_EMIT postPaymentsPaymentPspReferenceAmountUpdatesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postPaymentsPaymentPspReferenceAmountUpdatesSignalE(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceAmountUpdatesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postPaymentsPaymentPspReferenceAmountUpdatesSignalError(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceAmountUpdatesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceCancels(const QString &payment_psp_reference, const ::OpenAPI::OptionalParam<QString> &idempotency_key, const ::OpenAPI::OptionalParam<OAIPaymentCancelRequest> &oai_payment_cancel_request) {
    QString fullPath = QString(_serverConfigs["postPaymentsPaymentPspReferenceCancels"][_serverIndices.value("postPaymentsPaymentPspReferenceCancels")].URL()+"/payments/{paymentPspReference}/cancels");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    if (_apiKeys.contains("ApiKeyAuth")) {
        addHeaders("ApiKeyAuth",_apiKeys.find("ApiKeyAuth").value());
    }
    
    
    {
        QString payment_psp_referencePathParam("{");
        payment_psp_referencePathParam.append("paymentPspReference").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "paymentPspReference", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"paymentPspReference"+pathSuffix : pathPrefix;
        fullPath.replace(payment_psp_referencePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(payment_psp_reference)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_payment_cancel_request.hasValue()){

        
        QByteArray output = oai_payment_cancel_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("Idempotency-Key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIModificationsApi::postPaymentsPaymentPspReferenceCancelsCallback);
    connect(this, &OAIModificationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceCancelsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentCancelResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postPaymentsPaymentPspReferenceCancelsSignal(output);
        Q_EMIT postPaymentsPaymentPspReferenceCancelsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postPaymentsPaymentPspReferenceCancelsSignalE(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceCancelsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postPaymentsPaymentPspReferenceCancelsSignalError(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceCancelsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceCaptures(const QString &payment_psp_reference, const ::OpenAPI::OptionalParam<QString> &idempotency_key, const ::OpenAPI::OptionalParam<OAIPaymentCaptureRequest> &oai_payment_capture_request) {
    QString fullPath = QString(_serverConfigs["postPaymentsPaymentPspReferenceCaptures"][_serverIndices.value("postPaymentsPaymentPspReferenceCaptures")].URL()+"/payments/{paymentPspReference}/captures");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    if (_apiKeys.contains("ApiKeyAuth")) {
        addHeaders("ApiKeyAuth",_apiKeys.find("ApiKeyAuth").value());
    }
    
    
    {
        QString payment_psp_referencePathParam("{");
        payment_psp_referencePathParam.append("paymentPspReference").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "paymentPspReference", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"paymentPspReference"+pathSuffix : pathPrefix;
        fullPath.replace(payment_psp_referencePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(payment_psp_reference)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_payment_capture_request.hasValue()){

        
        QByteArray output = oai_payment_capture_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("Idempotency-Key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIModificationsApi::postPaymentsPaymentPspReferenceCapturesCallback);
    connect(this, &OAIModificationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceCapturesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentCaptureResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postPaymentsPaymentPspReferenceCapturesSignal(output);
        Q_EMIT postPaymentsPaymentPspReferenceCapturesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postPaymentsPaymentPspReferenceCapturesSignalE(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceCapturesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postPaymentsPaymentPspReferenceCapturesSignalError(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceCapturesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceRefunds(const QString &payment_psp_reference, const ::OpenAPI::OptionalParam<QString> &idempotency_key, const ::OpenAPI::OptionalParam<OAIPaymentRefundRequest> &oai_payment_refund_request) {
    QString fullPath = QString(_serverConfigs["postPaymentsPaymentPspReferenceRefunds"][_serverIndices.value("postPaymentsPaymentPspReferenceRefunds")].URL()+"/payments/{paymentPspReference}/refunds");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    if (_apiKeys.contains("ApiKeyAuth")) {
        addHeaders("ApiKeyAuth",_apiKeys.find("ApiKeyAuth").value());
    }
    
    
    {
        QString payment_psp_referencePathParam("{");
        payment_psp_referencePathParam.append("paymentPspReference").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "paymentPspReference", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"paymentPspReference"+pathSuffix : pathPrefix;
        fullPath.replace(payment_psp_referencePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(payment_psp_reference)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_payment_refund_request.hasValue()){

        
        QByteArray output = oai_payment_refund_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("Idempotency-Key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIModificationsApi::postPaymentsPaymentPspReferenceRefundsCallback);
    connect(this, &OAIModificationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceRefundsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentRefundResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postPaymentsPaymentPspReferenceRefundsSignal(output);
        Q_EMIT postPaymentsPaymentPspReferenceRefundsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postPaymentsPaymentPspReferenceRefundsSignalE(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceRefundsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postPaymentsPaymentPspReferenceRefundsSignalError(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceRefundsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceReversals(const QString &payment_psp_reference, const ::OpenAPI::OptionalParam<QString> &idempotency_key, const ::OpenAPI::OptionalParam<OAIPaymentReversalRequest> &oai_payment_reversal_request) {
    QString fullPath = QString(_serverConfigs["postPaymentsPaymentPspReferenceReversals"][_serverIndices.value("postPaymentsPaymentPspReferenceReversals")].URL()+"/payments/{paymentPspReference}/reversals");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    if (_apiKeys.contains("ApiKeyAuth")) {
        addHeaders("ApiKeyAuth",_apiKeys.find("ApiKeyAuth").value());
    }
    
    
    {
        QString payment_psp_referencePathParam("{");
        payment_psp_referencePathParam.append("paymentPspReference").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "paymentPspReference", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"paymentPspReference"+pathSuffix : pathPrefix;
        fullPath.replace(payment_psp_referencePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(payment_psp_reference)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_payment_reversal_request.hasValue()){

        
        QByteArray output = oai_payment_reversal_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("Idempotency-Key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIModificationsApi::postPaymentsPaymentPspReferenceReversalsCallback);
    connect(this, &OAIModificationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIModificationsApi::postPaymentsPaymentPspReferenceReversalsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentReversalResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postPaymentsPaymentPspReferenceReversalsSignal(output);
        Q_EMIT postPaymentsPaymentPspReferenceReversalsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postPaymentsPaymentPspReferenceReversalsSignalE(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceReversalsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postPaymentsPaymentPspReferenceReversalsSignalError(output, error_type, error_str);
        Q_EMIT postPaymentsPaymentPspReferenceReversalsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIModificationsApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
