/*
 * Subscriptions API (v3)
 *   A **Subscription** is a list of items (SKUs) tied to certain recurring purchase settings:    - User profile  - Address  - Payment method  - Frequency  - Cycle    Once you have [configured subscriptions](https://help.vtex.com/tutorial/how-to-configure-subscriptions%20--1FA9dfE7vJqxBna9Nft5Sj) in your store, the Subscriptions API allows you to create, manage and monitor your customers' subscriptions.    ![image](https://user-images.githubusercontent.com/77292838/213024675-9407863b-0c55-4282-9442-306352716abe.png)    To read more about the Subscriptions feature, check our article [How Subscription works](https://help.vtex.com/tutorial/how-subscriptions-work--frequentlyAskedQuestions_4453).
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Subscriptions settings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:55:48.114297-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Settings {
  public static final String SERIALIZED_NAME_DEFAULT_SLA = "defaultSla";
  @SerializedName(SERIALIZED_NAME_DEFAULT_SLA)
  private String defaultSla;

  public static final String SERIALIZED_NAME_DELIVERY_CHANNELS = "deliveryChannels";
  @SerializedName(SERIALIZED_NAME_DELIVERY_CHANNELS)
  private List<String> deliveryChannels = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXECUTION_HOUR_IN_UTC = "executionHourInUtc";
  @SerializedName(SERIALIZED_NAME_EXECUTION_HOUR_IN_UTC)
  private Integer executionHourInUtc = 0;

  public static final String SERIALIZED_NAME_IS_MULTIPLE_INSTALLMENTS_ENABLED_ON_CREATION = "isMultipleInstallmentsEnabledOnCreation";
  @SerializedName(SERIALIZED_NAME_IS_MULTIPLE_INSTALLMENTS_ENABLED_ON_CREATION)
  private Boolean isMultipleInstallmentsEnabledOnCreation = false;

  public static final String SERIALIZED_NAME_IS_MULTIPLE_INSTALLMENTS_ENABLED_ON_UPDATE = "isMultipleInstallmentsEnabledOnUpdate";
  @SerializedName(SERIALIZED_NAME_IS_MULTIPLE_INSTALLMENTS_ENABLED_ON_UPDATE)
  private Boolean isMultipleInstallmentsEnabledOnUpdate = false;

  public static final String SERIALIZED_NAME_IS_USING_V3 = "isUsingV3";
  @SerializedName(SERIALIZED_NAME_IS_USING_V3)
  private Boolean isUsingV3 = false;

  public static final String SERIALIZED_NAME_MANUAL_PRICE_ALLOWED = "manualPriceAllowed";
  @SerializedName(SERIALIZED_NAME_MANUAL_PRICE_ALLOWED)
  private Boolean manualPriceAllowed = false;

  public static final String SERIALIZED_NAME_ON_MIGRATION_PROCESS = "onMigrationProcess";
  @SerializedName(SERIALIZED_NAME_ON_MIGRATION_PROCESS)
  private Boolean onMigrationProcess = false;

  public static final String SERIALIZED_NAME_ORDER_CUSTOM_DATA_APP_ID = "orderCustomDataAppId";
  @SerializedName(SERIALIZED_NAME_ORDER_CUSTOM_DATA_APP_ID)
  private String orderCustomDataAppId;

  public static final String SERIALIZED_NAME_POSTPONE_EXPIRATION = "postponeExpiration";
  @SerializedName(SERIALIZED_NAME_POSTPONE_EXPIRATION)
  private Boolean postponeExpiration = false;

  public static final String SERIALIZED_NAME_RANDOM_ID_GENERATION = "randomIdGeneration";
  @SerializedName(SERIALIZED_NAME_RANDOM_ID_GENERATION)
  private Boolean randomIdGeneration = false;

  public static final String SERIALIZED_NAME_SLA_OPTION = "slaOption";
  @SerializedName(SERIALIZED_NAME_SLA_OPTION)
  private String slaOption = "";

  public static final String SERIALIZED_NAME_USE_ITEM_PRICE_FROM_ORIGINAL_ORDER = "useItemPriceFromOriginalOrder";
  @SerializedName(SERIALIZED_NAME_USE_ITEM_PRICE_FROM_ORIGINAL_ORDER)
  private Boolean useItemPriceFromOriginalOrder = false;

  public static final String SERIALIZED_NAME_WORKFLOW_VERSION = "workflowVersion";
  @SerializedName(SERIALIZED_NAME_WORKFLOW_VERSION)
  private String workflowVersion = "";

  public Settings() {
  }

  public Settings defaultSla(String defaultSla) {
    this.defaultSla = defaultSla;
    return this;
  }

  /**
   * Default delivery method.
   * @return defaultSla
   */
  @javax.annotation.Nullable
  public String getDefaultSla() {
    return defaultSla;
  }

  public void setDefaultSla(String defaultSla) {
    this.defaultSla = defaultSla;
  }


  public Settings deliveryChannels(List<String> deliveryChannels) {
    this.deliveryChannels = deliveryChannels;
    return this;
  }

  public Settings addDeliveryChannelsItem(String deliveryChannelsItem) {
    if (this.deliveryChannels == null) {
      this.deliveryChannels = new ArrayList<>();
    }
    this.deliveryChannels.add(deliveryChannelsItem);
    return this;
  }

  /**
   * Array containing delivery channels.
   * @return deliveryChannels
   */
  @javax.annotation.Nonnull
  public List<String> getDeliveryChannels() {
    return deliveryChannels;
  }

  public void setDeliveryChannels(List<String> deliveryChannels) {
    this.deliveryChannels = deliveryChannels;
  }


  public Settings executionHourInUtc(Integer executionHourInUtc) {
    this.executionHourInUtc = executionHourInUtc;
    return this;
  }

  /**
   * Indicates the time future subscription orders will be generated.
   * @return executionHourInUtc
   */
  @javax.annotation.Nonnull
  public Integer getExecutionHourInUtc() {
    return executionHourInUtc;
  }

  public void setExecutionHourInUtc(Integer executionHourInUtc) {
    this.executionHourInUtc = executionHourInUtc;
  }


  public Settings isMultipleInstallmentsEnabledOnCreation(Boolean isMultipleInstallmentsEnabledOnCreation) {
    this.isMultipleInstallmentsEnabledOnCreation = isMultipleInstallmentsEnabledOnCreation;
    return this;
  }

  /**
   * Defines whether or not multiple installments are enabled when a subscription is created.
   * @return isMultipleInstallmentsEnabledOnCreation
   */
  @javax.annotation.Nonnull
  public Boolean getIsMultipleInstallmentsEnabledOnCreation() {
    return isMultipleInstallmentsEnabledOnCreation;
  }

  public void setIsMultipleInstallmentsEnabledOnCreation(Boolean isMultipleInstallmentsEnabledOnCreation) {
    this.isMultipleInstallmentsEnabledOnCreation = isMultipleInstallmentsEnabledOnCreation;
  }


  public Settings isMultipleInstallmentsEnabledOnUpdate(Boolean isMultipleInstallmentsEnabledOnUpdate) {
    this.isMultipleInstallmentsEnabledOnUpdate = isMultipleInstallmentsEnabledOnUpdate;
    return this;
  }

  /**
   * Defines whether or not multiple installments are enabled when a subscription is updated.
   * @return isMultipleInstallmentsEnabledOnUpdate
   */
  @javax.annotation.Nonnull
  public Boolean getIsMultipleInstallmentsEnabledOnUpdate() {
    return isMultipleInstallmentsEnabledOnUpdate;
  }

  public void setIsMultipleInstallmentsEnabledOnUpdate(Boolean isMultipleInstallmentsEnabledOnUpdate) {
    this.isMultipleInstallmentsEnabledOnUpdate = isMultipleInstallmentsEnabledOnUpdate;
  }


  public Settings isUsingV3(Boolean isUsingV3) {
    this.isUsingV3 = isUsingV3;
    return this;
  }

  /**
   * Indicates whether or not Subscriptions V3 is enabled.
   * @return isUsingV3
   */
  @javax.annotation.Nonnull
  public Boolean getIsUsingV3() {
    return isUsingV3;
  }

  public void setIsUsingV3(Boolean isUsingV3) {
    this.isUsingV3 = isUsingV3;
  }


  public Settings manualPriceAllowed(Boolean manualPriceAllowed) {
    this.manualPriceAllowed = manualPriceAllowed;
    return this;
  }

  /**
   * When set to &#x60;true&#x60;, this property enables manual price configuration in subscription items. This is valid for all existing subscriptions, provided that there is a manual price configured and that &#x60;isUsingV3&#x60; is &#x60;true&#x60;.
   * @return manualPriceAllowed
   */
  @javax.annotation.Nonnull
  public Boolean getManualPriceAllowed() {
    return manualPriceAllowed;
  }

  public void setManualPriceAllowed(Boolean manualPriceAllowed) {
    this.manualPriceAllowed = manualPriceAllowed;
  }


  public Settings onMigrationProcess(Boolean onMigrationProcess) {
    this.onMigrationProcess = onMigrationProcess;
    return this;
  }

  /**
   * Indicates whether or not the account is in the migration process to Subscriptions V3.
   * @return onMigrationProcess
   */
  @javax.annotation.Nonnull
  public Boolean getOnMigrationProcess() {
    return onMigrationProcess;
  }

  public void setOnMigrationProcess(Boolean onMigrationProcess) {
    this.onMigrationProcess = onMigrationProcess;
  }


  public Settings orderCustomDataAppId(String orderCustomDataAppId) {
    this.orderCustomDataAppId = orderCustomDataAppId;
    return this;
  }

  /**
   * When filled, this field passes along the &#x60;customData&#x60; infomration in the order to the future recurrent subscription orders.
   * @return orderCustomDataAppId
   */
  @javax.annotation.Nonnull
  public String getOrderCustomDataAppId() {
    return orderCustomDataAppId;
  }

  public void setOrderCustomDataAppId(String orderCustomDataAppId) {
    this.orderCustomDataAppId = orderCustomDataAppId;
  }


  public Settings postponeExpiration(Boolean postponeExpiration) {
    this.postponeExpiration = postponeExpiration;
    return this;
  }

  /**
   * Defines whether or not the expiration of subscriptions can be postponed.
   * @return postponeExpiration
   */
  @javax.annotation.Nonnull
  public Boolean getPostponeExpiration() {
    return postponeExpiration;
  }

  public void setPostponeExpiration(Boolean postponeExpiration) {
    this.postponeExpiration = postponeExpiration;
  }


  public Settings randomIdGeneration(Boolean randomIdGeneration) {
    this.randomIdGeneration = randomIdGeneration;
    return this;
  }

  /**
   * Defines whether or not the subscription order IDs will be randomly generated.
   * @return randomIdGeneration
   */
  @javax.annotation.Nonnull
  public Boolean getRandomIdGeneration() {
    return randomIdGeneration;
  }

  public void setRandomIdGeneration(Boolean randomIdGeneration) {
    this.randomIdGeneration = randomIdGeneration;
  }


  public Settings slaOption(String slaOption) {
    this.slaOption = slaOption;
    return this;
  }

  /**
   * Delivery method.
   * @return slaOption
   */
  @javax.annotation.Nonnull
  public String getSlaOption() {
    return slaOption;
  }

  public void setSlaOption(String slaOption) {
    this.slaOption = slaOption;
  }


  public Settings useItemPriceFromOriginalOrder(Boolean useItemPriceFromOriginalOrder) {
    this.useItemPriceFromOriginalOrder = useItemPriceFromOriginalOrder;
    return this;
  }

  /**
   * When set to &#x60;true&#x60;, this property enables using the manual price for each item from the original subscription order. This is only valid for new subscriptions, created from the moment this configuration is enabled. For this to work, it is mandatory that the &#x60;manualPriceAllowed&#x60; property is set to &#x60;true&#x60; and that &#x60;isUsingV3&#x60; is &#x60;true&#x60;.
   * @return useItemPriceFromOriginalOrder
   */
  @javax.annotation.Nonnull
  public Boolean getUseItemPriceFromOriginalOrder() {
    return useItemPriceFromOriginalOrder;
  }

  public void setUseItemPriceFromOriginalOrder(Boolean useItemPriceFromOriginalOrder) {
    this.useItemPriceFromOriginalOrder = useItemPriceFromOriginalOrder;
  }


  public Settings workflowVersion(String workflowVersion) {
    this.workflowVersion = workflowVersion;
    return this;
  }

  /**
   * Workflow version.
   * @return workflowVersion
   */
  @javax.annotation.Nonnull
  public String getWorkflowVersion() {
    return workflowVersion;
  }

  public void setWorkflowVersion(String workflowVersion) {
    this.workflowVersion = workflowVersion;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Settings settings = (Settings) o;
    return Objects.equals(this.defaultSla, settings.defaultSla) &&
        Objects.equals(this.deliveryChannels, settings.deliveryChannels) &&
        Objects.equals(this.executionHourInUtc, settings.executionHourInUtc) &&
        Objects.equals(this.isMultipleInstallmentsEnabledOnCreation, settings.isMultipleInstallmentsEnabledOnCreation) &&
        Objects.equals(this.isMultipleInstallmentsEnabledOnUpdate, settings.isMultipleInstallmentsEnabledOnUpdate) &&
        Objects.equals(this.isUsingV3, settings.isUsingV3) &&
        Objects.equals(this.manualPriceAllowed, settings.manualPriceAllowed) &&
        Objects.equals(this.onMigrationProcess, settings.onMigrationProcess) &&
        Objects.equals(this.orderCustomDataAppId, settings.orderCustomDataAppId) &&
        Objects.equals(this.postponeExpiration, settings.postponeExpiration) &&
        Objects.equals(this.randomIdGeneration, settings.randomIdGeneration) &&
        Objects.equals(this.slaOption, settings.slaOption) &&
        Objects.equals(this.useItemPriceFromOriginalOrder, settings.useItemPriceFromOriginalOrder) &&
        Objects.equals(this.workflowVersion, settings.workflowVersion);
  }

  @Override
  public int hashCode() {
    return Objects.hash(defaultSla, deliveryChannels, executionHourInUtc, isMultipleInstallmentsEnabledOnCreation, isMultipleInstallmentsEnabledOnUpdate, isUsingV3, manualPriceAllowed, onMigrationProcess, orderCustomDataAppId, postponeExpiration, randomIdGeneration, slaOption, useItemPriceFromOriginalOrder, workflowVersion);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Settings {\n");
    sb.append("    defaultSla: ").append(toIndentedString(defaultSla)).append("\n");
    sb.append("    deliveryChannels: ").append(toIndentedString(deliveryChannels)).append("\n");
    sb.append("    executionHourInUtc: ").append(toIndentedString(executionHourInUtc)).append("\n");
    sb.append("    isMultipleInstallmentsEnabledOnCreation: ").append(toIndentedString(isMultipleInstallmentsEnabledOnCreation)).append("\n");
    sb.append("    isMultipleInstallmentsEnabledOnUpdate: ").append(toIndentedString(isMultipleInstallmentsEnabledOnUpdate)).append("\n");
    sb.append("    isUsingV3: ").append(toIndentedString(isUsingV3)).append("\n");
    sb.append("    manualPriceAllowed: ").append(toIndentedString(manualPriceAllowed)).append("\n");
    sb.append("    onMigrationProcess: ").append(toIndentedString(onMigrationProcess)).append("\n");
    sb.append("    orderCustomDataAppId: ").append(toIndentedString(orderCustomDataAppId)).append("\n");
    sb.append("    postponeExpiration: ").append(toIndentedString(postponeExpiration)).append("\n");
    sb.append("    randomIdGeneration: ").append(toIndentedString(randomIdGeneration)).append("\n");
    sb.append("    slaOption: ").append(toIndentedString(slaOption)).append("\n");
    sb.append("    useItemPriceFromOriginalOrder: ").append(toIndentedString(useItemPriceFromOriginalOrder)).append("\n");
    sb.append("    workflowVersion: ").append(toIndentedString(workflowVersion)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("defaultSla");
    openapiFields.add("deliveryChannels");
    openapiFields.add("executionHourInUtc");
    openapiFields.add("isMultipleInstallmentsEnabledOnCreation");
    openapiFields.add("isMultipleInstallmentsEnabledOnUpdate");
    openapiFields.add("isUsingV3");
    openapiFields.add("manualPriceAllowed");
    openapiFields.add("onMigrationProcess");
    openapiFields.add("orderCustomDataAppId");
    openapiFields.add("postponeExpiration");
    openapiFields.add("randomIdGeneration");
    openapiFields.add("slaOption");
    openapiFields.add("useItemPriceFromOriginalOrder");
    openapiFields.add("workflowVersion");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("defaultSla");
    openapiRequiredFields.add("deliveryChannels");
    openapiRequiredFields.add("executionHourInUtc");
    openapiRequiredFields.add("isMultipleInstallmentsEnabledOnCreation");
    openapiRequiredFields.add("isMultipleInstallmentsEnabledOnUpdate");
    openapiRequiredFields.add("isUsingV3");
    openapiRequiredFields.add("manualPriceAllowed");
    openapiRequiredFields.add("onMigrationProcess");
    openapiRequiredFields.add("orderCustomDataAppId");
    openapiRequiredFields.add("postponeExpiration");
    openapiRequiredFields.add("randomIdGeneration");
    openapiRequiredFields.add("slaOption");
    openapiRequiredFields.add("useItemPriceFromOriginalOrder");
    openapiRequiredFields.add("workflowVersion");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Settings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Settings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Settings is not found in the empty JSON string", Settings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Settings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Settings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Settings.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("defaultSla") != null && !jsonObj.get("defaultSla").isJsonNull()) && !jsonObj.get("defaultSla").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultSla` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultSla").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("deliveryChannels") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("deliveryChannels").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `deliveryChannels` to be an array in the JSON string but got `%s`", jsonObj.get("deliveryChannels").toString()));
      }
      if (!jsonObj.get("orderCustomDataAppId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `orderCustomDataAppId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("orderCustomDataAppId").toString()));
      }
      if (!jsonObj.get("slaOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `slaOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("slaOption").toString()));
      }
      if (!jsonObj.get("workflowVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workflowVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workflowVersion").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Settings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Settings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Settings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Settings.class));

       return (TypeAdapter<T>) new TypeAdapter<Settings>() {
           @Override
           public void write(JsonWriter out, Settings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Settings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Settings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Settings
   * @throws IOException if the JSON string is invalid with respect to Settings
   */
  public static Settings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Settings.class);
  }

  /**
   * Convert an instance of Settings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

