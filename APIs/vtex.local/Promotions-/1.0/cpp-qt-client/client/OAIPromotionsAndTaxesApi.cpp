/**
 * Promotions & Taxes API
 *   > Check the new [Promotions onboarding guide](https://developers.vtex.com/vtex-rest-api/docs/promotions-overview). We created this guide to improve the onboarding experience for developers at VTEX. It assembles all documentation on our Developer Portal about Promotions and is organized by focusing on the developer's journey.     The Promotions & Taxes API allows you to manage and retrieve all promotions, coupons and tax rules from your VTEX store.     ## Index     ### Coupons   `POST` [Create multiple coupons](https://developers.vtex.com/vtex-rest-api/reference/post_api-rnb-pvt-multiple-coupons)   `POST` [Create coupon](https://developers.vtex.com/vtex-rest-api/reference/post_api-rnb-pvt-coupon)   `GET` [Get coupon by coupon code](https://developers.vtex.com/vtex-rest-api/reference/getbycouponcode)   `GET` [Get archived coupon by coupon code](https://developers.vtex.com/vtex-rest-api/reference/getarchivedbycouponcode)   `POST` [Archive coupon by coupon code](https://developers.vtex.com/vtex-rest-api/reference/archivebycouponcode)   `POST` [Update coupon](https://developers.vtex.com/vtex-rest-api/reference/update)   `GET` [Get all coupons](https://developers.vtex.com/vtex-rest-api/reference/getall)   `POST` [Coupon Massive Generation](https://developers.vtex.com/vtex-rest-api/reference/massivegeneration)   `GET` [Get coupon usage](https://developers.vtex.com/vtex-rest-api/reference/getusage)   `POST` [Unarchive coupon by coupon code](https://developers.vtex.com/vtex-rest-api/reference/unarchivebycouponcode)     ### Promotions and Taxes   `GET` [Get All Promotions](https://developers.vtex.com/vtex-rest-api/reference/getallbenefits)   `GET` [Get All Taxes](https://developers.vtex.com/vtex-rest-api/reference/getalltaxes)   `GET` [Get Promotion or Tax By ID](https://developers.vtex.com/vtex-rest-api/reference/getcalculatorconfigurationbyid)   `POST` [Create or Update Promotion or Tax](https://developers.vtex.com/vtex-rest-api/reference/createorupdatecalculatorconfiguration)   `POST` [Create Multiple SKU Promotion](https://developers.vtex.com/vtex-rest-api/reference/post_api-rnb-pvt-import-calculatorconfiguration)   `PUT` [Update Multiple SKU Promotion](https://developers.vtex.com/vtex-rest-api/reference/put_api-rnb-pvt-import-calculatorconfiguration-promotionid)   `POST` [Archive Promotion or Tax](https://developers.vtex.com/vtex-rest-api/reference/archivepromotion-1)   `POST` [Unarchive Promotion or Tax](https://developers.vtex.com/vtex-rest-api/reference/unarchivepromotion-1)   `GET` [List archived Promotions](https://developers.vtex.com/vtex-rest-api/reference/getarchivedpromotions)   `GET` [List archived Taxes](https://developers.vtex.com/vtex-rest-api/reference/getarchivedtaxes)       ### Campaign Audiences   `GET` [Get campaign audience configuration](https://developers.vtex.com/vtex-rest-api/reference/getcampaignconfiguration)   `POST` [Create campaign audience](https://developers.vtex.com/vtex-rest-api/reference/setcampaignconfiguration)
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPromotionsAndTaxesApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIPromotionsAndTaxesApi::OAIPromotionsAndTaxesApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIPromotionsAndTaxesApi::~OAIPromotionsAndTaxesApi() {
}

void OAIPromotionsAndTaxesApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://vtex.local"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://{accountName}.{environment}.com.br"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"accountName", OAIServerVariable("Name of the VTEX account. Used as part of the URL","{accountName}",
    QSet<QString>{ {"{accountName}"} })},
    
    {"environment", OAIServerVariable("Environment to use. Used as part of the URL.","{environment}",
    QSet<QString>{ {"{environment}"} })}, }));
    
    _serverConfigs.insert("apiRnbPvtImportCalculatorConfigurationPost", defaultConf);
    _serverIndices.insert("apiRnbPvtImportCalculatorConfigurationPost", 0);
    _serverConfigs.insert("apiRnbPvtImportCalculatorConfigurationPromotionIdPut", defaultConf);
    _serverIndices.insert("apiRnbPvtImportCalculatorConfigurationPromotionIdPut", 0);
    _serverConfigs.insert("archivePromotion", defaultConf);
    _serverIndices.insert("archivePromotion", 0);
    _serverConfigs.insert("createOrUpdateCalculatorConfiguration", defaultConf);
    _serverIndices.insert("createOrUpdateCalculatorConfiguration", 0);
    _serverConfigs.insert("getAllBenefits", defaultConf);
    _serverIndices.insert("getAllBenefits", 0);
    _serverConfigs.insert("getAllTaxes", defaultConf);
    _serverIndices.insert("getAllTaxes", 0);
    _serverConfigs.insert("getArchivedPromotions", defaultConf);
    _serverIndices.insert("getArchivedPromotions", 0);
    _serverConfigs.insert("getArchivedTaxes", defaultConf);
    _serverIndices.insert("getArchivedTaxes", 0);
    _serverConfigs.insert("getCalculatorConfigurationById", defaultConf);
    _serverIndices.insert("getCalculatorConfigurationById", 0);
    _serverConfigs.insert("unarchivePromotion", defaultConf);
    _serverIndices.insert("unarchivePromotion", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIPromotionsAndTaxesApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIPromotionsAndTaxesApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIPromotionsAndTaxesApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIPromotionsAndTaxesApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIPromotionsAndTaxesApi::setUsername(const QString &username) {
    _username = username;
}

void OAIPromotionsAndTaxesApi::setPassword(const QString &password) {
    _password = password;
}


void OAIPromotionsAndTaxesApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIPromotionsAndTaxesApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIPromotionsAndTaxesApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIPromotionsAndTaxesApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIPromotionsAndTaxesApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIPromotionsAndTaxesApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIPromotionsAndTaxesApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIPromotionsAndTaxesApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIPromotionsAndTaxesApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIPromotionsAndTaxesApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIPromotionsAndTaxesApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIPromotionsAndTaxesApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIPromotionsAndTaxesApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIPromotionsAndTaxesApi::apiRnbPvtImportCalculatorConfigurationPost(const QString &content_type, const QString &accept, const QString &x_vtex_calculator_name, const QString &x_vtex_start_date, const QString &x_vtex_end_date, const bool &x_vtex_accumulate_with_manual_prices, const ::OpenAPI::OptionalParam<bool> &x_vtex_cumulative, const ::OpenAPI::OptionalParam<QString> &x_vtex_cluster_operator, const ::OpenAPI::OptionalParam<QString> &x_vtex_cluster_expression, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &body) {
    QString fullPath = QString(_serverConfigs["apiRnbPvtImportCalculatorConfigurationPost"][_serverIndices.value("apiRnbPvtImportCalculatorConfigurationPost")].URL()+"/api/rnb/pvt/import/calculatorConfiguration");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (body.hasValue()){

        input.headers.insert("Content-Type", "text/csv");
        QByteArray output = body.value().asByteArray();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_calculator_name).isEmpty()) {
            input.headers.insert("X-VTEX-calculator-name", ::OpenAPI::toStringValue(x_vtex_calculator_name));
        }
        }
    if (x_vtex_cumulative.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_vtex_cumulative.value()).isEmpty()) {
            input.headers.insert("X-VTEX-cumulative", ::OpenAPI::toStringValue(x_vtex_cumulative.value()));
        }
        }
    if (x_vtex_cluster_operator.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_vtex_cluster_operator.value()).isEmpty()) {
            input.headers.insert("X-VTEX-cluster-operator", ::OpenAPI::toStringValue(x_vtex_cluster_operator.value()));
        }
        }
    if (x_vtex_cluster_expression.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_vtex_cluster_expression.value()).isEmpty()) {
            input.headers.insert("X-VTEX-cluster-expression", ::OpenAPI::toStringValue(x_vtex_cluster_expression.value()));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_start_date).isEmpty()) {
            input.headers.insert("X-VTEX-start-date", ::OpenAPI::toStringValue(x_vtex_start_date));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_end_date).isEmpty()) {
            input.headers.insert("X-VTEX-end-date", ::OpenAPI::toStringValue(x_vtex_end_date));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_accumulate_with_manual_prices).isEmpty()) {
            input.headers.insert("X-VTEX-accumulate-with-manual-prices", ::OpenAPI::toStringValue(x_vtex_accumulate_with_manual_prices));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::apiRnbPvtImportCalculatorConfigurationPostCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::apiRnbPvtImportCalculatorConfigurationPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT apiRnbPvtImportCalculatorConfigurationPostSignal();
        Q_EMIT apiRnbPvtImportCalculatorConfigurationPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT apiRnbPvtImportCalculatorConfigurationPostSignalE(error_type, error_str);
        Q_EMIT apiRnbPvtImportCalculatorConfigurationPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT apiRnbPvtImportCalculatorConfigurationPostSignalError(error_type, error_str);
        Q_EMIT apiRnbPvtImportCalculatorConfigurationPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::apiRnbPvtImportCalculatorConfigurationPromotionIdPut(const QString &content_type, const QString &accept, const QString &x_vtex_calculator_name, const QString &x_vtex_start_date, const QString &x_vtex_end_date, const bool &x_vtex_accumulate_with_manual_prices, const QString &promotion_id, const ::OpenAPI::OptionalParam<bool> &x_vtex_cumulative, const ::OpenAPI::OptionalParam<QString> &x_vtex_cluster_operator, const ::OpenAPI::OptionalParam<QString> &x_vtex_cluster_expression, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &body) {
    QString fullPath = QString(_serverConfigs["apiRnbPvtImportCalculatorConfigurationPromotionIdPut"][_serverIndices.value("apiRnbPvtImportCalculatorConfigurationPromotionIdPut")].URL()+"/api/rnb/pvt/import/calculatorConfiguration/{promotionId}");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString promotion_idPathParam("{");
        promotion_idPathParam.append("promotionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "promotionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"promotionId"+pathSuffix : pathPrefix;
        fullPath.replace(promotion_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(promotion_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (body.hasValue()){

        input.headers.insert("Content-Type", "text/csv");
        QByteArray output = body.value().asByteArray();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_calculator_name).isEmpty()) {
            input.headers.insert("X-VTEX-calculator-name", ::OpenAPI::toStringValue(x_vtex_calculator_name));
        }
        }
    if (x_vtex_cumulative.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_vtex_cumulative.value()).isEmpty()) {
            input.headers.insert("X-VTEX-cumulative", ::OpenAPI::toStringValue(x_vtex_cumulative.value()));
        }
        }
    if (x_vtex_cluster_operator.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_vtex_cluster_operator.value()).isEmpty()) {
            input.headers.insert("X-VTEX-cluster-operator", ::OpenAPI::toStringValue(x_vtex_cluster_operator.value()));
        }
        }
    if (x_vtex_cluster_expression.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_vtex_cluster_expression.value()).isEmpty()) {
            input.headers.insert("X-VTEX-cluster-expression", ::OpenAPI::toStringValue(x_vtex_cluster_expression.value()));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_start_date).isEmpty()) {
            input.headers.insert("X-VTEX-start-date", ::OpenAPI::toStringValue(x_vtex_start_date));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_end_date).isEmpty()) {
            input.headers.insert("X-VTEX-end-date", ::OpenAPI::toStringValue(x_vtex_end_date));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_accumulate_with_manual_prices).isEmpty()) {
            input.headers.insert("X-VTEX-accumulate-with-manual-prices", ::OpenAPI::toStringValue(x_vtex_accumulate_with_manual_prices));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::apiRnbPvtImportCalculatorConfigurationPromotionIdPutCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::apiRnbPvtImportCalculatorConfigurationPromotionIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT apiRnbPvtImportCalculatorConfigurationPromotionIdPutSignal();
        Q_EMIT apiRnbPvtImportCalculatorConfigurationPromotionIdPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT apiRnbPvtImportCalculatorConfigurationPromotionIdPutSignalE(error_type, error_str);
        Q_EMIT apiRnbPvtImportCalculatorConfigurationPromotionIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT apiRnbPvtImportCalculatorConfigurationPromotionIdPutSignalError(error_type, error_str);
        Q_EMIT apiRnbPvtImportCalculatorConfigurationPromotionIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::archivePromotion(const QString &content_type, const QString &accept, const QString &id_calculator_configuration) {
    QString fullPath = QString(_serverConfigs["archivePromotion"][_serverIndices.value("archivePromotion")].URL()+"/api/rnb/pvt/archive/calculatorConfiguration/{idCalculatorConfiguration}");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString id_calculator_configurationPathParam("{");
        id_calculator_configurationPathParam.append("idCalculatorConfiguration").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "idCalculatorConfiguration", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"idCalculatorConfiguration"+pathSuffix : pathPrefix;
        fullPath.replace(id_calculator_configurationPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id_calculator_configuration)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::archivePromotionCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::archivePromotionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT archivePromotionSignal();
        Q_EMIT archivePromotionSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT archivePromotionSignalE(error_type, error_str);
        Q_EMIT archivePromotionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT archivePromotionSignalError(error_type, error_str);
        Q_EMIT archivePromotionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::createOrUpdateCalculatorConfiguration(const QString &content_type, const QString &accept, const OAICreateOrUpdateCalculatorConfiguration_request &oai_create_or_update_calculator_configuration_request) {
    QString fullPath = QString(_serverConfigs["createOrUpdateCalculatorConfiguration"][_serverIndices.value("createOrUpdateCalculatorConfiguration")].URL()+"/api/rnb/pvt/calculatorconfiguration");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_or_update_calculator_configuration_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::createOrUpdateCalculatorConfigurationCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::createOrUpdateCalculatorConfigurationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreateOrUpdateCalculatorConfiguration_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createOrUpdateCalculatorConfigurationSignal(output);
        Q_EMIT createOrUpdateCalculatorConfigurationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createOrUpdateCalculatorConfigurationSignalE(output, error_type, error_str);
        Q_EMIT createOrUpdateCalculatorConfigurationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createOrUpdateCalculatorConfigurationSignalError(output, error_type, error_str);
        Q_EMIT createOrUpdateCalculatorConfigurationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::getAllBenefits(const QString &content_type, const QString &accept) {
    QString fullPath = QString(_serverConfigs["getAllBenefits"][_serverIndices.value("getAllBenefits")].URL()+"/api/rnb/pvt/benefits/calculatorconfiguration");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::getAllBenefitsCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::getAllBenefitsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGetAllBenefits_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllBenefitsSignal(output);
        Q_EMIT getAllBenefitsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllBenefitsSignalE(output, error_type, error_str);
        Q_EMIT getAllBenefitsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllBenefitsSignalError(output, error_type, error_str);
        Q_EMIT getAllBenefitsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::getAllTaxes(const QString &content_type, const QString &accept) {
    QString fullPath = QString(_serverConfigs["getAllTaxes"][_serverIndices.value("getAllTaxes")].URL()+"/api/rnb/pvt/taxes/calculatorconfiguration");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::getAllTaxesCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::getAllTaxesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGetAllTaxes_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAllTaxesSignal(output);
        Q_EMIT getAllTaxesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAllTaxesSignalE(output, error_type, error_str);
        Q_EMIT getAllTaxesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAllTaxesSignalError(output, error_type, error_str);
        Q_EMIT getAllTaxesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::getArchivedPromotions(const QString &content_type, const QString &accept) {
    QString fullPath = QString(_serverConfigs["getArchivedPromotions"][_serverIndices.value("getArchivedPromotions")].URL()+"/api/rnb/pvt/archive/benefits/calculatorConfiguration");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::getArchivedPromotionsCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::getArchivedPromotionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGetArchivedPromotions_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getArchivedPromotionsSignal(output);
        Q_EMIT getArchivedPromotionsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getArchivedPromotionsSignalE(output, error_type, error_str);
        Q_EMIT getArchivedPromotionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getArchivedPromotionsSignalError(output, error_type, error_str);
        Q_EMIT getArchivedPromotionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::getArchivedTaxes(const QString &content_type, const QString &accept) {
    QString fullPath = QString(_serverConfigs["getArchivedTaxes"][_serverIndices.value("getArchivedTaxes")].URL()+"/api/rnb/pvt/archive/taxes/calculatorConfiguration");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::getArchivedTaxesCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::getArchivedTaxesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGetArchivedTaxes_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getArchivedTaxesSignal(output);
        Q_EMIT getArchivedTaxesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getArchivedTaxesSignalE(output, error_type, error_str);
        Q_EMIT getArchivedTaxesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getArchivedTaxesSignalError(output, error_type, error_str);
        Q_EMIT getArchivedTaxesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::getCalculatorConfigurationById(const QString &content_type, const QString &accept, const QString &id_calculator_configuration) {
    QString fullPath = QString(_serverConfigs["getCalculatorConfigurationById"][_serverIndices.value("getCalculatorConfigurationById")].URL()+"/api/rnb/pvt/calculatorconfiguration/{idCalculatorConfiguration}");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString id_calculator_configurationPathParam("{");
        id_calculator_configurationPathParam.append("idCalculatorConfiguration").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "idCalculatorConfiguration", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"idCalculatorConfiguration"+pathSuffix : pathPrefix;
        fullPath.replace(id_calculator_configurationPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id_calculator_configuration)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::getCalculatorConfigurationByIdCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::getCalculatorConfigurationByIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGetCalculatorConfigurationById_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getCalculatorConfigurationByIdSignal(output);
        Q_EMIT getCalculatorConfigurationByIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getCalculatorConfigurationByIdSignalE(output, error_type, error_str);
        Q_EMIT getCalculatorConfigurationByIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getCalculatorConfigurationByIdSignalError(output, error_type, error_str);
        Q_EMIT getCalculatorConfigurationByIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::unarchivePromotion(const QString &content_type, const QString &accept, const QString &id_calculator_configuration) {
    QString fullPath = QString(_serverConfigs["unarchivePromotion"][_serverIndices.value("unarchivePromotion")].URL()+"/api/rnb/pvt/unarchive/calculatorConfiguration/{idCalculatorConfiguration}");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString id_calculator_configurationPathParam("{");
        id_calculator_configurationPathParam.append("idCalculatorConfiguration").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "idCalculatorConfiguration", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"idCalculatorConfiguration"+pathSuffix : pathPrefix;
        fullPath.replace(id_calculator_configurationPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(id_calculator_configuration)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIPromotionsAndTaxesApi::unarchivePromotionCallback);
    connect(this, &OAIPromotionsAndTaxesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIPromotionsAndTaxesApi::unarchivePromotionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT unarchivePromotionSignal();
        Q_EMIT unarchivePromotionSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT unarchivePromotionSignalE(error_type, error_str);
        Q_EMIT unarchivePromotionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT unarchivePromotionSignalError(error_type, error_str);
        Q_EMIT unarchivePromotionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIPromotionsAndTaxesApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
