/**
 * Price Simulations API
 *   > Check the new [Pricing onboarding guide](https://developers.vtex.com/docs/guides/pricing-overview). We created this guide to improve the onboarding experience for developers at VTEX. It assembles all documentation on our Developer Portal about Pricing and is organized by focusing on the developer's journey    The Price Simulations API allows you to configure custom price selectors for B2B stores, based on the context set by the [Orders Configuration app](https://developers.vtex.com/docs/guides/vtex-order-configuration).    ## Custom Prices    In this section, you can create a specific shopping scenario with the criteria you want. For explaining purpose, we used the `orderType` and `state` as default values, but it can be others too.    `GET` [Get custom prices schema](https://developers.vtex.com/docs/api-reference/price-simulations#get-/_v/custom-prices/session/schema)  `POST` [Create or Update custom prices schema](https://developers.vtex.com/docs/api-reference/price-simulations#post-/_v/custom-prices/session/schema)    ## Session Management    Every time you edit a configuration value set on the Custom Prices session, you must use this endpoint to update the Order Configuration.    `POST` [Update Order Configuration](https://developers.vtex.com/docs/api-reference/price-simulations#post-/sessions/)      ## Price Association    Use these routes to associate a shopping scenario, created at the Custom Price session, to a specific price table.    `GET` [Get price association by ID](https://developers.vtex.com/docs/api-reference/price-simulations#get-/_v/custom-prices/rules/-priceAssociationId-)  `POST` [Create price association](https://developers.vtex.com/docs/api-reference/price-simulations#post-/_v/custom-prices/rules)  `PUT` [Update price association by ID](https://developers.vtex.com/docs/api-reference/price-simulations#put-/_v/custom-prices/rules/-priceAssociationId-)  `DELETE` [Disassociate price association by ID](https://developers.vtex.com/docs/api-reference/price-simulations#delete-/_v/custom-prices/rules/-priceAssociationId-)
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAICustomPricesApi_H
#define OAI_OAICustomPricesApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include "OAIRequest_body_1.h"
#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAICustomPricesApi : public QObject {
    Q_OBJECT

public:
    OAICustomPricesApi(const int timeOut = 0);
    ~OAICustomPricesApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);

    /**
    * @param[in]  content_type QString [required]
    * @param[in]  accept QString [required]
    */
    virtual void vCustomPricesSessionSchemaGet(const QString &content_type, const QString &accept);

    /**
    * @param[in]  content_type QString [required]
    * @param[in]  accept QString [required]
    * @param[in]  oai_request_body_1 OAIRequest_body_1 [optional]
    */
    virtual void vCustomPricesSessionSchemaPost(const QString &content_type, const QString &accept, const ::OpenAPI::OptionalParam<OAIRequest_body_1> &oai_request_body_1 = ::OpenAPI::OptionalParam<OAIRequest_body_1>());


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void vCustomPricesSessionSchemaGetCallback(OAIHttpRequestWorker *worker);
    void vCustomPricesSessionSchemaPostCallback(OAIHttpRequestWorker *worker);

Q_SIGNALS:

    void vCustomPricesSessionSchemaGetSignal(OAIRequest_body_1 summary);
    void vCustomPricesSessionSchemaPostSignal(OAIRequest_body_1 summary);


    void vCustomPricesSessionSchemaGetSignalFull(OAIHttpRequestWorker *worker, OAIRequest_body_1 summary);
    void vCustomPricesSessionSchemaPostSignalFull(OAIHttpRequestWorker *worker, OAIRequest_body_1 summary);

    Q_DECL_DEPRECATED_X("Use vCustomPricesSessionSchemaGetSignalError() instead")
    void vCustomPricesSessionSchemaGetSignalE(OAIRequest_body_1 summary, QNetworkReply::NetworkError error_type, QString error_str);
    void vCustomPricesSessionSchemaGetSignalError(OAIRequest_body_1 summary, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use vCustomPricesSessionSchemaPostSignalError() instead")
    void vCustomPricesSessionSchemaPostSignalE(OAIRequest_body_1 summary, QNetworkReply::NetworkError error_type, QString error_str);
    void vCustomPricesSessionSchemaPostSignalError(OAIRequest_body_1 summary, QNetworkReply::NetworkError error_type, const QString &error_str);

    Q_DECL_DEPRECATED_X("Use vCustomPricesSessionSchemaGetSignalErrorFull() instead")
    void vCustomPricesSessionSchemaGetSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void vCustomPricesSessionSchemaGetSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use vCustomPricesSessionSchemaPostSignalErrorFull() instead")
    void vCustomPricesSessionSchemaPostSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void vCustomPricesSessionSchemaPostSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public Q_SLOTS:
    void tokenAvailable();
};

} // namespace OpenAPI
#endif
