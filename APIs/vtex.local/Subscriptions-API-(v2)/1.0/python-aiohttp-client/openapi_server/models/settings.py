# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class Settings(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, default_sla: str=None, delivery_channels: List[str]=[], execution_hour_in_utc: int=0, is_multiple_installments_enabled_on_creation: bool=False, is_multiple_installments_enabled_on_update: bool=False, is_using_v3: bool=False, manual_price_allowed: bool=False, on_migration_process: bool=False, order_custom_data_app_id: str=None, postpone_expiration: bool=False, random_id_generation: bool=False, sla_option: str='', use_item_price_from_original_order: bool=False, workflow_version: str=''):
        """Settings - a model defined in OpenAPI

        :param default_sla: The default_sla of this Settings.
        :param delivery_channels: The delivery_channels of this Settings.
        :param execution_hour_in_utc: The execution_hour_in_utc of this Settings.
        :param is_multiple_installments_enabled_on_creation: The is_multiple_installments_enabled_on_creation of this Settings.
        :param is_multiple_installments_enabled_on_update: The is_multiple_installments_enabled_on_update of this Settings.
        :param is_using_v3: The is_using_v3 of this Settings.
        :param manual_price_allowed: The manual_price_allowed of this Settings.
        :param on_migration_process: The on_migration_process of this Settings.
        :param order_custom_data_app_id: The order_custom_data_app_id of this Settings.
        :param postpone_expiration: The postpone_expiration of this Settings.
        :param random_id_generation: The random_id_generation of this Settings.
        :param sla_option: The sla_option of this Settings.
        :param use_item_price_from_original_order: The use_item_price_from_original_order of this Settings.
        :param workflow_version: The workflow_version of this Settings.
        """
        self.openapi_types = {
            'default_sla': str,
            'delivery_channels': List[str],
            'execution_hour_in_utc': int,
            'is_multiple_installments_enabled_on_creation': bool,
            'is_multiple_installments_enabled_on_update': bool,
            'is_using_v3': bool,
            'manual_price_allowed': bool,
            'on_migration_process': bool,
            'order_custom_data_app_id': str,
            'postpone_expiration': bool,
            'random_id_generation': bool,
            'sla_option': str,
            'use_item_price_from_original_order': bool,
            'workflow_version': str
        }

        self.attribute_map = {
            'default_sla': 'defaultSla',
            'delivery_channels': 'deliveryChannels',
            'execution_hour_in_utc': 'executionHourInUtc',
            'is_multiple_installments_enabled_on_creation': 'isMultipleInstallmentsEnabledOnCreation',
            'is_multiple_installments_enabled_on_update': 'isMultipleInstallmentsEnabledOnUpdate',
            'is_using_v3': 'isUsingV3',
            'manual_price_allowed': 'manualPriceAllowed',
            'on_migration_process': 'onMigrationProcess',
            'order_custom_data_app_id': 'orderCustomDataAppId',
            'postpone_expiration': 'postponeExpiration',
            'random_id_generation': 'randomIdGeneration',
            'sla_option': 'slaOption',
            'use_item_price_from_original_order': 'useItemPriceFromOriginalOrder',
            'workflow_version': 'workflowVersion'
        }

        self._default_sla = default_sla
        self._delivery_channels = delivery_channels
        self._execution_hour_in_utc = execution_hour_in_utc
        self._is_multiple_installments_enabled_on_creation = is_multiple_installments_enabled_on_creation
        self._is_multiple_installments_enabled_on_update = is_multiple_installments_enabled_on_update
        self._is_using_v3 = is_using_v3
        self._manual_price_allowed = manual_price_allowed
        self._on_migration_process = on_migration_process
        self._order_custom_data_app_id = order_custom_data_app_id
        self._postpone_expiration = postpone_expiration
        self._random_id_generation = random_id_generation
        self._sla_option = sla_option
        self._use_item_price_from_original_order = use_item_price_from_original_order
        self._workflow_version = workflow_version

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Settings':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The settings of this Settings.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def default_sla(self):
        """Gets the default_sla of this Settings.

        Default delivery method.

        :return: The default_sla of this Settings.
        :rtype: str
        """
        return self._default_sla

    @default_sla.setter
    def default_sla(self, default_sla):
        """Sets the default_sla of this Settings.

        Default delivery method.

        :param default_sla: The default_sla of this Settings.
        :type default_sla: str
        """
        if default_sla is None:
            raise ValueError("Invalid value for `default_sla`, must not be `None`")

        self._default_sla = default_sla

    @property
    def delivery_channels(self):
        """Gets the delivery_channels of this Settings.

        Array containing delivery channels.

        :return: The delivery_channels of this Settings.
        :rtype: List[str]
        """
        return self._delivery_channels

    @delivery_channels.setter
    def delivery_channels(self, delivery_channels):
        """Sets the delivery_channels of this Settings.

        Array containing delivery channels.

        :param delivery_channels: The delivery_channels of this Settings.
        :type delivery_channels: List[str]
        """
        if delivery_channels is None:
            raise ValueError("Invalid value for `delivery_channels`, must not be `None`")

        self._delivery_channels = delivery_channels

    @property
    def execution_hour_in_utc(self):
        """Gets the execution_hour_in_utc of this Settings.

        Indicates the time future subscription orders will be generated.

        :return: The execution_hour_in_utc of this Settings.
        :rtype: int
        """
        return self._execution_hour_in_utc

    @execution_hour_in_utc.setter
    def execution_hour_in_utc(self, execution_hour_in_utc):
        """Sets the execution_hour_in_utc of this Settings.

        Indicates the time future subscription orders will be generated.

        :param execution_hour_in_utc: The execution_hour_in_utc of this Settings.
        :type execution_hour_in_utc: int
        """
        if execution_hour_in_utc is None:
            raise ValueError("Invalid value for `execution_hour_in_utc`, must not be `None`")

        self._execution_hour_in_utc = execution_hour_in_utc

    @property
    def is_multiple_installments_enabled_on_creation(self):
        """Gets the is_multiple_installments_enabled_on_creation of this Settings.

        Defines whether or not multiple installments are enabled when a subscription is created.

        :return: The is_multiple_installments_enabled_on_creation of this Settings.
        :rtype: bool
        """
        return self._is_multiple_installments_enabled_on_creation

    @is_multiple_installments_enabled_on_creation.setter
    def is_multiple_installments_enabled_on_creation(self, is_multiple_installments_enabled_on_creation):
        """Sets the is_multiple_installments_enabled_on_creation of this Settings.

        Defines whether or not multiple installments are enabled when a subscription is created.

        :param is_multiple_installments_enabled_on_creation: The is_multiple_installments_enabled_on_creation of this Settings.
        :type is_multiple_installments_enabled_on_creation: bool
        """
        if is_multiple_installments_enabled_on_creation is None:
            raise ValueError("Invalid value for `is_multiple_installments_enabled_on_creation`, must not be `None`")

        self._is_multiple_installments_enabled_on_creation = is_multiple_installments_enabled_on_creation

    @property
    def is_multiple_installments_enabled_on_update(self):
        """Gets the is_multiple_installments_enabled_on_update of this Settings.

        Defines whether or not multiple installments are enabled when a subscription is updated.

        :return: The is_multiple_installments_enabled_on_update of this Settings.
        :rtype: bool
        """
        return self._is_multiple_installments_enabled_on_update

    @is_multiple_installments_enabled_on_update.setter
    def is_multiple_installments_enabled_on_update(self, is_multiple_installments_enabled_on_update):
        """Sets the is_multiple_installments_enabled_on_update of this Settings.

        Defines whether or not multiple installments are enabled when a subscription is updated.

        :param is_multiple_installments_enabled_on_update: The is_multiple_installments_enabled_on_update of this Settings.
        :type is_multiple_installments_enabled_on_update: bool
        """
        if is_multiple_installments_enabled_on_update is None:
            raise ValueError("Invalid value for `is_multiple_installments_enabled_on_update`, must not be `None`")

        self._is_multiple_installments_enabled_on_update = is_multiple_installments_enabled_on_update

    @property
    def is_using_v3(self):
        """Gets the is_using_v3 of this Settings.

        Indicates whether or not Subscriptions V3 is enabled.

        :return: The is_using_v3 of this Settings.
        :rtype: bool
        """
        return self._is_using_v3

    @is_using_v3.setter
    def is_using_v3(self, is_using_v3):
        """Sets the is_using_v3 of this Settings.

        Indicates whether or not Subscriptions V3 is enabled.

        :param is_using_v3: The is_using_v3 of this Settings.
        :type is_using_v3: bool
        """
        if is_using_v3 is None:
            raise ValueError("Invalid value for `is_using_v3`, must not be `None`")

        self._is_using_v3 = is_using_v3

    @property
    def manual_price_allowed(self):
        """Gets the manual_price_allowed of this Settings.

        When set to `true`, this property enables manual price configuration in subscription items. This is valid for all existing subscriptions, provided that there is a manual price configured and that `isUsingV3` is `true`.

        :return: The manual_price_allowed of this Settings.
        :rtype: bool
        """
        return self._manual_price_allowed

    @manual_price_allowed.setter
    def manual_price_allowed(self, manual_price_allowed):
        """Sets the manual_price_allowed of this Settings.

        When set to `true`, this property enables manual price configuration in subscription items. This is valid for all existing subscriptions, provided that there is a manual price configured and that `isUsingV3` is `true`.

        :param manual_price_allowed: The manual_price_allowed of this Settings.
        :type manual_price_allowed: bool
        """
        if manual_price_allowed is None:
            raise ValueError("Invalid value for `manual_price_allowed`, must not be `None`")

        self._manual_price_allowed = manual_price_allowed

    @property
    def on_migration_process(self):
        """Gets the on_migration_process of this Settings.

        Indicates whether or not the account is in the migration process to Subscriptions V3.

        :return: The on_migration_process of this Settings.
        :rtype: bool
        """
        return self._on_migration_process

    @on_migration_process.setter
    def on_migration_process(self, on_migration_process):
        """Sets the on_migration_process of this Settings.

        Indicates whether or not the account is in the migration process to Subscriptions V3.

        :param on_migration_process: The on_migration_process of this Settings.
        :type on_migration_process: bool
        """
        if on_migration_process is None:
            raise ValueError("Invalid value for `on_migration_process`, must not be `None`")

        self._on_migration_process = on_migration_process

    @property
    def order_custom_data_app_id(self):
        """Gets the order_custom_data_app_id of this Settings.

        When filled, this field passes along the `customData` infomration in the order to the future recurrent subscription orders.

        :return: The order_custom_data_app_id of this Settings.
        :rtype: str
        """
        return self._order_custom_data_app_id

    @order_custom_data_app_id.setter
    def order_custom_data_app_id(self, order_custom_data_app_id):
        """Sets the order_custom_data_app_id of this Settings.

        When filled, this field passes along the `customData` infomration in the order to the future recurrent subscription orders.

        :param order_custom_data_app_id: The order_custom_data_app_id of this Settings.
        :type order_custom_data_app_id: str
        """
        if order_custom_data_app_id is None:
            raise ValueError("Invalid value for `order_custom_data_app_id`, must not be `None`")

        self._order_custom_data_app_id = order_custom_data_app_id

    @property
    def postpone_expiration(self):
        """Gets the postpone_expiration of this Settings.

        Defines whether or not the expiration of subscriptions can be postponed.

        :return: The postpone_expiration of this Settings.
        :rtype: bool
        """
        return self._postpone_expiration

    @postpone_expiration.setter
    def postpone_expiration(self, postpone_expiration):
        """Sets the postpone_expiration of this Settings.

        Defines whether or not the expiration of subscriptions can be postponed.

        :param postpone_expiration: The postpone_expiration of this Settings.
        :type postpone_expiration: bool
        """
        if postpone_expiration is None:
            raise ValueError("Invalid value for `postpone_expiration`, must not be `None`")

        self._postpone_expiration = postpone_expiration

    @property
    def random_id_generation(self):
        """Gets the random_id_generation of this Settings.

        Defines whether or not the subscription order IDs will be randomly generated.

        :return: The random_id_generation of this Settings.
        :rtype: bool
        """
        return self._random_id_generation

    @random_id_generation.setter
    def random_id_generation(self, random_id_generation):
        """Sets the random_id_generation of this Settings.

        Defines whether or not the subscription order IDs will be randomly generated.

        :param random_id_generation: The random_id_generation of this Settings.
        :type random_id_generation: bool
        """
        if random_id_generation is None:
            raise ValueError("Invalid value for `random_id_generation`, must not be `None`")

        self._random_id_generation = random_id_generation

    @property
    def sla_option(self):
        """Gets the sla_option of this Settings.

        Delivery method.

        :return: The sla_option of this Settings.
        :rtype: str
        """
        return self._sla_option

    @sla_option.setter
    def sla_option(self, sla_option):
        """Sets the sla_option of this Settings.

        Delivery method.

        :param sla_option: The sla_option of this Settings.
        :type sla_option: str
        """
        if sla_option is None:
            raise ValueError("Invalid value for `sla_option`, must not be `None`")

        self._sla_option = sla_option

    @property
    def use_item_price_from_original_order(self):
        """Gets the use_item_price_from_original_order of this Settings.

        When set to `true`, this property enables using the manual price for each item from the original subscription order. This is only valid for new subscriptions, created from the moment this configuration is enabled. For this to work, it is mandatory that the `manualPriceAllowed` property is set to `true` and that `isUsingV3` is `true`.

        :return: The use_item_price_from_original_order of this Settings.
        :rtype: bool
        """
        return self._use_item_price_from_original_order

    @use_item_price_from_original_order.setter
    def use_item_price_from_original_order(self, use_item_price_from_original_order):
        """Sets the use_item_price_from_original_order of this Settings.

        When set to `true`, this property enables using the manual price for each item from the original subscription order. This is only valid for new subscriptions, created from the moment this configuration is enabled. For this to work, it is mandatory that the `manualPriceAllowed` property is set to `true` and that `isUsingV3` is `true`.

        :param use_item_price_from_original_order: The use_item_price_from_original_order of this Settings.
        :type use_item_price_from_original_order: bool
        """
        if use_item_price_from_original_order is None:
            raise ValueError("Invalid value for `use_item_price_from_original_order`, must not be `None`")

        self._use_item_price_from_original_order = use_item_price_from_original_order

    @property
    def workflow_version(self):
        """Gets the workflow_version of this Settings.

        Workflow version.

        :return: The workflow_version of this Settings.
        :rtype: str
        """
        return self._workflow_version

    @workflow_version.setter
    def workflow_version(self, workflow_version):
        """Sets the workflow_version of this Settings.

        Workflow version.

        :param workflow_version: The workflow_version of this Settings.
        :type workflow_version: str
        """
        if workflow_version is None:
            raise ValueError("Invalid value for `workflow_version`, must not be `None`")

        self._workflow_version = workflow_version
