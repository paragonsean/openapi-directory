/**
 * Subscriptions API (v2 - DEPRECATED)
 * VTEX Subscriptions REST API Documentation  This documentation describes the available REST APIs for VTEX Subscription System.  With Subscriptions you can set up regularly scheduled deliveries.  All requests need authorization (VTEX Id authentication token or VTEX Appkey and Apptoken headers)
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPlan.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPlan::OAIPlan(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPlan::OAIPlan() {
    this->initializeModel();
}

OAIPlan::~OAIPlan() {}

void OAIPlan::initializeModel() {

    m_frequency_isSet = false;
    m_frequency_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_validity_isSet = false;
    m_validity_isValid = false;
}

void OAIPlan::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPlan::fromJsonObject(QJsonObject json) {

    m_frequency_isValid = ::OpenAPI::fromJsonValue(m_frequency, json[QString("frequency")]);
    m_frequency_isSet = !json[QString("frequency")].isNull() && m_frequency_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_validity_isValid = ::OpenAPI::fromJsonValue(m_validity, json[QString("validity")]);
    m_validity_isSet = !json[QString("validity")].isNull() && m_validity_isValid;
}

QString OAIPlan::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPlan::asJsonObject() const {
    QJsonObject obj;
    if (m_frequency.isSet()) {
        obj.insert(QString("frequency"), ::OpenAPI::toJsonValue(m_frequency));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_validity.isSet()) {
        obj.insert(QString("validity"), ::OpenAPI::toJsonValue(m_validity));
    }
    return obj;
}

OAIFrequency OAIPlan::getFrequency() const {
    return m_frequency;
}
void OAIPlan::setFrequency(const OAIFrequency &frequency) {
    m_frequency = frequency;
    m_frequency_isSet = true;
}

bool OAIPlan::is_frequency_Set() const{
    return m_frequency_isSet;
}

bool OAIPlan::is_frequency_Valid() const{
    return m_frequency_isValid;
}

QString OAIPlan::getType() const {
    return m_type;
}
void OAIPlan::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIPlan::is_type_Set() const{
    return m_type_isSet;
}

bool OAIPlan::is_type_Valid() const{
    return m_type_isValid;
}

OAIValidity OAIPlan::getValidity() const {
    return m_validity;
}
void OAIPlan::setValidity(const OAIValidity &validity) {
    m_validity = validity;
    m_validity_isSet = true;
}

bool OAIPlan::is_validity_Set() const{
    return m_validity_isSet;
}

bool OAIPlan::is_validity_Valid() const{
    return m_validity_isValid;
}

bool OAIPlan::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_frequency.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_validity.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPlan::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_frequency_isValid && m_type_isValid && m_validity_isValid && true;
}

} // namespace OpenAPI
