/**
 * Legacy Search API
 *   > Check the new [Search onboarding guide](https://developers.vtex.com/vtex-rest-api/docs/search-onboarding). We created this guide to improve the onboarding experience for developers at VTEX. It assembles all documentation on our Developer Portal about Search and is organized by focusing on the developer's journey.    This API lets you search and sort products in the Catalog using Fulltext, Category and Brand search terms.     Retrieve product data to create custom searches and product shelves.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import ProductSearchWhoBoughtAlsoBought200ResponseInner from '../model/ProductSearchWhoBoughtAlsoBought200ResponseInner';

/**
* Search service.
* @module api/SearchApi
* @version 1.0
*/
export default class SearchApi {

    /**
    * Constructs a new SearchApi. 
    * @alias module:api/SearchApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the productSearch operation.
     * @callback module:api/SearchApi~productSearchCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/ProductSearchWhoBoughtAlsoBought200ResponseInner>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Search for Products
     * Retrieves general information about the products related to the term searched.   This is the main search used by the store. The user can type anything to be searched.      For example, if they search for a \"decanter\", this is the URL: `https://{{accountName}}.{{environment}}.com.br/api/catalog_system/pub/products/search/decanter`.     Note that maybe the response can be HTTP 200 or 206, 206 means that it's a partial content response.    If it is a 206 take a look at the Headers, will be an entry called resources. E.g.: resources → 0-9/19. This means that the response is showing items from 0 to 9, 10 items, but there were 19 items found. See more information at the paging route example.
     * @param {String} accept HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.
     * @param {String} contentType Describes the type of the content being sent.
     * @param {String} search Term used to search products
     * @param {module:api/SearchApi~productSearchCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/ProductSearchWhoBoughtAlsoBought200ResponseInner>}
     */
    productSearch(accept, contentType, search, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'accept' is set
      if (accept === undefined || accept === null) {
        throw new Error("Missing the required parameter 'accept' when calling productSearch");
      }
      // verify the required parameter 'contentType' is set
      if (contentType === undefined || contentType === null) {
        throw new Error("Missing the required parameter 'contentType' when calling productSearch");
      }
      // verify the required parameter 'search' is set
      if (search === undefined || search === null) {
        throw new Error("Missing the required parameter 'search' when calling productSearch");
      }

      let pathParams = {
        'search': search
      };
      let queryParams = {
      };
      let headerParams = {
        'Accept': accept,
        'Content-Type': contentType
      };
      let formParams = {
      };

      let authNames = ['appToken', 'appKey'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [ProductSearchWhoBoughtAlsoBought200ResponseInner];
      let basePaths = ['http://example.com/.{environment}.com.br'];
      let basePath = basePaths[0]; // by default use the first one in "servers" defined in OpenAPI
      if (typeof opts['_base_path_index'] !== 'undefined') {
        if (opts['_base_path_index']  >= basePaths.length || opts['_base_path_index'] <  0) {
          throw new Error("Invalid index " + opts['_base_path_index'] + " when selecting the host settings. Must be less than " + basePaths.length);
        }
        basePath = basePaths[opts['_base_path_index']];
      }

      return this.apiClient.callApi(
        '/api/catalog_system/pub/products/search/{search}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, basePath, callback
      );
    }

    /**
     * Callback function to receive the result of the productSearchFilteredandOrdered operation.
     * @callback module:api/SearchApi~productSearchFilteredandOrderedCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/ProductSearchWhoBoughtAlsoBought200ResponseInner>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Search for Products with Filter, Order and Pagination
     * Retrieves general information about the store products. This information can be filtered and ordered by a number of options. It also can be paginated, filtered and ordered.     ## Filters      - **Filter by full text** - `ft={searchWord}`    E.g.: `ft=television`    - **Filter by category** - `fq=C:/{a}/{b}`    `{a}` and `{b}` are Category IDs     E.g.: `fq=C:/1000041/1000049/`    - **Filter by brand** - `fq=B:/{a}/{b}`    `{a}` and `{b}` are Brand IDs  E.g.: `fq=B:/189385/189387/`    - **Filter by specification** - `fq=specificationFilter_{a}:{b}`    `{a}` is the specification ID  `{b}` is the specification value  E.g.: To filter products where the color is Blue, find the specification ID for color. Suppose it is 123, then the query will be: `fq=specificationFilter_123:Blue`    - **Filter by price range** - `fq=P:[{a} TO {b}]`    `{a}`  is the minimum price \"from\"  `{b}` is the highest price \"to\"    E.g.: `fq=P:[0 TO 20]` will search products between 0.00 and 20.00.      - **Filter by collection** - `fq=productClusterIds:{{productClusterId}}`   `productClusterId` is the same as `collectionId`    For more information about collections, read [Creating a product collection](https://help.vtex.com/en/tutorial/creating-a-product-collection).    - **Filter by product ID** - `fq=productId:{{productId}}`    - **Filter by SKU ID** - `fq=skuId:{{skuId}}`    - **Filter by referenceId** - `fq=alternateIds_RefId:{{referenceId}}`    - **Filter by EAN13** - `fq=alternateIds_Ean:{{ean13}}`    - **Filter by availability at a specific sales channel** - `fq=isAvailablePerSalesChannel_{{sc}}:{{bool}}`    `{{sc}}` is the desired sales channel    `{{bool}}` is true ou false, 1 or 0.    E.g.: seaching available products for the sales channel 4 would be `fq=isAvailablePerSalesChannel_4:1`    - **Filter by available at a specific seller** - `fq=sellerId:{{sellerId}}`  The search does not include White Label Sellers.    ## Pagination    - **Initial item number** - `_from={{first}}`  - **Final item number** - `_to={{last}}`    >⚠️ This endpoint returns a maximum of 50 items per response, so the difference between `_from` and `_to` should not exceed this number. The result order is descending, from the highest product ID to the lowest.    ## Sorting    - **Price**    `O=OrderByPriceDESC`    `O=OrderByPriceASC`    - **Top Selling Products**    `O=OrderByTopSaleDESC`    - **Best Reviews**    `O=OrderByReviewRateDESC`    - **Name**    `O=OrderByNameASC`    `O=OrderByNameDESC`    - **Release Date**    `O=OrderByReleaseDateDESC`    - **Best Discounts**    `O=OrderByBestDiscountDESC`    - **Score**    `O=OrderByScoreDESC`
     * @param {String} accept HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.
     * @param {String} contentType Describes the type of the content being sent.
     * @param {Object} opts Optional parameters
     * @param {String} [from] Starter page range. These parameters allow the API to be paginated. Take into account that the initial and final pages cannot have a separation superior to 50 pages. Thus, it will be displayed 50 items per page.
     * @param {String} [to] Finisher page range. These parameters allow the API to be paginated. Take into account that the initial and final pages cannot have a separation superior to 50 pages. Thus, it will be displayed 50 items per page.
     * @param {String} [ft] Filter by full text. The form is`ft={searchWord}`
     * @param {String} [fq] General filter. It can be by category (`fq=C:/{a}/{b}`), by specification (`fq=specificationFilter_{a}:{b}`),  by price range (`fq=P:[{a} TO {b}]`), by collection (`fq=productClusterIds:{{productClusterId}}`), by product ID (`fq=productId:{{productId}}`),  by SKU ID (`fq=skuId:{{skuId}}`), by Reference ID (`fq=alternateIds_RefId:{{referenceId}}`), by EAN13 (`fq=alternateIds_Ean:{{ean13}}`), by availability at a specific sales channel (`fq=isAvailablePerSalesChannel_{{sc}}:{{bool}}`), by available at a specific seller (`fq=sellerId:{{sellerId}}`)
     * @param {String} [O] Sorting method. It can be by Price (`O=OrderByPriceDESC` or `O=OrderByPriceASC`), by Top Selling Products (`O=OrderByTopSaleDESC`), by Best Reviews (`O=OrderByReviewRateDESC`), by Name (`O=OrderByNameASC` or `O=OrderByNameDESC`), by Release Date (`O=OrderByReleaseDateDESC`), by Best Discounts (`O=OrderByBestDiscountDESC`), by Score (`O=OrderByScoreDESC`)
     * @param {module:api/SearchApi~productSearchFilteredandOrderedCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/ProductSearchWhoBoughtAlsoBought200ResponseInner>}
     */
    productSearchFilteredandOrdered(accept, contentType, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'accept' is set
      if (accept === undefined || accept === null) {
        throw new Error("Missing the required parameter 'accept' when calling productSearchFilteredandOrdered");
      }
      // verify the required parameter 'contentType' is set
      if (contentType === undefined || contentType === null) {
        throw new Error("Missing the required parameter 'contentType' when calling productSearchFilteredandOrdered");
      }

      let pathParams = {
      };
      let queryParams = {
        '_from': opts['from'],
        '_to': opts['to'],
        'ft': opts['ft'],
        'fq': opts['fq'],
        'O': opts['O']
      };
      let headerParams = {
        'Accept': accept,
        'Content-Type': contentType
      };
      let formParams = {
      };

      let authNames = ['appToken', 'appKey'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [ProductSearchWhoBoughtAlsoBought200ResponseInner];
      let basePaths = ['http://example.com/.{environment}.com.br'];
      let basePath = basePaths[0]; // by default use the first one in "servers" defined in OpenAPI
      if (typeof opts['_base_path_index'] !== 'undefined') {
        if (opts['_base_path_index']  >= basePaths.length || opts['_base_path_index'] <  0) {
          throw new Error("Invalid index " + opts['_base_path_index'] + " when selecting the host settings. Must be less than " + basePaths.length);
        }
        basePath = basePaths[opts['_base_path_index']];
      }

      return this.apiClient.callApi(
        '/api/catalog_system/pub/products/search', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, basePath, callback
      );
    }

    /**
     * Callback function to receive the result of the searchbyproducturl operation.
     * @callback module:api/SearchApi~searchbyproducturlCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/ProductSearchWhoBoughtAlsoBought200ResponseInner>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Search Product by Product URL
     * Retrieves general information about the product of the URL you searched for.
     * @param {String} accept HTTP Client Negotiation Accept Header. Indicates the types of responses the client can understand.
     * @param {String} contentType Describes the type of the content being sent.
     * @param {String} productTextLink Product URL
     * @param {module:api/SearchApi~searchbyproducturlCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/ProductSearchWhoBoughtAlsoBought200ResponseInner>}
     */
    searchbyproducturl(accept, contentType, productTextLink, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'accept' is set
      if (accept === undefined || accept === null) {
        throw new Error("Missing the required parameter 'accept' when calling searchbyproducturl");
      }
      // verify the required parameter 'contentType' is set
      if (contentType === undefined || contentType === null) {
        throw new Error("Missing the required parameter 'contentType' when calling searchbyproducturl");
      }
      // verify the required parameter 'productTextLink' is set
      if (productTextLink === undefined || productTextLink === null) {
        throw new Error("Missing the required parameter 'productTextLink' when calling searchbyproducturl");
      }

      let pathParams = {
        'product-text-link': productTextLink
      };
      let queryParams = {
      };
      let headerParams = {
        'Accept': accept,
        'Content-Type': contentType
      };
      let formParams = {
      };

      let authNames = ['appToken', 'appKey'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [ProductSearchWhoBoughtAlsoBought200ResponseInner];
      let basePaths = ['http://example.com/.{environment}.com.br'];
      let basePath = basePaths[0]; // by default use the first one in "servers" defined in OpenAPI
      if (typeof opts['_base_path_index'] !== 'undefined') {
        if (opts['_base_path_index']  >= basePaths.length || opts['_base_path_index'] <  0) {
          throw new Error("Invalid index " + opts['_base_path_index'] + " when selecting the host settings. Must be less than " + basePaths.length);
        }
        basePath = basePaths[opts['_base_path_index']];
      }

      return this.apiClient.callApi(
        '/api/catalog_system/pub/products/search/{product-text-link}/p', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, basePath, callback
      );
    }


}
