/**
 * GiftCard Hub API
 * >ℹ️ Check the new [Payments onboarding guide](https://developers.vtex.com/vtex-rest-api/docs/payments-overview). We created this guide to improve the onboarding experience for developers at VTEX. It assembles all documentation on our Developer Portal about Payments and is organized by focusing on the developer's journey.    The Gift Card Hub API allows interactions with all Gift Card providers registered to a store from a single point.    Gift Card providers are systems capable of providing cards to be used in the buying process.    The following is the sequence diagram that represents calls in the purchase closing process.  ![](https://cdn.jsdelivr.net/gh/vtexdocs/dev-portal-content@main/images/giftcard-hub-api-overview-0.png)    **Checkout + Gateway**: Systems responsible for the sale and for processing orders and payments.    **Gift Card Hub**: System responsible for managing multiple registered Gift Card providers for a store.    **Gift Card Provider**: System responsible for providing the Gift Cards available to the user not closing a purchase. This system can be implemented by third parties.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIProviderApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIProviderApi::OAIProviderApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIProviderApi::~OAIProviderApi() {
}

void OAIProviderApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://vtex.local"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://{accountName}.{environment}.com.br/api"),
    "VTEX server url",
    QMap<QString, OAIServerVariable>{ 
    {"accountName", OAIServerVariable("Name of the VTEX account. Used as part of the URL","{accountName}",
    QSet<QString>{ {"{accountName}"} })},
    
    {"environment", OAIServerVariable("Environment to use. Used as part of the URL.","{environment}",
    QSet<QString>{ {"{environment}"} })}, }));
    
    _serverConfigs.insert("create_UpdateGiftCardProviderbyID", defaultConf);
    _serverIndices.insert("create_UpdateGiftCardProviderbyID", 0);
    _serverConfigs.insert("deleteGiftCardProviderbyID", defaultConf);
    _serverIndices.insert("deleteGiftCardProviderbyID", 0);
    _serverConfigs.insert("getGiftCardProviderbyID", defaultConf);
    _serverIndices.insert("getGiftCardProviderbyID", 0);
    _serverConfigs.insert("listAllGiftCardProviders", defaultConf);
    _serverIndices.insert("listAllGiftCardProviders", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIProviderApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIProviderApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIProviderApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIProviderApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIProviderApi::setUsername(const QString &username) {
    _username = username;
}

void OAIProviderApi::setPassword(const QString &password) {
    _password = password;
}


void OAIProviderApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIProviderApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIProviderApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIProviderApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIProviderApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIProviderApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIProviderApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIProviderApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIProviderApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIProviderApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIProviderApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIProviderApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIProviderApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIProviderApi::create_UpdateGiftCardProviderbyID(const QString &accept, const QString &content_type, const QString &x_vtex_api_app_key, const QString &x_vtex_api_app_token, const QString &gift_card_provider_id, const OAICreateUpdateGiftCardProviderbyIDRequest &oai_create_update_gift_card_providerby_id_request) {
    QString fullPath = QString(_serverConfigs["create_UpdateGiftCardProviderbyID"][_serverIndices.value("create_UpdateGiftCardProviderbyID")].URL()+"/giftcardproviders/{giftCardProviderID}");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString gift_card_provider_idPathParam("{");
        gift_card_provider_idPathParam.append("giftCardProviderID").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "giftCardProviderID", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"giftCardProviderID"+pathSuffix : pathPrefix;
        fullPath.replace(gift_card_provider_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(gift_card_provider_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_create_update_gift_card_providerby_id_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_api_app_key).isEmpty()) {
            input.headers.insert("X-VTEX-API-AppKey", ::OpenAPI::toStringValue(x_vtex_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_api_app_token).isEmpty()) {
            input.headers.insert("X-VTEX-API-AppToken", ::OpenAPI::toStringValue(x_vtex_api_app_token));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIProviderApi::create_UpdateGiftCardProviderbyIDCallback);
    connect(this, &OAIProviderApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIProviderApi::create_UpdateGiftCardProviderbyIDCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT create_UpdateGiftCardProviderbyIDSignal(output);
        Q_EMIT create_UpdateGiftCardProviderbyIDSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT create_UpdateGiftCardProviderbyIDSignalE(output, error_type, error_str);
        Q_EMIT create_UpdateGiftCardProviderbyIDSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT create_UpdateGiftCardProviderbyIDSignalError(output, error_type, error_str);
        Q_EMIT create_UpdateGiftCardProviderbyIDSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIProviderApi::deleteGiftCardProviderbyID(const QString &accept, const QString &content_type, const QString &x_vtex_api_app_key, const QString &x_vtex_api_app_token, const QString &gift_card_provider_id) {
    QString fullPath = QString(_serverConfigs["deleteGiftCardProviderbyID"][_serverIndices.value("deleteGiftCardProviderbyID")].URL()+"/giftcardproviders/{giftCardProviderID}");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString gift_card_provider_idPathParam("{");
        gift_card_provider_idPathParam.append("giftCardProviderID").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "giftCardProviderID", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"giftCardProviderID"+pathSuffix : pathPrefix;
        fullPath.replace(gift_card_provider_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(gift_card_provider_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_api_app_key).isEmpty()) {
            input.headers.insert("X-VTEX-API-AppKey", ::OpenAPI::toStringValue(x_vtex_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_api_app_token).isEmpty()) {
            input.headers.insert("X-VTEX-API-AppToken", ::OpenAPI::toStringValue(x_vtex_api_app_token));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIProviderApi::deleteGiftCardProviderbyIDCallback);
    connect(this, &OAIProviderApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIProviderApi::deleteGiftCardProviderbyIDCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGiftCardProviderbyIDSignal(output);
        Q_EMIT deleteGiftCardProviderbyIDSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGiftCardProviderbyIDSignalE(output, error_type, error_str);
        Q_EMIT deleteGiftCardProviderbyIDSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGiftCardProviderbyIDSignalError(output, error_type, error_str);
        Q_EMIT deleteGiftCardProviderbyIDSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIProviderApi::getGiftCardProviderbyID(const QString &accept, const QString &content_type, const QString &x_vtex_api_app_key, const QString &x_vtex_api_app_token, const QString &gift_card_provider_id) {
    QString fullPath = QString(_serverConfigs["getGiftCardProviderbyID"][_serverIndices.value("getGiftCardProviderbyID")].URL()+"/giftcardproviders/{giftCardProviderId}");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString gift_card_provider_idPathParam("{");
        gift_card_provider_idPathParam.append("giftCardProviderId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "giftCardProviderId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"giftCardProviderId"+pathSuffix : pathPrefix;
        fullPath.replace(gift_card_provider_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(gift_card_provider_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_api_app_key).isEmpty()) {
            input.headers.insert("X-VTEX-API-AppKey", ::OpenAPI::toStringValue(x_vtex_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_api_app_token).isEmpty()) {
            input.headers.insert("X-VTEX-API-AppToken", ::OpenAPI::toStringValue(x_vtex_api_app_token));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIProviderApi::getGiftCardProviderbyIDCallback);
    connect(this, &OAIProviderApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIProviderApi::getGiftCardProviderbyIDCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGiftCardProviderbyIDSignal(output);
        Q_EMIT getGiftCardProviderbyIDSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGiftCardProviderbyIDSignalE(output, error_type, error_str);
        Q_EMIT getGiftCardProviderbyIDSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGiftCardProviderbyIDSignalError(output, error_type, error_str);
        Q_EMIT getGiftCardProviderbyIDSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIProviderApi::listAllGiftCardProviders(const QString &accept, const QString &content_type, const QString &x_vtex_api_app_key, const QString &x_vtex_api_app_token, const ::OpenAPI::OptionalParam<QString> &rest_range) {
    QString fullPath = QString(_serverConfigs["listAllGiftCardProviders"][_serverIndices.value("listAllGiftCardProviders")].URL()+"/giftcardproviders");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    if (rest_range.hasValue())
    {
        if (!::OpenAPI::toStringValue(rest_range.value()).isEmpty()) {
            input.headers.insert("REST-Range", ::OpenAPI::toStringValue(rest_range.value()));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_api_app_key).isEmpty()) {
            input.headers.insert("X-VTEX-API-AppKey", ::OpenAPI::toStringValue(x_vtex_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_vtex_api_app_token).isEmpty()) {
            input.headers.insert("X-VTEX-API-AppToken", ::OpenAPI::toStringValue(x_vtex_api_app_token));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIProviderApi::listAllGiftCardProvidersCallback);
    connect(this, &OAIProviderApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIProviderApi::listAllGiftCardProvidersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listAllGiftCardProvidersSignal(output);
        Q_EMIT listAllGiftCardProvidersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listAllGiftCardProvidersSignalE(output, error_type, error_str);
        Q_EMIT listAllGiftCardProvidersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listAllGiftCardProvidersSignalError(output, error_type, error_str);
        Q_EMIT listAllGiftCardProvidersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIProviderApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
