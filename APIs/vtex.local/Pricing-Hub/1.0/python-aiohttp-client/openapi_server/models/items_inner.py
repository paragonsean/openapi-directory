# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class ItemsInner(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, brand_id: str='2000000', categories_ids: List[str]=["1"], index: int=0, price_table_ids: List[str]=["1"], quantity: int=1, seller_id: str='1', sku_id: str='13'):
        """ItemsInner - a model defined in OpenAPI

        :param brand_id: The brand_id of this ItemsInner.
        :param categories_ids: The categories_ids of this ItemsInner.
        :param index: The index of this ItemsInner.
        :param price_table_ids: The price_table_ids of this ItemsInner.
        :param quantity: The quantity of this ItemsInner.
        :param seller_id: The seller_id of this ItemsInner.
        :param sku_id: The sku_id of this ItemsInner.
        """
        self.openapi_types = {
            'brand_id': str,
            'categories_ids': List[str],
            'index': int,
            'price_table_ids': List[str],
            'quantity': int,
            'seller_id': str,
            'sku_id': str
        }

        self.attribute_map = {
            'brand_id': 'brandId',
            'categories_ids': 'categoriesIds',
            'index': 'index',
            'price_table_ids': 'priceTableIds',
            'quantity': 'quantity',
            'seller_id': 'sellerId',
            'sku_id': 'skuId'
        }

        self._brand_id = brand_id
        self._categories_ids = categories_ids
        self._index = index
        self._price_table_ids = price_table_ids
        self._quantity = quantity
        self._seller_id = seller_id
        self._sku_id = sku_id

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ItemsInner':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The items_inner of this ItemsInner.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def brand_id(self):
        """Gets the brand_id of this ItemsInner.

        This is the brand ID for the item

        :return: The brand_id of this ItemsInner.
        :rtype: str
        """
        return self._brand_id

    @brand_id.setter
    def brand_id(self, brand_id):
        """Sets the brand_id of this ItemsInner.

        This is the brand ID for the item

        :param brand_id: The brand_id of this ItemsInner.
        :type brand_id: str
        """
        if brand_id is None:
            raise ValueError("Invalid value for `brand_id`, must not be `None`")

        self._brand_id = brand_id

    @property
    def categories_ids(self):
        """Gets the categories_ids of this ItemsInner.

        ID of the categories that will be used to compute the price

        :return: The categories_ids of this ItemsInner.
        :rtype: List[str]
        """
        return self._categories_ids

    @categories_ids.setter
    def categories_ids(self, categories_ids):
        """Sets the categories_ids of this ItemsInner.

        ID of the categories that will be used to compute the price

        :param categories_ids: The categories_ids of this ItemsInner.
        :type categories_ids: List[str]
        """
        if categories_ids is None:
            raise ValueError("Invalid value for `categories_ids`, must not be `None`")

        self._categories_ids = categories_ids

    @property
    def index(self):
        """Gets the index of this ItemsInner.

        This is the index of the item at Checkout's cart. It has to be unique in the items array

        :return: The index of this ItemsInner.
        :rtype: int
        """
        return self._index

    @index.setter
    def index(self, index):
        """Sets the index of this ItemsInner.

        This is the index of the item at Checkout's cart. It has to be unique in the items array

        :param index: The index of this ItemsInner.
        :type index: int
        """
        if index is None:
            raise ValueError("Invalid value for `index`, must not be `None`")

        self._index = index

    @property
    def price_table_ids(self):
        """Gets the price_table_ids of this ItemsInner.

        IDs of the price tables that will be used to compute the price. More than one price table might be passed to the array. The final price rule might be more complex than the lowest or the highest price

        :return: The price_table_ids of this ItemsInner.
        :rtype: List[str]
        """
        return self._price_table_ids

    @price_table_ids.setter
    def price_table_ids(self, price_table_ids):
        """Sets the price_table_ids of this ItemsInner.

        IDs of the price tables that will be used to compute the price. More than one price table might be passed to the array. The final price rule might be more complex than the lowest or the highest price

        :param price_table_ids: The price_table_ids of this ItemsInner.
        :type price_table_ids: List[str]
        """
        if price_table_ids is None:
            raise ValueError("Invalid value for `price_table_ids`, must not be `None`")

        self._price_table_ids = price_table_ids

    @property
    def quantity(self):
        """Gets the quantity of this ItemsInner.

        This is the amount of items that will be priced. It is possible to have a volume discount for many repeated items. Hence, the price may not be the quantity of the item multiplied by the unitary price

        :return: The quantity of this ItemsInner.
        :rtype: int
        """
        return self._quantity

    @quantity.setter
    def quantity(self, quantity):
        """Sets the quantity of this ItemsInner.

        This is the amount of items that will be priced. It is possible to have a volume discount for many repeated items. Hence, the price may not be the quantity of the item multiplied by the unitary price

        :param quantity: The quantity of this ItemsInner.
        :type quantity: int
        """
        if quantity is None:
            raise ValueError("Invalid value for `quantity`, must not be `None`")

        self._quantity = quantity

    @property
    def seller_id(self):
        """Gets the seller_id of this ItemsInner.

        This is the seller ID for the item

        :return: The seller_id of this ItemsInner.
        :rtype: str
        """
        return self._seller_id

    @seller_id.setter
    def seller_id(self, seller_id):
        """Sets the seller_id of this ItemsInner.

        This is the seller ID for the item

        :param seller_id: The seller_id of this ItemsInner.
        :type seller_id: str
        """
        if seller_id is None:
            raise ValueError("Invalid value for `seller_id`, must not be `None`")

        self._seller_id = seller_id

    @property
    def sku_id(self):
        """Gets the sku_id of this ItemsInner.

        This is the sku id of the item that will be priced

        :return: The sku_id of this ItemsInner.
        :rtype: str
        """
        return self._sku_id

    @sku_id.setter
    def sku_id(self, sku_id):
        """Sets the sku_id of this ItemsInner.

        This is the sku id of the item that will be priced

        :param sku_id: The sku_id of this ItemsInner.
        :type sku_id: str
        """
        if sku_id is None:
            raise ValueError("Invalid value for `sku_id`, must not be `None`")

        self._sku_id = sku_id
