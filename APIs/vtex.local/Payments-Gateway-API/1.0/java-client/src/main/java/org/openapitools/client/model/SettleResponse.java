/*
 * Payments Gateway API
 * >ℹ️ Onboarding guide  >  > Check the new [Payments onboarding guide](https://developers.vtex.com/docs/guides/payments-overview). We created this guide to improve the onboarding experience for developers at VTEX. It assembles all documentation on our Developer Portal about Payments and is organized by focusing on the developer's journey.    The Payments Gateway API allows you to get payment data and process your store's transactions.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * SettleResponse
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:55:23.786494-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SettleResponse {
  public static final String SERIALIZED_NAME_CANCELLED_VALUE = "cancelledValue";
  @SerializedName(SERIALIZED_NAME_CANCELLED_VALUE)
  private Integer cancelledValue;

  public static final String SERIALIZED_NAME_CONNECTOR_REFUNDED_VALUE = "connectorRefundedValue";
  @SerializedName(SERIALIZED_NAME_CONNECTOR_REFUNDED_VALUE)
  private Integer connectorRefundedValue;

  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  private String message;

  public static final String SERIALIZED_NAME_PROCESSING_DATE = "processingDate";
  @SerializedName(SERIALIZED_NAME_PROCESSING_DATE)
  private String processingDate;

  public static final String SERIALIZED_NAME_REFUNDED_TOKEN = "refundedToken";
  @SerializedName(SERIALIZED_NAME_REFUNDED_TOKEN)
  private String refundedToken;

  public static final String SERIALIZED_NAME_REFUNDED_VALUE = "refundedValue";
  @SerializedName(SERIALIZED_NAME_REFUNDED_VALUE)
  private Integer refundedValue;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private Integer status;

  public static final String SERIALIZED_NAME_STATUS_DETAIL = "statusDetail";
  @SerializedName(SERIALIZED_NAME_STATUS_DETAIL)
  private String statusDetail;

  public static final String SERIALIZED_NAME_TOKEN = "token";
  @SerializedName(SERIALIZED_NAME_TOKEN)
  private String token;

  public SettleResponse() {
  }

  public SettleResponse cancelledValue(Integer cancelledValue) {
    this.cancelledValue = cancelledValue;
    return this;
  }

  /**
   * Get cancelledValue
   * @return cancelledValue
   */
  @javax.annotation.Nonnull
  public Integer getCancelledValue() {
    return cancelledValue;
  }

  public void setCancelledValue(Integer cancelledValue) {
    this.cancelledValue = cancelledValue;
  }


  public SettleResponse connectorRefundedValue(Integer connectorRefundedValue) {
    this.connectorRefundedValue = connectorRefundedValue;
    return this;
  }

  /**
   * Get connectorRefundedValue
   * @return connectorRefundedValue
   */
  @javax.annotation.Nonnull
  public Integer getConnectorRefundedValue() {
    return connectorRefundedValue;
  }

  public void setConnectorRefundedValue(Integer connectorRefundedValue) {
    this.connectorRefundedValue = connectorRefundedValue;
  }


  public SettleResponse message(String message) {
    this.message = message;
    return this;
  }

  /**
   * Get message
   * @return message
   */
  @javax.annotation.Nullable
  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }


  public SettleResponse processingDate(String processingDate) {
    this.processingDate = processingDate;
    return this;
  }

  /**
   * Get processingDate
   * @return processingDate
   */
  @javax.annotation.Nonnull
  public String getProcessingDate() {
    return processingDate;
  }

  public void setProcessingDate(String processingDate) {
    this.processingDate = processingDate;
  }


  public SettleResponse refundedToken(String refundedToken) {
    this.refundedToken = refundedToken;
    return this;
  }

  /**
   * Get refundedToken
   * @return refundedToken
   */
  @javax.annotation.Nullable
  public String getRefundedToken() {
    return refundedToken;
  }

  public void setRefundedToken(String refundedToken) {
    this.refundedToken = refundedToken;
  }


  public SettleResponse refundedValue(Integer refundedValue) {
    this.refundedValue = refundedValue;
    return this;
  }

  /**
   * Get refundedValue
   * @return refundedValue
   */
  @javax.annotation.Nonnull
  public Integer getRefundedValue() {
    return refundedValue;
  }

  public void setRefundedValue(Integer refundedValue) {
    this.refundedValue = refundedValue;
  }


  public SettleResponse status(Integer status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nonnull
  public Integer getStatus() {
    return status;
  }

  public void setStatus(Integer status) {
    this.status = status;
  }


  public SettleResponse statusDetail(String statusDetail) {
    this.statusDetail = statusDetail;
    return this;
  }

  /**
   * Get statusDetail
   * @return statusDetail
   */
  @javax.annotation.Nonnull
  public String getStatusDetail() {
    return statusDetail;
  }

  public void setStatusDetail(String statusDetail) {
    this.statusDetail = statusDetail;
  }


  public SettleResponse token(String token) {
    this.token = token;
    return this;
  }

  /**
   * Get token
   * @return token
   */
  @javax.annotation.Nonnull
  public String getToken() {
    return token;
  }

  public void setToken(String token) {
    this.token = token;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SettleResponse settleResponse = (SettleResponse) o;
    return Objects.equals(this.cancelledValue, settleResponse.cancelledValue) &&
        Objects.equals(this.connectorRefundedValue, settleResponse.connectorRefundedValue) &&
        Objects.equals(this.message, settleResponse.message) &&
        Objects.equals(this.processingDate, settleResponse.processingDate) &&
        Objects.equals(this.refundedToken, settleResponse.refundedToken) &&
        Objects.equals(this.refundedValue, settleResponse.refundedValue) &&
        Objects.equals(this.status, settleResponse.status) &&
        Objects.equals(this.statusDetail, settleResponse.statusDetail) &&
        Objects.equals(this.token, settleResponse.token);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cancelledValue, connectorRefundedValue, message, processingDate, refundedToken, refundedValue, status, statusDetail, token);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SettleResponse {\n");
    sb.append("    cancelledValue: ").append(toIndentedString(cancelledValue)).append("\n");
    sb.append("    connectorRefundedValue: ").append(toIndentedString(connectorRefundedValue)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    processingDate: ").append(toIndentedString(processingDate)).append("\n");
    sb.append("    refundedToken: ").append(toIndentedString(refundedToken)).append("\n");
    sb.append("    refundedValue: ").append(toIndentedString(refundedValue)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    statusDetail: ").append(toIndentedString(statusDetail)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cancelledValue");
    openapiFields.add("connectorRefundedValue");
    openapiFields.add("message");
    openapiFields.add("processingDate");
    openapiFields.add("refundedToken");
    openapiFields.add("refundedValue");
    openapiFields.add("status");
    openapiFields.add("statusDetail");
    openapiFields.add("token");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("cancelledValue");
    openapiRequiredFields.add("connectorRefundedValue");
    openapiRequiredFields.add("message");
    openapiRequiredFields.add("processingDate");
    openapiRequiredFields.add("refundedToken");
    openapiRequiredFields.add("refundedValue");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("statusDetail");
    openapiRequiredFields.add("token");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SettleResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SettleResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SettleResponse is not found in the empty JSON string", SettleResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SettleResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SettleResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : SettleResponse.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("message") != null && !jsonObj.get("message").isJsonNull()) && !jsonObj.get("message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `message` to be a primitive type in the JSON string but got `%s`", jsonObj.get("message").toString()));
      }
      if (!jsonObj.get("processingDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `processingDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("processingDate").toString()));
      }
      if ((jsonObj.get("refundedToken") != null && !jsonObj.get("refundedToken").isJsonNull()) && !jsonObj.get("refundedToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `refundedToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("refundedToken").toString()));
      }
      if (!jsonObj.get("statusDetail").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `statusDetail` to be a primitive type in the JSON string but got `%s`", jsonObj.get("statusDetail").toString()));
      }
      if (!jsonObj.get("token").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `token` to be a primitive type in the JSON string but got `%s`", jsonObj.get("token").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SettleResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SettleResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SettleResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SettleResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<SettleResponse>() {
           @Override
           public void write(JsonWriter out, SettleResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SettleResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SettleResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SettleResponse
   * @throws IOException if the JSON string is invalid with respect to SettleResponse
   */
  public static SettleResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SettleResponse.class);
  }

  /**
   * Convert an instance of SettleResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

