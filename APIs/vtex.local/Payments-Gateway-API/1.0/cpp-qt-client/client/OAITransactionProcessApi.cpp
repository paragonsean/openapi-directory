/**
 * Payments Gateway API
 * >ℹ️ Onboarding guide  >  > Check the new [Payments onboarding guide](https://developers.vtex.com/docs/guides/payments-overview). We created this guide to improve the onboarding experience for developers at VTEX. It assembles all documentation on our Developer Portal about Payments and is organized by focusing on the developer's journey.    The Payments Gateway API allows you to get payment data and process your store's transactions.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITransactionProcessApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAITransactionProcessApi::OAITransactionProcessApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAITransactionProcessApi::~OAITransactionProcessApi() {
}

void OAITransactionProcessApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://vtex.local"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://{accountName}.vtexpayments.com.br"),
    "VTEX server url",
    QMap<QString, OAIServerVariable>{ 
    {"accountName", OAIServerVariable("Name of the VTEX account. Used as part of the URL","{accountName}",
    QSet<QString>{ {"{accountName}"} })}, }));
    
    _serverConfigs.insert("1_Createanewtransaction", defaultConf);
    _serverIndices.insert("1_Createanewtransaction", 0);
    _serverConfigs.insert("2_SendPaymentsPublic", defaultConf);
    _serverIndices.insert("2_SendPaymentsPublic", 0);
    _serverConfigs.insert("2_SendPaymentsWithSavedCreditCard", defaultConf);
    _serverIndices.insert("2_SendPaymentsWithSavedCreditCard", 0);
    _serverConfigs.insert("3_SendAdditionalData", defaultConf);
    _serverIndices.insert("3_SendAdditionalData", 0);
    _serverConfigs.insert("4_Doauthorization", defaultConf);
    _serverIndices.insert("4_Doauthorization", 0);
    _serverConfigs.insert("paymentDetails", defaultConf);
    _serverIndices.insert("paymentDetails", 0);
    _serverConfigs.insert("transactionDetails", defaultConf);
    _serverIndices.insert("transactionDetails", 0);
    _serverConfigs.insert("transactionSettlementDetails", defaultConf);
    _serverIndices.insert("transactionSettlementDetails", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAITransactionProcessApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAITransactionProcessApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAITransactionProcessApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAITransactionProcessApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAITransactionProcessApi::setUsername(const QString &username) {
    _username = username;
}

void OAITransactionProcessApi::setPassword(const QString &password) {
    _password = password;
}


void OAITransactionProcessApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAITransactionProcessApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAITransactionProcessApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAITransactionProcessApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAITransactionProcessApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAITransactionProcessApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAITransactionProcessApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAITransactionProcessApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAITransactionProcessApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAITransactionProcessApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAITransactionProcessApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAITransactionProcessApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAITransactionProcessApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAITransactionProcessApi::1_Createanewtransaction(const QString &x_provider_api_app_key, const QString &x_provider_api_app_token, const QString &accept, const QString &content_type, const OAI1_CreateanewtransactionRequest &oai1_createanewtransaction_request) {
    QString fullPath = QString(_serverConfigs["1_Createanewtransaction"][_serverIndices.value("1_Createanewtransaction")].URL()+"/api/pvt/transactions");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai1_createanewtransaction_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_key).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppKey", ::OpenAPI::toStringValue(x_provider_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_token).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppToken", ::OpenAPI::toStringValue(x_provider_api_app_token));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITransactionProcessApi::1_CreateanewtransactionCallback);
    connect(this, &OAITransactionProcessApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITransactionProcessApi::1_CreateanewtransactionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStartTransactionResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT 1_CreateanewtransactionSignal(output);
        Q_EMIT 1_CreateanewtransactionSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT 1_CreateanewtransactionSignalE(output, error_type, error_str);
        Q_EMIT 1_CreateanewtransactionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT 1_CreateanewtransactionSignalError(output, error_type, error_str);
        Q_EMIT 1_CreateanewtransactionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITransactionProcessApi::2_SendPaymentsPublic(const QString &order_id, const QString &x_provider_api_app_key, const QString &x_provider_api_app_token, const QString &accept, const QString &content_type, const QString &transaction_id, const QList<OAI2_SendPaymentsPublicRequest> &oai2_send_payments_public_request) {
    QString fullPath = QString(_serverConfigs["2_SendPaymentsPublic"][_serverIndices.value("2_SendPaymentsPublic")].URL()+"/api/pub/transactions/{transactionId}/payments");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString transaction_idPathParam("{");
        transaction_idPathParam.append("transactionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transactionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transactionId"+pathSuffix : pathPrefix;
        fullPath.replace(transaction_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transaction_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "orderId", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("orderId")).append(querySuffix).append(QUrl::toPercentEncoding(order_id));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {
        QJsonDocument doc(::OpenAPI::toJsonValue(oai2_send_payments_public_request).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_key).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppKey", ::OpenAPI::toStringValue(x_provider_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_token).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppToken", ::OpenAPI::toStringValue(x_provider_api_app_token));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITransactionProcessApi::2_SendPaymentsPublicCallback);
    connect(this, &OAITransactionProcessApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITransactionProcessApi::2_SendPaymentsPublicCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT 2_SendPaymentsPublicSignal();
        Q_EMIT 2_SendPaymentsPublicSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT 2_SendPaymentsPublicSignalE(error_type, error_str);
        Q_EMIT 2_SendPaymentsPublicSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT 2_SendPaymentsPublicSignalError(error_type, error_str);
        Q_EMIT 2_SendPaymentsPublicSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITransactionProcessApi::2_SendPaymentsWithSavedCreditCard(const QString &x_provider_api_app_key, const QString &x_provider_api_app_token, const QString &accept, const QString &content_type, const QString &transaction_id, const QList<OAI2_SendPaymentsWithSavedCreditCardRequest> &oai2_send_payments_with_saved_credit_card_request) {
    QString fullPath = QString(_serverConfigs["2_SendPaymentsWithSavedCreditCard"][_serverIndices.value("2_SendPaymentsWithSavedCreditCard")].URL()+"/api/pvt/transactions/{transactionId}/payments");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString transaction_idPathParam("{");
        transaction_idPathParam.append("transactionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transactionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transactionId"+pathSuffix : pathPrefix;
        fullPath.replace(transaction_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transaction_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {
        QJsonDocument doc(::OpenAPI::toJsonValue(oai2_send_payments_with_saved_credit_card_request).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_key).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppKey", ::OpenAPI::toStringValue(x_provider_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_token).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppToken", ::OpenAPI::toStringValue(x_provider_api_app_token));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITransactionProcessApi::2_SendPaymentsWithSavedCreditCardCallback);
    connect(this, &OAITransactionProcessApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITransactionProcessApi::2_SendPaymentsWithSavedCreditCardCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT 2_SendPaymentsWithSavedCreditCardSignal();
        Q_EMIT 2_SendPaymentsWithSavedCreditCardSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT 2_SendPaymentsWithSavedCreditCardSignalE(error_type, error_str);
        Q_EMIT 2_SendPaymentsWithSavedCreditCardSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT 2_SendPaymentsWithSavedCreditCardSignalError(error_type, error_str);
        Q_EMIT 2_SendPaymentsWithSavedCreditCardSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITransactionProcessApi::3_SendAdditionalData(const QString &x_provider_api_app_key, const QString &x_provider_api_app_token, const QString &accept, const QString &content_type, const QString &transaction_id, const QList<QList> &request_body) {
    QString fullPath = QString(_serverConfigs["3_SendAdditionalData"][_serverIndices.value("3_SendAdditionalData")].URL()+"/api/pvt/transactions/{transactionId}/additional-data");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString transaction_idPathParam("{");
        transaction_idPathParam.append("transactionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transactionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transactionId"+pathSuffix : pathPrefix;
        fullPath.replace(transaction_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transaction_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_key).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppKey", ::OpenAPI::toStringValue(x_provider_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_token).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppToken", ::OpenAPI::toStringValue(x_provider_api_app_token));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITransactionProcessApi::3_SendAdditionalDataCallback);
    connect(this, &OAITransactionProcessApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITransactionProcessApi::3_SendAdditionalDataCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT 3_SendAdditionalDataSignal();
        Q_EMIT 3_SendAdditionalDataSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT 3_SendAdditionalDataSignalE(error_type, error_str);
        Q_EMIT 3_SendAdditionalDataSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT 3_SendAdditionalDataSignalError(error_type, error_str);
        Q_EMIT 3_SendAdditionalDataSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITransactionProcessApi::4_Doauthorization(const QString &x_provider_api_app_key, const QString &x_provider_api_app_token, const QString &accept, const QString &content_type, const QString &transaction_id, const OAI4_DoauthorizationRequest &oai4_doauthorization_request) {
    QString fullPath = QString(_serverConfigs["4_Doauthorization"][_serverIndices.value("4_Doauthorization")].URL()+"/api/pvt/transactions/{transactionId}/authorization-request");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString transaction_idPathParam("{");
        transaction_idPathParam.append("transactionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transactionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transactionId"+pathSuffix : pathPrefix;
        fullPath.replace(transaction_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transaction_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai4_doauthorization_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_key).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppKey", ::OpenAPI::toStringValue(x_provider_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_token).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppToken", ::OpenAPI::toStringValue(x_provider_api_app_token));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITransactionProcessApi::4_DoauthorizationCallback);
    connect(this, &OAITransactionProcessApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITransactionProcessApi::4_DoauthorizationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT 4_DoauthorizationSignal();
        Q_EMIT 4_DoauthorizationSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT 4_DoauthorizationSignalE(error_type, error_str);
        Q_EMIT 4_DoauthorizationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT 4_DoauthorizationSignalError(error_type, error_str);
        Q_EMIT 4_DoauthorizationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITransactionProcessApi::paymentDetails(const QString &x_provider_api_app_key, const QString &x_provider_api_app_token, const QString &content_type, const QString &accept, const QString &transaction_id, const QString &payment_id) {
    QString fullPath = QString(_serverConfigs["paymentDetails"][_serverIndices.value("paymentDetails")].URL()+"/api/pvt/transactions/{transactionId}/payments/{paymentId}");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString transaction_idPathParam("{");
        transaction_idPathParam.append("transactionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transactionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transactionId"+pathSuffix : pathPrefix;
        fullPath.replace(transaction_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transaction_id)));
    }
    
    {
        QString payment_idPathParam("{");
        payment_idPathParam.append("paymentId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "paymentId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"paymentId"+pathSuffix : pathPrefix;
        fullPath.replace(payment_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(payment_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_key).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppKey", ::OpenAPI::toStringValue(x_provider_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_token).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppToken", ::OpenAPI::toStringValue(x_provider_api_app_token));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITransactionProcessApi::paymentDetailsCallback);
    connect(this, &OAITransactionProcessApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITransactionProcessApi::paymentDetailsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaymentDetailsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT paymentDetailsSignal(output);
        Q_EMIT paymentDetailsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT paymentDetailsSignalE(output, error_type, error_str);
        Q_EMIT paymentDetailsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT paymentDetailsSignalError(output, error_type, error_str);
        Q_EMIT paymentDetailsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITransactionProcessApi::transactionDetails(const QString &x_provider_api_app_key, const QString &x_provider_api_app_token, const QString &content_type, const QString &accept, const QString &transaction_id) {
    QString fullPath = QString(_serverConfigs["transactionDetails"][_serverIndices.value("transactionDetails")].URL()+"/api/pvt/transactions/{transactionId}");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString transaction_idPathParam("{");
        transaction_idPathParam.append("transactionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transactionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transactionId"+pathSuffix : pathPrefix;
        fullPath.replace(transaction_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transaction_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_key).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppKey", ::OpenAPI::toStringValue(x_provider_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_token).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppToken", ::OpenAPI::toStringValue(x_provider_api_app_token));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITransactionProcessApi::transactionDetailsCallback);
    connect(this, &OAITransactionProcessApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITransactionProcessApi::transactionDetailsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionDetailsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionDetailsSignal(output);
        Q_EMIT transactionDetailsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionDetailsSignalE(output, error_type, error_str);
        Q_EMIT transactionDetailsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionDetailsSignalError(output, error_type, error_str);
        Q_EMIT transactionDetailsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITransactionProcessApi::transactionSettlementDetails(const QString &x_provider_api_app_key, const QString &x_provider_api_app_token, const QString &content_type, const QString &accept, const QString &transaction_id) {
    QString fullPath = QString(_serverConfigs["transactionSettlementDetails"][_serverIndices.value("transactionSettlementDetails")].URL()+"/api/pvt/transactions/{transactionId}/settlements");
    
    if (_apiKeys.contains("appToken")) {
        addHeaders("appToken",_apiKeys.find("appToken").value());
    }
    
    if (_apiKeys.contains("appKey")) {
        addHeaders("appKey",_apiKeys.find("appKey").value());
    }
    
    
    {
        QString transaction_idPathParam("{");
        transaction_idPathParam.append("transactionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "transactionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"transactionId"+pathSuffix : pathPrefix;
        fullPath.replace(transaction_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(transaction_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_key).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppKey", ::OpenAPI::toStringValue(x_provider_api_app_key));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(x_provider_api_app_token).isEmpty()) {
            input.headers.insert("X-PROVIDER-API-AppToken", ::OpenAPI::toStringValue(x_provider_api_app_token));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(content_type).isEmpty()) {
            input.headers.insert("Content-Type", ::OpenAPI::toStringValue(content_type));
        }
        }
    
    {
        if (!::OpenAPI::toStringValue(accept).isEmpty()) {
            input.headers.insert("Accept", ::OpenAPI::toStringValue(accept));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAITransactionProcessApi::transactionSettlementDetailsCallback);
    connect(this, &OAITransactionProcessApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAITransactionProcessApi::transactionSettlementDetailsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransactionSettlementDetails output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT transactionSettlementDetailsSignal(output);
        Q_EMIT transactionSettlementDetailsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT transactionSettlementDetailsSignalE(output, error_type, error_str);
        Q_EMIT transactionSettlementDetailsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT transactionSettlementDetailsSignalError(output, error_type, error_str);
        Q_EMIT transactionSettlementDetailsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAITransactionProcessApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
