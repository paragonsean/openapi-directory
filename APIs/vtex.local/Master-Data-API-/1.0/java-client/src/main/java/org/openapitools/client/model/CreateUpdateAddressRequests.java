/*
 * Master Data API - v2
 * # ATTENTION: **This version isn't compliant with data entities of old version (e.g. CL and AD). It's possible to use this configuration only to new data entities.**      ## Welcome!    VTEX Master Data is an easy-to-use, secure, fast, scalable and extensible repository. On it you can create your own Entities, store data and consult directly from the storefront or use it to store info for some external integration.    There are internal VTEX modules that use VTEX Master Data as data repository. We have the VTEX Customer Service, VTEX Profile System and VTEX InStore, for example. It is also used by other internal services.    There are two ways to use Master Data:    1. Directly from the storefront  2. External integration    ### Directly from the storefront    If your scenario is to be used inside the storefront, be aware of the following observations:    1. Use the storefront host to query or store information to avoid **CORS**;  2. Configure which information should be public and which shouldn't, inside the JSON Schema of the Data Entity;  3. Do not create query loops (the storefront may be affected with Throttling and apis may be turned off as a security protection);  4. Never add via JS any type of authentication key (x-vtex-api-appkey or x-vtex-api-apptoken);    **It's important to avoid CORS using the relative path**    ### External Integration    If your scenario is to perform external integration, such as migrating client data from another service, be aware of the following observations:    1. Use the host ```{{accountName}}.vtexcommercestable.com.br```;  2. Use the authentication keys (x-vtex-api-appkey ou x-vtex-api-apptoken);    ### Most used attributes listed here    | Name | Description |  | -------- | -------- |  | accountName | Account name in VTEX License Manager |  | name | Data Entity name |  | schema | JSON Schema of a Data Entity |  | id | Identifier of a document |  | x-vtex-api-appKey | User key |  | x-vtex-api-appToken | User token |
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CreateUpdateAddressRequests
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:55:27.050089-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CreateUpdateAddressRequests {
  public static final String SERIALIZED_NAME_ADDRESS_NAME = "addressName";
  @SerializedName(SERIALIZED_NAME_ADDRESS_NAME)
  private String addressName;

  public static final String SERIALIZED_NAME_ADDRESS_TYPE = "addressType";
  @SerializedName(SERIALIZED_NAME_ADDRESS_TYPE)
  private String addressType;

  public static final String SERIALIZED_NAME_CITY = "city";
  @SerializedName(SERIALIZED_NAME_CITY)
  private String city;

  public static final String SERIALIZED_NAME_COMPLEMENT = "complement";
  @SerializedName(SERIALIZED_NAME_COMPLEMENT)
  private String complement;

  public static final String SERIALIZED_NAME_COUNTRY = "country";
  @SerializedName(SERIALIZED_NAME_COUNTRY)
  private String country;

  public static final String SERIALIZED_NAME_NEIGHBORHOOD = "neighborhood";
  @SerializedName(SERIALIZED_NAME_NEIGHBORHOOD)
  private String neighborhood;

  public static final String SERIALIZED_NAME_NUMBER = "number";
  @SerializedName(SERIALIZED_NAME_NUMBER)
  private String number;

  public static final String SERIALIZED_NAME_POSTAL_CODE = "postalCode";
  @SerializedName(SERIALIZED_NAME_POSTAL_CODE)
  private String postalCode;

  public static final String SERIALIZED_NAME_RECEIVER_NAME = "receiverName";
  @SerializedName(SERIALIZED_NAME_RECEIVER_NAME)
  private String receiverName;

  public static final String SERIALIZED_NAME_REFERENCE = "reference";
  @SerializedName(SERIALIZED_NAME_REFERENCE)
  private String reference;

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private String state;

  public static final String SERIALIZED_NAME_STREET = "street";
  @SerializedName(SERIALIZED_NAME_STREET)
  private String street;

  public static final String SERIALIZED_NAME_USER_ID = "userId";
  @SerializedName(SERIALIZED_NAME_USER_ID)
  private String userId;

  public CreateUpdateAddressRequests() {
  }

  public CreateUpdateAddressRequests addressName(String addressName) {
    this.addressName = addressName;
    return this;
  }

  /**
   * Address name.
   * @return addressName
   */
  @javax.annotation.Nullable
  public String getAddressName() {
    return addressName;
  }

  public void setAddressName(String addressName) {
    this.addressName = addressName;
  }


  public CreateUpdateAddressRequests addressType(String addressType) {
    this.addressType = addressType;
    return this;
  }

  /**
   * Type of address. For example, &#x60;Residential&#x60; or &#x60;Pickup&#x60;, among others.
   * @return addressType
   */
  @javax.annotation.Nullable
  public String getAddressType() {
    return addressType;
  }

  public void setAddressType(String addressType) {
    this.addressType = addressType;
  }


  public CreateUpdateAddressRequests city(String city) {
    this.city = city;
    return this;
  }

  /**
   * City of the shipping address.
   * @return city
   */
  @javax.annotation.Nullable
  public String getCity() {
    return city;
  }

  public void setCity(String city) {
    this.city = city;
  }


  public CreateUpdateAddressRequests complement(String complement) {
    this.complement = complement;
    return this;
  }

  /**
   * Complement to the shipping address in case it applies.
   * @return complement
   */
  @javax.annotation.Nullable
  public String getComplement() {
    return complement;
  }

  public void setComplement(String complement) {
    this.complement = complement;
  }


  public CreateUpdateAddressRequests country(String country) {
    this.country = country;
    return this;
  }

  /**
   * Three letter ISO code of the country of the shipping address.
   * @return country
   */
  @javax.annotation.Nullable
  public String getCountry() {
    return country;
  }

  public void setCountry(String country) {
    this.country = country;
  }


  public CreateUpdateAddressRequests neighborhood(String neighborhood) {
    this.neighborhood = neighborhood;
    return this;
  }

  /**
   * Neighborhood of the address.
   * @return neighborhood
   */
  @javax.annotation.Nullable
  public String getNeighborhood() {
    return neighborhood;
  }

  public void setNeighborhood(String neighborhood) {
    this.neighborhood = neighborhood;
  }


  public CreateUpdateAddressRequests number(String number) {
    this.number = number;
    return this;
  }

  /**
   * Number of the building, house or apartment in the shipping address.
   * @return number
   */
  @javax.annotation.Nullable
  public String getNumber() {
    return number;
  }

  public void setNumber(String number) {
    this.number = number;
  }


  public CreateUpdateAddressRequests postalCode(String postalCode) {
    this.postalCode = postalCode;
    return this;
  }

  /**
   * Postal Code.
   * @return postalCode
   */
  @javax.annotation.Nullable
  public String getPostalCode() {
    return postalCode;
  }

  public void setPostalCode(String postalCode) {
    this.postalCode = postalCode;
  }


  public CreateUpdateAddressRequests receiverName(String receiverName) {
    this.receiverName = receiverName;
    return this;
  }

  /**
   * Name of the person who is going to receive the order.
   * @return receiverName
   */
  @javax.annotation.Nullable
  public String getReceiverName() {
    return receiverName;
  }

  public void setReceiverName(String receiverName) {
    this.receiverName = receiverName;
  }


  public CreateUpdateAddressRequests reference(String reference) {
    this.reference = reference;
    return this;
  }

  /**
   * Complement that might help locate the shipping address more precisely in case of delivery.
   * @return reference
   */
  @javax.annotation.Nullable
  public String getReference() {
    return reference;
  }

  public void setReference(String reference) {
    this.reference = reference;
  }


  public CreateUpdateAddressRequests state(String state) {
    this.state = state;
    return this;
  }

  /**
   * State of the shipping address.
   * @return state
   */
  @javax.annotation.Nullable
  public String getState() {
    return state;
  }

  public void setState(String state) {
    this.state = state;
  }


  public CreateUpdateAddressRequests street(String street) {
    this.street = street;
    return this;
  }

  /**
   * Street of the address.
   * @return street
   */
  @javax.annotation.Nullable
  public String getStreet() {
    return street;
  }

  public void setStreet(String street) {
    this.street = street;
  }


  public CreateUpdateAddressRequests userId(String userId) {
    this.userId = userId;
    return this;
  }

  /**
   * ID of the customer to whom the address belongs.
   * @return userId
   */
  @javax.annotation.Nullable
  public String getUserId() {
    return userId;
  }

  public void setUserId(String userId) {
    this.userId = userId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateUpdateAddressRequests createUpdateAddressRequests = (CreateUpdateAddressRequests) o;
    return Objects.equals(this.addressName, createUpdateAddressRequests.addressName) &&
        Objects.equals(this.addressType, createUpdateAddressRequests.addressType) &&
        Objects.equals(this.city, createUpdateAddressRequests.city) &&
        Objects.equals(this.complement, createUpdateAddressRequests.complement) &&
        Objects.equals(this.country, createUpdateAddressRequests.country) &&
        Objects.equals(this.neighborhood, createUpdateAddressRequests.neighborhood) &&
        Objects.equals(this.number, createUpdateAddressRequests.number) &&
        Objects.equals(this.postalCode, createUpdateAddressRequests.postalCode) &&
        Objects.equals(this.receiverName, createUpdateAddressRequests.receiverName) &&
        Objects.equals(this.reference, createUpdateAddressRequests.reference) &&
        Objects.equals(this.state, createUpdateAddressRequests.state) &&
        Objects.equals(this.street, createUpdateAddressRequests.street) &&
        Objects.equals(this.userId, createUpdateAddressRequests.userId);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(addressName, addressType, city, complement, country, neighborhood, number, postalCode, receiverName, reference, state, street, userId);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateUpdateAddressRequests {\n");
    sb.append("    addressName: ").append(toIndentedString(addressName)).append("\n");
    sb.append("    addressType: ").append(toIndentedString(addressType)).append("\n");
    sb.append("    city: ").append(toIndentedString(city)).append("\n");
    sb.append("    complement: ").append(toIndentedString(complement)).append("\n");
    sb.append("    country: ").append(toIndentedString(country)).append("\n");
    sb.append("    neighborhood: ").append(toIndentedString(neighborhood)).append("\n");
    sb.append("    number: ").append(toIndentedString(number)).append("\n");
    sb.append("    postalCode: ").append(toIndentedString(postalCode)).append("\n");
    sb.append("    receiverName: ").append(toIndentedString(receiverName)).append("\n");
    sb.append("    reference: ").append(toIndentedString(reference)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    street: ").append(toIndentedString(street)).append("\n");
    sb.append("    userId: ").append(toIndentedString(userId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("addressName");
    openapiFields.add("addressType");
    openapiFields.add("city");
    openapiFields.add("complement");
    openapiFields.add("country");
    openapiFields.add("neighborhood");
    openapiFields.add("number");
    openapiFields.add("postalCode");
    openapiFields.add("receiverName");
    openapiFields.add("reference");
    openapiFields.add("state");
    openapiFields.add("street");
    openapiFields.add("userId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CreateUpdateAddressRequests
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateUpdateAddressRequests.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateUpdateAddressRequests is not found in the empty JSON string", CreateUpdateAddressRequests.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CreateUpdateAddressRequests.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CreateUpdateAddressRequests` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("addressName") != null && !jsonObj.get("addressName").isJsonNull()) && !jsonObj.get("addressName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `addressName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("addressName").toString()));
      }
      if ((jsonObj.get("addressType") != null && !jsonObj.get("addressType").isJsonNull()) && !jsonObj.get("addressType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `addressType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("addressType").toString()));
      }
      if ((jsonObj.get("city") != null && !jsonObj.get("city").isJsonNull()) && !jsonObj.get("city").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `city` to be a primitive type in the JSON string but got `%s`", jsonObj.get("city").toString()));
      }
      if ((jsonObj.get("complement") != null && !jsonObj.get("complement").isJsonNull()) && !jsonObj.get("complement").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `complement` to be a primitive type in the JSON string but got `%s`", jsonObj.get("complement").toString()));
      }
      if ((jsonObj.get("country") != null && !jsonObj.get("country").isJsonNull()) && !jsonObj.get("country").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `country` to be a primitive type in the JSON string but got `%s`", jsonObj.get("country").toString()));
      }
      if ((jsonObj.get("neighborhood") != null && !jsonObj.get("neighborhood").isJsonNull()) && !jsonObj.get("neighborhood").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `neighborhood` to be a primitive type in the JSON string but got `%s`", jsonObj.get("neighborhood").toString()));
      }
      if ((jsonObj.get("number") != null && !jsonObj.get("number").isJsonNull()) && !jsonObj.get("number").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `number` to be a primitive type in the JSON string but got `%s`", jsonObj.get("number").toString()));
      }
      if ((jsonObj.get("postalCode") != null && !jsonObj.get("postalCode").isJsonNull()) && !jsonObj.get("postalCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postalCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postalCode").toString()));
      }
      if ((jsonObj.get("receiverName") != null && !jsonObj.get("receiverName").isJsonNull()) && !jsonObj.get("receiverName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `receiverName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("receiverName").toString()));
      }
      if ((jsonObj.get("reference") != null && !jsonObj.get("reference").isJsonNull()) && !jsonObj.get("reference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reference").toString()));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      if ((jsonObj.get("street") != null && !jsonObj.get("street").isJsonNull()) && !jsonObj.get("street").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `street` to be a primitive type in the JSON string but got `%s`", jsonObj.get("street").toString()));
      }
      if ((jsonObj.get("userId") != null && !jsonObj.get("userId").isJsonNull()) && !jsonObj.get("userId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `userId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("userId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateUpdateAddressRequests.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateUpdateAddressRequests' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateUpdateAddressRequests> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateUpdateAddressRequests.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateUpdateAddressRequests>() {
           @Override
           public void write(JsonWriter out, CreateUpdateAddressRequests value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateUpdateAddressRequests read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CreateUpdateAddressRequests given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CreateUpdateAddressRequests
   * @throws IOException if the JSON string is invalid with respect to CreateUpdateAddressRequests
   */
  public static CreateUpdateAddressRequests fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateUpdateAddressRequests.class);
  }

  /**
   * Convert an instance of CreateUpdateAddressRequests to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

