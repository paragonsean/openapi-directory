# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class Product(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, brand_id: int=1234567, category_id: int=12, description: str='Description of the product, how it will appear on the marketplace.', name: str='Book', specifications: str=''):
        """Product - a model defined in OpenAPI

        :param brand_id: The brand_id of this Product.
        :param category_id: The category_id of this Product.
        :param description: The description of this Product.
        :param name: The name of this Product.
        :param specifications: The specifications of this Product.
        """
        self.openapi_types = {
            'brand_id': int,
            'category_id': int,
            'description': str,
            'name': str,
            'specifications': str
        }

        self.attribute_map = {
            'brand_id': 'brandId',
            'category_id': 'categoryId',
            'description': 'description',
            'name': 'name',
            'specifications': 'specifications'
        }

        self._brand_id = brand_id
        self._category_id = category_id
        self._description = description
        self._name = name
        self._specifications = specifications

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Product':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Product of this Product.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def brand_id(self):
        """Gets the brand_id of this Product.

        Marketplace's Brand ID that the product belongs to, configured in the Catalog. It should be the brand chosen for the received SKU to be matched with. The brandId is already mapped through the Get Suggestions API. This field is nulled when the inserted value is 0.

        :return: The brand_id of this Product.
        :rtype: int
        """
        return self._brand_id

    @brand_id.setter
    def brand_id(self, brand_id):
        """Sets the brand_id of this Product.

        Marketplace's Brand ID that the product belongs to, configured in the Catalog. It should be the brand chosen for the received SKU to be matched with. The brandId is already mapped through the Get Suggestions API. This field is nulled when the inserted value is 0.

        :param brand_id: The brand_id of this Product.
        :type brand_id: int
        """
        if brand_id is None:
            raise ValueError("Invalid value for `brand_id`, must not be `None`")

        self._brand_id = brand_id

    @property
    def category_id(self):
        """Gets the category_id of this Product.

        Marketplace's Category ID that the product belongs to, configured in the Catalog. It should be the category chosen for the received SKU to be matched with. The `categoryId` is already mapped through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion). You can choose to keep the same suggested `categoryID`, or overwrite it with another value in this request. This field is nulled when the inserted value is 0.

        :return: The category_id of this Product.
        :rtype: int
        """
        return self._category_id

    @category_id.setter
    def category_id(self, category_id):
        """Sets the category_id of this Product.

        Marketplace's Category ID that the product belongs to, configured in the Catalog. It should be the category chosen for the received SKU to be matched with. The `categoryId` is already mapped through the [Get SKU Suggestion by ID](https://developers.vtex.com/vtex-rest-api/reference/getsuggestion). You can choose to keep the same suggested `categoryID`, or overwrite it with another value in this request. This field is nulled when the inserted value is 0.

        :param category_id: The category_id of this Product.
        :type category_id: int
        """
        if category_id is None:
            raise ValueError("Invalid value for `category_id`, must not be `None`")

        self._category_id = category_id

    @property
    def description(self):
        """Gets the description of this Product.

        Product's description.

        :return: The description of this Product.
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this Product.

        Product's description.

        :param description: The description of this Product.
        :type description: str
        """
        if description is None:
            raise ValueError("Invalid value for `description`, must not be `None`")

        self._description = description

    @property
    def name(self):
        """Gets the name of this Product.

        Name of the product that will be matched.

        :return: The name of this Product.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Product.

        Name of the product that will be matched.

        :param name: The name of this Product.
        :type name: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")

        self._name = name

    @property
    def specifications(self):
        """Gets the specifications of this Product.

        This field is optional. Add here any product specifications or details.

        :return: The specifications of this Product.
        :rtype: str
        """
        return self._specifications

    @specifications.setter
    def specifications(self, specifications):
        """Sets the specifications of this Product.

        This field is optional. Add here any product specifications or details.

        :param specifications: The specifications of this Product.
        :type specifications: str
        """
        if specifications is None:
            raise ValueError("Invalid value for `specifications`, must not be `None`")

        self._specifications = specifications
