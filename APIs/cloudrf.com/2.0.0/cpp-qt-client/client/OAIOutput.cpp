/**
 * Cloud-RF API
 * Use this JSON API to build and test radio links for any radio, anywhere. Authenticate with your API2.0 key in the request header as key
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@cloudrf.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIOutput.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIOutput::OAIOutput(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIOutput::OAIOutput() {
    this->initializeModel();
}

OAIOutput::~OAIOutput() {}

void OAIOutput::initializeModel() {

    m_ber_isSet = false;
    m_ber_isValid = false;

    m_col_isSet = false;
    m_col_isValid = false;

    m_mod_isSet = false;
    m_mod_isValid = false;

    m_nf_isSet = false;
    m_nf_isValid = false;

    m_out_isSet = false;
    m_out_isValid = false;

    m_rad_isSet = false;
    m_rad_isValid = false;

    m_res_isSet = false;
    m_res_isValid = false;

    m_units_isSet = false;
    m_units_isValid = false;
}

void OAIOutput::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIOutput::fromJsonObject(QJsonObject json) {

    m_ber_isValid = ::OpenAPI::fromJsonValue(m_ber, json[QString("ber")]);
    m_ber_isSet = !json[QString("ber")].isNull() && m_ber_isValid;

    m_col_isValid = ::OpenAPI::fromJsonValue(m_col, json[QString("col")]);
    m_col_isSet = !json[QString("col")].isNull() && m_col_isValid;

    m_mod_isValid = ::OpenAPI::fromJsonValue(m_mod, json[QString("mod")]);
    m_mod_isSet = !json[QString("mod")].isNull() && m_mod_isValid;

    m_nf_isValid = ::OpenAPI::fromJsonValue(m_nf, json[QString("nf")]);
    m_nf_isSet = !json[QString("nf")].isNull() && m_nf_isValid;

    m_out_isValid = ::OpenAPI::fromJsonValue(m_out, json[QString("out")]);
    m_out_isSet = !json[QString("out")].isNull() && m_out_isValid;

    m_rad_isValid = ::OpenAPI::fromJsonValue(m_rad, json[QString("rad")]);
    m_rad_isSet = !json[QString("rad")].isNull() && m_rad_isValid;

    m_res_isValid = ::OpenAPI::fromJsonValue(m_res, json[QString("res")]);
    m_res_isSet = !json[QString("res")].isNull() && m_res_isValid;

    m_units_isValid = ::OpenAPI::fromJsonValue(m_units, json[QString("units")]);
    m_units_isSet = !json[QString("units")].isNull() && m_units_isValid;
}

QString OAIOutput::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIOutput::asJsonObject() const {
    QJsonObject obj;
    if (m_ber_isSet) {
        obj.insert(QString("ber"), ::OpenAPI::toJsonValue(m_ber));
    }
    if (m_col_isSet) {
        obj.insert(QString("col"), ::OpenAPI::toJsonValue(m_col));
    }
    if (m_mod_isSet) {
        obj.insert(QString("mod"), ::OpenAPI::toJsonValue(m_mod));
    }
    if (m_nf_isSet) {
        obj.insert(QString("nf"), ::OpenAPI::toJsonValue(m_nf));
    }
    if (m_out_isSet) {
        obj.insert(QString("out"), ::OpenAPI::toJsonValue(m_out));
    }
    if (m_rad_isSet) {
        obj.insert(QString("rad"), ::OpenAPI::toJsonValue(m_rad));
    }
    if (m_res_isSet) {
        obj.insert(QString("res"), ::OpenAPI::toJsonValue(m_res));
    }
    if (m_units_isSet) {
        obj.insert(QString("units"), ::OpenAPI::toJsonValue(m_units));
    }
    return obj;
}

qint32 OAIOutput::getBer() const {
    return m_ber;
}
void OAIOutput::setBer(const qint32 &ber) {
    m_ber = ber;
    m_ber_isSet = true;
}

bool OAIOutput::is_ber_Set() const{
    return m_ber_isSet;
}

bool OAIOutput::is_ber_Valid() const{
    return m_ber_isValid;
}

QString OAIOutput::getCol() const {
    return m_col;
}
void OAIOutput::setCol(const QString &col) {
    m_col = col;
    m_col_isSet = true;
}

bool OAIOutput::is_col_Set() const{
    return m_col_isSet;
}

bool OAIOutput::is_col_Valid() const{
    return m_col_isValid;
}

qint32 OAIOutput::getMod() const {
    return m_mod;
}
void OAIOutput::setMod(const qint32 &mod) {
    m_mod = mod;
    m_mod_isSet = true;
}

bool OAIOutput::is_mod_Set() const{
    return m_mod_isSet;
}

bool OAIOutput::is_mod_Valid() const{
    return m_mod_isValid;
}

qint32 OAIOutput::getNf() const {
    return m_nf;
}
void OAIOutput::setNf(const qint32 &nf) {
    m_nf = nf;
    m_nf_isSet = true;
}

bool OAIOutput::is_nf_Set() const{
    return m_nf_isSet;
}

bool OAIOutput::is_nf_Valid() const{
    return m_nf_isValid;
}

qint32 OAIOutput::getOut() const {
    return m_out;
}
void OAIOutput::setOut(const qint32 &out) {
    m_out = out;
    m_out_isSet = true;
}

bool OAIOutput::is_out_Set() const{
    return m_out_isSet;
}

bool OAIOutput::is_out_Valid() const{
    return m_out_isValid;
}

float OAIOutput::getRad() const {
    return m_rad;
}
void OAIOutput::setRad(const float &rad) {
    m_rad = rad;
    m_rad_isSet = true;
}

bool OAIOutput::is_rad_Set() const{
    return m_rad_isSet;
}

bool OAIOutput::is_rad_Valid() const{
    return m_rad_isValid;
}

qint32 OAIOutput::getRes() const {
    return m_res;
}
void OAIOutput::setRes(const qint32 &res) {
    m_res = res;
    m_res_isSet = true;
}

bool OAIOutput::is_res_Set() const{
    return m_res_isSet;
}

bool OAIOutput::is_res_Valid() const{
    return m_res_isValid;
}

QString OAIOutput::getUnits() const {
    return m_units;
}
void OAIOutput::setUnits(const QString &units) {
    m_units = units;
    m_units_isSet = true;
}

bool OAIOutput::is_units_Set() const{
    return m_units_isSet;
}

bool OAIOutput::is_units_Valid() const{
    return m_units_isValid;
}

bool OAIOutput::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_ber_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_col_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_mod_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_nf_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_out_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rad_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_res_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_units_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIOutput::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
