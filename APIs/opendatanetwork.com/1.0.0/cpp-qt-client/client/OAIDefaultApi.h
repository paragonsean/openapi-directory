/**
 * ODN API
 * The Socrata OpenDataNetwork (ODN) REST API exposes public data, often continuosly updated and enhanced, from many thousands of public government and non profit agencies.  Much of this data originating from independent sources is fused together to create new, and often powerful, entity level data. The API, in addition to search and autosuggest capabilities for finding datasets, enables data based comparisons across geographical regions such as states, counties, metropolitan areas, cities and zip codes using highly vetted data providers such as US Census, BEA, HUD and others. Comparison data is preformatted for easy and efficient display on a chart, graph or interactive map.  The API also exposes data organized by narrative style questions a human might ask. The questions can be rapidly found using an autosuggest style index, and then used to directly access all data needed to thoroughly and authoritatively answer the question. Retrieved data includes time series (temporally aligned), tabular, map heavy (includes spatial boundaries), and auto generated unstructured descriptive text.  The ODN API does not duplicate API endpoints or services provided by public sector agencies, but rather, returns context relevant pre-populated REST URLs, when appropriate, so the caller can access data directly from the source.  The [open source](http://github.com/socrata/odn-backend) API powers [OpenDataNetwork.com](http://OpenDataNetwork.com), an [open source](http://github.com/socrata/opendatanetwork.com) site; the site highlights myriad uses and provides API badges with contextually relevant API example REST endpoints and documentation pointers.  Finally, we continuously add new dat sources which appear automatically in the API, so if your favorite data source is not available, check back soon. You can also join us [HERE](http://www.opendatanetwork.com/join-open-data-network) and receive updates or let us know which data sources you are most interested in.  ## App Tokens  Registering for and including a [Socrata application token](https://dev.socrata.com/docs/app-tokens.html) is _required_ for the ODN API. They can be passed either using the `app_token` parameter or the `X-App-Token` HTTP header.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_OAIDefaultApi_H
#define OAI_OAIDefaultApi_H

#include "OAIHelpers.h"
#include "OAIHttpRequest.h"
#include "OAIServerConfiguration.h"
#include "OAIOauth.h"

#include <QString>

#include <QObject>
#include <QByteArray>
#include <QStringList>
#include <QList>
#include <QNetworkAccessManager>

namespace OpenAPI {

class OAIDefaultApi : public QObject {
    Q_OBJECT

public:
    OAIDefaultApi(const int timeOut = 0);
    ~OAIDefaultApi();

    void initializeServerConfigs();
    int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
    void setServerIndex(const QString &operation, int serverIndex);
    void setApiKey(const QString &apiKeyName, const QString &apiKey);
    void setBearerToken(const QString &token);
    void setUsername(const QString &username);
    void setPassword(const QString &password);
    void setTimeOut(const int timeOut);
    void setWorkingDirectory(const QString &path);
    void setNetworkAccessManager(QNetworkAccessManager* manager);
    int addServerConfiguration(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables = QMap<QString, OAIServerVariable>());
    void setNewServerForAllOperations(const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void setNewServer(const QString &operation, const QUrl &url, const QString &description = "", const QMap<QString, OAIServerVariable> &variables =  QMap<QString, OAIServerVariable>());
    void addHeaders(const QString &key, const QString &value);
    void enableRequestCompression();
    void enableResponseCompression();
    void abortRequests();
    QString getParamStylePrefix(const QString &style);
    QString getParamStyleSuffix(const QString &style);
    QString getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode);

    /**
    * @param[in]  variable QString [required]
    * @param[in]  entity_id QString [required]
    * @param[in]  constraint QString [optional]
    * @param[in]  app_token QString [optional]
    * @param[in]  x_app_token QString [optional]
    */
    virtual void create_a_map(const QString &variable, const QString &entity_id, const ::OpenAPI::OptionalParam<QString> &constraint = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &app_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &x_app_token = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  entity_id QString [required]
    * @param[in]  app_token QString [optional]
    * @param[in]  x_app_token QString [optional]
    */
    virtual void find_all_available_data_for_some_entities(const QString &entity_id, const ::OpenAPI::OptionalParam<QString> &app_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &x_app_token = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  relation QString [required]
    * @param[in]  entity_id QString [required]
    * @param[in]  variable_id QString [optional]
    * @param[in]  limit double [optional]
    * @param[in]  app_token QString [optional]
    * @param[in]  x_app_token QString [optional]
    */
    virtual void find_the_relatives_of_an_entity(const QString &relation, const QString &entity_id, const ::OpenAPI::OptionalParam<QString> &variable_id = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<double> &limit = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<QString> &app_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &x_app_token = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  entity_id QString [optional]
    * @param[in]  entity_name QString [optional]
    * @param[in]  entity_type QString [optional]
    * @param[in]  app_token QString [optional]
    * @param[in]  x_app_token QString [optional]
    */
    virtual void get_Entities(const ::OpenAPI::OptionalParam<QString> &entity_id = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &entity_name = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &entity_type = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &app_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &x_app_token = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  variable QString [required]
    * @param[in]  entity_id QString [required]
    * @param[in]  constraint QString [required]
    * @param[in]  app_token QString [optional]
    * @param[in]  x_app_token QString [optional]
    */
    virtual void get_constraint_permutations_for_entities(const QString &variable, const QString &entity_id, const QString &constraint, const ::OpenAPI::OptionalParam<QString> &app_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &x_app_token = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  entity_id QString [optional]
    * @param[in]  dataset_id QString [optional]
    * @param[in]  limit double [optional]
    * @param[in]  offset double [optional]
    * @param[in]  app_token QString [optional]
    * @param[in]  x_app_token QString [optional]
    */
    virtual void get_datasets(const ::OpenAPI::OptionalParam<QString> &entity_id = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &dataset_id = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<double> &limit = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &offset = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<QString> &app_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &x_app_token = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  query QString [required]
    * @param[in]  limit double [optional]
    * @param[in]  offset double [optional]
    * @param[in]  app_token QString [optional]
    * @param[in]  x_app_token QString [optional]
    */
    virtual void get_questions(const QString &query, const ::OpenAPI::OptionalParam<double> &limit = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<double> &offset = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<QString> &app_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &x_app_token = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  type QString [required]
    * @param[in]  query QString [required]
    * @param[in]  limit double [optional]
    * @param[in]  variable_id QString [optional]
    * @param[in]  app_token QString [optional]
    * @param[in]  x_app_token QString [optional]
    */
    virtual void get_suggestions(const QString &type, const QString &query, const ::OpenAPI::OptionalParam<double> &limit = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<QString> &variable_id = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &app_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &x_app_token = ::OpenAPI::OptionalParam<QString>());

    /**
    * @param[in]  variable QString [required]
    * @param[in]  entity_id QString [optional]
    * @param[in]  forecast double [optional]
    * @param[in]  describe bool [optional]
    * @param[in]  format QString [optional]
    * @param[in]  app_token QString [optional]
    * @param[in]  x_app_token QString [optional]
    */
    virtual void get_values_for_variables(const QString &variable, const ::OpenAPI::OptionalParam<QString> &entity_id = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<double> &forecast = ::OpenAPI::OptionalParam<double>(), const ::OpenAPI::OptionalParam<bool> &describe = ::OpenAPI::OptionalParam<bool>(), const ::OpenAPI::OptionalParam<QString> &format = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &app_token = ::OpenAPI::OptionalParam<QString>(), const ::OpenAPI::OptionalParam<QString> &x_app_token = ::OpenAPI::OptionalParam<QString>());


private:
    QMap<QString,int> _serverIndices;
    QMap<QString,QList<OAIServerConfiguration>> _serverConfigs;
    QMap<QString, QString> _apiKeys;
    QString _bearerToken;
    QString _username;
    QString _password;
    int _timeOut;
    QString _workingDirectory;
    QNetworkAccessManager* _manager;
    QMap<QString, QString> _defaultHeaders;
    bool _isResponseCompressionEnabled;
    bool _isRequestCompressionEnabled;
    OAIHttpRequestInput _latestInput;
    OAIHttpRequestWorker *_latestWorker;
    QStringList _latestScope;
    OauthCode _authFlow;
    OauthImplicit _implicitFlow;
    OauthCredentials _credentialFlow;
    OauthPassword _passwordFlow;
    int _OauthMethod = 0;

    void create_a_mapCallback(OAIHttpRequestWorker *worker);
    void find_all_available_data_for_some_entitiesCallback(OAIHttpRequestWorker *worker);
    void find_the_relatives_of_an_entityCallback(OAIHttpRequestWorker *worker);
    void get_EntitiesCallback(OAIHttpRequestWorker *worker);
    void get_constraint_permutations_for_entitiesCallback(OAIHttpRequestWorker *worker);
    void get_datasetsCallback(OAIHttpRequestWorker *worker);
    void get_questionsCallback(OAIHttpRequestWorker *worker);
    void get_suggestionsCallback(OAIHttpRequestWorker *worker);
    void get_values_for_variablesCallback(OAIHttpRequestWorker *worker);

Q_SIGNALS:

    void create_a_mapSignal();
    void find_all_available_data_for_some_entitiesSignal();
    void find_the_relatives_of_an_entitySignal();
    void get_EntitiesSignal();
    void get_constraint_permutations_for_entitiesSignal();
    void get_datasetsSignal();
    void get_questionsSignal();
    void get_suggestionsSignal();
    void get_values_for_variablesSignal();


    void create_a_mapSignalFull(OAIHttpRequestWorker *worker);
    void find_all_available_data_for_some_entitiesSignalFull(OAIHttpRequestWorker *worker);
    void find_the_relatives_of_an_entitySignalFull(OAIHttpRequestWorker *worker);
    void get_EntitiesSignalFull(OAIHttpRequestWorker *worker);
    void get_constraint_permutations_for_entitiesSignalFull(OAIHttpRequestWorker *worker);
    void get_datasetsSignalFull(OAIHttpRequestWorker *worker);
    void get_questionsSignalFull(OAIHttpRequestWorker *worker);
    void get_suggestionsSignalFull(OAIHttpRequestWorker *worker);
    void get_values_for_variablesSignalFull(OAIHttpRequestWorker *worker);

    Q_DECL_DEPRECATED_X("Use create_a_mapSignalError() instead")
    void create_a_mapSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void create_a_mapSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use find_all_available_data_for_some_entitiesSignalError() instead")
    void find_all_available_data_for_some_entitiesSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void find_all_available_data_for_some_entitiesSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use find_the_relatives_of_an_entitySignalError() instead")
    void find_the_relatives_of_an_entitySignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void find_the_relatives_of_an_entitySignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_EntitiesSignalError() instead")
    void get_EntitiesSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void get_EntitiesSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_constraint_permutations_for_entitiesSignalError() instead")
    void get_constraint_permutations_for_entitiesSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void get_constraint_permutations_for_entitiesSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_datasetsSignalError() instead")
    void get_datasetsSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void get_datasetsSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_questionsSignalError() instead")
    void get_questionsSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void get_questionsSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_suggestionsSignalError() instead")
    void get_suggestionsSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void get_suggestionsSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_values_for_variablesSignalError() instead")
    void get_values_for_variablesSignalE(QNetworkReply::NetworkError error_type, QString error_str);
    void get_values_for_variablesSignalError(QNetworkReply::NetworkError error_type, const QString &error_str);

    Q_DECL_DEPRECATED_X("Use create_a_mapSignalErrorFull() instead")
    void create_a_mapSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void create_a_mapSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use find_all_available_data_for_some_entitiesSignalErrorFull() instead")
    void find_all_available_data_for_some_entitiesSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void find_all_available_data_for_some_entitiesSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use find_the_relatives_of_an_entitySignalErrorFull() instead")
    void find_the_relatives_of_an_entitySignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void find_the_relatives_of_an_entitySignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_EntitiesSignalErrorFull() instead")
    void get_EntitiesSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void get_EntitiesSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_constraint_permutations_for_entitiesSignalErrorFull() instead")
    void get_constraint_permutations_for_entitiesSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void get_constraint_permutations_for_entitiesSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_datasetsSignalErrorFull() instead")
    void get_datasetsSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void get_datasetsSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_questionsSignalErrorFull() instead")
    void get_questionsSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void get_questionsSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_suggestionsSignalErrorFull() instead")
    void get_suggestionsSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void get_suggestionsSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);
    Q_DECL_DEPRECATED_X("Use get_values_for_variablesSignalErrorFull() instead")
    void get_values_for_variablesSignalEFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, QString error_str);
    void get_values_for_variablesSignalErrorFull(OAIHttpRequestWorker *worker, QNetworkReply::NetworkError error_type, const QString &error_str);

    void abortRequestsSignal();
    void allPendingRequestsCompleted();

public Q_SLOTS:
    void tokenAvailable();
};

} // namespace OpenAPI
#endif
