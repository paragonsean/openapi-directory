/*
 * MIMIC REST API
 * This is the API for MIMIC client to connect to MIMIC daemon.
 *
 * The version of the OpenAPI document: 21.00
 * Contact: support@gambitcomm.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.AgentState;
import org.openapitools.client.model.TimerScript;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for DaemonApi
 */
@Disabled
public class DaemonApiTest {

    private final DaemonApi api = new DaemonApi();

    /**
     * Add a new timer script to be executed at specified interval (in msec) with the specified argument.
     *
     * Add a new timer script to be executed at specified interval (in msec) with the specified argument.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void addDaemonTimerScriptTest() throws ApiException {
        String script = null;
        Integer interval = null;
        String arg = null;
        String response = api.addDaemonTimerScript(script, interval, arg);
        // TODO: test validations
    }

    /**
     * Load the lab configuration file file.
     *
     * Load agents in cfgFile from firstAgentNum to lastAgentNum on startAgentNum of current configuration
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cfgLoadTest() throws ApiException {
        String cfgFile = null;
        Integer firstAgentNum = null;
        Integer lastAgentNum = null;
        Integer startAgentNum = null;
        Map<String, Integer> response = api.cfgLoad(cfgFile, firstAgentNum, lastAgentNum, startAgentNum);
        // TODO: test validations
    }

    /**
     * Clear the lab configuration.
     *
     * Clear the lab configuration.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cfgNewTest() throws ApiException {
        Integer firstAgentNum = null;
        Integer lastAgentNum = null;
        Map<String, Integer> response = api.cfgNew(firstAgentNum, lastAgentNum);
        // TODO: test validations
    }

    /**
     * Save the lab configuration.
     *
     * Save the lab configuration.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cfgSaveTest() throws ApiException {
        Map<String, Integer> response = api.cfgSave();
        // TODO: test validations
    }

    /**
     * Save the lab configuration in file.
     *
     * Save the lab configuration in file.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cfgSaveasTest() throws ApiException {
        String cfgFile = null;
        Integer firstAgentNum = null;
        Integer lastAgentNum = null;
        Map<String, Integer> response = api.cfgSaveas(cfgFile, firstAgentNum, lastAgentNum);
        // TODO: test validations
    }

    /**
     * Remove a timer script from the execution list.
     *
     * The first scheduled script that matches the script name, and optionally the interval and argument will be deleted.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void delDaemonTimerScriptTest() throws ApiException {
        String script = null;
        Integer interval = null;
        String arg = null;
        String response = api.delDaemonTimerScript(script, interval, arg);
        // TODO: test validations
    }

    /**
     * The list of {agentnum {statistics}} for agents that are currently active and whose statistics have changed since the last invocation of this command.
     *
     * This list is guaranteed to be sorted into increasing order.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getActiveDataListTest() throws ApiException {
        List<Integer> response = api.getActiveDataList();
        // TODO: test validations
    }

    /**
     * The list of {agentnum} that are currently active (running or paused).
     *
     * This list is guaranteed to be sorted into increasing order.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getActiveListTest() throws ApiException {
        List<Integer> response = api.getActiveList();
        // TODO: test validations
    }

    /**
     * This predicate indicates if the currently loaded agent configuration file has changed.
     *
     * Whether the loaded agent configuration file has changed since the last time this predicate was queried. This allows for a client to detect agent configuration changes and to synchronize those changes from the MIMIC daemon.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCfgFileChangedTest() throws ApiException {
        Map<String, Integer> response = api.getCfgFileChanged();
        // TODO: test validations
    }

    /**
     * The currently loaded lab configuration file for the particular user.
     *
     * In the case of multi-user access this command returns a different configuration file loaded for each user.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCfgfileTest() throws ApiException {
        Map<String, Integer> response = api.getCfgfile();
        // TODO: test validations
    }

    /**
     * The list of {agentnum} for which a configurable parameter changed.
     *
     * This list contains at most 5000 agent(s), and is guaranteed to be sorted into increasing order.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getChangedConfigListTest() throws ApiException {
        List<Integer> response = api.getChangedConfigList();
        // TODO: test validations
    }

    /**
     * The list of {agentnum state} for which the state changed.
     *
     * This list contains at most 5000 agent(s), and is guaranteed to be sorted into increasing order.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getChangedStateListTest() throws ApiException {
        List<AgentState> response = api.getChangedStateList();
        // TODO: test validations
    }

    /**
     * The number of clients currently connected to the daemon.
     *
     * The number of clients currently connected to the daemon.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getClientsTest() throws ApiException {
        Map<String, Integer> response = api.getClients();
        // TODO: test validations
    }

    /**
     * The list of {agentnum} that are currently configured.
     *
     * This list is guaranteed to be sorted into increasing order.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getConfiguredListTest() throws ApiException {
        List<Integer> response = api.getConfiguredList();
        // TODO: test validations
    }

    /**
     * The set of protocols supported by the Simulator.
     *
     * The set of protocols supported by the Simulator.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDaemonProtocolsTest() throws ApiException {
        Map<String, Integer> response = api.getDaemonProtocols();
        // TODO: test validations
    }

    /**
     * The set of network interfaces that can be used for simulations.
     *
     * The set of network interfaces that can be used for simulations.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getInterfacesTest() throws ApiException {
        Map<String, Integer> response = api.getInterfaces();
        // TODO: test validations
    }

    /**
     * The last configured agent instance.
     *
     * The last configured agent instance.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getLastTest() throws ApiException {
        Integer response = api.getLast();
        // TODO: test validations
    }

    /**
     * The current log file for the Simulator.
     *
     * The current log file for the Simulator.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getLogTest() throws ApiException {
        Map<String, Integer> response = api.getLog();
        // TODO: test validations
    }

    /**
     * The maximum number of agent instances.
     *
     * The maximum number of agent instances.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getMaxTest() throws ApiException {
        Integer response = api.getMax();
        // TODO: test validations
    }

    /**
     * The network address of the host where the MIMIC simulator is running.
     *
     * The network address of the host where the MIMIC simulator is running.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getNetaddrTest() throws ApiException {
        Map<String, Integer> response = api.getNetaddr();
        // TODO: test validations
    }

    /**
     * The default network device to be used for agent addresses.
     *
     * The default network device to be used for agent addresses if the interface is not explicitly specified for an agent.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getNetdevTest() throws ApiException {
        Map<String, Integer> response = api.getNetdev();
        // TODO: test validations
    }

    /**
     * The product number that is licensed.
     *
     * The product number that is licensed.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getProductTest() throws ApiException {
        Map<String, Integer> response = api.getProduct();
        // TODO: test validations
    }

    /**
     * The return mode.
     *
     * The OpenAPI daemon operates in two modes, nocatch, where error returns from MIMIC operations return error; or catch, where the TCL catch semantics are used (these are similar to C++ exceptions)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getReturnTest() throws ApiException {
        Map<String, Integer> response = api.getReturn();
        // TODO: test validations
    }

    /**
     * The version of the MIMIC command interface.
     *
     * The version of the MIMIC command interface.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getVersionTest() throws ApiException {
        String response = api.getVersion();
        // TODO: test validations
    }

    /**
     * List the timer scripts currently running along with the their intervals.
     *
     * The command mimic timer script list lists global timer scripts, the command /mimic/timer/script/{agentNum}/list is the per-agent equivalent NOTE Global timer scripts run globally but within them you can address individual agents using {agentNum}. To schedule timerscripts for an individual agent, use /mimic/timer/script/{agentNum}.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listDaemonTimerScriptsTest() throws ApiException {
        List<TimerScript> response = api.listDaemonTimerScripts();
        // TODO: test validations
    }

    /**
     * Get multiple sets of information about MIMIC, where infoArray is one of the parameters defined in the mimic get command.
     *
     * Get multiple sets of information about MIMIC, where infoArray is one of the parameters defined in the mimic get command.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void mgetInfoTest() throws ApiException {
        List<String> infoArray = null;
        List<Object> response = api.mgetInfo(infoArray);
        // TODO: test validations
    }

    /**
     * The current log file for the Simulator.
     *
     * The current log file for the Simulator.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setLogTest() throws ApiException {
        String body = null;
        String response = api.setLog(body);
        // TODO: test validations
    }

    /**
     * The network address of the host where the MIMIC simulator is running.
     *
     * The network address of the host where the MIMIC simulator is running.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setNetdevTest() throws ApiException {
        Map<String, Integer> response = api.setNetdev();
        // TODO: test validations
    }

    /**
     * Start MIMIC.
     *
     * Start MIMIC.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void startAllAgentsTest() throws ApiException {
        Map<String, Integer> response = api.startAllAgents();
        // TODO: test validations
    }

    /**
     * Stop MIMIC.
     *
     * Stop MIMIC.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void stopAllAgentsTest() throws ApiException {
        Map<String, Integer> response = api.stopAllAgents();
        // TODO: test validations
    }

    /**
     * This command can be used as a predicate to ascertain the existence of a given variable.
     *
     * It returns \&quot;1\&quot; if the variable exists, else \&quot;0\&quot;.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void storeExistsTest() throws ApiException {
        String var = null;
        String response = api.storeExists(var);
        // TODO: test validations
    }

    /**
     * Fetches the value associated with a variable.
     *
     * The value will be returned as a string (like all Tcl values).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void storeGetTest() throws ApiException {
        String var = null;
        String response = api.storeGet(var);
        // TODO: test validations
    }

    /**
     * This command will return the list of variables in the said scope.
     *
     * The list will be a Tcl format list with curly braces \&quot;{}\&quot; around each list element. These elements in turn are space separated.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void storeListTest() throws ApiException {
        List<String> response = api.storeList();
        // TODO: test validations
    }

    /**
     * These commands treat the variable as a list, and allow to replace an entry in the list at the specified index with the specified value. The variable has to already exist.
     *
     * These commands treat the variable as a list, and allow to replace an entry in the list at the specified index with the specified value. The variable has to already exist.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void storeLreplaceTest() throws ApiException {
        String var = null;
        Integer index = null;
        String body = null;
        String response = api.storeLreplace(var, index, body);
        // TODO: test validations
    }

    /**
     * This command can be used as a predicate to ascertain the persistence of a given variable.
     *
     * It returns \&quot;1\&quot; if the variable is persistent, else \&quot;0\&quot;.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void storePersistsTest() throws ApiException {
        String var = null;
        String response = api.storePersists(var);
        // TODO: test validations
    }

    /**
     * This operation flushes all global objects which need to be made persistent to disk.
     *
     * The MIMIC daemon caches persistent objects and their changes, and writes them to disk at program termination. If it were to crash, these changes would be lost. This operation allows to checkpoint the cache, ie. write changes to persistent objects to disk. To save the lab configuration with per-agent persistent information the mimic save operation needs to be used.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void storeSaveTest() throws ApiException {
        Map<String, Integer> response = api.storeSave();
        // TODO: test validations
    }

    /**
     * Set the variable store for the global storage
     *
     * Persist 1 means persistent , 0 means non-persistent
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void storeSetTest() throws ApiException {
        String var = null;
        Integer persist = null;
        String body = null;
        String response = api.storeSet(var, persist, body);
        // TODO: test validations
    }

    /**
     * Deletes a variable which is currently defined.
     *
     * This will cleanup persistent variables if needed
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void storeUnsetTest() throws ApiException {
        String var = null;
        String response = api.storeUnset(var);
        // TODO: test validations
    }

    /**
     * Terminate the MIMIC daemon.
     *
     * Terminate the MIMIC daemon.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void terminateTest() throws ApiException {
        Map<String, Integer> response = api.terminate();
        // TODO: test validations
    }

}
