/**
 * Neblio REST API Suite
 * APIs for Interacting with NTP1 Tokens & The Neblio Blockchain
 *
 * The version of the OpenAPI document: 1.3.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIIssueTokenRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIIssueTokenRequest::OAIIssueTokenRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIIssueTokenRequest::OAIIssueTokenRequest() {
    this->initializeModel();
}

OAIIssueTokenRequest::~OAIIssueTokenRequest() {}

void OAIIssueTokenRequest::initializeModel() {

    m_amount_isSet = false;
    m_amount_isValid = false;

    m_divisibility_isSet = false;
    m_divisibility_isValid = false;

    m_fee_isSet = false;
    m_fee_isValid = false;

    m_flags_isSet = false;
    m_flags_isValid = false;

    m_issue_address_isSet = false;
    m_issue_address_isValid = false;

    m_metadata_isSet = false;
    m_metadata_isValid = false;

    m_reissuable_isSet = false;
    m_reissuable_isValid = false;

    m_transfer_isSet = false;
    m_transfer_isValid = false;
}

void OAIIssueTokenRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIIssueTokenRequest::fromJsonObject(QJsonObject json) {

    m_amount_isValid = ::OpenAPI::fromJsonValue(m_amount, json[QString("amount")]);
    m_amount_isSet = !json[QString("amount")].isNull() && m_amount_isValid;

    m_divisibility_isValid = ::OpenAPI::fromJsonValue(m_divisibility, json[QString("divisibility")]);
    m_divisibility_isSet = !json[QString("divisibility")].isNull() && m_divisibility_isValid;

    m_fee_isValid = ::OpenAPI::fromJsonValue(m_fee, json[QString("fee")]);
    m_fee_isSet = !json[QString("fee")].isNull() && m_fee_isValid;

    m_flags_isValid = ::OpenAPI::fromJsonValue(m_flags, json[QString("flags")]);
    m_flags_isSet = !json[QString("flags")].isNull() && m_flags_isValid;

    m_issue_address_isValid = ::OpenAPI::fromJsonValue(m_issue_address, json[QString("issueAddress")]);
    m_issue_address_isSet = !json[QString("issueAddress")].isNull() && m_issue_address_isValid;

    m_metadata_isValid = ::OpenAPI::fromJsonValue(m_metadata, json[QString("metadata")]);
    m_metadata_isSet = !json[QString("metadata")].isNull() && m_metadata_isValid;

    m_reissuable_isValid = ::OpenAPI::fromJsonValue(m_reissuable, json[QString("reissuable")]);
    m_reissuable_isSet = !json[QString("reissuable")].isNull() && m_reissuable_isValid;

    m_transfer_isValid = ::OpenAPI::fromJsonValue(m_transfer, json[QString("transfer")]);
    m_transfer_isSet = !json[QString("transfer")].isNull() && m_transfer_isValid;
}

QString OAIIssueTokenRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIIssueTokenRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_amount_isSet) {
        obj.insert(QString("amount"), ::OpenAPI::toJsonValue(m_amount));
    }
    if (m_divisibility_isSet) {
        obj.insert(QString("divisibility"), ::OpenAPI::toJsonValue(m_divisibility));
    }
    if (m_fee_isSet) {
        obj.insert(QString("fee"), ::OpenAPI::toJsonValue(m_fee));
    }
    if (m_flags.isSet()) {
        obj.insert(QString("flags"), ::OpenAPI::toJsonValue(m_flags));
    }
    if (m_issue_address_isSet) {
        obj.insert(QString("issueAddress"), ::OpenAPI::toJsonValue(m_issue_address));
    }
    if (m_metadata.isSet()) {
        obj.insert(QString("metadata"), ::OpenAPI::toJsonValue(m_metadata));
    }
    if (m_reissuable_isSet) {
        obj.insert(QString("reissuable"), ::OpenAPI::toJsonValue(m_reissuable));
    }
    if (m_transfer.size() > 0) {
        obj.insert(QString("transfer"), ::OpenAPI::toJsonValue(m_transfer));
    }
    return obj;
}

double OAIIssueTokenRequest::getAmount() const {
    return m_amount;
}
void OAIIssueTokenRequest::setAmount(const double &amount) {
    m_amount = amount;
    m_amount_isSet = true;
}

bool OAIIssueTokenRequest::is_amount_Set() const{
    return m_amount_isSet;
}

bool OAIIssueTokenRequest::is_amount_Valid() const{
    return m_amount_isValid;
}

double OAIIssueTokenRequest::getDivisibility() const {
    return m_divisibility;
}
void OAIIssueTokenRequest::setDivisibility(const double &divisibility) {
    m_divisibility = divisibility;
    m_divisibility_isSet = true;
}

bool OAIIssueTokenRequest::is_divisibility_Set() const{
    return m_divisibility_isSet;
}

bool OAIIssueTokenRequest::is_divisibility_Valid() const{
    return m_divisibility_isValid;
}

double OAIIssueTokenRequest::getFee() const {
    return m_fee;
}
void OAIIssueTokenRequest::setFee(const double &fee) {
    m_fee = fee;
    m_fee_isSet = true;
}

bool OAIIssueTokenRequest::is_fee_Set() const{
    return m_fee_isSet;
}

bool OAIIssueTokenRequest::is_fee_Valid() const{
    return m_fee_isValid;
}

OAIIssueTokenRequest_flags OAIIssueTokenRequest::getFlags() const {
    return m_flags;
}
void OAIIssueTokenRequest::setFlags(const OAIIssueTokenRequest_flags &flags) {
    m_flags = flags;
    m_flags_isSet = true;
}

bool OAIIssueTokenRequest::is_flags_Set() const{
    return m_flags_isSet;
}

bool OAIIssueTokenRequest::is_flags_Valid() const{
    return m_flags_isValid;
}

QString OAIIssueTokenRequest::getIssueAddress() const {
    return m_issue_address;
}
void OAIIssueTokenRequest::setIssueAddress(const QString &issue_address) {
    m_issue_address = issue_address;
    m_issue_address_isSet = true;
}

bool OAIIssueTokenRequest::is_issue_address_Set() const{
    return m_issue_address_isSet;
}

bool OAIIssueTokenRequest::is_issue_address_Valid() const{
    return m_issue_address_isValid;
}

OAIIssueTokenRequest_metadata OAIIssueTokenRequest::getMetadata() const {
    return m_metadata;
}
void OAIIssueTokenRequest::setMetadata(const OAIIssueTokenRequest_metadata &metadata) {
    m_metadata = metadata;
    m_metadata_isSet = true;
}

bool OAIIssueTokenRequest::is_metadata_Set() const{
    return m_metadata_isSet;
}

bool OAIIssueTokenRequest::is_metadata_Valid() const{
    return m_metadata_isValid;
}

bool OAIIssueTokenRequest::isReissuable() const {
    return m_reissuable;
}
void OAIIssueTokenRequest::setReissuable(const bool &reissuable) {
    m_reissuable = reissuable;
    m_reissuable_isSet = true;
}

bool OAIIssueTokenRequest::is_reissuable_Set() const{
    return m_reissuable_isSet;
}

bool OAIIssueTokenRequest::is_reissuable_Valid() const{
    return m_reissuable_isValid;
}

QList<OAIIssueTokenRequest_transfer_inner> OAIIssueTokenRequest::getTransfer() const {
    return m_transfer;
}
void OAIIssueTokenRequest::setTransfer(const QList<OAIIssueTokenRequest_transfer_inner> &transfer) {
    m_transfer = transfer;
    m_transfer_isSet = true;
}

bool OAIIssueTokenRequest::is_transfer_Set() const{
    return m_transfer_isSet;
}

bool OAIIssueTokenRequest::is_transfer_Valid() const{
    return m_transfer_isValid;
}

bool OAIIssueTokenRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_amount_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_divisibility_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_fee_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_flags.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_issue_address_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metadata.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_reissuable_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_transfer.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIIssueTokenRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_amount_isValid && m_divisibility_isValid && m_fee_isValid && m_issue_address_isValid && m_reissuable_isValid && m_transfer_isValid && true;
}

} // namespace OpenAPI
