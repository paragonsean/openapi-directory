/*
 * NPR Station Finder Service
 * Allows clients to look up NPR member station information
 *
 * The version of the OpenAPI document: 3
 * Contact: NPROneEnterprise@npr.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An associative array of brand-related metadata for this station
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:24:01.214324-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class StationBrandData {
  /**
   * The subsection of the radio spectrum -- &#39;AM&#39; or &#39;FM&#39; -- where this station can be heard
   */
  @JsonAdapter(BandEnum.Adapter.class)
  public enum BandEnum {
    FM("FM"),
    
    AM("AM");

    private String value;

    BandEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BandEnum fromValue(String value) {
      for (BandEnum b : BandEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BandEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BandEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BandEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BandEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BandEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BAND = "band";
  @SerializedName(SERIALIZED_NAME_BAND)
  private BandEnum band = BandEnum.FM;

  public static final String SERIALIZED_NAME_CALL = "call";
  @SerializedName(SERIALIZED_NAME_CALL)
  private String call;

  public static final String SERIALIZED_NAME_FREQUENCY = "frequency";
  @SerializedName(SERIALIZED_NAME_FREQUENCY)
  private String frequency;

  public static final String SERIALIZED_NAME_MARKET_CITY = "marketCity";
  @SerializedName(SERIALIZED_NAME_MARKET_CITY)
  private String marketCity;

  public static final String SERIALIZED_NAME_MARKET_STATE = "marketState";
  @SerializedName(SERIALIZED_NAME_MARKET_STATE)
  private String marketState;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_TAGLINE = "tagline";
  @SerializedName(SERIALIZED_NAME_TAGLINE)
  private String tagline = "";

  public StationBrandData() {
  }

  public StationBrandData band(BandEnum band) {
    this.band = band;
    return this;
  }

  /**
   * The subsection of the radio spectrum -- &#39;AM&#39; or &#39;FM&#39; -- where this station can be heard
   * @return band
   */
  @javax.annotation.Nullable
  public BandEnum getBand() {
    return band;
  }

  public void setBand(BandEnum band) {
    this.band = band;
  }


  public StationBrandData call(String call) {
    this.call = call;
    return this;
  }

  /**
   * The three-to-four-letter identifying code for this station. Please use this with caution; most stations prefer to be identified by their &#x60;name&#x60; in client applications instead of &#x60;call&#x60;.
   * @return call
   */
  @javax.annotation.Nullable
  public String getCall() {
    return call;
  }

  public void setCall(String call) {
    this.call = call;
  }


  public StationBrandData frequency(String frequency) {
    this.frequency = frequency;
    return this;
  }

  /**
   * Where on the radio dial the station can be heard. If the &#x60;band&#x60; is AM, the frequency will be between 540 and 1600. If the &#x60;band&#x60; is FM, the frequency will be between 87.8 and 108.0.
   * @return frequency
   */
  @javax.annotation.Nullable
  public String getFrequency() {
    return frequency;
  }

  public void setFrequency(String frequency) {
    this.frequency = frequency;
  }


  public StationBrandData marketCity(String marketCity) {
    this.marketCity = marketCity;
    return this;
  }

  /**
   * The city that the station is most closely associated with. This may or may not be the city the station is licensed in and it may or may not be the city that the station or the station&#39;s antenna is located in.
   * @return marketCity
   */
  @javax.annotation.Nonnull
  public String getMarketCity() {
    return marketCity;
  }

  public void setMarketCity(String marketCity) {
    this.marketCity = marketCity;
  }


  public StationBrandData marketState(String marketState) {
    this.marketState = marketState;
    return this;
  }

  /**
   * The state that the station is most closely associated with. This may or may not be the state the station is licensed in and it may or may not be the state that the station or the station&#39;s antenna is located in.
   * @return marketState
   */
  @javax.annotation.Nonnull
  public String getMarketState() {
    return marketState;
  }

  public void setMarketState(String marketState) {
    this.marketState = marketState;
  }


  public StationBrandData name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The display name for the station. In most cases, this will be the same as &#x60;call&#x60; letters combined with band. When returning networks, it will return the network name (e.g. Minnesota Public Radio).
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public StationBrandData tagline(String tagline) {
    this.tagline = tagline;
    return this;
  }

  /**
   * A short text-logo for the station
   * @return tagline
   */
  @javax.annotation.Nonnull
  public String getTagline() {
    return tagline;
  }

  public void setTagline(String tagline) {
    this.tagline = tagline;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StationBrandData stationBrandData = (StationBrandData) o;
    return Objects.equals(this.band, stationBrandData.band) &&
        Objects.equals(this.call, stationBrandData.call) &&
        Objects.equals(this.frequency, stationBrandData.frequency) &&
        Objects.equals(this.marketCity, stationBrandData.marketCity) &&
        Objects.equals(this.marketState, stationBrandData.marketState) &&
        Objects.equals(this.name, stationBrandData.name) &&
        Objects.equals(this.tagline, stationBrandData.tagline);
  }

  @Override
  public int hashCode() {
    return Objects.hash(band, call, frequency, marketCity, marketState, name, tagline);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StationBrandData {\n");
    sb.append("    band: ").append(toIndentedString(band)).append("\n");
    sb.append("    call: ").append(toIndentedString(call)).append("\n");
    sb.append("    frequency: ").append(toIndentedString(frequency)).append("\n");
    sb.append("    marketCity: ").append(toIndentedString(marketCity)).append("\n");
    sb.append("    marketState: ").append(toIndentedString(marketState)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    tagline: ").append(toIndentedString(tagline)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("band");
    openapiFields.add("call");
    openapiFields.add("frequency");
    openapiFields.add("marketCity");
    openapiFields.add("marketState");
    openapiFields.add("name");
    openapiFields.add("tagline");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("marketCity");
    openapiRequiredFields.add("marketState");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("tagline");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to StationBrandData
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!StationBrandData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in StationBrandData is not found in the empty JSON string", StationBrandData.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!StationBrandData.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `StationBrandData` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : StationBrandData.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("band") != null && !jsonObj.get("band").isJsonNull()) && !jsonObj.get("band").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `band` to be a primitive type in the JSON string but got `%s`", jsonObj.get("band").toString()));
      }
      // validate the optional field `band`
      if (jsonObj.get("band") != null && !jsonObj.get("band").isJsonNull()) {
        BandEnum.validateJsonElement(jsonObj.get("band"));
      }
      if ((jsonObj.get("call") != null && !jsonObj.get("call").isJsonNull()) && !jsonObj.get("call").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `call` to be a primitive type in the JSON string but got `%s`", jsonObj.get("call").toString()));
      }
      if ((jsonObj.get("frequency") != null && !jsonObj.get("frequency").isJsonNull()) && !jsonObj.get("frequency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `frequency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("frequency").toString()));
      }
      if (!jsonObj.get("marketCity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `marketCity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("marketCity").toString()));
      }
      if (!jsonObj.get("marketState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `marketState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("marketState").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (!jsonObj.get("tagline").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tagline` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tagline").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!StationBrandData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'StationBrandData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<StationBrandData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(StationBrandData.class));

       return (TypeAdapter<T>) new TypeAdapter<StationBrandData>() {
           @Override
           public void write(JsonWriter out, StationBrandData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public StationBrandData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of StationBrandData given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of StationBrandData
   * @throws IOException if the JSON string is invalid with respect to StationBrandData
   */
  public static StationBrandData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, StationBrandData.class);
  }

  /**
   * Convert an instance of StationBrandData to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

