/*
 * NPR Authorization Service
 * The interface to our OAuth2 server
 *
 * The version of the OpenAPI document: 2
 * Contact: NPROneEnterprise@npr.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AccessTokenData;
import org.openapitools.client.model.DeviceCodeData;
import java.time.OffsetDateTime;
import org.openapitools.client.model.SimpleError;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AuthorizationApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AuthorizationApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AuthorizationApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createToken
     * @param grantType The type of grant the client is requesting (required)
     * @param clientId The client&#39;s ID, required for all grant types. (required)
     * @param clientSecret The client&#39;s secret, required for all grant types. (required)
     * @param code Required for &#x60;authorization_code&#x60; and &#x60;device_code&#x60; grant types. The authorization code from a successful call to &#x60;/v2/authorize&#x60;, or a device code from a successful call to &#x60;/v2/device&#x60;. (optional)
     * @param redirectUri Required for &#x60;authorization_code&#x60; grant type. The requested redirect_uri. (optional)
     * @param username Required for &#x60;password&#x60; grant type. The email address of an NPR user. (optional)
     * @param password Required for &#x60;password&#x60; grant type. The password that matches the user specified with the username parameter. (optional)
     * @param service Required for &#x60;third_party&#x60; grant type. The name of the third-party login provider. (optional)
     * @param refreshToken Required for &#x60;refresh_token&#x60; grant type. A valid refresh token from a previous successful call to &#x60;POST /v2/token&#x60;. (optional)
     * @param scope Required for third-party developers using the &#x60;device_code&#x60; and &#x60;third_party&#x60; grant types. Optionally used by the &#x60;refresh_token&#x60; grant type. A space-separated list of scope(s) requested by the application. (optional)
     * @param tokenTypeHint A hint about the type of the token submitted for a new access and refresh token. If unspecified, the default value is assumed to be &#x60;refresh_token&#x60;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A new token was successfully created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid (any grant type), the user credentials were invalid (&#x60;password&#x60; grant type), the user has not yet logged in or has purposely denied the request (&#x60;device_code&#x60; grant type), or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public okhttp3.Call createTokenCall(String grantType, String clientId, String clientSecret, String code, String redirectUri, String username, String password, String service, String refreshToken, String scope, String tokenTypeHint, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/token";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (grantType != null) {
            localVarFormParams.put("grant_type", grantType);
        }

        if (clientId != null) {
            localVarFormParams.put("client_id", clientId);
        }

        if (clientSecret != null) {
            localVarFormParams.put("client_secret", clientSecret);
        }

        if (code != null) {
            localVarFormParams.put("code", code);
        }

        if (redirectUri != null) {
            localVarFormParams.put("redirect_uri", redirectUri);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        if (password != null) {
            localVarFormParams.put("password", password);
        }

        if (service != null) {
            localVarFormParams.put("service", service);
        }

        if (refreshToken != null) {
            localVarFormParams.put("refresh_token", refreshToken);
        }

        if (scope != null) {
            localVarFormParams.put("scope", scope);
        }

        if (tokenTypeHint != null) {
            localVarFormParams.put("token_type_hint", tokenTypeHint);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createTokenValidateBeforeCall(String grantType, String clientId, String clientSecret, String code, String redirectUri, String username, String password, String service, String refreshToken, String scope, String tokenTypeHint, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'grantType' is set
        if (grantType == null) {
            throw new ApiException("Missing the required parameter 'grantType' when calling createToken(Async)");
        }

        // verify the required parameter 'clientId' is set
        if (clientId == null) {
            throw new ApiException("Missing the required parameter 'clientId' when calling createToken(Async)");
        }

        // verify the required parameter 'clientSecret' is set
        if (clientSecret == null) {
            throw new ApiException("Missing the required parameter 'clientSecret' when calling createToken(Async)");
        }

        return createTokenCall(grantType, clientId, clientSecret, code, redirectUri, username, password, service, refreshToken, scope, tokenTypeHint, _callback);

    }

    /**
     * Create a new OAuth2 access token
     * Please be aware that the required parameters are contingent on the &#x60;grant_type&#x60; that you select.  For the &#x60;authorization_code&#x60; grant type, you are **required** to pass in the &#x60;code&#x60; and &#x60;redirect_uri&#x60; parameters. &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  For the &#x60;client_credentials&#x60; grant type, you do not need to pass in any additional parameters beyond the basic requirements. &#x60;code&#x60;, &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  For the &#x60;device_code&#x60; grant type, you are **required** to pass in the &#x60;code&#x60; parameter. If you are a third-party developer, you are also required to provide the &#x60;scope&#x60; parameter; see the documentation for &#x60;GET /v2/authorize&#x60; for possible values. &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  For the &#x60;password&#x60; grant type, you are **required** to pass in the &#x60;username&#x60; and &#x60;password&#x60; parameters. The &#x60;code&#x60; and &#x60;redirect_uri&#x60; parameters are ignored. Third-party developers do not have access to this grant type.  For the &#x60;refresh_token&#x60; grant type, you are **required** to pass in the &#x60;refresh_token&#x60; parameter. The &#x60;scope&#x60; parameter can optionally be used to request a different set of scopes than were used in the original request, but it **cannot** contain any scopes that were not previously requested. If not specified, then &#x60;scope&#x60; will be set to whichever scopes were used for the original access token request. If trading in an old non-expiring access token for a refresh-enabled token, set the value of &#x60;refresh_token&#x60; to the access token value and &#x60;token_type_hint&#x60; must be set to &#x60;access_token&#x60;. &#x60;code&#x60;, &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  The &#x60;anonymous_user&#x60; grant type is a custom grant type created by NPR to suit our needs for functionality such as our &amp;quot;try-before-you-buy&amp;quot; experience. If you are a third-party developer, you will not have access to this grant type unless we have explicitly given you permission within our system. For this grant type, if you are a third-party developer, you are required to provide the &#x60;scope&#x60; parameter; see the documentation for &#x60;GET /v2/authorize&#x60; for possible values. &#x60;code&#x60;, &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  The &#x60;third_party&#x60; grant type is another custom grant type created by NPR to handle login via third-party providers such as Facebook and Google. If you are a third-party developer, you will not have access to this grant types unless we have explicitly given you permission within our system. For this grant type, you are **required** to pass in the &#x60;service&#x60; and &#x60;token&#x60; parameters. If you are a third-party developer, you are also required to provide the &#x60;scope&#x60; parameter; see the documentation for &#x60;GET /v2/authorize&#x60; for possible values. The &#x60;code&#x60; and &#x60;redirect_uri&#x60; parameters are ignored.  If you are unsure of which grant type to select, assume that &#x60;authorization_code&#x60; is the one you want.  Note that at this time, refresh tokens are an opt-in feature; however, in the future, they will gradually transition to being opt-out, and ultimately required for all clients. Our general guidance at this time is that if this endpoint starts returning refresh tokens for you, you are responsible for implementing the code to handle them appropriately in accordance with the OAuth 2.0 spec. For more information about our gradual rollout of this feature, please contact the NPR One API team.
     * @param grantType The type of grant the client is requesting (required)
     * @param clientId The client&#39;s ID, required for all grant types. (required)
     * @param clientSecret The client&#39;s secret, required for all grant types. (required)
     * @param code Required for &#x60;authorization_code&#x60; and &#x60;device_code&#x60; grant types. The authorization code from a successful call to &#x60;/v2/authorize&#x60;, or a device code from a successful call to &#x60;/v2/device&#x60;. (optional)
     * @param redirectUri Required for &#x60;authorization_code&#x60; grant type. The requested redirect_uri. (optional)
     * @param username Required for &#x60;password&#x60; grant type. The email address of an NPR user. (optional)
     * @param password Required for &#x60;password&#x60; grant type. The password that matches the user specified with the username parameter. (optional)
     * @param service Required for &#x60;third_party&#x60; grant type. The name of the third-party login provider. (optional)
     * @param refreshToken Required for &#x60;refresh_token&#x60; grant type. A valid refresh token from a previous successful call to &#x60;POST /v2/token&#x60;. (optional)
     * @param scope Required for third-party developers using the &#x60;device_code&#x60; and &#x60;third_party&#x60; grant types. Optionally used by the &#x60;refresh_token&#x60; grant type. A space-separated list of scope(s) requested by the application. (optional)
     * @param tokenTypeHint A hint about the type of the token submitted for a new access and refresh token. If unspecified, the default value is assumed to be &#x60;refresh_token&#x60;. (optional)
     * @return AccessTokenData
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A new token was successfully created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid (any grant type), the user credentials were invalid (&#x60;password&#x60; grant type), the user has not yet logged in or has purposely denied the request (&#x60;device_code&#x60; grant type), or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public AccessTokenData createToken(String grantType, String clientId, String clientSecret, String code, String redirectUri, String username, String password, String service, String refreshToken, String scope, String tokenTypeHint) throws ApiException {
        ApiResponse<AccessTokenData> localVarResp = createTokenWithHttpInfo(grantType, clientId, clientSecret, code, redirectUri, username, password, service, refreshToken, scope, tokenTypeHint);
        return localVarResp.getData();
    }

    /**
     * Create a new OAuth2 access token
     * Please be aware that the required parameters are contingent on the &#x60;grant_type&#x60; that you select.  For the &#x60;authorization_code&#x60; grant type, you are **required** to pass in the &#x60;code&#x60; and &#x60;redirect_uri&#x60; parameters. &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  For the &#x60;client_credentials&#x60; grant type, you do not need to pass in any additional parameters beyond the basic requirements. &#x60;code&#x60;, &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  For the &#x60;device_code&#x60; grant type, you are **required** to pass in the &#x60;code&#x60; parameter. If you are a third-party developer, you are also required to provide the &#x60;scope&#x60; parameter; see the documentation for &#x60;GET /v2/authorize&#x60; for possible values. &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  For the &#x60;password&#x60; grant type, you are **required** to pass in the &#x60;username&#x60; and &#x60;password&#x60; parameters. The &#x60;code&#x60; and &#x60;redirect_uri&#x60; parameters are ignored. Third-party developers do not have access to this grant type.  For the &#x60;refresh_token&#x60; grant type, you are **required** to pass in the &#x60;refresh_token&#x60; parameter. The &#x60;scope&#x60; parameter can optionally be used to request a different set of scopes than were used in the original request, but it **cannot** contain any scopes that were not previously requested. If not specified, then &#x60;scope&#x60; will be set to whichever scopes were used for the original access token request. If trading in an old non-expiring access token for a refresh-enabled token, set the value of &#x60;refresh_token&#x60; to the access token value and &#x60;token_type_hint&#x60; must be set to &#x60;access_token&#x60;. &#x60;code&#x60;, &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  The &#x60;anonymous_user&#x60; grant type is a custom grant type created by NPR to suit our needs for functionality such as our &amp;quot;try-before-you-buy&amp;quot; experience. If you are a third-party developer, you will not have access to this grant type unless we have explicitly given you permission within our system. For this grant type, if you are a third-party developer, you are required to provide the &#x60;scope&#x60; parameter; see the documentation for &#x60;GET /v2/authorize&#x60; for possible values. &#x60;code&#x60;, &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  The &#x60;third_party&#x60; grant type is another custom grant type created by NPR to handle login via third-party providers such as Facebook and Google. If you are a third-party developer, you will not have access to this grant types unless we have explicitly given you permission within our system. For this grant type, you are **required** to pass in the &#x60;service&#x60; and &#x60;token&#x60; parameters. If you are a third-party developer, you are also required to provide the &#x60;scope&#x60; parameter; see the documentation for &#x60;GET /v2/authorize&#x60; for possible values. The &#x60;code&#x60; and &#x60;redirect_uri&#x60; parameters are ignored.  If you are unsure of which grant type to select, assume that &#x60;authorization_code&#x60; is the one you want.  Note that at this time, refresh tokens are an opt-in feature; however, in the future, they will gradually transition to being opt-out, and ultimately required for all clients. Our general guidance at this time is that if this endpoint starts returning refresh tokens for you, you are responsible for implementing the code to handle them appropriately in accordance with the OAuth 2.0 spec. For more information about our gradual rollout of this feature, please contact the NPR One API team.
     * @param grantType The type of grant the client is requesting (required)
     * @param clientId The client&#39;s ID, required for all grant types. (required)
     * @param clientSecret The client&#39;s secret, required for all grant types. (required)
     * @param code Required for &#x60;authorization_code&#x60; and &#x60;device_code&#x60; grant types. The authorization code from a successful call to &#x60;/v2/authorize&#x60;, or a device code from a successful call to &#x60;/v2/device&#x60;. (optional)
     * @param redirectUri Required for &#x60;authorization_code&#x60; grant type. The requested redirect_uri. (optional)
     * @param username Required for &#x60;password&#x60; grant type. The email address of an NPR user. (optional)
     * @param password Required for &#x60;password&#x60; grant type. The password that matches the user specified with the username parameter. (optional)
     * @param service Required for &#x60;third_party&#x60; grant type. The name of the third-party login provider. (optional)
     * @param refreshToken Required for &#x60;refresh_token&#x60; grant type. A valid refresh token from a previous successful call to &#x60;POST /v2/token&#x60;. (optional)
     * @param scope Required for third-party developers using the &#x60;device_code&#x60; and &#x60;third_party&#x60; grant types. Optionally used by the &#x60;refresh_token&#x60; grant type. A space-separated list of scope(s) requested by the application. (optional)
     * @param tokenTypeHint A hint about the type of the token submitted for a new access and refresh token. If unspecified, the default value is assumed to be &#x60;refresh_token&#x60;. (optional)
     * @return ApiResponse&lt;AccessTokenData&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A new token was successfully created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid (any grant type), the user credentials were invalid (&#x60;password&#x60; grant type), the user has not yet logged in or has purposely denied the request (&#x60;device_code&#x60; grant type), or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public ApiResponse<AccessTokenData> createTokenWithHttpInfo(String grantType, String clientId, String clientSecret, String code, String redirectUri, String username, String password, String service, String refreshToken, String scope, String tokenTypeHint) throws ApiException {
        okhttp3.Call localVarCall = createTokenValidateBeforeCall(grantType, clientId, clientSecret, code, redirectUri, username, password, service, refreshToken, scope, tokenTypeHint, null);
        Type localVarReturnType = new TypeToken<AccessTokenData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a new OAuth2 access token (asynchronously)
     * Please be aware that the required parameters are contingent on the &#x60;grant_type&#x60; that you select.  For the &#x60;authorization_code&#x60; grant type, you are **required** to pass in the &#x60;code&#x60; and &#x60;redirect_uri&#x60; parameters. &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  For the &#x60;client_credentials&#x60; grant type, you do not need to pass in any additional parameters beyond the basic requirements. &#x60;code&#x60;, &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  For the &#x60;device_code&#x60; grant type, you are **required** to pass in the &#x60;code&#x60; parameter. If you are a third-party developer, you are also required to provide the &#x60;scope&#x60; parameter; see the documentation for &#x60;GET /v2/authorize&#x60; for possible values. &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  For the &#x60;password&#x60; grant type, you are **required** to pass in the &#x60;username&#x60; and &#x60;password&#x60; parameters. The &#x60;code&#x60; and &#x60;redirect_uri&#x60; parameters are ignored. Third-party developers do not have access to this grant type.  For the &#x60;refresh_token&#x60; grant type, you are **required** to pass in the &#x60;refresh_token&#x60; parameter. The &#x60;scope&#x60; parameter can optionally be used to request a different set of scopes than were used in the original request, but it **cannot** contain any scopes that were not previously requested. If not specified, then &#x60;scope&#x60; will be set to whichever scopes were used for the original access token request. If trading in an old non-expiring access token for a refresh-enabled token, set the value of &#x60;refresh_token&#x60; to the access token value and &#x60;token_type_hint&#x60; must be set to &#x60;access_token&#x60;. &#x60;code&#x60;, &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  The &#x60;anonymous_user&#x60; grant type is a custom grant type created by NPR to suit our needs for functionality such as our &amp;quot;try-before-you-buy&amp;quot; experience. If you are a third-party developer, you will not have access to this grant type unless we have explicitly given you permission within our system. For this grant type, if you are a third-party developer, you are required to provide the &#x60;scope&#x60; parameter; see the documentation for &#x60;GET /v2/authorize&#x60; for possible values. &#x60;code&#x60;, &#x60;redirect_uri&#x60;, &#x60;service&#x60;, &#x60;username&#x60; and &#x60;password&#x60; parameters will be ignored.  The &#x60;third_party&#x60; grant type is another custom grant type created by NPR to handle login via third-party providers such as Facebook and Google. If you are a third-party developer, you will not have access to this grant types unless we have explicitly given you permission within our system. For this grant type, you are **required** to pass in the &#x60;service&#x60; and &#x60;token&#x60; parameters. If you are a third-party developer, you are also required to provide the &#x60;scope&#x60; parameter; see the documentation for &#x60;GET /v2/authorize&#x60; for possible values. The &#x60;code&#x60; and &#x60;redirect_uri&#x60; parameters are ignored.  If you are unsure of which grant type to select, assume that &#x60;authorization_code&#x60; is the one you want.  Note that at this time, refresh tokens are an opt-in feature; however, in the future, they will gradually transition to being opt-out, and ultimately required for all clients. Our general guidance at this time is that if this endpoint starts returning refresh tokens for you, you are responsible for implementing the code to handle them appropriately in accordance with the OAuth 2.0 spec. For more information about our gradual rollout of this feature, please contact the NPR One API team.
     * @param grantType The type of grant the client is requesting (required)
     * @param clientId The client&#39;s ID, required for all grant types. (required)
     * @param clientSecret The client&#39;s secret, required for all grant types. (required)
     * @param code Required for &#x60;authorization_code&#x60; and &#x60;device_code&#x60; grant types. The authorization code from a successful call to &#x60;/v2/authorize&#x60;, or a device code from a successful call to &#x60;/v2/device&#x60;. (optional)
     * @param redirectUri Required for &#x60;authorization_code&#x60; grant type. The requested redirect_uri. (optional)
     * @param username Required for &#x60;password&#x60; grant type. The email address of an NPR user. (optional)
     * @param password Required for &#x60;password&#x60; grant type. The password that matches the user specified with the username parameter. (optional)
     * @param service Required for &#x60;third_party&#x60; grant type. The name of the third-party login provider. (optional)
     * @param refreshToken Required for &#x60;refresh_token&#x60; grant type. A valid refresh token from a previous successful call to &#x60;POST /v2/token&#x60;. (optional)
     * @param scope Required for third-party developers using the &#x60;device_code&#x60; and &#x60;third_party&#x60; grant types. Optionally used by the &#x60;refresh_token&#x60; grant type. A space-separated list of scope(s) requested by the application. (optional)
     * @param tokenTypeHint A hint about the type of the token submitted for a new access and refresh token. If unspecified, the default value is assumed to be &#x60;refresh_token&#x60;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A new token was successfully created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid (any grant type), the user credentials were invalid (&#x60;password&#x60; grant type), the user has not yet logged in or has purposely denied the request (&#x60;device_code&#x60; grant type), or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public okhttp3.Call createTokenAsync(String grantType, String clientId, String clientSecret, String code, String redirectUri, String username, String password, String service, String refreshToken, String scope, String tokenTypeHint, final ApiCallback<AccessTokenData> _callback) throws ApiException {

        okhttp3.Call localVarCall = createTokenValidateBeforeCall(grantType, clientId, clientSecret, code, redirectUri, username, password, service, refreshToken, scope, tokenTypeHint, _callback);
        Type localVarReturnType = new TypeToken<AccessTokenData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for generateDeviceCode
     * @param clientId The client&#39;s ID (required)
     * @param clientSecret The client&#39;s secret key (required)
     * @param scope A space-separated list of scope(s) requested by the application. Required for all untrusted clients; will be ignored for trusted clients. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> We have generated a unique device code and user code. These will only be valid for the amount of time specified in the &#x60;expires_in&#x60; field; if the user does not complete the login process in that amount of time, the client will need to request a new set of codes. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public okhttp3.Call generateDeviceCodeCall(String clientId, String clientSecret, String scope, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/device";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clientId != null) {
            localVarFormParams.put("client_id", clientId);
        }

        if (clientSecret != null) {
            localVarFormParams.put("client_secret", clientSecret);
        }

        if (scope != null) {
            localVarFormParams.put("scope", scope);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call generateDeviceCodeValidateBeforeCall(String clientId, String clientSecret, String scope, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clientId' is set
        if (clientId == null) {
            throw new ApiException("Missing the required parameter 'clientId' when calling generateDeviceCode(Async)");
        }

        // verify the required parameter 'clientSecret' is set
        if (clientSecret == null) {
            throw new ApiException("Missing the required parameter 'clientSecret' when calling generateDeviceCode(Async)");
        }

        return generateDeviceCodeCall(clientId, clientSecret, scope, _callback);

    }

    /**
     * Initiate an OAuth2 login flow for limited input devices
     * This flow should only be used by clients who cannot show a native webview or do not have advanced input controls. It is an alternative to &#x60;GET /v2/authorize&#x60;.  Third-party clients will need to use one or the other of these two endpoints, but they will generally not use both.
     * @param clientId The client&#39;s ID (required)
     * @param clientSecret The client&#39;s secret key (required)
     * @param scope A space-separated list of scope(s) requested by the application. Required for all untrusted clients; will be ignored for trusted clients. (optional)
     * @return DeviceCodeData
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> We have generated a unique device code and user code. These will only be valid for the amount of time specified in the &#x60;expires_in&#x60; field; if the user does not complete the login process in that amount of time, the client will need to request a new set of codes. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public DeviceCodeData generateDeviceCode(String clientId, String clientSecret, String scope) throws ApiException {
        ApiResponse<DeviceCodeData> localVarResp = generateDeviceCodeWithHttpInfo(clientId, clientSecret, scope);
        return localVarResp.getData();
    }

    /**
     * Initiate an OAuth2 login flow for limited input devices
     * This flow should only be used by clients who cannot show a native webview or do not have advanced input controls. It is an alternative to &#x60;GET /v2/authorize&#x60;.  Third-party clients will need to use one or the other of these two endpoints, but they will generally not use both.
     * @param clientId The client&#39;s ID (required)
     * @param clientSecret The client&#39;s secret key (required)
     * @param scope A space-separated list of scope(s) requested by the application. Required for all untrusted clients; will be ignored for trusted clients. (optional)
     * @return ApiResponse&lt;DeviceCodeData&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> We have generated a unique device code and user code. These will only be valid for the amount of time specified in the &#x60;expires_in&#x60; field; if the user does not complete the login process in that amount of time, the client will need to request a new set of codes. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public ApiResponse<DeviceCodeData> generateDeviceCodeWithHttpInfo(String clientId, String clientSecret, String scope) throws ApiException {
        okhttp3.Call localVarCall = generateDeviceCodeValidateBeforeCall(clientId, clientSecret, scope, null);
        Type localVarReturnType = new TypeToken<DeviceCodeData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Initiate an OAuth2 login flow for limited input devices (asynchronously)
     * This flow should only be used by clients who cannot show a native webview or do not have advanced input controls. It is an alternative to &#x60;GET /v2/authorize&#x60;.  Third-party clients will need to use one or the other of these two endpoints, but they will generally not use both.
     * @param clientId The client&#39;s ID (required)
     * @param clientSecret The client&#39;s secret key (required)
     * @param scope A space-separated list of scope(s) requested by the application. Required for all untrusted clients; will be ignored for trusted clients. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> We have generated a unique device code and user code. These will only be valid for the amount of time specified in the &#x60;expires_in&#x60; field; if the user does not complete the login process in that amount of time, the client will need to request a new set of codes. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public okhttp3.Call generateDeviceCodeAsync(String clientId, String clientSecret, String scope, final ApiCallback<DeviceCodeData> _callback) throws ApiException {

        okhttp3.Call localVarCall = generateDeviceCodeValidateBeforeCall(clientId, clientSecret, scope, _callback);
        Type localVarReturnType = new TypeToken<DeviceCodeData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for revokeToken
     * @param authorization A &#x60;client_credentials&#x60; access token from the same client application as the token being revoked. Should start with &#x60;Bearer&#x60;, followed by a space, followed by the token. (required)
     * @param token The access token or refresh token that the client wants to have revoked. (required)
     * @param tokenTypeHint A hint about the type of the token submitted for revocation. If unspecified, the default value is assumed to be &#x60;access_token&#x60;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The old token was successfully revoked </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The client associated with the access token in the header does not own the access token that this request is attempting to revoke. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public okhttp3.Call revokeTokenCall(String authorization, String token, String tokenTypeHint, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/token/revoke";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarFormParams.put("token", token);
        }

        if (tokenTypeHint != null) {
            localVarFormParams.put("token_type_hint", tokenTypeHint);
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call revokeTokenValidateBeforeCall(String authorization, String token, String tokenTypeHint, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling revokeToken(Async)");
        }

        // verify the required parameter 'token' is set
        if (token == null) {
            throw new ApiException("Missing the required parameter 'token' when calling revokeToken(Async)");
        }

        return revokeTokenCall(authorization, token, tokenTypeHint, _callback);

    }

    /**
     * Revoke an existing OAuth2 access token
     * Our implementation follows the proposed IETF specification [RFC-7009](https://tools.ietf.org/html/rfc7009).  If your client application offers the ability to for a logged-in user to log out, and you have access to a long-lived &#x60;client_credentials&#x60; token (i.e. you have generated one that you are storing securely for the lifetime of the entire app install), we suggest (but do not require) that you call this endpoint and revoke the access token belonging to the logged-in user as part of your logout process. If you do not already have a long-lived &#x60;client_credentials&#x60; token, please don&#39;t generate one just for the purposes of calling this endpoint.  If you are building a prototype application, we also recommend that you use this endpoint to clean up access tokens that you generate during the testing of your app and do not intend to reuse.  Note that revoking an access token will automatically revoke any refresh tokens associated with it, and vice-versa.
     * @param authorization A &#x60;client_credentials&#x60; access token from the same client application as the token being revoked. Should start with &#x60;Bearer&#x60;, followed by a space, followed by the token. (required)
     * @param token The access token or refresh token that the client wants to have revoked. (required)
     * @param tokenTypeHint A hint about the type of the token submitted for revocation. If unspecified, the default value is assumed to be &#x60;access_token&#x60;. (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The old token was successfully revoked </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The client associated with the access token in the header does not own the access token that this request is attempting to revoke. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public Object revokeToken(String authorization, String token, String tokenTypeHint) throws ApiException {
        ApiResponse<Object> localVarResp = revokeTokenWithHttpInfo(authorization, token, tokenTypeHint);
        return localVarResp.getData();
    }

    /**
     * Revoke an existing OAuth2 access token
     * Our implementation follows the proposed IETF specification [RFC-7009](https://tools.ietf.org/html/rfc7009).  If your client application offers the ability to for a logged-in user to log out, and you have access to a long-lived &#x60;client_credentials&#x60; token (i.e. you have generated one that you are storing securely for the lifetime of the entire app install), we suggest (but do not require) that you call this endpoint and revoke the access token belonging to the logged-in user as part of your logout process. If you do not already have a long-lived &#x60;client_credentials&#x60; token, please don&#39;t generate one just for the purposes of calling this endpoint.  If you are building a prototype application, we also recommend that you use this endpoint to clean up access tokens that you generate during the testing of your app and do not intend to reuse.  Note that revoking an access token will automatically revoke any refresh tokens associated with it, and vice-versa.
     * @param authorization A &#x60;client_credentials&#x60; access token from the same client application as the token being revoked. Should start with &#x60;Bearer&#x60;, followed by a space, followed by the token. (required)
     * @param token The access token or refresh token that the client wants to have revoked. (required)
     * @param tokenTypeHint A hint about the type of the token submitted for revocation. If unspecified, the default value is assumed to be &#x60;access_token&#x60;. (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The old token was successfully revoked </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The client associated with the access token in the header does not own the access token that this request is attempting to revoke. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public ApiResponse<Object> revokeTokenWithHttpInfo(String authorization, String token, String tokenTypeHint) throws ApiException {
        okhttp3.Call localVarCall = revokeTokenValidateBeforeCall(authorization, token, tokenTypeHint, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Revoke an existing OAuth2 access token (asynchronously)
     * Our implementation follows the proposed IETF specification [RFC-7009](https://tools.ietf.org/html/rfc7009).  If your client application offers the ability to for a logged-in user to log out, and you have access to a long-lived &#x60;client_credentials&#x60; token (i.e. you have generated one that you are storing securely for the lifetime of the entire app install), we suggest (but do not require) that you call this endpoint and revoke the access token belonging to the logged-in user as part of your logout process. If you do not already have a long-lived &#x60;client_credentials&#x60; token, please don&#39;t generate one just for the purposes of calling this endpoint.  If you are building a prototype application, we also recommend that you use this endpoint to clean up access tokens that you generate during the testing of your app and do not intend to reuse.  Note that revoking an access token will automatically revoke any refresh tokens associated with it, and vice-versa.
     * @param authorization A &#x60;client_credentials&#x60; access token from the same client application as the token being revoked. Should start with &#x60;Bearer&#x60;, followed by a space, followed by the token. (required)
     * @param token The access token or refresh token that the client wants to have revoked. (required)
     * @param tokenTypeHint A hint about the type of the token submitted for revocation. If unspecified, the default value is assumed to be &#x60;access_token&#x60;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The old token was successfully revoked </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> A bad request; generally, one or more parameters passed in were incorrect or missing </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The client credentials were invalid or the authorization server denied the request. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The client associated with the access token in the header does not own the access token that this request is attempting to revoke. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> A server error </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> The system is undergoing maintenance and we are unable to fulfill this request. Look for a &#x60;Retry-After&#x60; header to see the predicted time the system will be back up. </td><td>  * Retry-After - The predicted time the system will be back up <br>  </td></tr>
     </table>
     */
    public okhttp3.Call revokeTokenAsync(String authorization, String token, String tokenTypeHint, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = revokeTokenValidateBeforeCall(authorization, token, tokenTypeHint, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
