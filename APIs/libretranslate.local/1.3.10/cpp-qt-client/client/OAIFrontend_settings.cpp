/**
 * LibreTranslate
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.3.10
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIFrontend_settings.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIFrontend_settings::OAIFrontend_settings(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIFrontend_settings::OAIFrontend_settings() {
    this->initializeModel();
}

OAIFrontend_settings::~OAIFrontend_settings() {}

void OAIFrontend_settings::initializeModel() {

    m_api_keys_isSet = false;
    m_api_keys_isValid = false;

    m_char_limit_isSet = false;
    m_char_limit_isValid = false;

    m_frontend_timeout_isSet = false;
    m_frontend_timeout_isValid = false;

    m_key_required_isSet = false;
    m_key_required_isValid = false;

    m_language_isSet = false;
    m_language_isValid = false;

    m_suggestions_isSet = false;
    m_suggestions_isValid = false;

    m_supported_files_format_isSet = false;
    m_supported_files_format_isValid = false;
}

void OAIFrontend_settings::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIFrontend_settings::fromJsonObject(QJsonObject json) {

    m_api_keys_isValid = ::OpenAPI::fromJsonValue(m_api_keys, json[QString("apiKeys")]);
    m_api_keys_isSet = !json[QString("apiKeys")].isNull() && m_api_keys_isValid;

    m_char_limit_isValid = ::OpenAPI::fromJsonValue(m_char_limit, json[QString("charLimit")]);
    m_char_limit_isSet = !json[QString("charLimit")].isNull() && m_char_limit_isValid;

    m_frontend_timeout_isValid = ::OpenAPI::fromJsonValue(m_frontend_timeout, json[QString("frontendTimeout")]);
    m_frontend_timeout_isSet = !json[QString("frontendTimeout")].isNull() && m_frontend_timeout_isValid;

    m_key_required_isValid = ::OpenAPI::fromJsonValue(m_key_required, json[QString("keyRequired")]);
    m_key_required_isSet = !json[QString("keyRequired")].isNull() && m_key_required_isValid;

    m_language_isValid = ::OpenAPI::fromJsonValue(m_language, json[QString("language")]);
    m_language_isSet = !json[QString("language")].isNull() && m_language_isValid;

    m_suggestions_isValid = ::OpenAPI::fromJsonValue(m_suggestions, json[QString("suggestions")]);
    m_suggestions_isSet = !json[QString("suggestions")].isNull() && m_suggestions_isValid;

    m_supported_files_format_isValid = ::OpenAPI::fromJsonValue(m_supported_files_format, json[QString("supportedFilesFormat")]);
    m_supported_files_format_isSet = !json[QString("supportedFilesFormat")].isNull() && m_supported_files_format_isValid;
}

QString OAIFrontend_settings::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIFrontend_settings::asJsonObject() const {
    QJsonObject obj;
    if (m_api_keys_isSet) {
        obj.insert(QString("apiKeys"), ::OpenAPI::toJsonValue(m_api_keys));
    }
    if (m_char_limit_isSet) {
        obj.insert(QString("charLimit"), ::OpenAPI::toJsonValue(m_char_limit));
    }
    if (m_frontend_timeout_isSet) {
        obj.insert(QString("frontendTimeout"), ::OpenAPI::toJsonValue(m_frontend_timeout));
    }
    if (m_key_required_isSet) {
        obj.insert(QString("keyRequired"), ::OpenAPI::toJsonValue(m_key_required));
    }
    if (m_language.isSet()) {
        obj.insert(QString("language"), ::OpenAPI::toJsonValue(m_language));
    }
    if (m_suggestions_isSet) {
        obj.insert(QString("suggestions"), ::OpenAPI::toJsonValue(m_suggestions));
    }
    if (m_supported_files_format.size() > 0) {
        obj.insert(QString("supportedFilesFormat"), ::OpenAPI::toJsonValue(m_supported_files_format));
    }
    return obj;
}

bool OAIFrontend_settings::isApiKeys() const {
    return m_api_keys;
}
void OAIFrontend_settings::setApiKeys(const bool &api_keys) {
    m_api_keys = api_keys;
    m_api_keys_isSet = true;
}

bool OAIFrontend_settings::is_api_keys_Set() const{
    return m_api_keys_isSet;
}

bool OAIFrontend_settings::is_api_keys_Valid() const{
    return m_api_keys_isValid;
}

qint32 OAIFrontend_settings::getCharLimit() const {
    return m_char_limit;
}
void OAIFrontend_settings::setCharLimit(const qint32 &char_limit) {
    m_char_limit = char_limit;
    m_char_limit_isSet = true;
}

bool OAIFrontend_settings::is_char_limit_Set() const{
    return m_char_limit_isSet;
}

bool OAIFrontend_settings::is_char_limit_Valid() const{
    return m_char_limit_isValid;
}

qint32 OAIFrontend_settings::getFrontendTimeout() const {
    return m_frontend_timeout;
}
void OAIFrontend_settings::setFrontendTimeout(const qint32 &frontend_timeout) {
    m_frontend_timeout = frontend_timeout;
    m_frontend_timeout_isSet = true;
}

bool OAIFrontend_settings::is_frontend_timeout_Set() const{
    return m_frontend_timeout_isSet;
}

bool OAIFrontend_settings::is_frontend_timeout_Valid() const{
    return m_frontend_timeout_isValid;
}

bool OAIFrontend_settings::isKeyRequired() const {
    return m_key_required;
}
void OAIFrontend_settings::setKeyRequired(const bool &key_required) {
    m_key_required = key_required;
    m_key_required_isSet = true;
}

bool OAIFrontend_settings::is_key_required_Set() const{
    return m_key_required_isSet;
}

bool OAIFrontend_settings::is_key_required_Valid() const{
    return m_key_required_isValid;
}

OAIFrontend_settings_language OAIFrontend_settings::getLanguage() const {
    return m_language;
}
void OAIFrontend_settings::setLanguage(const OAIFrontend_settings_language &language) {
    m_language = language;
    m_language_isSet = true;
}

bool OAIFrontend_settings::is_language_Set() const{
    return m_language_isSet;
}

bool OAIFrontend_settings::is_language_Valid() const{
    return m_language_isValid;
}

bool OAIFrontend_settings::isSuggestions() const {
    return m_suggestions;
}
void OAIFrontend_settings::setSuggestions(const bool &suggestions) {
    m_suggestions = suggestions;
    m_suggestions_isSet = true;
}

bool OAIFrontend_settings::is_suggestions_Set() const{
    return m_suggestions_isSet;
}

bool OAIFrontend_settings::is_suggestions_Valid() const{
    return m_suggestions_isValid;
}

QList<QString> OAIFrontend_settings::getSupportedFilesFormat() const {
    return m_supported_files_format;
}
void OAIFrontend_settings::setSupportedFilesFormat(const QList<QString> &supported_files_format) {
    m_supported_files_format = supported_files_format;
    m_supported_files_format_isSet = true;
}

bool OAIFrontend_settings::is_supported_files_format_Set() const{
    return m_supported_files_format_isSet;
}

bool OAIFrontend_settings::is_supported_files_format_Valid() const{
    return m_supported_files_format_isValid;
}

bool OAIFrontend_settings::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_api_keys_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_char_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_frontend_timeout_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_key_required_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_language.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_suggestions_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_supported_files_format.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIFrontend_settings::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
