/*
 * Telegram Bot API
 * Auto-generated OpenAPI schema
 *
 * The version of the OpenAPI document: 5.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.MessageEntity;
import org.openapitools.client.model.PollOption;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This object contains information about a poll.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:56:27.961160-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Poll {
  public static final String SERIALIZED_NAME_ALLOWS_MULTIPLE_ANSWERS = "allows_multiple_answers";
  @SerializedName(SERIALIZED_NAME_ALLOWS_MULTIPLE_ANSWERS)
  private Boolean allowsMultipleAnswers;

  public static final String SERIALIZED_NAME_CLOSE_DATE = "close_date";
  @SerializedName(SERIALIZED_NAME_CLOSE_DATE)
  private Integer closeDate;

  public static final String SERIALIZED_NAME_CORRECT_OPTION_ID = "correct_option_id";
  @SerializedName(SERIALIZED_NAME_CORRECT_OPTION_ID)
  private Integer correctOptionId;

  public static final String SERIALIZED_NAME_EXPLANATION = "explanation";
  @SerializedName(SERIALIZED_NAME_EXPLANATION)
  private String explanation;

  public static final String SERIALIZED_NAME_EXPLANATION_ENTITIES = "explanation_entities";
  @SerializedName(SERIALIZED_NAME_EXPLANATION_ENTITIES)
  private List<MessageEntity> explanationEntities = new ArrayList<>();

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IS_ANONYMOUS = "is_anonymous";
  @SerializedName(SERIALIZED_NAME_IS_ANONYMOUS)
  private Boolean isAnonymous;

  public static final String SERIALIZED_NAME_IS_CLOSED = "is_closed";
  @SerializedName(SERIALIZED_NAME_IS_CLOSED)
  private Boolean isClosed;

  public static final String SERIALIZED_NAME_OPEN_PERIOD = "open_period";
  @SerializedName(SERIALIZED_NAME_OPEN_PERIOD)
  private Integer openPeriod;

  public static final String SERIALIZED_NAME_OPTIONS = "options";
  @SerializedName(SERIALIZED_NAME_OPTIONS)
  private List<PollOption> options = new ArrayList<>();

  public static final String SERIALIZED_NAME_QUESTION = "question";
  @SerializedName(SERIALIZED_NAME_QUESTION)
  private String question;

  public static final String SERIALIZED_NAME_TOTAL_VOTER_COUNT = "total_voter_count";
  @SerializedName(SERIALIZED_NAME_TOTAL_VOTER_COUNT)
  private Integer totalVoterCount;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public Poll() {
  }

  public Poll allowsMultipleAnswers(Boolean allowsMultipleAnswers) {
    this.allowsMultipleAnswers = allowsMultipleAnswers;
    return this;
  }

  /**
   * True, if the poll allows multiple answers
   * @return allowsMultipleAnswers
   */
  @javax.annotation.Nonnull
  public Boolean getAllowsMultipleAnswers() {
    return allowsMultipleAnswers;
  }

  public void setAllowsMultipleAnswers(Boolean allowsMultipleAnswers) {
    this.allowsMultipleAnswers = allowsMultipleAnswers;
  }


  public Poll closeDate(Integer closeDate) {
    this.closeDate = closeDate;
    return this;
  }

  /**
   * *Optional*. Point in time (Unix timestamp) when the poll will be automatically closed
   * @return closeDate
   */
  @javax.annotation.Nullable
  public Integer getCloseDate() {
    return closeDate;
  }

  public void setCloseDate(Integer closeDate) {
    this.closeDate = closeDate;
  }


  public Poll correctOptionId(Integer correctOptionId) {
    this.correctOptionId = correctOptionId;
    return this;
  }

  /**
   * *Optional*. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot.
   * @return correctOptionId
   */
  @javax.annotation.Nullable
  public Integer getCorrectOptionId() {
    return correctOptionId;
  }

  public void setCorrectOptionId(Integer correctOptionId) {
    this.correctOptionId = correctOptionId;
  }


  public Poll explanation(String explanation) {
    this.explanation = explanation;
    return this;
  }

  /**
   * *Optional*. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters
   * @return explanation
   */
  @javax.annotation.Nullable
  public String getExplanation() {
    return explanation;
  }

  public void setExplanation(String explanation) {
    this.explanation = explanation;
  }


  public Poll explanationEntities(List<MessageEntity> explanationEntities) {
    this.explanationEntities = explanationEntities;
    return this;
  }

  public Poll addExplanationEntitiesItem(MessageEntity explanationEntitiesItem) {
    if (this.explanationEntities == null) {
      this.explanationEntities = new ArrayList<>();
    }
    this.explanationEntities.add(explanationEntitiesItem);
    return this;
  }

  /**
   * *Optional*. Special entities like usernames, URLs, bot commands, etc. that appear in the *explanation*
   * @return explanationEntities
   */
  @javax.annotation.Nullable
  public List<MessageEntity> getExplanationEntities() {
    return explanationEntities;
  }

  public void setExplanationEntities(List<MessageEntity> explanationEntities) {
    this.explanationEntities = explanationEntities;
  }


  public Poll id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Unique poll identifier
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Poll isAnonymous(Boolean isAnonymous) {
    this.isAnonymous = isAnonymous;
    return this;
  }

  /**
   * True, if the poll is anonymous
   * @return isAnonymous
   */
  @javax.annotation.Nonnull
  public Boolean getIsAnonymous() {
    return isAnonymous;
  }

  public void setIsAnonymous(Boolean isAnonymous) {
    this.isAnonymous = isAnonymous;
  }


  public Poll isClosed(Boolean isClosed) {
    this.isClosed = isClosed;
    return this;
  }

  /**
   * True, if the poll is closed
   * @return isClosed
   */
  @javax.annotation.Nonnull
  public Boolean getIsClosed() {
    return isClosed;
  }

  public void setIsClosed(Boolean isClosed) {
    this.isClosed = isClosed;
  }


  public Poll openPeriod(Integer openPeriod) {
    this.openPeriod = openPeriod;
    return this;
  }

  /**
   * *Optional*. Amount of time in seconds the poll will be active after creation
   * @return openPeriod
   */
  @javax.annotation.Nullable
  public Integer getOpenPeriod() {
    return openPeriod;
  }

  public void setOpenPeriod(Integer openPeriod) {
    this.openPeriod = openPeriod;
  }


  public Poll options(List<PollOption> options) {
    this.options = options;
    return this;
  }

  public Poll addOptionsItem(PollOption optionsItem) {
    if (this.options == null) {
      this.options = new ArrayList<>();
    }
    this.options.add(optionsItem);
    return this;
  }

  /**
   * List of poll options
   * @return options
   */
  @javax.annotation.Nonnull
  public List<PollOption> getOptions() {
    return options;
  }

  public void setOptions(List<PollOption> options) {
    this.options = options;
  }


  public Poll question(String question) {
    this.question = question;
    return this;
  }

  /**
   * Poll question, 1-255 characters
   * @return question
   */
  @javax.annotation.Nonnull
  public String getQuestion() {
    return question;
  }

  public void setQuestion(String question) {
    this.question = question;
  }


  public Poll totalVoterCount(Integer totalVoterCount) {
    this.totalVoterCount = totalVoterCount;
    return this;
  }

  /**
   * Total number of users that voted in the poll
   * @return totalVoterCount
   */
  @javax.annotation.Nonnull
  public Integer getTotalVoterCount() {
    return totalVoterCount;
  }

  public void setTotalVoterCount(Integer totalVoterCount) {
    this.totalVoterCount = totalVoterCount;
  }


  public Poll type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Poll type, currently can be “regular” or “quiz”
   * @return type
   */
  @javax.annotation.Nonnull
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Poll poll = (Poll) o;
    return Objects.equals(this.allowsMultipleAnswers, poll.allowsMultipleAnswers) &&
        Objects.equals(this.closeDate, poll.closeDate) &&
        Objects.equals(this.correctOptionId, poll.correctOptionId) &&
        Objects.equals(this.explanation, poll.explanation) &&
        Objects.equals(this.explanationEntities, poll.explanationEntities) &&
        Objects.equals(this.id, poll.id) &&
        Objects.equals(this.isAnonymous, poll.isAnonymous) &&
        Objects.equals(this.isClosed, poll.isClosed) &&
        Objects.equals(this.openPeriod, poll.openPeriod) &&
        Objects.equals(this.options, poll.options) &&
        Objects.equals(this.question, poll.question) &&
        Objects.equals(this.totalVoterCount, poll.totalVoterCount) &&
        Objects.equals(this.type, poll.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowsMultipleAnswers, closeDate, correctOptionId, explanation, explanationEntities, id, isAnonymous, isClosed, openPeriod, options, question, totalVoterCount, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Poll {\n");
    sb.append("    allowsMultipleAnswers: ").append(toIndentedString(allowsMultipleAnswers)).append("\n");
    sb.append("    closeDate: ").append(toIndentedString(closeDate)).append("\n");
    sb.append("    correctOptionId: ").append(toIndentedString(correctOptionId)).append("\n");
    sb.append("    explanation: ").append(toIndentedString(explanation)).append("\n");
    sb.append("    explanationEntities: ").append(toIndentedString(explanationEntities)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    isAnonymous: ").append(toIndentedString(isAnonymous)).append("\n");
    sb.append("    isClosed: ").append(toIndentedString(isClosed)).append("\n");
    sb.append("    openPeriod: ").append(toIndentedString(openPeriod)).append("\n");
    sb.append("    options: ").append(toIndentedString(options)).append("\n");
    sb.append("    question: ").append(toIndentedString(question)).append("\n");
    sb.append("    totalVoterCount: ").append(toIndentedString(totalVoterCount)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allows_multiple_answers");
    openapiFields.add("close_date");
    openapiFields.add("correct_option_id");
    openapiFields.add("explanation");
    openapiFields.add("explanation_entities");
    openapiFields.add("id");
    openapiFields.add("is_anonymous");
    openapiFields.add("is_closed");
    openapiFields.add("open_period");
    openapiFields.add("options");
    openapiFields.add("question");
    openapiFields.add("total_voter_count");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("allows_multiple_answers");
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("is_anonymous");
    openapiRequiredFields.add("is_closed");
    openapiRequiredFields.add("options");
    openapiRequiredFields.add("question");
    openapiRequiredFields.add("total_voter_count");
    openapiRequiredFields.add("type");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Poll
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Poll.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Poll is not found in the empty JSON string", Poll.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Poll.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Poll` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Poll.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("explanation") != null && !jsonObj.get("explanation").isJsonNull()) && !jsonObj.get("explanation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `explanation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("explanation").toString()));
      }
      if (jsonObj.get("explanation_entities") != null && !jsonObj.get("explanation_entities").isJsonNull()) {
        JsonArray jsonArrayexplanationEntities = jsonObj.getAsJsonArray("explanation_entities");
        if (jsonArrayexplanationEntities != null) {
          // ensure the json data is an array
          if (!jsonObj.get("explanation_entities").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `explanation_entities` to be an array in the JSON string but got `%s`", jsonObj.get("explanation_entities").toString()));
          }

          // validate the optional field `explanation_entities` (array)
          for (int i = 0; i < jsonArrayexplanationEntities.size(); i++) {
            MessageEntity.validateJsonElement(jsonArrayexplanationEntities.get(i));
          };
        }
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // ensure the json data is an array
      if (!jsonObj.get("options").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `options` to be an array in the JSON string but got `%s`", jsonObj.get("options").toString()));
      }

      JsonArray jsonArrayoptions = jsonObj.getAsJsonArray("options");
      // validate the required field `options` (array)
      for (int i = 0; i < jsonArrayoptions.size(); i++) {
        PollOption.validateJsonElement(jsonArrayoptions.get(i));
      };
      if (!jsonObj.get("question").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `question` to be a primitive type in the JSON string but got `%s`", jsonObj.get("question").toString()));
      }
      if (!jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Poll.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Poll' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Poll> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Poll.class));

       return (TypeAdapter<T>) new TypeAdapter<Poll>() {
           @Override
           public void write(JsonWriter out, Poll value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Poll read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Poll given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Poll
   * @throws IOException if the JSON string is invalid with respect to Poll
   */
  public static Poll fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Poll.class);
  }

  /**
   * Convert an instance of Poll to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

