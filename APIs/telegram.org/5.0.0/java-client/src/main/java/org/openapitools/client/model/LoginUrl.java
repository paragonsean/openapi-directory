/*
 * Telegram Bot API
 * Auto-generated OpenAPI schema
 *
 * The version of the OpenAPI document: 5.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a great replacement for the [Telegram Login Widget](https://core.telegram.org/widgets/login) when the user is coming from Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:  Telegram apps support these buttons as of [version 5.7](https://telegram.org/blog/privacy-discussions-web-bots#meet-seamless-web-bots).  Sample bot: [@discussbot](https://t.me/discussbot)
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:56:27.961160-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LoginUrl {
  public static final String SERIALIZED_NAME_BOT_USERNAME = "bot_username";
  @SerializedName(SERIALIZED_NAME_BOT_USERNAME)
  private String botUsername;

  public static final String SERIALIZED_NAME_FORWARD_TEXT = "forward_text";
  @SerializedName(SERIALIZED_NAME_FORWARD_TEXT)
  private String forwardText;

  public static final String SERIALIZED_NAME_REQUEST_WRITE_ACCESS = "request_write_access";
  @SerializedName(SERIALIZED_NAME_REQUEST_WRITE_ACCESS)
  private Boolean requestWriteAccess;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private String url;

  public LoginUrl() {
  }

  public LoginUrl botUsername(String botUsername) {
    this.botUsername = botUsername;
    return this;
  }

  /**
   * *Optional*. Username of a bot, which will be used for user authorization. See [Setting up a bot](https://core.telegram.org/widgets/login#setting-up-a-bot) for more details. If not specified, the current bot&#39;s username will be assumed. The *url*&#39;s domain must be the same as the domain linked with the bot. See [Linking your domain to the bot](https://core.telegram.org/widgets/login#linking-your-domain-to-the-bot) for more details.
   * @return botUsername
   */
  @javax.annotation.Nullable
  public String getBotUsername() {
    return botUsername;
  }

  public void setBotUsername(String botUsername) {
    this.botUsername = botUsername;
  }


  public LoginUrl forwardText(String forwardText) {
    this.forwardText = forwardText;
    return this;
  }

  /**
   * *Optional*. New text of the button in forwarded messages.
   * @return forwardText
   */
  @javax.annotation.Nullable
  public String getForwardText() {
    return forwardText;
  }

  public void setForwardText(String forwardText) {
    this.forwardText = forwardText;
  }


  public LoginUrl requestWriteAccess(Boolean requestWriteAccess) {
    this.requestWriteAccess = requestWriteAccess;
    return this;
  }

  /**
   * *Optional*. Pass True to request the permission for your bot to send messages to the user.
   * @return requestWriteAccess
   */
  @javax.annotation.Nullable
  public Boolean getRequestWriteAccess() {
    return requestWriteAccess;
  }

  public void setRequestWriteAccess(Boolean requestWriteAccess) {
    this.requestWriteAccess = requestWriteAccess;
  }


  public LoginUrl url(String url) {
    this.url = url;
    return this;
  }

  /**
   * An HTTP URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in [Receiving authorization data](https://core.telegram.org/widgets/login#receiving-authorization-data).    **NOTE:** You **must** always check the hash of the received data to verify the authentication and the integrity of the data as described in [Checking authorization](https://core.telegram.org/widgets/login#checking-authorization).
   * @return url
   */
  @javax.annotation.Nonnull
  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LoginUrl loginUrl = (LoginUrl) o;
    return Objects.equals(this.botUsername, loginUrl.botUsername) &&
        Objects.equals(this.forwardText, loginUrl.forwardText) &&
        Objects.equals(this.requestWriteAccess, loginUrl.requestWriteAccess) &&
        Objects.equals(this.url, loginUrl.url);
  }

  @Override
  public int hashCode() {
    return Objects.hash(botUsername, forwardText, requestWriteAccess, url);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LoginUrl {\n");
    sb.append("    botUsername: ").append(toIndentedString(botUsername)).append("\n");
    sb.append("    forwardText: ").append(toIndentedString(forwardText)).append("\n");
    sb.append("    requestWriteAccess: ").append(toIndentedString(requestWriteAccess)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bot_username");
    openapiFields.add("forward_text");
    openapiFields.add("request_write_access");
    openapiFields.add("url");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("url");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LoginUrl
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LoginUrl.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LoginUrl is not found in the empty JSON string", LoginUrl.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LoginUrl.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LoginUrl` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : LoginUrl.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("bot_username") != null && !jsonObj.get("bot_username").isJsonNull()) && !jsonObj.get("bot_username").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bot_username` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bot_username").toString()));
      }
      if ((jsonObj.get("forward_text") != null && !jsonObj.get("forward_text").isJsonNull()) && !jsonObj.get("forward_text").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `forward_text` to be a primitive type in the JSON string but got `%s`", jsonObj.get("forward_text").toString()));
      }
      if (!jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LoginUrl.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LoginUrl' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LoginUrl> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LoginUrl.class));

       return (TypeAdapter<T>) new TypeAdapter<LoginUrl>() {
           @Override
           public void write(JsonWriter out, LoginUrl value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LoginUrl read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LoginUrl given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LoginUrl
   * @throws IOException if the JSON string is invalid with respect to LoginUrl
   */
  public static LoginUrl fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LoginUrl.class);
  }

  /**
   * Convert an instance of LoginUrl to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

