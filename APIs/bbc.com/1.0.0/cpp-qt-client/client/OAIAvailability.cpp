/**
 * BBC Nitro API
 * BBC Nitro is the BBC's application programming interface (API) for BBC Programmes Metadata.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: nitro@bbc.co.uk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAvailability.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAvailability::OAIAvailability(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAvailability::OAIAvailability() {
    this->initializeModel();
}

OAIAvailability::~OAIAvailability() {}

void OAIAvailability::initializeModel() {

    m_accurate_programme_time_isSet = false;
    m_accurate_programme_time_isValid = false;

    m_actual_start_isSet = false;
    m_actual_start_isValid = false;

    m_availability_debug_isSet = false;
    m_availability_debug_isValid = false;

    m_availability_of_isSet = false;
    m_availability_of_isValid = false;

    m_availability_type_isSet = false;
    m_availability_type_isValid = false;

    m_media_availability_time_isSet = false;
    m_media_availability_time_isValid = false;

    m_media_set_isSet = false;
    m_media_set_isValid = false;

    m_revocation_status_isSet = false;
    m_revocation_status_isValid = false;

    m_scheduled_time_isSet = false;
    m_scheduled_time_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;
}

void OAIAvailability::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAvailability::fromJsonObject(QJsonObject json) {

    m_accurate_programme_time_isValid = ::OpenAPI::fromJsonValue(m_accurate_programme_time, json[QString("accurate_programme_time")]);
    m_accurate_programme_time_isSet = !json[QString("accurate_programme_time")].isNull() && m_accurate_programme_time_isValid;

    m_actual_start_isValid = ::OpenAPI::fromJsonValue(m_actual_start, json[QString("actual_start")]);
    m_actual_start_isSet = !json[QString("actual_start")].isNull() && m_actual_start_isValid;

    m_availability_debug_isValid = ::OpenAPI::fromJsonValue(m_availability_debug, json[QString("availability-debug")]);
    m_availability_debug_isSet = !json[QString("availability-debug")].isNull() && m_availability_debug_isValid;

    m_availability_of_isValid = ::OpenAPI::fromJsonValue(m_availability_of, json[QString("availability_of")]);
    m_availability_of_isSet = !json[QString("availability_of")].isNull() && m_availability_of_isValid;

    m_availability_type_isValid = ::OpenAPI::fromJsonValue(m_availability_type, json[QString("availability_type")]);
    m_availability_type_isSet = !json[QString("availability_type")].isNull() && m_availability_type_isValid;

    m_media_availability_time_isValid = ::OpenAPI::fromJsonValue(m_media_availability_time, json[QString("media_availability_time")]);
    m_media_availability_time_isSet = !json[QString("media_availability_time")].isNull() && m_media_availability_time_isValid;

    m_media_set_isValid = ::OpenAPI::fromJsonValue(m_media_set, json[QString("media_set")]);
    m_media_set_isSet = !json[QString("media_set")].isNull() && m_media_set_isValid;

    m_revocation_status_isValid = ::OpenAPI::fromJsonValue(m_revocation_status, json[QString("revocation_status")]);
    m_revocation_status_isSet = !json[QString("revocation_status")].isNull() && m_revocation_status_isValid;

    m_scheduled_time_isValid = ::OpenAPI::fromJsonValue(m_scheduled_time, json[QString("scheduled_time")]);
    m_scheduled_time_isSet = !json[QString("scheduled_time")].isNull() && m_scheduled_time_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;
}

QString OAIAvailability::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAvailability::asJsonObject() const {
    QJsonObject obj;
    if (m_accurate_programme_time.isSet()) {
        obj.insert(QString("accurate_programme_time"), ::OpenAPI::toJsonValue(m_accurate_programme_time));
    }
    if (m_actual_start_isSet) {
        obj.insert(QString("actual_start"), ::OpenAPI::toJsonValue(m_actual_start));
    }
    if (m_availability_debug.isSet()) {
        obj.insert(QString("availability-debug"), ::OpenAPI::toJsonValue(m_availability_debug));
    }
    if (m_availability_of.size() > 0) {
        obj.insert(QString("availability_of"), ::OpenAPI::toJsonValue(m_availability_of));
    }
    if (m_availability_type.isSet()) {
        obj.insert(QString("availability_type"), ::OpenAPI::toJsonValue(m_availability_type));
    }
    if (m_media_availability_time.isSet()) {
        obj.insert(QString("media_availability_time"), ::OpenAPI::toJsonValue(m_media_availability_time));
    }
    if (m_media_set.size() > 0) {
        obj.insert(QString("media_set"), ::OpenAPI::toJsonValue(m_media_set));
    }
    if (m_revocation_status_isSet) {
        obj.insert(QString("revocation_status"), ::OpenAPI::toJsonValue(m_revocation_status));
    }
    if (m_scheduled_time.isSet()) {
        obj.insert(QString("scheduled_time"), ::OpenAPI::toJsonValue(m_scheduled_time));
    }
    if (m_status_isSet) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    return obj;
}

OAIDateRange OAIAvailability::getAccurateProgrammeTime() const {
    return m_accurate_programme_time;
}
void OAIAvailability::setAccurateProgrammeTime(const OAIDateRange &accurate_programme_time) {
    m_accurate_programme_time = accurate_programme_time;
    m_accurate_programme_time_isSet = true;
}

bool OAIAvailability::is_accurate_programme_time_Set() const{
    return m_accurate_programme_time_isSet;
}

bool OAIAvailability::is_accurate_programme_time_Valid() const{
    return m_accurate_programme_time_isValid;
}

QDateTime OAIAvailability::getActualStart() const {
    return m_actual_start;
}
void OAIAvailability::setActualStart(const QDateTime &actual_start) {
    m_actual_start = actual_start;
    m_actual_start_isSet = true;
}

bool OAIAvailability::is_actual_start_Set() const{
    return m_actual_start_isSet;
}

bool OAIAvailability::is_actual_start_Valid() const{
    return m_actual_start_isValid;
}

OAIAvailability_debug OAIAvailability::getAvailabilityDebug() const {
    return m_availability_debug;
}
void OAIAvailability::setAvailabilityDebug(const OAIAvailability_debug &availability_debug) {
    m_availability_debug = availability_debug;
    m_availability_debug_isSet = true;
}

bool OAIAvailability::is_availability_debug_Set() const{
    return m_availability_debug_isSet;
}

bool OAIAvailability::is_availability_debug_Valid() const{
    return m_availability_debug_isValid;
}

QList<OAIAvailability_of> OAIAvailability::getAvailabilityOf() const {
    return m_availability_of;
}
void OAIAvailability::setAvailabilityOf(const QList<OAIAvailability_of> &availability_of) {
    m_availability_of = availability_of;
    m_availability_of_isSet = true;
}

bool OAIAvailability::is_availability_of_Set() const{
    return m_availability_of_isSet;
}

bool OAIAvailability::is_availability_of_Valid() const{
    return m_availability_of_isValid;
}

OAIAvailability_type OAIAvailability::getAvailabilityType() const {
    return m_availability_type;
}
void OAIAvailability::setAvailabilityType(const OAIAvailability_type &availability_type) {
    m_availability_type = availability_type;
    m_availability_type_isSet = true;
}

bool OAIAvailability::is_availability_type_Set() const{
    return m_availability_type_isSet;
}

bool OAIAvailability::is_availability_type_Valid() const{
    return m_availability_type_isValid;
}

OAIDateRange OAIAvailability::getMediaAvailabilityTime() const {
    return m_media_availability_time;
}
void OAIAvailability::setMediaAvailabilityTime(const OAIDateRange &media_availability_time) {
    m_media_availability_time = media_availability_time;
    m_media_availability_time_isSet = true;
}

bool OAIAvailability::is_media_availability_time_Set() const{
    return m_media_availability_time_isSet;
}

bool OAIAvailability::is_media_availability_time_Valid() const{
    return m_media_availability_time_isValid;
}

QList<QString> OAIAvailability::getMediaSet() const {
    return m_media_set;
}
void OAIAvailability::setMediaSet(const QList<QString> &media_set) {
    m_media_set = media_set;
    m_media_set_isSet = true;
}

bool OAIAvailability::is_media_set_Set() const{
    return m_media_set_isSet;
}

bool OAIAvailability::is_media_set_Valid() const{
    return m_media_set_isValid;
}

QString OAIAvailability::getRevocationStatus() const {
    return m_revocation_status;
}
void OAIAvailability::setRevocationStatus(const QString &revocation_status) {
    m_revocation_status = revocation_status;
    m_revocation_status_isSet = true;
}

bool OAIAvailability::is_revocation_status_Set() const{
    return m_revocation_status_isSet;
}

bool OAIAvailability::is_revocation_status_Valid() const{
    return m_revocation_status_isValid;
}

OAIScheduled_time OAIAvailability::getScheduledTime() const {
    return m_scheduled_time;
}
void OAIAvailability::setScheduledTime(const OAIScheduled_time &scheduled_time) {
    m_scheduled_time = scheduled_time;
    m_scheduled_time_isSet = true;
}

bool OAIAvailability::is_scheduled_time_Set() const{
    return m_scheduled_time_isSet;
}

bool OAIAvailability::is_scheduled_time_Valid() const{
    return m_scheduled_time_isValid;
}

QString OAIAvailability::getStatus() const {
    return m_status;
}
void OAIAvailability::setStatus(const QString &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIAvailability::is_status_Set() const{
    return m_status_isSet;
}

bool OAIAvailability::is_status_Valid() const{
    return m_status_isValid;
}

bool OAIAvailability::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accurate_programme_time.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_actual_start_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_availability_debug.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_availability_of.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_availability_type.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_media_availability_time.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_media_set.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_revocation_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_scheduled_time.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAvailability::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_availability_type_isValid && m_status_isValid && true;
}

} // namespace OpenAPI
