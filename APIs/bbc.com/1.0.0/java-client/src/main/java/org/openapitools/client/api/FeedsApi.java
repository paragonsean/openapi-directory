/*
 * BBC Nitro API
 * BBC Nitro is the BBC's application programming interface (API) for BBC Programmes Metadata.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: nitro@bbc.co.uk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ErrorModel;
import java.time.LocalDate;
import org.openapitools.client.model.Nitro;
import java.time.OffsetDateTime;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FeedsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public FeedsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public FeedsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for listAvailability
     * @param sort Sorts: * scheduled_start: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param availability filter for subset of availabilities (optional)
     * @param descendantsOf filter for subset of availabilities that have PID as ancestor (optional)
     * @param mediaSet filter for subset of availabilities with media set (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param territory filter for availabilities in given territory (optional)
     * @param debug Turn on debug information (undocumented) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listAvailabilityCall(String sort, String sortDirection, List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> territory, Boolean debug, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/availabilities";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (sortDirection != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_direction", sortDirection));
        }

        if (availability != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "availability", availability));
        }

        if (descendantsOf != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "descendants_of", descendantsOf));
        }

        if (mediaSet != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "media_set", mediaSet));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (territory != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "territory", territory));
        }

        if (debug != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("debug", debug));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listAvailabilityValidateBeforeCall(String sort, String sortDirection, List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> territory, Boolean debug, final ApiCallback _callback) throws ApiException {
        return listAvailabilityCall(sort, sortDirection, availability, descendantsOf, mediaSet, page, pageSize, territory, debug, _callback);

    }

    /**
     * Discover details of on-demand availability for programmes and their versions
     * Discover details of on-demand availability for programmes and their versions
     * @param sort Sorts: * scheduled_start: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param availability filter for subset of availabilities (optional)
     * @param descendantsOf filter for subset of availabilities that have PID as ancestor (optional)
     * @param mediaSet filter for subset of availabilities with media set (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param territory filter for availabilities in given territory (optional)
     * @param debug Turn on debug information (undocumented) (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listAvailability(String sort, String sortDirection, List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> territory, Boolean debug) throws ApiException {
        ApiResponse<Nitro> localVarResp = listAvailabilityWithHttpInfo(sort, sortDirection, availability, descendantsOf, mediaSet, page, pageSize, territory, debug);
        return localVarResp.getData();
    }

    /**
     * Discover details of on-demand availability for programmes and their versions
     * Discover details of on-demand availability for programmes and their versions
     * @param sort Sorts: * scheduled_start: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param availability filter for subset of availabilities (optional)
     * @param descendantsOf filter for subset of availabilities that have PID as ancestor (optional)
     * @param mediaSet filter for subset of availabilities with media set (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param territory filter for availabilities in given territory (optional)
     * @param debug Turn on debug information (undocumented) (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listAvailabilityWithHttpInfo(String sort, String sortDirection, List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> territory, Boolean debug) throws ApiException {
        okhttp3.Call localVarCall = listAvailabilityValidateBeforeCall(sort, sortDirection, availability, descendantsOf, mediaSet, page, pageSize, territory, debug, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Discover details of on-demand availability for programmes and their versions (asynchronously)
     * Discover details of on-demand availability for programmes and their versions
     * @param sort Sorts: * scheduled_start: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param availability filter for subset of availabilities (optional)
     * @param descendantsOf filter for subset of availabilities that have PID as ancestor (optional)
     * @param mediaSet filter for subset of availabilities with media set (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param territory filter for availabilities in given territory (optional)
     * @param debug Turn on debug information (undocumented) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listAvailabilityAsync(String sort, String sortDirection, List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> territory, Boolean debug, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listAvailabilityValidateBeforeCall(sort, sortDirection, availability, descendantsOf, mediaSet, page, pageSize, territory, debug, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listBroadcasts
     * @param sort Sorts: * start_date: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * titles: return ancestor programme titles  (optional)
     * @param authority filter for subset of broadcasts that have given authority (optional)
     * @param descendantsOf filter for subset of broadcasts that are descendants of the given programme PID (optional)
     * @param endFrom filter for subset of broadcasts that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts that end on or earlier than the specified datetime (optional)
     * @param format filter for subset of broadcasts that are classified in the given format ID (optional)
     * @param genre filter for subset of broadcasts that are classified in the given genre ID (optional)
     * @param id filter for subset of broadcasts that have given identifier (optional)
     * @param item filter for subset of broadcasts with the given item performed on it (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param people filter for subset of broadcasts that have given contributor (optional)
     * @param pid filter for subset of broadcasts having given PID (optional)
     * @param q filter for subset of broadcasts matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param scheduleDay filter for subset of broadcasts that start on the specified day (BBC time) (optional)
     * @param scheduleDayFrom filter for subset of broadcasts that start on or after the specified day (BBC time) (optional)
     * @param scheduleDayTo filter for subset of broadcasts that start on or before the specified day (BBC time) (optional)
     * @param serviceMasterBrand filter for subset of broadcasts with given service master brand (optional)
     * @param sid filter for subset of broadcasts that are on the specified linear service (optional)
     * @param startFrom filter for subset of broadcasts that start on or later than the specified datetime (optional)
     * @param startTo filter for subset of broadcasts that start on or earlier than the specified datetime (optional)
     * @param version filter for subset of broadcasts with given PID as their parent version (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listBroadcastsCall(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, List<String> id, List<String> item, Integer page, Integer pageSize, String people, List<String> pid, String q, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/broadcasts";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (sortDirection != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_direction", sortDirection));
        }

        if (mixin != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mixin", mixin));
        }

        if (authority != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "authority", authority));
        }

        if (descendantsOf != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "descendants_of", descendantsOf));
        }

        if (endFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_from", endFrom));
        }

        if (endTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_to", endTo));
        }

        if (format != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "format", format));
        }

        if (genre != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "genre", genre));
        }

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (item != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "item", item));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (people != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("people", people));
        }

        if (pid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "pid", pid));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (scheduleDay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("schedule_day", scheduleDay));
        }

        if (scheduleDayFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("schedule_day_from", scheduleDayFrom));
        }

        if (scheduleDayTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("schedule_day_to", scheduleDayTo));
        }

        if (serviceMasterBrand != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "service_master_brand", serviceMasterBrand));
        }

        if (sid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "sid", sid));
        }

        if (startFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_from", startFrom));
        }

        if (startTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_to", startTo));
        }

        if (version != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "version", version));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listBroadcastsValidateBeforeCall(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, List<String> id, List<String> item, Integer page, Integer pageSize, String people, List<String> pid, String q, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version, final ApiCallback _callback) throws ApiException {
        return listBroadcastsCall(sort, sortDirection, mixin, authority, descendantsOf, endFrom, endTo, format, genre, id, item, page, pageSize, people, pid, q, scheduleDay, scheduleDayFrom, scheduleDayTo, serviceMasterBrand, sid, startFrom, startTo, version, _callback);

    }

    /**
     * Build schedules and find metadata for TV and radio broadcasts
     * Fetch metadata about linear Broadcasts and Services, allowing the generation of Television and Radio schedules and other datasets for broadcast items. Use /schedules instead of this feed as it is more efficient. Broadcasts will be deprecated in the future.
     * @param sort Sorts: * start_date: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * titles: return ancestor programme titles  (optional)
     * @param authority filter for subset of broadcasts that have given authority (optional)
     * @param descendantsOf filter for subset of broadcasts that are descendants of the given programme PID (optional)
     * @param endFrom filter for subset of broadcasts that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts that end on or earlier than the specified datetime (optional)
     * @param format filter for subset of broadcasts that are classified in the given format ID (optional)
     * @param genre filter for subset of broadcasts that are classified in the given genre ID (optional)
     * @param id filter for subset of broadcasts that have given identifier (optional)
     * @param item filter for subset of broadcasts with the given item performed on it (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param people filter for subset of broadcasts that have given contributor (optional)
     * @param pid filter for subset of broadcasts having given PID (optional)
     * @param q filter for subset of broadcasts matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param scheduleDay filter for subset of broadcasts that start on the specified day (BBC time) (optional)
     * @param scheduleDayFrom filter for subset of broadcasts that start on or after the specified day (BBC time) (optional)
     * @param scheduleDayTo filter for subset of broadcasts that start on or before the specified day (BBC time) (optional)
     * @param serviceMasterBrand filter for subset of broadcasts with given service master brand (optional)
     * @param sid filter for subset of broadcasts that are on the specified linear service (optional)
     * @param startFrom filter for subset of broadcasts that start on or later than the specified datetime (optional)
     * @param startTo filter for subset of broadcasts that start on or earlier than the specified datetime (optional)
     * @param version filter for subset of broadcasts with given PID as their parent version (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listBroadcasts(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, List<String> id, List<String> item, Integer page, Integer pageSize, String people, List<String> pid, String q, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version) throws ApiException {
        ApiResponse<Nitro> localVarResp = listBroadcastsWithHttpInfo(sort, sortDirection, mixin, authority, descendantsOf, endFrom, endTo, format, genre, id, item, page, pageSize, people, pid, q, scheduleDay, scheduleDayFrom, scheduleDayTo, serviceMasterBrand, sid, startFrom, startTo, version);
        return localVarResp.getData();
    }

    /**
     * Build schedules and find metadata for TV and radio broadcasts
     * Fetch metadata about linear Broadcasts and Services, allowing the generation of Television and Radio schedules and other datasets for broadcast items. Use /schedules instead of this feed as it is more efficient. Broadcasts will be deprecated in the future.
     * @param sort Sorts: * start_date: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * titles: return ancestor programme titles  (optional)
     * @param authority filter for subset of broadcasts that have given authority (optional)
     * @param descendantsOf filter for subset of broadcasts that are descendants of the given programme PID (optional)
     * @param endFrom filter for subset of broadcasts that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts that end on or earlier than the specified datetime (optional)
     * @param format filter for subset of broadcasts that are classified in the given format ID (optional)
     * @param genre filter for subset of broadcasts that are classified in the given genre ID (optional)
     * @param id filter for subset of broadcasts that have given identifier (optional)
     * @param item filter for subset of broadcasts with the given item performed on it (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param people filter for subset of broadcasts that have given contributor (optional)
     * @param pid filter for subset of broadcasts having given PID (optional)
     * @param q filter for subset of broadcasts matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param scheduleDay filter for subset of broadcasts that start on the specified day (BBC time) (optional)
     * @param scheduleDayFrom filter for subset of broadcasts that start on or after the specified day (BBC time) (optional)
     * @param scheduleDayTo filter for subset of broadcasts that start on or before the specified day (BBC time) (optional)
     * @param serviceMasterBrand filter for subset of broadcasts with given service master brand (optional)
     * @param sid filter for subset of broadcasts that are on the specified linear service (optional)
     * @param startFrom filter for subset of broadcasts that start on or later than the specified datetime (optional)
     * @param startTo filter for subset of broadcasts that start on or earlier than the specified datetime (optional)
     * @param version filter for subset of broadcasts with given PID as their parent version (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listBroadcastsWithHttpInfo(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, List<String> id, List<String> item, Integer page, Integer pageSize, String people, List<String> pid, String q, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version) throws ApiException {
        okhttp3.Call localVarCall = listBroadcastsValidateBeforeCall(sort, sortDirection, mixin, authority, descendantsOf, endFrom, endTo, format, genre, id, item, page, pageSize, people, pid, q, scheduleDay, scheduleDayFrom, scheduleDayTo, serviceMasterBrand, sid, startFrom, startTo, version, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build schedules and find metadata for TV and radio broadcasts (asynchronously)
     * Fetch metadata about linear Broadcasts and Services, allowing the generation of Television and Radio schedules and other datasets for broadcast items. Use /schedules instead of this feed as it is more efficient. Broadcasts will be deprecated in the future.
     * @param sort Sorts: * start_date: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * titles: return ancestor programme titles  (optional)
     * @param authority filter for subset of broadcasts that have given authority (optional)
     * @param descendantsOf filter for subset of broadcasts that are descendants of the given programme PID (optional)
     * @param endFrom filter for subset of broadcasts that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts that end on or earlier than the specified datetime (optional)
     * @param format filter for subset of broadcasts that are classified in the given format ID (optional)
     * @param genre filter for subset of broadcasts that are classified in the given genre ID (optional)
     * @param id filter for subset of broadcasts that have given identifier (optional)
     * @param item filter for subset of broadcasts with the given item performed on it (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param people filter for subset of broadcasts that have given contributor (optional)
     * @param pid filter for subset of broadcasts having given PID (optional)
     * @param q filter for subset of broadcasts matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param scheduleDay filter for subset of broadcasts that start on the specified day (BBC time) (optional)
     * @param scheduleDayFrom filter for subset of broadcasts that start on or after the specified day (BBC time) (optional)
     * @param scheduleDayTo filter for subset of broadcasts that start on or before the specified day (BBC time) (optional)
     * @param serviceMasterBrand filter for subset of broadcasts with given service master brand (optional)
     * @param sid filter for subset of broadcasts that are on the specified linear service (optional)
     * @param startFrom filter for subset of broadcasts that start on or later than the specified datetime (optional)
     * @param startTo filter for subset of broadcasts that start on or earlier than the specified datetime (optional)
     * @param version filter for subset of broadcasts with given PID as their parent version (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listBroadcastsAsync(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, List<String> id, List<String> item, Integer page, Integer pageSize, String people, List<String> pid, String q, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listBroadcastsValidateBeforeCall(sort, sortDirection, mixin, authority, descendantsOf, endFrom, endTo, format, genre, id, item, page, pageSize, people, pid, q, scheduleDay, scheduleDayFrom, scheduleDayTo, serviceMasterBrand, sid, startFrom, startTo, version, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listGroups
     * @param sort Sorts: * pid: sort alphabetically by PID  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * alternate_images: mixin to return the alternate images for a group * group_for: mixin to return links to programme entities that group belongs to * images: mixin to add image information for a group * related_links: mixin to return related links for the group  (optional)
     * @param forDescendantsOf filter for groups related to given programme or its descendants (optional)
     * @param forProgramme filter for subset of groups directly related to a given programme (optional)
     * @param group filter for subset of groups which belong to the given group pid (optional)
     * @param groupType filter for subset of groups that have the given group type (optional)
     * @param member filter for subset of groups which contain an entity with the given pid as a member (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for groups by partner ID (optional)
     * @param partnerPid filter for groups by partner PID (optional)
     * @param pid filter for subset of seasons, collections, galleries or franchises having given PID (optional)
     * @param q filter for subset of groups matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listGroupsCall(String sort, String sortDirection, List<String> mixin, String forDescendantsOf, String forProgramme, String group, List<String> groupType, String member, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (sortDirection != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_direction", sortDirection));
        }

        if (mixin != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mixin", mixin));
        }

        if (forDescendantsOf != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("for_descendants_of", forDescendantsOf));
        }

        if (forProgramme != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("for_programme", forProgramme));
        }

        if (group != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group", group));
        }

        if (groupType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "group_type", groupType));
        }

        if (member != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("member", member));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (pid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "pid", pid));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (embargoed != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("embargoed", embargoed));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listGroupsValidateBeforeCall(String sort, String sortDirection, List<String> mixin, String forDescendantsOf, String forProgramme, String group, List<String> groupType, String member, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed, final ApiCallback _callback) throws ApiException {
        return listGroupsCall(sort, sortDirection, mixin, forDescendantsOf, forProgramme, group, groupType, member, page, pageSize, partnerId, partnerPid, pid, q, embargoed, _callback);

    }

    /**
     * Find metadata for curated groups: seasons, collections, galleries or franchises
     * Long-lived curated collections of programmes and more, including Collections, Seasons, Franchises and Galleries
     * @param sort Sorts: * pid: sort alphabetically by PID  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * alternate_images: mixin to return the alternate images for a group * group_for: mixin to return links to programme entities that group belongs to * images: mixin to add image information for a group * related_links: mixin to return related links for the group  (optional)
     * @param forDescendantsOf filter for groups related to given programme or its descendants (optional)
     * @param forProgramme filter for subset of groups directly related to a given programme (optional)
     * @param group filter for subset of groups which belong to the given group pid (optional)
     * @param groupType filter for subset of groups that have the given group type (optional)
     * @param member filter for subset of groups which contain an entity with the given pid as a member (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for groups by partner ID (optional)
     * @param partnerPid filter for groups by partner PID (optional)
     * @param pid filter for subset of seasons, collections, galleries or franchises having given PID (optional)
     * @param q filter for subset of groups matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listGroups(String sort, String sortDirection, List<String> mixin, String forDescendantsOf, String forProgramme, String group, List<String> groupType, String member, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed) throws ApiException {
        ApiResponse<Nitro> localVarResp = listGroupsWithHttpInfo(sort, sortDirection, mixin, forDescendantsOf, forProgramme, group, groupType, member, page, pageSize, partnerId, partnerPid, pid, q, embargoed);
        return localVarResp.getData();
    }

    /**
     * Find metadata for curated groups: seasons, collections, galleries or franchises
     * Long-lived curated collections of programmes and more, including Collections, Seasons, Franchises and Galleries
     * @param sort Sorts: * pid: sort alphabetically by PID  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * alternate_images: mixin to return the alternate images for a group * group_for: mixin to return links to programme entities that group belongs to * images: mixin to add image information for a group * related_links: mixin to return related links for the group  (optional)
     * @param forDescendantsOf filter for groups related to given programme or its descendants (optional)
     * @param forProgramme filter for subset of groups directly related to a given programme (optional)
     * @param group filter for subset of groups which belong to the given group pid (optional)
     * @param groupType filter for subset of groups that have the given group type (optional)
     * @param member filter for subset of groups which contain an entity with the given pid as a member (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for groups by partner ID (optional)
     * @param partnerPid filter for groups by partner PID (optional)
     * @param pid filter for subset of seasons, collections, galleries or franchises having given PID (optional)
     * @param q filter for subset of groups matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listGroupsWithHttpInfo(String sort, String sortDirection, List<String> mixin, String forDescendantsOf, String forProgramme, String group, List<String> groupType, String member, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed) throws ApiException {
        okhttp3.Call localVarCall = listGroupsValidateBeforeCall(sort, sortDirection, mixin, forDescendantsOf, forProgramme, group, groupType, member, page, pageSize, partnerId, partnerPid, pid, q, embargoed, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find metadata for curated groups: seasons, collections, galleries or franchises (asynchronously)
     * Long-lived curated collections of programmes and more, including Collections, Seasons, Franchises and Galleries
     * @param sort Sorts: * pid: sort alphabetically by PID  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * alternate_images: mixin to return the alternate images for a group * group_for: mixin to return links to programme entities that group belongs to * images: mixin to add image information for a group * related_links: mixin to return related links for the group  (optional)
     * @param forDescendantsOf filter for groups related to given programme or its descendants (optional)
     * @param forProgramme filter for subset of groups directly related to a given programme (optional)
     * @param group filter for subset of groups which belong to the given group pid (optional)
     * @param groupType filter for subset of groups that have the given group type (optional)
     * @param member filter for subset of groups which contain an entity with the given pid as a member (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for groups by partner ID (optional)
     * @param partnerPid filter for groups by partner PID (optional)
     * @param pid filter for subset of seasons, collections, galleries or franchises having given PID (optional)
     * @param q filter for subset of groups matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listGroupsAsync(String sort, String sortDirection, List<String> mixin, String forDescendantsOf, String forProgramme, String group, List<String> groupType, String member, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listGroupsValidateBeforeCall(sort, sortDirection, mixin, forDescendantsOf, forProgramme, group, groupType, member, page, pageSize, partnerId, partnerPid, pid, q, embargoed, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listImages
     * @param sort Sorts: * group_position: sort numerically by position, ascending only * pid: sort alphabetically by PID  (optional)
     * @param sortDirection Sort direction (optional)
     * @param group filter for images belonging to the given group (i.e. Gallery) (optional)
     * @param imageType filter for images by type (optional)
     * @param isAlternateImageFor filter for alternate images by entity PID (optional)
     * @param isImageFor filter for images by entity PID (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for images by partner ID (optional)
     * @param partnerPid filter for images by partner PID (optional)
     * @param pid filter for subset of images having given PID (optional)
     * @param q filter for subset of images matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listImagesCall(String sort, String sortDirection, String group, List<String> imageType, String isAlternateImageFor, String isImageFor, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/images";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (sortDirection != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_direction", sortDirection));
        }

        if (group != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group", group));
        }

        if (imageType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "image_type", imageType));
        }

        if (isAlternateImageFor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("is_alternate_image_for", isAlternateImageFor));
        }

        if (isImageFor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("is_image_for", isImageFor));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (pid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "pid", pid));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (embargoed != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("embargoed", embargoed));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listImagesValidateBeforeCall(String sort, String sortDirection, String group, List<String> imageType, String isAlternateImageFor, String isImageFor, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed, final ApiCallback _callback) throws ApiException {
        return listImagesCall(sort, sortDirection, group, imageType, isAlternateImageFor, isImageFor, page, pageSize, partnerId, partnerPid, pid, q, embargoed, _callback);

    }

    /**
     * Find metadata for images
     * Find metadata for images, particularly those in galleries
     * @param sort Sorts: * group_position: sort numerically by position, ascending only * pid: sort alphabetically by PID  (optional)
     * @param sortDirection Sort direction (optional)
     * @param group filter for images belonging to the given group (i.e. Gallery) (optional)
     * @param imageType filter for images by type (optional)
     * @param isAlternateImageFor filter for alternate images by entity PID (optional)
     * @param isImageFor filter for images by entity PID (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for images by partner ID (optional)
     * @param partnerPid filter for images by partner PID (optional)
     * @param pid filter for subset of images having given PID (optional)
     * @param q filter for subset of images matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listImages(String sort, String sortDirection, String group, List<String> imageType, String isAlternateImageFor, String isImageFor, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed) throws ApiException {
        ApiResponse<Nitro> localVarResp = listImagesWithHttpInfo(sort, sortDirection, group, imageType, isAlternateImageFor, isImageFor, page, pageSize, partnerId, partnerPid, pid, q, embargoed);
        return localVarResp.getData();
    }

    /**
     * Find metadata for images
     * Find metadata for images, particularly those in galleries
     * @param sort Sorts: * group_position: sort numerically by position, ascending only * pid: sort alphabetically by PID  (optional)
     * @param sortDirection Sort direction (optional)
     * @param group filter for images belonging to the given group (i.e. Gallery) (optional)
     * @param imageType filter for images by type (optional)
     * @param isAlternateImageFor filter for alternate images by entity PID (optional)
     * @param isImageFor filter for images by entity PID (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for images by partner ID (optional)
     * @param partnerPid filter for images by partner PID (optional)
     * @param pid filter for subset of images having given PID (optional)
     * @param q filter for subset of images matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listImagesWithHttpInfo(String sort, String sortDirection, String group, List<String> imageType, String isAlternateImageFor, String isImageFor, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed) throws ApiException {
        okhttp3.Call localVarCall = listImagesValidateBeforeCall(sort, sortDirection, group, imageType, isAlternateImageFor, isImageFor, page, pageSize, partnerId, partnerPid, pid, q, embargoed, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find metadata for images (asynchronously)
     * Find metadata for images, particularly those in galleries
     * @param sort Sorts: * group_position: sort numerically by position, ascending only * pid: sort alphabetically by PID  (optional)
     * @param sortDirection Sort direction (optional)
     * @param group filter for images belonging to the given group (i.e. Gallery) (optional)
     * @param imageType filter for images by type (optional)
     * @param isAlternateImageFor filter for alternate images by entity PID (optional)
     * @param isImageFor filter for images by entity PID (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for images by partner ID (optional)
     * @param partnerPid filter for images by partner PID (optional)
     * @param pid filter for subset of images having given PID (optional)
     * @param q filter for subset of images matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listImagesAsync(String sort, String sortDirection, String group, List<String> imageType, String isAlternateImageFor, String isImageFor, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String q, String embargoed, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listImagesValidateBeforeCall(sort, sortDirection, group, imageType, isAlternateImageFor, isImageFor, page, pageSize, partnerId, partnerPid, pid, q, embargoed, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listItems
     * @param sort Sorts: * pid: sort by pid, descending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * contributions: mixin to return information about contributors to items * images: mixin to add image information for an item * offset: mixin to return programme segment offsets, works in conjunction with programme filter * play_event: mixin to return programme segment events, works in conjunction with programme or segment_event filters  (optional)
     * @param authority filter for subset of items that have an ID issued by the given authority (optional)
     * @param id filter for subset of items having given ID (optional)
     * @param idType filter for subset of items that have given an ID of the given type (optional)
     * @param itemType filter for specific type(s) of items (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for items by partner ID (optional)
     * @param partnerPid filter for items by partner PID (optional)
     * @param people filter for subset of items that have specified person involved (optional)
     * @param pid filter for subset of items matching one of the given PIDs (optional)
     * @param programme filter for subset of items that are part of the given programme (optional)
     * @param q filter for subset of items matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param segmentEvent filter for item with the given segment_event (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listItemsCall(String sort, String sortDirection, List<String> mixin, String authority, List<String> id, String idType, List<String> itemType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String programme, String q, String segmentEvent, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/items";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (sortDirection != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_direction", sortDirection));
        }

        if (mixin != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mixin", mixin));
        }

        if (authority != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("authority", authority));
        }

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("id_type", idType));
        }

        if (itemType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "item_type", itemType));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (people != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("people", people));
        }

        if (pid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "pid", pid));
        }

        if (programme != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("programme", programme));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (segmentEvent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segment_event", segmentEvent));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listItemsValidateBeforeCall(String sort, String sortDirection, List<String> mixin, String authority, List<String> id, String idType, List<String> itemType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String programme, String q, String segmentEvent, final ApiCallback _callback) throws ApiException {
        return listItemsCall(sort, sortDirection, mixin, authority, id, idType, itemType, page, pageSize, partnerId, partnerPid, people, pid, programme, q, segmentEvent, _callback);

    }

    /**
     * Look inside programmes to find segments: chapters, tracks and more
     * Look inside programmes to find segments: chapters, tracks and more
     * @param sort Sorts: * pid: sort by pid, descending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * contributions: mixin to return information about contributors to items * images: mixin to add image information for an item * offset: mixin to return programme segment offsets, works in conjunction with programme filter * play_event: mixin to return programme segment events, works in conjunction with programme or segment_event filters  (optional)
     * @param authority filter for subset of items that have an ID issued by the given authority (optional)
     * @param id filter for subset of items having given ID (optional)
     * @param idType filter for subset of items that have given an ID of the given type (optional)
     * @param itemType filter for specific type(s) of items (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for items by partner ID (optional)
     * @param partnerPid filter for items by partner PID (optional)
     * @param people filter for subset of items that have specified person involved (optional)
     * @param pid filter for subset of items matching one of the given PIDs (optional)
     * @param programme filter for subset of items that are part of the given programme (optional)
     * @param q filter for subset of items matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param segmentEvent filter for item with the given segment_event (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listItems(String sort, String sortDirection, List<String> mixin, String authority, List<String> id, String idType, List<String> itemType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String programme, String q, String segmentEvent) throws ApiException {
        ApiResponse<Nitro> localVarResp = listItemsWithHttpInfo(sort, sortDirection, mixin, authority, id, idType, itemType, page, pageSize, partnerId, partnerPid, people, pid, programme, q, segmentEvent);
        return localVarResp.getData();
    }

    /**
     * Look inside programmes to find segments: chapters, tracks and more
     * Look inside programmes to find segments: chapters, tracks and more
     * @param sort Sorts: * pid: sort by pid, descending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * contributions: mixin to return information about contributors to items * images: mixin to add image information for an item * offset: mixin to return programme segment offsets, works in conjunction with programme filter * play_event: mixin to return programme segment events, works in conjunction with programme or segment_event filters  (optional)
     * @param authority filter for subset of items that have an ID issued by the given authority (optional)
     * @param id filter for subset of items having given ID (optional)
     * @param idType filter for subset of items that have given an ID of the given type (optional)
     * @param itemType filter for specific type(s) of items (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for items by partner ID (optional)
     * @param partnerPid filter for items by partner PID (optional)
     * @param people filter for subset of items that have specified person involved (optional)
     * @param pid filter for subset of items matching one of the given PIDs (optional)
     * @param programme filter for subset of items that are part of the given programme (optional)
     * @param q filter for subset of items matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param segmentEvent filter for item with the given segment_event (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listItemsWithHttpInfo(String sort, String sortDirection, List<String> mixin, String authority, List<String> id, String idType, List<String> itemType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String programme, String q, String segmentEvent) throws ApiException {
        okhttp3.Call localVarCall = listItemsValidateBeforeCall(sort, sortDirection, mixin, authority, id, idType, itemType, page, pageSize, partnerId, partnerPid, people, pid, programme, q, segmentEvent, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Look inside programmes to find segments: chapters, tracks and more (asynchronously)
     * Look inside programmes to find segments: chapters, tracks and more
     * @param sort Sorts: * pid: sort by pid, descending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * contributions: mixin to return information about contributors to items * images: mixin to add image information for an item * offset: mixin to return programme segment offsets, works in conjunction with programme filter * play_event: mixin to return programme segment events, works in conjunction with programme or segment_event filters  (optional)
     * @param authority filter for subset of items that have an ID issued by the given authority (optional)
     * @param id filter for subset of items having given ID (optional)
     * @param idType filter for subset of items that have given an ID of the given type (optional)
     * @param itemType filter for specific type(s) of items (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for items by partner ID (optional)
     * @param partnerPid filter for items by partner PID (optional)
     * @param people filter for subset of items that have specified person involved (optional)
     * @param pid filter for subset of items matching one of the given PIDs (optional)
     * @param programme filter for subset of items that are part of the given programme (optional)
     * @param q filter for subset of items matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param segmentEvent filter for item with the given segment_event (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listItemsAsync(String sort, String sortDirection, List<String> mixin, String authority, List<String> id, String idType, List<String> itemType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String programme, String q, String segmentEvent, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listItemsValidateBeforeCall(sort, sortDirection, mixin, authority, id, idType, itemType, page, pageSize, partnerId, partnerPid, people, pid, programme, q, segmentEvent, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listMasterbrands
     * @param sort Sorts: * mid: sort by mid, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * images: mixin to add image information for a masterbrand  (optional)
     * @param mid filter for subset of masterbrands that have given identifier (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for masterbrands by partner ID (optional)
     * @param partnerPid filter for masterbrands by partner PID (optional)
     * @param q filter for subset of masterbrands matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listMasterbrandsCall(String sort, String sortDirection, List<String> mixin, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/master_brands";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (sortDirection != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_direction", sortDirection));
        }

        if (mixin != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mixin", mixin));
        }

        if (mid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mid", mid));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listMasterbrandsValidateBeforeCall(String sort, String sortDirection, List<String> mixin, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q, final ApiCallback _callback) throws ApiException {
        return listMasterbrandsCall(sort, sortDirection, mixin, mid, page, pageSize, partnerId, partnerPid, q, _callback);

    }

    /**
     * List all Master Brands
     * List all Master Brands
     * @param sort Sorts: * mid: sort by mid, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * images: mixin to add image information for a masterbrand  (optional)
     * @param mid filter for subset of masterbrands that have given identifier (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for masterbrands by partner ID (optional)
     * @param partnerPid filter for masterbrands by partner PID (optional)
     * @param q filter for subset of masterbrands matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listMasterbrands(String sort, String sortDirection, List<String> mixin, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q) throws ApiException {
        ApiResponse<Nitro> localVarResp = listMasterbrandsWithHttpInfo(sort, sortDirection, mixin, mid, page, pageSize, partnerId, partnerPid, q);
        return localVarResp.getData();
    }

    /**
     * List all Master Brands
     * List all Master Brands
     * @param sort Sorts: * mid: sort by mid, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * images: mixin to add image information for a masterbrand  (optional)
     * @param mid filter for subset of masterbrands that have given identifier (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for masterbrands by partner ID (optional)
     * @param partnerPid filter for masterbrands by partner PID (optional)
     * @param q filter for subset of masterbrands matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listMasterbrandsWithHttpInfo(String sort, String sortDirection, List<String> mixin, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q) throws ApiException {
        okhttp3.Call localVarCall = listMasterbrandsValidateBeforeCall(sort, sortDirection, mixin, mid, page, pageSize, partnerId, partnerPid, q, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all Master Brands (asynchronously)
     * List all Master Brands
     * @param sort Sorts: * mid: sort by mid, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * images: mixin to add image information for a masterbrand  (optional)
     * @param mid filter for subset of masterbrands that have given identifier (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for masterbrands by partner ID (optional)
     * @param partnerPid filter for masterbrands by partner PID (optional)
     * @param q filter for subset of masterbrands matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listMasterbrandsAsync(String sort, String sortDirection, List<String> mixin, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listMasterbrandsValidateBeforeCall(sort, sortDirection, mixin, mid, page, pageSize, partnerId, partnerPid, q, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listPeople
     * @param authority filter for subset of people that have an ID issued by the given authority (optional)
     * @param hasExternalId filter for people who have an external identifier (optional)
     * @param id filter for subset of people having given ID (optional)
     * @param idType filter for subset of people that have given an ID of the given type (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for people by partner ID (optional)
     * @param partnerPid filter for people by partner PID (optional)
     * @param pid filter for subset of people having given PID (optional)
     * @param programme filter for subset of people that have contributed to the given programme pid (optional)
     * @param q filter for subset of people matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listPeopleCall(String authority, List<String> hasExternalId, List<String> id, String idType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String programme, String q, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/people";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (authority != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("authority", authority));
        }

        if (hasExternalId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "has_external_id", hasExternalId));
        }

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("id_type", idType));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (pid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "pid", pid));
        }

        if (programme != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("programme", programme));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listPeopleValidateBeforeCall(String authority, List<String> hasExternalId, List<String> id, String idType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String programme, String q, final ApiCallback _callback) throws ApiException {
        return listPeopleCall(authority, hasExternalId, id, idType, page, pageSize, partnerId, partnerPid, pid, programme, q, _callback);

    }

    /**
     * Find the people behind and in programmes: cast, crew, guests and more
     * The People feed allows you to search for the people and groups that contribute to programmes. This is the starting point for cast and crew credits, as well as finding contributors using external IDs (such as Wikipedia URLs)
     * @param authority filter for subset of people that have an ID issued by the given authority (optional)
     * @param hasExternalId filter for people who have an external identifier (optional)
     * @param id filter for subset of people having given ID (optional)
     * @param idType filter for subset of people that have given an ID of the given type (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for people by partner ID (optional)
     * @param partnerPid filter for people by partner PID (optional)
     * @param pid filter for subset of people having given PID (optional)
     * @param programme filter for subset of people that have contributed to the given programme pid (optional)
     * @param q filter for subset of people matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listPeople(String authority, List<String> hasExternalId, List<String> id, String idType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String programme, String q) throws ApiException {
        ApiResponse<Nitro> localVarResp = listPeopleWithHttpInfo(authority, hasExternalId, id, idType, page, pageSize, partnerId, partnerPid, pid, programme, q);
        return localVarResp.getData();
    }

    /**
     * Find the people behind and in programmes: cast, crew, guests and more
     * The People feed allows you to search for the people and groups that contribute to programmes. This is the starting point for cast and crew credits, as well as finding contributors using external IDs (such as Wikipedia URLs)
     * @param authority filter for subset of people that have an ID issued by the given authority (optional)
     * @param hasExternalId filter for people who have an external identifier (optional)
     * @param id filter for subset of people having given ID (optional)
     * @param idType filter for subset of people that have given an ID of the given type (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for people by partner ID (optional)
     * @param partnerPid filter for people by partner PID (optional)
     * @param pid filter for subset of people having given PID (optional)
     * @param programme filter for subset of people that have contributed to the given programme pid (optional)
     * @param q filter for subset of people matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listPeopleWithHttpInfo(String authority, List<String> hasExternalId, List<String> id, String idType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String programme, String q) throws ApiException {
        okhttp3.Call localVarCall = listPeopleValidateBeforeCall(authority, hasExternalId, id, idType, page, pageSize, partnerId, partnerPid, pid, programme, q, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Find the people behind and in programmes: cast, crew, guests and more (asynchronously)
     * The People feed allows you to search for the people and groups that contribute to programmes. This is the starting point for cast and crew credits, as well as finding contributors using external IDs (such as Wikipedia URLs)
     * @param authority filter for subset of people that have an ID issued by the given authority (optional)
     * @param hasExternalId filter for people who have an external identifier (optional)
     * @param id filter for subset of people having given ID (optional)
     * @param idType filter for subset of people that have given an ID of the given type (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for people by partner ID (optional)
     * @param partnerPid filter for people by partner PID (optional)
     * @param pid filter for subset of people having given PID (optional)
     * @param programme filter for subset of people that have contributed to the given programme pid (optional)
     * @param q filter for subset of people matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listPeopleAsync(String authority, List<String> hasExternalId, List<String> id, String idType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, String programme, String q, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listPeopleValidateBeforeCall(authority, hasExternalId, id, idType, page, pageSize, partnerId, partnerPid, pid, programme, q, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listPips
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param q filter for subset of programmes matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listPipsCall(Integer page, Integer pageSize, String q, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/pips";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listPipsValidateBeforeCall(Integer page, Integer pageSize, String q, final ApiCallback _callback) throws ApiException {
        return listPipsCall(page, pageSize, q, _callback);

    }

    /**
     * Look inside pips entities
     * Look inside pips entities
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param q filter for subset of programmes matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listPips(Integer page, Integer pageSize, String q) throws ApiException {
        ApiResponse<Nitro> localVarResp = listPipsWithHttpInfo(page, pageSize, q);
        return localVarResp.getData();
    }

    /**
     * Look inside pips entities
     * Look inside pips entities
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param q filter for subset of programmes matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listPipsWithHttpInfo(Integer page, Integer pageSize, String q) throws ApiException {
        okhttp3.Call localVarCall = listPipsValidateBeforeCall(page, pageSize, q, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Look inside pips entities (asynchronously)
     * Look inside pips entities
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param q filter for subset of programmes matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listPipsAsync(Integer page, Integer pageSize, String q, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listPipsValidateBeforeCall(page, pageSize, q, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listProgrammeDetails
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerPid Filter for programme information by partner PID (optional)
     * @param pid Filter for programme information for the provided PID (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProgrammeDetailsCall(Integer page, Integer pageSize, String partnerPid, String pid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/programme_details";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerPid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("partner_pid", partnerPid));
        }

        if (pid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pid", pid));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listProgrammeDetailsValidateBeforeCall(Integer page, Integer pageSize, String partnerPid, String pid, final ApiCallback _callback) throws ApiException {
        return listProgrammeDetailsCall(page, pageSize, partnerPid, pid, _callback);

    }

    /**
     * Exposes programme information for a single pid
     * Exposes programme information for a single pid
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerPid Filter for programme information by partner PID (optional)
     * @param pid Filter for programme information for the provided PID (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listProgrammeDetails(Integer page, Integer pageSize, String partnerPid, String pid) throws ApiException {
        ApiResponse<Nitro> localVarResp = listProgrammeDetailsWithHttpInfo(page, pageSize, partnerPid, pid);
        return localVarResp.getData();
    }

    /**
     * Exposes programme information for a single pid
     * Exposes programme information for a single pid
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerPid Filter for programme information by partner PID (optional)
     * @param pid Filter for programme information for the provided PID (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listProgrammeDetailsWithHttpInfo(Integer page, Integer pageSize, String partnerPid, String pid) throws ApiException {
        okhttp3.Call localVarCall = listProgrammeDetailsValidateBeforeCall(page, pageSize, partnerPid, pid, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Exposes programme information for a single pid (asynchronously)
     * Exposes programme information for a single pid
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerPid Filter for programme information by partner PID (optional)
     * @param pid Filter for programme information for the provided PID (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProgrammeDetailsAsync(Integer page, Integer pageSize, String partnerPid, String pid, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listProgrammeDetailsValidateBeforeCall(page, pageSize, partnerPid, pid, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listProgrammes
     * @param sort Sorts: * group_position: sort numerically by position in group, ascending * pid: sort alphabetically by PID, descending * position: sort numerically by position, ascending * promotion: sort by promotion rank, ascending * release_date: sort chronologically by release date, descending * relevance: sort by weighting of search term (use with q parameter) * scheduled_start: sort chronologically by scheduled start time/date, ascending * strict_title: sort alphabetically by title, ascending * title: sort by title librarian style (ignoring leading &#39;The&#39;, &#39;A&#39;, etc), ascending * tree: sort by root pid and then preorder tree sort. Requires entities to have release date.  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * alternate_images: mixin to return the alternate images for a programme * ancestor_titles: mixin to return ancestor programme titles * availability: mixin to return programme availability information * available_simulcasts: mixin to return information about programmes that are currently available as simulcasts * available_versions: mixin to return information about programmes that are currently available on demand * available_webcasts: mixin to return information about programmes that are currently available as webcasts * contributions: mixin to return information about contributors to a programme * duration: mixin to return original version duration in programme concept entities * genre_groupings: mixin to return list of genre groupings * genre_groups: mixin to return list of genre groups * images: mixin to add image information for a programme * is_embeddable: mixin to add embeddable information for a programme * previous_next: mixin to return the programmes which appear before and after a programme (as determined by the sort applied in the request) * programme_type: mixin to return the programme type * related_links: mixin to return information about related links to a programme * titles: mixin to return ancestor programme titles * versions_availability: mixin to return information about programmes that are currently available  (optional)
     * @param audioDescribed filter for subset of programmes that are audio-described (optional)
     * @param availability filter for subset of programmes that have availability (optional)
     * @param availabilityEntityType additional filter when availability&#x3D;available (optional)
     * @param availabilityFrom filter for subset of programmes that are available after or at the specified datetime (optional)
     * @param availabilityType filter for a subset of programmes that are available for a given type (optional)
     * @param childrenOf filter for subset of programmes that have PID as immediate parent (optional)
     * @param descendantsOf filter for subset of programmes that have PID as ancestor (optional)
     * @param duration filter for subset of programmes that have given duration (optional)
     * @param entityType filter for subset of programmes that have given entity type (optional)
     * @param format filter for subset of programmes with format (optional)
     * @param genre filter for subset of programmes with genre (optional)
     * @param group filter for subset of programmes which belong to the given group pid (optional)
     * @param initialLetter filter for subset of programmes with title beginning with initial letter librarian style (ignoring leading &#39;The&#39;, &#39;An&#39; (Welsh), etc) 0-9 a-z (optional)
     * @param initialLetterEnd Programmes with (librarian) titles whose initial letter is equal/before given letter. Use with initial_letter_start for a range (optional)
     * @param initialLetterStart Programmes with (librarian) titles whose initial letter is equal/after given letter. Use with initial_letter_end for range. (optional)
     * @param initialLetterStrict filter for subset of programmes with title beginning with initial letter (optional)
     * @param item filter for subset of programmes with linked to versions which have the given item pids (optional)
     * @param masterBrand filter for subset of programmes with master_brand (optional)
     * @param mediaSet filter for subset of programmes with media set (optional)
     * @param mediaType filter for subset of programmes with media type (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for programmes by partner ID (optional)
     * @param partnerPid filter for programmes by partner PID (optional)
     * @param paymentType filter for a subset of programmes that are of the given payment_type (optional)
     * @param people filter for subset of programmes with contributions by given people PID (optional)
     * @param pid filter for subset of programmes having given PID (optional)
     * @param promotedFor filter for subset of programmes which are promoted for given service (optional)
     * @param q filter for subset of programmes matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param signed filter for subset of programmes that are signed (optional)
     * @param tagName filter for subset of programmes with tag (optional)
     * @param tagScheme filter for subset of programmes with a tag (optional)
     * @param tleo filter for subset of programmes that are TLEOs (optional)
     * @param version filter for subset of programmes with given PID as one of their versions (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProgrammesCall(String sort, String sortDirection, List<String> mixin, List<String> audioDescribed, List<String> availability, List<String> availabilityEntityType, OffsetDateTime availabilityFrom, List<String> availabilityType, List<String> childrenOf, List<String> descendantsOf, List<String> duration, List<String> entityType, List<String> format, List<String> genre, String group, String initialLetter, String initialLetterEnd, String initialLetterStart, List<String> initialLetterStrict, List<String> item, List<String> masterBrand, String mediaSet, List<String> mediaType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, String people, List<String> pid, String promotedFor, String q, List<String> signed, String tagName, String tagScheme, List<String> tleo, List<String> version, String embargoed, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/programmes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (sortDirection != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_direction", sortDirection));
        }

        if (mixin != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mixin", mixin));
        }

        if (audioDescribed != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "audio_described", audioDescribed));
        }

        if (availability != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "availability", availability));
        }

        if (availabilityEntityType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "availability_entity_type", availabilityEntityType));
        }

        if (availabilityFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("availability_from", availabilityFrom));
        }

        if (availabilityType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "availability_type", availabilityType));
        }

        if (childrenOf != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "children_of", childrenOf));
        }

        if (descendantsOf != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "descendants_of", descendantsOf));
        }

        if (duration != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "duration", duration));
        }

        if (entityType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "entity_type", entityType));
        }

        if (format != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "format", format));
        }

        if (genre != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "genre", genre));
        }

        if (group != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group", group));
        }

        if (initialLetter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("initial_letter", initialLetter));
        }

        if (initialLetterEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("initial_letter_end", initialLetterEnd));
        }

        if (initialLetterStart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("initial_letter_start", initialLetterStart));
        }

        if (initialLetterStrict != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "initial_letter_strict", initialLetterStrict));
        }

        if (item != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "item", item));
        }

        if (masterBrand != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "master_brand", masterBrand));
        }

        if (mediaSet != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("media_set", mediaSet));
        }

        if (mediaType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "media_type", mediaType));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (paymentType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "payment_type", paymentType));
        }

        if (people != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("people", people));
        }

        if (pid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "pid", pid));
        }

        if (promotedFor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("promoted_for", promotedFor));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (signed != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "signed", signed));
        }

        if (tagName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag_name", tagName));
        }

        if (tagScheme != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag_scheme", tagScheme));
        }

        if (tleo != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "tleo", tleo));
        }

        if (version != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "version", version));
        }

        if (embargoed != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("embargoed", embargoed));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listProgrammesValidateBeforeCall(String sort, String sortDirection, List<String> mixin, List<String> audioDescribed, List<String> availability, List<String> availabilityEntityType, OffsetDateTime availabilityFrom, List<String> availabilityType, List<String> childrenOf, List<String> descendantsOf, List<String> duration, List<String> entityType, List<String> format, List<String> genre, String group, String initialLetter, String initialLetterEnd, String initialLetterStart, List<String> initialLetterStrict, List<String> item, List<String> masterBrand, String mediaSet, List<String> mediaType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, String people, List<String> pid, String promotedFor, String q, List<String> signed, String tagName, String tagScheme, List<String> tleo, List<String> version, String embargoed, final ApiCallback _callback) throws ApiException {
        return listProgrammesCall(sort, sortDirection, mixin, audioDescribed, availability, availabilityEntityType, availabilityFrom, availabilityType, childrenOf, descendantsOf, duration, entityType, format, genre, group, initialLetter, initialLetterEnd, initialLetterStart, initialLetterStrict, item, masterBrand, mediaSet, mediaType, page, pageSize, partnerId, partnerPid, paymentType, people, pid, promotedFor, q, signed, tagName, tagScheme, tleo, version, embargoed, _callback);

    }

    /**
     * Start here for programmes metadata: Brands, Series, Episodes and Clips
     * Fetch metadata about Programmes (brands, series, episodes, clips). By applying different filter restrictions this feed can be used in many ways, for example to retrieve all series belonging to a brand, all the episodes and/or clips for a specific series, or any TLEO objects for a masterbrand. Other filters permit restricting to specific formats and/or genres, and you can request specific versions (for example Signed or Audio-Described). Parameters may be combined in any way suitable for your application.
     * @param sort Sorts: * group_position: sort numerically by position in group, ascending * pid: sort alphabetically by PID, descending * position: sort numerically by position, ascending * promotion: sort by promotion rank, ascending * release_date: sort chronologically by release date, descending * relevance: sort by weighting of search term (use with q parameter) * scheduled_start: sort chronologically by scheduled start time/date, ascending * strict_title: sort alphabetically by title, ascending * title: sort by title librarian style (ignoring leading &#39;The&#39;, &#39;A&#39;, etc), ascending * tree: sort by root pid and then preorder tree sort. Requires entities to have release date.  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * alternate_images: mixin to return the alternate images for a programme * ancestor_titles: mixin to return ancestor programme titles * availability: mixin to return programme availability information * available_simulcasts: mixin to return information about programmes that are currently available as simulcasts * available_versions: mixin to return information about programmes that are currently available on demand * available_webcasts: mixin to return information about programmes that are currently available as webcasts * contributions: mixin to return information about contributors to a programme * duration: mixin to return original version duration in programme concept entities * genre_groupings: mixin to return list of genre groupings * genre_groups: mixin to return list of genre groups * images: mixin to add image information for a programme * is_embeddable: mixin to add embeddable information for a programme * previous_next: mixin to return the programmes which appear before and after a programme (as determined by the sort applied in the request) * programme_type: mixin to return the programme type * related_links: mixin to return information about related links to a programme * titles: mixin to return ancestor programme titles * versions_availability: mixin to return information about programmes that are currently available  (optional)
     * @param audioDescribed filter for subset of programmes that are audio-described (optional)
     * @param availability filter for subset of programmes that have availability (optional)
     * @param availabilityEntityType additional filter when availability&#x3D;available (optional)
     * @param availabilityFrom filter for subset of programmes that are available after or at the specified datetime (optional)
     * @param availabilityType filter for a subset of programmes that are available for a given type (optional)
     * @param childrenOf filter for subset of programmes that have PID as immediate parent (optional)
     * @param descendantsOf filter for subset of programmes that have PID as ancestor (optional)
     * @param duration filter for subset of programmes that have given duration (optional)
     * @param entityType filter for subset of programmes that have given entity type (optional)
     * @param format filter for subset of programmes with format (optional)
     * @param genre filter for subset of programmes with genre (optional)
     * @param group filter for subset of programmes which belong to the given group pid (optional)
     * @param initialLetter filter for subset of programmes with title beginning with initial letter librarian style (ignoring leading &#39;The&#39;, &#39;An&#39; (Welsh), etc) 0-9 a-z (optional)
     * @param initialLetterEnd Programmes with (librarian) titles whose initial letter is equal/before given letter. Use with initial_letter_start for a range (optional)
     * @param initialLetterStart Programmes with (librarian) titles whose initial letter is equal/after given letter. Use with initial_letter_end for range. (optional)
     * @param initialLetterStrict filter for subset of programmes with title beginning with initial letter (optional)
     * @param item filter for subset of programmes with linked to versions which have the given item pids (optional)
     * @param masterBrand filter for subset of programmes with master_brand (optional)
     * @param mediaSet filter for subset of programmes with media set (optional)
     * @param mediaType filter for subset of programmes with media type (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for programmes by partner ID (optional)
     * @param partnerPid filter for programmes by partner PID (optional)
     * @param paymentType filter for a subset of programmes that are of the given payment_type (optional)
     * @param people filter for subset of programmes with contributions by given people PID (optional)
     * @param pid filter for subset of programmes having given PID (optional)
     * @param promotedFor filter for subset of programmes which are promoted for given service (optional)
     * @param q filter for subset of programmes matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param signed filter for subset of programmes that are signed (optional)
     * @param tagName filter for subset of programmes with tag (optional)
     * @param tagScheme filter for subset of programmes with a tag (optional)
     * @param tleo filter for subset of programmes that are TLEOs (optional)
     * @param version filter for subset of programmes with given PID as one of their versions (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listProgrammes(String sort, String sortDirection, List<String> mixin, List<String> audioDescribed, List<String> availability, List<String> availabilityEntityType, OffsetDateTime availabilityFrom, List<String> availabilityType, List<String> childrenOf, List<String> descendantsOf, List<String> duration, List<String> entityType, List<String> format, List<String> genre, String group, String initialLetter, String initialLetterEnd, String initialLetterStart, List<String> initialLetterStrict, List<String> item, List<String> masterBrand, String mediaSet, List<String> mediaType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, String people, List<String> pid, String promotedFor, String q, List<String> signed, String tagName, String tagScheme, List<String> tleo, List<String> version, String embargoed) throws ApiException {
        ApiResponse<Nitro> localVarResp = listProgrammesWithHttpInfo(sort, sortDirection, mixin, audioDescribed, availability, availabilityEntityType, availabilityFrom, availabilityType, childrenOf, descendantsOf, duration, entityType, format, genre, group, initialLetter, initialLetterEnd, initialLetterStart, initialLetterStrict, item, masterBrand, mediaSet, mediaType, page, pageSize, partnerId, partnerPid, paymentType, people, pid, promotedFor, q, signed, tagName, tagScheme, tleo, version, embargoed);
        return localVarResp.getData();
    }

    /**
     * Start here for programmes metadata: Brands, Series, Episodes and Clips
     * Fetch metadata about Programmes (brands, series, episodes, clips). By applying different filter restrictions this feed can be used in many ways, for example to retrieve all series belonging to a brand, all the episodes and/or clips for a specific series, or any TLEO objects for a masterbrand. Other filters permit restricting to specific formats and/or genres, and you can request specific versions (for example Signed or Audio-Described). Parameters may be combined in any way suitable for your application.
     * @param sort Sorts: * group_position: sort numerically by position in group, ascending * pid: sort alphabetically by PID, descending * position: sort numerically by position, ascending * promotion: sort by promotion rank, ascending * release_date: sort chronologically by release date, descending * relevance: sort by weighting of search term (use with q parameter) * scheduled_start: sort chronologically by scheduled start time/date, ascending * strict_title: sort alphabetically by title, ascending * title: sort by title librarian style (ignoring leading &#39;The&#39;, &#39;A&#39;, etc), ascending * tree: sort by root pid and then preorder tree sort. Requires entities to have release date.  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * alternate_images: mixin to return the alternate images for a programme * ancestor_titles: mixin to return ancestor programme titles * availability: mixin to return programme availability information * available_simulcasts: mixin to return information about programmes that are currently available as simulcasts * available_versions: mixin to return information about programmes that are currently available on demand * available_webcasts: mixin to return information about programmes that are currently available as webcasts * contributions: mixin to return information about contributors to a programme * duration: mixin to return original version duration in programme concept entities * genre_groupings: mixin to return list of genre groupings * genre_groups: mixin to return list of genre groups * images: mixin to add image information for a programme * is_embeddable: mixin to add embeddable information for a programme * previous_next: mixin to return the programmes which appear before and after a programme (as determined by the sort applied in the request) * programme_type: mixin to return the programme type * related_links: mixin to return information about related links to a programme * titles: mixin to return ancestor programme titles * versions_availability: mixin to return information about programmes that are currently available  (optional)
     * @param audioDescribed filter for subset of programmes that are audio-described (optional)
     * @param availability filter for subset of programmes that have availability (optional)
     * @param availabilityEntityType additional filter when availability&#x3D;available (optional)
     * @param availabilityFrom filter for subset of programmes that are available after or at the specified datetime (optional)
     * @param availabilityType filter for a subset of programmes that are available for a given type (optional)
     * @param childrenOf filter for subset of programmes that have PID as immediate parent (optional)
     * @param descendantsOf filter for subset of programmes that have PID as ancestor (optional)
     * @param duration filter for subset of programmes that have given duration (optional)
     * @param entityType filter for subset of programmes that have given entity type (optional)
     * @param format filter for subset of programmes with format (optional)
     * @param genre filter for subset of programmes with genre (optional)
     * @param group filter for subset of programmes which belong to the given group pid (optional)
     * @param initialLetter filter for subset of programmes with title beginning with initial letter librarian style (ignoring leading &#39;The&#39;, &#39;An&#39; (Welsh), etc) 0-9 a-z (optional)
     * @param initialLetterEnd Programmes with (librarian) titles whose initial letter is equal/before given letter. Use with initial_letter_start for a range (optional)
     * @param initialLetterStart Programmes with (librarian) titles whose initial letter is equal/after given letter. Use with initial_letter_end for range. (optional)
     * @param initialLetterStrict filter for subset of programmes with title beginning with initial letter (optional)
     * @param item filter for subset of programmes with linked to versions which have the given item pids (optional)
     * @param masterBrand filter for subset of programmes with master_brand (optional)
     * @param mediaSet filter for subset of programmes with media set (optional)
     * @param mediaType filter for subset of programmes with media type (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for programmes by partner ID (optional)
     * @param partnerPid filter for programmes by partner PID (optional)
     * @param paymentType filter for a subset of programmes that are of the given payment_type (optional)
     * @param people filter for subset of programmes with contributions by given people PID (optional)
     * @param pid filter for subset of programmes having given PID (optional)
     * @param promotedFor filter for subset of programmes which are promoted for given service (optional)
     * @param q filter for subset of programmes matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param signed filter for subset of programmes that are signed (optional)
     * @param tagName filter for subset of programmes with tag (optional)
     * @param tagScheme filter for subset of programmes with a tag (optional)
     * @param tleo filter for subset of programmes that are TLEOs (optional)
     * @param version filter for subset of programmes with given PID as one of their versions (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listProgrammesWithHttpInfo(String sort, String sortDirection, List<String> mixin, List<String> audioDescribed, List<String> availability, List<String> availabilityEntityType, OffsetDateTime availabilityFrom, List<String> availabilityType, List<String> childrenOf, List<String> descendantsOf, List<String> duration, List<String> entityType, List<String> format, List<String> genre, String group, String initialLetter, String initialLetterEnd, String initialLetterStart, List<String> initialLetterStrict, List<String> item, List<String> masterBrand, String mediaSet, List<String> mediaType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, String people, List<String> pid, String promotedFor, String q, List<String> signed, String tagName, String tagScheme, List<String> tleo, List<String> version, String embargoed) throws ApiException {
        okhttp3.Call localVarCall = listProgrammesValidateBeforeCall(sort, sortDirection, mixin, audioDescribed, availability, availabilityEntityType, availabilityFrom, availabilityType, childrenOf, descendantsOf, duration, entityType, format, genre, group, initialLetter, initialLetterEnd, initialLetterStart, initialLetterStrict, item, masterBrand, mediaSet, mediaType, page, pageSize, partnerId, partnerPid, paymentType, people, pid, promotedFor, q, signed, tagName, tagScheme, tleo, version, embargoed, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Start here for programmes metadata: Brands, Series, Episodes and Clips (asynchronously)
     * Fetch metadata about Programmes (brands, series, episodes, clips). By applying different filter restrictions this feed can be used in many ways, for example to retrieve all series belonging to a brand, all the episodes and/or clips for a specific series, or any TLEO objects for a masterbrand. Other filters permit restricting to specific formats and/or genres, and you can request specific versions (for example Signed or Audio-Described). Parameters may be combined in any way suitable for your application.
     * @param sort Sorts: * group_position: sort numerically by position in group, ascending * pid: sort alphabetically by PID, descending * position: sort numerically by position, ascending * promotion: sort by promotion rank, ascending * release_date: sort chronologically by release date, descending * relevance: sort by weighting of search term (use with q parameter) * scheduled_start: sort chronologically by scheduled start time/date, ascending * strict_title: sort alphabetically by title, ascending * title: sort by title librarian style (ignoring leading &#39;The&#39;, &#39;A&#39;, etc), ascending * tree: sort by root pid and then preorder tree sort. Requires entities to have release date.  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * alternate_images: mixin to return the alternate images for a programme * ancestor_titles: mixin to return ancestor programme titles * availability: mixin to return programme availability information * available_simulcasts: mixin to return information about programmes that are currently available as simulcasts * available_versions: mixin to return information about programmes that are currently available on demand * available_webcasts: mixin to return information about programmes that are currently available as webcasts * contributions: mixin to return information about contributors to a programme * duration: mixin to return original version duration in programme concept entities * genre_groupings: mixin to return list of genre groupings * genre_groups: mixin to return list of genre groups * images: mixin to add image information for a programme * is_embeddable: mixin to add embeddable information for a programme * previous_next: mixin to return the programmes which appear before and after a programme (as determined by the sort applied in the request) * programme_type: mixin to return the programme type * related_links: mixin to return information about related links to a programme * titles: mixin to return ancestor programme titles * versions_availability: mixin to return information about programmes that are currently available  (optional)
     * @param audioDescribed filter for subset of programmes that are audio-described (optional)
     * @param availability filter for subset of programmes that have availability (optional)
     * @param availabilityEntityType additional filter when availability&#x3D;available (optional)
     * @param availabilityFrom filter for subset of programmes that are available after or at the specified datetime (optional)
     * @param availabilityType filter for a subset of programmes that are available for a given type (optional)
     * @param childrenOf filter for subset of programmes that have PID as immediate parent (optional)
     * @param descendantsOf filter for subset of programmes that have PID as ancestor (optional)
     * @param duration filter for subset of programmes that have given duration (optional)
     * @param entityType filter for subset of programmes that have given entity type (optional)
     * @param format filter for subset of programmes with format (optional)
     * @param genre filter for subset of programmes with genre (optional)
     * @param group filter for subset of programmes which belong to the given group pid (optional)
     * @param initialLetter filter for subset of programmes with title beginning with initial letter librarian style (ignoring leading &#39;The&#39;, &#39;An&#39; (Welsh), etc) 0-9 a-z (optional)
     * @param initialLetterEnd Programmes with (librarian) titles whose initial letter is equal/before given letter. Use with initial_letter_start for a range (optional)
     * @param initialLetterStart Programmes with (librarian) titles whose initial letter is equal/after given letter. Use with initial_letter_end for range. (optional)
     * @param initialLetterStrict filter for subset of programmes with title beginning with initial letter (optional)
     * @param item filter for subset of programmes with linked to versions which have the given item pids (optional)
     * @param masterBrand filter for subset of programmes with master_brand (optional)
     * @param mediaSet filter for subset of programmes with media set (optional)
     * @param mediaType filter for subset of programmes with media type (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for programmes by partner ID (optional)
     * @param partnerPid filter for programmes by partner PID (optional)
     * @param paymentType filter for a subset of programmes that are of the given payment_type (optional)
     * @param people filter for subset of programmes with contributions by given people PID (optional)
     * @param pid filter for subset of programmes having given PID (optional)
     * @param promotedFor filter for subset of programmes which are promoted for given service (optional)
     * @param q filter for subset of programmes matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param signed filter for subset of programmes that are signed (optional)
     * @param tagName filter for subset of programmes with tag (optional)
     * @param tagScheme filter for subset of programmes with a tag (optional)
     * @param tleo filter for subset of programmes that are TLEOs (optional)
     * @param version filter for subset of programmes with given PID as one of their versions (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProgrammesAsync(String sort, String sortDirection, List<String> mixin, List<String> audioDescribed, List<String> availability, List<String> availabilityEntityType, OffsetDateTime availabilityFrom, List<String> availabilityType, List<String> childrenOf, List<String> descendantsOf, List<String> duration, List<String> entityType, List<String> format, List<String> genre, String group, String initialLetter, String initialLetterEnd, String initialLetterStart, List<String> initialLetterStrict, List<String> item, List<String> masterBrand, String mediaSet, List<String> mediaType, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, String people, List<String> pid, String promotedFor, String q, List<String> signed, String tagName, String tagScheme, List<String> tleo, List<String> version, String embargoed, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listProgrammesValidateBeforeCall(sort, sortDirection, mixin, audioDescribed, availability, availabilityEntityType, availabilityFrom, availabilityType, childrenOf, descendantsOf, duration, entityType, format, genre, group, initialLetter, initialLetterEnd, initialLetterStart, initialLetterStrict, item, masterBrand, mediaSet, mediaType, page, pageSize, partnerId, partnerPid, paymentType, people, pid, promotedFor, q, signed, tagName, tagScheme, tleo, version, embargoed, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listPromotions
     * @param mixin Mixins: * related_links: mixin to return information about related links to a promotion  (optional)
     * @param context filter for subset of promotions belonging to a given context (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for promotions by partner ID (optional)
     * @param partnerPid filter for promotions by partner PID (optional)
     * @param pid filter for subset of promotions having given PID (optional)
     * @param promotedBy filter for subset of promotions having given promoted by (optional)
     * @param promotedFor filter for subset of promotions having given promoted for (optional)
     * @param q filter for subset of promotions matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param status filter for subset of promotions with status (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listPromotionsCall(List<String> mixin, String context, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, List<String> promotedBy, List<String> promotedFor, String q, List<String> status, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/promotions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (mixin != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mixin", mixin));
        }

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (pid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "pid", pid));
        }

        if (promotedBy != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "promoted_by", promotedBy));
        }

        if (promotedFor != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "promoted_for", promotedFor));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (status != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "status", status));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listPromotionsValidateBeforeCall(List<String> mixin, String context, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, List<String> promotedBy, List<String> promotedFor, String q, List<String> status, final ApiCallback _callback) throws ApiException {
        return listPromotionsCall(mixin, context, page, pageSize, partnerId, partnerPid, pid, promotedBy, promotedFor, q, status, _callback);

    }

    /**
     * Discover metadata for content promotions
     * Details of short-term editorially curated \&quot;promotions\&quot;, for instance those programmes featured on iPlayer today
     * @param mixin Mixins: * related_links: mixin to return information about related links to a promotion  (optional)
     * @param context filter for subset of promotions belonging to a given context (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for promotions by partner ID (optional)
     * @param partnerPid filter for promotions by partner PID (optional)
     * @param pid filter for subset of promotions having given PID (optional)
     * @param promotedBy filter for subset of promotions having given promoted by (optional)
     * @param promotedFor filter for subset of promotions having given promoted for (optional)
     * @param q filter for subset of promotions matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param status filter for subset of promotions with status (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listPromotions(List<String> mixin, String context, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, List<String> promotedBy, List<String> promotedFor, String q, List<String> status) throws ApiException {
        ApiResponse<Nitro> localVarResp = listPromotionsWithHttpInfo(mixin, context, page, pageSize, partnerId, partnerPid, pid, promotedBy, promotedFor, q, status);
        return localVarResp.getData();
    }

    /**
     * Discover metadata for content promotions
     * Details of short-term editorially curated \&quot;promotions\&quot;, for instance those programmes featured on iPlayer today
     * @param mixin Mixins: * related_links: mixin to return information about related links to a promotion  (optional)
     * @param context filter for subset of promotions belonging to a given context (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for promotions by partner ID (optional)
     * @param partnerPid filter for promotions by partner PID (optional)
     * @param pid filter for subset of promotions having given PID (optional)
     * @param promotedBy filter for subset of promotions having given promoted by (optional)
     * @param promotedFor filter for subset of promotions having given promoted for (optional)
     * @param q filter for subset of promotions matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param status filter for subset of promotions with status (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listPromotionsWithHttpInfo(List<String> mixin, String context, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, List<String> promotedBy, List<String> promotedFor, String q, List<String> status) throws ApiException {
        okhttp3.Call localVarCall = listPromotionsValidateBeforeCall(mixin, context, page, pageSize, partnerId, partnerPid, pid, promotedBy, promotedFor, q, status, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Discover metadata for content promotions (asynchronously)
     * Details of short-term editorially curated \&quot;promotions\&quot;, for instance those programmes featured on iPlayer today
     * @param mixin Mixins: * related_links: mixin to return information about related links to a promotion  (optional)
     * @param context filter for subset of promotions belonging to a given context (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for promotions by partner ID (optional)
     * @param partnerPid filter for promotions by partner PID (optional)
     * @param pid filter for subset of promotions having given PID (optional)
     * @param promotedBy filter for subset of promotions having given promoted by (optional)
     * @param promotedFor filter for subset of promotions having given promoted for (optional)
     * @param q filter for subset of promotions matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param status filter for subset of promotions with status (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listPromotionsAsync(List<String> mixin, String context, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> pid, List<String> promotedBy, List<String> promotedFor, String q, List<String> status, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listPromotionsValidateBeforeCall(mixin, context, page, pageSize, partnerId, partnerPid, pid, promotedBy, promotedFor, q, status, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listSchedules
     * @param sort Sorts: * start_date: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * ancestor_titles: return ancestor programme titles * images: mixin to add image information for broadcasts and webcasts * titles: return ancestor programme titles  (optional)
     * @param authority filter for subset of broadcasts and webcasts that have given authority (optional)
     * @param descendantsOf filter for subset of broadcasts and webcasts that are descendants of the given programme PID (optional)
     * @param endFrom filter for subset of broadcasts and webcasts that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts and webcasts that end on or earlier than the specified datetime (optional)
     * @param format filter for subset of broadcasts and webcasts that are classified in the given format ID (optional)
     * @param genre filter for subset of broadcasts and webcasts that are classified in the given genre ID (optional)
     * @param group filter for subset of broadcasts and webcasts that have programmes in the given group (optional)
     * @param id filter for subset of broadcasts and webcasts that have given identifier (optional)
     * @param idType filter for subset of broadcasts and webcasts that have given id type (optional)
     * @param item filter for subset of broadcasts and webcasts with the given item performed on it (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for broadcasts and webcasts by partner ID (optional)
     * @param partnerPid filter for broadcasts and webcasts by partner PID (optional)
     * @param people filter for subset of broadcasts and webcasts that have given contributor (optional)
     * @param pid filter for subset of broadcasts and webcasts having given PID (optional)
     * @param q filter for subset of broadcasts and webcasts matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param repeat filter to show either only repeats or non-repeats (optional)
     * @param scheduleDay filter for subset of broadcasts and webcasts that start on the specified day (BBC time) (optional)
     * @param scheduleDayFrom filter for subset of broadcasts and webcasts that start on or after the specified day (BBC time) (optional)
     * @param scheduleDayTo filter for subset of broadcasts and webcasts that start on or before the specified day (BBC time) (optional)
     * @param serviceMasterBrand filter for subset of broadcasts and webcasts with given service master brand (optional)
     * @param sid filter for subset of broadcasts and webcasts that are on the specified linear service (optional)
     * @param startFrom filter for subset of broadcasts and webcasts that start on or later than the specified datetime (optional)
     * @param startTo filter for subset of broadcasts and webcasts that start on or earlier than the specified datetime (optional)
     * @param version filter for subset of broadcasts and webcasts with given PID as their parent version (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listSchedulesCall(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, String group, List<String> id, List<String> idType, List<String> item, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String q, Boolean repeat, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/schedules";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (sortDirection != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_direction", sortDirection));
        }

        if (mixin != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mixin", mixin));
        }

        if (authority != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "authority", authority));
        }

        if (descendantsOf != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "descendants_of", descendantsOf));
        }

        if (endFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_from", endFrom));
        }

        if (endTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_to", endTo));
        }

        if (format != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "format", format));
        }

        if (genre != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "genre", genre));
        }

        if (group != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group", group));
        }

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (idType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id_type", idType));
        }

        if (item != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "item", item));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (people != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("people", people));
        }

        if (pid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "pid", pid));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (repeat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("repeat", repeat));
        }

        if (scheduleDay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("schedule_day", scheduleDay));
        }

        if (scheduleDayFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("schedule_day_from", scheduleDayFrom));
        }

        if (scheduleDayTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("schedule_day_to", scheduleDayTo));
        }

        if (serviceMasterBrand != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "service_master_brand", serviceMasterBrand));
        }

        if (sid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "sid", sid));
        }

        if (startFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_from", startFrom));
        }

        if (startTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_to", startTo));
        }

        if (version != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "version", version));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listSchedulesValidateBeforeCall(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, String group, List<String> id, List<String> idType, List<String> item, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String q, Boolean repeat, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version, final ApiCallback _callback) throws ApiException {
        return listSchedulesCall(sort, sortDirection, mixin, authority, descendantsOf, endFrom, endTo, format, genre, group, id, idType, item, page, pageSize, partnerId, partnerPid, people, pid, q, repeat, scheduleDay, scheduleDayFrom, scheduleDayTo, serviceMasterBrand, sid, startFrom, startTo, version, _callback);

    }

    /**
     * Build schedules and find metadata for TV and radio broadcasts and webcasts
     * Dates, Times, Schedules: when and where are programmes being shown?
     * @param sort Sorts: * start_date: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * ancestor_titles: return ancestor programme titles * images: mixin to add image information for broadcasts and webcasts * titles: return ancestor programme titles  (optional)
     * @param authority filter for subset of broadcasts and webcasts that have given authority (optional)
     * @param descendantsOf filter for subset of broadcasts and webcasts that are descendants of the given programme PID (optional)
     * @param endFrom filter for subset of broadcasts and webcasts that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts and webcasts that end on or earlier than the specified datetime (optional)
     * @param format filter for subset of broadcasts and webcasts that are classified in the given format ID (optional)
     * @param genre filter for subset of broadcasts and webcasts that are classified in the given genre ID (optional)
     * @param group filter for subset of broadcasts and webcasts that have programmes in the given group (optional)
     * @param id filter for subset of broadcasts and webcasts that have given identifier (optional)
     * @param idType filter for subset of broadcasts and webcasts that have given id type (optional)
     * @param item filter for subset of broadcasts and webcasts with the given item performed on it (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for broadcasts and webcasts by partner ID (optional)
     * @param partnerPid filter for broadcasts and webcasts by partner PID (optional)
     * @param people filter for subset of broadcasts and webcasts that have given contributor (optional)
     * @param pid filter for subset of broadcasts and webcasts having given PID (optional)
     * @param q filter for subset of broadcasts and webcasts matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param repeat filter to show either only repeats or non-repeats (optional)
     * @param scheduleDay filter for subset of broadcasts and webcasts that start on the specified day (BBC time) (optional)
     * @param scheduleDayFrom filter for subset of broadcasts and webcasts that start on or after the specified day (BBC time) (optional)
     * @param scheduleDayTo filter for subset of broadcasts and webcasts that start on or before the specified day (BBC time) (optional)
     * @param serviceMasterBrand filter for subset of broadcasts and webcasts with given service master brand (optional)
     * @param sid filter for subset of broadcasts and webcasts that are on the specified linear service (optional)
     * @param startFrom filter for subset of broadcasts and webcasts that start on or later than the specified datetime (optional)
     * @param startTo filter for subset of broadcasts and webcasts that start on or earlier than the specified datetime (optional)
     * @param version filter for subset of broadcasts and webcasts with given PID as their parent version (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listSchedules(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, String group, List<String> id, List<String> idType, List<String> item, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String q, Boolean repeat, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version) throws ApiException {
        ApiResponse<Nitro> localVarResp = listSchedulesWithHttpInfo(sort, sortDirection, mixin, authority, descendantsOf, endFrom, endTo, format, genre, group, id, idType, item, page, pageSize, partnerId, partnerPid, people, pid, q, repeat, scheduleDay, scheduleDayFrom, scheduleDayTo, serviceMasterBrand, sid, startFrom, startTo, version);
        return localVarResp.getData();
    }

    /**
     * Build schedules and find metadata for TV and radio broadcasts and webcasts
     * Dates, Times, Schedules: when and where are programmes being shown?
     * @param sort Sorts: * start_date: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * ancestor_titles: return ancestor programme titles * images: mixin to add image information for broadcasts and webcasts * titles: return ancestor programme titles  (optional)
     * @param authority filter for subset of broadcasts and webcasts that have given authority (optional)
     * @param descendantsOf filter for subset of broadcasts and webcasts that are descendants of the given programme PID (optional)
     * @param endFrom filter for subset of broadcasts and webcasts that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts and webcasts that end on or earlier than the specified datetime (optional)
     * @param format filter for subset of broadcasts and webcasts that are classified in the given format ID (optional)
     * @param genre filter for subset of broadcasts and webcasts that are classified in the given genre ID (optional)
     * @param group filter for subset of broadcasts and webcasts that have programmes in the given group (optional)
     * @param id filter for subset of broadcasts and webcasts that have given identifier (optional)
     * @param idType filter for subset of broadcasts and webcasts that have given id type (optional)
     * @param item filter for subset of broadcasts and webcasts with the given item performed on it (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for broadcasts and webcasts by partner ID (optional)
     * @param partnerPid filter for broadcasts and webcasts by partner PID (optional)
     * @param people filter for subset of broadcasts and webcasts that have given contributor (optional)
     * @param pid filter for subset of broadcasts and webcasts having given PID (optional)
     * @param q filter for subset of broadcasts and webcasts matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param repeat filter to show either only repeats or non-repeats (optional)
     * @param scheduleDay filter for subset of broadcasts and webcasts that start on the specified day (BBC time) (optional)
     * @param scheduleDayFrom filter for subset of broadcasts and webcasts that start on or after the specified day (BBC time) (optional)
     * @param scheduleDayTo filter for subset of broadcasts and webcasts that start on or before the specified day (BBC time) (optional)
     * @param serviceMasterBrand filter for subset of broadcasts and webcasts with given service master brand (optional)
     * @param sid filter for subset of broadcasts and webcasts that are on the specified linear service (optional)
     * @param startFrom filter for subset of broadcasts and webcasts that start on or later than the specified datetime (optional)
     * @param startTo filter for subset of broadcasts and webcasts that start on or earlier than the specified datetime (optional)
     * @param version filter for subset of broadcasts and webcasts with given PID as their parent version (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listSchedulesWithHttpInfo(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, String group, List<String> id, List<String> idType, List<String> item, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String q, Boolean repeat, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version) throws ApiException {
        okhttp3.Call localVarCall = listSchedulesValidateBeforeCall(sort, sortDirection, mixin, authority, descendantsOf, endFrom, endTo, format, genre, group, id, idType, item, page, pageSize, partnerId, partnerPid, people, pid, q, repeat, scheduleDay, scheduleDayFrom, scheduleDayTo, serviceMasterBrand, sid, startFrom, startTo, version, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build schedules and find metadata for TV and radio broadcasts and webcasts (asynchronously)
     * Dates, Times, Schedules: when and where are programmes being shown?
     * @param sort Sorts: * start_date: sort chronologically by scheduled start time/date, ascending  (optional)
     * @param sortDirection Sort direction (optional)
     * @param mixin Mixins: * ancestor_titles: return ancestor programme titles * images: mixin to add image information for broadcasts and webcasts * titles: return ancestor programme titles  (optional)
     * @param authority filter for subset of broadcasts and webcasts that have given authority (optional)
     * @param descendantsOf filter for subset of broadcasts and webcasts that are descendants of the given programme PID (optional)
     * @param endFrom filter for subset of broadcasts and webcasts that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts and webcasts that end on or earlier than the specified datetime (optional)
     * @param format filter for subset of broadcasts and webcasts that are classified in the given format ID (optional)
     * @param genre filter for subset of broadcasts and webcasts that are classified in the given genre ID (optional)
     * @param group filter for subset of broadcasts and webcasts that have programmes in the given group (optional)
     * @param id filter for subset of broadcasts and webcasts that have given identifier (optional)
     * @param idType filter for subset of broadcasts and webcasts that have given id type (optional)
     * @param item filter for subset of broadcasts and webcasts with the given item performed on it (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for broadcasts and webcasts by partner ID (optional)
     * @param partnerPid filter for broadcasts and webcasts by partner PID (optional)
     * @param people filter for subset of broadcasts and webcasts that have given contributor (optional)
     * @param pid filter for subset of broadcasts and webcasts having given PID (optional)
     * @param q filter for subset of broadcasts and webcasts matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param repeat filter to show either only repeats or non-repeats (optional)
     * @param scheduleDay filter for subset of broadcasts and webcasts that start on the specified day (BBC time) (optional)
     * @param scheduleDayFrom filter for subset of broadcasts and webcasts that start on or after the specified day (BBC time) (optional)
     * @param scheduleDayTo filter for subset of broadcasts and webcasts that start on or before the specified day (BBC time) (optional)
     * @param serviceMasterBrand filter for subset of broadcasts and webcasts with given service master brand (optional)
     * @param sid filter for subset of broadcasts and webcasts that are on the specified linear service (optional)
     * @param startFrom filter for subset of broadcasts and webcasts that start on or later than the specified datetime (optional)
     * @param startTo filter for subset of broadcasts and webcasts that start on or earlier than the specified datetime (optional)
     * @param version filter for subset of broadcasts and webcasts with given PID as their parent version (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listSchedulesAsync(String sort, String sortDirection, List<String> mixin, List<String> authority, List<String> descendantsOf, OffsetDateTime endFrom, OffsetDateTime endTo, List<String> format, List<String> genre, String group, List<String> id, List<String> idType, List<String> item, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String people, List<String> pid, String q, Boolean repeat, LocalDate scheduleDay, LocalDate scheduleDayFrom, LocalDate scheduleDayTo, List<String> serviceMasterBrand, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, List<String> version, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listSchedulesValidateBeforeCall(sort, sortDirection, mixin, authority, descendantsOf, endFrom, endTo, format, genre, group, id, idType, item, page, pageSize, partnerId, partnerPid, people, pid, q, repeat, scheduleDay, scheduleDayFrom, scheduleDayTo, serviceMasterBrand, sid, startFrom, startTo, version, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listServices
     * @param endFrom Return services that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts that end on or earlier than the specified datetime (optional)
     * @param mid filter for services by masterbrand MID (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for services by partner ID (optional)
     * @param partnerPid filter for services by partner PID (optional)
     * @param q filter for subset of services matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param serviceType filter for specified type of linear services (optional)
     * @param sid filter for specified linear service (optional)
     * @param startFrom Return services that start on or later than the specified datetime (optional)
     * @param startTo Return services that start earlier than the specified datetime (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listServicesCall(OffsetDateTime endFrom, OffsetDateTime endTo, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q, List<String> serviceType, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/services";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (endFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_from", endFrom));
        }

        if (endTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_to", endTo));
        }

        if (mid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mid", mid));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (serviceType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "service_type", serviceType));
        }

        if (sid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "sid", sid));
        }

        if (startFrom != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_from", startFrom));
        }

        if (startTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_to", startTo));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listServicesValidateBeforeCall(OffsetDateTime endFrom, OffsetDateTime endTo, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q, List<String> serviceType, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, final ApiCallback _callback) throws ApiException {
        return listServicesCall(endFrom, endTo, mid, page, pageSize, partnerId, partnerPid, q, serviceType, sid, startFrom, startTo, _callback);

    }

    /**
     * Information about the linear services used for broadcast transmissions
     * The services feed exposes the linear broadcast \&quot;services\&quot; from PIPs. These are the actual services which broadcast programmes (eg bbc_one_oxford is the service for BBC One in Oxford).
     * @param endFrom Return services that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts that end on or earlier than the specified datetime (optional)
     * @param mid filter for services by masterbrand MID (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for services by partner ID (optional)
     * @param partnerPid filter for services by partner PID (optional)
     * @param q filter for subset of services matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param serviceType filter for specified type of linear services (optional)
     * @param sid filter for specified linear service (optional)
     * @param startFrom Return services that start on or later than the specified datetime (optional)
     * @param startTo Return services that start earlier than the specified datetime (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listServices(OffsetDateTime endFrom, OffsetDateTime endTo, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q, List<String> serviceType, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo) throws ApiException {
        ApiResponse<Nitro> localVarResp = listServicesWithHttpInfo(endFrom, endTo, mid, page, pageSize, partnerId, partnerPid, q, serviceType, sid, startFrom, startTo);
        return localVarResp.getData();
    }

    /**
     * Information about the linear services used for broadcast transmissions
     * The services feed exposes the linear broadcast \&quot;services\&quot; from PIPs. These are the actual services which broadcast programmes (eg bbc_one_oxford is the service for BBC One in Oxford).
     * @param endFrom Return services that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts that end on or earlier than the specified datetime (optional)
     * @param mid filter for services by masterbrand MID (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for services by partner ID (optional)
     * @param partnerPid filter for services by partner PID (optional)
     * @param q filter for subset of services matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param serviceType filter for specified type of linear services (optional)
     * @param sid filter for specified linear service (optional)
     * @param startFrom Return services that start on or later than the specified datetime (optional)
     * @param startTo Return services that start earlier than the specified datetime (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listServicesWithHttpInfo(OffsetDateTime endFrom, OffsetDateTime endTo, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q, List<String> serviceType, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo) throws ApiException {
        okhttp3.Call localVarCall = listServicesValidateBeforeCall(endFrom, endTo, mid, page, pageSize, partnerId, partnerPid, q, serviceType, sid, startFrom, startTo, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Information about the linear services used for broadcast transmissions (asynchronously)
     * The services feed exposes the linear broadcast \&quot;services\&quot; from PIPs. These are the actual services which broadcast programmes (eg bbc_one_oxford is the service for BBC One in Oxford).
     * @param endFrom Return services that end on or later than the specified datetime (optional)
     * @param endTo filter for subset of broadcasts that end on or earlier than the specified datetime (optional)
     * @param mid filter for services by masterbrand MID (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for services by partner ID (optional)
     * @param partnerPid filter for services by partner PID (optional)
     * @param q filter for subset of services matching supplied keyword/phrase (boolean operators permitted) (optional)
     * @param serviceType filter for specified type of linear services (optional)
     * @param sid filter for specified linear service (optional)
     * @param startFrom Return services that start on or later than the specified datetime (optional)
     * @param startTo Return services that start earlier than the specified datetime (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listServicesAsync(OffsetDateTime endFrom, OffsetDateTime endTo, List<String> mid, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, String q, List<String> serviceType, List<String> sid, OffsetDateTime startFrom, OffsetDateTime startTo, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listServicesValidateBeforeCall(endFrom, endTo, mid, page, pageSize, partnerId, partnerPid, q, serviceType, sid, startFrom, startTo, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listVersions
     * @param availability filter for subset of versions that have availability (optional)
     * @param descendantsOf filter for subset of versions having given programme PID (optional)
     * @param mediaSet filter for subset of versions with availability in the given media set (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for versions by partner ID (optional)
     * @param partnerPid filter for versions by partner PID (optional)
     * @param paymentType filter for a subset of versions that are of the given payment_type (optional)
     * @param pid filter for subset of versions having given PID (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listVersionsCall(List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, List<String> pid, String embargoed, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/versions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (availability != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "availability", availability));
        }

        if (descendantsOf != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "descendants_of", descendantsOf));
        }

        if (mediaSet != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "media_set", mediaSet));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (partnerId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_id", partnerId));
        }

        if (partnerPid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "partner_pid", partnerPid));
        }

        if (paymentType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "payment_type", paymentType));
        }

        if (pid != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "pid", pid));
        }

        if (embargoed != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("embargoed", embargoed));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listVersionsValidateBeforeCall(List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, List<String> pid, String embargoed, final ApiCallback _callback) throws ApiException {
        return listVersionsCall(availability, descendantsOf, mediaSet, page, pageSize, partnerId, partnerPid, paymentType, pid, embargoed, _callback);

    }

    /**
     * Metadata on editorial programme versions: original, signed, audio-described, etc
     * The versions feed exposes editorial \&quot;Versions\&quot; of programmes. These are concepts used to capture different presentations of an overall programme: for example, versions of a programme may include one with sign language, one with audio description, one edited for content and more. Versions are also important to understand for broadcasts: a linear broadcast or an ondemand is always of a specific version, not merely of a programme.
     * @param availability filter for subset of versions that have availability (optional)
     * @param descendantsOf filter for subset of versions having given programme PID (optional)
     * @param mediaSet filter for subset of versions with availability in the given media set (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for versions by partner ID (optional)
     * @param partnerPid filter for versions by partner PID (optional)
     * @param paymentType filter for a subset of versions that are of the given payment_type (optional)
     * @param pid filter for subset of versions having given PID (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @return Nitro
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public Nitro listVersions(List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, List<String> pid, String embargoed) throws ApiException {
        ApiResponse<Nitro> localVarResp = listVersionsWithHttpInfo(availability, descendantsOf, mediaSet, page, pageSize, partnerId, partnerPid, paymentType, pid, embargoed);
        return localVarResp.getData();
    }

    /**
     * Metadata on editorial programme versions: original, signed, audio-described, etc
     * The versions feed exposes editorial \&quot;Versions\&quot; of programmes. These are concepts used to capture different presentations of an overall programme: for example, versions of a programme may include one with sign language, one with audio description, one edited for content and more. Versions are also important to understand for broadcasts: a linear broadcast or an ondemand is always of a specific version, not merely of a programme.
     * @param availability filter for subset of versions that have availability (optional)
     * @param descendantsOf filter for subset of versions having given programme PID (optional)
     * @param mediaSet filter for subset of versions with availability in the given media set (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for versions by partner ID (optional)
     * @param partnerPid filter for versions by partner PID (optional)
     * @param paymentType filter for a subset of versions that are of the given payment_type (optional)
     * @param pid filter for subset of versions having given PID (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @return ApiResponse&lt;Nitro&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Nitro> listVersionsWithHttpInfo(List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, List<String> pid, String embargoed) throws ApiException {
        okhttp3.Call localVarCall = listVersionsValidateBeforeCall(availability, descendantsOf, mediaSet, page, pageSize, partnerId, partnerPid, paymentType, pid, embargoed, null);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Metadata on editorial programme versions: original, signed, audio-described, etc (asynchronously)
     * The versions feed exposes editorial \&quot;Versions\&quot; of programmes. These are concepts used to capture different presentations of an overall programme: for example, versions of a programme may include one with sign language, one with audio description, one edited for content and more. Versions are also important to understand for broadcasts: a linear broadcast or an ondemand is always of a specific version, not merely of a programme.
     * @param availability filter for subset of versions that have availability (optional)
     * @param descendantsOf filter for subset of versions having given programme PID (optional)
     * @param mediaSet filter for subset of versions with availability in the given media set (optional)
     * @param page which page of results to return (optional, default to 1)
     * @param pageSize number of results in each page (optional, default to 10)
     * @param partnerId filter for versions by partner ID (optional)
     * @param partnerPid filter for versions by partner PID (optional)
     * @param paymentType filter for a subset of versions that are of the given payment_type (optional)
     * @param pid filter for subset of versions having given PID (optional)
     * @param embargoed Control return of embargoed items (undocumented) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Nitro response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Unexpected error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listVersionsAsync(List<String> availability, List<String> descendantsOf, List<String> mediaSet, Integer page, Integer pageSize, List<String> partnerId, List<String> partnerPid, List<String> paymentType, List<String> pid, String embargoed, final ApiCallback<Nitro> _callback) throws ApiException {

        okhttp3.Call localVarCall = listVersionsValidateBeforeCall(availability, descendantsOf, mediaSet, page, pageSize, partnerId, partnerPid, paymentType, pid, embargoed, _callback);
        Type localVarReturnType = new TypeToken<Nitro>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
