/**
 * PatientView
 * The recommended REST API endpoints to be used when integrating with PatientView
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIUserToken.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIUserToken::OAIUserToken(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIUserToken::OAIUserToken() {
    this->initializeModel();
}

OAIUserToken::~OAIUserToken() {}

void OAIUserToken::initializeModel() {

    m_audit_actions_isSet = false;
    m_audit_actions_isValid = false;

    m_check_secret_word_isSet = false;
    m_check_secret_word_isValid = false;

    m_created_isSet = false;
    m_created_isValid = false;

    m_expiration_isSet = false;
    m_expiration_isValid = false;

    m_external_standards_isSet = false;
    m_external_standards_isValid = false;

    m_group_features_isSet = false;
    m_group_features_isValid = false;

    m_group_messaging_enabled_isSet = false;
    m_group_messaging_enabled_isValid = false;

    m_must_set_secret_word_isSet = false;
    m_must_set_secret_word_isValid = false;

    m_patient_features_isSet = false;
    m_patient_features_isValid = false;

    m_patient_messaging_feature_types_isSet = false;
    m_patient_messaging_feature_types_isValid = false;

    m_patient_roles_isSet = false;
    m_patient_roles_isValid = false;

    m_routes_isSet = false;
    m_routes_isValid = false;

    m_secret_word_isSet = false;
    m_secret_word_isValid = false;

    m_secret_word_choices_isSet = false;
    m_secret_word_choices_isValid = false;

    m_secret_word_indexes_isSet = false;
    m_secret_word_indexes_isValid = false;

    m_secret_word_salt_isSet = false;
    m_secret_word_salt_isValid = false;

    m_secret_word_token_isSet = false;
    m_secret_word_token_isValid = false;

    m_security_roles_isSet = false;
    m_security_roles_isValid = false;

    m_should_enter_condition_isSet = false;
    m_should_enter_condition_isValid = false;

    m_staff_features_isSet = false;
    m_staff_features_isValid = false;

    m_staff_roles_isSet = false;
    m_staff_roles_isValid = false;

    m_token_isSet = false;
    m_token_isValid = false;

    m_user_isSet = false;
    m_user_isValid = false;

    m_user_features_isSet = false;
    m_user_features_isValid = false;

    m_user_groups_isSet = false;
    m_user_groups_isValid = false;
}

void OAIUserToken::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIUserToken::fromJsonObject(QJsonObject json) {

    m_audit_actions_isValid = ::OpenAPI::fromJsonValue(m_audit_actions, json[QString("auditActions")]);
    m_audit_actions_isSet = !json[QString("auditActions")].isNull() && m_audit_actions_isValid;

    m_check_secret_word_isValid = ::OpenAPI::fromJsonValue(m_check_secret_word, json[QString("checkSecretWord")]);
    m_check_secret_word_isSet = !json[QString("checkSecretWord")].isNull() && m_check_secret_word_isValid;

    m_created_isValid = ::OpenAPI::fromJsonValue(m_created, json[QString("created")]);
    m_created_isSet = !json[QString("created")].isNull() && m_created_isValid;

    m_expiration_isValid = ::OpenAPI::fromJsonValue(m_expiration, json[QString("expiration")]);
    m_expiration_isSet = !json[QString("expiration")].isNull() && m_expiration_isValid;

    m_external_standards_isValid = ::OpenAPI::fromJsonValue(m_external_standards, json[QString("externalStandards")]);
    m_external_standards_isSet = !json[QString("externalStandards")].isNull() && m_external_standards_isValid;

    m_group_features_isValid = ::OpenAPI::fromJsonValue(m_group_features, json[QString("groupFeatures")]);
    m_group_features_isSet = !json[QString("groupFeatures")].isNull() && m_group_features_isValid;

    m_group_messaging_enabled_isValid = ::OpenAPI::fromJsonValue(m_group_messaging_enabled, json[QString("groupMessagingEnabled")]);
    m_group_messaging_enabled_isSet = !json[QString("groupMessagingEnabled")].isNull() && m_group_messaging_enabled_isValid;

    m_must_set_secret_word_isValid = ::OpenAPI::fromJsonValue(m_must_set_secret_word, json[QString("mustSetSecretWord")]);
    m_must_set_secret_word_isSet = !json[QString("mustSetSecretWord")].isNull() && m_must_set_secret_word_isValid;

    m_patient_features_isValid = ::OpenAPI::fromJsonValue(m_patient_features, json[QString("patientFeatures")]);
    m_patient_features_isSet = !json[QString("patientFeatures")].isNull() && m_patient_features_isValid;

    m_patient_messaging_feature_types_isValid = ::OpenAPI::fromJsonValue(m_patient_messaging_feature_types, json[QString("patientMessagingFeatureTypes")]);
    m_patient_messaging_feature_types_isSet = !json[QString("patientMessagingFeatureTypes")].isNull() && m_patient_messaging_feature_types_isValid;

    m_patient_roles_isValid = ::OpenAPI::fromJsonValue(m_patient_roles, json[QString("patientRoles")]);
    m_patient_roles_isSet = !json[QString("patientRoles")].isNull() && m_patient_roles_isValid;

    m_routes_isValid = ::OpenAPI::fromJsonValue(m_routes, json[QString("routes")]);
    m_routes_isSet = !json[QString("routes")].isNull() && m_routes_isValid;

    m_secret_word_isValid = ::OpenAPI::fromJsonValue(m_secret_word, json[QString("secretWord")]);
    m_secret_word_isSet = !json[QString("secretWord")].isNull() && m_secret_word_isValid;

    m_secret_word_choices_isValid = ::OpenAPI::fromJsonValue(m_secret_word_choices, json[QString("secretWordChoices")]);
    m_secret_word_choices_isSet = !json[QString("secretWordChoices")].isNull() && m_secret_word_choices_isValid;

    m_secret_word_indexes_isValid = ::OpenAPI::fromJsonValue(m_secret_word_indexes, json[QString("secretWordIndexes")]);
    m_secret_word_indexes_isSet = !json[QString("secretWordIndexes")].isNull() && m_secret_word_indexes_isValid;

    m_secret_word_salt_isValid = ::OpenAPI::fromJsonValue(m_secret_word_salt, json[QString("secretWordSalt")]);
    m_secret_word_salt_isSet = !json[QString("secretWordSalt")].isNull() && m_secret_word_salt_isValid;

    m_secret_word_token_isValid = ::OpenAPI::fromJsonValue(m_secret_word_token, json[QString("secretWordToken")]);
    m_secret_word_token_isSet = !json[QString("secretWordToken")].isNull() && m_secret_word_token_isValid;

    m_security_roles_isValid = ::OpenAPI::fromJsonValue(m_security_roles, json[QString("securityRoles")]);
    m_security_roles_isSet = !json[QString("securityRoles")].isNull() && m_security_roles_isValid;

    m_should_enter_condition_isValid = ::OpenAPI::fromJsonValue(m_should_enter_condition, json[QString("shouldEnterCondition")]);
    m_should_enter_condition_isSet = !json[QString("shouldEnterCondition")].isNull() && m_should_enter_condition_isValid;

    m_staff_features_isValid = ::OpenAPI::fromJsonValue(m_staff_features, json[QString("staffFeatures")]);
    m_staff_features_isSet = !json[QString("staffFeatures")].isNull() && m_staff_features_isValid;

    m_staff_roles_isValid = ::OpenAPI::fromJsonValue(m_staff_roles, json[QString("staffRoles")]);
    m_staff_roles_isSet = !json[QString("staffRoles")].isNull() && m_staff_roles_isValid;

    m_token_isValid = ::OpenAPI::fromJsonValue(m_token, json[QString("token")]);
    m_token_isSet = !json[QString("token")].isNull() && m_token_isValid;

    m_user_isValid = ::OpenAPI::fromJsonValue(m_user, json[QString("user")]);
    m_user_isSet = !json[QString("user")].isNull() && m_user_isValid;

    m_user_features_isValid = ::OpenAPI::fromJsonValue(m_user_features, json[QString("userFeatures")]);
    m_user_features_isSet = !json[QString("userFeatures")].isNull() && m_user_features_isValid;

    m_user_groups_isValid = ::OpenAPI::fromJsonValue(m_user_groups, json[QString("userGroups")]);
    m_user_groups_isSet = !json[QString("userGroups")].isNull() && m_user_groups_isValid;
}

QString OAIUserToken::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIUserToken::asJsonObject() const {
    QJsonObject obj;
    if (m_audit_actions.size() > 0) {
        obj.insert(QString("auditActions"), ::OpenAPI::toJsonValue(m_audit_actions));
    }
    if (m_check_secret_word_isSet) {
        obj.insert(QString("checkSecretWord"), ::OpenAPI::toJsonValue(m_check_secret_word));
    }
    if (m_created_isSet) {
        obj.insert(QString("created"), ::OpenAPI::toJsonValue(m_created));
    }
    if (m_expiration_isSet) {
        obj.insert(QString("expiration"), ::OpenAPI::toJsonValue(m_expiration));
    }
    if (m_external_standards.size() > 0) {
        obj.insert(QString("externalStandards"), ::OpenAPI::toJsonValue(m_external_standards));
    }
    if (m_group_features.size() > 0) {
        obj.insert(QString("groupFeatures"), ::OpenAPI::toJsonValue(m_group_features));
    }
    if (m_group_messaging_enabled_isSet) {
        obj.insert(QString("groupMessagingEnabled"), ::OpenAPI::toJsonValue(m_group_messaging_enabled));
    }
    if (m_must_set_secret_word_isSet) {
        obj.insert(QString("mustSetSecretWord"), ::OpenAPI::toJsonValue(m_must_set_secret_word));
    }
    if (m_patient_features.size() > 0) {
        obj.insert(QString("patientFeatures"), ::OpenAPI::toJsonValue(m_patient_features));
    }
    if (m_patient_messaging_feature_types.size() > 0) {
        obj.insert(QString("patientMessagingFeatureTypes"), ::OpenAPI::toJsonValue(m_patient_messaging_feature_types));
    }
    if (m_patient_roles.size() > 0) {
        obj.insert(QString("patientRoles"), ::OpenAPI::toJsonValue(m_patient_roles));
    }
    if (m_routes.size() > 0) {
        obj.insert(QString("routes"), ::OpenAPI::toJsonValue(m_routes));
    }
    if (m_secret_word_isSet) {
        obj.insert(QString("secretWord"), ::OpenAPI::toJsonValue(m_secret_word));
    }
    if (m_secret_word_choices_isSet) {
        obj.insert(QString("secretWordChoices"), ::OpenAPI::toJsonValue(m_secret_word_choices));
    }
    if (m_secret_word_indexes.size() > 0) {
        obj.insert(QString("secretWordIndexes"), ::OpenAPI::toJsonValue(m_secret_word_indexes));
    }
    if (m_secret_word_salt_isSet) {
        obj.insert(QString("secretWordSalt"), ::OpenAPI::toJsonValue(m_secret_word_salt));
    }
    if (m_secret_word_token_isSet) {
        obj.insert(QString("secretWordToken"), ::OpenAPI::toJsonValue(m_secret_word_token));
    }
    if (m_security_roles.size() > 0) {
        obj.insert(QString("securityRoles"), ::OpenAPI::toJsonValue(m_security_roles));
    }
    if (m_should_enter_condition_isSet) {
        obj.insert(QString("shouldEnterCondition"), ::OpenAPI::toJsonValue(m_should_enter_condition));
    }
    if (m_staff_features.size() > 0) {
        obj.insert(QString("staffFeatures"), ::OpenAPI::toJsonValue(m_staff_features));
    }
    if (m_staff_roles.size() > 0) {
        obj.insert(QString("staffRoles"), ::OpenAPI::toJsonValue(m_staff_roles));
    }
    if (m_token_isSet) {
        obj.insert(QString("token"), ::OpenAPI::toJsonValue(m_token));
    }
    if (m_user.isSet()) {
        obj.insert(QString("user"), ::OpenAPI::toJsonValue(m_user));
    }
    if (m_user_features.size() > 0) {
        obj.insert(QString("userFeatures"), ::OpenAPI::toJsonValue(m_user_features));
    }
    if (m_user_groups.size() > 0) {
        obj.insert(QString("userGroups"), ::OpenAPI::toJsonValue(m_user_groups));
    }
    return obj;
}

QList<QString> OAIUserToken::getAuditActions() const {
    return m_audit_actions;
}
void OAIUserToken::setAuditActions(const QList<QString> &audit_actions) {
    m_audit_actions = audit_actions;
    m_audit_actions_isSet = true;
}

bool OAIUserToken::is_audit_actions_Set() const{
    return m_audit_actions_isSet;
}

bool OAIUserToken::is_audit_actions_Valid() const{
    return m_audit_actions_isValid;
}

bool OAIUserToken::isCheckSecretWord() const {
    return m_check_secret_word;
}
void OAIUserToken::setCheckSecretWord(const bool &check_secret_word) {
    m_check_secret_word = check_secret_word;
    m_check_secret_word_isSet = true;
}

bool OAIUserToken::is_check_secret_word_Set() const{
    return m_check_secret_word_isSet;
}

bool OAIUserToken::is_check_secret_word_Valid() const{
    return m_check_secret_word_isValid;
}

QDateTime OAIUserToken::getCreated() const {
    return m_created;
}
void OAIUserToken::setCreated(const QDateTime &created) {
    m_created = created;
    m_created_isSet = true;
}

bool OAIUserToken::is_created_Set() const{
    return m_created_isSet;
}

bool OAIUserToken::is_created_Valid() const{
    return m_created_isValid;
}

QDateTime OAIUserToken::getExpiration() const {
    return m_expiration;
}
void OAIUserToken::setExpiration(const QDateTime &expiration) {
    m_expiration = expiration;
    m_expiration_isSet = true;
}

bool OAIUserToken::is_expiration_Set() const{
    return m_expiration_isSet;
}

bool OAIUserToken::is_expiration_Valid() const{
    return m_expiration_isValid;
}

QList<OAIExternalStandard> OAIUserToken::getExternalStandards() const {
    return m_external_standards;
}
void OAIUserToken::setExternalStandards(const QList<OAIExternalStandard> &external_standards) {
    m_external_standards = external_standards;
    m_external_standards_isSet = true;
}

bool OAIUserToken::is_external_standards_Set() const{
    return m_external_standards_isSet;
}

bool OAIUserToken::is_external_standards_Valid() const{
    return m_external_standards_isValid;
}

QList<OAIFeature> OAIUserToken::getGroupFeatures() const {
    return m_group_features;
}
void OAIUserToken::setGroupFeatures(const QList<OAIFeature> &group_features) {
    m_group_features = group_features;
    m_group_features_isSet = true;
}

bool OAIUserToken::is_group_features_Set() const{
    return m_group_features_isSet;
}

bool OAIUserToken::is_group_features_Valid() const{
    return m_group_features_isValid;
}

bool OAIUserToken::isGroupMessagingEnabled() const {
    return m_group_messaging_enabled;
}
void OAIUserToken::setGroupMessagingEnabled(const bool &group_messaging_enabled) {
    m_group_messaging_enabled = group_messaging_enabled;
    m_group_messaging_enabled_isSet = true;
}

bool OAIUserToken::is_group_messaging_enabled_Set() const{
    return m_group_messaging_enabled_isSet;
}

bool OAIUserToken::is_group_messaging_enabled_Valid() const{
    return m_group_messaging_enabled_isValid;
}

bool OAIUserToken::isMustSetSecretWord() const {
    return m_must_set_secret_word;
}
void OAIUserToken::setMustSetSecretWord(const bool &must_set_secret_word) {
    m_must_set_secret_word = must_set_secret_word;
    m_must_set_secret_word_isSet = true;
}

bool OAIUserToken::is_must_set_secret_word_Set() const{
    return m_must_set_secret_word_isSet;
}

bool OAIUserToken::is_must_set_secret_word_Valid() const{
    return m_must_set_secret_word_isValid;
}

QList<OAIFeature> OAIUserToken::getPatientFeatures() const {
    return m_patient_features;
}
void OAIUserToken::setPatientFeatures(const QList<OAIFeature> &patient_features) {
    m_patient_features = patient_features;
    m_patient_features_isSet = true;
}

bool OAIUserToken::is_patient_features_Set() const{
    return m_patient_features_isSet;
}

bool OAIUserToken::is_patient_features_Valid() const{
    return m_patient_features_isValid;
}

QList<QString> OAIUserToken::getPatientMessagingFeatureTypes() const {
    return m_patient_messaging_feature_types;
}
void OAIUserToken::setPatientMessagingFeatureTypes(const QList<QString> &patient_messaging_feature_types) {
    m_patient_messaging_feature_types = patient_messaging_feature_types;
    m_patient_messaging_feature_types_isSet = true;
}

bool OAIUserToken::is_patient_messaging_feature_types_Set() const{
    return m_patient_messaging_feature_types_isSet;
}

bool OAIUserToken::is_patient_messaging_feature_types_Valid() const{
    return m_patient_messaging_feature_types_isValid;
}

QList<OAIRole> OAIUserToken::getPatientRoles() const {
    return m_patient_roles;
}
void OAIUserToken::setPatientRoles(const QList<OAIRole> &patient_roles) {
    m_patient_roles = patient_roles;
    m_patient_roles_isSet = true;
}

bool OAIUserToken::is_patient_roles_Set() const{
    return m_patient_roles_isSet;
}

bool OAIUserToken::is_patient_roles_Valid() const{
    return m_patient_roles_isValid;
}

QSet<OAIRoute> OAIUserToken::getRoutes() const {
    return m_routes;
}
void OAIUserToken::setRoutes(const QSet<OAIRoute> &routes) {
    m_routes = routes;
    m_routes_isSet = true;
}

bool OAIUserToken::is_routes_Set() const{
    return m_routes_isSet;
}

bool OAIUserToken::is_routes_Valid() const{
    return m_routes_isValid;
}

QString OAIUserToken::getSecretWord() const {
    return m_secret_word;
}
void OAIUserToken::setSecretWord(const QString &secret_word) {
    m_secret_word = secret_word;
    m_secret_word_isSet = true;
}

bool OAIUserToken::is_secret_word_Set() const{
    return m_secret_word_isSet;
}

bool OAIUserToken::is_secret_word_Valid() const{
    return m_secret_word_isValid;
}

OAIObject OAIUserToken::getSecretWordChoices() const {
    return m_secret_word_choices;
}
void OAIUserToken::setSecretWordChoices(const OAIObject &secret_word_choices) {
    m_secret_word_choices = secret_word_choices;
    m_secret_word_choices_isSet = true;
}

bool OAIUserToken::is_secret_word_choices_Set() const{
    return m_secret_word_choices_isSet;
}

bool OAIUserToken::is_secret_word_choices_Valid() const{
    return m_secret_word_choices_isValid;
}

QList<QString> OAIUserToken::getSecretWordIndexes() const {
    return m_secret_word_indexes;
}
void OAIUserToken::setSecretWordIndexes(const QList<QString> &secret_word_indexes) {
    m_secret_word_indexes = secret_word_indexes;
    m_secret_word_indexes_isSet = true;
}

bool OAIUserToken::is_secret_word_indexes_Set() const{
    return m_secret_word_indexes_isSet;
}

bool OAIUserToken::is_secret_word_indexes_Valid() const{
    return m_secret_word_indexes_isValid;
}

QString OAIUserToken::getSecretWordSalt() const {
    return m_secret_word_salt;
}
void OAIUserToken::setSecretWordSalt(const QString &secret_word_salt) {
    m_secret_word_salt = secret_word_salt;
    m_secret_word_salt_isSet = true;
}

bool OAIUserToken::is_secret_word_salt_Set() const{
    return m_secret_word_salt_isSet;
}

bool OAIUserToken::is_secret_word_salt_Valid() const{
    return m_secret_word_salt_isValid;
}

QString OAIUserToken::getSecretWordToken() const {
    return m_secret_word_token;
}
void OAIUserToken::setSecretWordToken(const QString &secret_word_token) {
    m_secret_word_token = secret_word_token;
    m_secret_word_token_isSet = true;
}

bool OAIUserToken::is_secret_word_token_Set() const{
    return m_secret_word_token_isSet;
}

bool OAIUserToken::is_secret_word_token_Valid() const{
    return m_secret_word_token_isValid;
}

QList<OAIRole> OAIUserToken::getSecurityRoles() const {
    return m_security_roles;
}
void OAIUserToken::setSecurityRoles(const QList<OAIRole> &security_roles) {
    m_security_roles = security_roles;
    m_security_roles_isSet = true;
}

bool OAIUserToken::is_security_roles_Set() const{
    return m_security_roles_isSet;
}

bool OAIUserToken::is_security_roles_Valid() const{
    return m_security_roles_isValid;
}

bool OAIUserToken::isShouldEnterCondition() const {
    return m_should_enter_condition;
}
void OAIUserToken::setShouldEnterCondition(const bool &should_enter_condition) {
    m_should_enter_condition = should_enter_condition;
    m_should_enter_condition_isSet = true;
}

bool OAIUserToken::is_should_enter_condition_Set() const{
    return m_should_enter_condition_isSet;
}

bool OAIUserToken::is_should_enter_condition_Valid() const{
    return m_should_enter_condition_isValid;
}

QList<OAIFeature> OAIUserToken::getStaffFeatures() const {
    return m_staff_features;
}
void OAIUserToken::setStaffFeatures(const QList<OAIFeature> &staff_features) {
    m_staff_features = staff_features;
    m_staff_features_isSet = true;
}

bool OAIUserToken::is_staff_features_Set() const{
    return m_staff_features_isSet;
}

bool OAIUserToken::is_staff_features_Valid() const{
    return m_staff_features_isValid;
}

QList<OAIRole> OAIUserToken::getStaffRoles() const {
    return m_staff_roles;
}
void OAIUserToken::setStaffRoles(const QList<OAIRole> &staff_roles) {
    m_staff_roles = staff_roles;
    m_staff_roles_isSet = true;
}

bool OAIUserToken::is_staff_roles_Set() const{
    return m_staff_roles_isSet;
}

bool OAIUserToken::is_staff_roles_Valid() const{
    return m_staff_roles_isValid;
}

QString OAIUserToken::getToken() const {
    return m_token;
}
void OAIUserToken::setToken(const QString &token) {
    m_token = token;
    m_token_isSet = true;
}

bool OAIUserToken::is_token_Set() const{
    return m_token_isSet;
}

bool OAIUserToken::is_token_Valid() const{
    return m_token_isValid;
}

OAIUser OAIUserToken::getUser() const {
    return m_user;
}
void OAIUserToken::setUser(const OAIUser &user) {
    m_user = user;
    m_user_isSet = true;
}

bool OAIUserToken::is_user_Set() const{
    return m_user_isSet;
}

bool OAIUserToken::is_user_Valid() const{
    return m_user_isValid;
}

QList<OAIFeature> OAIUserToken::getUserFeatures() const {
    return m_user_features;
}
void OAIUserToken::setUserFeatures(const QList<OAIFeature> &user_features) {
    m_user_features = user_features;
    m_user_features_isSet = true;
}

bool OAIUserToken::is_user_features_Set() const{
    return m_user_features_isSet;
}

bool OAIUserToken::is_user_features_Valid() const{
    return m_user_features_isValid;
}

QList<OAIBaseGroup> OAIUserToken::getUserGroups() const {
    return m_user_groups;
}
void OAIUserToken::setUserGroups(const QList<OAIBaseGroup> &user_groups) {
    m_user_groups = user_groups;
    m_user_groups_isSet = true;
}

bool OAIUserToken::is_user_groups_Set() const{
    return m_user_groups_isSet;
}

bool OAIUserToken::is_user_groups_Valid() const{
    return m_user_groups_isValid;
}

bool OAIUserToken::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_audit_actions.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_check_secret_word_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_created_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_expiration_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_external_standards.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_group_features.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_group_messaging_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_must_set_secret_word_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_patient_features.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_patient_messaging_feature_types.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_patient_roles.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_routes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_secret_word_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_secret_word_choices_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_secret_word_indexes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_secret_word_salt_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_secret_word_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_security_roles.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_should_enter_condition_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_staff_features.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_staff_roles.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_token_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_user.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_features.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_groups.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIUserToken::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
