/*
 * PowerTools Developer
 * Apptigent PowerTools Developer Edition is a powerful suite of API endpoints for custom applications running on any stack. Manipulate text, modify collections, format dates and times, convert currency, perform advanced mathematical calculations, shorten URL's, encode strings, convert text to speech, translate content into multiple languages, process images, and more. PowerTools is the ultimate developer toolkit.
 *
 * The version of the OpenAPI document: 2021.1.01
 * Contact: support@apptigent.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * OutputDateDifference
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:04:11.265696-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class OutputDateDifference {
  public static final String SERIALIZED_NAME_DAYS = "days";
  @SerializedName(SERIALIZED_NAME_DAYS)
  private BigDecimal days;

  public static final String SERIALIZED_NAME_HOURS = "hours";
  @SerializedName(SERIALIZED_NAME_HOURS)
  private BigDecimal hours;

  public static final String SERIALIZED_NAME_MILLISECONDS = "milliseconds";
  @SerializedName(SERIALIZED_NAME_MILLISECONDS)
  private BigDecimal milliseconds;

  public static final String SERIALIZED_NAME_MINUTES = "minutes";
  @SerializedName(SERIALIZED_NAME_MINUTES)
  private BigDecimal minutes;

  public static final String SERIALIZED_NAME_MONTHS = "months";
  @SerializedName(SERIALIZED_NAME_MONTHS)
  private BigDecimal months;

  public static final String SERIALIZED_NAME_TICKS = "ticks";
  @SerializedName(SERIALIZED_NAME_TICKS)
  private BigDecimal ticks;

  public static final String SERIALIZED_NAME_TOTAL_DAYS = "totalDays";
  @SerializedName(SERIALIZED_NAME_TOTAL_DAYS)
  private Double totalDays;

  public static final String SERIALIZED_NAME_TOTAL_HOURS = "totalHours";
  @SerializedName(SERIALIZED_NAME_TOTAL_HOURS)
  private Double totalHours;

  public static final String SERIALIZED_NAME_TOTAL_MILLISECONDS = "totalMilliseconds";
  @SerializedName(SERIALIZED_NAME_TOTAL_MILLISECONDS)
  private Double totalMilliseconds;

  public static final String SERIALIZED_NAME_TOTAL_MINUTES = "totalMinutes";
  @SerializedName(SERIALIZED_NAME_TOTAL_MINUTES)
  private Double totalMinutes;

  public static final String SERIALIZED_NAME_TOTAL_MONTHS = "totalMonths";
  @SerializedName(SERIALIZED_NAME_TOTAL_MONTHS)
  private Double totalMonths;

  public static final String SERIALIZED_NAME_TOTAL_SECONDS = "totalSeconds";
  @SerializedName(SERIALIZED_NAME_TOTAL_SECONDS)
  private Double totalSeconds;

  public static final String SERIALIZED_NAME_TOTAL_YEARS = "totalYears";
  @SerializedName(SERIALIZED_NAME_TOTAL_YEARS)
  private Double totalYears;

  public static final String SERIALIZED_NAME_YEARS = "years";
  @SerializedName(SERIALIZED_NAME_YEARS)
  private BigDecimal years;

  public OutputDateDifference() {
  }

  public OutputDateDifference days(BigDecimal days) {
    this.days = days;
    return this;
  }

  /**
   * Days
   * @return days
   */
  @javax.annotation.Nullable
  public BigDecimal getDays() {
    return days;
  }

  public void setDays(BigDecimal days) {
    this.days = days;
  }


  public OutputDateDifference hours(BigDecimal hours) {
    this.hours = hours;
    return this;
  }

  /**
   * Hours
   * @return hours
   */
  @javax.annotation.Nullable
  public BigDecimal getHours() {
    return hours;
  }

  public void setHours(BigDecimal hours) {
    this.hours = hours;
  }


  public OutputDateDifference milliseconds(BigDecimal milliseconds) {
    this.milliseconds = milliseconds;
    return this;
  }

  /**
   * Milliseconds
   * @return milliseconds
   */
  @javax.annotation.Nullable
  public BigDecimal getMilliseconds() {
    return milliseconds;
  }

  public void setMilliseconds(BigDecimal milliseconds) {
    this.milliseconds = milliseconds;
  }


  public OutputDateDifference minutes(BigDecimal minutes) {
    this.minutes = minutes;
    return this;
  }

  /**
   * Minutes
   * @return minutes
   */
  @javax.annotation.Nullable
  public BigDecimal getMinutes() {
    return minutes;
  }

  public void setMinutes(BigDecimal minutes) {
    this.minutes = minutes;
  }


  public OutputDateDifference months(BigDecimal months) {
    this.months = months;
    return this;
  }

  /**
   * Months
   * @return months
   */
  @javax.annotation.Nullable
  public BigDecimal getMonths() {
    return months;
  }

  public void setMonths(BigDecimal months) {
    this.months = months;
  }


  public OutputDateDifference ticks(BigDecimal ticks) {
    this.ticks = ticks;
    return this;
  }

  /**
   * Ticks
   * @return ticks
   */
  @javax.annotation.Nullable
  public BigDecimal getTicks() {
    return ticks;
  }

  public void setTicks(BigDecimal ticks) {
    this.ticks = ticks;
  }


  public OutputDateDifference totalDays(Double totalDays) {
    this.totalDays = totalDays;
    return this;
  }

  /**
   * Total Days
   * @return totalDays
   */
  @javax.annotation.Nullable
  public Double getTotalDays() {
    return totalDays;
  }

  public void setTotalDays(Double totalDays) {
    this.totalDays = totalDays;
  }


  public OutputDateDifference totalHours(Double totalHours) {
    this.totalHours = totalHours;
    return this;
  }

  /**
   * Total Hours
   * @return totalHours
   */
  @javax.annotation.Nullable
  public Double getTotalHours() {
    return totalHours;
  }

  public void setTotalHours(Double totalHours) {
    this.totalHours = totalHours;
  }


  public OutputDateDifference totalMilliseconds(Double totalMilliseconds) {
    this.totalMilliseconds = totalMilliseconds;
    return this;
  }

  /**
   * Total Milliseconds
   * @return totalMilliseconds
   */
  @javax.annotation.Nullable
  public Double getTotalMilliseconds() {
    return totalMilliseconds;
  }

  public void setTotalMilliseconds(Double totalMilliseconds) {
    this.totalMilliseconds = totalMilliseconds;
  }


  public OutputDateDifference totalMinutes(Double totalMinutes) {
    this.totalMinutes = totalMinutes;
    return this;
  }

  /**
   * Total Minutes
   * @return totalMinutes
   */
  @javax.annotation.Nullable
  public Double getTotalMinutes() {
    return totalMinutes;
  }

  public void setTotalMinutes(Double totalMinutes) {
    this.totalMinutes = totalMinutes;
  }


  public OutputDateDifference totalMonths(Double totalMonths) {
    this.totalMonths = totalMonths;
    return this;
  }

  /**
   * Total Months
   * @return totalMonths
   */
  @javax.annotation.Nullable
  public Double getTotalMonths() {
    return totalMonths;
  }

  public void setTotalMonths(Double totalMonths) {
    this.totalMonths = totalMonths;
  }


  public OutputDateDifference totalSeconds(Double totalSeconds) {
    this.totalSeconds = totalSeconds;
    return this;
  }

  /**
   * Total Seconds
   * @return totalSeconds
   */
  @javax.annotation.Nullable
  public Double getTotalSeconds() {
    return totalSeconds;
  }

  public void setTotalSeconds(Double totalSeconds) {
    this.totalSeconds = totalSeconds;
  }


  public OutputDateDifference totalYears(Double totalYears) {
    this.totalYears = totalYears;
    return this;
  }

  /**
   * Total Years
   * @return totalYears
   */
  @javax.annotation.Nullable
  public Double getTotalYears() {
    return totalYears;
  }

  public void setTotalYears(Double totalYears) {
    this.totalYears = totalYears;
  }


  public OutputDateDifference years(BigDecimal years) {
    this.years = years;
    return this;
  }

  /**
   * Years
   * @return years
   */
  @javax.annotation.Nullable
  public BigDecimal getYears() {
    return years;
  }

  public void setYears(BigDecimal years) {
    this.years = years;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OutputDateDifference outputDateDifference = (OutputDateDifference) o;
    return Objects.equals(this.days, outputDateDifference.days) &&
        Objects.equals(this.hours, outputDateDifference.hours) &&
        Objects.equals(this.milliseconds, outputDateDifference.milliseconds) &&
        Objects.equals(this.minutes, outputDateDifference.minutes) &&
        Objects.equals(this.months, outputDateDifference.months) &&
        Objects.equals(this.ticks, outputDateDifference.ticks) &&
        Objects.equals(this.totalDays, outputDateDifference.totalDays) &&
        Objects.equals(this.totalHours, outputDateDifference.totalHours) &&
        Objects.equals(this.totalMilliseconds, outputDateDifference.totalMilliseconds) &&
        Objects.equals(this.totalMinutes, outputDateDifference.totalMinutes) &&
        Objects.equals(this.totalMonths, outputDateDifference.totalMonths) &&
        Objects.equals(this.totalSeconds, outputDateDifference.totalSeconds) &&
        Objects.equals(this.totalYears, outputDateDifference.totalYears) &&
        Objects.equals(this.years, outputDateDifference.years);
  }

  @Override
  public int hashCode() {
    return Objects.hash(days, hours, milliseconds, minutes, months, ticks, totalDays, totalHours, totalMilliseconds, totalMinutes, totalMonths, totalSeconds, totalYears, years);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OutputDateDifference {\n");
    sb.append("    days: ").append(toIndentedString(days)).append("\n");
    sb.append("    hours: ").append(toIndentedString(hours)).append("\n");
    sb.append("    milliseconds: ").append(toIndentedString(milliseconds)).append("\n");
    sb.append("    minutes: ").append(toIndentedString(minutes)).append("\n");
    sb.append("    months: ").append(toIndentedString(months)).append("\n");
    sb.append("    ticks: ").append(toIndentedString(ticks)).append("\n");
    sb.append("    totalDays: ").append(toIndentedString(totalDays)).append("\n");
    sb.append("    totalHours: ").append(toIndentedString(totalHours)).append("\n");
    sb.append("    totalMilliseconds: ").append(toIndentedString(totalMilliseconds)).append("\n");
    sb.append("    totalMinutes: ").append(toIndentedString(totalMinutes)).append("\n");
    sb.append("    totalMonths: ").append(toIndentedString(totalMonths)).append("\n");
    sb.append("    totalSeconds: ").append(toIndentedString(totalSeconds)).append("\n");
    sb.append("    totalYears: ").append(toIndentedString(totalYears)).append("\n");
    sb.append("    years: ").append(toIndentedString(years)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("days");
    openapiFields.add("hours");
    openapiFields.add("milliseconds");
    openapiFields.add("minutes");
    openapiFields.add("months");
    openapiFields.add("ticks");
    openapiFields.add("totalDays");
    openapiFields.add("totalHours");
    openapiFields.add("totalMilliseconds");
    openapiFields.add("totalMinutes");
    openapiFields.add("totalMonths");
    openapiFields.add("totalSeconds");
    openapiFields.add("totalYears");
    openapiFields.add("years");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to OutputDateDifference
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!OutputDateDifference.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in OutputDateDifference is not found in the empty JSON string", OutputDateDifference.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!OutputDateDifference.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `OutputDateDifference` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!OutputDateDifference.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'OutputDateDifference' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<OutputDateDifference> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(OutputDateDifference.class));

       return (TypeAdapter<T>) new TypeAdapter<OutputDateDifference>() {
           @Override
           public void write(JsonWriter out, OutputDateDifference value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public OutputDateDifference read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of OutputDateDifference given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of OutputDateDifference
   * @throws IOException if the JSON string is invalid with respect to OutputDateDifference
   */
  public static OutputDateDifference fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OutputDateDifference.class);
  }

  /**
   * Convert an instance of OutputDateDifference to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

