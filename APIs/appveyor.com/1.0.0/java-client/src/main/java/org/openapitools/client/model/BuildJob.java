/*
 * AppVeyor REST API
 * AppVeyor is a hosted continuous integration service which runs on Microsoft Windows.  The AppVeyor REST API provides a RESTful way to interact with the AppVeyor service.  This includes managing projects, builds, deployments, and the teams that build them.  Additional help and discussion of the AppVeyor REST API is available at http://help.appveyor.com/discussions  This Swagger definition is an **unofficial** description of the AppVeyor REST API maintained at https://github.com/kevinoid/appveyor-swagger Please report any issues or suggestions for this Swagger definition at https://github.com/kevinoid/appveyor-swagger/issues/new  #### API Conventions  Fields which are missing from update operations (`PUT` requests) are typically reset to their default values.  So although most fields are not technically required, they should usually be specified in practice. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: team@appveyor.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.OSType;
import org.openapitools.client.model.Status;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * BuildJob
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:20:34.647088-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BuildJob {
  public static final String SERIALIZED_NAME_CREATED = "created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private OffsetDateTime created;

  public static final String SERIALIZED_NAME_UPDATED = "updated";
  @SerializedName(SERIALIZED_NAME_UPDATED)
  private OffsetDateTime updated;

  public static final String SERIALIZED_NAME_FINISHED = "finished";
  @SerializedName(SERIALIZED_NAME_FINISHED)
  private OffsetDateTime finished;

  public static final String SERIALIZED_NAME_JOB_ID = "jobId";
  @SerializedName(SERIALIZED_NAME_JOB_ID)
  private String jobId;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_STARTED = "started";
  @SerializedName(SERIALIZED_NAME_STARTED)
  private OffsetDateTime started;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private Status status;

  public static final String SERIALIZED_NAME_ALLOW_FAILURE = "allowFailure";
  @SerializedName(SERIALIZED_NAME_ALLOW_FAILURE)
  private Boolean allowFailure;

  public static final String SERIALIZED_NAME_ARTIFACTS_COUNT = "artifactsCount";
  @SerializedName(SERIALIZED_NAME_ARTIFACTS_COUNT)
  private Integer artifactsCount;

  public static final String SERIALIZED_NAME_COMPILATION_ERRORS_COUNT = "compilationErrorsCount";
  @SerializedName(SERIALIZED_NAME_COMPILATION_ERRORS_COUNT)
  private Integer compilationErrorsCount;

  public static final String SERIALIZED_NAME_COMPILATION_MESSAGES_COUNT = "compilationMessagesCount";
  @SerializedName(SERIALIZED_NAME_COMPILATION_MESSAGES_COUNT)
  private Integer compilationMessagesCount;

  public static final String SERIALIZED_NAME_COMPILATION_WARNINGS_COUNT = "compilationWarningsCount";
  @SerializedName(SERIALIZED_NAME_COMPILATION_WARNINGS_COUNT)
  private Integer compilationWarningsCount;

  public static final String SERIALIZED_NAME_FAILED_TESTS_COUNT = "failedTestsCount";
  @SerializedName(SERIALIZED_NAME_FAILED_TESTS_COUNT)
  private Integer failedTestsCount;

  public static final String SERIALIZED_NAME_MESSAGES_COUNT = "messagesCount";
  @SerializedName(SERIALIZED_NAME_MESSAGES_COUNT)
  private Integer messagesCount;

  public static final String SERIALIZED_NAME_OS_TYPE = "osType";
  @SerializedName(SERIALIZED_NAME_OS_TYPE)
  private OSType osType;

  public static final String SERIALIZED_NAME_PASSED_TESTS_COUNT = "passedTestsCount";
  @SerializedName(SERIALIZED_NAME_PASSED_TESTS_COUNT)
  private Integer passedTestsCount;

  public static final String SERIALIZED_NAME_TESTS_COUNT = "testsCount";
  @SerializedName(SERIALIZED_NAME_TESTS_COUNT)
  private Integer testsCount;

  public BuildJob() {
  }

  public BuildJob(
     OffsetDateTime created, 
     OffsetDateTime updated
  ) {
    this();
    this.created = created;
    this.updated = updated;
  }

  /**
   * Get created
   * @return created
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreated() {
    return created;
  }



  /**
   * Get updated
   * @return updated
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdated() {
    return updated;
  }



  public BuildJob finished(OffsetDateTime finished) {
    this.finished = finished;
    return this;
  }

  /**
   * Get finished
   * @return finished
   */
  @javax.annotation.Nullable
  public OffsetDateTime getFinished() {
    return finished;
  }

  public void setFinished(OffsetDateTime finished) {
    this.finished = finished;
  }


  public BuildJob jobId(String jobId) {
    this.jobId = jobId;
    return this;
  }

  /**
   * Get jobId
   * @return jobId
   */
  @javax.annotation.Nullable
  public String getJobId() {
    return jobId;
  }

  public void setJobId(String jobId) {
    this.jobId = jobId;
  }


  public BuildJob name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public BuildJob started(OffsetDateTime started) {
    this.started = started;
    return this;
  }

  /**
   * Get started
   * @return started
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStarted() {
    return started;
  }

  public void setStarted(OffsetDateTime started) {
    this.started = started;
  }


  public BuildJob status(Status status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nullable
  public Status getStatus() {
    return status;
  }

  public void setStatus(Status status) {
    this.status = status;
  }


  public BuildJob allowFailure(Boolean allowFailure) {
    this.allowFailure = allowFailure;
    return this;
  }

  /**
   * Get allowFailure
   * @return allowFailure
   */
  @javax.annotation.Nullable
  public Boolean getAllowFailure() {
    return allowFailure;
  }

  public void setAllowFailure(Boolean allowFailure) {
    this.allowFailure = allowFailure;
  }


  public BuildJob artifactsCount(Integer artifactsCount) {
    this.artifactsCount = artifactsCount;
    return this;
  }

  /**
   * Get artifactsCount
   * minimum: 0
   * @return artifactsCount
   */
  @javax.annotation.Nullable
  public Integer getArtifactsCount() {
    return artifactsCount;
  }

  public void setArtifactsCount(Integer artifactsCount) {
    this.artifactsCount = artifactsCount;
  }


  public BuildJob compilationErrorsCount(Integer compilationErrorsCount) {
    this.compilationErrorsCount = compilationErrorsCount;
    return this;
  }

  /**
   * Get compilationErrorsCount
   * minimum: 0
   * @return compilationErrorsCount
   */
  @javax.annotation.Nullable
  public Integer getCompilationErrorsCount() {
    return compilationErrorsCount;
  }

  public void setCompilationErrorsCount(Integer compilationErrorsCount) {
    this.compilationErrorsCount = compilationErrorsCount;
  }


  public BuildJob compilationMessagesCount(Integer compilationMessagesCount) {
    this.compilationMessagesCount = compilationMessagesCount;
    return this;
  }

  /**
   * Get compilationMessagesCount
   * minimum: 0
   * @return compilationMessagesCount
   */
  @javax.annotation.Nullable
  public Integer getCompilationMessagesCount() {
    return compilationMessagesCount;
  }

  public void setCompilationMessagesCount(Integer compilationMessagesCount) {
    this.compilationMessagesCount = compilationMessagesCount;
  }


  public BuildJob compilationWarningsCount(Integer compilationWarningsCount) {
    this.compilationWarningsCount = compilationWarningsCount;
    return this;
  }

  /**
   * Get compilationWarningsCount
   * minimum: 0
   * @return compilationWarningsCount
   */
  @javax.annotation.Nullable
  public Integer getCompilationWarningsCount() {
    return compilationWarningsCount;
  }

  public void setCompilationWarningsCount(Integer compilationWarningsCount) {
    this.compilationWarningsCount = compilationWarningsCount;
  }


  public BuildJob failedTestsCount(Integer failedTestsCount) {
    this.failedTestsCount = failedTestsCount;
    return this;
  }

  /**
   * Get failedTestsCount
   * minimum: 0
   * @return failedTestsCount
   */
  @javax.annotation.Nullable
  public Integer getFailedTestsCount() {
    return failedTestsCount;
  }

  public void setFailedTestsCount(Integer failedTestsCount) {
    this.failedTestsCount = failedTestsCount;
  }


  public BuildJob messagesCount(Integer messagesCount) {
    this.messagesCount = messagesCount;
    return this;
  }

  /**
   * Get messagesCount
   * minimum: 0
   * @return messagesCount
   */
  @javax.annotation.Nullable
  public Integer getMessagesCount() {
    return messagesCount;
  }

  public void setMessagesCount(Integer messagesCount) {
    this.messagesCount = messagesCount;
  }


  public BuildJob osType(OSType osType) {
    this.osType = osType;
    return this;
  }

  /**
   * Get osType
   * @return osType
   */
  @javax.annotation.Nullable
  public OSType getOsType() {
    return osType;
  }

  public void setOsType(OSType osType) {
    this.osType = osType;
  }


  public BuildJob passedTestsCount(Integer passedTestsCount) {
    this.passedTestsCount = passedTestsCount;
    return this;
  }

  /**
   * Get passedTestsCount
   * minimum: 0
   * @return passedTestsCount
   */
  @javax.annotation.Nullable
  public Integer getPassedTestsCount() {
    return passedTestsCount;
  }

  public void setPassedTestsCount(Integer passedTestsCount) {
    this.passedTestsCount = passedTestsCount;
  }


  public BuildJob testsCount(Integer testsCount) {
    this.testsCount = testsCount;
    return this;
  }

  /**
   * Get testsCount
   * minimum: 0
   * @return testsCount
   */
  @javax.annotation.Nullable
  public Integer getTestsCount() {
    return testsCount;
  }

  public void setTestsCount(Integer testsCount) {
    this.testsCount = testsCount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BuildJob buildJob = (BuildJob) o;
    return Objects.equals(this.created, buildJob.created) &&
        Objects.equals(this.updated, buildJob.updated) &&
        Objects.equals(this.finished, buildJob.finished) &&
        Objects.equals(this.jobId, buildJob.jobId) &&
        Objects.equals(this.name, buildJob.name) &&
        Objects.equals(this.started, buildJob.started) &&
        Objects.equals(this.status, buildJob.status) &&
        Objects.equals(this.allowFailure, buildJob.allowFailure) &&
        Objects.equals(this.artifactsCount, buildJob.artifactsCount) &&
        Objects.equals(this.compilationErrorsCount, buildJob.compilationErrorsCount) &&
        Objects.equals(this.compilationMessagesCount, buildJob.compilationMessagesCount) &&
        Objects.equals(this.compilationWarningsCount, buildJob.compilationWarningsCount) &&
        Objects.equals(this.failedTestsCount, buildJob.failedTestsCount) &&
        Objects.equals(this.messagesCount, buildJob.messagesCount) &&
        Objects.equals(this.osType, buildJob.osType) &&
        Objects.equals(this.passedTestsCount, buildJob.passedTestsCount) &&
        Objects.equals(this.testsCount, buildJob.testsCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(created, updated, finished, jobId, name, started, status, allowFailure, artifactsCount, compilationErrorsCount, compilationMessagesCount, compilationWarningsCount, failedTestsCount, messagesCount, osType, passedTestsCount, testsCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BuildJob {\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    updated: ").append(toIndentedString(updated)).append("\n");
    sb.append("    finished: ").append(toIndentedString(finished)).append("\n");
    sb.append("    jobId: ").append(toIndentedString(jobId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    started: ").append(toIndentedString(started)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    allowFailure: ").append(toIndentedString(allowFailure)).append("\n");
    sb.append("    artifactsCount: ").append(toIndentedString(artifactsCount)).append("\n");
    sb.append("    compilationErrorsCount: ").append(toIndentedString(compilationErrorsCount)).append("\n");
    sb.append("    compilationMessagesCount: ").append(toIndentedString(compilationMessagesCount)).append("\n");
    sb.append("    compilationWarningsCount: ").append(toIndentedString(compilationWarningsCount)).append("\n");
    sb.append("    failedTestsCount: ").append(toIndentedString(failedTestsCount)).append("\n");
    sb.append("    messagesCount: ").append(toIndentedString(messagesCount)).append("\n");
    sb.append("    osType: ").append(toIndentedString(osType)).append("\n");
    sb.append("    passedTestsCount: ").append(toIndentedString(passedTestsCount)).append("\n");
    sb.append("    testsCount: ").append(toIndentedString(testsCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("created");
    openapiFields.add("updated");
    openapiFields.add("finished");
    openapiFields.add("jobId");
    openapiFields.add("name");
    openapiFields.add("started");
    openapiFields.add("status");
    openapiFields.add("allowFailure");
    openapiFields.add("artifactsCount");
    openapiFields.add("compilationErrorsCount");
    openapiFields.add("compilationMessagesCount");
    openapiFields.add("compilationWarningsCount");
    openapiFields.add("failedTestsCount");
    openapiFields.add("messagesCount");
    openapiFields.add("osType");
    openapiFields.add("passedTestsCount");
    openapiFields.add("testsCount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BuildJob
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BuildJob.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BuildJob is not found in the empty JSON string", BuildJob.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BuildJob.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BuildJob` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("jobId") != null && !jsonObj.get("jobId").isJsonNull()) && !jsonObj.get("jobId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `jobId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("jobId").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        Status.validateJsonElement(jsonObj.get("status"));
      }
      // validate the optional field `osType`
      if (jsonObj.get("osType") != null && !jsonObj.get("osType").isJsonNull()) {
        OSType.validateJsonElement(jsonObj.get("osType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BuildJob.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BuildJob' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BuildJob> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BuildJob.class));

       return (TypeAdapter<T>) new TypeAdapter<BuildJob>() {
           @Override
           public void write(JsonWriter out, BuildJob value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BuildJob read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BuildJob given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BuildJob
   * @throws IOException if the JSON string is invalid with respect to BuildJob
   */
  public static BuildJob fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BuildJob.class);
  }

  /**
   * Convert an instance of BuildJob to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

