# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class V3DynamoDbTimetable(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, applicable_local_date: str=None, exists: bool=None, parser_mapping_version: str=None, parser_version: int=None, pt_mapping_version: str=None, pt_version: int=None, table_name: str=None, transport_type: int=None):
        """V3DynamoDbTimetable - a model defined in OpenAPI

        :param applicable_local_date: The applicable_local_date of this V3DynamoDbTimetable.
        :param exists: The exists of this V3DynamoDbTimetable.
        :param parser_mapping_version: The parser_mapping_version of this V3DynamoDbTimetable.
        :param parser_version: The parser_version of this V3DynamoDbTimetable.
        :param pt_mapping_version: The pt_mapping_version of this V3DynamoDbTimetable.
        :param pt_version: The pt_version of this V3DynamoDbTimetable.
        :param table_name: The table_name of this V3DynamoDbTimetable.
        :param transport_type: The transport_type of this V3DynamoDbTimetable.
        """
        self.openapi_types = {
            'applicable_local_date': str,
            'exists': bool,
            'parser_mapping_version': str,
            'parser_version': int,
            'pt_mapping_version': str,
            'pt_version': int,
            'table_name': str,
            'transport_type': int
        }

        self.attribute_map = {
            'applicable_local_date': 'applicable_local_date',
            'exists': 'exists',
            'parser_mapping_version': 'parser_mapping_version',
            'parser_version': 'parser_version',
            'pt_mapping_version': 'pt_mapping_version',
            'pt_version': 'pt_version',
            'table_name': 'table_name',
            'transport_type': 'transport_type'
        }

        self._applicable_local_date = applicable_local_date
        self._exists = exists
        self._parser_mapping_version = parser_mapping_version
        self._parser_version = parser_version
        self._pt_mapping_version = pt_mapping_version
        self._pt_version = pt_version
        self._table_name = table_name
        self._transport_type = transport_type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'V3DynamoDbTimetable':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The V3.DynamoDbTimetable of this V3DynamoDbTimetable.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def applicable_local_date(self):
        """Gets the applicable_local_date of this V3DynamoDbTimetable.

        Formated date string of applicable date

        :return: The applicable_local_date of this V3DynamoDbTimetable.
        :rtype: str
        """
        return self._applicable_local_date

    @applicable_local_date.setter
    def applicable_local_date(self, applicable_local_date):
        """Sets the applicable_local_date of this V3DynamoDbTimetable.

        Formated date string of applicable date

        :param applicable_local_date: The applicable_local_date of this V3DynamoDbTimetable.
        :type applicable_local_date: str
        """

        self._applicable_local_date = applicable_local_date

    @property
    def exists(self):
        """Gets the exists of this V3DynamoDbTimetable.

        True if the named table has been created in DynamoDB (i.e. at least one departure record has been loaded),              or false if there are no records for this date and transport type.

        :return: The exists of this V3DynamoDbTimetable.
        :rtype: bool
        """
        return self._exists

    @exists.setter
    def exists(self, exists):
        """Sets the exists of this V3DynamoDbTimetable.

        True if the named table has been created in DynamoDB (i.e. at least one departure record has been loaded),              or false if there are no records for this date and transport type.

        :param exists: The exists of this V3DynamoDbTimetable.
        :type exists: bool
        """

        self._exists = exists

    @property
    def parser_mapping_version(self):
        """Gets the parser_mapping_version of this V3DynamoDbTimetable.

        Diva Mapping Version used to load Parser into DynamoDB

        :return: The parser_mapping_version of this V3DynamoDbTimetable.
        :rtype: str
        """
        return self._parser_mapping_version

    @parser_mapping_version.setter
    def parser_mapping_version(self, parser_mapping_version):
        """Sets the parser_mapping_version of this V3DynamoDbTimetable.

        Diva Mapping Version used to load Parser into DynamoDB

        :param parser_mapping_version: The parser_mapping_version of this V3DynamoDbTimetable.
        :type parser_mapping_version: str
        """

        self._parser_mapping_version = parser_mapping_version

    @property
    def parser_version(self):
        """Gets the parser_version of this V3DynamoDbTimetable.

        Parser verison

        :return: The parser_version of this V3DynamoDbTimetable.
        :rtype: int
        """
        return self._parser_version

    @parser_version.setter
    def parser_version(self, parser_version):
        """Sets the parser_version of this V3DynamoDbTimetable.

        Parser verison

        :param parser_version: The parser_version of this V3DynamoDbTimetable.
        :type parser_version: int
        """

        self._parser_version = parser_version

    @property
    def pt_mapping_version(self):
        """Gets the pt_mapping_version of this V3DynamoDbTimetable.

        Diva Mapping Version used to load PT into DynamoDB

        :return: The pt_mapping_version of this V3DynamoDbTimetable.
        :rtype: str
        """
        return self._pt_mapping_version

    @pt_mapping_version.setter
    def pt_mapping_version(self, pt_mapping_version):
        """Sets the pt_mapping_version of this V3DynamoDbTimetable.

        Diva Mapping Version used to load PT into DynamoDB

        :param pt_mapping_version: The pt_mapping_version of this V3DynamoDbTimetable.
        :type pt_mapping_version: str
        """

        self._pt_mapping_version = pt_mapping_version

    @property
    def pt_version(self):
        """Gets the pt_version of this V3DynamoDbTimetable.

        PT version

        :return: The pt_version of this V3DynamoDbTimetable.
        :rtype: int
        """
        return self._pt_version

    @pt_version.setter
    def pt_version(self, pt_version):
        """Sets the pt_version of this V3DynamoDbTimetable.

        PT version

        :param pt_version: The pt_version of this V3DynamoDbTimetable.
        :type pt_version: int
        """

        self._pt_version = pt_version

    @property
    def table_name(self):
        """Gets the table_name of this V3DynamoDbTimetable.

        Name of corresponding table in DynamoDB.

        :return: The table_name of this V3DynamoDbTimetable.
        :rtype: str
        """
        return self._table_name

    @table_name.setter
    def table_name(self, table_name):
        """Sets the table_name of this V3DynamoDbTimetable.

        Name of corresponding table in DynamoDB.

        :param table_name: The table_name of this V3DynamoDbTimetable.
        :type table_name: str
        """

        self._table_name = table_name

    @property
    def transport_type(self):
        """Gets the transport_type of this V3DynamoDbTimetable.

        A.k.a. Transport Mode (e.g. Train, Tram, Bus, V/Line, Nightrider)

        :return: The transport_type of this V3DynamoDbTimetable.
        :rtype: int
        """
        return self._transport_type

    @transport_type.setter
    def transport_type(self, transport_type):
        """Sets the transport_type of this V3DynamoDbTimetable.

        A.k.a. Transport Mode (e.g. Train, Tram, Bus, V/Line, Nightrider)

        :param transport_type: The transport_type of this V3DynamoDbTimetable.
        :type transport_type: int
        """
        allowed_values = [0, 1, 2, 3, 4]  # noqa: E501
        if transport_type not in allowed_values:
            raise ValueError(
                "Invalid value for `transport_type` ({0}), must be one of {1}"
                .format(transport_type, allowed_values)
            )

        self._transport_type = transport_type
