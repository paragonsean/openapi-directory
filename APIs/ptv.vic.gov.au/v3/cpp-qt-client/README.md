# C++ Qt API client

# 

PTV Timetable API - Version 3

- API version: v3
- Generator version: 7.9.0

The PTV Timetable API provides direct access to Public Transport Victoriaâ€™s public transport timetable data.

The API returns scheduled timetable, route and stop data for all metropolitan and regional train, tram and bus services in Victoria, including Night Network(Night Train and Night Tram data are included in metropolitan train and tram services data, respectively, whereas Night Bus is a separate route type).

The API also returns real-time data for metropolitan train, tram and bus services (where this data is made available to PTV), as well as disruption information, stop facility information, and access to myki ticket outlet data.

This Swagger is for Version 3 of the PTV Timetable API. By using this documentation you agree to comply with the licence and terms of service.

Train timetable data is updated daily, while the remaining data is updated weekly, taking into account any planned timetable changes (for example, due to holidays or planned disruptions). The PTV timetable API is the same API used by PTV for its apps. To access the most up to date data PTV has (including real-time data) you must use the API dynamically.

You can access the PTV Timetable API through a HTTP or HTTPS interface, as follows:

    base URL / version number / API name / query string
The base URL is either:
  *  http://timetableapi.ptv.vic.gov.au
or
  *  https://timetableapi.ptv.vic.gov.au

The Swagger JSON file is available at http://timetableapi.ptv.vic.gov.au/swagger/docs/v3

Frequently asked questions are available on the PTV website at http://ptv.vic.gov.au/apifaq

Links to the following information are also provided on the PTV website at http://ptv.vic.gov.au/ptv-timetable-api/
* How to register for an API key and calculate a signature
* PTV Timetable API V2 to V3 Migration Guide
* Documentation for Version 2 of the PTV Timetable API
* PTV Timetable API Data Quality Statement

All information about how to use the API is in this documentation. PTV cannot provide technical support for the API.

Credits: This page has been based on Steve Bennett's http://opentransportdata.org/, used with permission.


  For more information, please visit [http://ptv.vic.gov.au/digital](http://ptv.vic.gov.au/digital)

*Automatically generated by the [OpenAPI Generator](https://openapi-generator.tech)*


## Requirements

Building the API client library requires:

1. CMake 3.2+
2. Qt
3. C++ Compiler

## Getting Started

example.h:
```c++

#include <iostream>
#include "../client/OAIDeparturesApi.h"

using namespace test_namespace;

class Example : public QObject {
    Q_OBJECT
    qint32 create();
    qint32 create();
    QList<qint32> create();
    qint32 create();
    bool create();
    QDateTime create();
    qint32 create();
    bool create();
    bool create();
    QList<QString> create();
    bool create();
    QString create();
    QString create();
    QString create();
public Q_SLOTS:
   void exampleFunction1();
};

```

example.cpp:
```c++

#include "../client/OAIDeparturesApi.h"
#include "example.h"
#include <QTimer>
#include <QEventLoop>

qint32 Example::create(){
    qint32 obj;
qint32 Example::create(){
    qint32 obj;
QList&lt;qint32&gt; Example::create(){
    QList<qint32> obj;
qint32 Example::create(){
    qint32 obj;
bool Example::create(){
    bool obj;
QDateTime Example::create(){
    QDateTime obj;
qint32 Example::create(){
    qint32 obj;
bool Example::create(){
    bool obj;
bool Example::create(){
    bool obj;
QList&lt;QString&gt; Example::create(){
    QList<QString> obj;
bool Example::create(){
    bool obj;
QString Example::create(){
    QString obj;
QString Example::create(){
    QString obj;
QString Example::create(){
    QString obj;
 return obj;
}

void Example::exampleFunction1(){
     OAIDeparturesApi apiInstance;
     
      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      qint32 route_type = create(); // qint32 | Number identifying transport mode; values returned via RouteTypes API

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      qint32 stop_id = create(); // qint32 | Identifier of stop; values returned by Stops API

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      QList<qint32> platform_numbers = create(); // QList<qint32> | Filter by platform number at stop

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      qint32 direction_id = create(); // qint32 | Filter by identifier of direction of travel; values returned by Directions API - /v3/directions/route/{route_id}

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      bool gtfs = create(); // bool | Indicates that stop_id parameter will accept \"GTFS stop_id\" data

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      QDateTime date_utc = create(); // QDateTime | Filter by the date and time of the request (ISO 8601 UTC format) (default = current date and time)

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      qint32 max_results = create(); // qint32 | Maximum number of results returned

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      bool include_cancelled = create(); // bool | Indicates if cancelled services (if they exist) are returned (default = false) - metropolitan train only

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      bool look_backwards = create(); // bool | Indicates if filtering runs (and their departures) to those that arrive at destination before date_utc (default = false). Requires max_results &gt; 0.

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      QList<QString> expand = create(); // QList<QString> | List of objects to be returned in full (i.e. expanded) - options include: All, Stop, Route, Run, Direction, Disruption, VehiclePosition, VehicleDescriptor or None.              Run must be expanded to receive VehiclePosition and VehicleDescriptor information.

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      bool include_geopath = create(); // bool | Indicates if the route geopath should be returned

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      QString token = create(); // QString | Please ignore

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      QString devid = create(); // QString | Your developer id

      QEventLoop loop;
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignal, [&]() {
          loop.quit();
      });
      connect(&apiInstance, &OAIDeparturesApi::departuresGetForStopSignalE, [&](QNetworkReply::NetworkError, QString error_str) {
          qDebug() << "Error happened while issuing request : " << error_str;
          loop.quit();
      });

      QString signature = create(); // QString | Authentication signature for request
      apiInstance.departuresGetForStop(route_typestop_idplatform_numbersdirection_idgtfsdate_utcmax_resultsinclude_cancelledlook_backwardsexpandinclude_geopathtokendevidsignature);
      QTimer::singleShot(5000, &loop, &QEventLoop::quit);
      loop.exec();
  }

```

## Documentation for Servers

Parameterized Servers are supported. Define a server in the API for each endpoint with arbitrary numbers of variables:

```yaml
servers:
- url: http://{server}:{port}/{basePath}
  description: Description of the Server
  variables:
    server:
        enum:
          - 'petstore'
          - 'qa-petstore'
          - 'dev-petstore'
        default: 'petstore'
    port:
      enum:
        - '3000'
        - '1000'
      default: '3000'
    basePath:
      default: v1
```
To change the default variable, use this function in each Api:
```c++
int setDefaultServerValue(int serverIndex,const QString &operation, const QString &variable,const QString &val);
```
The parameter "serverIndex" will choose a server from the server list for each endpoint. There is always at least one server with index 0. The Parameter "operation" should be the desired endpoint operationid.
Variable is the name of the variable you wish to change and the value is the new default Value.
The function will return -1 when the variable does not exists, -2 if value is not defined in the variable enum and -3 if the operation is not found.

If your endpoint has multiple server objects in the servers array, you can set the server that will be used with this function:
```c++
void setServerIndex(const QString &operation, int serverIndex);
```
Parameter "operation" should be your operationid. "serverIndex" is the index you want to set as your default server. The function will check if there is a server with your index.
Here is an example of multiple servers in the servers array. The first server will have index 0 and the second will have index 1.
```yaml
servers:
- url: http://{server}:8080/
  description: Description of the Server
  variables:
    server:
        enum:
          - 'petstore'
          - 'qa-petstore'
          - 'dev-petstore'
        default: 'petstore'
- url: https://localhost:8080/v1
```

## Documentation for Authorization

All endpoints do not require authorization.
Authentication schemes defined for the API:

## Author




## License

Creative Commons Attribution 4.0 International for more information visit [Creative Commons Attribution 4.0 International](https://creativecommons.org/licenses/by/4.0/)