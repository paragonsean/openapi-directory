/**
 * PTV Timetable API - Version 3
 * The PTV Timetable API provides direct access to Public Transport Victoriaâ€™s public transport timetable data.    The API returns scheduled timetable, route and stop data for all metropolitan and regional train, tram and bus services in Victoria, including Night Network(Night Train and Night Tram data are included in metropolitan train and tram services data, respectively, whereas Night Bus is a separate route type).    The API also returns real-time data for metropolitan train, tram and bus services (where this data is made available to PTV), as well as disruption information, stop facility information, and access to myki ticket outlet data.    This Swagger is for Version 3 of the PTV Timetable API. By using this documentation you agree to comply with the licence and terms of service.    Train timetable data is updated daily, while the remaining data is updated weekly, taking into account any planned timetable changes (for example, due to holidays or planned disruptions). The PTV timetable API is the same API used by PTV for its apps. To access the most up to date data PTV has (including real-time data) you must use the API dynamically.    You can access the PTV Timetable API through a HTTP or HTTPS interface, as follows:        base URL / version number / API name / query string  The base URL is either:    *  http://timetableapi.ptv.vic.gov.au  or    *  https://timetableapi.ptv.vic.gov.au    The Swagger JSON file is available at http://timetableapi.ptv.vic.gov.au/swagger/docs/v3    Frequently asked questions are available on the PTV website at http://ptv.vic.gov.au/apifaq    Links to the following information are also provided on the PTV website at http://ptv.vic.gov.au/ptv-timetable-api/  * How to register for an API key and calculate a signature  * PTV Timetable API V2 to V3 Migration Guide  * Documentation for Version 2 of the PTV Timetable API  * PTV Timetable API Data Quality Statement    All information about how to use the API is in this documentation. PTV cannot provide technical support for the API.    Credits: This page has been based on Steve Bennett's http://opentransportdata.org/, used with permission.  
 *
 * The version of the OpenAPI document: v3
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * OAIV3_PatternDeparture.h
 *
 * 
 */

#ifndef OAIV3_PatternDeparture_H
#define OAIV3_PatternDeparture_H

#include <QJsonObject>

#include "OAIV3_StopModel.h"
#include <QDateTime>
#include <QList>
#include <QString>

#include "OAIEnum.h"
#include "OAIObject.h"

namespace OpenAPI {
class OAIV3_StopModel;

class OAIV3_PatternDeparture : public OAIObject {
public:
    OAIV3_PatternDeparture();
    OAIV3_PatternDeparture(QString json);
    ~OAIV3_PatternDeparture() override;

    QString asJson() const override;
    QJsonObject asJsonObject() const override;
    void fromJsonObject(QJsonObject json) override;
    void fromJson(QString jsonString) override;

    bool isAtPlatform() const;
    void setAtPlatform(const bool &at_platform);
    bool is_at_platform_Set() const;
    bool is_at_platform_Valid() const;

    qint32 getDepartureSequence() const;
    void setDepartureSequence(const qint32 &departure_sequence);
    bool is_departure_sequence_Set() const;
    bool is_departure_sequence_Valid() const;

    qint32 getDirectionId() const;
    void setDirectionId(const qint32 &direction_id);
    bool is_direction_id_Set() const;
    bool is_direction_id_Valid() const;

    QList<qint64> getDisruptionIds() const;
    void setDisruptionIds(const QList<qint64> &disruption_ids);
    bool is_disruption_ids_Set() const;
    bool is_disruption_ids_Valid() const;

    QDateTime getEstimatedDepartureUtc() const;
    void setEstimatedDepartureUtc(const QDateTime &estimated_departure_utc);
    bool is_estimated_departure_utc_Set() const;
    bool is_estimated_departure_utc_Valid() const;

    QString getFlags() const;
    void setFlags(const QString &flags);
    bool is_flags_Set() const;
    bool is_flags_Valid() const;

    QString getPlatformNumber() const;
    void setPlatformNumber(const QString &platform_number);
    bool is_platform_number_Set() const;
    bool is_platform_number_Valid() const;

    qint32 getRouteId() const;
    void setRouteId(const qint32 &route_id);
    bool is_route_id_Set() const;
    bool is_route_id_Valid() const;

    qint32 getRunId() const;
    void setRunId(const qint32 &run_id);
    bool is_run_id_Set() const;
    bool is_run_id_Valid() const;

    QString getRunRef() const;
    void setRunRef(const QString &run_ref);
    bool is_run_ref_Set() const;
    bool is_run_ref_Valid() const;

    QDateTime getScheduledDepartureUtc() const;
    void setScheduledDepartureUtc(const QDateTime &scheduled_departure_utc);
    bool is_scheduled_departure_utc_Set() const;
    bool is_scheduled_departure_utc_Valid() const;

    QList<OAIV3_StopModel> getSkippedStops() const;
    void setSkippedStops(const QList<OAIV3_StopModel> &skipped_stops);
    bool is_skipped_stops_Set() const;
    bool is_skipped_stops_Valid() const;

    qint32 getStopId() const;
    void setStopId(const qint32 &stop_id);
    bool is_stop_id_Set() const;
    bool is_stop_id_Valid() const;

    virtual bool isSet() const override;
    virtual bool isValid() const override;

private:
    void initializeModel();

    bool m_at_platform;
    bool m_at_platform_isSet;
    bool m_at_platform_isValid;

    qint32 m_departure_sequence;
    bool m_departure_sequence_isSet;
    bool m_departure_sequence_isValid;

    qint32 m_direction_id;
    bool m_direction_id_isSet;
    bool m_direction_id_isValid;

    QList<qint64> m_disruption_ids;
    bool m_disruption_ids_isSet;
    bool m_disruption_ids_isValid;

    QDateTime m_estimated_departure_utc;
    bool m_estimated_departure_utc_isSet;
    bool m_estimated_departure_utc_isValid;

    QString m_flags;
    bool m_flags_isSet;
    bool m_flags_isValid;

    QString m_platform_number;
    bool m_platform_number_isSet;
    bool m_platform_number_isValid;

    qint32 m_route_id;
    bool m_route_id_isSet;
    bool m_route_id_isValid;

    qint32 m_run_id;
    bool m_run_id_isSet;
    bool m_run_id_isValid;

    QString m_run_ref;
    bool m_run_ref_isSet;
    bool m_run_ref_isValid;

    QDateTime m_scheduled_departure_utc;
    bool m_scheduled_departure_utc_isSet;
    bool m_scheduled_departure_utc_isValid;

    QList<OAIV3_StopModel> m_skipped_stops;
    bool m_skipped_stops_isSet;
    bool m_skipped_stops_isValid;

    qint32 m_stop_id;
    bool m_stop_id_isSet;
    bool m_stop_id_isValid;
};

} // namespace OpenAPI

Q_DECLARE_METATYPE(OpenAPI::OAIV3_PatternDeparture)

#endif // OAIV3_PatternDeparture_H
