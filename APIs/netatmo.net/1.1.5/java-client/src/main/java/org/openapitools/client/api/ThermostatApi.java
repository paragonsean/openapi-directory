/*
 * Netatmo
 * <h3>Welcome to the Netatmo swagger on-line documentation !</h3> This site is a complement to the official <a href=\"https://dev.netatmo.com/\">Netatmo developper documentation</a> using swagger to bring interactivity and easy testing of requests with the \"try it\" button (authenticate with the authorization code OAuth2 flow by clicking the authenticate button in the methods). You can find the source code for this site can be found in the project <a href=\"https://github.com/cbornet/netatmo-swagger-ui\">netatmo-swagger-ui</a>. You can also use the online <a href=\"./swagger.json\">swagger declaration</a> file to generate code or static documentation (see <a href=\"https://github.com/cbornet/netatmo-swagger-api\">netatmo-swagger-api</a>). 
 *
 * The version of the OpenAPI document: 1.1.5
 * Contact: contact-api@netatmo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.NAMeasureResponse;
import org.openapitools.client.model.NANewScheduleResponse;
import org.openapitools.client.model.NAOkResponse;
import org.openapitools.client.model.NAThermProgram;
import org.openapitools.client.model.NAThermostatDataResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ThermostatApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ThermostatApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ThermostatApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createnewschedule
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param naThermProgram The thermostat program (zones and timetable) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createnewscheduleCall(String deviceId, String moduleId, NAThermProgram naThermProgram, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = naThermProgram;

        // create path and map variables
        String localVarPath = "/createnewschedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("device_id", deviceId));
        }

        if (moduleId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("module_id", moduleId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "code_oauth", "password_oauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createnewscheduleValidateBeforeCall(String deviceId, String moduleId, NAThermProgram naThermProgram, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deviceId' is set
        if (deviceId == null) {
            throw new ApiException("Missing the required parameter 'deviceId' when calling createnewschedule(Async)");
        }

        // verify the required parameter 'moduleId' is set
        if (moduleId == null) {
            throw new ApiException("Missing the required parameter 'moduleId' when calling createnewschedule(Async)");
        }

        // verify the required parameter 'naThermProgram' is set
        if (naThermProgram == null) {
            throw new ApiException("Missing the required parameter 'naThermProgram' when calling createnewschedule(Async)");
        }

        return createnewscheduleCall(deviceId, moduleId, naThermProgram, _callback);

    }

    /**
     * 
     * The method createnewschedule creates a new schedule stored in the backup list.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param naThermProgram The thermostat program (zones and timetable) (required)
     * @return NANewScheduleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public NANewScheduleResponse createnewschedule(String deviceId, String moduleId, NAThermProgram naThermProgram) throws ApiException {
        ApiResponse<NANewScheduleResponse> localVarResp = createnewscheduleWithHttpInfo(deviceId, moduleId, naThermProgram);
        return localVarResp.getData();
    }

    /**
     * 
     * The method createnewschedule creates a new schedule stored in the backup list.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param naThermProgram The thermostat program (zones and timetable) (required)
     * @return ApiResponse&lt;NANewScheduleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NANewScheduleResponse> createnewscheduleWithHttpInfo(String deviceId, String moduleId, NAThermProgram naThermProgram) throws ApiException {
        okhttp3.Call localVarCall = createnewscheduleValidateBeforeCall(deviceId, moduleId, naThermProgram, null);
        Type localVarReturnType = new TypeToken<NANewScheduleResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * The method createnewschedule creates a new schedule stored in the backup list.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param naThermProgram The thermostat program (zones and timetable) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createnewscheduleAsync(String deviceId, String moduleId, NAThermProgram naThermProgram, final ApiCallback<NANewScheduleResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createnewscheduleValidateBeforeCall(deviceId, moduleId, naThermProgram, _callback);
        Type localVarReturnType = new TypeToken<NANewScheduleResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getmeasure_0
     * @param deviceId Id of the device whose module&#39;s measurements you want to retrieve. This _id can be found in the user&#39;s devices field. (required)
     * @param scale Defines the time interval between two measurements. Possible values : max -&gt; every value stored will be returned 30min -&gt; 1 value every 30 minutes 1hour -&gt; 1 value every hour 3hours -&gt; 1 value every 3 hours 1day -&gt; 1 value per day 1week -&gt; 1 value per week 1month -&gt; 1 value per month  (required)
     * @param type Measures you are interested in. Data you can request depends on the scale. **For Weather Station:**   * max -&gt; Temperature (°C), CO2 (ppm), Humidity (%), Pressure (mbar), Noise (db), Rain (mm), WindStrength (km/h), WindAngle (angles), Guststrength (km/h), GustAngle (angles)   * 30min, 1hour, 3hours -&gt; Same as above + min_temp, max_temp, min_hum, max_hum, min_pressure, max_pressure, min_noise, max_noise, sum_rain, date_max_gust   * 1day, 1week, 1month -&gt; Same as above + date_min_temp, date_max_temp, date_min_hum, date_max_hum, date_min_pressure, date_max_pressure, date_min_noise, date_max_noise, date_min_co2, date_max_co2  **For Thermostat:**   * max -&gt; temperature (°C), sp_temperature (°C), boileron (sec), boileroff (sec)   * 30min, 1hour, 3hours -&gt; temperature, sp_temperature, min_temp, max_temp, sum_boiler_on, sum_boiler_off   * 1day, 1week, 1month -&gt; temperature, min_temp, date_min_temp, max_temp, sum_boiler_on, sum_boiler_off  (required)
     * @param moduleId If you don&#39;t specify any module_id you will retrieve the device&#39;s measurements. If you specify a module_id you will retrieve the module&#39;s measurements. (optional)
     * @param dateBegin Starting timestamp (utc) of the requested measurements. Please note measurement retrieving is limited to 1024 measurements.  (optional)
     * @param dateEnd Ending timestamp (utc) of the request measurements. If you want only the last measurement, do not provide date_begin, and set date_end to &#x60;last&#x60;.  (optional)
     * @param limit Limits the number of measurements returned (default &amp; max is 1024) (optional)
     * @param optimize Allows you to choose the format of the answer. If you build a mobile app and bandwith usage is an issue, use &#x60;optimize &#x3D; true&#x60;. Use &#x60;optimize &#x3D; false&#x60;, for an easier parse. In this case, values are indexed by sorted timestamp. Example of un-optimized response : &#x60;&#x60;&#x60;json {\&quot;status\&quot;: \&quot;ok\&quot;,    \&quot;body\&quot;: {     \&quot;1347575400\&quot;: [18.3,39],     \&quot;1347586200\&quot;: [20.6,48]   }, \&quot;time_exec\&quot;: 0.012136936187744} &#x60;&#x60;&#x60; If optimize is set true, measurements are returned as an array of series of regularly spaced measurements. Each series is defined by a beginning time beg_time and a step between measurements, step_time: &#x60;&#x60;&#x60;json {\&quot;status\&quot;: \&quot;ok\&quot;,   \&quot;body\&quot;: [     {\&quot;beg_time\&quot;: 1347575400,      \&quot;step_time\&quot;: 10800,      \&quot;value\&quot;:          [[18.3,39],         [ 20.6,48]]     }], \&quot;time_exec\&quot;: 0.014238119125366} &#x60;&#x60;&#x60; Default value is &#x60;true&#x60;.  (optional)
     * @param realTime In scales higher than max, since the data is aggregated, the timestamps returned are by default offset by +(scale/2). For instance, if you ask for measurements at a daily scale, you will receive data timestamped at 12:00 if real_time is set to &#x60;false&#x60; (default case), and timestamped at 00:00 if real_time is set to &#x60;true&#x60;. NB : The servers always store data with real_time set to &#x60;true&#x60; and data are offset by this parameter AFTER having being time-filtered, thus you could have data after date_end if real_time is set to &#x60;false&#x60;.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getmeasure_0Call(String deviceId, String scale, List<String> type, String moduleId, Integer dateBegin, String dateEnd, Integer limit, Boolean optimize, Boolean realTime, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/getmeasure";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("device_id", deviceId));
        }

        if (moduleId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("module_id", moduleId));
        }

        if (scale != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scale", scale));
        }

        if (type != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "type", type));
        }

        if (dateBegin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date_begin", dateBegin));
        }

        if (dateEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date_end", dateEnd));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (optimize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("optimize", optimize));
        }

        if (realTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("real_time", realTime));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "code_oauth", "password_oauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getmeasure_0ValidateBeforeCall(String deviceId, String scale, List<String> type, String moduleId, Integer dateBegin, String dateEnd, Integer limit, Boolean optimize, Boolean realTime, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deviceId' is set
        if (deviceId == null) {
            throw new ApiException("Missing the required parameter 'deviceId' when calling getmeasure_0(Async)");
        }

        // verify the required parameter 'scale' is set
        if (scale == null) {
            throw new ApiException("Missing the required parameter 'scale' when calling getmeasure_0(Async)");
        }

        // verify the required parameter 'type' is set
        if (type == null) {
            throw new ApiException("Missing the required parameter 'type' when calling getmeasure_0(Async)");
        }

        return getmeasure_0Call(deviceId, scale, type, moduleId, dateBegin, dateEnd, limit, optimize, realTime, _callback);

    }

    /**
     * 
     * The method getmeasure returns the measurements of a device or a module. 
     * @param deviceId Id of the device whose module&#39;s measurements you want to retrieve. This _id can be found in the user&#39;s devices field. (required)
     * @param scale Defines the time interval between two measurements. Possible values : max -&gt; every value stored will be returned 30min -&gt; 1 value every 30 minutes 1hour -&gt; 1 value every hour 3hours -&gt; 1 value every 3 hours 1day -&gt; 1 value per day 1week -&gt; 1 value per week 1month -&gt; 1 value per month  (required)
     * @param type Measures you are interested in. Data you can request depends on the scale. **For Weather Station:**   * max -&gt; Temperature (°C), CO2 (ppm), Humidity (%), Pressure (mbar), Noise (db), Rain (mm), WindStrength (km/h), WindAngle (angles), Guststrength (km/h), GustAngle (angles)   * 30min, 1hour, 3hours -&gt; Same as above + min_temp, max_temp, min_hum, max_hum, min_pressure, max_pressure, min_noise, max_noise, sum_rain, date_max_gust   * 1day, 1week, 1month -&gt; Same as above + date_min_temp, date_max_temp, date_min_hum, date_max_hum, date_min_pressure, date_max_pressure, date_min_noise, date_max_noise, date_min_co2, date_max_co2  **For Thermostat:**   * max -&gt; temperature (°C), sp_temperature (°C), boileron (sec), boileroff (sec)   * 30min, 1hour, 3hours -&gt; temperature, sp_temperature, min_temp, max_temp, sum_boiler_on, sum_boiler_off   * 1day, 1week, 1month -&gt; temperature, min_temp, date_min_temp, max_temp, sum_boiler_on, sum_boiler_off  (required)
     * @param moduleId If you don&#39;t specify any module_id you will retrieve the device&#39;s measurements. If you specify a module_id you will retrieve the module&#39;s measurements. (optional)
     * @param dateBegin Starting timestamp (utc) of the requested measurements. Please note measurement retrieving is limited to 1024 measurements.  (optional)
     * @param dateEnd Ending timestamp (utc) of the request measurements. If you want only the last measurement, do not provide date_begin, and set date_end to &#x60;last&#x60;.  (optional)
     * @param limit Limits the number of measurements returned (default &amp; max is 1024) (optional)
     * @param optimize Allows you to choose the format of the answer. If you build a mobile app and bandwith usage is an issue, use &#x60;optimize &#x3D; true&#x60;. Use &#x60;optimize &#x3D; false&#x60;, for an easier parse. In this case, values are indexed by sorted timestamp. Example of un-optimized response : &#x60;&#x60;&#x60;json {\&quot;status\&quot;: \&quot;ok\&quot;,    \&quot;body\&quot;: {     \&quot;1347575400\&quot;: [18.3,39],     \&quot;1347586200\&quot;: [20.6,48]   }, \&quot;time_exec\&quot;: 0.012136936187744} &#x60;&#x60;&#x60; If optimize is set true, measurements are returned as an array of series of regularly spaced measurements. Each series is defined by a beginning time beg_time and a step between measurements, step_time: &#x60;&#x60;&#x60;json {\&quot;status\&quot;: \&quot;ok\&quot;,   \&quot;body\&quot;: [     {\&quot;beg_time\&quot;: 1347575400,      \&quot;step_time\&quot;: 10800,      \&quot;value\&quot;:          [[18.3,39],         [ 20.6,48]]     }], \&quot;time_exec\&quot;: 0.014238119125366} &#x60;&#x60;&#x60; Default value is &#x60;true&#x60;.  (optional)
     * @param realTime In scales higher than max, since the data is aggregated, the timestamps returned are by default offset by +(scale/2). For instance, if you ask for measurements at a daily scale, you will receive data timestamped at 12:00 if real_time is set to &#x60;false&#x60; (default case), and timestamped at 00:00 if real_time is set to &#x60;true&#x60;. NB : The servers always store data with real_time set to &#x60;true&#x60; and data are offset by this parameter AFTER having being time-filtered, thus you could have data after date_end if real_time is set to &#x60;false&#x60;.  (optional)
     * @return NAMeasureResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public NAMeasureResponse getmeasure_0(String deviceId, String scale, List<String> type, String moduleId, Integer dateBegin, String dateEnd, Integer limit, Boolean optimize, Boolean realTime) throws ApiException {
        ApiResponse<NAMeasureResponse> localVarResp = getmeasure_0WithHttpInfo(deviceId, scale, type, moduleId, dateBegin, dateEnd, limit, optimize, realTime);
        return localVarResp.getData();
    }

    /**
     * 
     * The method getmeasure returns the measurements of a device or a module. 
     * @param deviceId Id of the device whose module&#39;s measurements you want to retrieve. This _id can be found in the user&#39;s devices field. (required)
     * @param scale Defines the time interval between two measurements. Possible values : max -&gt; every value stored will be returned 30min -&gt; 1 value every 30 minutes 1hour -&gt; 1 value every hour 3hours -&gt; 1 value every 3 hours 1day -&gt; 1 value per day 1week -&gt; 1 value per week 1month -&gt; 1 value per month  (required)
     * @param type Measures you are interested in. Data you can request depends on the scale. **For Weather Station:**   * max -&gt; Temperature (°C), CO2 (ppm), Humidity (%), Pressure (mbar), Noise (db), Rain (mm), WindStrength (km/h), WindAngle (angles), Guststrength (km/h), GustAngle (angles)   * 30min, 1hour, 3hours -&gt; Same as above + min_temp, max_temp, min_hum, max_hum, min_pressure, max_pressure, min_noise, max_noise, sum_rain, date_max_gust   * 1day, 1week, 1month -&gt; Same as above + date_min_temp, date_max_temp, date_min_hum, date_max_hum, date_min_pressure, date_max_pressure, date_min_noise, date_max_noise, date_min_co2, date_max_co2  **For Thermostat:**   * max -&gt; temperature (°C), sp_temperature (°C), boileron (sec), boileroff (sec)   * 30min, 1hour, 3hours -&gt; temperature, sp_temperature, min_temp, max_temp, sum_boiler_on, sum_boiler_off   * 1day, 1week, 1month -&gt; temperature, min_temp, date_min_temp, max_temp, sum_boiler_on, sum_boiler_off  (required)
     * @param moduleId If you don&#39;t specify any module_id you will retrieve the device&#39;s measurements. If you specify a module_id you will retrieve the module&#39;s measurements. (optional)
     * @param dateBegin Starting timestamp (utc) of the requested measurements. Please note measurement retrieving is limited to 1024 measurements.  (optional)
     * @param dateEnd Ending timestamp (utc) of the request measurements. If you want only the last measurement, do not provide date_begin, and set date_end to &#x60;last&#x60;.  (optional)
     * @param limit Limits the number of measurements returned (default &amp; max is 1024) (optional)
     * @param optimize Allows you to choose the format of the answer. If you build a mobile app and bandwith usage is an issue, use &#x60;optimize &#x3D; true&#x60;. Use &#x60;optimize &#x3D; false&#x60;, for an easier parse. In this case, values are indexed by sorted timestamp. Example of un-optimized response : &#x60;&#x60;&#x60;json {\&quot;status\&quot;: \&quot;ok\&quot;,    \&quot;body\&quot;: {     \&quot;1347575400\&quot;: [18.3,39],     \&quot;1347586200\&quot;: [20.6,48]   }, \&quot;time_exec\&quot;: 0.012136936187744} &#x60;&#x60;&#x60; If optimize is set true, measurements are returned as an array of series of regularly spaced measurements. Each series is defined by a beginning time beg_time and a step between measurements, step_time: &#x60;&#x60;&#x60;json {\&quot;status\&quot;: \&quot;ok\&quot;,   \&quot;body\&quot;: [     {\&quot;beg_time\&quot;: 1347575400,      \&quot;step_time\&quot;: 10800,      \&quot;value\&quot;:          [[18.3,39],         [ 20.6,48]]     }], \&quot;time_exec\&quot;: 0.014238119125366} &#x60;&#x60;&#x60; Default value is &#x60;true&#x60;.  (optional)
     * @param realTime In scales higher than max, since the data is aggregated, the timestamps returned are by default offset by +(scale/2). For instance, if you ask for measurements at a daily scale, you will receive data timestamped at 12:00 if real_time is set to &#x60;false&#x60; (default case), and timestamped at 00:00 if real_time is set to &#x60;true&#x60;. NB : The servers always store data with real_time set to &#x60;true&#x60; and data are offset by this parameter AFTER having being time-filtered, thus you could have data after date_end if real_time is set to &#x60;false&#x60;.  (optional)
     * @return ApiResponse&lt;NAMeasureResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NAMeasureResponse> getmeasure_0WithHttpInfo(String deviceId, String scale, List<String> type, String moduleId, Integer dateBegin, String dateEnd, Integer limit, Boolean optimize, Boolean realTime) throws ApiException {
        okhttp3.Call localVarCall = getmeasure_0ValidateBeforeCall(deviceId, scale, type, moduleId, dateBegin, dateEnd, limit, optimize, realTime, null);
        Type localVarReturnType = new TypeToken<NAMeasureResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * The method getmeasure returns the measurements of a device or a module. 
     * @param deviceId Id of the device whose module&#39;s measurements you want to retrieve. This _id can be found in the user&#39;s devices field. (required)
     * @param scale Defines the time interval between two measurements. Possible values : max -&gt; every value stored will be returned 30min -&gt; 1 value every 30 minutes 1hour -&gt; 1 value every hour 3hours -&gt; 1 value every 3 hours 1day -&gt; 1 value per day 1week -&gt; 1 value per week 1month -&gt; 1 value per month  (required)
     * @param type Measures you are interested in. Data you can request depends on the scale. **For Weather Station:**   * max -&gt; Temperature (°C), CO2 (ppm), Humidity (%), Pressure (mbar), Noise (db), Rain (mm), WindStrength (km/h), WindAngle (angles), Guststrength (km/h), GustAngle (angles)   * 30min, 1hour, 3hours -&gt; Same as above + min_temp, max_temp, min_hum, max_hum, min_pressure, max_pressure, min_noise, max_noise, sum_rain, date_max_gust   * 1day, 1week, 1month -&gt; Same as above + date_min_temp, date_max_temp, date_min_hum, date_max_hum, date_min_pressure, date_max_pressure, date_min_noise, date_max_noise, date_min_co2, date_max_co2  **For Thermostat:**   * max -&gt; temperature (°C), sp_temperature (°C), boileron (sec), boileroff (sec)   * 30min, 1hour, 3hours -&gt; temperature, sp_temperature, min_temp, max_temp, sum_boiler_on, sum_boiler_off   * 1day, 1week, 1month -&gt; temperature, min_temp, date_min_temp, max_temp, sum_boiler_on, sum_boiler_off  (required)
     * @param moduleId If you don&#39;t specify any module_id you will retrieve the device&#39;s measurements. If you specify a module_id you will retrieve the module&#39;s measurements. (optional)
     * @param dateBegin Starting timestamp (utc) of the requested measurements. Please note measurement retrieving is limited to 1024 measurements.  (optional)
     * @param dateEnd Ending timestamp (utc) of the request measurements. If you want only the last measurement, do not provide date_begin, and set date_end to &#x60;last&#x60;.  (optional)
     * @param limit Limits the number of measurements returned (default &amp; max is 1024) (optional)
     * @param optimize Allows you to choose the format of the answer. If you build a mobile app and bandwith usage is an issue, use &#x60;optimize &#x3D; true&#x60;. Use &#x60;optimize &#x3D; false&#x60;, for an easier parse. In this case, values are indexed by sorted timestamp. Example of un-optimized response : &#x60;&#x60;&#x60;json {\&quot;status\&quot;: \&quot;ok\&quot;,    \&quot;body\&quot;: {     \&quot;1347575400\&quot;: [18.3,39],     \&quot;1347586200\&quot;: [20.6,48]   }, \&quot;time_exec\&quot;: 0.012136936187744} &#x60;&#x60;&#x60; If optimize is set true, measurements are returned as an array of series of regularly spaced measurements. Each series is defined by a beginning time beg_time and a step between measurements, step_time: &#x60;&#x60;&#x60;json {\&quot;status\&quot;: \&quot;ok\&quot;,   \&quot;body\&quot;: [     {\&quot;beg_time\&quot;: 1347575400,      \&quot;step_time\&quot;: 10800,      \&quot;value\&quot;:          [[18.3,39],         [ 20.6,48]]     }], \&quot;time_exec\&quot;: 0.014238119125366} &#x60;&#x60;&#x60; Default value is &#x60;true&#x60;.  (optional)
     * @param realTime In scales higher than max, since the data is aggregated, the timestamps returned are by default offset by +(scale/2). For instance, if you ask for measurements at a daily scale, you will receive data timestamped at 12:00 if real_time is set to &#x60;false&#x60; (default case), and timestamped at 00:00 if real_time is set to &#x60;true&#x60;. NB : The servers always store data with real_time set to &#x60;true&#x60; and data are offset by this parameter AFTER having being time-filtered, thus you could have data after date_end if real_time is set to &#x60;false&#x60;.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getmeasure_0Async(String deviceId, String scale, List<String> type, String moduleId, Integer dateBegin, String dateEnd, Integer limit, Boolean optimize, Boolean realTime, final ApiCallback<NAMeasureResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getmeasure_0ValidateBeforeCall(deviceId, scale, type, moduleId, dateBegin, dateEnd, limit, optimize, realTime, _callback);
        Type localVarReturnType = new TypeToken<NAMeasureResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getthermostatsdata
     * @param deviceId Id of the device you want to retrieve information of (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getthermostatsdataCall(String deviceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/getthermostatsdata";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("device_id", deviceId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "code_oauth", "password_oauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getthermostatsdataValidateBeforeCall(String deviceId, final ApiCallback _callback) throws ApiException {
        return getthermostatsdataCall(deviceId, _callback);

    }

    /**
     * 
     * The method getthermostatsdata returns information about user&#39;s thermostats such as their last measurements.
     * @param deviceId Id of the device you want to retrieve information of (optional)
     * @return NAThermostatDataResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public NAThermostatDataResponse getthermostatsdata(String deviceId) throws ApiException {
        ApiResponse<NAThermostatDataResponse> localVarResp = getthermostatsdataWithHttpInfo(deviceId);
        return localVarResp.getData();
    }

    /**
     * 
     * The method getthermostatsdata returns information about user&#39;s thermostats such as their last measurements.
     * @param deviceId Id of the device you want to retrieve information of (optional)
     * @return ApiResponse&lt;NAThermostatDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NAThermostatDataResponse> getthermostatsdataWithHttpInfo(String deviceId) throws ApiException {
        okhttp3.Call localVarCall = getthermostatsdataValidateBeforeCall(deviceId, null);
        Type localVarReturnType = new TypeToken<NAThermostatDataResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * The method getthermostatsdata returns information about user&#39;s thermostats such as their last measurements.
     * @param deviceId Id of the device you want to retrieve information of (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getthermostatsdataAsync(String deviceId, final ApiCallback<NAThermostatDataResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getthermostatsdataValidateBeforeCall(deviceId, _callback);
        Type localVarReturnType = new TypeToken<NAThermostatDataResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for setthermpoint
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param setpointMode Chosen setpoint_mode (required)
     * @param setpointEndtime When using the manual or max setpoint_mode, this parameter defines when the setpoint expires. (optional)
     * @param setpointTemp When using the manual setpoint_mode, this parameter defines the temperature setpoint (in Celcius) to use. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call setthermpointCall(String deviceId, String moduleId, String setpointMode, Integer setpointEndtime, Float setpointTemp, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/setthermpoint";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("device_id", deviceId));
        }

        if (moduleId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("module_id", moduleId));
        }

        if (setpointMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("setpoint_mode", setpointMode));
        }

        if (setpointEndtime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("setpoint_endtime", setpointEndtime));
        }

        if (setpointTemp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("setpoint_temp", setpointTemp));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "code_oauth", "password_oauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call setthermpointValidateBeforeCall(String deviceId, String moduleId, String setpointMode, Integer setpointEndtime, Float setpointTemp, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deviceId' is set
        if (deviceId == null) {
            throw new ApiException("Missing the required parameter 'deviceId' when calling setthermpoint(Async)");
        }

        // verify the required parameter 'moduleId' is set
        if (moduleId == null) {
            throw new ApiException("Missing the required parameter 'moduleId' when calling setthermpoint(Async)");
        }

        // verify the required parameter 'setpointMode' is set
        if (setpointMode == null) {
            throw new ApiException("Missing the required parameter 'setpointMode' when calling setthermpoint(Async)");
        }

        return setthermpointCall(deviceId, moduleId, setpointMode, setpointEndtime, setpointTemp, _callback);

    }

    /**
     * 
     * The method setthermpoint changes the Thermostat manual temperature setpoint.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param setpointMode Chosen setpoint_mode (required)
     * @param setpointEndtime When using the manual or max setpoint_mode, this parameter defines when the setpoint expires. (optional)
     * @param setpointTemp When using the manual setpoint_mode, this parameter defines the temperature setpoint (in Celcius) to use. (optional)
     * @return NAOkResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public NAOkResponse setthermpoint(String deviceId, String moduleId, String setpointMode, Integer setpointEndtime, Float setpointTemp) throws ApiException {
        ApiResponse<NAOkResponse> localVarResp = setthermpointWithHttpInfo(deviceId, moduleId, setpointMode, setpointEndtime, setpointTemp);
        return localVarResp.getData();
    }

    /**
     * 
     * The method setthermpoint changes the Thermostat manual temperature setpoint.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param setpointMode Chosen setpoint_mode (required)
     * @param setpointEndtime When using the manual or max setpoint_mode, this parameter defines when the setpoint expires. (optional)
     * @param setpointTemp When using the manual setpoint_mode, this parameter defines the temperature setpoint (in Celcius) to use. (optional)
     * @return ApiResponse&lt;NAOkResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NAOkResponse> setthermpointWithHttpInfo(String deviceId, String moduleId, String setpointMode, Integer setpointEndtime, Float setpointTemp) throws ApiException {
        okhttp3.Call localVarCall = setthermpointValidateBeforeCall(deviceId, moduleId, setpointMode, setpointEndtime, setpointTemp, null);
        Type localVarReturnType = new TypeToken<NAOkResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * The method setthermpoint changes the Thermostat manual temperature setpoint.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param setpointMode Chosen setpoint_mode (required)
     * @param setpointEndtime When using the manual or max setpoint_mode, this parameter defines when the setpoint expires. (optional)
     * @param setpointTemp When using the manual setpoint_mode, this parameter defines the temperature setpoint (in Celcius) to use. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call setthermpointAsync(String deviceId, String moduleId, String setpointMode, Integer setpointEndtime, Float setpointTemp, final ApiCallback<NAOkResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = setthermpointValidateBeforeCall(deviceId, moduleId, setpointMode, setpointEndtime, setpointTemp, _callback);
        Type localVarReturnType = new TypeToken<NAOkResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for switchschedule
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param scheduleId The schedule id. It can be found in the getthermstate response, under the keys &#x60;therm_program_backup&#x60; and &#x60;therm_program&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call switchscheduleCall(String deviceId, String moduleId, String scheduleId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/switchschedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("device_id", deviceId));
        }

        if (moduleId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("module_id", moduleId));
        }

        if (scheduleId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("schedule_id", scheduleId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "code_oauth", "password_oauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call switchscheduleValidateBeforeCall(String deviceId, String moduleId, String scheduleId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deviceId' is set
        if (deviceId == null) {
            throw new ApiException("Missing the required parameter 'deviceId' when calling switchschedule(Async)");
        }

        // verify the required parameter 'moduleId' is set
        if (moduleId == null) {
            throw new ApiException("Missing the required parameter 'moduleId' when calling switchschedule(Async)");
        }

        // verify the required parameter 'scheduleId' is set
        if (scheduleId == null) {
            throw new ApiException("Missing the required parameter 'scheduleId' when calling switchschedule(Async)");
        }

        return switchscheduleCall(deviceId, moduleId, scheduleId, _callback);

    }

    /**
     * 
     * The method switchschedule switches the Thermostat&#39;s schedule to another existing schedule.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param scheduleId The schedule id. It can be found in the getthermstate response, under the keys &#x60;therm_program_backup&#x60; and &#x60;therm_program&#x60;.  (required)
     * @return NAOkResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public NAOkResponse switchschedule(String deviceId, String moduleId, String scheduleId) throws ApiException {
        ApiResponse<NAOkResponse> localVarResp = switchscheduleWithHttpInfo(deviceId, moduleId, scheduleId);
        return localVarResp.getData();
    }

    /**
     * 
     * The method switchschedule switches the Thermostat&#39;s schedule to another existing schedule.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param scheduleId The schedule id. It can be found in the getthermstate response, under the keys &#x60;therm_program_backup&#x60; and &#x60;therm_program&#x60;.  (required)
     * @return ApiResponse&lt;NAOkResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NAOkResponse> switchscheduleWithHttpInfo(String deviceId, String moduleId, String scheduleId) throws ApiException {
        okhttp3.Call localVarCall = switchscheduleValidateBeforeCall(deviceId, moduleId, scheduleId, null);
        Type localVarReturnType = new TypeToken<NAOkResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * The method switchschedule switches the Thermostat&#39;s schedule to another existing schedule.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param scheduleId The schedule id. It can be found in the getthermstate response, under the keys &#x60;therm_program_backup&#x60; and &#x60;therm_program&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call switchscheduleAsync(String deviceId, String moduleId, String scheduleId, final ApiCallback<NAOkResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = switchscheduleValidateBeforeCall(deviceId, moduleId, scheduleId, _callback);
        Type localVarReturnType = new TypeToken<NAOkResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for syncschedule
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param naThermProgram The thermostat program (zones, timetable and name) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call syncscheduleCall(String deviceId, String moduleId, NAThermProgram naThermProgram, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = naThermProgram;

        // create path and map variables
        String localVarPath = "/syncschedule";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deviceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("device_id", deviceId));
        }

        if (moduleId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("module_id", moduleId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "code_oauth", "password_oauth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call syncscheduleValidateBeforeCall(String deviceId, String moduleId, NAThermProgram naThermProgram, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deviceId' is set
        if (deviceId == null) {
            throw new ApiException("Missing the required parameter 'deviceId' when calling syncschedule(Async)");
        }

        // verify the required parameter 'moduleId' is set
        if (moduleId == null) {
            throw new ApiException("Missing the required parameter 'moduleId' when calling syncschedule(Async)");
        }

        // verify the required parameter 'naThermProgram' is set
        if (naThermProgram == null) {
            throw new ApiException("Missing the required parameter 'naThermProgram' when calling syncschedule(Async)");
        }

        return syncscheduleCall(deviceId, moduleId, naThermProgram, _callback);

    }

    /**
     * 
     * The method syncschedule changes the Thermostat weekly schedule.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param naThermProgram The thermostat program (zones, timetable and name) (required)
     * @return NAOkResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public NAOkResponse syncschedule(String deviceId, String moduleId, NAThermProgram naThermProgram) throws ApiException {
        ApiResponse<NAOkResponse> localVarResp = syncscheduleWithHttpInfo(deviceId, moduleId, naThermProgram);
        return localVarResp.getData();
    }

    /**
     * 
     * The method syncschedule changes the Thermostat weekly schedule.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param naThermProgram The thermostat program (zones, timetable and name) (required)
     * @return ApiResponse&lt;NAOkResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NAOkResponse> syncscheduleWithHttpInfo(String deviceId, String moduleId, NAThermProgram naThermProgram) throws ApiException {
        okhttp3.Call localVarCall = syncscheduleValidateBeforeCall(deviceId, moduleId, naThermProgram, null);
        Type localVarReturnType = new TypeToken<NAOkResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * The method syncschedule changes the Thermostat weekly schedule.
     * @param deviceId The relay id (required)
     * @param moduleId The thermostat id (required)
     * @param naThermProgram The thermostat program (zones, timetable and name) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call syncscheduleAsync(String deviceId, String moduleId, NAThermProgram naThermProgram, final ApiCallback<NAOkResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = syncscheduleValidateBeforeCall(deviceId, moduleId, naThermProgram, _callback);
        Type localVarReturnType = new TypeToken<NAOkResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
