/*
 * Netatmo
 * <h3>Welcome to the Netatmo swagger on-line documentation !</h3> This site is a complement to the official <a href=\"https://dev.netatmo.com/\">Netatmo developper documentation</a> using swagger to bring interactivity and easy testing of requests with the \"try it\" button (authenticate with the authorization code OAuth2 flow by clicking the authenticate button in the methods). You can find the source code for this site can be found in the project <a href=\"https://github.com/cbornet/netatmo-swagger-ui\">netatmo-swagger-ui</a>. You can also use the online <a href=\"./swagger.json\">swagger declaration</a> file to generate code or static documentation (see <a href=\"https://github.com/cbornet/netatmo-swagger-api\">netatmo-swagger-api</a>). 
 *
 * The version of the OpenAPI document: 1.1.5
 * Contact: contact-api@netatmo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * NAStation
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:19:42.898640-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NAStation {
  public static final String SERIALIZED_NAME_LAG_DOWN = "lag_down";
  @SerializedName(SERIALIZED_NAME_LAG_DOWN)
  private Integer lagDown;

  public static final String SERIALIZED_NAME_LAG_UP = "lag_up";
  @SerializedName(SERIALIZED_NAME_LAG_UP)
  private Integer lagUp;

  public static final String SERIALIZED_NAME_OFF_OVERSHOOT = "off_overshoot";
  @SerializedName(SERIALIZED_NAME_OFF_OVERSHOOT)
  private Float offOvershoot;

  public static final String SERIALIZED_NAME_ON_OVERSHOOT = "on_overshoot";
  @SerializedName(SERIALIZED_NAME_ON_OVERSHOOT)
  private Float onOvershoot;

  public static final String SERIALIZED_NAME_PK = "pk";
  @SerializedName(SERIALIZED_NAME_PK)
  private Integer pk;

  public static final String SERIALIZED_NAME_TAU = "tau";
  @SerializedName(SERIALIZED_NAME_TAU)
  private Integer tau;

  public NAStation() {
  }

  public NAStation lagDown(Integer lagDown) {
    this.lagDown = lagDown;
    return this;
  }

  /**
   * Get lagDown
   * @return lagDown
   */
  @javax.annotation.Nullable
  public Integer getLagDown() {
    return lagDown;
  }

  public void setLagDown(Integer lagDown) {
    this.lagDown = lagDown;
  }


  public NAStation lagUp(Integer lagUp) {
    this.lagUp = lagUp;
    return this;
  }

  /**
   * Get lagUp
   * @return lagUp
   */
  @javax.annotation.Nullable
  public Integer getLagUp() {
    return lagUp;
  }

  public void setLagUp(Integer lagUp) {
    this.lagUp = lagUp;
  }


  public NAStation offOvershoot(Float offOvershoot) {
    this.offOvershoot = offOvershoot;
    return this;
  }

  /**
   * Get offOvershoot
   * @return offOvershoot
   */
  @javax.annotation.Nullable
  public Float getOffOvershoot() {
    return offOvershoot;
  }

  public void setOffOvershoot(Float offOvershoot) {
    this.offOvershoot = offOvershoot;
  }


  public NAStation onOvershoot(Float onOvershoot) {
    this.onOvershoot = onOvershoot;
    return this;
  }

  /**
   * Get onOvershoot
   * @return onOvershoot
   */
  @javax.annotation.Nullable
  public Float getOnOvershoot() {
    return onOvershoot;
  }

  public void setOnOvershoot(Float onOvershoot) {
    this.onOvershoot = onOvershoot;
  }


  public NAStation pk(Integer pk) {
    this.pk = pk;
    return this;
  }

  /**
   * Get pk
   * @return pk
   */
  @javax.annotation.Nullable
  public Integer getPk() {
    return pk;
  }

  public void setPk(Integer pk) {
    this.pk = pk;
  }


  public NAStation tau(Integer tau) {
    this.tau = tau;
    return this;
  }

  /**
   * Get tau
   * @return tau
   */
  @javax.annotation.Nullable
  public Integer getTau() {
    return tau;
  }

  public void setTau(Integer tau) {
    this.tau = tau;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NAStation naStation = (NAStation) o;
    return Objects.equals(this.lagDown, naStation.lagDown) &&
        Objects.equals(this.lagUp, naStation.lagUp) &&
        Objects.equals(this.offOvershoot, naStation.offOvershoot) &&
        Objects.equals(this.onOvershoot, naStation.onOvershoot) &&
        Objects.equals(this.pk, naStation.pk) &&
        Objects.equals(this.tau, naStation.tau);
  }

  @Override
  public int hashCode() {
    return Objects.hash(lagDown, lagUp, offOvershoot, onOvershoot, pk, tau);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NAStation {\n");
    sb.append("    lagDown: ").append(toIndentedString(lagDown)).append("\n");
    sb.append("    lagUp: ").append(toIndentedString(lagUp)).append("\n");
    sb.append("    offOvershoot: ").append(toIndentedString(offOvershoot)).append("\n");
    sb.append("    onOvershoot: ").append(toIndentedString(onOvershoot)).append("\n");
    sb.append("    pk: ").append(toIndentedString(pk)).append("\n");
    sb.append("    tau: ").append(toIndentedString(tau)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("lag_down");
    openapiFields.add("lag_up");
    openapiFields.add("off_overshoot");
    openapiFields.add("on_overshoot");
    openapiFields.add("pk");
    openapiFields.add("tau");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NAStation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NAStation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NAStation is not found in the empty JSON string", NAStation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NAStation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NAStation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NAStation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NAStation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NAStation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NAStation.class));

       return (TypeAdapter<T>) new TypeAdapter<NAStation>() {
           @Override
           public void write(JsonWriter out, NAStation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NAStation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NAStation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NAStation
   * @throws IOException if the JSON string is invalid with respect to NAStation
   */
  public static NAStation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NAStation.class);
  }

  /**
   * Convert an instance of NAStation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

