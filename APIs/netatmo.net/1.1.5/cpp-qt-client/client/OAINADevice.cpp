/**
 * Netatmo
 * <h3>Welcome to the Netatmo swagger on-line documentation !</h3> This site is a complement to the official <a href=\"https://dev.netatmo.com/\">Netatmo developper documentation</a> using swagger to bring interactivity and easy testing of requests with the \"try it\" button (authenticate with the authorization code OAuth2 flow by clicking the authenticate button in the methods). You can find the source code for this site can be found in the project <a href=\"https://github.com/cbornet/netatmo-swagger-ui\">netatmo-swagger-ui</a>. You can also use the online <a href=\"./swagger.json\">swagger declaration</a> file to generate code or static documentation (see <a href=\"https://github.com/cbornet/netatmo-swagger-api\">netatmo-swagger-api</a>). 
 *
 * The version of the OpenAPI document: 1.1.5
 * Contact: contact-api@netatmo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINADevice.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINADevice::OAINADevice(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINADevice::OAINADevice() {
    this->initializeModel();
}

OAINADevice::~OAINADevice() {}

void OAINADevice::initializeModel() {

    m__id_isSet = false;
    m__id_isValid = false;

    m_behavior_isSet = false;
    m_behavior_isValid = false;

    m_cipher_id_isSet = false;
    m_cipher_id_isValid = false;

    m_dashboard_data_isSet = false;
    m_dashboard_data_isValid = false;

    m_data_type_isSet = false;
    m_data_type_isValid = false;

    m_date_setup_isSet = false;
    m_date_setup_isValid = false;

    m_firmware_isSet = false;
    m_firmware_isValid = false;

    m_first_pid_avail_isSet = false;
    m_first_pid_avail_isValid = false;

    m_heating_system_isSet = false;
    m_heating_system_isValid = false;

    m_house_model_isSet = false;
    m_house_model_isValid = false;

    m_hw_version_isSet = false;
    m_hw_version_isValid = false;

    m_ip_isSet = false;
    m_ip_isValid = false;

    m_last_fw_update_isSet = false;
    m_last_fw_update_isValid = false;

    m_last_radio_store_isSet = false;
    m_last_radio_store_isValid = false;

    m_last_status_store_isSet = false;
    m_last_status_store_isValid = false;

    m_last_upgrade_isSet = false;
    m_last_upgrade_isValid = false;

    m_module_name_isSet = false;
    m_module_name_isValid = false;

    m_modules_isSet = false;
    m_modules_isValid = false;

    m_new_feature_avail_isSet = false;
    m_new_feature_avail_isValid = false;

    m_place_isSet = false;
    m_place_isValid = false;

    m_public_ext_data_isSet = false;
    m_public_ext_data_isValid = false;

    m_setpoint_isSet = false;
    m_setpoint_isValid = false;

    m_setpoint_default_duration_isSet = false;
    m_setpoint_default_duration_isValid = false;

    m_setpoint_order_isSet = false;
    m_setpoint_order_isValid = false;

    m_station_name_isSet = false;
    m_station_name_isValid = false;

    m_therm_program_isSet = false;
    m_therm_program_isValid = false;

    m_therm_program_backup_isSet = false;
    m_therm_program_backup_isValid = false;

    m_therm_program_order_isSet = false;
    m_therm_program_order_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_udp_conn_isSet = false;
    m_udp_conn_isValid = false;

    m_user_owner_isSet = false;
    m_user_owner_isValid = false;

    m_wifi_status_isSet = false;
    m_wifi_status_isValid = false;
}

void OAINADevice::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINADevice::fromJsonObject(QJsonObject json) {

    m__id_isValid = ::OpenAPI::fromJsonValue(m__id, json[QString("_id")]);
    m__id_isSet = !json[QString("_id")].isNull() && m__id_isValid;

    m_behavior_isValid = ::OpenAPI::fromJsonValue(m_behavior, json[QString("behavior")]);
    m_behavior_isSet = !json[QString("behavior")].isNull() && m_behavior_isValid;

    m_cipher_id_isValid = ::OpenAPI::fromJsonValue(m_cipher_id, json[QString("cipher_id")]);
    m_cipher_id_isSet = !json[QString("cipher_id")].isNull() && m_cipher_id_isValid;

    m_dashboard_data_isValid = ::OpenAPI::fromJsonValue(m_dashboard_data, json[QString("dashboard_data")]);
    m_dashboard_data_isSet = !json[QString("dashboard_data")].isNull() && m_dashboard_data_isValid;

    m_data_type_isValid = ::OpenAPI::fromJsonValue(m_data_type, json[QString("data_type")]);
    m_data_type_isSet = !json[QString("data_type")].isNull() && m_data_type_isValid;

    m_date_setup_isValid = ::OpenAPI::fromJsonValue(m_date_setup, json[QString("date_setup")]);
    m_date_setup_isSet = !json[QString("date_setup")].isNull() && m_date_setup_isValid;

    m_firmware_isValid = ::OpenAPI::fromJsonValue(m_firmware, json[QString("firmware")]);
    m_firmware_isSet = !json[QString("firmware")].isNull() && m_firmware_isValid;

    m_first_pid_avail_isValid = ::OpenAPI::fromJsonValue(m_first_pid_avail, json[QString("first_pid_avail")]);
    m_first_pid_avail_isSet = !json[QString("first_pid_avail")].isNull() && m_first_pid_avail_isValid;

    m_heating_system_isValid = ::OpenAPI::fromJsonValue(m_heating_system, json[QString("heating_system")]);
    m_heating_system_isSet = !json[QString("heating_system")].isNull() && m_heating_system_isValid;

    m_house_model_isValid = ::OpenAPI::fromJsonValue(m_house_model, json[QString("house_model")]);
    m_house_model_isSet = !json[QString("house_model")].isNull() && m_house_model_isValid;

    m_hw_version_isValid = ::OpenAPI::fromJsonValue(m_hw_version, json[QString("hw_version")]);
    m_hw_version_isSet = !json[QString("hw_version")].isNull() && m_hw_version_isValid;

    m_ip_isValid = ::OpenAPI::fromJsonValue(m_ip, json[QString("ip")]);
    m_ip_isSet = !json[QString("ip")].isNull() && m_ip_isValid;

    m_last_fw_update_isValid = ::OpenAPI::fromJsonValue(m_last_fw_update, json[QString("last_fw_update")]);
    m_last_fw_update_isSet = !json[QString("last_fw_update")].isNull() && m_last_fw_update_isValid;

    m_last_radio_store_isValid = ::OpenAPI::fromJsonValue(m_last_radio_store, json[QString("last_radio_store")]);
    m_last_radio_store_isSet = !json[QString("last_radio_store")].isNull() && m_last_radio_store_isValid;

    m_last_status_store_isValid = ::OpenAPI::fromJsonValue(m_last_status_store, json[QString("last_status_store")]);
    m_last_status_store_isSet = !json[QString("last_status_store")].isNull() && m_last_status_store_isValid;

    m_last_upgrade_isValid = ::OpenAPI::fromJsonValue(m_last_upgrade, json[QString("last_upgrade")]);
    m_last_upgrade_isSet = !json[QString("last_upgrade")].isNull() && m_last_upgrade_isValid;

    m_module_name_isValid = ::OpenAPI::fromJsonValue(m_module_name, json[QString("module_name")]);
    m_module_name_isSet = !json[QString("module_name")].isNull() && m_module_name_isValid;

    m_modules_isValid = ::OpenAPI::fromJsonValue(m_modules, json[QString("modules")]);
    m_modules_isSet = !json[QString("modules")].isNull() && m_modules_isValid;

    m_new_feature_avail_isValid = ::OpenAPI::fromJsonValue(m_new_feature_avail, json[QString("new_feature_avail")]);
    m_new_feature_avail_isSet = !json[QString("new_feature_avail")].isNull() && m_new_feature_avail_isValid;

    m_place_isValid = ::OpenAPI::fromJsonValue(m_place, json[QString("place")]);
    m_place_isSet = !json[QString("place")].isNull() && m_place_isValid;

    m_public_ext_data_isValid = ::OpenAPI::fromJsonValue(m_public_ext_data, json[QString("public_ext_data")]);
    m_public_ext_data_isSet = !json[QString("public_ext_data")].isNull() && m_public_ext_data_isValid;

    m_setpoint_isValid = ::OpenAPI::fromJsonValue(m_setpoint, json[QString("setpoint")]);
    m_setpoint_isSet = !json[QString("setpoint")].isNull() && m_setpoint_isValid;

    m_setpoint_default_duration_isValid = ::OpenAPI::fromJsonValue(m_setpoint_default_duration, json[QString("setpoint_default_duration")]);
    m_setpoint_default_duration_isSet = !json[QString("setpoint_default_duration")].isNull() && m_setpoint_default_duration_isValid;

    if(json["setpoint_order"].isObject()){
        auto varmap = json["setpoint_order"].toObject().toVariantMap();
        m_setpoint_order_isValid = true;
        if(varmap.count() > 0){
            for(auto val : varmap.keys()){
                QList<OAINAObject> item;
                auto jval = QJsonValue::fromVariant(varmap.value(val));
                m_setpoint_order_isValid &= ::OpenAPI::fromJsonValue(item, jval);
                m_setpoint_order_isSet &= !jval.isNull() && m_setpoint_order_isValid;
                m_setpoint_order.insert(m_setpoint_order.end(), val, item);
            }
        }
    }

    m_station_name_isValid = ::OpenAPI::fromJsonValue(m_station_name, json[QString("station_name")]);
    m_station_name_isSet = !json[QString("station_name")].isNull() && m_station_name_isValid;

    m_therm_program_isValid = ::OpenAPI::fromJsonValue(m_therm_program, json[QString("therm_program")]);
    m_therm_program_isSet = !json[QString("therm_program")].isNull() && m_therm_program_isValid;

    if(json["therm_program_backup"].isObject()){
        auto varmap = json["therm_program_backup"].toObject().toVariantMap();
        m_therm_program_backup_isValid = true;
        if(varmap.count() > 0){
            for(auto val : varmap.keys()){
                QList<OAINAThermProgram> item;
                auto jval = QJsonValue::fromVariant(varmap.value(val));
                m_therm_program_backup_isValid &= ::OpenAPI::fromJsonValue(item, jval);
                m_therm_program_backup_isSet &= !jval.isNull() && m_therm_program_backup_isValid;
                m_therm_program_backup.insert(m_therm_program_backup.end(), val, item);
            }
        }
    }

    if(json["therm_program_order"].isObject()){
        auto varmap = json["therm_program_order"].toObject().toVariantMap();
        m_therm_program_order_isValid = true;
        if(varmap.count() > 0){
            for(auto val : varmap.keys()){
                QList<OAINAObject> item;
                auto jval = QJsonValue::fromVariant(varmap.value(val));
                m_therm_program_order_isValid &= ::OpenAPI::fromJsonValue(item, jval);
                m_therm_program_order_isSet &= !jval.isNull() && m_therm_program_order_isValid;
                m_therm_program_order.insert(m_therm_program_order.end(), val, item);
            }
        }
    }

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_udp_conn_isValid = ::OpenAPI::fromJsonValue(m_udp_conn, json[QString("udp_conn")]);
    m_udp_conn_isSet = !json[QString("udp_conn")].isNull() && m_udp_conn_isValid;

    m_user_owner_isValid = ::OpenAPI::fromJsonValue(m_user_owner, json[QString("user_owner")]);
    m_user_owner_isSet = !json[QString("user_owner")].isNull() && m_user_owner_isValid;

    m_wifi_status_isValid = ::OpenAPI::fromJsonValue(m_wifi_status, json[QString("wifi_status")]);
    m_wifi_status_isSet = !json[QString("wifi_status")].isNull() && m_wifi_status_isValid;
}

QString OAINADevice::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINADevice::asJsonObject() const {
    QJsonObject obj;
    if (m__id_isSet) {
        obj.insert(QString("_id"), ::OpenAPI::toJsonValue(m__id));
    }
    if (m_behavior_isSet) {
        obj.insert(QString("behavior"), ::OpenAPI::toJsonValue(m_behavior));
    }
    if (m_cipher_id_isSet) {
        obj.insert(QString("cipher_id"), ::OpenAPI::toJsonValue(m_cipher_id));
    }
    if (m_dashboard_data.isSet()) {
        obj.insert(QString("dashboard_data"), ::OpenAPI::toJsonValue(m_dashboard_data));
    }
    if (m_data_type.size() > 0) {
        obj.insert(QString("data_type"), ::OpenAPI::toJsonValue(m_data_type));
    }
    if (m_date_setup.isSet()) {
        obj.insert(QString("date_setup"), ::OpenAPI::toJsonValue(m_date_setup));
    }
    if (m_firmware_isSet) {
        obj.insert(QString("firmware"), ::OpenAPI::toJsonValue(m_firmware));
    }
    if (m_first_pid_avail_isSet) {
        obj.insert(QString("first_pid_avail"), ::OpenAPI::toJsonValue(m_first_pid_avail));
    }
    if (m_heating_system.isSet()) {
        obj.insert(QString("heating_system"), ::OpenAPI::toJsonValue(m_heating_system));
    }
    if (m_house_model.isSet()) {
        obj.insert(QString("house_model"), ::OpenAPI::toJsonValue(m_house_model));
    }
    if (m_hw_version_isSet) {
        obj.insert(QString("hw_version"), ::OpenAPI::toJsonValue(m_hw_version));
    }
    if (m_ip_isSet) {
        obj.insert(QString("ip"), ::OpenAPI::toJsonValue(m_ip));
    }
    if (m_last_fw_update_isSet) {
        obj.insert(QString("last_fw_update"), ::OpenAPI::toJsonValue(m_last_fw_update));
    }
    if (m_last_radio_store_isSet) {
        obj.insert(QString("last_radio_store"), ::OpenAPI::toJsonValue(m_last_radio_store));
    }
    if (m_last_status_store_isSet) {
        obj.insert(QString("last_status_store"), ::OpenAPI::toJsonValue(m_last_status_store));
    }
    if (m_last_upgrade_isSet) {
        obj.insert(QString("last_upgrade"), ::OpenAPI::toJsonValue(m_last_upgrade));
    }
    if (m_module_name_isSet) {
        obj.insert(QString("module_name"), ::OpenAPI::toJsonValue(m_module_name));
    }
    if (m_modules.size() > 0) {
        obj.insert(QString("modules"), ::OpenAPI::toJsonValue(m_modules));
    }
    if (m_new_feature_avail_isSet) {
        obj.insert(QString("new_feature_avail"), ::OpenAPI::toJsonValue(m_new_feature_avail));
    }
    if (m_place.isSet()) {
        obj.insert(QString("place"), ::OpenAPI::toJsonValue(m_place));
    }
    if (m_public_ext_data_isSet) {
        obj.insert(QString("public_ext_data"), ::OpenAPI::toJsonValue(m_public_ext_data));
    }
    if (m_setpoint_isSet) {
        obj.insert(QString("setpoint"), ::OpenAPI::toJsonValue(m_setpoint));
    }
    if (m_setpoint_default_duration_isSet) {
        obj.insert(QString("setpoint_default_duration"), ::OpenAPI::toJsonValue(m_setpoint_default_duration));
    }
    if (m_setpoint_order.size() > 0) {
        
        obj.insert(QString("setpoint_order"), toJsonValue(m_setpoint_order));
    }
    if (m_station_name_isSet) {
        obj.insert(QString("station_name"), ::OpenAPI::toJsonValue(m_station_name));
    }
    if (m_therm_program.size() > 0) {
        obj.insert(QString("therm_program"), ::OpenAPI::toJsonValue(m_therm_program));
    }
    if (m_therm_program_backup.size() > 0) {
        
        obj.insert(QString("therm_program_backup"), toJsonValue(m_therm_program_backup));
    }
    if (m_therm_program_order.size() > 0) {
        
        obj.insert(QString("therm_program_order"), toJsonValue(m_therm_program_order));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_udp_conn_isSet) {
        obj.insert(QString("udp_conn"), ::OpenAPI::toJsonValue(m_udp_conn));
    }
    if (m_user_owner.size() > 0) {
        obj.insert(QString("user_owner"), ::OpenAPI::toJsonValue(m_user_owner));
    }
    if (m_wifi_status_isSet) {
        obj.insert(QString("wifi_status"), ::OpenAPI::toJsonValue(m_wifi_status));
    }
    return obj;
}

QString OAINADevice::getId() const {
    return m__id;
}
void OAINADevice::setId(const QString &_id) {
    m__id = _id;
    m__id_isSet = true;
}

bool OAINADevice::is__id_Set() const{
    return m__id_isSet;
}

bool OAINADevice::is__id_Valid() const{
    return m__id_isValid;
}

qint32 OAINADevice::getBehavior() const {
    return m_behavior;
}
void OAINADevice::setBehavior(const qint32 &behavior) {
    m_behavior = behavior;
    m_behavior_isSet = true;
}

bool OAINADevice::is_behavior_Set() const{
    return m_behavior_isSet;
}

bool OAINADevice::is_behavior_Valid() const{
    return m_behavior_isValid;
}

QString OAINADevice::getCipherId() const {
    return m_cipher_id;
}
void OAINADevice::setCipherId(const QString &cipher_id) {
    m_cipher_id = cipher_id;
    m_cipher_id_isSet = true;
}

bool OAINADevice::is_cipher_id_Set() const{
    return m_cipher_id_isSet;
}

bool OAINADevice::is_cipher_id_Valid() const{
    return m_cipher_id_isValid;
}

OAINADashboardData OAINADevice::getDashboardData() const {
    return m_dashboard_data;
}
void OAINADevice::setDashboardData(const OAINADashboardData &dashboard_data) {
    m_dashboard_data = dashboard_data;
    m_dashboard_data_isSet = true;
}

bool OAINADevice::is_dashboard_data_Set() const{
    return m_dashboard_data_isSet;
}

bool OAINADevice::is_dashboard_data_Valid() const{
    return m_dashboard_data_isValid;
}

QList<QString> OAINADevice::getDataType() const {
    return m_data_type;
}
void OAINADevice::setDataType(const QList<QString> &data_type) {
    m_data_type = data_type;
    m_data_type_isSet = true;
}

bool OAINADevice::is_data_type_Set() const{
    return m_data_type_isSet;
}

bool OAINADevice::is_data_type_Valid() const{
    return m_data_type_isValid;
}

OAINADate OAINADevice::getDateSetup() const {
    return m_date_setup;
}
void OAINADevice::setDateSetup(const OAINADate &date_setup) {
    m_date_setup = date_setup;
    m_date_setup_isSet = true;
}

bool OAINADevice::is_date_setup_Set() const{
    return m_date_setup_isSet;
}

bool OAINADevice::is_date_setup_Valid() const{
    return m_date_setup_isValid;
}

qint32 OAINADevice::getFirmware() const {
    return m_firmware;
}
void OAINADevice::setFirmware(const qint32 &firmware) {
    m_firmware = firmware;
    m_firmware_isSet = true;
}

bool OAINADevice::is_firmware_Set() const{
    return m_firmware_isSet;
}

bool OAINADevice::is_firmware_Valid() const{
    return m_firmware_isValid;
}

bool OAINADevice::isFirstPidAvail() const {
    return m_first_pid_avail;
}
void OAINADevice::setFirstPidAvail(const bool &first_pid_avail) {
    m_first_pid_avail = first_pid_avail;
    m_first_pid_avail_isSet = true;
}

bool OAINADevice::is_first_pid_avail_Set() const{
    return m_first_pid_avail_isSet;
}

bool OAINADevice::is_first_pid_avail_Valid() const{
    return m_first_pid_avail_isValid;
}

OAINAHeatingSystem OAINADevice::getHeatingSystem() const {
    return m_heating_system;
}
void OAINADevice::setHeatingSystem(const OAINAHeatingSystem &heating_system) {
    m_heating_system = heating_system;
    m_heating_system_isSet = true;
}

bool OAINADevice::is_heating_system_Set() const{
    return m_heating_system_isSet;
}

bool OAINADevice::is_heating_system_Valid() const{
    return m_heating_system_isValid;
}

OAINAHouseModel OAINADevice::getHouseModel() const {
    return m_house_model;
}
void OAINADevice::setHouseModel(const OAINAHouseModel &house_model) {
    m_house_model = house_model;
    m_house_model_isSet = true;
}

bool OAINADevice::is_house_model_Set() const{
    return m_house_model_isSet;
}

bool OAINADevice::is_house_model_Valid() const{
    return m_house_model_isValid;
}

qint32 OAINADevice::getHwVersion() const {
    return m_hw_version;
}
void OAINADevice::setHwVersion(const qint32 &hw_version) {
    m_hw_version = hw_version;
    m_hw_version_isSet = true;
}

bool OAINADevice::is_hw_version_Set() const{
    return m_hw_version_isSet;
}

bool OAINADevice::is_hw_version_Valid() const{
    return m_hw_version_isValid;
}

QString OAINADevice::getIp() const {
    return m_ip;
}
void OAINADevice::setIp(const QString &ip) {
    m_ip = ip;
    m_ip_isSet = true;
}

bool OAINADevice::is_ip_Set() const{
    return m_ip_isSet;
}

bool OAINADevice::is_ip_Valid() const{
    return m_ip_isValid;
}

qint32 OAINADevice::getLastFwUpdate() const {
    return m_last_fw_update;
}
void OAINADevice::setLastFwUpdate(const qint32 &last_fw_update) {
    m_last_fw_update = last_fw_update;
    m_last_fw_update_isSet = true;
}

bool OAINADevice::is_last_fw_update_Set() const{
    return m_last_fw_update_isSet;
}

bool OAINADevice::is_last_fw_update_Valid() const{
    return m_last_fw_update_isValid;
}

qint32 OAINADevice::getLastRadioStore() const {
    return m_last_radio_store;
}
void OAINADevice::setLastRadioStore(const qint32 &last_radio_store) {
    m_last_radio_store = last_radio_store;
    m_last_radio_store_isSet = true;
}

bool OAINADevice::is_last_radio_store_Set() const{
    return m_last_radio_store_isSet;
}

bool OAINADevice::is_last_radio_store_Valid() const{
    return m_last_radio_store_isValid;
}

qint32 OAINADevice::getLastStatusStore() const {
    return m_last_status_store;
}
void OAINADevice::setLastStatusStore(const qint32 &last_status_store) {
    m_last_status_store = last_status_store;
    m_last_status_store_isSet = true;
}

bool OAINADevice::is_last_status_store_Set() const{
    return m_last_status_store_isSet;
}

bool OAINADevice::is_last_status_store_Valid() const{
    return m_last_status_store_isValid;
}

qint32 OAINADevice::getLastUpgrade() const {
    return m_last_upgrade;
}
void OAINADevice::setLastUpgrade(const qint32 &last_upgrade) {
    m_last_upgrade = last_upgrade;
    m_last_upgrade_isSet = true;
}

bool OAINADevice::is_last_upgrade_Set() const{
    return m_last_upgrade_isSet;
}

bool OAINADevice::is_last_upgrade_Valid() const{
    return m_last_upgrade_isValid;
}

QString OAINADevice::getModuleName() const {
    return m_module_name;
}
void OAINADevice::setModuleName(const QString &module_name) {
    m_module_name = module_name;
    m_module_name_isSet = true;
}

bool OAINADevice::is_module_name_Set() const{
    return m_module_name_isSet;
}

bool OAINADevice::is_module_name_Valid() const{
    return m_module_name_isValid;
}

QList<QString> OAINADevice::getModules() const {
    return m_modules;
}
void OAINADevice::setModules(const QList<QString> &modules) {
    m_modules = modules;
    m_modules_isSet = true;
}

bool OAINADevice::is_modules_Set() const{
    return m_modules_isSet;
}

bool OAINADevice::is_modules_Valid() const{
    return m_modules_isValid;
}

bool OAINADevice::isNewFeatureAvail() const {
    return m_new_feature_avail;
}
void OAINADevice::setNewFeatureAvail(const bool &new_feature_avail) {
    m_new_feature_avail = new_feature_avail;
    m_new_feature_avail_isSet = true;
}

bool OAINADevice::is_new_feature_avail_Set() const{
    return m_new_feature_avail_isSet;
}

bool OAINADevice::is_new_feature_avail_Valid() const{
    return m_new_feature_avail_isValid;
}

OAINAPlace OAINADevice::getPlace() const {
    return m_place;
}
void OAINADevice::setPlace(const OAINAPlace &place) {
    m_place = place;
    m_place_isSet = true;
}

bool OAINADevice::is_place_Set() const{
    return m_place_isSet;
}

bool OAINADevice::is_place_Valid() const{
    return m_place_isValid;
}

bool OAINADevice::isPublicExtData() const {
    return m_public_ext_data;
}
void OAINADevice::setPublicExtData(const bool &public_ext_data) {
    m_public_ext_data = public_ext_data;
    m_public_ext_data_isSet = true;
}

bool OAINADevice::is_public_ext_data_Set() const{
    return m_public_ext_data_isSet;
}

bool OAINADevice::is_public_ext_data_Valid() const{
    return m_public_ext_data_isValid;
}

OAIObject OAINADevice::getSetpoint() const {
    return m_setpoint;
}
void OAINADevice::setSetpoint(const OAIObject &setpoint) {
    m_setpoint = setpoint;
    m_setpoint_isSet = true;
}

bool OAINADevice::is_setpoint_Set() const{
    return m_setpoint_isSet;
}

bool OAINADevice::is_setpoint_Valid() const{
    return m_setpoint_isValid;
}

qint32 OAINADevice::getSetpointDefaultDuration() const {
    return m_setpoint_default_duration;
}
void OAINADevice::setSetpointDefaultDuration(const qint32 &setpoint_default_duration) {
    m_setpoint_default_duration = setpoint_default_duration;
    m_setpoint_default_duration_isSet = true;
}

bool OAINADevice::is_setpoint_default_duration_Set() const{
    return m_setpoint_default_duration_isSet;
}

bool OAINADevice::is_setpoint_default_duration_Valid() const{
    return m_setpoint_default_duration_isValid;
}

QMap<QString, QList<OAINAObject>> OAINADevice::getSetpointOrder() const {
    return m_setpoint_order;
}
void OAINADevice::setSetpointOrder(const QMap<QString, QList<OAINAObject>> &setpoint_order) {
    m_setpoint_order = setpoint_order;
    m_setpoint_order_isSet = true;
}

bool OAINADevice::is_setpoint_order_Set() const{
    return m_setpoint_order_isSet;
}

bool OAINADevice::is_setpoint_order_Valid() const{
    return m_setpoint_order_isValid;
}

QString OAINADevice::getStationName() const {
    return m_station_name;
}
void OAINADevice::setStationName(const QString &station_name) {
    m_station_name = station_name;
    m_station_name_isSet = true;
}

bool OAINADevice::is_station_name_Set() const{
    return m_station_name_isSet;
}

bool OAINADevice::is_station_name_Valid() const{
    return m_station_name_isValid;
}

QMap<QString, OAINAThermProgram> OAINADevice::getThermProgram() const {
    return m_therm_program;
}
void OAINADevice::setThermProgram(const QMap<QString, OAINAThermProgram> &therm_program) {
    m_therm_program = therm_program;
    m_therm_program_isSet = true;
}

bool OAINADevice::is_therm_program_Set() const{
    return m_therm_program_isSet;
}

bool OAINADevice::is_therm_program_Valid() const{
    return m_therm_program_isValid;
}

QMap<QString, QList<OAINAThermProgram>> OAINADevice::getThermProgramBackup() const {
    return m_therm_program_backup;
}
void OAINADevice::setThermProgramBackup(const QMap<QString, QList<OAINAThermProgram>> &therm_program_backup) {
    m_therm_program_backup = therm_program_backup;
    m_therm_program_backup_isSet = true;
}

bool OAINADevice::is_therm_program_backup_Set() const{
    return m_therm_program_backup_isSet;
}

bool OAINADevice::is_therm_program_backup_Valid() const{
    return m_therm_program_backup_isValid;
}

QMap<QString, QList<OAINAObject>> OAINADevice::getThermProgramOrder() const {
    return m_therm_program_order;
}
void OAINADevice::setThermProgramOrder(const QMap<QString, QList<OAINAObject>> &therm_program_order) {
    m_therm_program_order = therm_program_order;
    m_therm_program_order_isSet = true;
}

bool OAINADevice::is_therm_program_order_Set() const{
    return m_therm_program_order_isSet;
}

bool OAINADevice::is_therm_program_order_Valid() const{
    return m_therm_program_order_isValid;
}

QString OAINADevice::getType() const {
    return m_type;
}
void OAINADevice::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAINADevice::is_type_Set() const{
    return m_type_isSet;
}

bool OAINADevice::is_type_Valid() const{
    return m_type_isValid;
}

bool OAINADevice::isUdpConn() const {
    return m_udp_conn;
}
void OAINADevice::setUdpConn(const bool &udp_conn) {
    m_udp_conn = udp_conn;
    m_udp_conn_isSet = true;
}

bool OAINADevice::is_udp_conn_Set() const{
    return m_udp_conn_isSet;
}

bool OAINADevice::is_udp_conn_Valid() const{
    return m_udp_conn_isValid;
}

QList<QString> OAINADevice::getUserOwner() const {
    return m_user_owner;
}
void OAINADevice::setUserOwner(const QList<QString> &user_owner) {
    m_user_owner = user_owner;
    m_user_owner_isSet = true;
}

bool OAINADevice::is_user_owner_Set() const{
    return m_user_owner_isSet;
}

bool OAINADevice::is_user_owner_Valid() const{
    return m_user_owner_isValid;
}

qint32 OAINADevice::getWifiStatus() const {
    return m_wifi_status;
}
void OAINADevice::setWifiStatus(const qint32 &wifi_status) {
    m_wifi_status = wifi_status;
    m_wifi_status_isSet = true;
}

bool OAINADevice::is_wifi_status_Set() const{
    return m_wifi_status_isSet;
}

bool OAINADevice::is_wifi_status_Valid() const{
    return m_wifi_status_isValid;
}

bool OAINADevice::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m__id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_behavior_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cipher_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_dashboard_data.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_type.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_date_setup.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_firmware_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_first_pid_avail_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_heating_system.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_house_model.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_hw_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ip_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_fw_update_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_radio_store_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_status_store_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_upgrade_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_module_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_modules.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_new_feature_avail_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_place.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_public_ext_data_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_setpoint_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_setpoint_default_duration_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_setpoint_order.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_station_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_therm_program.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_therm_program_backup.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_therm_program_order.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_udp_conn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_owner.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_wifi_status_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINADevice::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
