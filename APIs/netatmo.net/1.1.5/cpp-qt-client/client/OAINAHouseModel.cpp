/**
 * Netatmo
 * <h3>Welcome to the Netatmo swagger on-line documentation !</h3> This site is a complement to the official <a href=\"https://dev.netatmo.com/\">Netatmo developper documentation</a> using swagger to bring interactivity and easy testing of requests with the \"try it\" button (authenticate with the authorization code OAuth2 flow by clicking the authenticate button in the methods). You can find the source code for this site can be found in the project <a href=\"https://github.com/cbornet/netatmo-swagger-ui\">netatmo-swagger-ui</a>. You can also use the online <a href=\"./swagger.json\">swagger declaration</a> file to generate code or static documentation (see <a href=\"https://github.com/cbornet/netatmo-swagger-api\">netatmo-swagger-api</a>). 
 *
 * The version of the OpenAPI document: 1.1.5
 * Contact: contact-api@netatmo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINAHouseModel.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINAHouseModel::OAINAHouseModel(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINAHouseModel::OAINAHouseModel() {
    this->initializeModel();
}

OAINAHouseModel::~OAINAHouseModel() {}

void OAINAHouseModel::initializeModel() {

    m_algo_type_isSet = false;
    m_algo_type_isValid = false;

    m_ca_isSet = false;
    m_ca_isValid = false;

    m_ext_temps_isSet = false;
    m_ext_temps_isValid = false;

    m_first_anticipate_avail_isSet = false;
    m_first_anticipate_avail_isValid = false;

    m_first_pid_avail_isSet = false;
    m_first_pid_avail_isValid = false;

    m_gefs_isSet = false;
    m_gefs_isValid = false;

    m_in_use_isSet = false;
    m_in_use_isValid = false;

    m_last_compute_try_isSet = false;
    m_last_compute_try_isValid = false;

    m_link_station_isSet = false;
    m_link_station_isValid = false;

    m_pid_algo_isSet = false;
    m_pid_algo_isValid = false;

    m_prefered_algo_type_isSet = false;
    m_prefered_algo_type_isValid = false;

    m_simple_algo_isSet = false;
    m_simple_algo_isValid = false;

    m_station_isSet = false;
    m_station_isValid = false;

    m_station_firsttime_anticipate_isSet = false;
    m_station_firsttime_anticipate_isValid = false;

    m_time_isSet = false;
    m_time_isValid = false;

    m_time_algo_changed_isSet = false;
    m_time_algo_changed_isValid = false;

    m_time_pid_computed_isSet = false;
    m_time_pid_computed_isValid = false;
}

void OAINAHouseModel::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINAHouseModel::fromJsonObject(QJsonObject json) {

    m_algo_type_isValid = ::OpenAPI::fromJsonValue(m_algo_type, json[QString("algo_type")]);
    m_algo_type_isSet = !json[QString("algo_type")].isNull() && m_algo_type_isValid;

    m_ca_isValid = ::OpenAPI::fromJsonValue(m_ca, json[QString("ca")]);
    m_ca_isSet = !json[QString("ca")].isNull() && m_ca_isValid;

    m_ext_temps_isValid = ::OpenAPI::fromJsonValue(m_ext_temps, json[QString("ext_temps")]);
    m_ext_temps_isSet = !json[QString("ext_temps")].isNull() && m_ext_temps_isValid;

    m_first_anticipate_avail_isValid = ::OpenAPI::fromJsonValue(m_first_anticipate_avail, json[QString("first_anticipate_avail")]);
    m_first_anticipate_avail_isSet = !json[QString("first_anticipate_avail")].isNull() && m_first_anticipate_avail_isValid;

    m_first_pid_avail_isValid = ::OpenAPI::fromJsonValue(m_first_pid_avail, json[QString("first_pid_avail")]);
    m_first_pid_avail_isSet = !json[QString("first_pid_avail")].isNull() && m_first_pid_avail_isValid;

    m_gefs_isValid = ::OpenAPI::fromJsonValue(m_gefs, json[QString("gefs")]);
    m_gefs_isSet = !json[QString("gefs")].isNull() && m_gefs_isValid;

    m_in_use_isValid = ::OpenAPI::fromJsonValue(m_in_use, json[QString("in_use")]);
    m_in_use_isSet = !json[QString("in_use")].isNull() && m_in_use_isValid;

    m_last_compute_try_isValid = ::OpenAPI::fromJsonValue(m_last_compute_try, json[QString("last_compute_try")]);
    m_last_compute_try_isSet = !json[QString("last_compute_try")].isNull() && m_last_compute_try_isValid;

    m_link_station_isValid = ::OpenAPI::fromJsonValue(m_link_station, json[QString("link_station")]);
    m_link_station_isSet = !json[QString("link_station")].isNull() && m_link_station_isValid;

    m_pid_algo_isValid = ::OpenAPI::fromJsonValue(m_pid_algo, json[QString("pid_algo")]);
    m_pid_algo_isSet = !json[QString("pid_algo")].isNull() && m_pid_algo_isValid;

    m_prefered_algo_type_isValid = ::OpenAPI::fromJsonValue(m_prefered_algo_type, json[QString("prefered_algo_type")]);
    m_prefered_algo_type_isSet = !json[QString("prefered_algo_type")].isNull() && m_prefered_algo_type_isValid;

    m_simple_algo_isValid = ::OpenAPI::fromJsonValue(m_simple_algo, json[QString("simple_algo")]);
    m_simple_algo_isSet = !json[QString("simple_algo")].isNull() && m_simple_algo_isValid;

    m_station_isValid = ::OpenAPI::fromJsonValue(m_station, json[QString("station")]);
    m_station_isSet = !json[QString("station")].isNull() && m_station_isValid;

    m_station_firsttime_anticipate_isValid = ::OpenAPI::fromJsonValue(m_station_firsttime_anticipate, json[QString("station_firsttime_anticipate")]);
    m_station_firsttime_anticipate_isSet = !json[QString("station_firsttime_anticipate")].isNull() && m_station_firsttime_anticipate_isValid;

    m_time_isValid = ::OpenAPI::fromJsonValue(m_time, json[QString("time")]);
    m_time_isSet = !json[QString("time")].isNull() && m_time_isValid;

    m_time_algo_changed_isValid = ::OpenAPI::fromJsonValue(m_time_algo_changed, json[QString("time_algo_changed")]);
    m_time_algo_changed_isSet = !json[QString("time_algo_changed")].isNull() && m_time_algo_changed_isValid;

    m_time_pid_computed_isValid = ::OpenAPI::fromJsonValue(m_time_pid_computed, json[QString("time_pid_computed")]);
    m_time_pid_computed_isSet = !json[QString("time_pid_computed")].isNull() && m_time_pid_computed_isValid;
}

QString OAINAHouseModel::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINAHouseModel::asJsonObject() const {
    QJsonObject obj;
    if (m_algo_type_isSet) {
        obj.insert(QString("algo_type"), ::OpenAPI::toJsonValue(m_algo_type));
    }
    if (m_ca.isSet()) {
        obj.insert(QString("ca"), ::OpenAPI::toJsonValue(m_ca));
    }
    if (m_ext_temps.size() > 0) {
        obj.insert(QString("ext_temps"), ::OpenAPI::toJsonValue(m_ext_temps));
    }
    if (m_first_anticipate_avail_isSet) {
        obj.insert(QString("first_anticipate_avail"), ::OpenAPI::toJsonValue(m_first_anticipate_avail));
    }
    if (m_first_pid_avail_isSet) {
        obj.insert(QString("first_pid_avail"), ::OpenAPI::toJsonValue(m_first_pid_avail));
    }
    if (m_gefs.isSet()) {
        obj.insert(QString("gefs"), ::OpenAPI::toJsonValue(m_gefs));
    }
    if (m_in_use_isSet) {
        obj.insert(QString("in_use"), ::OpenAPI::toJsonValue(m_in_use));
    }
    if (m_last_compute_try.isSet()) {
        obj.insert(QString("last_compute_try"), ::OpenAPI::toJsonValue(m_last_compute_try));
    }
    if (m_link_station.isSet()) {
        obj.insert(QString("link_station"), ::OpenAPI::toJsonValue(m_link_station));
    }
    if (m_pid_algo.isSet()) {
        obj.insert(QString("pid_algo"), ::OpenAPI::toJsonValue(m_pid_algo));
    }
    if (m_prefered_algo_type_isSet) {
        obj.insert(QString("prefered_algo_type"), ::OpenAPI::toJsonValue(m_prefered_algo_type));
    }
    if (m_simple_algo.isSet()) {
        obj.insert(QString("simple_algo"), ::OpenAPI::toJsonValue(m_simple_algo));
    }
    if (m_station.isSet()) {
        obj.insert(QString("station"), ::OpenAPI::toJsonValue(m_station));
    }
    if (m_station_firsttime_anticipate_isSet) {
        obj.insert(QString("station_firsttime_anticipate"), ::OpenAPI::toJsonValue(m_station_firsttime_anticipate));
    }
    if (m_time.isSet()) {
        obj.insert(QString("time"), ::OpenAPI::toJsonValue(m_time));
    }
    if (m_time_algo_changed_isSet) {
        obj.insert(QString("time_algo_changed"), ::OpenAPI::toJsonValue(m_time_algo_changed));
    }
    if (m_time_pid_computed_isSet) {
        obj.insert(QString("time_pid_computed"), ::OpenAPI::toJsonValue(m_time_pid_computed));
    }
    return obj;
}

QString OAINAHouseModel::getAlgoType() const {
    return m_algo_type;
}
void OAINAHouseModel::setAlgoType(const QString &algo_type) {
    m_algo_type = algo_type;
    m_algo_type_isSet = true;
}

bool OAINAHouseModel::is_algo_type_Set() const{
    return m_algo_type_isSet;
}

bool OAINAHouseModel::is_algo_type_Valid() const{
    return m_algo_type_isValid;
}

OAINAHouseModelCa OAINAHouseModel::getCa() const {
    return m_ca;
}
void OAINAHouseModel::setCa(const OAINAHouseModelCa &ca) {
    m_ca = ca;
    m_ca_isSet = true;
}

bool OAINAHouseModel::is_ca_Set() const{
    return m_ca_isSet;
}

bool OAINAHouseModel::is_ca_Valid() const{
    return m_ca_isValid;
}

QMap<QString, qint32> OAINAHouseModel::getExtTemps() const {
    return m_ext_temps;
}
void OAINAHouseModel::setExtTemps(const QMap<QString, qint32> &ext_temps) {
    m_ext_temps = ext_temps;
    m_ext_temps_isSet = true;
}

bool OAINAHouseModel::is_ext_temps_Set() const{
    return m_ext_temps_isSet;
}

bool OAINAHouseModel::is_ext_temps_Valid() const{
    return m_ext_temps_isValid;
}

bool OAINAHouseModel::isFirstAnticipateAvail() const {
    return m_first_anticipate_avail;
}
void OAINAHouseModel::setFirstAnticipateAvail(const bool &first_anticipate_avail) {
    m_first_anticipate_avail = first_anticipate_avail;
    m_first_anticipate_avail_isSet = true;
}

bool OAINAHouseModel::is_first_anticipate_avail_Set() const{
    return m_first_anticipate_avail_isSet;
}

bool OAINAHouseModel::is_first_anticipate_avail_Valid() const{
    return m_first_anticipate_avail_isValid;
}

bool OAINAHouseModel::isFirstPidAvail() const {
    return m_first_pid_avail;
}
void OAINAHouseModel::setFirstPidAvail(const bool &first_pid_avail) {
    m_first_pid_avail = first_pid_avail;
    m_first_pid_avail_isSet = true;
}

bool OAINAHouseModel::is_first_pid_avail_Set() const{
    return m_first_pid_avail_isSet;
}

bool OAINAHouseModel::is_first_pid_avail_Valid() const{
    return m_first_pid_avail_isValid;
}

OAINAStation OAINAHouseModel::getGefs() const {
    return m_gefs;
}
void OAINAHouseModel::setGefs(const OAINAStation &gefs) {
    m_gefs = gefs;
    m_gefs_isSet = true;
}

bool OAINAHouseModel::is_gefs_Set() const{
    return m_gefs_isSet;
}

bool OAINAHouseModel::is_gefs_Valid() const{
    return m_gefs_isValid;
}

QString OAINAHouseModel::getInUse() const {
    return m_in_use;
}
void OAINAHouseModel::setInUse(const QString &in_use) {
    m_in_use = in_use;
    m_in_use_isSet = true;
}

bool OAINAHouseModel::is_in_use_Set() const{
    return m_in_use_isSet;
}

bool OAINAHouseModel::is_in_use_Valid() const{
    return m_in_use_isValid;
}

OAINADate OAINAHouseModel::getLastComputeTry() const {
    return m_last_compute_try;
}
void OAINAHouseModel::setLastComputeTry(const OAINADate &last_compute_try) {
    m_last_compute_try = last_compute_try;
    m_last_compute_try_isSet = true;
}

bool OAINAHouseModel::is_last_compute_try_Set() const{
    return m_last_compute_try_isSet;
}

bool OAINAHouseModel::is_last_compute_try_Valid() const{
    return m_last_compute_try_isValid;
}

OAINALinkStation OAINAHouseModel::getLinkStation() const {
    return m_link_station;
}
void OAINAHouseModel::setLinkStation(const OAINALinkStation &link_station) {
    m_link_station = link_station;
    m_link_station_isSet = true;
}

bool OAINAHouseModel::is_link_station_Set() const{
    return m_link_station_isSet;
}

bool OAINAHouseModel::is_link_station_Valid() const{
    return m_link_station_isValid;
}

OAINAPidAlgo OAINAHouseModel::getPidAlgo() const {
    return m_pid_algo;
}
void OAINAHouseModel::setPidAlgo(const OAINAPidAlgo &pid_algo) {
    m_pid_algo = pid_algo;
    m_pid_algo_isSet = true;
}

bool OAINAHouseModel::is_pid_algo_Set() const{
    return m_pid_algo_isSet;
}

bool OAINAHouseModel::is_pid_algo_Valid() const{
    return m_pid_algo_isValid;
}

QString OAINAHouseModel::getPreferedAlgoType() const {
    return m_prefered_algo_type;
}
void OAINAHouseModel::setPreferedAlgoType(const QString &prefered_algo_type) {
    m_prefered_algo_type = prefered_algo_type;
    m_prefered_algo_type_isSet = true;
}

bool OAINAHouseModel::is_prefered_algo_type_Set() const{
    return m_prefered_algo_type_isSet;
}

bool OAINAHouseModel::is_prefered_algo_type_Valid() const{
    return m_prefered_algo_type_isValid;
}

OAINASimpleAlgo OAINAHouseModel::getSimpleAlgo() const {
    return m_simple_algo;
}
void OAINAHouseModel::setSimpleAlgo(const OAINASimpleAlgo &simple_algo) {
    m_simple_algo = simple_algo;
    m_simple_algo_isSet = true;
}

bool OAINAHouseModel::is_simple_algo_Set() const{
    return m_simple_algo_isSet;
}

bool OAINAHouseModel::is_simple_algo_Valid() const{
    return m_simple_algo_isValid;
}

OAINAStation OAINAHouseModel::getStation() const {
    return m_station;
}
void OAINAHouseModel::setStation(const OAINAStation &station) {
    m_station = station;
    m_station_isSet = true;
}

bool OAINAHouseModel::is_station_Set() const{
    return m_station_isSet;
}

bool OAINAHouseModel::is_station_Valid() const{
    return m_station_isValid;
}

bool OAINAHouseModel::isStationFirsttimeAnticipate() const {
    return m_station_firsttime_anticipate;
}
void OAINAHouseModel::setStationFirsttimeAnticipate(const bool &station_firsttime_anticipate) {
    m_station_firsttime_anticipate = station_firsttime_anticipate;
    m_station_firsttime_anticipate_isSet = true;
}

bool OAINAHouseModel::is_station_firsttime_anticipate_Set() const{
    return m_station_firsttime_anticipate_isSet;
}

bool OAINAHouseModel::is_station_firsttime_anticipate_Valid() const{
    return m_station_firsttime_anticipate_isValid;
}

OAINADate OAINAHouseModel::getTime() const {
    return m_time;
}
void OAINAHouseModel::setTime(const OAINADate &time) {
    m_time = time;
    m_time_isSet = true;
}

bool OAINAHouseModel::is_time_Set() const{
    return m_time_isSet;
}

bool OAINAHouseModel::is_time_Valid() const{
    return m_time_isValid;
}

qint32 OAINAHouseModel::getTimeAlgoChanged() const {
    return m_time_algo_changed;
}
void OAINAHouseModel::setTimeAlgoChanged(const qint32 &time_algo_changed) {
    m_time_algo_changed = time_algo_changed;
    m_time_algo_changed_isSet = true;
}

bool OAINAHouseModel::is_time_algo_changed_Set() const{
    return m_time_algo_changed_isSet;
}

bool OAINAHouseModel::is_time_algo_changed_Valid() const{
    return m_time_algo_changed_isValid;
}

qint32 OAINAHouseModel::getTimePidComputed() const {
    return m_time_pid_computed;
}
void OAINAHouseModel::setTimePidComputed(const qint32 &time_pid_computed) {
    m_time_pid_computed = time_pid_computed;
    m_time_pid_computed_isSet = true;
}

bool OAINAHouseModel::is_time_pid_computed_Set() const{
    return m_time_pid_computed_isSet;
}

bool OAINAHouseModel::is_time_pid_computed_Valid() const{
    return m_time_pid_computed_isValid;
}

bool OAINAHouseModel::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_algo_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ca.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ext_temps.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_first_anticipate_avail_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_first_pid_avail_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gefs.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_in_use_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_compute_try.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_link_station.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_pid_algo.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_prefered_algo_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_simple_algo.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_station.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_station_firsttime_anticipate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_algo_changed_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_pid_computed_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINAHouseModel::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
