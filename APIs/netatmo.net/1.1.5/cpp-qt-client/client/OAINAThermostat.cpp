/**
 * Netatmo
 * <h3>Welcome to the Netatmo swagger on-line documentation !</h3> This site is a complement to the official <a href=\"https://dev.netatmo.com/\">Netatmo developper documentation</a> using swagger to bring interactivity and easy testing of requests with the \"try it\" button (authenticate with the authorization code OAuth2 flow by clicking the authenticate button in the methods). You can find the source code for this site can be found in the project <a href=\"https://github.com/cbornet/netatmo-swagger-ui\">netatmo-swagger-ui</a>. You can also use the online <a href=\"./swagger.json\">swagger declaration</a> file to generate code or static documentation (see <a href=\"https://github.com/cbornet/netatmo-swagger-api\">netatmo-swagger-api</a>). 
 *
 * The version of the OpenAPI document: 1.1.5
 * Contact: contact-api@netatmo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAINAThermostat.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAINAThermostat::OAINAThermostat(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAINAThermostat::OAINAThermostat() {
    this->initializeModel();
}

OAINAThermostat::~OAINAThermostat() {}

void OAINAThermostat::initializeModel() {

    m__id_isSet = false;
    m__id_isValid = false;

    m_battery_percent_isSet = false;
    m_battery_percent_isValid = false;

    m_battery_vp_isSet = false;
    m_battery_vp_isValid = false;

    m_firmware_isSet = false;
    m_firmware_isValid = false;

    m_last_message_isSet = false;
    m_last_message_isValid = false;

    m_last_therm_seen_isSet = false;
    m_last_therm_seen_isValid = false;

    m_measured_isSet = false;
    m_measured_isValid = false;

    m_module_name_isSet = false;
    m_module_name_isValid = false;

    m_rf_status_isSet = false;
    m_rf_status_isValid = false;

    m_setpoint_isSet = false;
    m_setpoint_isValid = false;

    m_setpoint_history_isSet = false;
    m_setpoint_history_isValid = false;

    m_setpoint_order_isSet = false;
    m_setpoint_order_isValid = false;

    m_therm_orientation_isSet = false;
    m_therm_orientation_isValid = false;

    m_therm_program_list_isSet = false;
    m_therm_program_list_isValid = false;

    m_therm_relay_cmd_isSet = false;
    m_therm_relay_cmd_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAINAThermostat::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAINAThermostat::fromJsonObject(QJsonObject json) {

    m__id_isValid = ::OpenAPI::fromJsonValue(m__id, json[QString("_id")]);
    m__id_isSet = !json[QString("_id")].isNull() && m__id_isValid;

    m_battery_percent_isValid = ::OpenAPI::fromJsonValue(m_battery_percent, json[QString("battery_percent")]);
    m_battery_percent_isSet = !json[QString("battery_percent")].isNull() && m_battery_percent_isValid;

    m_battery_vp_isValid = ::OpenAPI::fromJsonValue(m_battery_vp, json[QString("battery_vp")]);
    m_battery_vp_isSet = !json[QString("battery_vp")].isNull() && m_battery_vp_isValid;

    m_firmware_isValid = ::OpenAPI::fromJsonValue(m_firmware, json[QString("firmware")]);
    m_firmware_isSet = !json[QString("firmware")].isNull() && m_firmware_isValid;

    m_last_message_isValid = ::OpenAPI::fromJsonValue(m_last_message, json[QString("last_message")]);
    m_last_message_isSet = !json[QString("last_message")].isNull() && m_last_message_isValid;

    m_last_therm_seen_isValid = ::OpenAPI::fromJsonValue(m_last_therm_seen, json[QString("last_therm_seen")]);
    m_last_therm_seen_isSet = !json[QString("last_therm_seen")].isNull() && m_last_therm_seen_isValid;

    m_measured_isValid = ::OpenAPI::fromJsonValue(m_measured, json[QString("measured")]);
    m_measured_isSet = !json[QString("measured")].isNull() && m_measured_isValid;

    m_module_name_isValid = ::OpenAPI::fromJsonValue(m_module_name, json[QString("module_name")]);
    m_module_name_isSet = !json[QString("module_name")].isNull() && m_module_name_isValid;

    m_rf_status_isValid = ::OpenAPI::fromJsonValue(m_rf_status, json[QString("rf_status")]);
    m_rf_status_isSet = !json[QString("rf_status")].isNull() && m_rf_status_isValid;

    m_setpoint_isValid = ::OpenAPI::fromJsonValue(m_setpoint, json[QString("setpoint")]);
    m_setpoint_isSet = !json[QString("setpoint")].isNull() && m_setpoint_isValid;

    m_setpoint_history_isValid = ::OpenAPI::fromJsonValue(m_setpoint_history, json[QString("setpoint_history")]);
    m_setpoint_history_isSet = !json[QString("setpoint_history")].isNull() && m_setpoint_history_isValid;

    m_setpoint_order_isValid = ::OpenAPI::fromJsonValue(m_setpoint_order, json[QString("setpoint_order")]);
    m_setpoint_order_isSet = !json[QString("setpoint_order")].isNull() && m_setpoint_order_isValid;

    m_therm_orientation_isValid = ::OpenAPI::fromJsonValue(m_therm_orientation, json[QString("therm_orientation")]);
    m_therm_orientation_isSet = !json[QString("therm_orientation")].isNull() && m_therm_orientation_isValid;

    m_therm_program_list_isValid = ::OpenAPI::fromJsonValue(m_therm_program_list, json[QString("therm_program_list")]);
    m_therm_program_list_isSet = !json[QString("therm_program_list")].isNull() && m_therm_program_list_isValid;

    m_therm_relay_cmd_isValid = ::OpenAPI::fromJsonValue(m_therm_relay_cmd, json[QString("therm_relay_cmd")]);
    m_therm_relay_cmd_isSet = !json[QString("therm_relay_cmd")].isNull() && m_therm_relay_cmd_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAINAThermostat::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAINAThermostat::asJsonObject() const {
    QJsonObject obj;
    if (m__id_isSet) {
        obj.insert(QString("_id"), ::OpenAPI::toJsonValue(m__id));
    }
    if (m_battery_percent_isSet) {
        obj.insert(QString("battery_percent"), ::OpenAPI::toJsonValue(m_battery_percent));
    }
    if (m_battery_vp_isSet) {
        obj.insert(QString("battery_vp"), ::OpenAPI::toJsonValue(m_battery_vp));
    }
    if (m_firmware_isSet) {
        obj.insert(QString("firmware"), ::OpenAPI::toJsonValue(m_firmware));
    }
    if (m_last_message_isSet) {
        obj.insert(QString("last_message"), ::OpenAPI::toJsonValue(m_last_message));
    }
    if (m_last_therm_seen_isSet) {
        obj.insert(QString("last_therm_seen"), ::OpenAPI::toJsonValue(m_last_therm_seen));
    }
    if (m_measured.isSet()) {
        obj.insert(QString("measured"), ::OpenAPI::toJsonValue(m_measured));
    }
    if (m_module_name_isSet) {
        obj.insert(QString("module_name"), ::OpenAPI::toJsonValue(m_module_name));
    }
    if (m_rf_status_isSet) {
        obj.insert(QString("rf_status"), ::OpenAPI::toJsonValue(m_rf_status));
    }
    if (m_setpoint.isSet()) {
        obj.insert(QString("setpoint"), ::OpenAPI::toJsonValue(m_setpoint));
    }
    if (m_setpoint_history.size() > 0) {
        obj.insert(QString("setpoint_history"), ::OpenAPI::toJsonValue(m_setpoint_history));
    }
    if (m_setpoint_order.isSet()) {
        obj.insert(QString("setpoint_order"), ::OpenAPI::toJsonValue(m_setpoint_order));
    }
    if (m_therm_orientation_isSet) {
        obj.insert(QString("therm_orientation"), ::OpenAPI::toJsonValue(m_therm_orientation));
    }
    if (m_therm_program_list.size() > 0) {
        obj.insert(QString("therm_program_list"), ::OpenAPI::toJsonValue(m_therm_program_list));
    }
    if (m_therm_relay_cmd_isSet) {
        obj.insert(QString("therm_relay_cmd"), ::OpenAPI::toJsonValue(m_therm_relay_cmd));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

QString OAINAThermostat::getId() const {
    return m__id;
}
void OAINAThermostat::setId(const QString &_id) {
    m__id = _id;
    m__id_isSet = true;
}

bool OAINAThermostat::is__id_Set() const{
    return m__id_isSet;
}

bool OAINAThermostat::is__id_Valid() const{
    return m__id_isValid;
}

qint32 OAINAThermostat::getBatteryPercent() const {
    return m_battery_percent;
}
void OAINAThermostat::setBatteryPercent(const qint32 &battery_percent) {
    m_battery_percent = battery_percent;
    m_battery_percent_isSet = true;
}

bool OAINAThermostat::is_battery_percent_Set() const{
    return m_battery_percent_isSet;
}

bool OAINAThermostat::is_battery_percent_Valid() const{
    return m_battery_percent_isValid;
}

qint32 OAINAThermostat::getBatteryVp() const {
    return m_battery_vp;
}
void OAINAThermostat::setBatteryVp(const qint32 &battery_vp) {
    m_battery_vp = battery_vp;
    m_battery_vp_isSet = true;
}

bool OAINAThermostat::is_battery_vp_Set() const{
    return m_battery_vp_isSet;
}

bool OAINAThermostat::is_battery_vp_Valid() const{
    return m_battery_vp_isValid;
}

qint32 OAINAThermostat::getFirmware() const {
    return m_firmware;
}
void OAINAThermostat::setFirmware(const qint32 &firmware) {
    m_firmware = firmware;
    m_firmware_isSet = true;
}

bool OAINAThermostat::is_firmware_Set() const{
    return m_firmware_isSet;
}

bool OAINAThermostat::is_firmware_Valid() const{
    return m_firmware_isValid;
}

qint32 OAINAThermostat::getLastMessage() const {
    return m_last_message;
}
void OAINAThermostat::setLastMessage(const qint32 &last_message) {
    m_last_message = last_message;
    m_last_message_isSet = true;
}

bool OAINAThermostat::is_last_message_Set() const{
    return m_last_message_isSet;
}

bool OAINAThermostat::is_last_message_Valid() const{
    return m_last_message_isValid;
}

qint32 OAINAThermostat::getLastThermSeen() const {
    return m_last_therm_seen;
}
void OAINAThermostat::setLastThermSeen(const qint32 &last_therm_seen) {
    m_last_therm_seen = last_therm_seen;
    m_last_therm_seen_isSet = true;
}

bool OAINAThermostat::is_last_therm_seen_Set() const{
    return m_last_therm_seen_isSet;
}

bool OAINAThermostat::is_last_therm_seen_Valid() const{
    return m_last_therm_seen_isValid;
}

OAINAThermMeasure OAINAThermostat::getMeasured() const {
    return m_measured;
}
void OAINAThermostat::setMeasured(const OAINAThermMeasure &measured) {
    m_measured = measured;
    m_measured_isSet = true;
}

bool OAINAThermostat::is_measured_Set() const{
    return m_measured_isSet;
}

bool OAINAThermostat::is_measured_Valid() const{
    return m_measured_isValid;
}

QString OAINAThermostat::getModuleName() const {
    return m_module_name;
}
void OAINAThermostat::setModuleName(const QString &module_name) {
    m_module_name = module_name;
    m_module_name_isSet = true;
}

bool OAINAThermostat::is_module_name_Set() const{
    return m_module_name_isSet;
}

bool OAINAThermostat::is_module_name_Valid() const{
    return m_module_name_isValid;
}

qint32 OAINAThermostat::getRfStatus() const {
    return m_rf_status;
}
void OAINAThermostat::setRfStatus(const qint32 &rf_status) {
    m_rf_status = rf_status;
    m_rf_status_isSet = true;
}

bool OAINAThermostat::is_rf_status_Set() const{
    return m_rf_status_isSet;
}

bool OAINAThermostat::is_rf_status_Valid() const{
    return m_rf_status_isValid;
}

OAINASetpoint OAINAThermostat::getSetpoint() const {
    return m_setpoint;
}
void OAINAThermostat::setSetpoint(const OAINASetpoint &setpoint) {
    m_setpoint = setpoint;
    m_setpoint_isSet = true;
}

bool OAINAThermostat::is_setpoint_Set() const{
    return m_setpoint_isSet;
}

bool OAINAThermostat::is_setpoint_Valid() const{
    return m_setpoint_isValid;
}

QList<OAINASetpointLog> OAINAThermostat::getSetpointHistory() const {
    return m_setpoint_history;
}
void OAINAThermostat::setSetpointHistory(const QList<OAINASetpointLog> &setpoint_history) {
    m_setpoint_history = setpoint_history;
    m_setpoint_history_isSet = true;
}

bool OAINAThermostat::is_setpoint_history_Set() const{
    return m_setpoint_history_isSet;
}

bool OAINAThermostat::is_setpoint_history_Valid() const{
    return m_setpoint_history_isValid;
}

OAINASetpoint OAINAThermostat::getSetpointOrder() const {
    return m_setpoint_order;
}
void OAINAThermostat::setSetpointOrder(const OAINASetpoint &setpoint_order) {
    m_setpoint_order = setpoint_order;
    m_setpoint_order_isSet = true;
}

bool OAINAThermostat::is_setpoint_order_Set() const{
    return m_setpoint_order_isSet;
}

bool OAINAThermostat::is_setpoint_order_Valid() const{
    return m_setpoint_order_isValid;
}

qint32 OAINAThermostat::getThermOrientation() const {
    return m_therm_orientation;
}
void OAINAThermostat::setThermOrientation(const qint32 &therm_orientation) {
    m_therm_orientation = therm_orientation;
    m_therm_orientation_isSet = true;
}

bool OAINAThermostat::is_therm_orientation_Set() const{
    return m_therm_orientation_isSet;
}

bool OAINAThermostat::is_therm_orientation_Valid() const{
    return m_therm_orientation_isValid;
}

QList<OAINAThermProgram> OAINAThermostat::getThermProgramList() const {
    return m_therm_program_list;
}
void OAINAThermostat::setThermProgramList(const QList<OAINAThermProgram> &therm_program_list) {
    m_therm_program_list = therm_program_list;
    m_therm_program_list_isSet = true;
}

bool OAINAThermostat::is_therm_program_list_Set() const{
    return m_therm_program_list_isSet;
}

bool OAINAThermostat::is_therm_program_list_Valid() const{
    return m_therm_program_list_isValid;
}

qint32 OAINAThermostat::getThermRelayCmd() const {
    return m_therm_relay_cmd;
}
void OAINAThermostat::setThermRelayCmd(const qint32 &therm_relay_cmd) {
    m_therm_relay_cmd = therm_relay_cmd;
    m_therm_relay_cmd_isSet = true;
}

bool OAINAThermostat::is_therm_relay_cmd_Set() const{
    return m_therm_relay_cmd_isSet;
}

bool OAINAThermostat::is_therm_relay_cmd_Valid() const{
    return m_therm_relay_cmd_isValid;
}

QString OAINAThermostat::getType() const {
    return m_type;
}
void OAINAThermostat::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAINAThermostat::is_type_Set() const{
    return m_type_isSet;
}

bool OAINAThermostat::is_type_Valid() const{
    return m_type_isValid;
}

bool OAINAThermostat::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m__id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_battery_percent_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_battery_vp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_firmware_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_message_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_therm_seen_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_measured.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_module_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rf_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_setpoint.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_setpoint_history.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_setpoint_order.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_therm_orientation_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_therm_program_list.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_therm_relay_cmd_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAINAThermostat::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
