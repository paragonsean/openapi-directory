/*
 * Gisgraphy webservices
 * Since 2006, [Gisgraphy](http://www.gisgraphy.com) is a free, open source framework that offers the possibility to do geolocalisation and geocoding via Java APIs or REST webservices. Because geocoding is nothing without data, it provides an easy to use importer that will automatically download and import the necessary (free) data to your local database ([OpenStreetMap](http://www.openstreetmap.org/), [Geonames](http://www.geonames.org/) and [Quattroshapes](http://www.quattroshapes.com/): more than 100 million entries). You can also add your own data with the Web interface or the importer connectors provided. Gisgraphy is production ready, and has been designed to be scalable(load balanced), performant and used in other languages than just java : results can be output in XML, JSON, PHP, Python, Ruby, YAML, GeoRSS, and Atom. One of the most popular GPS tracking System (OpenGTS) also includes a Gisgraphy client...Gisgraphy is a framework. As a result it's flexible and powerful enough to be used in a lot of different use cases. [read more](http://www.gisgraphy.com)   if you use the premium servers, you can use the api key to test the webservices 
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AddressResultsDto;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AddressparserStandardizerApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AddressparserStandardizerApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AddressparserStandardizerApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for addressparsing
     * @param address A postal address. (required)
     * @param country The ISO 3166 Alpha 2 code of the country. (optional)
     * @param format The output format. (optional, default to XML)
     * @param paramCallback The callback method name (optional), use to wrap the content into a (alphanumeric) Javascript method. Works only for script output formats (JSON, PHP, Ruby, Python) (optional)
     * @param indent indents the results.Default to false. Possible values are true or false (or on when used with the rest service. If you use a checkbox in a web form, to indent the results, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param standardize Whether the address should be standardized after parsing, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param geocode UNUSED YET. Whether the address should be geocoded after parsing, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Sucessfully processed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Need auth. The API key parameter is missing or wrong, or doesn&#39;t correspond to any subscriptions </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Unhauthorize (auth will change nothing).Your IP is not allowed. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Missing parameter. Some parameters required for the webservices ar missing, please consult documentation </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. You exceed the authorized rate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addressparsingCall(String address, String country, String format, String paramCallback, Boolean indent, Boolean standardize, Boolean geocode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/addressparser/parse";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (address != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address", address));
        }

        if (country != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country", country));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (indent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("indent", indent));
        }

        if (standardize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("standardize", standardize));
        }

        if (geocode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("geocode", geocode));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "application/php",
            "application/ruby",
            "application/yaml",
            "application/python"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call addressparsingValidateBeforeCall(String address, String country, String format, String paramCallback, Boolean indent, Boolean standardize, Boolean geocode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling addressparsing(Async)");
        }

        return addressparsingCall(address, country, format, paramCallback, indent, standardize, geocode, _callback);

    }

    /**
     * split a raw address into several parts
     * The address parser and address standardizer, are part of the Gisgraphy project (free open source worldwide geocoder). Address parsing is the process of dividing a single address string into its individual component parts. Please visit [http://www.address-parser.net](http://www.address-parser.net) for more details 
     * @param address A postal address. (required)
     * @param country The ISO 3166 Alpha 2 code of the country. (optional)
     * @param format The output format. (optional, default to XML)
     * @param paramCallback The callback method name (optional), use to wrap the content into a (alphanumeric) Javascript method. Works only for script output formats (JSON, PHP, Ruby, Python) (optional)
     * @param indent indents the results.Default to false. Possible values are true or false (or on when used with the rest service. If you use a checkbox in a web form, to indent the results, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param standardize Whether the address should be standardized after parsing, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param geocode UNUSED YET. Whether the address should be geocoded after parsing, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @return AddressResultsDto
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Sucessfully processed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Need auth. The API key parameter is missing or wrong, or doesn&#39;t correspond to any subscriptions </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Unhauthorize (auth will change nothing).Your IP is not allowed. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Missing parameter. Some parameters required for the webservices ar missing, please consult documentation </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. You exceed the authorized rate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     </table>
     */
    public AddressResultsDto addressparsing(String address, String country, String format, String paramCallback, Boolean indent, Boolean standardize, Boolean geocode) throws ApiException {
        ApiResponse<AddressResultsDto> localVarResp = addressparsingWithHttpInfo(address, country, format, paramCallback, indent, standardize, geocode);
        return localVarResp.getData();
    }

    /**
     * split a raw address into several parts
     * The address parser and address standardizer, are part of the Gisgraphy project (free open source worldwide geocoder). Address parsing is the process of dividing a single address string into its individual component parts. Please visit [http://www.address-parser.net](http://www.address-parser.net) for more details 
     * @param address A postal address. (required)
     * @param country The ISO 3166 Alpha 2 code of the country. (optional)
     * @param format The output format. (optional, default to XML)
     * @param paramCallback The callback method name (optional), use to wrap the content into a (alphanumeric) Javascript method. Works only for script output formats (JSON, PHP, Ruby, Python) (optional)
     * @param indent indents the results.Default to false. Possible values are true or false (or on when used with the rest service. If you use a checkbox in a web form, to indent the results, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param standardize Whether the address should be standardized after parsing, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param geocode UNUSED YET. Whether the address should be geocoded after parsing, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @return ApiResponse&lt;AddressResultsDto&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Sucessfully processed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Need auth. The API key parameter is missing or wrong, or doesn&#39;t correspond to any subscriptions </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Unhauthorize (auth will change nothing).Your IP is not allowed. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Missing parameter. Some parameters required for the webservices ar missing, please consult documentation </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. You exceed the authorized rate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AddressResultsDto> addressparsingWithHttpInfo(String address, String country, String format, String paramCallback, Boolean indent, Boolean standardize, Boolean geocode) throws ApiException {
        okhttp3.Call localVarCall = addressparsingValidateBeforeCall(address, country, format, paramCallback, indent, standardize, geocode, null);
        Type localVarReturnType = new TypeToken<AddressResultsDto>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * split a raw address into several parts (asynchronously)
     * The address parser and address standardizer, are part of the Gisgraphy project (free open source worldwide geocoder). Address parsing is the process of dividing a single address string into its individual component parts. Please visit [http://www.address-parser.net](http://www.address-parser.net) for more details 
     * @param address A postal address. (required)
     * @param country The ISO 3166 Alpha 2 code of the country. (optional)
     * @param format The output format. (optional, default to XML)
     * @param paramCallback The callback method name (optional), use to wrap the content into a (alphanumeric) Javascript method. Works only for script output formats (JSON, PHP, Ruby, Python) (optional)
     * @param indent indents the results.Default to false. Possible values are true or false (or on when used with the rest service. If you use a checkbox in a web form, to indent the results, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param standardize Whether the address should be standardized after parsing, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param geocode UNUSED YET. Whether the address should be geocoded after parsing, the value will be &#39;on&#39; or &#39;off&#39;, so for a simple use : the value of indent can be &#39;true&#39; or &#39;on&#39; (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Sucessfully processed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Need auth. The API key parameter is missing or wrong, or doesn&#39;t correspond to any subscriptions </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Unhauthorize (auth will change nothing).Your IP is not allowed. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Missing parameter. Some parameters required for the webservices ar missing, please consult documentation </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests. You exceed the authorized rate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addressparsingAsync(String address, String country, String format, String paramCallback, Boolean indent, Boolean standardize, Boolean geocode, final ApiCallback<AddressResultsDto> _callback) throws ApiException {

        okhttp3.Call localVarCall = addressparsingValidateBeforeCall(address, country, format, paramCallback, indent, standardize, geocode, _callback);
        Type localVarReturnType = new TypeToken<AddressResultsDto>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
