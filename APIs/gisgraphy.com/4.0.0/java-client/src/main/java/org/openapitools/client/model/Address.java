/*
 * Gisgraphy webservices
 * Since 2006, [Gisgraphy](http://www.gisgraphy.com) is a free, open source framework that offers the possibility to do geolocalisation and geocoding via Java APIs or REST webservices. Because geocoding is nothing without data, it provides an easy to use importer that will automatically download and import the necessary (free) data to your local database ([OpenStreetMap](http://www.openstreetmap.org/), [Geonames](http://www.geonames.org/) and [Quattroshapes](http://www.quattroshapes.com/): more than 100 million entries). You can also add your own data with the Web interface or the importer connectors provided. Gisgraphy is production ready, and has been designed to be scalable(load balanced), performant and used in other languages than just java : results can be output in XML, JSON, PHP, Python, Ruby, YAML, GeoRSS, and Atom. One of the most popular GPS tracking System (OpenGTS) also includes a Gisgraphy client...Gisgraphy is a framework. As a result it's flexible and powerful enough to be used in a lot of different use cases. [read more](http://www.gisgraphy.com)   if you use the premium servers, you can use the api key to test the webservices 
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Address
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:27:52.231698-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Address {
  public static final String SERIALIZED_NAME_PO_BOX = "POBox";
  @SerializedName(SERIALIZED_NAME_PO_BOX)
  private String poBox;

  public static final String SERIALIZED_NAME_PO_BOX_AGENCY = "POBoxAgency";
  @SerializedName(SERIALIZED_NAME_PO_BOX_AGENCY)
  private String poBoxAgency;

  public static final String SERIALIZED_NAME_PO_BOX_INFO = "POBoxInfo";
  @SerializedName(SERIALIZED_NAME_PO_BOX_INFO)
  private String poBoxInfo;

  public static final String SERIALIZED_NAME_ADM1_NAME_ALTERNATES_LOCALIZED = "adm1NameAlternatesLocalized";
  @SerializedName(SERIALIZED_NAME_ADM1_NAME_ALTERNATES_LOCALIZED)
  private Map<String, List<String>> adm1NameAlternatesLocalized = new HashMap<>();

  public static final String SERIALIZED_NAME_ADM2_NAME_ALTERNATES_LOCALIZED = "adm2NameAlternatesLocalized";
  @SerializedName(SERIALIZED_NAME_ADM2_NAME_ALTERNATES_LOCALIZED)
  private Map<String, List<String>> adm2NameAlternatesLocalized = new HashMap<>();

  public static final String SERIALIZED_NAME_BLOCK = "block";
  @SerializedName(SERIALIZED_NAME_BLOCK)
  private String block;

  public static final String SERIALIZED_NAME_CITY = "city";
  @SerializedName(SERIALIZED_NAME_CITY)
  private String city;

  public static final String SERIALIZED_NAME_CITY_SUBDIVISION = "citySubdivision";
  @SerializedName(SERIALIZED_NAME_CITY_SUBDIVISION)
  private String citySubdivision;

  public static final String SERIALIZED_NAME_CIVIC_NUMBER_SUFFIX = "civicNumberSuffix";
  @SerializedName(SERIALIZED_NAME_CIVIC_NUMBER_SUFFIX)
  private String civicNumberSuffix;

  public static final String SERIALIZED_NAME_CONFIDENCE = "confidence";
  @SerializedName(SERIALIZED_NAME_CONFIDENCE)
  private String confidence;

  public static final String SERIALIZED_NAME_COUNTRY = "country";
  @SerializedName(SERIALIZED_NAME_COUNTRY)
  private String country;

  public static final String SERIALIZED_NAME_COUNTRY_NAME_ALTERNATES_LOCALIZED = "countryNameAlternatesLocalized";
  @SerializedName(SERIALIZED_NAME_COUNTRY_NAME_ALTERNATES_LOCALIZED)
  private Map<String, List<String>> countryNameAlternatesLocalized = new HashMap<>();

  public static final String SERIALIZED_NAME_COUNTRYCODE = "countrycode";
  @SerializedName(SERIALIZED_NAME_COUNTRYCODE)
  private String countrycode;

  public static final String SERIALIZED_NAME_DEPENDENT_LOCALITY = "dependentLocality";
  @SerializedName(SERIALIZED_NAME_DEPENDENT_LOCALITY)
  private String dependentLocality;

  public static final String SERIALIZED_NAME_DISTANCE = "distance";
  @SerializedName(SERIALIZED_NAME_DISTANCE)
  private Double distance;

  public static final String SERIALIZED_NAME_DISTRICT = "district";
  @SerializedName(SERIALIZED_NAME_DISTRICT)
  private String district;

  public static final String SERIALIZED_NAME_EXTRA_INFO = "extraInfo";
  @SerializedName(SERIALIZED_NAME_EXTRA_INFO)
  private String extraInfo;

  public static final String SERIALIZED_NAME_FLOOR = "floor";
  @SerializedName(SERIALIZED_NAME_FLOOR)
  private String floor;

  /**
   * Gets or Sets geocodinglevel
   */
  @JsonAdapter(GeocodinglevelEnum.Adapter.class)
  public enum GeocodinglevelEnum {
    NONE("NONE"),
    
    HOUSE_NUMBER("HOUSE_NUMBER"),
    
    STREET("STREET"),
    
    CITY("CITY"),
    
    STATE("STATE"),
    
    COUNTRY("COUNTRY");

    private String value;

    GeocodinglevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static GeocodinglevelEnum fromValue(String value) {
      for (GeocodinglevelEnum b : GeocodinglevelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<GeocodinglevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final GeocodinglevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public GeocodinglevelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return GeocodinglevelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      GeocodinglevelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_GEOCODINGLEVEL = "geocodinglevel";
  @SerializedName(SERIALIZED_NAME_GEOCODINGLEVEL)
  private GeocodinglevelEnum geocodinglevel;

  public static final String SERIALIZED_NAME_HOUSE_NUMBER = "houseNumber";
  @SerializedName(SERIALIZED_NAME_HOUSE_NUMBER)
  private String houseNumber;

  public static final String SERIALIZED_NAME_HOUSE_NUMBER_INFO = "houseNumberInfo";
  @SerializedName(SERIALIZED_NAME_HOUSE_NUMBER_INFO)
  private String houseNumberInfo;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Long id;

  public static final String SERIALIZED_NAME_LAT = "lat";
  @SerializedName(SERIALIZED_NAME_LAT)
  private Double lat;

  public static final String SERIALIZED_NAME_LNG = "lng";
  @SerializedName(SERIALIZED_NAME_LNG)
  private Double lng;

  public static final String SERIALIZED_NAME_LOTE = "lote";
  @SerializedName(SERIALIZED_NAME_LOTE)
  private String lote;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAME_ALTERNATES_LOCALIZED = "nameAlternatesLocalized";
  @SerializedName(SERIALIZED_NAME_NAME_ALTERNATES_LOCALIZED)
  private Map<String, List<String>> nameAlternatesLocalized = new HashMap<>();

  public static final String SERIALIZED_NAME_POST_DIRECTION = "postDirection";
  @SerializedName(SERIALIZED_NAME_POST_DIRECTION)
  private String postDirection;

  public static final String SERIALIZED_NAME_POST_DIRECTION_INTERSECTION = "postDirectionIntersection";
  @SerializedName(SERIALIZED_NAME_POST_DIRECTION_INTERSECTION)
  private String postDirectionIntersection;

  public static final String SERIALIZED_NAME_POST_TOWN = "postTown";
  @SerializedName(SERIALIZED_NAME_POST_TOWN)
  private String postTown;

  public static final String SERIALIZED_NAME_PRE_DIRECTION = "preDirection";
  @SerializedName(SERIALIZED_NAME_PRE_DIRECTION)
  private String preDirection;

  public static final String SERIALIZED_NAME_PRE_DIRECTION_INTERSECTION = "preDirectionIntersection";
  @SerializedName(SERIALIZED_NAME_PRE_DIRECTION_INTERSECTION)
  private String preDirectionIntersection;

  public static final String SERIALIZED_NAME_PREFECTURE = "prefecture";
  @SerializedName(SERIALIZED_NAME_PREFECTURE)
  private String prefecture;

  public static final String SERIALIZED_NAME_QUADRANT = "quadrant";
  @SerializedName(SERIALIZED_NAME_QUADRANT)
  private String quadrant;

  public static final String SERIALIZED_NAME_QUARTER = "quarter";
  @SerializedName(SERIALIZED_NAME_QUARTER)
  private String quarter;

  public static final String SERIALIZED_NAME_RECIPIENT_NAME = "recipientName";
  @SerializedName(SERIALIZED_NAME_RECIPIENT_NAME)
  private String recipientName;

  public static final String SERIALIZED_NAME_SECTOR = "sector";
  @SerializedName(SERIALIZED_NAME_SECTOR)
  private String sector;

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private String state;

  public static final String SERIALIZED_NAME_STREET_NAME = "streetName";
  @SerializedName(SERIALIZED_NAME_STREET_NAME)
  private String streetName;

  public static final String SERIALIZED_NAME_STREET_NAME_INTERSECTION = "streetNameIntersection";
  @SerializedName(SERIALIZED_NAME_STREET_NAME_INTERSECTION)
  private String streetNameIntersection;

  public static final String SERIALIZED_NAME_STREET_TYPE = "streetType";
  @SerializedName(SERIALIZED_NAME_STREET_TYPE)
  private String streetType;

  public static final String SERIALIZED_NAME_STREET_TYPE_INTERSECTION = "streetTypeIntersection";
  @SerializedName(SERIALIZED_NAME_STREET_TYPE_INTERSECTION)
  private String streetTypeIntersection;

  public static final String SERIALIZED_NAME_SUITE_NUMBER = "suiteNumber";
  @SerializedName(SERIALIZED_NAME_SUITE_NUMBER)
  private String suiteNumber;

  public static final String SERIALIZED_NAME_SUITE_TYPE = "suiteType";
  @SerializedName(SERIALIZED_NAME_SUITE_TYPE)
  private String suiteType;

  public static final String SERIALIZED_NAME_WARD = "ward";
  @SerializedName(SERIALIZED_NAME_WARD)
  private String ward;

  public static final String SERIALIZED_NAME_ZIP_CODE = "zipCode";
  @SerializedName(SERIALIZED_NAME_ZIP_CODE)
  private String zipCode;

  public Address() {
  }

  public Address poBox(String poBox) {
    this.poBox = poBox;
    return this;
  }

  /**
   * Post office box, Boite postale, Casilla de Correo,...
   * @return poBox
   */
  @javax.annotation.Nullable
  public String getPoBox() {
    return poBox;
  }

  public void setPoBox(String poBox) {
    this.poBox = poBox;
  }


  public Address poBoxAgency(String poBoxAgency) {
    this.poBoxAgency = poBoxAgency;
    return this;
  }

  /**
   * Agency where the office box, Boite postale, Casilla de Correo is
   * @return poBoxAgency
   */
  @javax.annotation.Nullable
  public String getPoBoxAgency() {
    return poBoxAgency;
  }

  public void setPoBoxAgency(String poBoxAgency) {
    this.poBoxAgency = poBoxAgency;
  }


  public Address poBoxInfo(String poBoxInfo) {
    this.poBoxInfo = poBoxInfo;
    return this;
  }

  /**
   * extra info on post office box, Boite postale, Casilla de Correo,..
   * @return poBoxInfo
   */
  @javax.annotation.Nullable
  public String getPoBoxInfo() {
    return poBoxInfo;
  }

  public void setPoBoxInfo(String poBoxInfo) {
    this.poBoxInfo = poBoxInfo;
  }


  public Address adm1NameAlternatesLocalized(Map<String, List<String>> adm1NameAlternatesLocalized) {
    this.adm1NameAlternatesLocalized = adm1NameAlternatesLocalized;
    return this;
  }

  public Address putAdm1NameAlternatesLocalizedItem(String key, List<String> adm1NameAlternatesLocalizedItem) {
    if (this.adm1NameAlternatesLocalized == null) {
      this.adm1NameAlternatesLocalized = new HashMap<>();
    }
    this.adm1NameAlternatesLocalized.put(key, adm1NameAlternatesLocalizedItem);
    return this;
  }

  /**
   * Get adm1NameAlternatesLocalized
   * @return adm1NameAlternatesLocalized
   */
  @javax.annotation.Nullable
  public Map<String, List<String>> getAdm1NameAlternatesLocalized() {
    return adm1NameAlternatesLocalized;
  }

  public void setAdm1NameAlternatesLocalized(Map<String, List<String>> adm1NameAlternatesLocalized) {
    this.adm1NameAlternatesLocalized = adm1NameAlternatesLocalized;
  }


  public Address adm2NameAlternatesLocalized(Map<String, List<String>> adm2NameAlternatesLocalized) {
    this.adm2NameAlternatesLocalized = adm2NameAlternatesLocalized;
    return this;
  }

  public Address putAdm2NameAlternatesLocalizedItem(String key, List<String> adm2NameAlternatesLocalizedItem) {
    if (this.adm2NameAlternatesLocalized == null) {
      this.adm2NameAlternatesLocalized = new HashMap<>();
    }
    this.adm2NameAlternatesLocalized.put(key, adm2NameAlternatesLocalizedItem);
    return this;
  }

  /**
   * Get adm2NameAlternatesLocalized
   * @return adm2NameAlternatesLocalized
   */
  @javax.annotation.Nullable
  public Map<String, List<String>> getAdm2NameAlternatesLocalized() {
    return adm2NameAlternatesLocalized;
  }

  public void setAdm2NameAlternatesLocalized(Map<String, List<String>> adm2NameAlternatesLocalized) {
    this.adm2NameAlternatesLocalized = adm2NameAlternatesLocalized;
  }


  public Address block(String block) {
    this.block = block;
    return this;
  }

  /**
   * The block in an address (Brasilia only) the block in austria, singapore,... address
   * @return block
   */
  @javax.annotation.Nullable
  public String getBlock() {
    return block;
  }

  public void setBlock(String block) {
    this.block = block;
  }


  public Address city(String city) {
    this.city = city;
    return this;
  }

  /**
   * The city or locality, a small town or village name sometimes is included in an address when the Delivery Point is outside the boundary of the main Post Town that serves it.
   * @return city
   */
  @javax.annotation.Nullable
  public String getCity() {
    return city;
  }

  public void setCity(String city) {
    this.city = city;
  }


  public Address citySubdivision(String citySubdivision) {
    this.citySubdivision = citySubdivision;
    return this;
  }

  /**
   * A sub division of a city
   * @return citySubdivision
   */
  @javax.annotation.Nullable
  public String getCitySubdivision() {
    return citySubdivision;
  }

  public void setCitySubdivision(String citySubdivision) {
    this.citySubdivision = citySubdivision;
  }


  public Address civicNumberSuffix(String civicNumberSuffix) {
    this.civicNumberSuffix = civicNumberSuffix;
    return this;
  }

  /**
   * The number that follows the house number (Canada only)
   * @return civicNumberSuffix
   */
  @javax.annotation.Nullable
  public String getCivicNumberSuffix() {
    return civicNumberSuffix;
  }

  public void setCivicNumberSuffix(String civicNumberSuffix) {
    this.civicNumberSuffix = civicNumberSuffix;
  }


  public Address confidence(String confidence) {
    this.confidence = confidence;
    return this;
  }

  /**
   * An indicator that mesure how the parser is confident for the result
   * @return confidence
   */
  @javax.annotation.Nullable
  public String getConfidence() {
    return confidence;
  }

  public void setConfidence(String confidence) {
    this.confidence = confidence;
  }


  public Address country(String country) {
    this.country = country;
    return this;
  }

  /**
   * The country name
   * @return country
   */
  @javax.annotation.Nullable
  public String getCountry() {
    return country;
  }

  public void setCountry(String country) {
    this.country = country;
  }


  public Address countryNameAlternatesLocalized(Map<String, List<String>> countryNameAlternatesLocalized) {
    this.countryNameAlternatesLocalized = countryNameAlternatesLocalized;
    return this;
  }

  public Address putCountryNameAlternatesLocalizedItem(String key, List<String> countryNameAlternatesLocalizedItem) {
    if (this.countryNameAlternatesLocalized == null) {
      this.countryNameAlternatesLocalized = new HashMap<>();
    }
    this.countryNameAlternatesLocalized.put(key, countryNameAlternatesLocalizedItem);
    return this;
  }

  /**
   * Get countryNameAlternatesLocalized
   * @return countryNameAlternatesLocalized
   */
  @javax.annotation.Nullable
  public Map<String, List<String>> getCountryNameAlternatesLocalized() {
    return countryNameAlternatesLocalized;
  }

  public void setCountryNameAlternatesLocalized(Map<String, List<String>> countryNameAlternatesLocalized) {
    this.countryNameAlternatesLocalized = countryNameAlternatesLocalized;
  }


  public Address countrycode(String countrycode) {
    this.countrycode = countrycode;
    return this;
  }

  /**
   * The countrycode given in the request
   * @return countrycode
   */
  @javax.annotation.Nullable
  public String getCountrycode() {
    return countrycode;
  }

  public void setCountrycode(String countrycode) {
    this.countrycode = countrycode;
  }


  public Address dependentLocality(String dependentLocality) {
    this.dependentLocality = dependentLocality;
    return this;
  }

  /**
   * &#39;Sub&#39; city atached to a big city
   * @return dependentLocality
   */
  @javax.annotation.Nullable
  public String getDependentLocality() {
    return dependentLocality;
  }

  public void setDependentLocality(String dependentLocality) {
    this.dependentLocality = dependentLocality;
  }


  public Address distance(Double distance) {
    this.distance = distance;
    return this;
  }

  /**
   * The distance of the address for the given parameter location in the query
   * @return distance
   */
  @javax.annotation.Nullable
  public Double getDistance() {
    return distance;
  }

  public void setDistance(Double distance) {
    this.distance = distance;
  }


  public Address district(String district) {
    this.district = district;
    return this;
  }

  /**
   * The district, mainly use for Russia
   * @return district
   */
  @javax.annotation.Nullable
  public String getDistrict() {
    return district;
  }

  public void setDistrict(String district) {
    this.district = district;
  }


  public Address extraInfo(String extraInfo) {
    this.extraInfo = extraInfo;
    return this;
  }

  /**
   * Informations on floor, unit, and sometimes POBOX,...
   * @return extraInfo
   */
  @javax.annotation.Nullable
  public String getExtraInfo() {
    return extraInfo;
  }

  public void setExtraInfo(String extraInfo) {
    this.extraInfo = extraInfo;
  }


  public Address floor(String floor) {
    this.floor = floor;
    return this;
  }

  /**
   * The floor in an address, not a floor number in a unit (Brasilia only)
   * @return floor
   */
  @javax.annotation.Nullable
  public String getFloor() {
    return floor;
  }

  public void setFloor(String floor) {
    this.floor = floor;
  }


  public Address geocodinglevel(GeocodinglevelEnum geocodinglevel) {
    this.geocodinglevel = geocodinglevel;
    return this;
  }

  /**
   * Get geocodinglevel
   * @return geocodinglevel
   */
  @javax.annotation.Nullable
  public GeocodinglevelEnum getGeocodinglevel() {
    return geocodinglevel;
  }

  public void setGeocodinglevel(GeocodinglevelEnum geocodinglevel) {
    this.geocodinglevel = geocodinglevel;
  }


  public Address houseNumber(String houseNumber) {
    this.houseNumber = houseNumber;
    return this;
  }

  /**
   * Official number assigned to an address by the municipality, several languages supported
   * @return houseNumber
   */
  @javax.annotation.Nullable
  public String getHouseNumber() {
    return houseNumber;
  }

  public void setHouseNumber(String houseNumber) {
    this.houseNumber = houseNumber;
  }


  public Address houseNumberInfo(String houseNumberInfo) {
    this.houseNumberInfo = houseNumberInfo;
    return this;
  }

  /**
   * All information that give extra information on the house number
   * @return houseNumberInfo
   */
  @javax.annotation.Nullable
  public String getHouseNumberInfo() {
    return houseNumberInfo;
  }

  public void setHouseNumberInfo(String houseNumberInfo) {
    this.houseNumberInfo = houseNumberInfo;
  }


  public Address id(Long id) {
    this.id = id;
    return this;
  }

  /**
   * An internal ID to identify the address
   * @return id
   */
  @javax.annotation.Nullable
  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }


  public Address lat(Double lat) {
    this.lat = lat;
    return this;
  }

  /**
   * The latitude of the address
   * @return lat
   */
  @javax.annotation.Nullable
  public Double getLat() {
    return lat;
  }

  public void setLat(Double lat) {
    this.lat = lat;
  }


  public Address lng(Double lng) {
    this.lng = lng;
    return this;
  }

  /**
   * The longitude of the address
   * @return lng
   */
  @javax.annotation.Nullable
  public Double getLng() {
    return lng;
  }

  public void setLng(Double lng) {
    this.lng = lng;
  }


  public Address lote(String lote) {
    this.lote = lote;
    return this;
  }

  /**
   * Lote in Brazilian address
   * @return lote
   */
  @javax.annotation.Nullable
  public String getLote() {
    return lote;
  }

  public void setLote(String lote) {
    this.lote = lote;
  }


  public Address name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of the place, it is null in case of address but filled if common place. Name is different than recipient name
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Address nameAlternatesLocalized(Map<String, List<String>> nameAlternatesLocalized) {
    this.nameAlternatesLocalized = nameAlternatesLocalized;
    return this;
  }

  public Address putNameAlternatesLocalizedItem(String key, List<String> nameAlternatesLocalizedItem) {
    if (this.nameAlternatesLocalized == null) {
      this.nameAlternatesLocalized = new HashMap<>();
    }
    this.nameAlternatesLocalized.put(key, nameAlternatesLocalizedItem);
    return this;
  }

  /**
   * Get nameAlternatesLocalized
   * @return nameAlternatesLocalized
   */
  @javax.annotation.Nullable
  public Map<String, List<String>> getNameAlternatesLocalized() {
    return nameAlternatesLocalized;
  }

  public void setNameAlternatesLocalized(Map<String, List<String>> nameAlternatesLocalized) {
    this.nameAlternatesLocalized = nameAlternatesLocalized;
  }


  public Address postDirection(String postDirection) {
    this.postDirection = postDirection;
    return this;
  }

  /**
   * The cardinal direction after the name of the street
   * @return postDirection
   */
  @javax.annotation.Nullable
  public String getPostDirection() {
    return postDirection;
  }

  public void setPostDirection(String postDirection) {
    this.postDirection = postDirection;
  }


  public Address postDirectionIntersection(String postDirectionIntersection) {
    this.postDirectionIntersection = postDirectionIntersection;
    return this;
  }

  /**
   * The cardinal direction after the name of the intersection street
   * @return postDirectionIntersection
   */
  @javax.annotation.Nullable
  public String getPostDirectionIntersection() {
    return postDirectionIntersection;
  }

  public void setPostDirectionIntersection(String postDirectionIntersection) {
    this.postDirectionIntersection = postDirectionIntersection;
  }


  public Address postTown(String postTown) {
    this.postTown = postTown;
    return this;
  }

  /**
   * a city is a required part of all postal addresses in the United Kingdom
   * @return postTown
   */
  @javax.annotation.Nullable
  public String getPostTown() {
    return postTown;
  }

  public void setPostTown(String postTown) {
    this.postTown = postTown;
  }


  public Address preDirection(String preDirection) {
    this.preDirection = preDirection;
    return this;
  }

  /**
   * The cardinal direction before the name of the street
   * @return preDirection
   */
  @javax.annotation.Nullable
  public String getPreDirection() {
    return preDirection;
  }

  public void setPreDirection(String preDirection) {
    this.preDirection = preDirection;
  }


  public Address preDirectionIntersection(String preDirectionIntersection) {
    this.preDirectionIntersection = preDirectionIntersection;
    return this;
  }

  /**
   * The cardinal direction before the name of the intersection street
   * @return preDirectionIntersection
   */
  @javax.annotation.Nullable
  public String getPreDirectionIntersection() {
    return preDirectionIntersection;
  }

  public void setPreDirectionIntersection(String preDirectionIntersection) {
    this.preDirectionIntersection = preDirectionIntersection;
  }


  public Address prefecture(String prefecture) {
    this.prefecture = prefecture;
    return this;
  }

  /**
   * prefecture of China
   * @return prefecture
   */
  @javax.annotation.Nullable
  public String getPrefecture() {
    return prefecture;
  }

  public void setPrefecture(String prefecture) {
    this.prefecture = prefecture;
  }


  public Address quadrant(String quadrant) {
    this.quadrant = quadrant;
    return this;
  }

  /**
   * The quadrant in an address (Brasilia only)
   * @return quadrant
   */
  @javax.annotation.Nullable
  public String getQuadrant() {
    return quadrant;
  }

  public void setQuadrant(String quadrant) {
    this.quadrant = quadrant;
  }


  public Address quarter(String quarter) {
    this.quarter = quarter;
    return this;
  }

  /**
   * A section of an urban settlement
   * @return quarter
   */
  @javax.annotation.Nullable
  public String getQuarter() {
    return quarter;
  }

  public void setQuarter(String quarter) {
    this.quarter = quarter;
  }


  public Address recipientName(String recipientName) {
    this.recipientName = recipientName;
    return this;
  }

  /**
   * Name of the organisation or person at the given address
   * @return recipientName
   */
  @javax.annotation.Nullable
  public String getRecipientName() {
    return recipientName;
  }

  public void setRecipientName(String recipientName) {
    this.recipientName = recipientName;
  }


  public Address sector(String sector) {
    this.sector = sector;
    return this;
  }

  /**
   * The sector in an address (Brasilia only)
   * @return sector
   */
  @javax.annotation.Nullable
  public String getSector() {
    return sector;
  }

  public void setSector(String sector) {
    this.sector = sector;
  }


  public Address state(String state) {
    this.state = state;
    return this;
  }

  /**
   * The state or county when applicable, can be fullname or abbreviation
   * @return state
   */
  @javax.annotation.Nullable
  public String getState() {
    return state;
  }

  public void setState(String state) {
    this.state = state;
  }


  public Address streetName(String streetName) {
    this.streetName = streetName;
    return this;
  }

  /**
   * The official name of the street or the ordinal number
   * @return streetName
   */
  @javax.annotation.Nullable
  public String getStreetName() {
    return streetName;
  }

  public void setStreetName(String streetName) {
    this.streetName = streetName;
  }


  public Address streetNameIntersection(String streetNameIntersection) {
    this.streetNameIntersection = streetNameIntersection;
    return this;
  }

  /**
   * The official name of the intersection street
   * @return streetNameIntersection
   */
  @javax.annotation.Nullable
  public String getStreetNameIntersection() {
    return streetNameIntersection;
  }

  public void setStreetNameIntersection(String streetNameIntersection) {
    this.streetNameIntersection = streetNameIntersection;
  }


  public Address streetType(String streetType) {
    this.streetType = streetType;
    return this;
  }

  /**
   * The type of the street
   * @return streetType
   */
  @javax.annotation.Nullable
  public String getStreetType() {
    return streetType;
  }

  public void setStreetType(String streetType) {
    this.streetType = streetType;
  }


  public Address streetTypeIntersection(String streetTypeIntersection) {
    this.streetTypeIntersection = streetTypeIntersection;
    return this;
  }

  /**
   * The type of the intersection street
   * @return streetTypeIntersection
   */
  @javax.annotation.Nullable
  public String getStreetTypeIntersection() {
    return streetTypeIntersection;
  }

  public void setStreetTypeIntersection(String streetTypeIntersection) {
    this.streetTypeIntersection = streetTypeIntersection;
  }


  public Address suiteNumber(String suiteNumber) {
    this.suiteNumber = suiteNumber;
    return this;
  }

  /**
   * Informations on the unit, mainly used and filled by standardizer
   * @return suiteNumber
   */
  @javax.annotation.Nullable
  public String getSuiteNumber() {
    return suiteNumber;
  }

  public void setSuiteNumber(String suiteNumber) {
    this.suiteNumber = suiteNumber;
  }


  public Address suiteType(String suiteType) {
    this.suiteType = suiteType;
    return this;
  }

  /**
   * Informations on the unit, mainly used and filled by standardizer
   * @return suiteType
   */
  @javax.annotation.Nullable
  public String getSuiteType() {
    return suiteType;
  }

  public void setSuiteType(String suiteType) {
    this.suiteType = suiteType;
  }


  public Address ward(String ward) {
    this.ward = ward;
    return this;
  }

  /**
   * Ward in japanese address
   * @return ward
   */
  @javax.annotation.Nullable
  public String getWard() {
    return ward;
  }

  public void setWard(String ward) {
    this.ward = ward;
  }


  public Address zipCode(String zipCode) {
    this.zipCode = zipCode;
    return this;
  }

  /**
   * The zip or post code
   * @return zipCode
   */
  @javax.annotation.Nullable
  public String getZipCode() {
    return zipCode;
  }

  public void setZipCode(String zipCode) {
    this.zipCode = zipCode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Address address = (Address) o;
    return Objects.equals(this.poBox, address.poBox) &&
        Objects.equals(this.poBoxAgency, address.poBoxAgency) &&
        Objects.equals(this.poBoxInfo, address.poBoxInfo) &&
        Objects.equals(this.adm1NameAlternatesLocalized, address.adm1NameAlternatesLocalized) &&
        Objects.equals(this.adm2NameAlternatesLocalized, address.adm2NameAlternatesLocalized) &&
        Objects.equals(this.block, address.block) &&
        Objects.equals(this.city, address.city) &&
        Objects.equals(this.citySubdivision, address.citySubdivision) &&
        Objects.equals(this.civicNumberSuffix, address.civicNumberSuffix) &&
        Objects.equals(this.confidence, address.confidence) &&
        Objects.equals(this.country, address.country) &&
        Objects.equals(this.countryNameAlternatesLocalized, address.countryNameAlternatesLocalized) &&
        Objects.equals(this.countrycode, address.countrycode) &&
        Objects.equals(this.dependentLocality, address.dependentLocality) &&
        Objects.equals(this.distance, address.distance) &&
        Objects.equals(this.district, address.district) &&
        Objects.equals(this.extraInfo, address.extraInfo) &&
        Objects.equals(this.floor, address.floor) &&
        Objects.equals(this.geocodinglevel, address.geocodinglevel) &&
        Objects.equals(this.houseNumber, address.houseNumber) &&
        Objects.equals(this.houseNumberInfo, address.houseNumberInfo) &&
        Objects.equals(this.id, address.id) &&
        Objects.equals(this.lat, address.lat) &&
        Objects.equals(this.lng, address.lng) &&
        Objects.equals(this.lote, address.lote) &&
        Objects.equals(this.name, address.name) &&
        Objects.equals(this.nameAlternatesLocalized, address.nameAlternatesLocalized) &&
        Objects.equals(this.postDirection, address.postDirection) &&
        Objects.equals(this.postDirectionIntersection, address.postDirectionIntersection) &&
        Objects.equals(this.postTown, address.postTown) &&
        Objects.equals(this.preDirection, address.preDirection) &&
        Objects.equals(this.preDirectionIntersection, address.preDirectionIntersection) &&
        Objects.equals(this.prefecture, address.prefecture) &&
        Objects.equals(this.quadrant, address.quadrant) &&
        Objects.equals(this.quarter, address.quarter) &&
        Objects.equals(this.recipientName, address.recipientName) &&
        Objects.equals(this.sector, address.sector) &&
        Objects.equals(this.state, address.state) &&
        Objects.equals(this.streetName, address.streetName) &&
        Objects.equals(this.streetNameIntersection, address.streetNameIntersection) &&
        Objects.equals(this.streetType, address.streetType) &&
        Objects.equals(this.streetTypeIntersection, address.streetTypeIntersection) &&
        Objects.equals(this.suiteNumber, address.suiteNumber) &&
        Objects.equals(this.suiteType, address.suiteType) &&
        Objects.equals(this.ward, address.ward) &&
        Objects.equals(this.zipCode, address.zipCode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(poBox, poBoxAgency, poBoxInfo, adm1NameAlternatesLocalized, adm2NameAlternatesLocalized, block, city, citySubdivision, civicNumberSuffix, confidence, country, countryNameAlternatesLocalized, countrycode, dependentLocality, distance, district, extraInfo, floor, geocodinglevel, houseNumber, houseNumberInfo, id, lat, lng, lote, name, nameAlternatesLocalized, postDirection, postDirectionIntersection, postTown, preDirection, preDirectionIntersection, prefecture, quadrant, quarter, recipientName, sector, state, streetName, streetNameIntersection, streetType, streetTypeIntersection, suiteNumber, suiteType, ward, zipCode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Address {\n");
    sb.append("    poBox: ").append(toIndentedString(poBox)).append("\n");
    sb.append("    poBoxAgency: ").append(toIndentedString(poBoxAgency)).append("\n");
    sb.append("    poBoxInfo: ").append(toIndentedString(poBoxInfo)).append("\n");
    sb.append("    adm1NameAlternatesLocalized: ").append(toIndentedString(adm1NameAlternatesLocalized)).append("\n");
    sb.append("    adm2NameAlternatesLocalized: ").append(toIndentedString(adm2NameAlternatesLocalized)).append("\n");
    sb.append("    block: ").append(toIndentedString(block)).append("\n");
    sb.append("    city: ").append(toIndentedString(city)).append("\n");
    sb.append("    citySubdivision: ").append(toIndentedString(citySubdivision)).append("\n");
    sb.append("    civicNumberSuffix: ").append(toIndentedString(civicNumberSuffix)).append("\n");
    sb.append("    confidence: ").append(toIndentedString(confidence)).append("\n");
    sb.append("    country: ").append(toIndentedString(country)).append("\n");
    sb.append("    countryNameAlternatesLocalized: ").append(toIndentedString(countryNameAlternatesLocalized)).append("\n");
    sb.append("    countrycode: ").append(toIndentedString(countrycode)).append("\n");
    sb.append("    dependentLocality: ").append(toIndentedString(dependentLocality)).append("\n");
    sb.append("    distance: ").append(toIndentedString(distance)).append("\n");
    sb.append("    district: ").append(toIndentedString(district)).append("\n");
    sb.append("    extraInfo: ").append(toIndentedString(extraInfo)).append("\n");
    sb.append("    floor: ").append(toIndentedString(floor)).append("\n");
    sb.append("    geocodinglevel: ").append(toIndentedString(geocodinglevel)).append("\n");
    sb.append("    houseNumber: ").append(toIndentedString(houseNumber)).append("\n");
    sb.append("    houseNumberInfo: ").append(toIndentedString(houseNumberInfo)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    lat: ").append(toIndentedString(lat)).append("\n");
    sb.append("    lng: ").append(toIndentedString(lng)).append("\n");
    sb.append("    lote: ").append(toIndentedString(lote)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nameAlternatesLocalized: ").append(toIndentedString(nameAlternatesLocalized)).append("\n");
    sb.append("    postDirection: ").append(toIndentedString(postDirection)).append("\n");
    sb.append("    postDirectionIntersection: ").append(toIndentedString(postDirectionIntersection)).append("\n");
    sb.append("    postTown: ").append(toIndentedString(postTown)).append("\n");
    sb.append("    preDirection: ").append(toIndentedString(preDirection)).append("\n");
    sb.append("    preDirectionIntersection: ").append(toIndentedString(preDirectionIntersection)).append("\n");
    sb.append("    prefecture: ").append(toIndentedString(prefecture)).append("\n");
    sb.append("    quadrant: ").append(toIndentedString(quadrant)).append("\n");
    sb.append("    quarter: ").append(toIndentedString(quarter)).append("\n");
    sb.append("    recipientName: ").append(toIndentedString(recipientName)).append("\n");
    sb.append("    sector: ").append(toIndentedString(sector)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    streetName: ").append(toIndentedString(streetName)).append("\n");
    sb.append("    streetNameIntersection: ").append(toIndentedString(streetNameIntersection)).append("\n");
    sb.append("    streetType: ").append(toIndentedString(streetType)).append("\n");
    sb.append("    streetTypeIntersection: ").append(toIndentedString(streetTypeIntersection)).append("\n");
    sb.append("    suiteNumber: ").append(toIndentedString(suiteNumber)).append("\n");
    sb.append("    suiteType: ").append(toIndentedString(suiteType)).append("\n");
    sb.append("    ward: ").append(toIndentedString(ward)).append("\n");
    sb.append("    zipCode: ").append(toIndentedString(zipCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("POBox");
    openapiFields.add("POBoxAgency");
    openapiFields.add("POBoxInfo");
    openapiFields.add("adm1NameAlternatesLocalized");
    openapiFields.add("adm2NameAlternatesLocalized");
    openapiFields.add("block");
    openapiFields.add("city");
    openapiFields.add("citySubdivision");
    openapiFields.add("civicNumberSuffix");
    openapiFields.add("confidence");
    openapiFields.add("country");
    openapiFields.add("countryNameAlternatesLocalized");
    openapiFields.add("countrycode");
    openapiFields.add("dependentLocality");
    openapiFields.add("distance");
    openapiFields.add("district");
    openapiFields.add("extraInfo");
    openapiFields.add("floor");
    openapiFields.add("geocodinglevel");
    openapiFields.add("houseNumber");
    openapiFields.add("houseNumberInfo");
    openapiFields.add("id");
    openapiFields.add("lat");
    openapiFields.add("lng");
    openapiFields.add("lote");
    openapiFields.add("name");
    openapiFields.add("nameAlternatesLocalized");
    openapiFields.add("postDirection");
    openapiFields.add("postDirectionIntersection");
    openapiFields.add("postTown");
    openapiFields.add("preDirection");
    openapiFields.add("preDirectionIntersection");
    openapiFields.add("prefecture");
    openapiFields.add("quadrant");
    openapiFields.add("quarter");
    openapiFields.add("recipientName");
    openapiFields.add("sector");
    openapiFields.add("state");
    openapiFields.add("streetName");
    openapiFields.add("streetNameIntersection");
    openapiFields.add("streetType");
    openapiFields.add("streetTypeIntersection");
    openapiFields.add("suiteNumber");
    openapiFields.add("suiteType");
    openapiFields.add("ward");
    openapiFields.add("zipCode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Address
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Address.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Address is not found in the empty JSON string", Address.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Address.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Address` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("POBox") != null && !jsonObj.get("POBox").isJsonNull()) && !jsonObj.get("POBox").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `POBox` to be a primitive type in the JSON string but got `%s`", jsonObj.get("POBox").toString()));
      }
      if ((jsonObj.get("POBoxAgency") != null && !jsonObj.get("POBoxAgency").isJsonNull()) && !jsonObj.get("POBoxAgency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `POBoxAgency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("POBoxAgency").toString()));
      }
      if ((jsonObj.get("POBoxInfo") != null && !jsonObj.get("POBoxInfo").isJsonNull()) && !jsonObj.get("POBoxInfo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `POBoxInfo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("POBoxInfo").toString()));
      }
      if ((jsonObj.get("block") != null && !jsonObj.get("block").isJsonNull()) && !jsonObj.get("block").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `block` to be a primitive type in the JSON string but got `%s`", jsonObj.get("block").toString()));
      }
      if ((jsonObj.get("city") != null && !jsonObj.get("city").isJsonNull()) && !jsonObj.get("city").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `city` to be a primitive type in the JSON string but got `%s`", jsonObj.get("city").toString()));
      }
      if ((jsonObj.get("citySubdivision") != null && !jsonObj.get("citySubdivision").isJsonNull()) && !jsonObj.get("citySubdivision").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `citySubdivision` to be a primitive type in the JSON string but got `%s`", jsonObj.get("citySubdivision").toString()));
      }
      if ((jsonObj.get("civicNumberSuffix") != null && !jsonObj.get("civicNumberSuffix").isJsonNull()) && !jsonObj.get("civicNumberSuffix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `civicNumberSuffix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("civicNumberSuffix").toString()));
      }
      if ((jsonObj.get("confidence") != null && !jsonObj.get("confidence").isJsonNull()) && !jsonObj.get("confidence").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `confidence` to be a primitive type in the JSON string but got `%s`", jsonObj.get("confidence").toString()));
      }
      if ((jsonObj.get("country") != null && !jsonObj.get("country").isJsonNull()) && !jsonObj.get("country").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `country` to be a primitive type in the JSON string but got `%s`", jsonObj.get("country").toString()));
      }
      if ((jsonObj.get("countrycode") != null && !jsonObj.get("countrycode").isJsonNull()) && !jsonObj.get("countrycode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `countrycode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("countrycode").toString()));
      }
      if ((jsonObj.get("dependentLocality") != null && !jsonObj.get("dependentLocality").isJsonNull()) && !jsonObj.get("dependentLocality").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dependentLocality` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dependentLocality").toString()));
      }
      if ((jsonObj.get("district") != null && !jsonObj.get("district").isJsonNull()) && !jsonObj.get("district").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `district` to be a primitive type in the JSON string but got `%s`", jsonObj.get("district").toString()));
      }
      if ((jsonObj.get("extraInfo") != null && !jsonObj.get("extraInfo").isJsonNull()) && !jsonObj.get("extraInfo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `extraInfo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("extraInfo").toString()));
      }
      if ((jsonObj.get("floor") != null && !jsonObj.get("floor").isJsonNull()) && !jsonObj.get("floor").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `floor` to be a primitive type in the JSON string but got `%s`", jsonObj.get("floor").toString()));
      }
      if ((jsonObj.get("geocodinglevel") != null && !jsonObj.get("geocodinglevel").isJsonNull()) && !jsonObj.get("geocodinglevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `geocodinglevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("geocodinglevel").toString()));
      }
      // validate the optional field `geocodinglevel`
      if (jsonObj.get("geocodinglevel") != null && !jsonObj.get("geocodinglevel").isJsonNull()) {
        GeocodinglevelEnum.validateJsonElement(jsonObj.get("geocodinglevel"));
      }
      if ((jsonObj.get("houseNumber") != null && !jsonObj.get("houseNumber").isJsonNull()) && !jsonObj.get("houseNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `houseNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("houseNumber").toString()));
      }
      if ((jsonObj.get("houseNumberInfo") != null && !jsonObj.get("houseNumberInfo").isJsonNull()) && !jsonObj.get("houseNumberInfo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `houseNumberInfo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("houseNumberInfo").toString()));
      }
      if ((jsonObj.get("lote") != null && !jsonObj.get("lote").isJsonNull()) && !jsonObj.get("lote").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lote` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lote").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("postDirection") != null && !jsonObj.get("postDirection").isJsonNull()) && !jsonObj.get("postDirection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postDirection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postDirection").toString()));
      }
      if ((jsonObj.get("postDirectionIntersection") != null && !jsonObj.get("postDirectionIntersection").isJsonNull()) && !jsonObj.get("postDirectionIntersection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postDirectionIntersection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postDirectionIntersection").toString()));
      }
      if ((jsonObj.get("postTown") != null && !jsonObj.get("postTown").isJsonNull()) && !jsonObj.get("postTown").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postTown` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postTown").toString()));
      }
      if ((jsonObj.get("preDirection") != null && !jsonObj.get("preDirection").isJsonNull()) && !jsonObj.get("preDirection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `preDirection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("preDirection").toString()));
      }
      if ((jsonObj.get("preDirectionIntersection") != null && !jsonObj.get("preDirectionIntersection").isJsonNull()) && !jsonObj.get("preDirectionIntersection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `preDirectionIntersection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("preDirectionIntersection").toString()));
      }
      if ((jsonObj.get("prefecture") != null && !jsonObj.get("prefecture").isJsonNull()) && !jsonObj.get("prefecture").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `prefecture` to be a primitive type in the JSON string but got `%s`", jsonObj.get("prefecture").toString()));
      }
      if ((jsonObj.get("quadrant") != null && !jsonObj.get("quadrant").isJsonNull()) && !jsonObj.get("quadrant").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quadrant` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quadrant").toString()));
      }
      if ((jsonObj.get("quarter") != null && !jsonObj.get("quarter").isJsonNull()) && !jsonObj.get("quarter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quarter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quarter").toString()));
      }
      if ((jsonObj.get("recipientName") != null && !jsonObj.get("recipientName").isJsonNull()) && !jsonObj.get("recipientName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recipientName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recipientName").toString()));
      }
      if ((jsonObj.get("sector") != null && !jsonObj.get("sector").isJsonNull()) && !jsonObj.get("sector").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sector` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sector").toString()));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      if ((jsonObj.get("streetName") != null && !jsonObj.get("streetName").isJsonNull()) && !jsonObj.get("streetName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streetName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streetName").toString()));
      }
      if ((jsonObj.get("streetNameIntersection") != null && !jsonObj.get("streetNameIntersection").isJsonNull()) && !jsonObj.get("streetNameIntersection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streetNameIntersection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streetNameIntersection").toString()));
      }
      if ((jsonObj.get("streetType") != null && !jsonObj.get("streetType").isJsonNull()) && !jsonObj.get("streetType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streetType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streetType").toString()));
      }
      if ((jsonObj.get("streetTypeIntersection") != null && !jsonObj.get("streetTypeIntersection").isJsonNull()) && !jsonObj.get("streetTypeIntersection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `streetTypeIntersection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("streetTypeIntersection").toString()));
      }
      if ((jsonObj.get("suiteNumber") != null && !jsonObj.get("suiteNumber").isJsonNull()) && !jsonObj.get("suiteNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `suiteNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("suiteNumber").toString()));
      }
      if ((jsonObj.get("suiteType") != null && !jsonObj.get("suiteType").isJsonNull()) && !jsonObj.get("suiteType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `suiteType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("suiteType").toString()));
      }
      if ((jsonObj.get("ward") != null && !jsonObj.get("ward").isJsonNull()) && !jsonObj.get("ward").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ward` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ward").toString()));
      }
      if ((jsonObj.get("zipCode") != null && !jsonObj.get("zipCode").isJsonNull()) && !jsonObj.get("zipCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zipCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zipCode").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Address.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Address' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Address> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Address.class));

       return (TypeAdapter<T>) new TypeAdapter<Address>() {
           @Override
           public void write(JsonWriter out, Address value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Address read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Address given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Address
   * @throws IOException if the JSON string is invalid with respect to Address
   */
  public static Address fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Address.class);
  }

  /**
   * Convert an instance of Address to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

