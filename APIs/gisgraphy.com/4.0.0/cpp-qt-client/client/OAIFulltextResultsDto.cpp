/**
 * Gisgraphy webservices
 * Since 2006, [Gisgraphy](http://www.gisgraphy.com) is a free, open source framework that offers the possibility to do geolocalisation and geocoding via Java APIs or REST webservices. Because geocoding is nothing without data, it provides an easy to use importer that will automatically download and import the necessary (free) data to your local database ([OpenStreetMap](http://www.openstreetmap.org/), [Geonames](http://www.geonames.org/) and [Quattroshapes](http://www.quattroshapes.com/): more than 100 million entries). You can also add your own data with the Web interface or the importer connectors provided. Gisgraphy is production ready, and has been designed to be scalable(load balanced), performant and used in other languages than just java : results can be output in XML, JSON, PHP, Python, Ruby, YAML, GeoRSS, and Atom. One of the most popular GPS tracking System (OpenGTS) also includes a Gisgraphy client...Gisgraphy is a framework. As a result it's flexible and powerful enough to be used in a lot of different use cases. [read more](http://www.gisgraphy.com)   if you use the premium servers, you can use the api key to test the webservices 
 *
 * The version of the OpenAPI document: 4.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIFulltextResultsDto.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIFulltextResultsDto::OAIFulltextResultsDto(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIFulltextResultsDto::OAIFulltextResultsDto() {
    this->initializeModel();
}

OAIFulltextResultsDto::~OAIFulltextResultsDto() {}

void OAIFulltextResultsDto::initializeModel() {

    m_q_time_isSet = false;
    m_q_time_isValid = false;

    m_max_score_isSet = false;
    m_max_score_isValid = false;

    m_message_isSet = false;
    m_message_isValid = false;

    m_num_found_isSet = false;
    m_num_found_isValid = false;

    m_result_isSet = false;
    m_result_isValid = false;

    m_results_size_isSet = false;
    m_results_size_isValid = false;
}

void OAIFulltextResultsDto::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIFulltextResultsDto::fromJsonObject(QJsonObject json) {

    m_q_time_isValid = ::OpenAPI::fromJsonValue(m_q_time, json[QString("QTime")]);
    m_q_time_isSet = !json[QString("QTime")].isNull() && m_q_time_isValid;

    m_max_score_isValid = ::OpenAPI::fromJsonValue(m_max_score, json[QString("maxScore")]);
    m_max_score_isSet = !json[QString("maxScore")].isNull() && m_max_score_isValid;

    m_message_isValid = ::OpenAPI::fromJsonValue(m_message, json[QString("message")]);
    m_message_isSet = !json[QString("message")].isNull() && m_message_isValid;

    m_num_found_isValid = ::OpenAPI::fromJsonValue(m_num_found, json[QString("numFound")]);
    m_num_found_isSet = !json[QString("numFound")].isNull() && m_num_found_isValid;

    m_result_isValid = ::OpenAPI::fromJsonValue(m_result, json[QString("result")]);
    m_result_isSet = !json[QString("result")].isNull() && m_result_isValid;

    m_results_size_isValid = ::OpenAPI::fromJsonValue(m_results_size, json[QString("resultsSize")]);
    m_results_size_isSet = !json[QString("resultsSize")].isNull() && m_results_size_isValid;
}

QString OAIFulltextResultsDto::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIFulltextResultsDto::asJsonObject() const {
    QJsonObject obj;
    if (m_q_time_isSet) {
        obj.insert(QString("QTime"), ::OpenAPI::toJsonValue(m_q_time));
    }
    if (m_max_score_isSet) {
        obj.insert(QString("maxScore"), ::OpenAPI::toJsonValue(m_max_score));
    }
    if (m_message_isSet) {
        obj.insert(QString("message"), ::OpenAPI::toJsonValue(m_message));
    }
    if (m_num_found_isSet) {
        obj.insert(QString("numFound"), ::OpenAPI::toJsonValue(m_num_found));
    }
    if (m_result.size() > 0) {
        obj.insert(QString("result"), ::OpenAPI::toJsonValue(m_result));
    }
    if (m_results_size_isSet) {
        obj.insert(QString("resultsSize"), ::OpenAPI::toJsonValue(m_results_size));
    }
    return obj;
}

qint64 OAIFulltextResultsDto::getQTime() const {
    return m_q_time;
}
void OAIFulltextResultsDto::setQTime(const qint64 &q_time) {
    m_q_time = q_time;
    m_q_time_isSet = true;
}

bool OAIFulltextResultsDto::is_q_time_Set() const{
    return m_q_time_isSet;
}

bool OAIFulltextResultsDto::is_q_time_Valid() const{
    return m_q_time_isValid;
}

float OAIFulltextResultsDto::getMaxScore() const {
    return m_max_score;
}
void OAIFulltextResultsDto::setMaxScore(const float &max_score) {
    m_max_score = max_score;
    m_max_score_isSet = true;
}

bool OAIFulltextResultsDto::is_max_score_Set() const{
    return m_max_score_isSet;
}

bool OAIFulltextResultsDto::is_max_score_Valid() const{
    return m_max_score_isValid;
}

QString OAIFulltextResultsDto::getMessage() const {
    return m_message;
}
void OAIFulltextResultsDto::setMessage(const QString &message) {
    m_message = message;
    m_message_isSet = true;
}

bool OAIFulltextResultsDto::is_message_Set() const{
    return m_message_isSet;
}

bool OAIFulltextResultsDto::is_message_Valid() const{
    return m_message_isValid;
}

qint32 OAIFulltextResultsDto::getNumFound() const {
    return m_num_found;
}
void OAIFulltextResultsDto::setNumFound(const qint32 &num_found) {
    m_num_found = num_found;
    m_num_found_isSet = true;
}

bool OAIFulltextResultsDto::is_num_found_Set() const{
    return m_num_found_isSet;
}

bool OAIFulltextResultsDto::is_num_found_Valid() const{
    return m_num_found_isValid;
}

QList<OAISolrResponseDto> OAIFulltextResultsDto::getResult() const {
    return m_result;
}
void OAIFulltextResultsDto::setResult(const QList<OAISolrResponseDto> &result) {
    m_result = result;
    m_result_isSet = true;
}

bool OAIFulltextResultsDto::is_result_Set() const{
    return m_result_isSet;
}

bool OAIFulltextResultsDto::is_result_Valid() const{
    return m_result_isValid;
}

qint32 OAIFulltextResultsDto::getResultsSize() const {
    return m_results_size;
}
void OAIFulltextResultsDto::setResultsSize(const qint32 &results_size) {
    m_results_size = results_size;
    m_results_size_isSet = true;
}

bool OAIFulltextResultsDto::is_results_size_Set() const{
    return m_results_size_isSet;
}

bool OAIFulltextResultsDto::is_results_size_Valid() const{
    return m_results_size_isValid;
}

bool OAIFulltextResultsDto::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_q_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_score_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_message_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_found_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_result.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_results_size_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIFulltextResultsDto::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
