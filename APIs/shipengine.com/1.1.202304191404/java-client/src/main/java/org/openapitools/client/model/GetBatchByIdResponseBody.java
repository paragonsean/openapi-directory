/*
 * ShipEngine API
 * ShipEngine's easy-to-use REST API lets you manage all of your shipping needs without worrying about the complexities of different carrier APIs and protocols. We handle all the heavy lifting so you can focus on providing a first-class shipping experience for your customers at the best possible prices.  Each of ShipEngine's features can be used by itself or in conjunction with each other to build powerful shipping functionality into your application or service.  ## Getting Started If you're new to REST APIs then be sure to read our [introduction to REST](https://www.shipengine.com/docs/rest/) to understand the basics.  Learn how to [authenticate yourself to ShipEngine](https://www.shipengine.com/docs/auth/), and then use our [sandbox environment](https://www.shipengine.com/docs/sandbox/) to kick the tires and get familiar with our API. If you run into any problems, then be sure to check the [error handling guide](https://www.shipengine.com/docs/errors/) for tips.  Here are some step-by-step **tutorials** to get you started:    - [Learn how to create your first shipping label](https://www.shipengine.com/docs/labels/create-a-label/)   - [Calculate shipping costs and compare rates across carriers](https://www.shipengine.com/docs/rates/)   - [Track packages on-demand or in real time](https://www.shipengine.com/docs/tracking/)   - [Validate mailing addresses anywhere on Earth](https://www.shipengine.com/docs/addresses/validation/)   ## Shipping Labels for Every Major Carrier ShipEngine makes it easy to [create shipping labels for any carrier](https://www.shipengine.com/docs/labels/create-a-label/) and [download them](https://www.shipengine.com/docs/labels/downloading/) in a [variety of file formats](https://www.shipengine.com/docs/labels/formats/). You can even customize labels with your own [messages](https://www.shipengine.com/docs/labels/messages/) and [images](https://www.shipengine.com/docs/labels/branding/).   ## Real-Time Package Tracking With ShipEngine you can [get the current status of a package](https://www.shipengine.com/docs/tracking/) or [subscribe to real-time tracking updates](https://www.shipengine.com/docs/tracking/webhooks/) via webhooks. You can also create [custimized tracking pages](https://www.shipengine.com/docs/tracking/branded-tracking-page/) with your own branding so your customers will always know where their package is.   ## Compare Shipping Costs Across Carriers Make sure you ship as cost-effectively as possible by [comparing rates across carriers](https://www.shipengine.com/docs/rates/get-shipment-rates/) using the ShipEngine Rates API. Or if you don't know the full shipment details yet, then you can [get rate estimates](https://www.shipengine.com/docs/rates/estimate/) with limited address info.   ## Worldwide Address Validation ShipEngine supports [address validation](https://www.shipengine.com/docs/addresses/validation/) for virtually [every country on Earth](https://www.shipengine.com/docs/addresses/validation/countries/), including the United States, Canada, Great Britain, Australia, Germany, France, Norway, Spain, Sweden, Israel, Italy, and over 160 others. 
 *
 * The version of the OpenAPI document: 1.1.202304191404
 * Contact: sales@shipengine.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.BatchStatus;
import org.openapitools.client.model.LabelDownload;
import org.openapitools.client.model.LabelFormat;
import org.openapitools.client.model.LabelLayout;
import org.openapitools.client.model.OptionalLink;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A get batch by id response body
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:20:16.939652-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GetBatchByIdResponseBody {
  public static final String SERIALIZED_NAME_BATCH_ERRORS_URL = "batch_errors_url";
  @SerializedName(SERIALIZED_NAME_BATCH_ERRORS_URL)
  private OptionalLink batchErrorsUrl;

  public static final String SERIALIZED_NAME_BATCH_ID = "batch_id";
  @SerializedName(SERIALIZED_NAME_BATCH_ID)
  private String batchId;

  public static final String SERIALIZED_NAME_BATCH_LABELS_URL = "batch_labels_url";
  @SerializedName(SERIALIZED_NAME_BATCH_LABELS_URL)
  private OptionalLink batchLabelsUrl;

  public static final String SERIALIZED_NAME_BATCH_NOTES = "batch_notes";
  @SerializedName(SERIALIZED_NAME_BATCH_NOTES)
  private String batchNotes = "";

  public static final String SERIALIZED_NAME_BATCH_NUMBER = "batch_number";
  @SerializedName(SERIALIZED_NAME_BATCH_NUMBER)
  private String batchNumber;

  public static final String SERIALIZED_NAME_BATCH_SHIPMENTS_URL = "batch_shipments_url";
  @SerializedName(SERIALIZED_NAME_BATCH_SHIPMENTS_URL)
  private OptionalLink batchShipmentsUrl;

  public static final String SERIALIZED_NAME_COMPLETED = "completed";
  @SerializedName(SERIALIZED_NAME_COMPLETED)
  private Integer completed;

  public static final String SERIALIZED_NAME_COUNT = "count";
  @SerializedName(SERIALIZED_NAME_COUNT)
  private Integer count;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_ERRORS = "errors";
  @SerializedName(SERIALIZED_NAME_ERRORS)
  private Integer errors;

  public static final String SERIALIZED_NAME_EXTERNAL_BATCH_ID = "external_batch_id";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_BATCH_ID)
  private String externalBatchId;

  public static final String SERIALIZED_NAME_FORM_DOWNLOAD = "form_download";
  @SerializedName(SERIALIZED_NAME_FORM_DOWNLOAD)
  private OptionalLink formDownload;

  public static final String SERIALIZED_NAME_FORMS = "forms";
  @SerializedName(SERIALIZED_NAME_FORMS)
  private Integer forms;

  public static final String SERIALIZED_NAME_LABEL_DOWNLOAD = "label_download";
  @SerializedName(SERIALIZED_NAME_LABEL_DOWNLOAD)
  private LabelDownload labelDownload;

  public static final String SERIALIZED_NAME_LABEL_FORMAT = "label_format";
  @SerializedName(SERIALIZED_NAME_LABEL_FORMAT)
  private LabelFormat labelFormat = LabelFormat.PDF;

  public static final String SERIALIZED_NAME_LABEL_LAYOUT = "label_layout";
  @SerializedName(SERIALIZED_NAME_LABEL_LAYOUT)
  private LabelLayout labelLayout = LabelLayout._4X6;

  public static final String SERIALIZED_NAME_PROCESSED_AT = "processed_at";
  @SerializedName(SERIALIZED_NAME_PROCESSED_AT)
  private OffsetDateTime processedAt;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private BatchStatus status;

  public static final String SERIALIZED_NAME_WARNINGS = "warnings";
  @SerializedName(SERIALIZED_NAME_WARNINGS)
  private Integer warnings;

  public GetBatchByIdResponseBody() {
  }

  public GetBatchByIdResponseBody(
     OptionalLink batchErrorsUrl, 
     String batchId, 
     String batchNotes, 
     String batchNumber, 
     Integer completed, 
     Integer count, 
     OffsetDateTime createdAt, 
     Integer errors, 
     String externalBatchId, 
     OptionalLink formDownload, 
     Integer forms, 
     LabelDownload labelDownload, 
     LabelFormat labelFormat, 
     LabelLayout labelLayout, 
     OffsetDateTime processedAt, 
     BatchStatus status, 
     Integer warnings
  ) {
    this();
    this.batchErrorsUrl = batchErrorsUrl;
    this.batchId = batchId;
    this.batchNotes = batchNotes;
    this.batchNumber = batchNumber;
    this.completed = completed;
    this.count = count;
    this.createdAt = createdAt;
    this.errors = errors;
    this.externalBatchId = externalBatchId;
    this.formDownload = formDownload;
    this.forms = forms;
    this.labelDownload = labelDownload;
    this.labelFormat = labelFormat;
    this.labelLayout = labelLayout;
    this.processedAt = processedAt;
    this.status = status;
    this.warnings = warnings;
  }

  /**
   * Link to batch errors endpoint
   * @return batchErrorsUrl
   */
  @javax.annotation.Nonnull
  public OptionalLink getBatchErrorsUrl() {
    return batchErrorsUrl;
  }



  /**
   * A string that uniquely identifies the batch
   * @return batchId
   */
  @javax.annotation.Nonnull
  public String getBatchId() {
    return batchId;
  }



  public GetBatchByIdResponseBody batchLabelsUrl(OptionalLink batchLabelsUrl) {
    this.batchLabelsUrl = batchLabelsUrl;
    return this;
  }

  /**
   * Link to batch labels query
   * @return batchLabelsUrl
   */
  @javax.annotation.Nonnull
  public OptionalLink getBatchLabelsUrl() {
    return batchLabelsUrl;
  }

  public void setBatchLabelsUrl(OptionalLink batchLabelsUrl) {
    this.batchLabelsUrl = batchLabelsUrl;
  }


  /**
   * Custom notes you can add for each created batch
   * @return batchNotes
   */
  @javax.annotation.Nullable
  public String getBatchNotes() {
    return batchNotes;
  }



  /**
   * The batch number.
   * @return batchNumber
   */
  @javax.annotation.Nonnull
  public String getBatchNumber() {
    return batchNumber;
  }



  public GetBatchByIdResponseBody batchShipmentsUrl(OptionalLink batchShipmentsUrl) {
    this.batchShipmentsUrl = batchShipmentsUrl;
    return this;
  }

  /**
   * The batch shipments endpoint
   * @return batchShipmentsUrl
   */
  @javax.annotation.Nonnull
  public OptionalLink getBatchShipmentsUrl() {
    return batchShipmentsUrl;
  }

  public void setBatchShipmentsUrl(OptionalLink batchShipmentsUrl) {
    this.batchShipmentsUrl = batchShipmentsUrl;
  }


  /**
   * The number of labels generated in the batch
   * minimum: 0
   * @return completed
   */
  @javax.annotation.Nonnull
  public Integer getCompleted() {
    return completed;
  }



  /**
   * The total of errors, warnings, and completed properties
   * minimum: 0
   * @return count
   */
  @javax.annotation.Nonnull
  public Integer getCount() {
    return count;
  }



  /**
   * The date and time the batch was created in ShipEngine
   * @return createdAt
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  /**
   * The number of errors that occurred while generating the batch
   * minimum: 0
   * @return errors
   */
  @javax.annotation.Nonnull
  public Integer getErrors() {
    return errors;
  }



  /**
   * A string that uniquely identifies the external batch
   * @return externalBatchId
   */
  @javax.annotation.Nullable
  public String getExternalBatchId() {
    return externalBatchId;
  }



  /**
   * The form download for any customs that are needed
   * @return formDownload
   */
  @javax.annotation.Nonnull
  public OptionalLink getFormDownload() {
    return formDownload;
  }



  /**
   * The number of forms for customs that are available for download
   * minimum: 0
   * @return forms
   */
  @javax.annotation.Nonnull
  public Integer getForms() {
    return forms;
  }



  /**
   * The label download for the batch
   * @return labelDownload
   */
  @javax.annotation.Nonnull
  public LabelDownload getLabelDownload() {
    return labelDownload;
  }



  /**
   * Get labelFormat
   * @return labelFormat
   */
  @javax.annotation.Nonnull
  public LabelFormat getLabelFormat() {
    return labelFormat;
  }



  /**
   * label layout
   * @return labelLayout
   */
  @javax.annotation.Nonnull
  public LabelLayout getLabelLayout() {
    return labelLayout;
  }



  /**
   * The date and time the batch was processed in ShipEngine
   * @return processedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getProcessedAt() {
    return processedAt;
  }



  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nonnull
  public BatchStatus getStatus() {
    return status;
  }



  /**
   * The number of warnings that occurred while generating the batch
   * minimum: 0
   * @return warnings
   */
  @javax.annotation.Nonnull
  public Integer getWarnings() {
    return warnings;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GetBatchByIdResponseBody getBatchByIdResponseBody = (GetBatchByIdResponseBody) o;
    return Objects.equals(this.batchErrorsUrl, getBatchByIdResponseBody.batchErrorsUrl) &&
        Objects.equals(this.batchId, getBatchByIdResponseBody.batchId) &&
        Objects.equals(this.batchLabelsUrl, getBatchByIdResponseBody.batchLabelsUrl) &&
        Objects.equals(this.batchNotes, getBatchByIdResponseBody.batchNotes) &&
        Objects.equals(this.batchNumber, getBatchByIdResponseBody.batchNumber) &&
        Objects.equals(this.batchShipmentsUrl, getBatchByIdResponseBody.batchShipmentsUrl) &&
        Objects.equals(this.completed, getBatchByIdResponseBody.completed) &&
        Objects.equals(this.count, getBatchByIdResponseBody.count) &&
        Objects.equals(this.createdAt, getBatchByIdResponseBody.createdAt) &&
        Objects.equals(this.errors, getBatchByIdResponseBody.errors) &&
        Objects.equals(this.externalBatchId, getBatchByIdResponseBody.externalBatchId) &&
        Objects.equals(this.formDownload, getBatchByIdResponseBody.formDownload) &&
        Objects.equals(this.forms, getBatchByIdResponseBody.forms) &&
        Objects.equals(this.labelDownload, getBatchByIdResponseBody.labelDownload) &&
        Objects.equals(this.labelFormat, getBatchByIdResponseBody.labelFormat) &&
        Objects.equals(this.labelLayout, getBatchByIdResponseBody.labelLayout) &&
        Objects.equals(this.processedAt, getBatchByIdResponseBody.processedAt) &&
        Objects.equals(this.status, getBatchByIdResponseBody.status) &&
        Objects.equals(this.warnings, getBatchByIdResponseBody.warnings);
  }

  @Override
  public int hashCode() {
    return Objects.hash(batchErrorsUrl, batchId, batchLabelsUrl, batchNotes, batchNumber, batchShipmentsUrl, completed, count, createdAt, errors, externalBatchId, formDownload, forms, labelDownload, labelFormat, labelLayout, processedAt, status, warnings);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GetBatchByIdResponseBody {\n");
    sb.append("    batchErrorsUrl: ").append(toIndentedString(batchErrorsUrl)).append("\n");
    sb.append("    batchId: ").append(toIndentedString(batchId)).append("\n");
    sb.append("    batchLabelsUrl: ").append(toIndentedString(batchLabelsUrl)).append("\n");
    sb.append("    batchNotes: ").append(toIndentedString(batchNotes)).append("\n");
    sb.append("    batchNumber: ").append(toIndentedString(batchNumber)).append("\n");
    sb.append("    batchShipmentsUrl: ").append(toIndentedString(batchShipmentsUrl)).append("\n");
    sb.append("    completed: ").append(toIndentedString(completed)).append("\n");
    sb.append("    count: ").append(toIndentedString(count)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    errors: ").append(toIndentedString(errors)).append("\n");
    sb.append("    externalBatchId: ").append(toIndentedString(externalBatchId)).append("\n");
    sb.append("    formDownload: ").append(toIndentedString(formDownload)).append("\n");
    sb.append("    forms: ").append(toIndentedString(forms)).append("\n");
    sb.append("    labelDownload: ").append(toIndentedString(labelDownload)).append("\n");
    sb.append("    labelFormat: ").append(toIndentedString(labelFormat)).append("\n");
    sb.append("    labelLayout: ").append(toIndentedString(labelLayout)).append("\n");
    sb.append("    processedAt: ").append(toIndentedString(processedAt)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    warnings: ").append(toIndentedString(warnings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("batch_errors_url");
    openapiFields.add("batch_id");
    openapiFields.add("batch_labels_url");
    openapiFields.add("batch_notes");
    openapiFields.add("batch_number");
    openapiFields.add("batch_shipments_url");
    openapiFields.add("completed");
    openapiFields.add("count");
    openapiFields.add("created_at");
    openapiFields.add("errors");
    openapiFields.add("external_batch_id");
    openapiFields.add("form_download");
    openapiFields.add("forms");
    openapiFields.add("label_download");
    openapiFields.add("label_format");
    openapiFields.add("label_layout");
    openapiFields.add("processed_at");
    openapiFields.add("status");
    openapiFields.add("warnings");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("batch_errors_url");
    openapiRequiredFields.add("batch_id");
    openapiRequiredFields.add("batch_labels_url");
    openapiRequiredFields.add("batch_notes");
    openapiRequiredFields.add("batch_number");
    openapiRequiredFields.add("batch_shipments_url");
    openapiRequiredFields.add("completed");
    openapiRequiredFields.add("count");
    openapiRequiredFields.add("created_at");
    openapiRequiredFields.add("errors");
    openapiRequiredFields.add("external_batch_id");
    openapiRequiredFields.add("form_download");
    openapiRequiredFields.add("forms");
    openapiRequiredFields.add("label_download");
    openapiRequiredFields.add("label_format");
    openapiRequiredFields.add("label_layout");
    openapiRequiredFields.add("processed_at");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("warnings");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GetBatchByIdResponseBody
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GetBatchByIdResponseBody.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GetBatchByIdResponseBody is not found in the empty JSON string", GetBatchByIdResponseBody.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GetBatchByIdResponseBody.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GetBatchByIdResponseBody` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : GetBatchByIdResponseBody.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `batch_errors_url`
      OptionalLink.validateJsonElement(jsonObj.get("batch_errors_url"));
      if (!jsonObj.get("batch_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `batch_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("batch_id").toString()));
      }
      // validate the required field `batch_labels_url`
      OptionalLink.validateJsonElement(jsonObj.get("batch_labels_url"));
      if ((jsonObj.get("batch_notes") != null && !jsonObj.get("batch_notes").isJsonNull()) && !jsonObj.get("batch_notes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `batch_notes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("batch_notes").toString()));
      }
      if (!jsonObj.get("batch_number").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `batch_number` to be a primitive type in the JSON string but got `%s`", jsonObj.get("batch_number").toString()));
      }
      // validate the required field `batch_shipments_url`
      OptionalLink.validateJsonElement(jsonObj.get("batch_shipments_url"));
      if ((jsonObj.get("external_batch_id") != null && !jsonObj.get("external_batch_id").isJsonNull()) && !jsonObj.get("external_batch_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `external_batch_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("external_batch_id").toString()));
      }
      // validate the required field `form_download`
      OptionalLink.validateJsonElement(jsonObj.get("form_download"));
      // validate the required field `label_download`
      LabelDownload.validateJsonElement(jsonObj.get("label_download"));
      // validate the required field `label_format`
      LabelFormat.validateJsonElement(jsonObj.get("label_format"));
      // validate the required field `label_layout`
      LabelLayout.validateJsonElement(jsonObj.get("label_layout"));
      // validate the required field `status`
      BatchStatus.validateJsonElement(jsonObj.get("status"));
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GetBatchByIdResponseBody.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GetBatchByIdResponseBody' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GetBatchByIdResponseBody> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GetBatchByIdResponseBody.class));

       return (TypeAdapter<T>) new TypeAdapter<GetBatchByIdResponseBody>() {
           @Override
           public void write(JsonWriter out, GetBatchByIdResponseBody value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GetBatchByIdResponseBody read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GetBatchByIdResponseBody given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GetBatchByIdResponseBody
   * @throws IOException if the JSON string is invalid with respect to GetBatchByIdResponseBody
   */
  public static GetBatchByIdResponseBody fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GetBatchByIdResponseBody.class);
  }

  /**
   * Convert an instance of GetBatchByIdResponseBody to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

