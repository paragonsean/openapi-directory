/**
 * Eqivo API
 * Eqivo OpenApi Specification
 *
 * The version of the OpenAPI document: v0.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICallApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAICallApi::OAICallApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAICallApi::~OAICallApi() {
}

void OAICallApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://raw.github.com/rtckit/media/master/eqivo/readme-splash.png"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("v01BulkCallPost", defaultConf);
    _serverIndices.insert("v01BulkCallPost", 0);
    _serverConfigs.insert("v01CallPost", defaultConf);
    _serverIndices.insert("v01CallPost", 0);
    _serverConfigs.insert("v01CancelScheduledHangupPost", defaultConf);
    _serverIndices.insert("v01CancelScheduledHangupPost", 0);
    _serverConfigs.insert("v01CancelScheduledPlayPost", defaultConf);
    _serverIndices.insert("v01CancelScheduledPlayPost", 0);
    _serverConfigs.insert("v01GroupCallPost", defaultConf);
    _serverIndices.insert("v01GroupCallPost", 0);
    _serverConfigs.insert("v01HangupAllCallsPost", defaultConf);
    _serverIndices.insert("v01HangupAllCallsPost", 0);
    _serverConfigs.insert("v01HangupCallPost", defaultConf);
    _serverIndices.insert("v01HangupCallPost", 0);
    _serverConfigs.insert("v01PlayPost", defaultConf);
    _serverIndices.insert("v01PlayPost", 0);
    _serverConfigs.insert("v01PlayStopPost", defaultConf);
    _serverIndices.insert("v01PlayStopPost", 0);
    _serverConfigs.insert("v01RecordStartPost", defaultConf);
    _serverIndices.insert("v01RecordStartPost", 0);
    _serverConfigs.insert("v01RecordStopPost", defaultConf);
    _serverIndices.insert("v01RecordStopPost", 0);
    _serverConfigs.insert("v01ScheduleHangupPost", defaultConf);
    _serverIndices.insert("v01ScheduleHangupPost", 0);
    _serverConfigs.insert("v01SchedulePlayPost", defaultConf);
    _serverIndices.insert("v01SchedulePlayPost", 0);
    _serverConfigs.insert("v01SendDigitsPost", defaultConf);
    _serverIndices.insert("v01SendDigitsPost", 0);
    _serverConfigs.insert("v01SoundTouchPost", defaultConf);
    _serverIndices.insert("v01SoundTouchPost", 0);
    _serverConfigs.insert("v01SoundTouchStopPost", defaultConf);
    _serverIndices.insert("v01SoundTouchStopPost", 0);
    _serverConfigs.insert("v01TransferCallPost", defaultConf);
    _serverIndices.insert("v01TransferCallPost", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAICallApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAICallApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAICallApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAICallApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAICallApi::setUsername(const QString &username) {
    _username = username;
}

void OAICallApi::setPassword(const QString &password) {
    _password = password;
}


void OAICallApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAICallApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAICallApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAICallApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAICallApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAICallApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAICallApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAICallApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAICallApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAICallApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAICallApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAICallApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAICallApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAICallApi::v01BulkCallPost(const QString &answer_url, const QString &delimiter, const QString &from, const QString &gateways, const QString &to, const ::OpenAPI::OptionalParam<QString> &caller_name, const ::OpenAPI::OptionalParam<QString> &confirm_key, const ::OpenAPI::OptionalParam<QString> &confirm_sound, const ::OpenAPI::OptionalParam<QString> &core_uuid, const ::OpenAPI::OptionalParam<QString> &extra_dial_string, const ::OpenAPI::OptionalParam<QString> &gateway_codecs, const ::OpenAPI::OptionalParam<QString> &gateway_retries, const ::OpenAPI::OptionalParam<QString> &gateway_timeouts, const ::OpenAPI::OptionalParam<qint32> &hangup_on_ring, const ::OpenAPI::OptionalParam<QString> &hangup_url, const ::OpenAPI::OptionalParam<QString> &reject_causes, const ::OpenAPI::OptionalParam<QString> &ring_url, const ::OpenAPI::OptionalParam<QString> &send_digits, const ::OpenAPI::OptionalParam<bool> &send_on_preanswer, const ::OpenAPI::OptionalParam<qint32> &time_limit) {
    QString fullPath = QString(_serverConfigs["v01BulkCallPost"][_serverIndices.value("v01BulkCallPost")].URL()+"/v0.1/BulkCall/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("AnswerUrl", ::OpenAPI::toStringValue(answer_url));
    }
    if (caller_name.hasValue())
    {
        input.add_var("CallerName", ::OpenAPI::toStringValue(caller_name.value()));
    }
    if (confirm_key.hasValue())
    {
        input.add_var("ConfirmKey", ::OpenAPI::toStringValue(confirm_key.value()));
    }
    if (confirm_sound.hasValue())
    {
        input.add_var("ConfirmSound", ::OpenAPI::toStringValue(confirm_sound.value()));
    }
    if (core_uuid.hasValue())
    {
        input.add_var("CoreUUID", ::OpenAPI::toStringValue(core_uuid.value()));
    }
    
    {
        input.add_var("Delimiter", ::OpenAPI::toStringValue(delimiter));
    }
    if (extra_dial_string.hasValue())
    {
        input.add_var("ExtraDialString", ::OpenAPI::toStringValue(extra_dial_string.value()));
    }
    
    {
        input.add_var("From", ::OpenAPI::toStringValue(from));
    }
    if (gateway_codecs.hasValue())
    {
        input.add_var("GatewayCodecs", ::OpenAPI::toStringValue(gateway_codecs.value()));
    }
    if (gateway_retries.hasValue())
    {
        input.add_var("GatewayRetries", ::OpenAPI::toStringValue(gateway_retries.value()));
    }
    if (gateway_timeouts.hasValue())
    {
        input.add_var("GatewayTimeouts", ::OpenAPI::toStringValue(gateway_timeouts.value()));
    }
    
    {
        input.add_var("Gateways", ::OpenAPI::toStringValue(gateways));
    }
    if (hangup_on_ring.hasValue())
    {
        input.add_var("HangupOnRing", ::OpenAPI::toStringValue(hangup_on_ring.value()));
    }
    if (hangup_url.hasValue())
    {
        input.add_var("HangupUrl", ::OpenAPI::toStringValue(hangup_url.value()));
    }
    if (reject_causes.hasValue())
    {
        input.add_var("RejectCauses", ::OpenAPI::toStringValue(reject_causes.value()));
    }
    if (ring_url.hasValue())
    {
        input.add_var("RingUrl", ::OpenAPI::toStringValue(ring_url.value()));
    }
    if (send_digits.hasValue())
    {
        input.add_var("SendDigits", ::OpenAPI::toStringValue(send_digits.value()));
    }
    if (send_on_preanswer.hasValue())
    {
        input.add_var("SendOnPreanswer", ::OpenAPI::toStringValue(send_on_preanswer.value()));
    }
    if (time_limit.hasValue())
    {
        input.add_var("TimeLimit", ::OpenAPI::toStringValue(time_limit.value()));
    }
    
    {
        input.add_var("To", ::OpenAPI::toStringValue(to));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01BulkCallPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01BulkCallPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBulkCallResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01BulkCallPostSignal(output);
        Q_EMIT v01BulkCallPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01BulkCallPostSignalE(output, error_type, error_str);
        Q_EMIT v01BulkCallPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01BulkCallPostSignalError(output, error_type, error_str);
        Q_EMIT v01BulkCallPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01CallPost(const QString &answer_url, const QString &from, const QString &gateways, const QString &to, const ::OpenAPI::OptionalParam<bool> &async_amd, const ::OpenAPI::OptionalParam<QString> &async_amd_status_callback, const ::OpenAPI::OptionalParam<QString> &async_amd_status_callback_method, const ::OpenAPI::OptionalParam<QString> &caller_name, const ::OpenAPI::OptionalParam<QString> &core_uuid, const ::OpenAPI::OptionalParam<QString> &extra_dial_string, const ::OpenAPI::OptionalParam<QString> &gateway_codecs, const ::OpenAPI::OptionalParam<QString> &gateway_retries, const ::OpenAPI::OptionalParam<QString> &gateway_timeouts, const ::OpenAPI::OptionalParam<qint32> &hangup_on_ring, const ::OpenAPI::OptionalParam<QString> &hangup_url, const ::OpenAPI::OptionalParam<QString> &machine_detection, const ::OpenAPI::OptionalParam<qint32> &machine_detection_silence_timeout, const ::OpenAPI::OptionalParam<qint32> &machine_detection_speech_end_threshold, const ::OpenAPI::OptionalParam<qint32> &machine_detection_speech_threshold, const ::OpenAPI::OptionalParam<qint32> &machine_detection_timeout, const ::OpenAPI::OptionalParam<QString> &ring_url, const ::OpenAPI::OptionalParam<QString> &send_digits, const ::OpenAPI::OptionalParam<bool> &send_on_preanswer, const ::OpenAPI::OptionalParam<qint32> &time_limit) {
    QString fullPath = QString(_serverConfigs["v01CallPost"][_serverIndices.value("v01CallPost")].URL()+"/v0.1/Call/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("AnswerUrl", ::OpenAPI::toStringValue(answer_url));
    }
    if (async_amd.hasValue())
    {
        input.add_var("AsyncAMD", ::OpenAPI::toStringValue(async_amd.value()));
    }
    if (async_amd_status_callback.hasValue())
    {
        input.add_var("AsyncAmdStatusCallback", ::OpenAPI::toStringValue(async_amd_status_callback.value()));
    }
    if (async_amd_status_callback_method.hasValue())
    {
        input.add_var("AsyncAmdStatusCallbackMethod", ::OpenAPI::toStringValue(async_amd_status_callback_method.value()));
    }
    if (caller_name.hasValue())
    {
        input.add_var("CallerName", ::OpenAPI::toStringValue(caller_name.value()));
    }
    if (core_uuid.hasValue())
    {
        input.add_var("CoreUUID", ::OpenAPI::toStringValue(core_uuid.value()));
    }
    if (extra_dial_string.hasValue())
    {
        input.add_var("ExtraDialString", ::OpenAPI::toStringValue(extra_dial_string.value()));
    }
    
    {
        input.add_var("From", ::OpenAPI::toStringValue(from));
    }
    if (gateway_codecs.hasValue())
    {
        input.add_var("GatewayCodecs", ::OpenAPI::toStringValue(gateway_codecs.value()));
    }
    if (gateway_retries.hasValue())
    {
        input.add_var("GatewayRetries", ::OpenAPI::toStringValue(gateway_retries.value()));
    }
    if (gateway_timeouts.hasValue())
    {
        input.add_var("GatewayTimeouts", ::OpenAPI::toStringValue(gateway_timeouts.value()));
    }
    
    {
        input.add_var("Gateways", ::OpenAPI::toStringValue(gateways));
    }
    if (hangup_on_ring.hasValue())
    {
        input.add_var("HangupOnRing", ::OpenAPI::toStringValue(hangup_on_ring.value()));
    }
    if (hangup_url.hasValue())
    {
        input.add_var("HangupUrl", ::OpenAPI::toStringValue(hangup_url.value()));
    }
    if (machine_detection.hasValue())
    {
        input.add_var("MachineDetection", ::OpenAPI::toStringValue(machine_detection.value()));
    }
    if (machine_detection_silence_timeout.hasValue())
    {
        input.add_var("MachineDetectionSilenceTimeout", ::OpenAPI::toStringValue(machine_detection_silence_timeout.value()));
    }
    if (machine_detection_speech_end_threshold.hasValue())
    {
        input.add_var("MachineDetectionSpeechEndThreshold", ::OpenAPI::toStringValue(machine_detection_speech_end_threshold.value()));
    }
    if (machine_detection_speech_threshold.hasValue())
    {
        input.add_var("MachineDetectionSpeechThreshold", ::OpenAPI::toStringValue(machine_detection_speech_threshold.value()));
    }
    if (machine_detection_timeout.hasValue())
    {
        input.add_var("MachineDetectionTimeout", ::OpenAPI::toStringValue(machine_detection_timeout.value()));
    }
    if (ring_url.hasValue())
    {
        input.add_var("RingUrl", ::OpenAPI::toStringValue(ring_url.value()));
    }
    if (send_digits.hasValue())
    {
        input.add_var("SendDigits", ::OpenAPI::toStringValue(send_digits.value()));
    }
    if (send_on_preanswer.hasValue())
    {
        input.add_var("SendOnPreanswer", ::OpenAPI::toStringValue(send_on_preanswer.value()));
    }
    if (time_limit.hasValue())
    {
        input.add_var("TimeLimit", ::OpenAPI::toStringValue(time_limit.value()));
    }
    
    {
        input.add_var("To", ::OpenAPI::toStringValue(to));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01CallPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01CallPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICallResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01CallPostSignal(output);
        Q_EMIT v01CallPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01CallPostSignalE(output, error_type, error_str);
        Q_EMIT v01CallPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01CallPostSignalError(output, error_type, error_str);
        Q_EMIT v01CallPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01CancelScheduledHangupPost(const QString &sched_hangup_id) {
    QString fullPath = QString(_serverConfigs["v01CancelScheduledHangupPost"][_serverIndices.value("v01CancelScheduledHangupPost")].URL()+"/v0.1/CancelScheduledHangup/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("SchedHangupId", ::OpenAPI::toStringValue(sched_hangup_id));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01CancelScheduledHangupPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01CancelScheduledHangupPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICancelScheduledHangupResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01CancelScheduledHangupPostSignal(output);
        Q_EMIT v01CancelScheduledHangupPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01CancelScheduledHangupPostSignalE(output, error_type, error_str);
        Q_EMIT v01CancelScheduledHangupPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01CancelScheduledHangupPostSignalError(output, error_type, error_str);
        Q_EMIT v01CancelScheduledHangupPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01CancelScheduledPlayPost(const QString &sched_play_id) {
    QString fullPath = QString(_serverConfigs["v01CancelScheduledPlayPost"][_serverIndices.value("v01CancelScheduledPlayPost")].URL()+"/v0.1/CancelScheduledPlay/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("SchedPlayId", ::OpenAPI::toStringValue(sched_play_id));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01CancelScheduledPlayPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01CancelScheduledPlayPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICancelScheduledPlayResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01CancelScheduledPlayPostSignal(output);
        Q_EMIT v01CancelScheduledPlayPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01CancelScheduledPlayPostSignalE(output, error_type, error_str);
        Q_EMIT v01CancelScheduledPlayPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01CancelScheduledPlayPostSignalError(output, error_type, error_str);
        Q_EMIT v01CancelScheduledPlayPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01GroupCallPost(const QString &answer_url, const QString &delimiter, const QString &from, const QString &gateways, const QString &to, const ::OpenAPI::OptionalParam<QString> &caller_name, const ::OpenAPI::OptionalParam<QString> &confirm_key, const ::OpenAPI::OptionalParam<QString> &confirm_sound, const ::OpenAPI::OptionalParam<QString> &core_uuid, const ::OpenAPI::OptionalParam<QString> &extra_dial_string, const ::OpenAPI::OptionalParam<QString> &gateway_codecs, const ::OpenAPI::OptionalParam<QString> &gateway_retries, const ::OpenAPI::OptionalParam<QString> &gateway_timeouts, const ::OpenAPI::OptionalParam<qint32> &hangup_on_ring, const ::OpenAPI::OptionalParam<QString> &hangup_url, const ::OpenAPI::OptionalParam<QString> &reject_causes, const ::OpenAPI::OptionalParam<QString> &ring_url, const ::OpenAPI::OptionalParam<QString> &send_digits, const ::OpenAPI::OptionalParam<bool> &send_on_preanswer, const ::OpenAPI::OptionalParam<qint32> &time_limit) {
    QString fullPath = QString(_serverConfigs["v01GroupCallPost"][_serverIndices.value("v01GroupCallPost")].URL()+"/v0.1/GroupCall/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("AnswerUrl", ::OpenAPI::toStringValue(answer_url));
    }
    if (caller_name.hasValue())
    {
        input.add_var("CallerName", ::OpenAPI::toStringValue(caller_name.value()));
    }
    if (confirm_key.hasValue())
    {
        input.add_var("ConfirmKey", ::OpenAPI::toStringValue(confirm_key.value()));
    }
    if (confirm_sound.hasValue())
    {
        input.add_var("ConfirmSound", ::OpenAPI::toStringValue(confirm_sound.value()));
    }
    if (core_uuid.hasValue())
    {
        input.add_var("CoreUUID", ::OpenAPI::toStringValue(core_uuid.value()));
    }
    
    {
        input.add_var("Delimiter", ::OpenAPI::toStringValue(delimiter));
    }
    if (extra_dial_string.hasValue())
    {
        input.add_var("ExtraDialString", ::OpenAPI::toStringValue(extra_dial_string.value()));
    }
    
    {
        input.add_var("From", ::OpenAPI::toStringValue(from));
    }
    if (gateway_codecs.hasValue())
    {
        input.add_var("GatewayCodecs", ::OpenAPI::toStringValue(gateway_codecs.value()));
    }
    if (gateway_retries.hasValue())
    {
        input.add_var("GatewayRetries", ::OpenAPI::toStringValue(gateway_retries.value()));
    }
    if (gateway_timeouts.hasValue())
    {
        input.add_var("GatewayTimeouts", ::OpenAPI::toStringValue(gateway_timeouts.value()));
    }
    
    {
        input.add_var("Gateways", ::OpenAPI::toStringValue(gateways));
    }
    if (hangup_on_ring.hasValue())
    {
        input.add_var("HangupOnRing", ::OpenAPI::toStringValue(hangup_on_ring.value()));
    }
    if (hangup_url.hasValue())
    {
        input.add_var("HangupUrl", ::OpenAPI::toStringValue(hangup_url.value()));
    }
    if (reject_causes.hasValue())
    {
        input.add_var("RejectCauses", ::OpenAPI::toStringValue(reject_causes.value()));
    }
    if (ring_url.hasValue())
    {
        input.add_var("RingUrl", ::OpenAPI::toStringValue(ring_url.value()));
    }
    if (send_digits.hasValue())
    {
        input.add_var("SendDigits", ::OpenAPI::toStringValue(send_digits.value()));
    }
    if (send_on_preanswer.hasValue())
    {
        input.add_var("SendOnPreanswer", ::OpenAPI::toStringValue(send_on_preanswer.value()));
    }
    if (time_limit.hasValue())
    {
        input.add_var("TimeLimit", ::OpenAPI::toStringValue(time_limit.value()));
    }
    
    {
        input.add_var("To", ::OpenAPI::toStringValue(to));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01GroupCallPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01GroupCallPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGroupCallResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01GroupCallPostSignal(output);
        Q_EMIT v01GroupCallPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01GroupCallPostSignalE(output, error_type, error_str);
        Q_EMIT v01GroupCallPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01GroupCallPostSignalError(output, error_type, error_str);
        Q_EMIT v01GroupCallPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01HangupAllCallsPost() {
    QString fullPath = QString(_serverConfigs["v01HangupAllCallsPost"][_serverIndices.value("v01HangupAllCallsPost")].URL()+"/v0.1/HangupAllCalls/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01HangupAllCallsPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01HangupAllCallsPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHangupAllCallsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01HangupAllCallsPostSignal(output);
        Q_EMIT v01HangupAllCallsPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01HangupAllCallsPostSignalE(output, error_type, error_str);
        Q_EMIT v01HangupAllCallsPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01HangupAllCallsPostSignalError(output, error_type, error_str);
        Q_EMIT v01HangupAllCallsPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01HangupCallPost(const ::OpenAPI::OptionalParam<QString> &call_uuid, const ::OpenAPI::OptionalParam<QString> &request_uuid) {
    QString fullPath = QString(_serverConfigs["v01HangupCallPost"][_serverIndices.value("v01HangupCallPost")].URL()+"/v0.1/HangupCall/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (call_uuid.hasValue())
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid.value()));
    }
    if (request_uuid.hasValue())
    {
        input.add_var("RequestUUID", ::OpenAPI::toStringValue(request_uuid.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01HangupCallPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01HangupCallPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHangupCallResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01HangupCallPostSignal(output);
        Q_EMIT v01HangupCallPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01HangupCallPostSignalE(output, error_type, error_str);
        Q_EMIT v01HangupCallPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01HangupCallPostSignalError(output, error_type, error_str);
        Q_EMIT v01HangupCallPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01PlayPost(const QString &call_uuid, const QString &sounds, const ::OpenAPI::OptionalParam<QString> &legs, const ::OpenAPI::OptionalParam<qint32> &length, const ::OpenAPI::OptionalParam<bool> &loop, const ::OpenAPI::OptionalParam<bool> &mix) {
    QString fullPath = QString(_serverConfigs["v01PlayPost"][_serverIndices.value("v01PlayPost")].URL()+"/v0.1/Play/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid));
    }
    if (legs.hasValue())
    {
        input.add_var("Legs", ::OpenAPI::toStringValue(legs.value()));
    }
    if (length.hasValue())
    {
        input.add_var("Length", ::OpenAPI::toStringValue(length.value()));
    }
    if (loop.hasValue())
    {
        input.add_var("Loop", ::OpenAPI::toStringValue(loop.value()));
    }
    if (mix.hasValue())
    {
        input.add_var("Mix", ::OpenAPI::toStringValue(mix.value()));
    }
    
    {
        input.add_var("Sounds", ::OpenAPI::toStringValue(sounds));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01PlayPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01PlayPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPlayResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01PlayPostSignal(output);
        Q_EMIT v01PlayPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01PlayPostSignalE(output, error_type, error_str);
        Q_EMIT v01PlayPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01PlayPostSignalError(output, error_type, error_str);
        Q_EMIT v01PlayPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01PlayStopPost(const QString &call_uuid) {
    QString fullPath = QString(_serverConfigs["v01PlayStopPost"][_serverIndices.value("v01PlayStopPost")].URL()+"/v0.1/PlayStop/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01PlayStopPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01PlayStopPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPlayStopResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01PlayStopPostSignal(output);
        Q_EMIT v01PlayStopPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01PlayStopPostSignalE(output, error_type, error_str);
        Q_EMIT v01PlayStopPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01PlayStopPostSignalError(output, error_type, error_str);
        Q_EMIT v01PlayStopPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01RecordStartPost(const ::OpenAPI::OptionalParam<QString> &call_uuid, const ::OpenAPI::OptionalParam<QString> &file_format, const ::OpenAPI::OptionalParam<QString> &file_name, const ::OpenAPI::OptionalParam<QString> &file_path, const ::OpenAPI::OptionalParam<qint32> &time_limit) {
    QString fullPath = QString(_serverConfigs["v01RecordStartPost"][_serverIndices.value("v01RecordStartPost")].URL()+"/v0.1/RecordStart/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (call_uuid.hasValue())
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid.value()));
    }
    if (file_format.hasValue())
    {
        input.add_var("FileFormat", ::OpenAPI::toStringValue(file_format.value()));
    }
    if (file_name.hasValue())
    {
        input.add_var("FileName", ::OpenAPI::toStringValue(file_name.value()));
    }
    if (file_path.hasValue())
    {
        input.add_var("FilePath", ::OpenAPI::toStringValue(file_path.value()));
    }
    if (time_limit.hasValue())
    {
        input.add_var("TimeLimit", ::OpenAPI::toStringValue(time_limit.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01RecordStartPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01RecordStartPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIRecordStartResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01RecordStartPostSignal(output);
        Q_EMIT v01RecordStartPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01RecordStartPostSignalE(output, error_type, error_str);
        Q_EMIT v01RecordStartPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01RecordStartPostSignalError(output, error_type, error_str);
        Q_EMIT v01RecordStartPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01RecordStopPost(const QString &call_uuid, const QString &record_file) {
    QString fullPath = QString(_serverConfigs["v01RecordStopPost"][_serverIndices.value("v01RecordStopPost")].URL()+"/v0.1/RecordStop/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid));
    }
    
    {
        input.add_var("RecordFile", ::OpenAPI::toStringValue(record_file));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01RecordStopPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01RecordStopPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIRecordStopResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01RecordStopPostSignal(output);
        Q_EMIT v01RecordStopPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01RecordStopPostSignalE(output, error_type, error_str);
        Q_EMIT v01RecordStopPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01RecordStopPostSignalError(output, error_type, error_str);
        Q_EMIT v01RecordStopPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01ScheduleHangupPost(const QString &call_uuid, const qint32 &time) {
    QString fullPath = QString(_serverConfigs["v01ScheduleHangupPost"][_serverIndices.value("v01ScheduleHangupPost")].URL()+"/v0.1/ScheduleHangup/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid));
    }
    
    {
        input.add_var("Time", ::OpenAPI::toStringValue(time));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01ScheduleHangupPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01ScheduleHangupPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIScheduleHangupResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01ScheduleHangupPostSignal(output);
        Q_EMIT v01ScheduleHangupPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01ScheduleHangupPostSignalE(output, error_type, error_str);
        Q_EMIT v01ScheduleHangupPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01ScheduleHangupPostSignalError(output, error_type, error_str);
        Q_EMIT v01ScheduleHangupPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01SchedulePlayPost(const QString &call_uuid, const QString &sounds, const qint32 &time, const ::OpenAPI::OptionalParam<QString> &legs, const ::OpenAPI::OptionalParam<qint32> &length, const ::OpenAPI::OptionalParam<bool> &loop, const ::OpenAPI::OptionalParam<bool> &mix) {
    QString fullPath = QString(_serverConfigs["v01SchedulePlayPost"][_serverIndices.value("v01SchedulePlayPost")].URL()+"/v0.1/SchedulePlay/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid));
    }
    if (legs.hasValue())
    {
        input.add_var("Legs", ::OpenAPI::toStringValue(legs.value()));
    }
    if (length.hasValue())
    {
        input.add_var("Length", ::OpenAPI::toStringValue(length.value()));
    }
    if (loop.hasValue())
    {
        input.add_var("Loop", ::OpenAPI::toStringValue(loop.value()));
    }
    if (mix.hasValue())
    {
        input.add_var("Mix", ::OpenAPI::toStringValue(mix.value()));
    }
    
    {
        input.add_var("Sounds", ::OpenAPI::toStringValue(sounds));
    }
    
    {
        input.add_var("Time", ::OpenAPI::toStringValue(time));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01SchedulePlayPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01SchedulePlayPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISchedulePlayResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01SchedulePlayPostSignal(output);
        Q_EMIT v01SchedulePlayPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01SchedulePlayPostSignalE(output, error_type, error_str);
        Q_EMIT v01SchedulePlayPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01SchedulePlayPostSignalError(output, error_type, error_str);
        Q_EMIT v01SchedulePlayPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01SendDigitsPost(const QString &call_uuid, const QString &digits, const ::OpenAPI::OptionalParam<QString> &leg) {
    QString fullPath = QString(_serverConfigs["v01SendDigitsPost"][_serverIndices.value("v01SendDigitsPost")].URL()+"/v0.1/SendDigits/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid));
    }
    
    {
        input.add_var("Digits", ::OpenAPI::toStringValue(digits));
    }
    if (leg.hasValue())
    {
        input.add_var("Leg", ::OpenAPI::toStringValue(leg.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01SendDigitsPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01SendDigitsPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISendDigitsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01SendDigitsPostSignal(output);
        Q_EMIT v01SendDigitsPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01SendDigitsPostSignalE(output, error_type, error_str);
        Q_EMIT v01SendDigitsPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01SendDigitsPostSignalError(output, error_type, error_str);
        Q_EMIT v01SendDigitsPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01SoundTouchPost(const QString &call_uuid, const ::OpenAPI::OptionalParam<QString> &audio_direction, const ::OpenAPI::OptionalParam<float> &pitch, const ::OpenAPI::OptionalParam<float> &pitch_octaves, const ::OpenAPI::OptionalParam<float> &pitch_semi_tones, const ::OpenAPI::OptionalParam<float> &rate, const ::OpenAPI::OptionalParam<float> &tempo) {
    QString fullPath = QString(_serverConfigs["v01SoundTouchPost"][_serverIndices.value("v01SoundTouchPost")].URL()+"/v0.1/SoundTouch/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (audio_direction.hasValue())
    {
        input.add_var("AudioDirection", ::OpenAPI::toStringValue(audio_direction.value()));
    }
    
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid));
    }
    if (pitch.hasValue())
    {
        input.add_var("Pitch", ::OpenAPI::toStringValue(pitch.value()));
    }
    if (pitch_octaves.hasValue())
    {
        input.add_var("PitchOctaves", ::OpenAPI::toStringValue(pitch_octaves.value()));
    }
    if (pitch_semi_tones.hasValue())
    {
        input.add_var("PitchSemiTones", ::OpenAPI::toStringValue(pitch_semi_tones.value()));
    }
    if (rate.hasValue())
    {
        input.add_var("Rate", ::OpenAPI::toStringValue(rate.value()));
    }
    if (tempo.hasValue())
    {
        input.add_var("Tempo", ::OpenAPI::toStringValue(tempo.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01SoundTouchPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01SoundTouchPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISoundTouchResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01SoundTouchPostSignal(output);
        Q_EMIT v01SoundTouchPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01SoundTouchPostSignalE(output, error_type, error_str);
        Q_EMIT v01SoundTouchPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01SoundTouchPostSignalError(output, error_type, error_str);
        Q_EMIT v01SoundTouchPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01SoundTouchStopPost(const QString &call_uuid) {
    QString fullPath = QString(_serverConfigs["v01SoundTouchStopPost"][_serverIndices.value("v01SoundTouchStopPost")].URL()+"/v0.1/SoundTouchStop/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01SoundTouchStopPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01SoundTouchStopPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISoundTouchStopResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01SoundTouchStopPostSignal(output);
        Q_EMIT v01SoundTouchStopPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01SoundTouchStopPostSignalE(output, error_type, error_str);
        Q_EMIT v01SoundTouchStopPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01SoundTouchStopPostSignalError(output, error_type, error_str);
        Q_EMIT v01SoundTouchStopPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::v01TransferCallPost(const QString &call_uuid, const QString &url) {
    QString fullPath = QString(_serverConfigs["v01TransferCallPost"][_serverIndices.value("v01TransferCallPost")].URL()+"/v0.1/TransferCall/");
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("CallUUID", ::OpenAPI::toStringValue(call_uuid));
    }
    
    {
        input.add_var("Url", ::OpenAPI::toStringValue(url));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICallApi::v01TransferCallPostCallback);
    connect(this, &OAICallApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICallApi::v01TransferCallPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAITransferCallResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT v01TransferCallPostSignal(output);
        Q_EMIT v01TransferCallPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT v01TransferCallPostSignalE(output, error_type, error_str);
        Q_EMIT v01TransferCallPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT v01TransferCallPostSignalError(output, error_type, error_str);
        Q_EMIT v01TransferCallPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICallApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
