/*
 * GitHub v3 REST API
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * CodeScanningUploadSarifRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:08:22.800879-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CodeScanningUploadSarifRequest {
  public static final String SERIALIZED_NAME_CHECKOUT_URI = "checkout_uri";
  @SerializedName(SERIALIZED_NAME_CHECKOUT_URI)
  private URI checkoutUri;

  public static final String SERIALIZED_NAME_COMMIT_SHA = "commit_sha";
  @SerializedName(SERIALIZED_NAME_COMMIT_SHA)
  private String commitSha;

  public static final String SERIALIZED_NAME_REF = "ref";
  @SerializedName(SERIALIZED_NAME_REF)
  private String ref;

  public static final String SERIALIZED_NAME_SARIF = "sarif";
  @SerializedName(SERIALIZED_NAME_SARIF)
  private String sarif;

  public static final String SERIALIZED_NAME_STARTED_AT = "started_at";
  @SerializedName(SERIALIZED_NAME_STARTED_AT)
  private OffsetDateTime startedAt;

  public static final String SERIALIZED_NAME_TOOL_NAME = "tool_name";
  @SerializedName(SERIALIZED_NAME_TOOL_NAME)
  private String toolName;

  public CodeScanningUploadSarifRequest() {
  }

  public CodeScanningUploadSarifRequest checkoutUri(URI checkoutUri) {
    this.checkoutUri = checkoutUri;
    return this;
  }

  /**
   * The base directory used in the analysis, as it appears in the SARIF file. This property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.
   * @return checkoutUri
   */
  @javax.annotation.Nullable
  public URI getCheckoutUri() {
    return checkoutUri;
  }

  public void setCheckoutUri(URI checkoutUri) {
    this.checkoutUri = checkoutUri;
  }


  public CodeScanningUploadSarifRequest commitSha(String commitSha) {
    this.commitSha = commitSha;
    return this;
  }

  /**
   * The SHA of the commit to which the analysis you are uploading relates.
   * @return commitSha
   */
  @javax.annotation.Nonnull
  public String getCommitSha() {
    return commitSha;
  }

  public void setCommitSha(String commitSha) {
    this.commitSha = commitSha;
  }


  public CodeScanningUploadSarifRequest ref(String ref) {
    this.ref = ref;
    return this;
  }

  /**
   * The full Git reference, formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;, &#x60;refs/pull/&lt;number&gt;/merge&#x60;, or &#x60;refs/pull/&lt;number&gt;/head&#x60;.
   * @return ref
   */
  @javax.annotation.Nonnull
  public String getRef() {
    return ref;
  }

  public void setRef(String ref) {
    this.ref = ref;
  }


  public CodeScanningUploadSarifRequest sarif(String sarif) {
    this.sarif = sarif;
    return this;
  }

  /**
   * A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [&#x60;gzip&#x60;](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see \&quot;[SARIF support for code scanning](https://docs.github.com/enterprise-server@3.3/code-security/secure-coding/sarif-support-for-code-scanning).\&quot;
   * @return sarif
   */
  @javax.annotation.Nonnull
  public String getSarif() {
    return sarif;
  }

  public void setSarif(String sarif) {
    this.sarif = sarif;
  }


  public CodeScanningUploadSarifRequest startedAt(OffsetDateTime startedAt) {
    this.startedAt = startedAt;
    return this;
  }

  /**
   * The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: &#x60;YYYY-MM-DDTHH:MM:SSZ&#x60;.
   * @return startedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartedAt() {
    return startedAt;
  }

  public void setStartedAt(OffsetDateTime startedAt) {
    this.startedAt = startedAt;
  }


  public CodeScanningUploadSarifRequest toolName(String toolName) {
    this.toolName = toolName;
    return this;
  }

  /**
   * The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to \&quot;API\&quot;. If the uploaded SARIF contains a tool GUID, this will be available for filtering using the &#x60;tool_guid&#x60; parameter of operations such as &#x60;GET /repos/{owner}/{repo}/code-scanning/alerts&#x60;.
   * @return toolName
   */
  @javax.annotation.Nullable
  public String getToolName() {
    return toolName;
  }

  public void setToolName(String toolName) {
    this.toolName = toolName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CodeScanningUploadSarifRequest codeScanningUploadSarifRequest = (CodeScanningUploadSarifRequest) o;
    return Objects.equals(this.checkoutUri, codeScanningUploadSarifRequest.checkoutUri) &&
        Objects.equals(this.commitSha, codeScanningUploadSarifRequest.commitSha) &&
        Objects.equals(this.ref, codeScanningUploadSarifRequest.ref) &&
        Objects.equals(this.sarif, codeScanningUploadSarifRequest.sarif) &&
        Objects.equals(this.startedAt, codeScanningUploadSarifRequest.startedAt) &&
        Objects.equals(this.toolName, codeScanningUploadSarifRequest.toolName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(checkoutUri, commitSha, ref, sarif, startedAt, toolName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CodeScanningUploadSarifRequest {\n");
    sb.append("    checkoutUri: ").append(toIndentedString(checkoutUri)).append("\n");
    sb.append("    commitSha: ").append(toIndentedString(commitSha)).append("\n");
    sb.append("    ref: ").append(toIndentedString(ref)).append("\n");
    sb.append("    sarif: ").append(toIndentedString(sarif)).append("\n");
    sb.append("    startedAt: ").append(toIndentedString(startedAt)).append("\n");
    sb.append("    toolName: ").append(toIndentedString(toolName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("checkout_uri");
    openapiFields.add("commit_sha");
    openapiFields.add("ref");
    openapiFields.add("sarif");
    openapiFields.add("started_at");
    openapiFields.add("tool_name");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("commit_sha");
    openapiRequiredFields.add("ref");
    openapiRequiredFields.add("sarif");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CodeScanningUploadSarifRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CodeScanningUploadSarifRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CodeScanningUploadSarifRequest is not found in the empty JSON string", CodeScanningUploadSarifRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CodeScanningUploadSarifRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CodeScanningUploadSarifRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CodeScanningUploadSarifRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("checkout_uri") != null && !jsonObj.get("checkout_uri").isJsonNull()) && !jsonObj.get("checkout_uri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `checkout_uri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("checkout_uri").toString()));
      }
      if (!jsonObj.get("commit_sha").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `commit_sha` to be a primitive type in the JSON string but got `%s`", jsonObj.get("commit_sha").toString()));
      }
      if (!jsonObj.get("ref").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ref` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ref").toString()));
      }
      if (!jsonObj.get("sarif").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sarif` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sarif").toString()));
      }
      if ((jsonObj.get("tool_name") != null && !jsonObj.get("tool_name").isJsonNull()) && !jsonObj.get("tool_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tool_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tool_name").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CodeScanningUploadSarifRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CodeScanningUploadSarifRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CodeScanningUploadSarifRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CodeScanningUploadSarifRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CodeScanningUploadSarifRequest>() {
           @Override
           public void write(JsonWriter out, CodeScanningUploadSarifRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CodeScanningUploadSarifRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CodeScanningUploadSarifRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CodeScanningUploadSarifRequest
   * @throws IOException if the JSON string is invalid with respect to CodeScanningUploadSarifRequest
   */
  public static CodeScanningUploadSarifRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CodeScanningUploadSarifRequest.class);
  }

  /**
   * Convert an instance of CodeScanningUploadSarifRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

