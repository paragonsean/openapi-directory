/**
 * GitHub v3 REST API
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import BasicError from '../model/BasicError';
import GitCommit from '../model/GitCommit';
import GitCreateBlobRequest from '../model/GitCreateBlobRequest';
import GitCreateCommitRequest from '../model/GitCreateCommitRequest';
import GitCreateRefRequest from '../model/GitCreateRefRequest';
import GitCreateTagRequest from '../model/GitCreateTagRequest';
import GitCreateTreeRequest from '../model/GitCreateTreeRequest';
import GitRef from '../model/GitRef';
import GitTag from '../model/GitTag';
import GitTree from '../model/GitTree';
import GitUpdateRefRequest from '../model/GitUpdateRefRequest';
import ShortBlob from '../model/ShortBlob';
import ValidationError from '../model/ValidationError';

/**
* Git service.
* @module api/GitApi
* @version 1.1.4
*/
export default class GitApi {

    /**
    * Constructs a new GitApi. 
    * @alias module:api/GitApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the gitCreateBlob operation.
     * @callback module:api/GitApi~gitCreateBlobCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ShortBlob} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create a blob
     * 
     * @param {String} owner 
     * @param {String} repo 
     * @param {module:model/GitCreateBlobRequest} gitCreateBlobRequest 
     * @param {module:api/GitApi~gitCreateBlobCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ShortBlob}
     */
    gitCreateBlob(owner, repo, gitCreateBlobRequest, callback) {
      let postBody = gitCreateBlobRequest;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitCreateBlob");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitCreateBlob");
      }
      // verify the required parameter 'gitCreateBlobRequest' is set
      if (gitCreateBlobRequest === undefined || gitCreateBlobRequest === null) {
        throw new Error("Missing the required parameter 'gitCreateBlobRequest' when calling gitCreateBlob");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = ShortBlob;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/blobs', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitCreateCommit operation.
     * @callback module:api/GitApi~gitCreateCommitCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GitCommit} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create a commit
     * Creates a new Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).  **Signature verification object**  The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:  | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. | | `signature` | `string` | The signature that was extracted from the commit. | | `payload` | `string` | The value that was signed. |  These are the possible values for `reason` in the `verification` object:  | Value | Description | | ----- | ----------- | | `expired_key` | The key that made the signature is expired. | | `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error communicating with the signature verification service. | | `gpgverify_unavailable` | The signature verification service is currently unavailable. | | `unsigned` | The object does not include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No user was associated with the `committer` email address in the commit. | | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. | | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. | | `unknown_key` | The key that made the signature has not been registered with any user's account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. | | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     * @param {String} owner 
     * @param {String} repo 
     * @param {module:model/GitCreateCommitRequest} gitCreateCommitRequest 
     * @param {module:api/GitApi~gitCreateCommitCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GitCommit}
     */
    gitCreateCommit(owner, repo, gitCreateCommitRequest, callback) {
      let postBody = gitCreateCommitRequest;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitCreateCommit");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitCreateCommit");
      }
      // verify the required parameter 'gitCreateCommitRequest' is set
      if (gitCreateCommitRequest === undefined || gitCreateCommitRequest === null) {
        throw new Error("Missing the required parameter 'gitCreateCommitRequest' when calling gitCreateCommit");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GitCommit;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/commits', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitCreateRef operation.
     * @callback module:api/GitApi~gitCreateRefCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GitRef} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create a reference
     * Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
     * @param {String} owner 
     * @param {String} repo 
     * @param {module:model/GitCreateRefRequest} gitCreateRefRequest 
     * @param {module:api/GitApi~gitCreateRefCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GitRef}
     */
    gitCreateRef(owner, repo, gitCreateRefRequest, callback) {
      let postBody = gitCreateRefRequest;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitCreateRef");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitCreateRef");
      }
      // verify the required parameter 'gitCreateRefRequest' is set
      if (gitCreateRefRequest === undefined || gitCreateRefRequest === null) {
        throw new Error("Missing the required parameter 'gitCreateRefRequest' when calling gitCreateRef");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GitRef;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/refs', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitCreateTag operation.
     * @callback module:api/GitApi~gitCreateTagCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GitTag} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create a tag object
     * Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then [create](https://docs.github.com/enterprise-server@2.18/rest/reference/git#create-a-reference) the `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.com/enterprise-server@2.18/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.  **Signature verification object**  The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:  | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. | | `signature` | `string` | The signature that was extracted from the commit. | | `payload` | `string` | The value that was signed. |  These are the possible values for `reason` in the `verification` object:  | Value | Description | | ----- | ----------- | | `expired_key` | The key that made the signature is expired. | | `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error communicating with the signature verification service. | | `gpgverify_unavailable` | The signature verification service is currently unavailable. | | `unsigned` | The object does not include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No user was associated with the `committer` email address in the commit. | | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. | | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. | | `unknown_key` | The key that made the signature has not been registered with any user's account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. | | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     * @param {String} owner 
     * @param {String} repo 
     * @param {module:model/GitCreateTagRequest} gitCreateTagRequest 
     * @param {module:api/GitApi~gitCreateTagCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GitTag}
     */
    gitCreateTag(owner, repo, gitCreateTagRequest, callback) {
      let postBody = gitCreateTagRequest;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitCreateTag");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitCreateTag");
      }
      // verify the required parameter 'gitCreateTagRequest' is set
      if (gitCreateTagRequest === undefined || gitCreateTagRequest === null) {
        throw new Error("Missing the required parameter 'gitCreateTagRequest' when calling gitCreateTag");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GitTag;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/tags', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitCreateTree operation.
     * @callback module:api/GitApi~gitCreateTreeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GitTree} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create a tree
     * The tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that tree, this endpoint will overwrite the contents of the tree with the new path contents, and create a new tree structure.  If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then update a branch to point to the commit. For more information see \"[Create a commit](https://docs.github.com/enterprise-server@2.18/rest/reference/git#create-a-commit)\" and \"[Update a reference](https://docs.github.com/enterprise-server@2.18/rest/reference/git#update-a-reference).\"
     * @param {String} owner 
     * @param {String} repo 
     * @param {module:model/GitCreateTreeRequest} gitCreateTreeRequest 
     * @param {module:api/GitApi~gitCreateTreeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GitTree}
     */
    gitCreateTree(owner, repo, gitCreateTreeRequest, callback) {
      let postBody = gitCreateTreeRequest;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitCreateTree");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitCreateTree");
      }
      // verify the required parameter 'gitCreateTreeRequest' is set
      if (gitCreateTreeRequest === undefined || gitCreateTreeRequest === null) {
        throw new Error("Missing the required parameter 'gitCreateTreeRequest' when calling gitCreateTree");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GitTree;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/trees', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitDeleteRef operation.
     * @callback module:api/GitApi~gitDeleteRefCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete a reference
     * 
     * @param {String} owner 
     * @param {String} repo 
     * @param {String} ref ref parameter
     * @param {module:api/GitApi~gitDeleteRefCallback} callback The callback function, accepting three arguments: error, data, response
     */
    gitDeleteRef(owner, repo, ref, callback) {
      let postBody = null;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitDeleteRef");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitDeleteRef");
      }
      // verify the required parameter 'ref' is set
      if (ref === undefined || ref === null) {
        throw new Error("Missing the required parameter 'ref' when calling gitDeleteRef");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo,
        'ref': ref
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/refs/{ref}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitGetAllRefs operation.
     * @callback module:api/GitApi~gitGetAllRefsCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/GitRef>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get all references
     * Returns an array of all the references from your Git database, including notes and stashes if they exist on the server. Anything in the namespace is returned, not just `heads` and `tags`. If there are no references to list, a `404` is returned.  **Note:** You need to explicitly [request a pull request](https://docs.github.com/enterprise-server@2.18/rest/reference/pulls#get-a-single-pull-request) to trigger a merge commit creation. For more information, see \"[Checking mergeability of pull requests](https://docs.github.com/enterprise-server@2.18/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)\".  ``` GET /repos/octocat/Hello-World/git/refs ```  You can also request a sub-namespace. For example, to get all the tag references, you can call:  ``` GET /repos/octocat/Hello-World/git/refs/tags ```
     * @param {String} owner 
     * @param {String} repo 
     * @param {String} namespace Automatically added
     * @param {Object} opts Optional parameters
     * @param {Number} [perPage = 30)] Results per page (max 100)
     * @param {Number} [page = 1)] Page number of the results to fetch.
     * @param {module:api/GitApi~gitGetAllRefsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/GitRef>}
     */
    gitGetAllRefs(owner, repo, namespace, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitGetAllRefs");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitGetAllRefs");
      }
      // verify the required parameter 'namespace' is set
      if (namespace === undefined || namespace === null) {
        throw new Error("Missing the required parameter 'namespace' when calling gitGetAllRefs");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo,
        'namespace': namespace
      };
      let queryParams = {
        'per_page': opts['perPage'],
        'page': opts['page']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [GitRef];
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/refs/{namespace}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitGetBlob operation.
     * @callback module:api/GitApi~gitGetBlobCallback
     * @param {String} error Error message, if any.
     * @param {Blob} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a blob
     * The `content` in the response will always be Base64 encoded.  _Note_: This API supports blobs up to 100 megabytes in size.
     * @param {String} owner 
     * @param {String} repo 
     * @param {String} fileSha 
     * @param {module:api/GitApi~gitGetBlobCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Blob}
     */
    gitGetBlob(owner, repo, fileSha, callback) {
      let postBody = null;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitGetBlob");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitGetBlob");
      }
      // verify the required parameter 'fileSha' is set
      if (fileSha === undefined || fileSha === null) {
        throw new Error("Missing the required parameter 'fileSha' when calling gitGetBlob");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo,
        'file_sha': fileSha
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = 'Blob';
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/blobs/{file_sha}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitGetCommit operation.
     * @callback module:api/GitApi~gitGetCommitCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GitCommit} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a commit
     * Gets a Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).  **Signature verification object**  The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:  | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. | | `signature` | `string` | The signature that was extracted from the commit. | | `payload` | `string` | The value that was signed. |  These are the possible values for `reason` in the `verification` object:  | Value | Description | | ----- | ----------- | | `expired_key` | The key that made the signature is expired. | | `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error communicating with the signature verification service. | | `gpgverify_unavailable` | The signature verification service is currently unavailable. | | `unsigned` | The object does not include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No user was associated with the `committer` email address in the commit. | | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. | | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. | | `unknown_key` | The key that made the signature has not been registered with any user's account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. | | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     * @param {String} owner 
     * @param {String} repo 
     * @param {String} commitSha commit_sha parameter
     * @param {module:api/GitApi~gitGetCommitCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GitCommit}
     */
    gitGetCommit(owner, repo, commitSha, callback) {
      let postBody = null;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitGetCommit");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitGetCommit");
      }
      // verify the required parameter 'commitSha' is set
      if (commitSha === undefined || commitSha === null) {
        throw new Error("Missing the required parameter 'commitSha' when calling gitGetCommit");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo,
        'commit_sha': commitSha
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = GitCommit;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/commits/{commit_sha}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitGetTag operation.
     * @callback module:api/GitApi~gitGetTagCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GitTag} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a tag
     * **Signature verification object**  The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:  | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. | | `signature` | `string` | The signature that was extracted from the commit. | | `payload` | `string` | The value that was signed. |  These are the possible values for `reason` in the `verification` object:  | Value | Description | | ----- | ----------- | | `expired_key` | The key that made the signature is expired. | | `not_signing_key` | The \"signing\" flag is not among the usage flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error communicating with the signature verification service. | | `gpgverify_unavailable` | The signature verification service is currently unavailable. | | `unsigned` | The object does not include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No user was associated with the `committer` email address in the commit. | | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. | | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. | | `unknown_key` | The key that made the signature has not been registered with any user's account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. | | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     * @param {String} owner 
     * @param {String} repo 
     * @param {String} tagSha 
     * @param {module:api/GitApi~gitGetTagCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GitTag}
     */
    gitGetTag(owner, repo, tagSha, callback) {
      let postBody = null;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitGetTag");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitGetTag");
      }
      // verify the required parameter 'tagSha' is set
      if (tagSha === undefined || tagSha === null) {
        throw new Error("Missing the required parameter 'tagSha' when calling gitGetTag");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo,
        'tag_sha': tagSha
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = GitTag;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/tags/{tag_sha}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitGetTree operation.
     * @callback module:api/GitApi~gitGetTreeCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GitTree} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get a tree
     * Returns a single tree using the SHA1 value for that tree.  If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree at a time.
     * @param {String} owner 
     * @param {String} repo 
     * @param {String} treeSha 
     * @param {Object} opts Optional parameters
     * @param {String} [recursive] Setting this parameter to any value returns the objects or subtrees referenced by the tree specified in `:tree_sha`. For example, setting `recursive` to any of the following will enable returning objects or subtrees: `0`, `1`, `\"true\"`, and `\"false\"`. Omit this parameter to prevent recursively returning objects or subtrees.
     * @param {module:api/GitApi~gitGetTreeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GitTree}
     */
    gitGetTree(owner, repo, treeSha, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitGetTree");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitGetTree");
      }
      // verify the required parameter 'treeSha' is set
      if (treeSha === undefined || treeSha === null) {
        throw new Error("Missing the required parameter 'treeSha' when calling gitGetTree");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo,
        'tree_sha': treeSha
      };
      let queryParams = {
        'recursive': opts['recursive']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = GitTree;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/trees/{tree_sha}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the gitUpdateRef operation.
     * @callback module:api/GitApi~gitUpdateRefCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GitRef} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update a reference
     * 
     * @param {String} owner 
     * @param {String} repo 
     * @param {String} ref ref parameter
     * @param {module:model/GitUpdateRefRequest} gitUpdateRefRequest 
     * @param {module:api/GitApi~gitUpdateRefCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GitRef}
     */
    gitUpdateRef(owner, repo, ref, gitUpdateRefRequest, callback) {
      let postBody = gitUpdateRefRequest;
      // verify the required parameter 'owner' is set
      if (owner === undefined || owner === null) {
        throw new Error("Missing the required parameter 'owner' when calling gitUpdateRef");
      }
      // verify the required parameter 'repo' is set
      if (repo === undefined || repo === null) {
        throw new Error("Missing the required parameter 'repo' when calling gitUpdateRef");
      }
      // verify the required parameter 'ref' is set
      if (ref === undefined || ref === null) {
        throw new Error("Missing the required parameter 'ref' when calling gitUpdateRef");
      }
      // verify the required parameter 'gitUpdateRefRequest' is set
      if (gitUpdateRefRequest === undefined || gitUpdateRefRequest === null) {
        throw new Error("Missing the required parameter 'gitUpdateRefRequest' when calling gitUpdateRef");
      }

      let pathParams = {
        'owner': owner,
        'repo': repo,
        'ref': ref
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GitRef;
      return this.apiClient.callApi(
        '/repos/{owner}/{repo}/git/refs/{ref}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
