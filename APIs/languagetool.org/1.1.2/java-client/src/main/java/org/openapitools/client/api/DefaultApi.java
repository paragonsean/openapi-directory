/*
 * LanguageTool API
 * Check texts for style and grammar issues with <a href='https://languagetool.org'>LanguageTool</a>. Please consider the following default limitations:<ul><li>your daily request limit depending on <a href='https://languagetool.org/editor/settings/access-tokens'>your plan</a> <li>maximum number of requests per minute: 20 (free) / 80 (Premium) <li>maximum number of characters per minute: 75,000 (free) / 300,000 (Premium) <li>maximum number of characters per request: 20,000 (free) / 60,000 (Premium) <li>for the free version, also consider the <a href='https://dev.languagetool.org/public-http-api'>limitations documented here</a> <li><b>Note:</b> any parameters or outputs not part of this documentation are internal and must not be relied on</ul> Need more generous limits? Just <a href='https://languagetool.org/proofreading-api'>contact us</a>.
 *
 * The version of the OpenAPI document: 1.1.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.CheckPost200Response;
import org.openapitools.client.model.LanguagesGet200ResponseInner;
import org.openapitools.client.model.WordsAddPost200Response;
import org.openapitools.client.model.WordsDeletePost200Response;
import org.openapitools.client.model.WordsGet200Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for checkPost
     * @param language A language code like &#x60;en-US&#x60;, &#x60;de-DE&#x60;, &#x60;fr&#x60;, or &#x60;auto&#x60; to guess the language automatically (see &#x60;preferredVariants&#x60; below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. &#x60;en-GB&#x60; instead of just &#x60;en&#x60;. (required)
     * @param text The text to be checked. This or &#39;data&#39; is required. (optional)
     * @param data The text to be checked, given as a JSON document that specifies what&#39;s text and what&#39;s markup. This or &#39;text&#39; is required. Markup will be ignored when looking for errors. Example text: &lt;pre&gt;A &amp;lt;b&gt;test&amp;lt;/b&gt;&lt;/pre&gt;JSON for the example text: &lt;pre&gt;{\\\&quot;annotation\\\&quot;:[  {\\\&quot;text\\\&quot;: \\\&quot;A \\\&quot;},  {\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;b&gt;\\\&quot;},  {\\\&quot;text\\\&quot;: \\\&quot;test\\\&quot;},  {\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;/b&gt;\\\&quot;} ]}&lt;/pre&gt; &lt;p&gt;If you have markup that should be interpreted as whitespace, like &lt;tt&gt;&amp;lt;p&amp;gt;&lt;/tt&gt; in HTML, you can have it interpreted like this: &lt;pre&gt;{\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;p&amp;gt;\\\&quot;, \\\&quot;interpretAs\\\&quot;: \\\&quot;\\\\n\\\\n\\\&quot;}&lt;/pre&gt;&lt;p&gt;The &#39;data&#39; feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input. (optional)
     * @param username Set to get Premium API access: Your username/email as used to log in at languagetool.org. (optional)
     * @param apiKey Set to get Premium API access: &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;your API key&lt;/a&gt; (optional)
     * @param dicts Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset (optional)
     * @param motherTongue A language code of the user&#39;s native language, enabling false friends checks for some language pairs. (optional)
     * @param preferredVariants Comma-separated list of preferred language variants. The language detector used with &#x60;language&#x3D;auto&#x60; can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like &#x60;en-GB&#x60; and &#x60;de-AT&#x60;. Only available with &#x60;language&#x3D;auto&#x60;. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just &#x60;en&#x60; or &#x60;de&#x60;. (optional)
     * @param enabledRules IDs of rules to be enabled, comma-separated (optional)
     * @param disabledRules IDs of rules to be disabled, comma-separated (optional)
     * @param enabledCategories IDs of categories to be enabled, comma-separated (optional)
     * @param disabledCategories IDs of categories to be disabled, comma-separated (optional)
     * @param enabledOnly If true, only the rules and categories whose IDs are specified with &#x60;enabledRules&#x60; or &#x60;enabledCategories&#x60; are enabled. (optional, default to false)
     * @param level If set to &#x60;picky&#x60;, additional rules will be activated, i.e. rules that you might only find useful when checking formal text. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of checking the text </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call checkPostCall(String language, String text, String data, String username, String apiKey, String dicts, String motherTongue, String preferredVariants, String enabledRules, String disabledRules, String enabledCategories, String disabledCategories, Boolean enabledOnly, String level, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/check";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (text != null) {
            localVarFormParams.put("text", text);
        }

        if (data != null) {
            localVarFormParams.put("data", data);
        }

        if (language != null) {
            localVarFormParams.put("language", language);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        if (apiKey != null) {
            localVarFormParams.put("apiKey", apiKey);
        }

        if (dicts != null) {
            localVarFormParams.put("dicts", dicts);
        }

        if (motherTongue != null) {
            localVarFormParams.put("motherTongue", motherTongue);
        }

        if (preferredVariants != null) {
            localVarFormParams.put("preferredVariants", preferredVariants);
        }

        if (enabledRules != null) {
            localVarFormParams.put("enabledRules", enabledRules);
        }

        if (disabledRules != null) {
            localVarFormParams.put("disabledRules", disabledRules);
        }

        if (enabledCategories != null) {
            localVarFormParams.put("enabledCategories", enabledCategories);
        }

        if (disabledCategories != null) {
            localVarFormParams.put("disabledCategories", disabledCategories);
        }

        if (enabledOnly != null) {
            localVarFormParams.put("enabledOnly", enabledOnly);
        }

        if (level != null) {
            localVarFormParams.put("level", level);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call checkPostValidateBeforeCall(String language, String text, String data, String username, String apiKey, String dicts, String motherTongue, String preferredVariants, String enabledRules, String disabledRules, String enabledCategories, String disabledCategories, Boolean enabledOnly, String level, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'language' is set
        if (language == null) {
            throw new ApiException("Missing the required parameter 'language' when calling checkPost(Async)");
        }

        return checkPostCall(language, text, data, username, apiKey, dicts, motherTongue, preferredVariants, enabledRules, disabledRules, enabledCategories, disabledCategories, enabledOnly, level, _callback);

    }

    /**
     * Check a text
     * The main feature - check a text with LanguageTool for possible style and grammar issues.
     * @param language A language code like &#x60;en-US&#x60;, &#x60;de-DE&#x60;, &#x60;fr&#x60;, or &#x60;auto&#x60; to guess the language automatically (see &#x60;preferredVariants&#x60; below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. &#x60;en-GB&#x60; instead of just &#x60;en&#x60;. (required)
     * @param text The text to be checked. This or &#39;data&#39; is required. (optional)
     * @param data The text to be checked, given as a JSON document that specifies what&#39;s text and what&#39;s markup. This or &#39;text&#39; is required. Markup will be ignored when looking for errors. Example text: &lt;pre&gt;A &amp;lt;b&gt;test&amp;lt;/b&gt;&lt;/pre&gt;JSON for the example text: &lt;pre&gt;{\\\&quot;annotation\\\&quot;:[  {\\\&quot;text\\\&quot;: \\\&quot;A \\\&quot;},  {\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;b&gt;\\\&quot;},  {\\\&quot;text\\\&quot;: \\\&quot;test\\\&quot;},  {\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;/b&gt;\\\&quot;} ]}&lt;/pre&gt; &lt;p&gt;If you have markup that should be interpreted as whitespace, like &lt;tt&gt;&amp;lt;p&amp;gt;&lt;/tt&gt; in HTML, you can have it interpreted like this: &lt;pre&gt;{\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;p&amp;gt;\\\&quot;, \\\&quot;interpretAs\\\&quot;: \\\&quot;\\\\n\\\\n\\\&quot;}&lt;/pre&gt;&lt;p&gt;The &#39;data&#39; feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input. (optional)
     * @param username Set to get Premium API access: Your username/email as used to log in at languagetool.org. (optional)
     * @param apiKey Set to get Premium API access: &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;your API key&lt;/a&gt; (optional)
     * @param dicts Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset (optional)
     * @param motherTongue A language code of the user&#39;s native language, enabling false friends checks for some language pairs. (optional)
     * @param preferredVariants Comma-separated list of preferred language variants. The language detector used with &#x60;language&#x3D;auto&#x60; can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like &#x60;en-GB&#x60; and &#x60;de-AT&#x60;. Only available with &#x60;language&#x3D;auto&#x60;. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just &#x60;en&#x60; or &#x60;de&#x60;. (optional)
     * @param enabledRules IDs of rules to be enabled, comma-separated (optional)
     * @param disabledRules IDs of rules to be disabled, comma-separated (optional)
     * @param enabledCategories IDs of categories to be enabled, comma-separated (optional)
     * @param disabledCategories IDs of categories to be disabled, comma-separated (optional)
     * @param enabledOnly If true, only the rules and categories whose IDs are specified with &#x60;enabledRules&#x60; or &#x60;enabledCategories&#x60; are enabled. (optional, default to false)
     * @param level If set to &#x60;picky&#x60;, additional rules will be activated, i.e. rules that you might only find useful when checking formal text. (optional)
     * @return CheckPost200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of checking the text </td><td>  -  </td></tr>
     </table>
     */
    public CheckPost200Response checkPost(String language, String text, String data, String username, String apiKey, String dicts, String motherTongue, String preferredVariants, String enabledRules, String disabledRules, String enabledCategories, String disabledCategories, Boolean enabledOnly, String level) throws ApiException {
        ApiResponse<CheckPost200Response> localVarResp = checkPostWithHttpInfo(language, text, data, username, apiKey, dicts, motherTongue, preferredVariants, enabledRules, disabledRules, enabledCategories, disabledCategories, enabledOnly, level);
        return localVarResp.getData();
    }

    /**
     * Check a text
     * The main feature - check a text with LanguageTool for possible style and grammar issues.
     * @param language A language code like &#x60;en-US&#x60;, &#x60;de-DE&#x60;, &#x60;fr&#x60;, or &#x60;auto&#x60; to guess the language automatically (see &#x60;preferredVariants&#x60; below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. &#x60;en-GB&#x60; instead of just &#x60;en&#x60;. (required)
     * @param text The text to be checked. This or &#39;data&#39; is required. (optional)
     * @param data The text to be checked, given as a JSON document that specifies what&#39;s text and what&#39;s markup. This or &#39;text&#39; is required. Markup will be ignored when looking for errors. Example text: &lt;pre&gt;A &amp;lt;b&gt;test&amp;lt;/b&gt;&lt;/pre&gt;JSON for the example text: &lt;pre&gt;{\\\&quot;annotation\\\&quot;:[  {\\\&quot;text\\\&quot;: \\\&quot;A \\\&quot;},  {\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;b&gt;\\\&quot;},  {\\\&quot;text\\\&quot;: \\\&quot;test\\\&quot;},  {\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;/b&gt;\\\&quot;} ]}&lt;/pre&gt; &lt;p&gt;If you have markup that should be interpreted as whitespace, like &lt;tt&gt;&amp;lt;p&amp;gt;&lt;/tt&gt; in HTML, you can have it interpreted like this: &lt;pre&gt;{\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;p&amp;gt;\\\&quot;, \\\&quot;interpretAs\\\&quot;: \\\&quot;\\\\n\\\\n\\\&quot;}&lt;/pre&gt;&lt;p&gt;The &#39;data&#39; feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input. (optional)
     * @param username Set to get Premium API access: Your username/email as used to log in at languagetool.org. (optional)
     * @param apiKey Set to get Premium API access: &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;your API key&lt;/a&gt; (optional)
     * @param dicts Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset (optional)
     * @param motherTongue A language code of the user&#39;s native language, enabling false friends checks for some language pairs. (optional)
     * @param preferredVariants Comma-separated list of preferred language variants. The language detector used with &#x60;language&#x3D;auto&#x60; can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like &#x60;en-GB&#x60; and &#x60;de-AT&#x60;. Only available with &#x60;language&#x3D;auto&#x60;. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just &#x60;en&#x60; or &#x60;de&#x60;. (optional)
     * @param enabledRules IDs of rules to be enabled, comma-separated (optional)
     * @param disabledRules IDs of rules to be disabled, comma-separated (optional)
     * @param enabledCategories IDs of categories to be enabled, comma-separated (optional)
     * @param disabledCategories IDs of categories to be disabled, comma-separated (optional)
     * @param enabledOnly If true, only the rules and categories whose IDs are specified with &#x60;enabledRules&#x60; or &#x60;enabledCategories&#x60; are enabled. (optional, default to false)
     * @param level If set to &#x60;picky&#x60;, additional rules will be activated, i.e. rules that you might only find useful when checking formal text. (optional)
     * @return ApiResponse&lt;CheckPost200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of checking the text </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CheckPost200Response> checkPostWithHttpInfo(String language, String text, String data, String username, String apiKey, String dicts, String motherTongue, String preferredVariants, String enabledRules, String disabledRules, String enabledCategories, String disabledCategories, Boolean enabledOnly, String level) throws ApiException {
        okhttp3.Call localVarCall = checkPostValidateBeforeCall(language, text, data, username, apiKey, dicts, motherTongue, preferredVariants, enabledRules, disabledRules, enabledCategories, disabledCategories, enabledOnly, level, null);
        Type localVarReturnType = new TypeToken<CheckPost200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Check a text (asynchronously)
     * The main feature - check a text with LanguageTool for possible style and grammar issues.
     * @param language A language code like &#x60;en-US&#x60;, &#x60;de-DE&#x60;, &#x60;fr&#x60;, or &#x60;auto&#x60; to guess the language automatically (see &#x60;preferredVariants&#x60; below). For languages with variants (English, German, Portuguese) spell checking will only be activated when you specify the variant, e.g. &#x60;en-GB&#x60; instead of just &#x60;en&#x60;. (required)
     * @param text The text to be checked. This or &#39;data&#39; is required. (optional)
     * @param data The text to be checked, given as a JSON document that specifies what&#39;s text and what&#39;s markup. This or &#39;text&#39; is required. Markup will be ignored when looking for errors. Example text: &lt;pre&gt;A &amp;lt;b&gt;test&amp;lt;/b&gt;&lt;/pre&gt;JSON for the example text: &lt;pre&gt;{\\\&quot;annotation\\\&quot;:[  {\\\&quot;text\\\&quot;: \\\&quot;A \\\&quot;},  {\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;b&gt;\\\&quot;},  {\\\&quot;text\\\&quot;: \\\&quot;test\\\&quot;},  {\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;/b&gt;\\\&quot;} ]}&lt;/pre&gt; &lt;p&gt;If you have markup that should be interpreted as whitespace, like &lt;tt&gt;&amp;lt;p&amp;gt;&lt;/tt&gt; in HTML, you can have it interpreted like this: &lt;pre&gt;{\\\&quot;markup\\\&quot;: \\\&quot;&amp;lt;p&amp;gt;\\\&quot;, \\\&quot;interpretAs\\\&quot;: \\\&quot;\\\\n\\\\n\\\&quot;}&lt;/pre&gt;&lt;p&gt;The &#39;data&#39; feature is not limited to HTML or XML, it can be used for any kind of markup. Entities will need to be expanded in this input. (optional)
     * @param username Set to get Premium API access: Your username/email as used to log in at languagetool.org. (optional)
     * @param apiKey Set to get Premium API access: &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;your API key&lt;/a&gt; (optional)
     * @param dicts Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset (optional)
     * @param motherTongue A language code of the user&#39;s native language, enabling false friends checks for some language pairs. (optional)
     * @param preferredVariants Comma-separated list of preferred language variants. The language detector used with &#x60;language&#x3D;auto&#x60; can detect e.g. English, but it cannot decide whether British English or American English is used. Thus this parameter can be used to specify the preferred variants like &#x60;en-GB&#x60; and &#x60;de-AT&#x60;. Only available with &#x60;language&#x3D;auto&#x60;. You should set variants for at least German and English, as otherwise the spell checking will not work for those, as no spelling dictionary can be selected for just &#x60;en&#x60; or &#x60;de&#x60;. (optional)
     * @param enabledRules IDs of rules to be enabled, comma-separated (optional)
     * @param disabledRules IDs of rules to be disabled, comma-separated (optional)
     * @param enabledCategories IDs of categories to be enabled, comma-separated (optional)
     * @param disabledCategories IDs of categories to be disabled, comma-separated (optional)
     * @param enabledOnly If true, only the rules and categories whose IDs are specified with &#x60;enabledRules&#x60; or &#x60;enabledCategories&#x60; are enabled. (optional, default to false)
     * @param level If set to &#x60;picky&#x60;, additional rules will be activated, i.e. rules that you might only find useful when checking formal text. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of checking the text </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call checkPostAsync(String language, String text, String data, String username, String apiKey, String dicts, String motherTongue, String preferredVariants, String enabledRules, String disabledRules, String enabledCategories, String disabledCategories, Boolean enabledOnly, String level, final ApiCallback<CheckPost200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = checkPostValidateBeforeCall(language, text, data, username, apiKey, dicts, motherTongue, preferredVariants, enabledRules, disabledRules, enabledCategories, disabledCategories, enabledOnly, level, _callback);
        Type localVarReturnType = new TypeToken<CheckPost200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for languagesGet
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of language objects. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call languagesGetCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/languages";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call languagesGetValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return languagesGetCall(_callback);

    }

    /**
     * Get a list of supported languages.
     * 
     * @return List&lt;LanguagesGet200ResponseInner&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of language objects. </td><td>  -  </td></tr>
     </table>
     */
    public List<LanguagesGet200ResponseInner> languagesGet() throws ApiException {
        ApiResponse<List<LanguagesGet200ResponseInner>> localVarResp = languagesGetWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Get a list of supported languages.
     * 
     * @return ApiResponse&lt;List&lt;LanguagesGet200ResponseInner&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of language objects. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<LanguagesGet200ResponseInner>> languagesGetWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = languagesGetValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<LanguagesGet200ResponseInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a list of supported languages. (asynchronously)
     * 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of language objects. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call languagesGetAsync(final ApiCallback<List<LanguagesGet200ResponseInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = languagesGetValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<LanguagesGet200ResponseInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for wordsAddPost
     * @param word The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages. (required)
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param dict Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of adding the word </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call wordsAddPostCall(String word, String username, String apiKey, String dict, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/words/add";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (word != null) {
            localVarFormParams.put("word", word);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        if (apiKey != null) {
            localVarFormParams.put("apiKey", apiKey);
        }

        if (dict != null) {
            localVarFormParams.put("dict", dict);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call wordsAddPostValidateBeforeCall(String word, String username, String apiKey, String dict, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'word' is set
        if (word == null) {
            throw new ApiException("Missing the required parameter 'word' when calling wordsAddPost(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling wordsAddPost(Async)");
        }

        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling wordsAddPost(Async)");
        }

        return wordsAddPostCall(word, username, apiKey, dict, _callback);

    }

    /**
     * Add word to a dictionary
     * Add a word to one of the user&#39;s personal dictionaries. Please note that this feature is considered to be used for personal dictionaries which must not contain more than 500 words. If this is an issue for you, please contact us.
     * @param word The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages. (required)
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param dict Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary (optional)
     * @return WordsAddPost200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of adding the word </td><td>  -  </td></tr>
     </table>
     */
    public WordsAddPost200Response wordsAddPost(String word, String username, String apiKey, String dict) throws ApiException {
        ApiResponse<WordsAddPost200Response> localVarResp = wordsAddPostWithHttpInfo(word, username, apiKey, dict);
        return localVarResp.getData();
    }

    /**
     * Add word to a dictionary
     * Add a word to one of the user&#39;s personal dictionaries. Please note that this feature is considered to be used for personal dictionaries which must not contain more than 500 words. If this is an issue for you, please contact us.
     * @param word The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages. (required)
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param dict Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary (optional)
     * @return ApiResponse&lt;WordsAddPost200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of adding the word </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WordsAddPost200Response> wordsAddPostWithHttpInfo(String word, String username, String apiKey, String dict) throws ApiException {
        okhttp3.Call localVarCall = wordsAddPostValidateBeforeCall(word, username, apiKey, dict, null);
        Type localVarReturnType = new TypeToken<WordsAddPost200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Add word to a dictionary (asynchronously)
     * Add a word to one of the user&#39;s personal dictionaries. Please note that this feature is considered to be used for personal dictionaries which must not contain more than 500 words. If this is an issue for you, please contact us.
     * @param word The word to be added. Must not be a phrase, i.e. cannot contain white space. The word is added to a global dictionary that applies to all languages. (required)
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param dict Name of the dictionary to add the word to; non-existent dictionaries are created after calling this; if unset, adds to special default dictionary (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of adding the word </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call wordsAddPostAsync(String word, String username, String apiKey, String dict, final ApiCallback<WordsAddPost200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = wordsAddPostValidateBeforeCall(word, username, apiKey, dict, _callback);
        Type localVarReturnType = new TypeToken<WordsAddPost200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for wordsDeletePost
     * @param word The word to be removed. (required)
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param dict Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of removing the word </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call wordsDeletePostCall(String word, String username, String apiKey, String dict, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/words/delete";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (word != null) {
            localVarFormParams.put("word", word);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        if (apiKey != null) {
            localVarFormParams.put("apiKey", apiKey);
        }

        if (dict != null) {
            localVarFormParams.put("dict", dict);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call wordsDeletePostValidateBeforeCall(String word, String username, String apiKey, String dict, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'word' is set
        if (word == null) {
            throw new ApiException("Missing the required parameter 'word' when calling wordsDeletePost(Async)");
        }

        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling wordsDeletePost(Async)");
        }

        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling wordsDeletePost(Async)");
        }

        return wordsDeletePostCall(word, username, apiKey, dict, _callback);

    }

    /**
     * Remove word from a dictionary
     * Remove a word from one of the user&#39;s personal dictionaries.
     * @param word The word to be removed. (required)
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param dict Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary (optional)
     * @return WordsDeletePost200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of removing the word </td><td>  -  </td></tr>
     </table>
     */
    public WordsDeletePost200Response wordsDeletePost(String word, String username, String apiKey, String dict) throws ApiException {
        ApiResponse<WordsDeletePost200Response> localVarResp = wordsDeletePostWithHttpInfo(word, username, apiKey, dict);
        return localVarResp.getData();
    }

    /**
     * Remove word from a dictionary
     * Remove a word from one of the user&#39;s personal dictionaries.
     * @param word The word to be removed. (required)
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param dict Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary (optional)
     * @return ApiResponse&lt;WordsDeletePost200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of removing the word </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WordsDeletePost200Response> wordsDeletePostWithHttpInfo(String word, String username, String apiKey, String dict) throws ApiException {
        okhttp3.Call localVarCall = wordsDeletePostValidateBeforeCall(word, username, apiKey, dict, null);
        Type localVarReturnType = new TypeToken<WordsDeletePost200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Remove word from a dictionary (asynchronously)
     * Remove a word from one of the user&#39;s personal dictionaries.
     * @param word The word to be removed. (required)
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param dict Name of the dictionary to remove the word from; if the dictionary is empty upon calling this, it is deleted; if unset, removes from special default dictionary (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the result of removing the word </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call wordsDeletePostAsync(String word, String username, String apiKey, String dict, final ApiCallback<WordsDeletePost200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = wordsDeletePostValidateBeforeCall(word, username, apiKey, dict, _callback);
        Type localVarReturnType = new TypeToken<WordsDeletePost200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for wordsGet
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param offset Offset of where to start in the list of words. Defaults to 0. (optional)
     * @param limit Maximum number of words to return. Defaults to 10. (optional)
     * @param dicts Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the user&#39;s words from the given user dictionaries </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call wordsGetCall(String username, String apiKey, Integer offset, Integer limit, String dicts, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/words";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (username != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("username", username));
        }

        if (apiKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("apiKey", apiKey));
        }

        if (dicts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dicts", dicts));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call wordsGetValidateBeforeCall(String username, String apiKey, Integer offset, Integer limit, String dicts, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'username' is set
        if (username == null) {
            throw new ApiException("Missing the required parameter 'username' when calling wordsGet(Async)");
        }

        // verify the required parameter 'apiKey' is set
        if (apiKey == null) {
            throw new ApiException("Missing the required parameter 'apiKey' when calling wordsGet(Async)");
        }

        return wordsGetCall(username, apiKey, offset, limit, dicts, _callback);

    }

    /**
     * List words in dictionaries
     * List words in the user&#39;s personal dictionaries.
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param offset Offset of where to start in the list of words. Defaults to 0. (optional)
     * @param limit Maximum number of words to return. Defaults to 10. (optional)
     * @param dicts Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset (optional)
     * @return WordsGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the user&#39;s words from the given user dictionaries </td><td>  -  </td></tr>
     </table>
     */
    public WordsGet200Response wordsGet(String username, String apiKey, Integer offset, Integer limit, String dicts) throws ApiException {
        ApiResponse<WordsGet200Response> localVarResp = wordsGetWithHttpInfo(username, apiKey, offset, limit, dicts);
        return localVarResp.getData();
    }

    /**
     * List words in dictionaries
     * List words in the user&#39;s personal dictionaries.
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param offset Offset of where to start in the list of words. Defaults to 0. (optional)
     * @param limit Maximum number of words to return. Defaults to 10. (optional)
     * @param dicts Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset (optional)
     * @return ApiResponse&lt;WordsGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the user&#39;s words from the given user dictionaries </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WordsGet200Response> wordsGetWithHttpInfo(String username, String apiKey, Integer offset, Integer limit, String dicts) throws ApiException {
        okhttp3.Call localVarCall = wordsGetValidateBeforeCall(username, apiKey, offset, limit, dicts, null);
        Type localVarReturnType = new TypeToken<WordsGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List words in dictionaries (asynchronously)
     * List words in the user&#39;s personal dictionaries.
     * @param username Your username as used to log in at languagetool.org. (required)
     * @param apiKey &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;https://languagetool.org/editor/settings/access-tokens&#39;&gt;Your API key&lt;/a&gt; (required)
     * @param offset Offset of where to start in the list of words. Defaults to 0. (optional)
     * @param limit Maximum number of words to return. Defaults to 10. (optional)
     * @param dicts Comma-separated list of dictionaries to include words from; uses special default dictionary if this is unset (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> the user&#39;s words from the given user dictionaries </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call wordsGetAsync(String username, String apiKey, Integer offset, Integer limit, String dicts, final ApiCallback<WordsGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = wordsGetValidateBeforeCall(username, apiKey, offset, limit, dicts, _callback);
        Type localVarReturnType = new TypeToken<WordsGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
