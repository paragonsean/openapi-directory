/*
 * CORE API v2
 * <p style=\"text-align: justify;\">You can use the CORE API to access the      resources harvested and enriched by CORE. If you encounter any problems with the API, please <a href=\"/contact\">report them to us</a>.</p>  <h2>Overview</h2> <p style=\"text-align: justify;\">The API is organised by resource type. The resources are <b>articles</b>,      <b>journals</b> and <b>repositories</b> and are represented using JSON data format. Furthermore,      each resource has a list of methods. The API also provides two global methods for accessing all resources at once.</p>  <h2>Response format</h2> <p style=\"text-align: justify;\">Response for each query contains two fields: <b>status</b> and <b>data</b>.     In case of an error status, the data field is empty. The data field contains a single object     in case the request is for a specific identifier (e.g. CORE ID, CORE repository ID, etc.), or       contains a list of objects, for example for search queries. In case of batch requests, the response     is an array of objects, each of which contains its own <b>status</b> and <b>data</b> fields.     For search queries the response contains an additional field <b>totalHits</b>, which is the      total number of items which match the search criteria.</p>  <h2>Search query syntax</h2>  <p style=\"text-align: justify\">Complex search queries can be used in all of the API search methods.     The query can be a simple string or it can be built using terms and operators described in Elasticsearch     <a href=\"http://www.elastic.co/guide/en/elasticsearch/reference/1.4/query-dsl-query-string-query.html#query-string-syntax\">documentation</a>.     The usable field names are <strong>title</strong>, <strong>description</strong>, <strong>fullText</strong>,      <strong>authors</strong>, <strong>publisher</strong>, <strong>repositories.id</strong>, <strong>repositories.name</strong>,      <strong>doi</strong>, <strong>oai</strong>, <strong>identifiers</strong> (which is a list of article identifiers including OAI, URL, etc.), <strong>language.name</strong>      and <strong>year</strong>. Some example queries: </p>  <ul style=\"margin-left: 30px;\">     <li><p>title:psychology and language.name:English</p></li>     <li><p>repositories.id:86 AND year:2014</p></li>     <li><p>identifiers:\"oai:aura.abdn.ac.uk:2164/3837\" OR identifiers:\"oai:aura.abdn.ac.uk:2164/3843\"</p></li>     <li><p>doi:\"10.1186/1471-2458-6-309\"</p></li> </ul>  <h3>Retrieving the latest Articles</h3> <p style=\"text-align: justify\">     You can retrieve the harvested items since specific dates using the following queries: </p>  <ul style=\"margin-left: 30px;\">     <li><p>repositoryDocument.metadataUpdated:>2017-02-10</p></li>     <li><p>repositoryDocument.metadataUpdated:>2017-03-01 AND repositoryDocument.metadataUpdated:<2017-03-31</p></li>     </ul>  <h2>Sort order</h2>  <p style=\"text-align: justify;\">For search queries, the results are ordered by relevance score. For batch      requests, the results are retrieved in the order of the requests.</p>  <h2>Parameters</h2> <p style=\"text-align: justify;\">The API methods allow different parameters to be passed. Additionally, there is an API key parameter which is common to all API methods. For all API methods      the API key can be provided either as a query parameter or in the request header. If the API key      is not provided, the API will return HTTP 401 error. You can register for an API key <a href=\"/services#api\">here</a>.</p>  <h2>API methods</h2>
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Language
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:58:44.717365-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Language {
  public static final String SERIALIZED_NAME_DELETED_STATUS = "deletedStatus";
  @SerializedName(SERIALIZED_NAME_DELETED_STATUS)
  private Integer deletedStatus;

  public static final String SERIALIZED_NAME_DEPOSITED_DATE = "depositedDate";
  @SerializedName(SERIALIZED_NAME_DEPOSITED_DATE)
  private LocalDate depositedDate;

  public static final String SERIALIZED_NAME_INDEXED = "indexed";
  @SerializedName(SERIALIZED_NAME_INDEXED)
  private Integer indexed;

  public static final String SERIALIZED_NAME_METADATA_UPDATED = "metadataUpdated";
  @SerializedName(SERIALIZED_NAME_METADATA_UPDATED)
  private LocalDate metadataUpdated;

  public static final String SERIALIZED_NAME_PDF_ORIGIN = "pdfOrigin";
  @SerializedName(SERIALIZED_NAME_PDF_ORIGIN)
  private String pdfOrigin;

  public static final String SERIALIZED_NAME_PDF_SIZE = "pdfSize";
  @SerializedName(SERIALIZED_NAME_PDF_SIZE)
  private Integer pdfSize;

  public static final String SERIALIZED_NAME_PDF_STATUS = "pdfStatus";
  @SerializedName(SERIALIZED_NAME_PDF_STATUS)
  private Integer pdfStatus;

  public static final String SERIALIZED_NAME_TDM_ONLY = "tdmOnly";
  @SerializedName(SERIALIZED_NAME_TDM_ONLY)
  private Boolean tdmOnly;

  public static final String SERIALIZED_NAME_TEXT_STATUS = "textStatus";
  @SerializedName(SERIALIZED_NAME_TEXT_STATUS)
  private Integer textStatus;

  public static final String SERIALIZED_NAME_TIMESTAMP = "timestamp";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP)
  private LocalDate timestamp;

  public Language() {
  }

  public Language deletedStatus(Integer deletedStatus) {
    this.deletedStatus = deletedStatus;
    return this;
  }

  /**
   * The deleted status of the document: 0 for allowed, 1 for deleted, 2 for disabled
   * @return deletedStatus
   */
  @javax.annotation.Nullable
  public Integer getDeletedStatus() {
    return deletedStatus;
  }

  public void setDeletedStatus(Integer deletedStatus) {
    this.deletedStatus = deletedStatus;
  }


  public Language depositedDate(LocalDate depositedDate) {
    this.depositedDate = depositedDate;
    return this;
  }

  /**
   * The date the item was deposited in the Data Provider (repository/Journal)
   * @return depositedDate
   */
  @javax.annotation.Nullable
  public LocalDate getDepositedDate() {
    return depositedDate;
  }

  public void setDepositedDate(LocalDate depositedDate) {
    this.depositedDate = depositedDate;
  }


  public Language indexed(Integer indexed) {
    this.indexed = indexed;
    return this;
  }

  /**
   * The index status of the document: 0 for not indexed, 1 for indexed
   * @return indexed
   */
  @javax.annotation.Nullable
  public Integer getIndexed() {
    return indexed;
  }

  public void setIndexed(Integer indexed) {
    this.indexed = indexed;
  }


  public Language metadataUpdated(LocalDate metadataUpdated) {
    this.metadataUpdated = metadataUpdated;
    return this;
  }

  /**
   * The last date metadata of this article were updated
   * @return metadataUpdated
   */
  @javax.annotation.Nullable
  public LocalDate getMetadataUpdated() {
    return metadataUpdated;
  }

  public void setMetadataUpdated(LocalDate metadataUpdated) {
    this.metadataUpdated = metadataUpdated;
  }


  public Language pdfOrigin(String pdfOrigin) {
    this.pdfOrigin = pdfOrigin;
    return this;
  }

  /**
   * The remote URL where we aquired the PDF
   * @return pdfOrigin
   */
  @javax.annotation.Nullable
  public String getPdfOrigin() {
    return pdfOrigin;
  }

  public void setPdfOrigin(String pdfOrigin) {
    this.pdfOrigin = pdfOrigin;
  }


  public Language pdfSize(Integer pdfSize) {
    this.pdfSize = pdfSize;
    return this;
  }

  /**
   * The size of pdf in bytes
   * @return pdfSize
   */
  @javax.annotation.Nullable
  public Integer getPdfSize() {
    return pdfSize;
  }

  public void setPdfSize(Integer pdfSize) {
    this.pdfSize = pdfSize;
  }


  public Language pdfStatus(Integer pdfStatus) {
    this.pdfStatus = pdfStatus;
    return this;
  }

  /**
   * The pdf status flag of article: 0 no pdf, 1 pdf exists
   * @return pdfStatus
   */
  @javax.annotation.Nullable
  public Integer getPdfStatus() {
    return pdfStatus;
  }

  public void setPdfStatus(Integer pdfStatus) {
    this.pdfStatus = pdfStatus;
  }


  public Language tdmOnly(Boolean tdmOnly) {
    this.tdmOnly = tdmOnly;
    return this;
  }

  /**
   * The tdmOnly flag of the article: 0 normal, 1 tdm only
   * @return tdmOnly
   */
  @javax.annotation.Nullable
  public Boolean getTdmOnly() {
    return tdmOnly;
  }

  public void setTdmOnly(Boolean tdmOnly) {
    this.tdmOnly = tdmOnly;
  }


  public Language textStatus(Integer textStatus) {
    this.textStatus = textStatus;
    return this;
  }

  /**
   * The text status flag of article: 0 does not exist, 1 exists
   * @return textStatus
   */
  @javax.annotation.Nullable
  public Integer getTextStatus() {
    return textStatus;
  }

  public void setTextStatus(Integer textStatus) {
    this.textStatus = textStatus;
  }


  public Language timestamp(LocalDate timestamp) {
    this.timestamp = timestamp;
    return this;
  }

  /**
   * The date of article as given by the repository
   * @return timestamp
   */
  @javax.annotation.Nullable
  public LocalDate getTimestamp() {
    return timestamp;
  }

  public void setTimestamp(LocalDate timestamp) {
    this.timestamp = timestamp;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Language language = (Language) o;
    return Objects.equals(this.deletedStatus, language.deletedStatus) &&
        Objects.equals(this.depositedDate, language.depositedDate) &&
        Objects.equals(this.indexed, language.indexed) &&
        Objects.equals(this.metadataUpdated, language.metadataUpdated) &&
        Objects.equals(this.pdfOrigin, language.pdfOrigin) &&
        Objects.equals(this.pdfSize, language.pdfSize) &&
        Objects.equals(this.pdfStatus, language.pdfStatus) &&
        Objects.equals(this.tdmOnly, language.tdmOnly) &&
        Objects.equals(this.textStatus, language.textStatus) &&
        Objects.equals(this.timestamp, language.timestamp);
  }

  @Override
  public int hashCode() {
    return Objects.hash(deletedStatus, depositedDate, indexed, metadataUpdated, pdfOrigin, pdfSize, pdfStatus, tdmOnly, textStatus, timestamp);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Language {\n");
    sb.append("    deletedStatus: ").append(toIndentedString(deletedStatus)).append("\n");
    sb.append("    depositedDate: ").append(toIndentedString(depositedDate)).append("\n");
    sb.append("    indexed: ").append(toIndentedString(indexed)).append("\n");
    sb.append("    metadataUpdated: ").append(toIndentedString(metadataUpdated)).append("\n");
    sb.append("    pdfOrigin: ").append(toIndentedString(pdfOrigin)).append("\n");
    sb.append("    pdfSize: ").append(toIndentedString(pdfSize)).append("\n");
    sb.append("    pdfStatus: ").append(toIndentedString(pdfStatus)).append("\n");
    sb.append("    tdmOnly: ").append(toIndentedString(tdmOnly)).append("\n");
    sb.append("    textStatus: ").append(toIndentedString(textStatus)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("deletedStatus");
    openapiFields.add("depositedDate");
    openapiFields.add("indexed");
    openapiFields.add("metadataUpdated");
    openapiFields.add("pdfOrigin");
    openapiFields.add("pdfSize");
    openapiFields.add("pdfStatus");
    openapiFields.add("tdmOnly");
    openapiFields.add("textStatus");
    openapiFields.add("timestamp");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Language
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Language.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Language is not found in the empty JSON string", Language.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Language.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Language` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("pdfOrigin") != null && !jsonObj.get("pdfOrigin").isJsonNull()) && !jsonObj.get("pdfOrigin").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pdfOrigin` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pdfOrigin").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Language.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Language' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Language> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Language.class));

       return (TypeAdapter<T>) new TypeAdapter<Language>() {
           @Override
           public void write(JsonWriter out, Language value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Language read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Language given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Language
   * @throws IOException if the JSON string is invalid with respect to Language
   */
  public static Language fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Language.class);
  }

  /**
   * Convert an instance of Language to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

