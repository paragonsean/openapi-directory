/*
 * Twilio - Video
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.55.0
 * Contact: support@twilio.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.RoomEnumRoomStatus;
import org.openapitools.client.model.RoomEnumRoomType;
import org.openapitools.client.model.RoomEnumVideoCodec;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * VideoV1Room
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:26:06.985861-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VideoV1Room {
  public static final String SERIALIZED_NAME_ACCOUNT_SID = "account_sid";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_SID)
  private String accountSid;

  public static final String SERIALIZED_NAME_AUDIO_ONLY = "audio_only";
  @SerializedName(SERIALIZED_NAME_AUDIO_ONLY)
  private Boolean audioOnly;

  public static final String SERIALIZED_NAME_DATE_CREATED = "date_created";
  @SerializedName(SERIALIZED_NAME_DATE_CREATED)
  private OffsetDateTime dateCreated;

  public static final String SERIALIZED_NAME_DATE_UPDATED = "date_updated";
  @SerializedName(SERIALIZED_NAME_DATE_UPDATED)
  private OffsetDateTime dateUpdated;

  public static final String SERIALIZED_NAME_DURATION = "duration";
  @SerializedName(SERIALIZED_NAME_DURATION)
  private Integer duration;

  public static final String SERIALIZED_NAME_EMPTY_ROOM_TIMEOUT = "empty_room_timeout";
  @SerializedName(SERIALIZED_NAME_EMPTY_ROOM_TIMEOUT)
  private Integer emptyRoomTimeout;

  public static final String SERIALIZED_NAME_ENABLE_TURN = "enable_turn";
  @SerializedName(SERIALIZED_NAME_ENABLE_TURN)
  private Boolean enableTurn;

  public static final String SERIALIZED_NAME_END_TIME = "end_time";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private OffsetDateTime endTime;

  public static final String SERIALIZED_NAME_LARGE_ROOM = "large_room";
  @SerializedName(SERIALIZED_NAME_LARGE_ROOM)
  private Boolean largeRoom;

  public static final String SERIALIZED_NAME_LINKS = "links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private Object links;

  public static final String SERIALIZED_NAME_MAX_CONCURRENT_PUBLISHED_TRACKS = "max_concurrent_published_tracks";
  @SerializedName(SERIALIZED_NAME_MAX_CONCURRENT_PUBLISHED_TRACKS)
  private Integer maxConcurrentPublishedTracks;

  public static final String SERIALIZED_NAME_MAX_PARTICIPANT_DURATION = "max_participant_duration";
  @SerializedName(SERIALIZED_NAME_MAX_PARTICIPANT_DURATION)
  private Integer maxParticipantDuration;

  public static final String SERIALIZED_NAME_MAX_PARTICIPANTS = "max_participants";
  @SerializedName(SERIALIZED_NAME_MAX_PARTICIPANTS)
  private Integer maxParticipants;

  public static final String SERIALIZED_NAME_MEDIA_REGION = "media_region";
  @SerializedName(SERIALIZED_NAME_MEDIA_REGION)
  private String mediaRegion;

  public static final String SERIALIZED_NAME_RECORD_PARTICIPANTS_ON_CONNECT = "record_participants_on_connect";
  @SerializedName(SERIALIZED_NAME_RECORD_PARTICIPANTS_ON_CONNECT)
  private Boolean recordParticipantsOnConnect;

  public static final String SERIALIZED_NAME_SID = "sid";
  @SerializedName(SERIALIZED_NAME_SID)
  private String sid;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private RoomEnumRoomStatus status;

  public static final String SERIALIZED_NAME_STATUS_CALLBACK = "status_callback";
  @SerializedName(SERIALIZED_NAME_STATUS_CALLBACK)
  private URI statusCallback;

  /**
   * The HTTP method we use to call &#x60;status_callback&#x60;. Can be &#x60;POST&#x60; or &#x60;GET&#x60; and defaults to &#x60;POST&#x60;.
   */
  @JsonAdapter(StatusCallbackMethodEnum.Adapter.class)
  public enum StatusCallbackMethodEnum {
    HEAD("HEAD"),
    
    GET("GET"),
    
    POST("POST"),
    
    PATCH("PATCH"),
    
    PUT("PUT"),
    
    DELETE("DELETE");

    private String value;

    StatusCallbackMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusCallbackMethodEnum fromValue(String value) {
      for (StatusCallbackMethodEnum b : StatusCallbackMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<StatusCallbackMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusCallbackMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusCallbackMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusCallbackMethodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusCallbackMethodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS_CALLBACK_METHOD = "status_callback_method";
  @SerializedName(SERIALIZED_NAME_STATUS_CALLBACK_METHOD)
  private StatusCallbackMethodEnum statusCallbackMethod;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private RoomEnumRoomType type;

  public static final String SERIALIZED_NAME_UNIQUE_NAME = "unique_name";
  @SerializedName(SERIALIZED_NAME_UNIQUE_NAME)
  private String uniqueName;

  public static final String SERIALIZED_NAME_UNUSED_ROOM_TIMEOUT = "unused_room_timeout";
  @SerializedName(SERIALIZED_NAME_UNUSED_ROOM_TIMEOUT)
  private Integer unusedRoomTimeout;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private URI url;

  public static final String SERIALIZED_NAME_VIDEO_CODECS = "video_codecs";
  @SerializedName(SERIALIZED_NAME_VIDEO_CODECS)
  private List<RoomEnumVideoCodec> videoCodecs;

  public VideoV1Room() {
  }

  public VideoV1Room accountSid(String accountSid) {
    this.accountSid = accountSid;
    return this;
  }

  /**
   * The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Room resource.
   * @return accountSid
   */
  @javax.annotation.Nullable
  public String getAccountSid() {
    return accountSid;
  }

  public void setAccountSid(String accountSid) {
    this.accountSid = accountSid;
  }


  public VideoV1Room audioOnly(Boolean audioOnly) {
    this.audioOnly = audioOnly;
    return this;
  }

  /**
   * When set to true, indicates that the participants in the room will only publish audio. No video tracks will be allowed. Group rooms only.
   * @return audioOnly
   */
  @javax.annotation.Nullable
  public Boolean getAudioOnly() {
    return audioOnly;
  }

  public void setAudioOnly(Boolean audioOnly) {
    this.audioOnly = audioOnly;
  }


  public VideoV1Room dateCreated(OffsetDateTime dateCreated) {
    this.dateCreated = dateCreated;
    return this;
  }

  /**
   * The date and time in GMT when the resource was created specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   * @return dateCreated
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDateCreated() {
    return dateCreated;
  }

  public void setDateCreated(OffsetDateTime dateCreated) {
    this.dateCreated = dateCreated;
  }


  public VideoV1Room dateUpdated(OffsetDateTime dateUpdated) {
    this.dateUpdated = dateUpdated;
    return this;
  }

  /**
   * The date and time in GMT when the resource was last updated specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   * @return dateUpdated
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDateUpdated() {
    return dateUpdated;
  }

  public void setDateUpdated(OffsetDateTime dateUpdated) {
    this.dateUpdated = dateUpdated;
  }


  public VideoV1Room duration(Integer duration) {
    this.duration = duration;
    return this;
  }

  /**
   * The duration of the room in seconds.
   * @return duration
   */
  @javax.annotation.Nullable
  public Integer getDuration() {
    return duration;
  }

  public void setDuration(Integer duration) {
    this.duration = duration;
  }


  public VideoV1Room emptyRoomTimeout(Integer emptyRoomTimeout) {
    this.emptyRoomTimeout = emptyRoomTimeout;
    return this;
  }

  /**
   * Specifies how long (in minutes) a room will remain active after last participant leaves. Can be configured when creating a room via REST API. For Ad-Hoc rooms this value cannot be changed.
   * @return emptyRoomTimeout
   */
  @javax.annotation.Nullable
  public Integer getEmptyRoomTimeout() {
    return emptyRoomTimeout;
  }

  public void setEmptyRoomTimeout(Integer emptyRoomTimeout) {
    this.emptyRoomTimeout = emptyRoomTimeout;
  }


  public VideoV1Room enableTurn(Boolean enableTurn) {
    this.enableTurn = enableTurn;
    return this;
  }

  /**
   * Deprecated, now always considered to be true.
   * @return enableTurn
   */
  @javax.annotation.Nullable
  public Boolean getEnableTurn() {
    return enableTurn;
  }

  public void setEnableTurn(Boolean enableTurn) {
    this.enableTurn = enableTurn;
  }


  public VideoV1Room endTime(OffsetDateTime endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * The UTC end time of the room in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#UTC) format.
   * @return endTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getEndTime() {
    return endTime;
  }

  public void setEndTime(OffsetDateTime endTime) {
    this.endTime = endTime;
  }


  public VideoV1Room largeRoom(Boolean largeRoom) {
    this.largeRoom = largeRoom;
    return this;
  }

  /**
   * Indicates if this is a large room.
   * @return largeRoom
   */
  @javax.annotation.Nullable
  public Boolean getLargeRoom() {
    return largeRoom;
  }

  public void setLargeRoom(Boolean largeRoom) {
    this.largeRoom = largeRoom;
  }


  public VideoV1Room links(Object links) {
    this.links = links;
    return this;
  }

  /**
   * The URLs of related resources.
   * @return links
   */
  @javax.annotation.Nullable
  public Object getLinks() {
    return links;
  }

  public void setLinks(Object links) {
    this.links = links;
  }


  public VideoV1Room maxConcurrentPublishedTracks(Integer maxConcurrentPublishedTracks) {
    this.maxConcurrentPublishedTracks = maxConcurrentPublishedTracks;
    return this;
  }

  /**
   * The maximum number of published audio, video, and data tracks all participants combined are allowed to publish in the room at the same time. Check [Programmable Video Limits](https://www.twilio.com/docs/video/programmable-video-limits) for more details. If it is set to 0 it means unconstrained.
   * @return maxConcurrentPublishedTracks
   */
  @javax.annotation.Nullable
  public Integer getMaxConcurrentPublishedTracks() {
    return maxConcurrentPublishedTracks;
  }

  public void setMaxConcurrentPublishedTracks(Integer maxConcurrentPublishedTracks) {
    this.maxConcurrentPublishedTracks = maxConcurrentPublishedTracks;
  }


  public VideoV1Room maxParticipantDuration(Integer maxParticipantDuration) {
    this.maxParticipantDuration = maxParticipantDuration;
    return this;
  }

  /**
   * The maximum number of seconds a Participant can be connected to the room. The maximum possible value is 86400 seconds (24 hours). The default is 14400 seconds (4 hours).
   * @return maxParticipantDuration
   */
  @javax.annotation.Nullable
  public Integer getMaxParticipantDuration() {
    return maxParticipantDuration;
  }

  public void setMaxParticipantDuration(Integer maxParticipantDuration) {
    this.maxParticipantDuration = maxParticipantDuration;
  }


  public VideoV1Room maxParticipants(Integer maxParticipants) {
    this.maxParticipants = maxParticipants;
    return this;
  }

  /**
   * The maximum number of concurrent Participants allowed in the room. 
   * @return maxParticipants
   */
  @javax.annotation.Nullable
  public Integer getMaxParticipants() {
    return maxParticipants;
  }

  public void setMaxParticipants(Integer maxParticipants) {
    this.maxParticipants = maxParticipants;
  }


  public VideoV1Room mediaRegion(String mediaRegion) {
    this.mediaRegion = mediaRegion;
    return this;
  }

  /**
   * The region for the media server in Group Rooms.  Can be: one of the [available Media Regions](https://www.twilio.com/docs/video/ip-addresses#media-servers). ***This feature is not available in &#x60;peer-to-peer&#x60; rooms.***
   * @return mediaRegion
   */
  @javax.annotation.Nullable
  public String getMediaRegion() {
    return mediaRegion;
  }

  public void setMediaRegion(String mediaRegion) {
    this.mediaRegion = mediaRegion;
  }


  public VideoV1Room recordParticipantsOnConnect(Boolean recordParticipantsOnConnect) {
    this.recordParticipantsOnConnect = recordParticipantsOnConnect;
    return this;
  }

  /**
   * Whether to start recording when Participants connect. ***This feature is not available in &#x60;peer-to-peer&#x60; rooms.***
   * @return recordParticipantsOnConnect
   */
  @javax.annotation.Nullable
  public Boolean getRecordParticipantsOnConnect() {
    return recordParticipantsOnConnect;
  }

  public void setRecordParticipantsOnConnect(Boolean recordParticipantsOnConnect) {
    this.recordParticipantsOnConnect = recordParticipantsOnConnect;
  }


  public VideoV1Room sid(String sid) {
    this.sid = sid;
    return this;
  }

  /**
   * The unique string that we created to identify the Room resource.
   * @return sid
   */
  @javax.annotation.Nullable
  public String getSid() {
    return sid;
  }

  public void setSid(String sid) {
    this.sid = sid;
  }


  public VideoV1Room status(RoomEnumRoomStatus status) {
    this.status = status;
    return this;
  }

  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nullable
  public RoomEnumRoomStatus getStatus() {
    return status;
  }

  public void setStatus(RoomEnumRoomStatus status) {
    this.status = status;
  }


  public VideoV1Room statusCallback(URI statusCallback) {
    this.statusCallback = statusCallback;
    return this;
  }

  /**
   * The URL we call using the &#x60;status_callback_method&#x60; to send status information to your application on every room event. See [Status Callbacks](https://www.twilio.com/docs/video/api/status-callbacks) for more info.
   * @return statusCallback
   */
  @javax.annotation.Nullable
  public URI getStatusCallback() {
    return statusCallback;
  }

  public void setStatusCallback(URI statusCallback) {
    this.statusCallback = statusCallback;
  }


  public VideoV1Room statusCallbackMethod(StatusCallbackMethodEnum statusCallbackMethod) {
    this.statusCallbackMethod = statusCallbackMethod;
    return this;
  }

  /**
   * The HTTP method we use to call &#x60;status_callback&#x60;. Can be &#x60;POST&#x60; or &#x60;GET&#x60; and defaults to &#x60;POST&#x60;.
   * @return statusCallbackMethod
   */
  @javax.annotation.Nullable
  public StatusCallbackMethodEnum getStatusCallbackMethod() {
    return statusCallbackMethod;
  }

  public void setStatusCallbackMethod(StatusCallbackMethodEnum statusCallbackMethod) {
    this.statusCallbackMethod = statusCallbackMethod;
  }


  public VideoV1Room type(RoomEnumRoomType type) {
    this.type = type;
    return this;
  }

  /**
   * Get type
   * @return type
   */
  @javax.annotation.Nullable
  public RoomEnumRoomType getType() {
    return type;
  }

  public void setType(RoomEnumRoomType type) {
    this.type = type;
  }


  public VideoV1Room uniqueName(String uniqueName) {
    this.uniqueName = uniqueName;
    return this;
  }

  /**
   * An application-defined string that uniquely identifies the resource. It can be used as a &#x60;room_sid&#x60; in place of the resource&#39;s &#x60;sid&#x60; in the URL to address the resource, assuming it does not contain any [reserved characters](https://tools.ietf.org/html/rfc3986#section-2.2) that would need to be URL encoded. This value is unique for &#x60;in-progress&#x60; rooms. SDK clients can use this name to connect to the room. REST API clients can use this name in place of the Room SID to interact with the room as long as the room is &#x60;in-progress&#x60;.
   * @return uniqueName
   */
  @javax.annotation.Nullable
  public String getUniqueName() {
    return uniqueName;
  }

  public void setUniqueName(String uniqueName) {
    this.uniqueName = uniqueName;
  }


  public VideoV1Room unusedRoomTimeout(Integer unusedRoomTimeout) {
    this.unusedRoomTimeout = unusedRoomTimeout;
    return this;
  }

  /**
   * Specifies how long (in minutes) a room will remain active if no one joins. Can be configured when creating a room via REST API. For Ad-Hoc rooms this value cannot be changed.
   * @return unusedRoomTimeout
   */
  @javax.annotation.Nullable
  public Integer getUnusedRoomTimeout() {
    return unusedRoomTimeout;
  }

  public void setUnusedRoomTimeout(Integer unusedRoomTimeout) {
    this.unusedRoomTimeout = unusedRoomTimeout;
  }


  public VideoV1Room url(URI url) {
    this.url = url;
    return this;
  }

  /**
   * The absolute URL of the resource.
   * @return url
   */
  @javax.annotation.Nullable
  public URI getUrl() {
    return url;
  }

  public void setUrl(URI url) {
    this.url = url;
  }


  public VideoV1Room videoCodecs(List<RoomEnumVideoCodec> videoCodecs) {
    this.videoCodecs = videoCodecs;
    return this;
  }

  public VideoV1Room addVideoCodecsItem(RoomEnumVideoCodec videoCodecsItem) {
    if (this.videoCodecs == null) {
      this.videoCodecs = new ArrayList<>();
    }
    this.videoCodecs.add(videoCodecsItem);
    return this;
  }

  /**
   * An array of the video codecs that are supported when publishing a track in the room.  Can be: &#x60;VP8&#x60; and &#x60;H264&#x60;.  ***This feature is not available in &#x60;peer-to-peer&#x60; rooms***
   * @return videoCodecs
   */
  @javax.annotation.Nullable
  public List<RoomEnumVideoCodec> getVideoCodecs() {
    return videoCodecs;
  }

  public void setVideoCodecs(List<RoomEnumVideoCodec> videoCodecs) {
    this.videoCodecs = videoCodecs;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoV1Room videoV1Room = (VideoV1Room) o;
    return Objects.equals(this.accountSid, videoV1Room.accountSid) &&
        Objects.equals(this.audioOnly, videoV1Room.audioOnly) &&
        Objects.equals(this.dateCreated, videoV1Room.dateCreated) &&
        Objects.equals(this.dateUpdated, videoV1Room.dateUpdated) &&
        Objects.equals(this.duration, videoV1Room.duration) &&
        Objects.equals(this.emptyRoomTimeout, videoV1Room.emptyRoomTimeout) &&
        Objects.equals(this.enableTurn, videoV1Room.enableTurn) &&
        Objects.equals(this.endTime, videoV1Room.endTime) &&
        Objects.equals(this.largeRoom, videoV1Room.largeRoom) &&
        Objects.equals(this.links, videoV1Room.links) &&
        Objects.equals(this.maxConcurrentPublishedTracks, videoV1Room.maxConcurrentPublishedTracks) &&
        Objects.equals(this.maxParticipantDuration, videoV1Room.maxParticipantDuration) &&
        Objects.equals(this.maxParticipants, videoV1Room.maxParticipants) &&
        Objects.equals(this.mediaRegion, videoV1Room.mediaRegion) &&
        Objects.equals(this.recordParticipantsOnConnect, videoV1Room.recordParticipantsOnConnect) &&
        Objects.equals(this.sid, videoV1Room.sid) &&
        Objects.equals(this.status, videoV1Room.status) &&
        Objects.equals(this.statusCallback, videoV1Room.statusCallback) &&
        Objects.equals(this.statusCallbackMethod, videoV1Room.statusCallbackMethod) &&
        Objects.equals(this.type, videoV1Room.type) &&
        Objects.equals(this.uniqueName, videoV1Room.uniqueName) &&
        Objects.equals(this.unusedRoomTimeout, videoV1Room.unusedRoomTimeout) &&
        Objects.equals(this.url, videoV1Room.url) &&
        Objects.equals(this.videoCodecs, videoV1Room.videoCodecs);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountSid, audioOnly, dateCreated, dateUpdated, duration, emptyRoomTimeout, enableTurn, endTime, largeRoom, links, maxConcurrentPublishedTracks, maxParticipantDuration, maxParticipants, mediaRegion, recordParticipantsOnConnect, sid, status, statusCallback, statusCallbackMethod, type, uniqueName, unusedRoomTimeout, url, videoCodecs);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoV1Room {\n");
    sb.append("    accountSid: ").append(toIndentedString(accountSid)).append("\n");
    sb.append("    audioOnly: ").append(toIndentedString(audioOnly)).append("\n");
    sb.append("    dateCreated: ").append(toIndentedString(dateCreated)).append("\n");
    sb.append("    dateUpdated: ").append(toIndentedString(dateUpdated)).append("\n");
    sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
    sb.append("    emptyRoomTimeout: ").append(toIndentedString(emptyRoomTimeout)).append("\n");
    sb.append("    enableTurn: ").append(toIndentedString(enableTurn)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    largeRoom: ").append(toIndentedString(largeRoom)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    maxConcurrentPublishedTracks: ").append(toIndentedString(maxConcurrentPublishedTracks)).append("\n");
    sb.append("    maxParticipantDuration: ").append(toIndentedString(maxParticipantDuration)).append("\n");
    sb.append("    maxParticipants: ").append(toIndentedString(maxParticipants)).append("\n");
    sb.append("    mediaRegion: ").append(toIndentedString(mediaRegion)).append("\n");
    sb.append("    recordParticipantsOnConnect: ").append(toIndentedString(recordParticipantsOnConnect)).append("\n");
    sb.append("    sid: ").append(toIndentedString(sid)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    statusCallback: ").append(toIndentedString(statusCallback)).append("\n");
    sb.append("    statusCallbackMethod: ").append(toIndentedString(statusCallbackMethod)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    uniqueName: ").append(toIndentedString(uniqueName)).append("\n");
    sb.append("    unusedRoomTimeout: ").append(toIndentedString(unusedRoomTimeout)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    videoCodecs: ").append(toIndentedString(videoCodecs)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("account_sid");
    openapiFields.add("audio_only");
    openapiFields.add("date_created");
    openapiFields.add("date_updated");
    openapiFields.add("duration");
    openapiFields.add("empty_room_timeout");
    openapiFields.add("enable_turn");
    openapiFields.add("end_time");
    openapiFields.add("large_room");
    openapiFields.add("links");
    openapiFields.add("max_concurrent_published_tracks");
    openapiFields.add("max_participant_duration");
    openapiFields.add("max_participants");
    openapiFields.add("media_region");
    openapiFields.add("record_participants_on_connect");
    openapiFields.add("sid");
    openapiFields.add("status");
    openapiFields.add("status_callback");
    openapiFields.add("status_callback_method");
    openapiFields.add("type");
    openapiFields.add("unique_name");
    openapiFields.add("unused_room_timeout");
    openapiFields.add("url");
    openapiFields.add("video_codecs");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoV1Room
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoV1Room.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoV1Room is not found in the empty JSON string", VideoV1Room.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VideoV1Room.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VideoV1Room` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("account_sid") != null && !jsonObj.get("account_sid").isJsonNull()) && !jsonObj.get("account_sid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `account_sid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("account_sid").toString()));
      }
      if ((jsonObj.get("media_region") != null && !jsonObj.get("media_region").isJsonNull()) && !jsonObj.get("media_region").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `media_region` to be a primitive type in the JSON string but got `%s`", jsonObj.get("media_region").toString()));
      }
      if ((jsonObj.get("sid") != null && !jsonObj.get("sid").isJsonNull()) && !jsonObj.get("sid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sid").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        RoomEnumRoomStatus.validateJsonElement(jsonObj.get("status"));
      }
      if ((jsonObj.get("status_callback") != null && !jsonObj.get("status_callback").isJsonNull()) && !jsonObj.get("status_callback").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status_callback` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status_callback").toString()));
      }
      if ((jsonObj.get("status_callback_method") != null && !jsonObj.get("status_callback_method").isJsonNull()) && !jsonObj.get("status_callback_method").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status_callback_method` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status_callback_method").toString()));
      }
      // validate the optional field `status_callback_method`
      if (jsonObj.get("status_callback_method") != null && !jsonObj.get("status_callback_method").isJsonNull()) {
        StatusCallbackMethodEnum.validateJsonElement(jsonObj.get("status_callback_method"));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        RoomEnumRoomType.validateJsonElement(jsonObj.get("type"));
      }
      if ((jsonObj.get("unique_name") != null && !jsonObj.get("unique_name").isJsonNull()) && !jsonObj.get("unique_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `unique_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("unique_name").toString()));
      }
      if ((jsonObj.get("url") != null && !jsonObj.get("url").isJsonNull()) && !jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("video_codecs") != null && !jsonObj.get("video_codecs").isJsonNull() && !jsonObj.get("video_codecs").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `video_codecs` to be an array in the JSON string but got `%s`", jsonObj.get("video_codecs").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VideoV1Room.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VideoV1Room' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VideoV1Room> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VideoV1Room.class));

       return (TypeAdapter<T>) new TypeAdapter<VideoV1Room>() {
           @Override
           public void write(JsonWriter out, VideoV1Room value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VideoV1Room read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VideoV1Room given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoV1Room
   * @throws IOException if the JSON string is invalid with respect to VideoV1Room
   */
  public static VideoV1Room fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoV1Room.class);
  }

  /**
   * Convert an instance of VideoV1Room to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

