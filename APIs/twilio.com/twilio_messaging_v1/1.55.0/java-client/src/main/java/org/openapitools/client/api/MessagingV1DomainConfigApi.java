/*
 * Twilio - Messaging
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.55.0
 * Contact: support@twilio.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.MessagingV1DomainConfig;
import java.net.URI;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MessagingV1DomainConfigApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MessagingV1DomainConfigApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MessagingV1DomainConfigApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for fetchDomainConfig
     * @param domainSid Unique string used to identify the domain that this config should be associated with. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fetchDomainConfigCall(String domainSid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://messaging.twilio.com" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/LinkShortening/Domains/{DomainSid}/Config"
            .replace("{" + "DomainSid" + "}", localVarApiClient.escapeString(domainSid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accountSid_authToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchDomainConfigValidateBeforeCall(String domainSid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'domainSid' is set
        if (domainSid == null) {
            throw new ApiException("Missing the required parameter 'domainSid' when calling fetchDomainConfig(Async)");
        }

        return fetchDomainConfigCall(domainSid, _callback);

    }

    /**
     * 
     * 
     * @param domainSid Unique string used to identify the domain that this config should be associated with. (required)
     * @return MessagingV1DomainConfig
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public MessagingV1DomainConfig fetchDomainConfig(String domainSid) throws ApiException {
        ApiResponse<MessagingV1DomainConfig> localVarResp = fetchDomainConfigWithHttpInfo(domainSid);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param domainSid Unique string used to identify the domain that this config should be associated with. (required)
     * @return ApiResponse&lt;MessagingV1DomainConfig&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MessagingV1DomainConfig> fetchDomainConfigWithHttpInfo(String domainSid) throws ApiException {
        okhttp3.Call localVarCall = fetchDomainConfigValidateBeforeCall(domainSid, null);
        Type localVarReturnType = new TypeToken<MessagingV1DomainConfig>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param domainSid Unique string used to identify the domain that this config should be associated with. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call fetchDomainConfigAsync(String domainSid, final ApiCallback<MessagingV1DomainConfig> _callback) throws ApiException {

        okhttp3.Call localVarCall = fetchDomainConfigValidateBeforeCall(domainSid, _callback);
        Type localVarReturnType = new TypeToken<MessagingV1DomainConfig>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateDomainConfig
     * @param domainSid Unique string used to identify the domain that this config should be associated with. (required)
     * @param callbackUrl URL to receive click events to your webhook whenever the recipients click on the shortened links (optional)
     * @param continueOnFailure Boolean field to set customer delivery preference when there is a failure in linkShortening service (optional)
     * @param disableHttps Customer&#39;s choice to send links with/without \\\&quot;https://\\\&quot; attached to shortened url. If true, messages will not be sent with https:// at the beginning of the url. If false, messages will be sent with https:// at the beginning of the url. False is the default behavior if it is not specified. (optional)
     * @param fallbackUrl Any requests we receive to this domain that do not match an existing shortened message will be redirected to the fallback url. These will likely be either expired messages, random misdirected traffic, or intentional scraping. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateDomainConfigCall(String domainSid, URI callbackUrl, Boolean continueOnFailure, Boolean disableHttps, URI fallbackUrl, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] { "https://messaging.twilio.com" };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/LinkShortening/Domains/{DomainSid}/Config"
            .replace("{" + "DomainSid" + "}", localVarApiClient.escapeString(domainSid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (callbackUrl != null) {
            localVarFormParams.put("CallbackUrl", callbackUrl);
        }

        if (continueOnFailure != null) {
            localVarFormParams.put("ContinueOnFailure", continueOnFailure);
        }

        if (disableHttps != null) {
            localVarFormParams.put("DisableHttps", disableHttps);
        }

        if (fallbackUrl != null) {
            localVarFormParams.put("FallbackUrl", fallbackUrl);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "accountSid_authToken" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateDomainConfigValidateBeforeCall(String domainSid, URI callbackUrl, Boolean continueOnFailure, Boolean disableHttps, URI fallbackUrl, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'domainSid' is set
        if (domainSid == null) {
            throw new ApiException("Missing the required parameter 'domainSid' when calling updateDomainConfig(Async)");
        }

        return updateDomainConfigCall(domainSid, callbackUrl, continueOnFailure, disableHttps, fallbackUrl, _callback);

    }

    /**
     * 
     * 
     * @param domainSid Unique string used to identify the domain that this config should be associated with. (required)
     * @param callbackUrl URL to receive click events to your webhook whenever the recipients click on the shortened links (optional)
     * @param continueOnFailure Boolean field to set customer delivery preference when there is a failure in linkShortening service (optional)
     * @param disableHttps Customer&#39;s choice to send links with/without \\\&quot;https://\\\&quot; attached to shortened url. If true, messages will not be sent with https:// at the beginning of the url. If false, messages will be sent with https:// at the beginning of the url. False is the default behavior if it is not specified. (optional)
     * @param fallbackUrl Any requests we receive to this domain that do not match an existing shortened message will be redirected to the fallback url. These will likely be either expired messages, random misdirected traffic, or intentional scraping. (optional)
     * @return MessagingV1DomainConfig
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public MessagingV1DomainConfig updateDomainConfig(String domainSid, URI callbackUrl, Boolean continueOnFailure, Boolean disableHttps, URI fallbackUrl) throws ApiException {
        ApiResponse<MessagingV1DomainConfig> localVarResp = updateDomainConfigWithHttpInfo(domainSid, callbackUrl, continueOnFailure, disableHttps, fallbackUrl);
        return localVarResp.getData();
    }

    /**
     * 
     * 
     * @param domainSid Unique string used to identify the domain that this config should be associated with. (required)
     * @param callbackUrl URL to receive click events to your webhook whenever the recipients click on the shortened links (optional)
     * @param continueOnFailure Boolean field to set customer delivery preference when there is a failure in linkShortening service (optional)
     * @param disableHttps Customer&#39;s choice to send links with/without \\\&quot;https://\\\&quot; attached to shortened url. If true, messages will not be sent with https:// at the beginning of the url. If false, messages will be sent with https:// at the beginning of the url. False is the default behavior if it is not specified. (optional)
     * @param fallbackUrl Any requests we receive to this domain that do not match an existing shortened message will be redirected to the fallback url. These will likely be either expired messages, random misdirected traffic, or intentional scraping. (optional)
     * @return ApiResponse&lt;MessagingV1DomainConfig&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MessagingV1DomainConfig> updateDomainConfigWithHttpInfo(String domainSid, URI callbackUrl, Boolean continueOnFailure, Boolean disableHttps, URI fallbackUrl) throws ApiException {
        okhttp3.Call localVarCall = updateDomainConfigValidateBeforeCall(domainSid, callbackUrl, continueOnFailure, disableHttps, fallbackUrl, null);
        Type localVarReturnType = new TypeToken<MessagingV1DomainConfig>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param domainSid Unique string used to identify the domain that this config should be associated with. (required)
     * @param callbackUrl URL to receive click events to your webhook whenever the recipients click on the shortened links (optional)
     * @param continueOnFailure Boolean field to set customer delivery preference when there is a failure in linkShortening service (optional)
     * @param disableHttps Customer&#39;s choice to send links with/without \\\&quot;https://\\\&quot; attached to shortened url. If true, messages will not be sent with https:// at the beginning of the url. If false, messages will be sent with https:// at the beginning of the url. False is the default behavior if it is not specified. (optional)
     * @param fallbackUrl Any requests we receive to this domain that do not match an existing shortened message will be redirected to the fallback url. These will likely be either expired messages, random misdirected traffic, or intentional scraping. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateDomainConfigAsync(String domainSid, URI callbackUrl, Boolean continueOnFailure, Boolean disableHttps, URI fallbackUrl, final ApiCallback<MessagingV1DomainConfig> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateDomainConfigValidateBeforeCall(domainSid, callbackUrl, continueOnFailure, disableHttps, fallbackUrl, _callback);
        Type localVarReturnType = new TypeToken<MessagingV1DomainConfig>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
