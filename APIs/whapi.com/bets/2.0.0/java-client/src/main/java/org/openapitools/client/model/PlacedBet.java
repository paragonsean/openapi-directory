/*
 * Bets API
 * The Bets API methods are used to place single, multiple and complex bets and to retrieve a customer’s bet history. When retrieving a customer’s bet history you can organize the bets from the betting history in terms of date, bet type and whether the bet is settled or not. You can also specify what fields to be included/excluded or return a list of all default fields the method returns. <br /><br /> The Bets API will also generate a bet delay if you’re placing a single/multiple bet in-Play by creating a time margin to negate the effects of major changes to the market (for example, goals during a football match). Note that in version 2 of our APIs, Bets API contains the functionality of both Bets API v1 and the Betslips API v1.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: platform@williamhill.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.PlacedBetLeg;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * PlacedBet
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:21:46.039338-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PlacedBet {
  public static final String SERIALIZED_NAME_CASHIN_VALUE = "cashinValue";
  @SerializedName(SERIALIZED_NAME_CASHIN_VALUE)
  private Double cashinValue;

  public static final String SERIALIZED_NAME_ESTIMATED_RETURNS = "estimatedReturns";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_RETURNS)
  private Double estimatedReturns;

  public static final String SERIALIZED_NAME_FREE_BET_VALUE = "freeBetValue";
  @SerializedName(SERIALIZED_NAME_FREE_BET_VALUE)
  private Double freeBetValue;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_LEGS = "legs";
  @SerializedName(SERIALIZED_NAME_LEGS)
  private List<PlacedBetLeg> legs = new ArrayList<>();

  public static final String SERIALIZED_NAME_NUM_LINES = "numLines";
  @SerializedName(SERIALIZED_NAME_NUM_LINES)
  private Integer numLines;

  public static final String SERIALIZED_NAME_NUM_SELECTIONS = "numSelections";
  @SerializedName(SERIALIZED_NAME_NUM_SELECTIONS)
  private Integer numSelections;

  public static final String SERIALIZED_NAME_RECEIPT = "receipt";
  @SerializedName(SERIALIZED_NAME_RECEIPT)
  private String receipt;

  public static final String SERIALIZED_NAME_SETTLED = "settled";
  @SerializedName(SERIALIZED_NAME_SETTLED)
  private Boolean settled;

  public static final String SERIALIZED_NAME_STAKE = "stake";
  @SerializedName(SERIALIZED_NAME_STAKE)
  private Double stake;

  public static final String SERIALIZED_NAME_STAKE_PER_LINE = "stakePerLine";
  @SerializedName(SERIALIZED_NAME_STAKE_PER_LINE)
  private Double stakePerLine;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_TRANS_DATE_TIME = "transDateTime";
  @SerializedName(SERIALIZED_NAME_TRANS_DATE_TIME)
  private String transDateTime;

  public static final String SERIALIZED_NAME_TYPE_CODE = "typeCode";
  @SerializedName(SERIALIZED_NAME_TYPE_CODE)
  private String typeCode;

  public static final String SERIALIZED_NAME_TYPE_NAME = "typeName";
  @SerializedName(SERIALIZED_NAME_TYPE_NAME)
  private String typeName;

  public static final String SERIALIZED_NAME_WINNINGS = "winnings";
  @SerializedName(SERIALIZED_NAME_WINNINGS)
  private Double winnings;

  public PlacedBet() {
  }

  public PlacedBet cashinValue(Double cashinValue) {
    this.cashinValue = cashinValue;
    return this;
  }

  /**
   * The cash in value of the bet. For example £0.88. When no value is given or no value is present, no cash in is available
   * @return cashinValue
   */
  @javax.annotation.Nullable
  public Double getCashinValue() {
    return cashinValue;
  }

  public void setCashinValue(Double cashinValue) {
    this.cashinValue = cashinValue;
  }


  public PlacedBet estimatedReturns(Double estimatedReturns) {
    this.estimatedReturns = estimatedReturns;
    return this;
  }

  /**
   * The estimated value of the returns if the bet is successful. Note: when an estimated return isn’t available, as in the case of a bet placed on a horse at SP (starting price) where the actual price is unknown when the bet is placed, ‘NOT_AVAILABLE’ will appear in the response field.
   * @return estimatedReturns
   */
  @javax.annotation.Nonnull
  public Double getEstimatedReturns() {
    return estimatedReturns;
  }

  public void setEstimatedReturns(Double estimatedReturns) {
    this.estimatedReturns = estimatedReturns;
  }


  public PlacedBet freeBetValue(Double freeBetValue) {
    this.freeBetValue = freeBetValue;
    return this;
  }

  /**
   * If a free bet token is used for the bet, this element represents the value
   * @return freeBetValue
   */
  @javax.annotation.Nullable
  public Double getFreeBetValue() {
    return freeBetValue;
  }

  public void setFreeBetValue(Double freeBetValue) {
    this.freeBetValue = freeBetValue;
  }


  public PlacedBet id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The unique identifier of the bet
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public PlacedBet legs(List<PlacedBetLeg> legs) {
    this.legs = legs;
    return this;
  }

  public PlacedBet addLegsItem(PlacedBetLeg legsItem) {
    if (this.legs == null) {
      this.legs = new ArrayList<>();
    }
    this.legs.add(legsItem);
    return this;
  }

  /**
   * Get legs
   * @return legs
   */
  @javax.annotation.Nullable
  public List<PlacedBetLeg> getLegs() {
    return legs;
  }

  public void setLegs(List<PlacedBetLeg> legs) {
    this.legs = legs;
  }


  public PlacedBet numLines(Integer numLines) {
    this.numLines = numLines;
    return this;
  }

  /**
   * Number of lines of bets
   * @return numLines
   */
  @javax.annotation.Nullable
  public Integer getNumLines() {
    return numLines;
  }

  public void setNumLines(Integer numLines) {
    this.numLines = numLines;
  }


  public PlacedBet numSelections(Integer numSelections) {
    this.numSelections = numSelections;
    return this;
  }

  /**
   * Number of selections that the bet is made of
   * @return numSelections
   */
  @javax.annotation.Nullable
  public Integer getNumSelections() {
    return numSelections;
  }

  public void setNumSelections(Integer numSelections) {
    this.numSelections = numSelections;
  }


  public PlacedBet receipt(String receipt) {
    this.receipt = receipt;
    return this;
  }

  /**
   * The unique identifier of the receipt for the bet
   * @return receipt
   */
  @javax.annotation.Nullable
  public String getReceipt() {
    return receipt;
  }

  public void setReceipt(String receipt) {
    this.receipt = receipt;
  }


  public PlacedBet settled(Boolean settled) {
    this.settled = settled;
    return this;
  }

  /**
   * Whether the bet is settled
   * @return settled
   */
  @javax.annotation.Nonnull
  public Boolean getSettled() {
    return settled;
  }

  public void setSettled(Boolean settled) {
    this.settled = settled;
  }


  public PlacedBet stake(Double stake) {
    this.stake = stake;
    return this;
  }

  /**
   * The bet stake, which represents the total value of the bet. For example: £ 12.34
   * @return stake
   */
  @javax.annotation.Nonnull
  public Double getStake() {
    return stake;
  }

  public void setStake(Double stake) {
    this.stake = stake;
  }


  public PlacedBet stakePerLine(Double stakePerLine) {
    this.stakePerLine = stakePerLine;
    return this;
  }

  /**
   * The individual stake on each line of the bet. For example: £ 6.17
   * @return stakePerLine
   */
  @javax.annotation.Nullable
  public Double getStakePerLine() {
    return stakePerLine;
  }

  public void setStakePerLine(Double stakePerLine) {
    this.stakePerLine = stakePerLine;
  }


  public PlacedBet status(String status) {
    this.status = status;
    return this;
  }

  /**
   * The status of the bet. Can be one of the following: A - Active, S - suspended, C - Cashed Out
   * @return status
   */
  @javax.annotation.Nonnull
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }


  public PlacedBet transDateTime(String transDateTime) {
    this.transDateTime = transDateTime;
    return this;
  }

  /**
   * The time the bet was placed
   * @return transDateTime
   */
  @javax.annotation.Nonnull
  public String getTransDateTime() {
    return transDateTime;
  }

  public void setTransDateTime(String transDateTime) {
    this.transDateTime = transDateTime;
  }


  public PlacedBet typeCode(String typeCode) {
    this.typeCode = typeCode;
    return this;
  }

  /**
   * The bet type code of the bet. For example: TBL (Treble)
   * @return typeCode
   */
  @javax.annotation.Nonnull
  public String getTypeCode() {
    return typeCode;
  }

  public void setTypeCode(String typeCode) {
    this.typeCode = typeCode;
  }


  public PlacedBet typeName(String typeName) {
    this.typeName = typeName;
    return this;
  }

  /**
   * The name of the bet type. For example: Double
   * @return typeName
   */
  @javax.annotation.Nonnull
  public String getTypeName() {
    return typeName;
  }

  public void setTypeName(String typeName) {
    this.typeName = typeName;
  }


  public PlacedBet winnings(Double winnings) {
    this.winnings = winnings;
    return this;
  }

  /**
   * Actual value of the returns from this bet
   * @return winnings
   */
  @javax.annotation.Nonnull
  public Double getWinnings() {
    return winnings;
  }

  public void setWinnings(Double winnings) {
    this.winnings = winnings;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PlacedBet placedBet = (PlacedBet) o;
    return Objects.equals(this.cashinValue, placedBet.cashinValue) &&
        Objects.equals(this.estimatedReturns, placedBet.estimatedReturns) &&
        Objects.equals(this.freeBetValue, placedBet.freeBetValue) &&
        Objects.equals(this.id, placedBet.id) &&
        Objects.equals(this.legs, placedBet.legs) &&
        Objects.equals(this.numLines, placedBet.numLines) &&
        Objects.equals(this.numSelections, placedBet.numSelections) &&
        Objects.equals(this.receipt, placedBet.receipt) &&
        Objects.equals(this.settled, placedBet.settled) &&
        Objects.equals(this.stake, placedBet.stake) &&
        Objects.equals(this.stakePerLine, placedBet.stakePerLine) &&
        Objects.equals(this.status, placedBet.status) &&
        Objects.equals(this.transDateTime, placedBet.transDateTime) &&
        Objects.equals(this.typeCode, placedBet.typeCode) &&
        Objects.equals(this.typeName, placedBet.typeName) &&
        Objects.equals(this.winnings, placedBet.winnings);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cashinValue, estimatedReturns, freeBetValue, id, legs, numLines, numSelections, receipt, settled, stake, stakePerLine, status, transDateTime, typeCode, typeName, winnings);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PlacedBet {\n");
    sb.append("    cashinValue: ").append(toIndentedString(cashinValue)).append("\n");
    sb.append("    estimatedReturns: ").append(toIndentedString(estimatedReturns)).append("\n");
    sb.append("    freeBetValue: ").append(toIndentedString(freeBetValue)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    legs: ").append(toIndentedString(legs)).append("\n");
    sb.append("    numLines: ").append(toIndentedString(numLines)).append("\n");
    sb.append("    numSelections: ").append(toIndentedString(numSelections)).append("\n");
    sb.append("    receipt: ").append(toIndentedString(receipt)).append("\n");
    sb.append("    settled: ").append(toIndentedString(settled)).append("\n");
    sb.append("    stake: ").append(toIndentedString(stake)).append("\n");
    sb.append("    stakePerLine: ").append(toIndentedString(stakePerLine)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    transDateTime: ").append(toIndentedString(transDateTime)).append("\n");
    sb.append("    typeCode: ").append(toIndentedString(typeCode)).append("\n");
    sb.append("    typeName: ").append(toIndentedString(typeName)).append("\n");
    sb.append("    winnings: ").append(toIndentedString(winnings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cashinValue");
    openapiFields.add("estimatedReturns");
    openapiFields.add("freeBetValue");
    openapiFields.add("id");
    openapiFields.add("legs");
    openapiFields.add("numLines");
    openapiFields.add("numSelections");
    openapiFields.add("receipt");
    openapiFields.add("settled");
    openapiFields.add("stake");
    openapiFields.add("stakePerLine");
    openapiFields.add("status");
    openapiFields.add("transDateTime");
    openapiFields.add("typeCode");
    openapiFields.add("typeName");
    openapiFields.add("winnings");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("estimatedReturns");
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("settled");
    openapiRequiredFields.add("stake");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("transDateTime");
    openapiRequiredFields.add("typeCode");
    openapiRequiredFields.add("typeName");
    openapiRequiredFields.add("winnings");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PlacedBet
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PlacedBet.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PlacedBet is not found in the empty JSON string", PlacedBet.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PlacedBet.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PlacedBet` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : PlacedBet.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (jsonObj.get("legs") != null && !jsonObj.get("legs").isJsonNull()) {
        JsonArray jsonArraylegs = jsonObj.getAsJsonArray("legs");
        if (jsonArraylegs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("legs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `legs` to be an array in the JSON string but got `%s`", jsonObj.get("legs").toString()));
          }

          // validate the optional field `legs` (array)
          for (int i = 0; i < jsonArraylegs.size(); i++) {
            PlacedBetLeg.validateJsonElement(jsonArraylegs.get(i));
          };
        }
      }
      if ((jsonObj.get("receipt") != null && !jsonObj.get("receipt").isJsonNull()) && !jsonObj.get("receipt").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `receipt` to be a primitive type in the JSON string but got `%s`", jsonObj.get("receipt").toString()));
      }
      if (!jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      if (!jsonObj.get("transDateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transDateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transDateTime").toString()));
      }
      if (!jsonObj.get("typeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `typeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("typeCode").toString()));
      }
      if (!jsonObj.get("typeName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `typeName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("typeName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PlacedBet.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PlacedBet' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PlacedBet> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PlacedBet.class));

       return (TypeAdapter<T>) new TypeAdapter<PlacedBet>() {
           @Override
           public void write(JsonWriter out, PlacedBet value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PlacedBet read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PlacedBet given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PlacedBet
   * @throws IOException if the JSON string is invalid with respect to PlacedBet
   */
  public static PlacedBet fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PlacedBet.class);
  }

  /**
   * Convert an instance of PlacedBet to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

