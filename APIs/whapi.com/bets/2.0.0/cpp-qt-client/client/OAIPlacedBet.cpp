/**
 * Bets API
 * The Bets API methods are used to place single, multiple and complex bets and to retrieve a customer’s bet history. When retrieving a customer’s bet history you can organize the bets from the betting history in terms of date, bet type and whether the bet is settled or not. You can also specify what fields to be included/excluded or return a list of all default fields the method returns. <br /><br /> The Bets API will also generate a bet delay if you’re placing a single/multiple bet in-Play by creating a time margin to negate the effects of major changes to the market (for example, goals during a football match). Note that in version 2 of our APIs, Bets API contains the functionality of both Bets API v1 and the Betslips API v1.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: platform@williamhill.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPlacedBet.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPlacedBet::OAIPlacedBet(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPlacedBet::OAIPlacedBet() {
    this->initializeModel();
}

OAIPlacedBet::~OAIPlacedBet() {}

void OAIPlacedBet::initializeModel() {

    m_cashin_value_isSet = false;
    m_cashin_value_isValid = false;

    m_estimated_returns_isSet = false;
    m_estimated_returns_isValid = false;

    m_free_bet_value_isSet = false;
    m_free_bet_value_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_legs_isSet = false;
    m_legs_isValid = false;

    m_num_lines_isSet = false;
    m_num_lines_isValid = false;

    m_num_selections_isSet = false;
    m_num_selections_isValid = false;

    m_receipt_isSet = false;
    m_receipt_isValid = false;

    m_settled_isSet = false;
    m_settled_isValid = false;

    m_stake_isSet = false;
    m_stake_isValid = false;

    m_stake_per_line_isSet = false;
    m_stake_per_line_isValid = false;

    m_status_isSet = false;
    m_status_isValid = false;

    m_trans_date_time_isSet = false;
    m_trans_date_time_isValid = false;

    m_type_code_isSet = false;
    m_type_code_isValid = false;

    m_type_name_isSet = false;
    m_type_name_isValid = false;

    m_winnings_isSet = false;
    m_winnings_isValid = false;
}

void OAIPlacedBet::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPlacedBet::fromJsonObject(QJsonObject json) {

    m_cashin_value_isValid = ::OpenAPI::fromJsonValue(m_cashin_value, json[QString("cashinValue")]);
    m_cashin_value_isSet = !json[QString("cashinValue")].isNull() && m_cashin_value_isValid;

    m_estimated_returns_isValid = ::OpenAPI::fromJsonValue(m_estimated_returns, json[QString("estimatedReturns")]);
    m_estimated_returns_isSet = !json[QString("estimatedReturns")].isNull() && m_estimated_returns_isValid;

    m_free_bet_value_isValid = ::OpenAPI::fromJsonValue(m_free_bet_value, json[QString("freeBetValue")]);
    m_free_bet_value_isSet = !json[QString("freeBetValue")].isNull() && m_free_bet_value_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_legs_isValid = ::OpenAPI::fromJsonValue(m_legs, json[QString("legs")]);
    m_legs_isSet = !json[QString("legs")].isNull() && m_legs_isValid;

    m_num_lines_isValid = ::OpenAPI::fromJsonValue(m_num_lines, json[QString("numLines")]);
    m_num_lines_isSet = !json[QString("numLines")].isNull() && m_num_lines_isValid;

    m_num_selections_isValid = ::OpenAPI::fromJsonValue(m_num_selections, json[QString("numSelections")]);
    m_num_selections_isSet = !json[QString("numSelections")].isNull() && m_num_selections_isValid;

    m_receipt_isValid = ::OpenAPI::fromJsonValue(m_receipt, json[QString("receipt")]);
    m_receipt_isSet = !json[QString("receipt")].isNull() && m_receipt_isValid;

    m_settled_isValid = ::OpenAPI::fromJsonValue(m_settled, json[QString("settled")]);
    m_settled_isSet = !json[QString("settled")].isNull() && m_settled_isValid;

    m_stake_isValid = ::OpenAPI::fromJsonValue(m_stake, json[QString("stake")]);
    m_stake_isSet = !json[QString("stake")].isNull() && m_stake_isValid;

    m_stake_per_line_isValid = ::OpenAPI::fromJsonValue(m_stake_per_line, json[QString("stakePerLine")]);
    m_stake_per_line_isSet = !json[QString("stakePerLine")].isNull() && m_stake_per_line_isValid;

    m_status_isValid = ::OpenAPI::fromJsonValue(m_status, json[QString("status")]);
    m_status_isSet = !json[QString("status")].isNull() && m_status_isValid;

    m_trans_date_time_isValid = ::OpenAPI::fromJsonValue(m_trans_date_time, json[QString("transDateTime")]);
    m_trans_date_time_isSet = !json[QString("transDateTime")].isNull() && m_trans_date_time_isValid;

    m_type_code_isValid = ::OpenAPI::fromJsonValue(m_type_code, json[QString("typeCode")]);
    m_type_code_isSet = !json[QString("typeCode")].isNull() && m_type_code_isValid;

    m_type_name_isValid = ::OpenAPI::fromJsonValue(m_type_name, json[QString("typeName")]);
    m_type_name_isSet = !json[QString("typeName")].isNull() && m_type_name_isValid;

    m_winnings_isValid = ::OpenAPI::fromJsonValue(m_winnings, json[QString("winnings")]);
    m_winnings_isSet = !json[QString("winnings")].isNull() && m_winnings_isValid;
}

QString OAIPlacedBet::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPlacedBet::asJsonObject() const {
    QJsonObject obj;
    if (m_cashin_value_isSet) {
        obj.insert(QString("cashinValue"), ::OpenAPI::toJsonValue(m_cashin_value));
    }
    if (m_estimated_returns_isSet) {
        obj.insert(QString("estimatedReturns"), ::OpenAPI::toJsonValue(m_estimated_returns));
    }
    if (m_free_bet_value_isSet) {
        obj.insert(QString("freeBetValue"), ::OpenAPI::toJsonValue(m_free_bet_value));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_legs.size() > 0) {
        obj.insert(QString("legs"), ::OpenAPI::toJsonValue(m_legs));
    }
    if (m_num_lines_isSet) {
        obj.insert(QString("numLines"), ::OpenAPI::toJsonValue(m_num_lines));
    }
    if (m_num_selections_isSet) {
        obj.insert(QString("numSelections"), ::OpenAPI::toJsonValue(m_num_selections));
    }
    if (m_receipt_isSet) {
        obj.insert(QString("receipt"), ::OpenAPI::toJsonValue(m_receipt));
    }
    if (m_settled_isSet) {
        obj.insert(QString("settled"), ::OpenAPI::toJsonValue(m_settled));
    }
    if (m_stake_isSet) {
        obj.insert(QString("stake"), ::OpenAPI::toJsonValue(m_stake));
    }
    if (m_stake_per_line_isSet) {
        obj.insert(QString("stakePerLine"), ::OpenAPI::toJsonValue(m_stake_per_line));
    }
    if (m_status_isSet) {
        obj.insert(QString("status"), ::OpenAPI::toJsonValue(m_status));
    }
    if (m_trans_date_time_isSet) {
        obj.insert(QString("transDateTime"), ::OpenAPI::toJsonValue(m_trans_date_time));
    }
    if (m_type_code_isSet) {
        obj.insert(QString("typeCode"), ::OpenAPI::toJsonValue(m_type_code));
    }
    if (m_type_name_isSet) {
        obj.insert(QString("typeName"), ::OpenAPI::toJsonValue(m_type_name));
    }
    if (m_winnings_isSet) {
        obj.insert(QString("winnings"), ::OpenAPI::toJsonValue(m_winnings));
    }
    return obj;
}

double OAIPlacedBet::getCashinValue() const {
    return m_cashin_value;
}
void OAIPlacedBet::setCashinValue(const double &cashin_value) {
    m_cashin_value = cashin_value;
    m_cashin_value_isSet = true;
}

bool OAIPlacedBet::is_cashin_value_Set() const{
    return m_cashin_value_isSet;
}

bool OAIPlacedBet::is_cashin_value_Valid() const{
    return m_cashin_value_isValid;
}

double OAIPlacedBet::getEstimatedReturns() const {
    return m_estimated_returns;
}
void OAIPlacedBet::setEstimatedReturns(const double &estimated_returns) {
    m_estimated_returns = estimated_returns;
    m_estimated_returns_isSet = true;
}

bool OAIPlacedBet::is_estimated_returns_Set() const{
    return m_estimated_returns_isSet;
}

bool OAIPlacedBet::is_estimated_returns_Valid() const{
    return m_estimated_returns_isValid;
}

double OAIPlacedBet::getFreeBetValue() const {
    return m_free_bet_value;
}
void OAIPlacedBet::setFreeBetValue(const double &free_bet_value) {
    m_free_bet_value = free_bet_value;
    m_free_bet_value_isSet = true;
}

bool OAIPlacedBet::is_free_bet_value_Set() const{
    return m_free_bet_value_isSet;
}

bool OAIPlacedBet::is_free_bet_value_Valid() const{
    return m_free_bet_value_isValid;
}

QString OAIPlacedBet::getId() const {
    return m_id;
}
void OAIPlacedBet::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIPlacedBet::is_id_Set() const{
    return m_id_isSet;
}

bool OAIPlacedBet::is_id_Valid() const{
    return m_id_isValid;
}

QList<OAIPlacedBetLeg> OAIPlacedBet::getLegs() const {
    return m_legs;
}
void OAIPlacedBet::setLegs(const QList<OAIPlacedBetLeg> &legs) {
    m_legs = legs;
    m_legs_isSet = true;
}

bool OAIPlacedBet::is_legs_Set() const{
    return m_legs_isSet;
}

bool OAIPlacedBet::is_legs_Valid() const{
    return m_legs_isValid;
}

qint32 OAIPlacedBet::getNumLines() const {
    return m_num_lines;
}
void OAIPlacedBet::setNumLines(const qint32 &num_lines) {
    m_num_lines = num_lines;
    m_num_lines_isSet = true;
}

bool OAIPlacedBet::is_num_lines_Set() const{
    return m_num_lines_isSet;
}

bool OAIPlacedBet::is_num_lines_Valid() const{
    return m_num_lines_isValid;
}

qint32 OAIPlacedBet::getNumSelections() const {
    return m_num_selections;
}
void OAIPlacedBet::setNumSelections(const qint32 &num_selections) {
    m_num_selections = num_selections;
    m_num_selections_isSet = true;
}

bool OAIPlacedBet::is_num_selections_Set() const{
    return m_num_selections_isSet;
}

bool OAIPlacedBet::is_num_selections_Valid() const{
    return m_num_selections_isValid;
}

QString OAIPlacedBet::getReceipt() const {
    return m_receipt;
}
void OAIPlacedBet::setReceipt(const QString &receipt) {
    m_receipt = receipt;
    m_receipt_isSet = true;
}

bool OAIPlacedBet::is_receipt_Set() const{
    return m_receipt_isSet;
}

bool OAIPlacedBet::is_receipt_Valid() const{
    return m_receipt_isValid;
}

bool OAIPlacedBet::isSettled() const {
    return m_settled;
}
void OAIPlacedBet::setSettled(const bool &settled) {
    m_settled = settled;
    m_settled_isSet = true;
}

bool OAIPlacedBet::is_settled_Set() const{
    return m_settled_isSet;
}

bool OAIPlacedBet::is_settled_Valid() const{
    return m_settled_isValid;
}

double OAIPlacedBet::getStake() const {
    return m_stake;
}
void OAIPlacedBet::setStake(const double &stake) {
    m_stake = stake;
    m_stake_isSet = true;
}

bool OAIPlacedBet::is_stake_Set() const{
    return m_stake_isSet;
}

bool OAIPlacedBet::is_stake_Valid() const{
    return m_stake_isValid;
}

double OAIPlacedBet::getStakePerLine() const {
    return m_stake_per_line;
}
void OAIPlacedBet::setStakePerLine(const double &stake_per_line) {
    m_stake_per_line = stake_per_line;
    m_stake_per_line_isSet = true;
}

bool OAIPlacedBet::is_stake_per_line_Set() const{
    return m_stake_per_line_isSet;
}

bool OAIPlacedBet::is_stake_per_line_Valid() const{
    return m_stake_per_line_isValid;
}

QString OAIPlacedBet::getStatus() const {
    return m_status;
}
void OAIPlacedBet::setStatus(const QString &status) {
    m_status = status;
    m_status_isSet = true;
}

bool OAIPlacedBet::is_status_Set() const{
    return m_status_isSet;
}

bool OAIPlacedBet::is_status_Valid() const{
    return m_status_isValid;
}

QString OAIPlacedBet::getTransDateTime() const {
    return m_trans_date_time;
}
void OAIPlacedBet::setTransDateTime(const QString &trans_date_time) {
    m_trans_date_time = trans_date_time;
    m_trans_date_time_isSet = true;
}

bool OAIPlacedBet::is_trans_date_time_Set() const{
    return m_trans_date_time_isSet;
}

bool OAIPlacedBet::is_trans_date_time_Valid() const{
    return m_trans_date_time_isValid;
}

QString OAIPlacedBet::getTypeCode() const {
    return m_type_code;
}
void OAIPlacedBet::setTypeCode(const QString &type_code) {
    m_type_code = type_code;
    m_type_code_isSet = true;
}

bool OAIPlacedBet::is_type_code_Set() const{
    return m_type_code_isSet;
}

bool OAIPlacedBet::is_type_code_Valid() const{
    return m_type_code_isValid;
}

QString OAIPlacedBet::getTypeName() const {
    return m_type_name;
}
void OAIPlacedBet::setTypeName(const QString &type_name) {
    m_type_name = type_name;
    m_type_name_isSet = true;
}

bool OAIPlacedBet::is_type_name_Set() const{
    return m_type_name_isSet;
}

bool OAIPlacedBet::is_type_name_Valid() const{
    return m_type_name_isValid;
}

double OAIPlacedBet::getWinnings() const {
    return m_winnings;
}
void OAIPlacedBet::setWinnings(const double &winnings) {
    m_winnings = winnings;
    m_winnings_isSet = true;
}

bool OAIPlacedBet::is_winnings_Set() const{
    return m_winnings_isSet;
}

bool OAIPlacedBet::is_winnings_Valid() const{
    return m_winnings_isValid;
}

bool OAIPlacedBet::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cashin_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_estimated_returns_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_free_bet_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_legs.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_lines_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_num_selections_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_receipt_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_settled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stake_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stake_per_line_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_trans_date_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_code_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_winnings_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPlacedBet::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_estimated_returns_isValid && m_id_isValid && m_settled_isValid && m_stake_isValid && m_status_isValid && m_trans_date_time_isValid && m_type_code_isValid && m_type_name_isValid && m_winnings_isValid && true;
}

} // namespace OpenAPI
