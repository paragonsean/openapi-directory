/*
 * SportsData API
 * The William Hill SportsData REST API is a collection of GET methods to provide William Hill product data such as sport, competition, event, market and selection data (including prices).
 *
 * The version of the OpenAPI document: 2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Selection;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Market
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:21:47.763944-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Market {
  public static final String SERIALIZED_NAME_ANTEPOST_MARKET = "antepostMarket";
  @SerializedName(SERIALIZED_NAME_ANTEPOST_MARKET)
  private Boolean antepostMarket;

  public static final String SERIALIZED_NAME_BEST_ODDS_GUARANTEED = "bestOddsGuaranteed";
  @SerializedName(SERIALIZED_NAME_BEST_ODDS_GUARANTEED)
  private Boolean bestOddsGuaranteed;

  public static final String SERIALIZED_NAME_BET_IN_RUNNING_DELAY = "betInRunningDelay";
  @SerializedName(SERIALIZED_NAME_BET_IN_RUNNING_DELAY)
  private BigDecimal betInRunningDelay;

  public static final String SERIALIZED_NAME_CHANNELS = "channels";
  @SerializedName(SERIALIZED_NAME_CHANNELS)
  private String channels;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DISPLAYED = "displayed";
  @SerializedName(SERIALIZED_NAME_DISPLAYED)
  private Boolean displayed;

  public static final String SERIALIZED_NAME_EACH_WAY = "eachWay";
  @SerializedName(SERIALIZED_NAME_EACH_WAY)
  private Boolean eachWay;

  public static final String SERIALIZED_NAME_EACH_WAY_FACTOR_DEN = "eachWayFactorDen";
  @SerializedName(SERIALIZED_NAME_EACH_WAY_FACTOR_DEN)
  private BigDecimal eachWayFactorDen;

  public static final String SERIALIZED_NAME_EACH_WAY_FACTOR_NUM = "eachWayFactorNum";
  @SerializedName(SERIALIZED_NAME_EACH_WAY_FACTOR_NUM)
  private BigDecimal eachWayFactorNum;

  public static final String SERIALIZED_NAME_EACH_WAY_PLACES = "eachWayPlaces";
  @SerializedName(SERIALIZED_NAME_EACH_WAY_PLACES)
  private BigDecimal eachWayPlaces;

  public static final String SERIALIZED_NAME_EARLY_PRICE_AVAILABLE = "earlyPriceAvailable";
  @SerializedName(SERIALIZED_NAME_EARLY_PRICE_AVAILABLE)
  private Boolean earlyPriceAvailable;

  public static final String SERIALIZED_NAME_FC_AVAILABLE = "fcAvailable";
  @SerializedName(SERIALIZED_NAME_FC_AVAILABLE)
  private Boolean fcAvailable;

  public static final String SERIALIZED_NAME_FIRST_FOUR_AVAILABLE = "firstFourAvailable";
  @SerializedName(SERIALIZED_NAME_FIRST_FOUR_AVAILABLE)
  private Boolean firstFourAvailable;

  public static final String SERIALIZED_NAME_FIRST_PRICE_AVAILABLE = "firstPriceAvailable";
  @SerializedName(SERIALIZED_NAME_FIRST_PRICE_AVAILABLE)
  private Boolean firstPriceAvailable;

  public static final String SERIALIZED_NAME_FLAGS = "flags";
  @SerializedName(SERIALIZED_NAME_FLAGS)
  private String flags;

  public static final String SERIALIZED_NAME_HCAP_MAKEUP = "hcapMakeup";
  @SerializedName(SERIALIZED_NAME_HCAP_MAKEUP)
  private BigDecimal hcapMakeup;

  public static final String SERIALIZED_NAME_HCAP_VALUE = "hcapValue";
  @SerializedName(SERIALIZED_NAME_HCAP_VALUE)
  private BigDecimal hcapValue;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IS_IN_PLAY_MARKET = "isInPlayMarket";
  @SerializedName(SERIALIZED_NAME_IS_IN_PLAY_MARKET)
  private Boolean isInPlayMarket;

  public static final String SERIALIZED_NAME_IS_PUBLISHED = "isPublished";
  @SerializedName(SERIALIZED_NAME_IS_PUBLISHED)
  private Boolean isPublished;

  public static final String SERIALIZED_NAME_LIVE_PRICE_AVAILABLE = "livePriceAvailable";
  @SerializedName(SERIALIZED_NAME_LIVE_PRICE_AVAILABLE)
  private Boolean livePriceAvailable;

  public static final String SERIALIZED_NAME_MARKET_GROUP_COLLECTION_ID = "marketGroupCollectionId";
  @SerializedName(SERIALIZED_NAME_MARKET_GROUP_COLLECTION_ID)
  private String marketGroupCollectionId;

  public static final String SERIALIZED_NAME_MARKET_GROUP_ID = "marketGroupId";
  @SerializedName(SERIALIZED_NAME_MARKET_GROUP_ID)
  private String marketGroupId;

  public static final String SERIALIZED_NAME_MARKET_GROUP_NAME = "marketGroupName";
  @SerializedName(SERIALIZED_NAME_MARKET_GROUP_NAME)
  private String marketGroupName;

  public static final String SERIALIZED_NAME_MARKET_SORT = "marketSort";
  @SerializedName(SERIALIZED_NAME_MARKET_SORT)
  private String marketSort;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_ORDER = "order";
  @SerializedName(SERIALIZED_NAME_ORDER)
  private BigDecimal order;

  public static final String SERIALIZED_NAME_PARENT_IDS = "parentIds";
  @SerializedName(SERIALIZED_NAME_PARENT_IDS)
  private List<String> parentIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_QUINELLA_AVAILABLE = "quinellaAvailable";
  @SerializedName(SERIALIZED_NAME_QUINELLA_AVAILABLE)
  private Boolean quinellaAvailable;

  public static final String SERIALIZED_NAME_SELECTIONS = "selections";
  @SerializedName(SERIALIZED_NAME_SELECTIONS)
  private List<Selection> selections = new ArrayList<>();

  public static final String SERIALIZED_NAME_SETTLED = "settled";
  @SerializedName(SERIALIZED_NAME_SETTLED)
  private Boolean settled;

  public static final String SERIALIZED_NAME_STARTING_PRICE_AVAILABLE = "startingPriceAvailable";
  @SerializedName(SERIALIZED_NAME_STARTING_PRICE_AVAILABLE)
  private Boolean startingPriceAvailable;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private String status;

  public static final String SERIALIZED_NAME_TC_AVAILABLE = "tcAvailable";
  @SerializedName(SERIALIZED_NAME_TC_AVAILABLE)
  private Boolean tcAvailable;

  public Market() {
  }

  public Market antepostMarket(Boolean antepostMarket) {
    this.antepostMarket = antepostMarket;
    return this;
  }

  /**
   * Antepost Market
   * @return antepostMarket
   */
  @javax.annotation.Nullable
  public Boolean getAntepostMarket() {
    return antepostMarket;
  }

  public void setAntepostMarket(Boolean antepostMarket) {
    this.antepostMarket = antepostMarket;
  }


  public Market bestOddsGuaranteed(Boolean bestOddsGuaranteed) {
    this.bestOddsGuaranteed = bestOddsGuaranteed;
    return this;
  }

  /**
   * BOG Available
   * @return bestOddsGuaranteed
   */
  @javax.annotation.Nullable
  public Boolean getBestOddsGuaranteed() {
    return bestOddsGuaranteed;
  }

  public void setBestOddsGuaranteed(Boolean bestOddsGuaranteed) {
    this.bestOddsGuaranteed = bestOddsGuaranteed;
  }


  public Market betInRunningDelay(BigDecimal betInRunningDelay) {
    this.betInRunningDelay = betInRunningDelay;
    return this;
  }

  /**
   * Get betInRunningDelay
   * @return betInRunningDelay
   */
  @javax.annotation.Nullable
  public BigDecimal getBetInRunningDelay() {
    return betInRunningDelay;
  }

  public void setBetInRunningDelay(BigDecimal betInRunningDelay) {
    this.betInRunningDelay = betInRunningDelay;
  }


  public Market channels(String channels) {
    this.channels = channels;
    return this;
  }

  /**
   * A channel indicates where an entry can be accessed. Its made up of a string containing a number of characters
   * @return channels
   */
  @javax.annotation.Nullable
  public String getChannels() {
    return channels;
  }

  public void setChannels(String channels) {
    this.channels = channels;
  }


  public Market description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Additional market information
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public Market displayed(Boolean displayed) {
    this.displayed = displayed;
    return this;
  }

  /**
   * Indicates if the item should be displayed
   * @return displayed
   */
  @javax.annotation.Nullable
  public Boolean getDisplayed() {
    return displayed;
  }

  public void setDisplayed(Boolean displayed) {
    this.displayed = displayed;
  }


  public Market eachWay(Boolean eachWay) {
    this.eachWay = eachWay;
    return this;
  }

  /**
   * Indicates if each way betting is available
   * @return eachWay
   */
  @javax.annotation.Nullable
  public Boolean getEachWay() {
    return eachWay;
  }

  public void setEachWay(Boolean eachWay) {
    this.eachWay = eachWay;
  }


  public Market eachWayFactorDen(BigDecimal eachWayFactorDen) {
    this.eachWayFactorDen = eachWayFactorDen;
    return this;
  }

  /**
   * Where each way terms are stored with the bet, this holds the denominator for the each way factor. For example, if the each way terms are: 5 places pay ¼, this value will be 4
   * @return eachWayFactorDen
   */
  @javax.annotation.Nullable
  public BigDecimal getEachWayFactorDen() {
    return eachWayFactorDen;
  }

  public void setEachWayFactorDen(BigDecimal eachWayFactorDen) {
    this.eachWayFactorDen = eachWayFactorDen;
  }


  public Market eachWayFactorNum(BigDecimal eachWayFactorNum) {
    this.eachWayFactorNum = eachWayFactorNum;
    return this;
  }

  /**
   * Where each way terms are stored with the bet, this holds the numerator for the each way factor. For example, if the each way terms are: 5 places pay ¼, this value will be 1
   * @return eachWayFactorNum
   */
  @javax.annotation.Nullable
  public BigDecimal getEachWayFactorNum() {
    return eachWayFactorNum;
  }

  public void setEachWayFactorNum(BigDecimal eachWayFactorNum) {
    this.eachWayFactorNum = eachWayFactorNum;
  }


  public Market eachWayPlaces(BigDecimal eachWayPlaces) {
    this.eachWayPlaces = eachWayPlaces;
    return this;
  }

  /**
   * Where each way terms are stored with the bet, this holds the number of places paid. For example, if the each way terms are: 5 places pay ¼, this value will be 5
   * @return eachWayPlaces
   */
  @javax.annotation.Nullable
  public BigDecimal getEachWayPlaces() {
    return eachWayPlaces;
  }

  public void setEachWayPlaces(BigDecimal eachWayPlaces) {
    this.eachWayPlaces = eachWayPlaces;
  }


  public Market earlyPriceAvailable(Boolean earlyPriceAvailable) {
    this.earlyPriceAvailable = earlyPriceAvailable;
    return this;
  }

  /**
   * Early Pricing Active
   * @return earlyPriceAvailable
   */
  @javax.annotation.Nullable
  public Boolean getEarlyPriceAvailable() {
    return earlyPriceAvailable;
  }

  public void setEarlyPriceAvailable(Boolean earlyPriceAvailable) {
    this.earlyPriceAvailable = earlyPriceAvailable;
  }


  public Market fcAvailable(Boolean fcAvailable) {
    this.fcAvailable = fcAvailable;
    return this;
  }

  /**
   * Is tricast betting available
   * @return fcAvailable
   */
  @javax.annotation.Nullable
  public Boolean getFcAvailable() {
    return fcAvailable;
  }

  public void setFcAvailable(Boolean fcAvailable) {
    this.fcAvailable = fcAvailable;
  }


  public Market firstFourAvailable(Boolean firstFourAvailable) {
    this.firstFourAvailable = firstFourAvailable;
    return this;
  }

  /**
   * Is firstFour betting available
   * @return firstFourAvailable
   */
  @javax.annotation.Nullable
  public Boolean getFirstFourAvailable() {
    return firstFourAvailable;
  }

  public void setFirstFourAvailable(Boolean firstFourAvailable) {
    this.firstFourAvailable = firstFourAvailable;
  }


  public Market firstPriceAvailable(Boolean firstPriceAvailable) {
    this.firstPriceAvailable = firstPriceAvailable;
    return this;
  }

  /**
   * Is firstPrice betting available
   * @return firstPriceAvailable
   */
  @javax.annotation.Nullable
  public Boolean getFirstPriceAvailable() {
    return firstPriceAvailable;
  }

  public void setFirstPriceAvailable(Boolean firstPriceAvailable) {
    this.firstPriceAvailable = firstPriceAvailable;
  }


  public Market flags(String flags) {
    this.flags = flags;
    return this;
  }

  /**
   * Flags for the market
   * @return flags
   */
  @javax.annotation.Nullable
  public String getFlags() {
    return flags;
  }

  public void setFlags(String flags) {
    this.flags = flags;
  }


  public Market hcapMakeup(BigDecimal hcapMakeup) {
    this.hcapMakeup = hcapMakeup;
    return this;
  }

  /**
   * Handicap score
   * @return hcapMakeup
   */
  @javax.annotation.Nullable
  public BigDecimal getHcapMakeup() {
    return hcapMakeup;
  }

  public void setHcapMakeup(BigDecimal hcapMakeup) {
    this.hcapMakeup = hcapMakeup;
  }


  public Market hcapValue(BigDecimal hcapValue) {
    this.hcapValue = hcapValue;
    return this;
  }

  /**
   * This value indicates the current handicap set on the Event Market, assuming it has a handicap type.
   * @return hcapValue
   */
  @javax.annotation.Nullable
  public BigDecimal getHcapValue() {
    return hcapValue;
  }

  public void setHcapValue(BigDecimal hcapValue) {
    this.hcapValue = hcapValue;
  }


  public Market id(String id) {
    this.id = id;
    return this;
  }

  /**
   * ID (e.g. OB_MA{id} (e.g. OB_MA1), OB_SP (Sport), OB_CL (Class), OB_TY (Competition / type), OB_EV (event) OB_MA (Market), OB_OU (Selection / outcome)
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Market isInPlayMarket(Boolean isInPlayMarket) {
    this.isInPlayMarket = isInPlayMarket;
    return this;
  }

  /**
   * Is this an in-play market
   * @return isInPlayMarket
   */
  @javax.annotation.Nullable
  public Boolean getIsInPlayMarket() {
    return isInPlayMarket;
  }

  public void setIsInPlayMarket(Boolean isInPlayMarket) {
    this.isInPlayMarket = isInPlayMarket;
  }


  public Market isPublished(Boolean isPublished) {
    this.isPublished = isPublished;
    return this;
  }

  /**
   * Indicates if the item is published
   * @return isPublished
   */
  @javax.annotation.Nullable
  public Boolean getIsPublished() {
    return isPublished;
  }

  public void setIsPublished(Boolean isPublished) {
    this.isPublished = isPublished;
  }


  public Market livePriceAvailable(Boolean livePriceAvailable) {
    this.livePriceAvailable = livePriceAvailable;
    return this;
  }

  /**
   * Live Price
   * @return livePriceAvailable
   */
  @javax.annotation.Nullable
  public Boolean getLivePriceAvailable() {
    return livePriceAvailable;
  }

  public void setLivePriceAvailable(Boolean livePriceAvailable) {
    this.livePriceAvailable = livePriceAvailable;
  }


  public Market marketGroupCollectionId(String marketGroupCollectionId) {
    this.marketGroupCollectionId = marketGroupCollectionId;
    return this;
  }

  /**
   * The collectionId of the Market Group inherited from
   * @return marketGroupCollectionId
   */
  @javax.annotation.Nullable
  public String getMarketGroupCollectionId() {
    return marketGroupCollectionId;
  }

  public void setMarketGroupCollectionId(String marketGroupCollectionId) {
    this.marketGroupCollectionId = marketGroupCollectionId;
  }


  public Market marketGroupId(String marketGroupId) {
    this.marketGroupId = marketGroupId;
    return this;
  }

  /**
   * The group id the market was inherited from
   * @return marketGroupId
   */
  @javax.annotation.Nullable
  public String getMarketGroupId() {
    return marketGroupId;
  }

  public void setMarketGroupId(String marketGroupId) {
    this.marketGroupId = marketGroupId;
  }


  public Market marketGroupName(String marketGroupName) {
    this.marketGroupName = marketGroupName;
    return this;
  }

  /**
   * The group name the market was inherited from
   * @return marketGroupName
   */
  @javax.annotation.Nullable
  public String getMarketGroupName() {
    return marketGroupName;
  }

  public void setMarketGroupName(String marketGroupName) {
    this.marketGroupName = marketGroupName;
  }


  public Market marketSort(String marketSort) {
    this.marketSort = marketSort;
    return this;
  }

  /**
   * The sort defines the market template
   * @return marketSort
   */
  @javax.annotation.Nullable
  public String getMarketSort() {
    return marketSort;
  }

  public void setMarketSort(String marketSort) {
    this.marketSort = marketSort;
  }


  public Market name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Human-friendly name of the market
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Market order(BigDecimal order) {
    this.order = order;
    return this;
  }

  /**
   * Display order of the items (Ascending)
   * @return order
   */
  @javax.annotation.Nullable
  public BigDecimal getOrder() {
    return order;
  }

  public void setOrder(BigDecimal order) {
    this.order = order;
  }


  public Market parentIds(List<String> parentIds) {
    this.parentIds = parentIds;
    return this;
  }

  public Market addParentIdsItem(String parentIdsItem) {
    if (this.parentIds == null) {
      this.parentIds = new ArrayList<>();
    }
    this.parentIds.add(parentIdsItem);
    return this;
  }

  /**
   * A list of IDs of parent entities
   * @return parentIds
   */
  @javax.annotation.Nullable
  public List<String> getParentIds() {
    return parentIds;
  }

  public void setParentIds(List<String> parentIds) {
    this.parentIds = parentIds;
  }


  public Market quinellaAvailable(Boolean quinellaAvailable) {
    this.quinellaAvailable = quinellaAvailable;
    return this;
  }

  /**
   * Is firstFour betting available
   * @return quinellaAvailable
   */
  @javax.annotation.Nullable
  public Boolean getQuinellaAvailable() {
    return quinellaAvailable;
  }

  public void setQuinellaAvailable(Boolean quinellaAvailable) {
    this.quinellaAvailable = quinellaAvailable;
  }


  public Market selections(List<Selection> selections) {
    this.selections = selections;
    return this;
  }

  public Market addSelectionsItem(Selection selectionsItem) {
    if (this.selections == null) {
      this.selections = new ArrayList<>();
    }
    this.selections.add(selectionsItem);
    return this;
  }

  /**
   * A list of selections belonging to the market
   * @return selections
   */
  @javax.annotation.Nullable
  public List<Selection> getSelections() {
    return selections;
  }

  public void setSelections(List<Selection> selections) {
    this.selections = selections;
  }


  public Market settled(Boolean settled) {
    this.settled = settled;
    return this;
  }

  /**
   * Whether the market is settled or not
   * @return settled
   */
  @javax.annotation.Nullable
  public Boolean getSettled() {
    return settled;
  }

  public void setSettled(Boolean settled) {
    this.settled = settled;
  }


  public Market startingPriceAvailable(Boolean startingPriceAvailable) {
    this.startingPriceAvailable = startingPriceAvailable;
    return this;
  }

  /**
   * Starting Price Available
   * @return startingPriceAvailable
   */
  @javax.annotation.Nullable
  public Boolean getStartingPriceAvailable() {
    return startingPriceAvailable;
  }

  public void setStartingPriceAvailable(Boolean startingPriceAvailable) {
    this.startingPriceAvailable = startingPriceAvailable;
  }


  public Market status(String status) {
    this.status = status;
    return this;
  }

  /**
   * Indicates the status of the Market (A &#x3D; Active/S &#x3D; Suspended)
   * @return status
   */
  @javax.annotation.Nonnull
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }


  public Market tcAvailable(Boolean tcAvailable) {
    this.tcAvailable = tcAvailable;
    return this;
  }

  /**
   * Is forecast betting available
   * @return tcAvailable
   */
  @javax.annotation.Nullable
  public Boolean getTcAvailable() {
    return tcAvailable;
  }

  public void setTcAvailable(Boolean tcAvailable) {
    this.tcAvailable = tcAvailable;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Market market = (Market) o;
    return Objects.equals(this.antepostMarket, market.antepostMarket) &&
        Objects.equals(this.bestOddsGuaranteed, market.bestOddsGuaranteed) &&
        Objects.equals(this.betInRunningDelay, market.betInRunningDelay) &&
        Objects.equals(this.channels, market.channels) &&
        Objects.equals(this.description, market.description) &&
        Objects.equals(this.displayed, market.displayed) &&
        Objects.equals(this.eachWay, market.eachWay) &&
        Objects.equals(this.eachWayFactorDen, market.eachWayFactorDen) &&
        Objects.equals(this.eachWayFactorNum, market.eachWayFactorNum) &&
        Objects.equals(this.eachWayPlaces, market.eachWayPlaces) &&
        Objects.equals(this.earlyPriceAvailable, market.earlyPriceAvailable) &&
        Objects.equals(this.fcAvailable, market.fcAvailable) &&
        Objects.equals(this.firstFourAvailable, market.firstFourAvailable) &&
        Objects.equals(this.firstPriceAvailable, market.firstPriceAvailable) &&
        Objects.equals(this.flags, market.flags) &&
        Objects.equals(this.hcapMakeup, market.hcapMakeup) &&
        Objects.equals(this.hcapValue, market.hcapValue) &&
        Objects.equals(this.id, market.id) &&
        Objects.equals(this.isInPlayMarket, market.isInPlayMarket) &&
        Objects.equals(this.isPublished, market.isPublished) &&
        Objects.equals(this.livePriceAvailable, market.livePriceAvailable) &&
        Objects.equals(this.marketGroupCollectionId, market.marketGroupCollectionId) &&
        Objects.equals(this.marketGroupId, market.marketGroupId) &&
        Objects.equals(this.marketGroupName, market.marketGroupName) &&
        Objects.equals(this.marketSort, market.marketSort) &&
        Objects.equals(this.name, market.name) &&
        Objects.equals(this.order, market.order) &&
        Objects.equals(this.parentIds, market.parentIds) &&
        Objects.equals(this.quinellaAvailable, market.quinellaAvailable) &&
        Objects.equals(this.selections, market.selections) &&
        Objects.equals(this.settled, market.settled) &&
        Objects.equals(this.startingPriceAvailable, market.startingPriceAvailable) &&
        Objects.equals(this.status, market.status) &&
        Objects.equals(this.tcAvailable, market.tcAvailable);
  }

  @Override
  public int hashCode() {
    return Objects.hash(antepostMarket, bestOddsGuaranteed, betInRunningDelay, channels, description, displayed, eachWay, eachWayFactorDen, eachWayFactorNum, eachWayPlaces, earlyPriceAvailable, fcAvailable, firstFourAvailable, firstPriceAvailable, flags, hcapMakeup, hcapValue, id, isInPlayMarket, isPublished, livePriceAvailable, marketGroupCollectionId, marketGroupId, marketGroupName, marketSort, name, order, parentIds, quinellaAvailable, selections, settled, startingPriceAvailable, status, tcAvailable);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Market {\n");
    sb.append("    antepostMarket: ").append(toIndentedString(antepostMarket)).append("\n");
    sb.append("    bestOddsGuaranteed: ").append(toIndentedString(bestOddsGuaranteed)).append("\n");
    sb.append("    betInRunningDelay: ").append(toIndentedString(betInRunningDelay)).append("\n");
    sb.append("    channels: ").append(toIndentedString(channels)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    displayed: ").append(toIndentedString(displayed)).append("\n");
    sb.append("    eachWay: ").append(toIndentedString(eachWay)).append("\n");
    sb.append("    eachWayFactorDen: ").append(toIndentedString(eachWayFactorDen)).append("\n");
    sb.append("    eachWayFactorNum: ").append(toIndentedString(eachWayFactorNum)).append("\n");
    sb.append("    eachWayPlaces: ").append(toIndentedString(eachWayPlaces)).append("\n");
    sb.append("    earlyPriceAvailable: ").append(toIndentedString(earlyPriceAvailable)).append("\n");
    sb.append("    fcAvailable: ").append(toIndentedString(fcAvailable)).append("\n");
    sb.append("    firstFourAvailable: ").append(toIndentedString(firstFourAvailable)).append("\n");
    sb.append("    firstPriceAvailable: ").append(toIndentedString(firstPriceAvailable)).append("\n");
    sb.append("    flags: ").append(toIndentedString(flags)).append("\n");
    sb.append("    hcapMakeup: ").append(toIndentedString(hcapMakeup)).append("\n");
    sb.append("    hcapValue: ").append(toIndentedString(hcapValue)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    isInPlayMarket: ").append(toIndentedString(isInPlayMarket)).append("\n");
    sb.append("    isPublished: ").append(toIndentedString(isPublished)).append("\n");
    sb.append("    livePriceAvailable: ").append(toIndentedString(livePriceAvailable)).append("\n");
    sb.append("    marketGroupCollectionId: ").append(toIndentedString(marketGroupCollectionId)).append("\n");
    sb.append("    marketGroupId: ").append(toIndentedString(marketGroupId)).append("\n");
    sb.append("    marketGroupName: ").append(toIndentedString(marketGroupName)).append("\n");
    sb.append("    marketSort: ").append(toIndentedString(marketSort)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    order: ").append(toIndentedString(order)).append("\n");
    sb.append("    parentIds: ").append(toIndentedString(parentIds)).append("\n");
    sb.append("    quinellaAvailable: ").append(toIndentedString(quinellaAvailable)).append("\n");
    sb.append("    selections: ").append(toIndentedString(selections)).append("\n");
    sb.append("    settled: ").append(toIndentedString(settled)).append("\n");
    sb.append("    startingPriceAvailable: ").append(toIndentedString(startingPriceAvailable)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    tcAvailable: ").append(toIndentedString(tcAvailable)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("antepostMarket");
    openapiFields.add("bestOddsGuaranteed");
    openapiFields.add("betInRunningDelay");
    openapiFields.add("channels");
    openapiFields.add("description");
    openapiFields.add("displayed");
    openapiFields.add("eachWay");
    openapiFields.add("eachWayFactorDen");
    openapiFields.add("eachWayFactorNum");
    openapiFields.add("eachWayPlaces");
    openapiFields.add("earlyPriceAvailable");
    openapiFields.add("fcAvailable");
    openapiFields.add("firstFourAvailable");
    openapiFields.add("firstPriceAvailable");
    openapiFields.add("flags");
    openapiFields.add("hcapMakeup");
    openapiFields.add("hcapValue");
    openapiFields.add("id");
    openapiFields.add("isInPlayMarket");
    openapiFields.add("isPublished");
    openapiFields.add("livePriceAvailable");
    openapiFields.add("marketGroupCollectionId");
    openapiFields.add("marketGroupId");
    openapiFields.add("marketGroupName");
    openapiFields.add("marketSort");
    openapiFields.add("name");
    openapiFields.add("order");
    openapiFields.add("parentIds");
    openapiFields.add("quinellaAvailable");
    openapiFields.add("selections");
    openapiFields.add("settled");
    openapiFields.add("startingPriceAvailable");
    openapiFields.add("status");
    openapiFields.add("tcAvailable");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("status");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Market
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Market.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Market is not found in the empty JSON string", Market.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Market.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Market` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Market.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("channels") != null && !jsonObj.get("channels").isJsonNull()) && !jsonObj.get("channels").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `channels` to be a primitive type in the JSON string but got `%s`", jsonObj.get("channels").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("flags") != null && !jsonObj.get("flags").isJsonNull()) && !jsonObj.get("flags").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `flags` to be a primitive type in the JSON string but got `%s`", jsonObj.get("flags").toString()));
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("marketGroupCollectionId") != null && !jsonObj.get("marketGroupCollectionId").isJsonNull()) && !jsonObj.get("marketGroupCollectionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `marketGroupCollectionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("marketGroupCollectionId").toString()));
      }
      if ((jsonObj.get("marketGroupId") != null && !jsonObj.get("marketGroupId").isJsonNull()) && !jsonObj.get("marketGroupId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `marketGroupId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("marketGroupId").toString()));
      }
      if ((jsonObj.get("marketGroupName") != null && !jsonObj.get("marketGroupName").isJsonNull()) && !jsonObj.get("marketGroupName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `marketGroupName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("marketGroupName").toString()));
      }
      if ((jsonObj.get("marketSort") != null && !jsonObj.get("marketSort").isJsonNull()) && !jsonObj.get("marketSort").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `marketSort` to be a primitive type in the JSON string but got `%s`", jsonObj.get("marketSort").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("parentIds") != null && !jsonObj.get("parentIds").isJsonNull() && !jsonObj.get("parentIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `parentIds` to be an array in the JSON string but got `%s`", jsonObj.get("parentIds").toString()));
      }
      if (jsonObj.get("selections") != null && !jsonObj.get("selections").isJsonNull()) {
        JsonArray jsonArrayselections = jsonObj.getAsJsonArray("selections");
        if (jsonArrayselections != null) {
          // ensure the json data is an array
          if (!jsonObj.get("selections").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `selections` to be an array in the JSON string but got `%s`", jsonObj.get("selections").toString()));
          }

          // validate the optional field `selections` (array)
          for (int i = 0; i < jsonArrayselections.size(); i++) {
            Selection.validateJsonElement(jsonArrayselections.get(i));
          };
        }
      }
      if (!jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Market.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Market' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Market> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Market.class));

       return (TypeAdapter<T>) new TypeAdapter<Market>() {
           @Override
           public void write(JsonWriter out, Market value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Market read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Market given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Market
   * @throws IOException if the JSON string is invalid with respect to Market
   */
  public static Market fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Market.class);
  }

  /**
   * Convert an instance of Market to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

