/**
 * Files.com API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@files.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAISiteApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAISiteApi::OAISiteApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAISiteApi::~OAISiteApi() {
}

void OAISiteApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("//app.files.com/api/rest/v1"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("getSite", defaultConf);
    _serverIndices.insert("getSite", 0);
    _serverConfigs.insert("getSiteApiKeys", defaultConf);
    _serverIndices.insert("getSiteApiKeys", 0);
    _serverConfigs.insert("getSiteDnsRecords", defaultConf);
    _serverIndices.insert("getSiteDnsRecords", 0);
    _serverConfigs.insert("getSiteIpAddresses", defaultConf);
    _serverIndices.insert("getSiteIpAddresses", 0);
    _serverConfigs.insert("getSiteUsage", defaultConf);
    _serverIndices.insert("getSiteUsage", 0);
    _serverConfigs.insert("patchSite", defaultConf);
    _serverIndices.insert("patchSite", 0);
    _serverConfigs.insert("postSiteApiKeys", defaultConf);
    _serverIndices.insert("postSiteApiKeys", 0);
    _serverConfigs.insert("postSiteTestWebhook", defaultConf);
    _serverIndices.insert("postSiteTestWebhook", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAISiteApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAISiteApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAISiteApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAISiteApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAISiteApi::setUsername(const QString &username) {
    _username = username;
}

void OAISiteApi::setPassword(const QString &password) {
    _password = password;
}


void OAISiteApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAISiteApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAISiteApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAISiteApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAISiteApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAISiteApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAISiteApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAISiteApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAISiteApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAISiteApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAISiteApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAISiteApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAISiteApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAISiteApi::getSite() {
    QString fullPath = QString(_serverConfigs["getSite"][_serverIndices.value("getSite")].URL()+"/site");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISiteApi::getSiteCallback);
    connect(this, &OAISiteApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISiteApi::getSiteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISiteEntity output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSiteSignal(output);
        Q_EMIT getSiteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSiteSignalE(output, error_type, error_str);
        Q_EMIT getSiteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSiteSignalError(output, error_type, error_str);
        Q_EMIT getSiteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISiteApi::getSiteApiKeys(const ::OpenAPI::OptionalParam<qint32> &user_id, const ::OpenAPI::OptionalParam<QString> &cursor, const ::OpenAPI::OptionalParam<qint32> &per_page, const ::OpenAPI::OptionalParam<OAIObject> &sort_by, const ::OpenAPI::OptionalParam<OAIObject> &filter, const ::OpenAPI::OptionalParam<OAIObject> &filter_gt, const ::OpenAPI::OptionalParam<OAIObject> &filter_gteq, const ::OpenAPI::OptionalParam<OAIObject> &filter_lt, const ::OpenAPI::OptionalParam<OAIObject> &filter_lteq) {
    QString fullPath = QString(_serverConfigs["getSiteApiKeys"][_serverIndices.value("getSiteApiKeys")].URL()+"/site/api_keys");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (user_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("user_id")).append(querySuffix).append(QUrl::toPercentEncoding(user_id.stringValue()));
    }
    if (cursor.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cursor", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cursor")).append(querySuffix).append(QUrl::toPercentEncoding(cursor.stringValue()));
    }
    if (per_page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(per_page.stringValue()));
    }
    if (sort_by.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "sort_by", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "sort_by"+querySuffix : "";
        QJsonObject parameter = sort_by.value().asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sort_by").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sort_by").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sort_by").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sort_by").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sort_by").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    if (filter.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "filter", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "filter"+querySuffix : "";
        QJsonObject parameter = filter.value().asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    if (filter_gt.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "filter_gt", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "filter_gt"+querySuffix : "";
        QJsonObject parameter = filter_gt.value().asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gt").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gt").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gt").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gt").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gt").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    if (filter_gteq.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "filter_gteq", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "filter_gteq"+querySuffix : "";
        QJsonObject parameter = filter_gteq.value().asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gteq").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gteq").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gteq").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gteq").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_gteq").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    if (filter_lt.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "filter_lt", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "filter_lt"+querySuffix : "";
        QJsonObject parameter = filter_lt.value().asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lt").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lt").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lt").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lt").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lt").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    if (filter_lteq.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "filter_lteq", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "filter_lteq"+querySuffix : "";
        QJsonObject parameter = filter_lteq.value().asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lteq").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lteq").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lteq").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lteq").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("filter_lteq").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISiteApi::getSiteApiKeysCallback);
    connect(this, &OAISiteApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISiteApi::getSiteApiKeysCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApiKeyEntity> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApiKeyEntity val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSiteApiKeysSignal(output);
        Q_EMIT getSiteApiKeysSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSiteApiKeysSignalE(output, error_type, error_str);
        Q_EMIT getSiteApiKeysSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSiteApiKeysSignalError(output, error_type, error_str);
        Q_EMIT getSiteApiKeysSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISiteApi::getSiteDnsRecords(const ::OpenAPI::OptionalParam<QString> &cursor, const ::OpenAPI::OptionalParam<qint32> &per_page) {
    QString fullPath = QString(_serverConfigs["getSiteDnsRecords"][_serverIndices.value("getSiteDnsRecords")].URL()+"/site/dns_records");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (cursor.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cursor", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cursor")).append(querySuffix).append(QUrl::toPercentEncoding(cursor.stringValue()));
    }
    if (per_page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(per_page.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISiteApi::getSiteDnsRecordsCallback);
    connect(this, &OAISiteApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISiteApi::getSiteDnsRecordsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIDnsRecordEntity> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIDnsRecordEntity val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSiteDnsRecordsSignal(output);
        Q_EMIT getSiteDnsRecordsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSiteDnsRecordsSignalE(output, error_type, error_str);
        Q_EMIT getSiteDnsRecordsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSiteDnsRecordsSignalError(output, error_type, error_str);
        Q_EMIT getSiteDnsRecordsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISiteApi::getSiteIpAddresses(const ::OpenAPI::OptionalParam<QString> &cursor, const ::OpenAPI::OptionalParam<qint32> &per_page) {
    QString fullPath = QString(_serverConfigs["getSiteIpAddresses"][_serverIndices.value("getSiteIpAddresses")].URL()+"/site/ip_addresses");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (cursor.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cursor", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cursor")).append(querySuffix).append(QUrl::toPercentEncoding(cursor.stringValue()));
    }
    if (per_page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "per_page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("per_page")).append(querySuffix).append(QUrl::toPercentEncoding(per_page.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISiteApi::getSiteIpAddressesCallback);
    connect(this, &OAISiteApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISiteApi::getSiteIpAddressesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIIpAddressEntity> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIIpAddressEntity val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSiteIpAddressesSignal(output);
        Q_EMIT getSiteIpAddressesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSiteIpAddressesSignalE(output, error_type, error_str);
        Q_EMIT getSiteIpAddressesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSiteIpAddressesSignalError(output, error_type, error_str);
        Q_EMIT getSiteIpAddressesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISiteApi::getSiteUsage() {
    QString fullPath = QString(_serverConfigs["getSiteUsage"][_serverIndices.value("getSiteUsage")].URL()+"/site/usage");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISiteApi::getSiteUsageCallback);
    connect(this, &OAISiteApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISiteApi::getSiteUsageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUsageSnapshotEntity output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSiteUsageSignal(output);
        Q_EMIT getSiteUsageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSiteUsageSignalE(output, error_type, error_str);
        Q_EMIT getSiteUsageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSiteUsageSignalError(output, error_type, error_str);
        Q_EMIT getSiteUsageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISiteApi::patchSite(const ::OpenAPI::OptionalParam<qint32> &active_sftp_host_key_id, const ::OpenAPI::OptionalParam<bool> &allow_bundle_names, const ::OpenAPI::OptionalParam<bool> &allowed_2fa_method_bypass_for_ftp_sftp_dav, const ::OpenAPI::OptionalParam<bool> &allowed_2fa_method_sms, const ::OpenAPI::OptionalParam<bool> &allowed_2fa_method_totp, const ::OpenAPI::OptionalParam<bool> &allowed_2fa_method_u2f, const ::OpenAPI::OptionalParam<bool> &allowed_2fa_method_webauthn, const ::OpenAPI::OptionalParam<bool> &allowed_2fa_method_yubi, const ::OpenAPI::OptionalParam<QString> &allowed_countries, const ::OpenAPI::OptionalParam<QString> &allowed_ips, const ::OpenAPI::OptionalParam<bool> &ask_about_overwrites, const ::OpenAPI::OptionalParam<QString> &bundle_activity_notifications, const ::OpenAPI::OptionalParam<qint32> &bundle_expiration, const ::OpenAPI::OptionalParam<bool> &bundle_password_required, const ::OpenAPI::OptionalParam<QString> &bundle_registration_notifications, const ::OpenAPI::OptionalParam<bool> &bundle_require_share_recipient, const ::OpenAPI::OptionalParam<QString> &bundle_upload_receipt_notifications, const ::OpenAPI::OptionalParam<bool> &bundle_watermark_attachment_delete, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &bundle_watermark_attachment_file, const ::OpenAPI::OptionalParam<OAIObject> &bundle_watermark_value, const ::OpenAPI::OptionalParam<QString> &color2_left, const ::OpenAPI::OptionalParam<QString> &color2_link, const ::OpenAPI::OptionalParam<QString> &color2_text, const ::OpenAPI::OptionalParam<QString> &color2_top, const ::OpenAPI::OptionalParam<QString> &color2_top_text, const ::OpenAPI::OptionalParam<bool> &custom_namespace, const ::OpenAPI::OptionalParam<qint32> &days_to_retain_backups, const ::OpenAPI::OptionalParam<QString> &default_time_zone, const ::OpenAPI::OptionalParam<bool> &desktop_app, const ::OpenAPI::OptionalParam<bool> &desktop_app_session_ip_pinning, const ::OpenAPI::OptionalParam<qint32> &desktop_app_session_lifetime, const ::OpenAPI::OptionalParam<bool> &disable_2fa_with_delay, const ::OpenAPI::OptionalParam<bool> &disable_files_certificate_generation, const ::OpenAPI::OptionalParam<bool> &disable_password_reset, const ::OpenAPI::OptionalParam<qint32> &disable_users_from_inactivity_period_days, const ::OpenAPI::OptionalParam<QString> &disallowed_countries, const ::OpenAPI::OptionalParam<QString> &domain, const ::OpenAPI::OptionalParam<bool> &domain_hsts_header, const ::OpenAPI::OptionalParam<QString> &domain_letsencrypt_chain, const ::OpenAPI::OptionalParam<QString> &email, const ::OpenAPI::OptionalParam<bool> &folder_permissions_groups_only, const ::OpenAPI::OptionalParam<bool> &ftp_enabled, const ::OpenAPI::OptionalParam<bool> &icon128_delete, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &icon128_file, const ::OpenAPI::OptionalParam<bool> &icon16_delete, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &icon16_file, const ::OpenAPI::OptionalParam<bool> &icon32_delete, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &icon32_file, const ::OpenAPI::OptionalParam<bool> &icon48_delete, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &icon48_file, const ::OpenAPI::OptionalParam<bool> &immutable_files, const ::OpenAPI::OptionalParam<bool> &include_password_in_welcome_email, const ::OpenAPI::OptionalParam<QString> &language, const ::OpenAPI::OptionalParam<QString> &ldap_base_dn, const ::OpenAPI::OptionalParam<QString> &ldap_domain, const ::OpenAPI::OptionalParam<bool> &ldap_enabled, const ::OpenAPI::OptionalParam<QString> &ldap_group_action, const ::OpenAPI::OptionalParam<QString> &ldap_group_exclusion, const ::OpenAPI::OptionalParam<QString> &ldap_group_inclusion, const ::OpenAPI::OptionalParam<QString> &ldap_host, const ::OpenAPI::OptionalParam<QString> &ldap_host_2, const ::OpenAPI::OptionalParam<QString> &ldap_host_3, const ::OpenAPI::OptionalParam<QString> &ldap_password_change, const ::OpenAPI::OptionalParam<QString> &ldap_password_change_confirmation, const ::OpenAPI::OptionalParam<qint32> &ldap_port, const ::OpenAPI::OptionalParam<bool> &ldap_secure, const ::OpenAPI::OptionalParam<QString> &ldap_type, const ::OpenAPI::OptionalParam<QString> &ldap_user_action, const ::OpenAPI::OptionalParam<QString> &ldap_user_include_groups, const ::OpenAPI::OptionalParam<QString> &ldap_username, const ::OpenAPI::OptionalParam<QString> &ldap_username_field, const ::OpenAPI::OptionalParam<QString> &login_help_text, const ::OpenAPI::OptionalParam<bool> &logo_delete, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &logo_file, const ::OpenAPI::OptionalParam<qint32> &max_prior_passwords, const ::OpenAPI::OptionalParam<bool> &mobile_app, const ::OpenAPI::OptionalParam<bool> &mobile_app_session_ip_pinning, const ::OpenAPI::OptionalParam<qint32> &mobile_app_session_lifetime, const ::OpenAPI::OptionalParam<QString> &motd_text, const ::OpenAPI::OptionalParam<bool> &motd_use_for_ftp, const ::OpenAPI::OptionalParam<bool> &motd_use_for_sftp, const ::OpenAPI::OptionalParam<QString> &name, const ::OpenAPI::OptionalParam<bool> &non_sso_groups_allowed, const ::OpenAPI::OptionalParam<bool> &non_sso_users_allowed, const ::OpenAPI::OptionalParam<bool> &office_integration_available, const ::OpenAPI::OptionalParam<QString> &office_integration_type, const ::OpenAPI::OptionalParam<bool> &opt_out_global, const ::OpenAPI::OptionalParam<qint32> &password_min_length, const ::OpenAPI::OptionalParam<bool> &password_require_letter, const ::OpenAPI::OptionalParam<bool> &password_require_mixed, const ::OpenAPI::OptionalParam<bool> &password_require_number, const ::OpenAPI::OptionalParam<bool> &password_require_special, const ::OpenAPI::OptionalParam<bool> &password_require_unbreached, const ::OpenAPI::OptionalParam<bool> &password_requirements_apply_to_bundles, const ::OpenAPI::OptionalParam<qint32> &password_validity_days, const ::OpenAPI::OptionalParam<bool> &pin_all_remote_servers_to_site_region, const ::OpenAPI::OptionalParam<QString> &reply_to_email, const ::OpenAPI::OptionalParam<bool> &require_2fa, const ::OpenAPI::OptionalParam<QString> &require_2fa_user_type, const ::OpenAPI::OptionalParam<double> &session_expiry, const ::OpenAPI::OptionalParam<qint32> &session_expiry_minutes, const ::OpenAPI::OptionalParam<bool> &session_pinned_by_ip, const ::OpenAPI::OptionalParam<bool> &sftp_enabled, const ::OpenAPI::OptionalParam<QString> &sftp_host_key_type, const ::OpenAPI::OptionalParam<bool> &sftp_insecure_ciphers, const ::OpenAPI::OptionalParam<bool> &sftp_user_root_enabled, const ::OpenAPI::OptionalParam<bool> &sharing_enabled, const ::OpenAPI::OptionalParam<bool> &show_request_access_link, const ::OpenAPI::OptionalParam<QString> &site_footer, const ::OpenAPI::OptionalParam<QString> &site_header, const ::OpenAPI::OptionalParam<QString> &smtp_address, const ::OpenAPI::OptionalParam<QString> &smtp_authentication, const ::OpenAPI::OptionalParam<QString> &smtp_from, const ::OpenAPI::OptionalParam<QString> &smtp_password, const ::OpenAPI::OptionalParam<qint32> &smtp_port, const ::OpenAPI::OptionalParam<QString> &smtp_username, const ::OpenAPI::OptionalParam<bool> &ssl_required, const ::OpenAPI::OptionalParam<QString> &subdomain, const ::OpenAPI::OptionalParam<bool> &tls_disabled, const ::OpenAPI::OptionalParam<bool> &uploads_via_email_authentication, const ::OpenAPI::OptionalParam<bool> &use_provided_modified_at, const ::OpenAPI::OptionalParam<bool> &user_lockout, const ::OpenAPI::OptionalParam<qint32> &user_lockout_lock_period, const ::OpenAPI::OptionalParam<qint32> &user_lockout_tries, const ::OpenAPI::OptionalParam<qint32> &user_lockout_within, const ::OpenAPI::OptionalParam<bool> &user_requests_enabled, const ::OpenAPI::OptionalParam<bool> &user_requests_notify_admins, const ::OpenAPI::OptionalParam<QString> &welcome_custom_text, const ::OpenAPI::OptionalParam<QString> &welcome_email_cc, const ::OpenAPI::OptionalParam<bool> &welcome_email_enabled, const ::OpenAPI::OptionalParam<QString> &welcome_email_subject, const ::OpenAPI::OptionalParam<QString> &welcome_screen, const ::OpenAPI::OptionalParam<bool> &windows_mode_ftp) {
    QString fullPath = QString(_serverConfigs["patchSite"][_serverIndices.value("patchSite")].URL()+"/site");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    if (active_sftp_host_key_id.hasValue())
    {
        input.add_var("active_sftp_host_key_id", ::OpenAPI::toStringValue(active_sftp_host_key_id.value()));
    }
    if (allow_bundle_names.hasValue())
    {
        input.add_var("allow_bundle_names", ::OpenAPI::toStringValue(allow_bundle_names.value()));
    }
    if (allowed_2fa_method_bypass_for_ftp_sftp_dav.hasValue())
    {
        input.add_var("allowed_2fa_method_bypass_for_ftp_sftp_dav", ::OpenAPI::toStringValue(allowed_2fa_method_bypass_for_ftp_sftp_dav.value()));
    }
    if (allowed_2fa_method_sms.hasValue())
    {
        input.add_var("allowed_2fa_method_sms", ::OpenAPI::toStringValue(allowed_2fa_method_sms.value()));
    }
    if (allowed_2fa_method_totp.hasValue())
    {
        input.add_var("allowed_2fa_method_totp", ::OpenAPI::toStringValue(allowed_2fa_method_totp.value()));
    }
    if (allowed_2fa_method_u2f.hasValue())
    {
        input.add_var("allowed_2fa_method_u2f", ::OpenAPI::toStringValue(allowed_2fa_method_u2f.value()));
    }
    if (allowed_2fa_method_webauthn.hasValue())
    {
        input.add_var("allowed_2fa_method_webauthn", ::OpenAPI::toStringValue(allowed_2fa_method_webauthn.value()));
    }
    if (allowed_2fa_method_yubi.hasValue())
    {
        input.add_var("allowed_2fa_method_yubi", ::OpenAPI::toStringValue(allowed_2fa_method_yubi.value()));
    }
    if (allowed_countries.hasValue())
    {
        input.add_var("allowed_countries", ::OpenAPI::toStringValue(allowed_countries.value()));
    }
    if (allowed_ips.hasValue())
    {
        input.add_var("allowed_ips", ::OpenAPI::toStringValue(allowed_ips.value()));
    }
    if (ask_about_overwrites.hasValue())
    {
        input.add_var("ask_about_overwrites", ::OpenAPI::toStringValue(ask_about_overwrites.value()));
    }
    if (bundle_activity_notifications.hasValue())
    {
        input.add_var("bundle_activity_notifications", ::OpenAPI::toStringValue(bundle_activity_notifications.value()));
    }
    if (bundle_expiration.hasValue())
    {
        input.add_var("bundle_expiration", ::OpenAPI::toStringValue(bundle_expiration.value()));
    }
    if (bundle_password_required.hasValue())
    {
        input.add_var("bundle_password_required", ::OpenAPI::toStringValue(bundle_password_required.value()));
    }
    if (bundle_registration_notifications.hasValue())
    {
        input.add_var("bundle_registration_notifications", ::OpenAPI::toStringValue(bundle_registration_notifications.value()));
    }
    if (bundle_require_share_recipient.hasValue())
    {
        input.add_var("bundle_require_share_recipient", ::OpenAPI::toStringValue(bundle_require_share_recipient.value()));
    }
    if (bundle_upload_receipt_notifications.hasValue())
    {
        input.add_var("bundle_upload_receipt_notifications", ::OpenAPI::toStringValue(bundle_upload_receipt_notifications.value()));
    }
    if (bundle_watermark_attachment_delete.hasValue())
    {
        input.add_var("bundle_watermark_attachment_delete", ::OpenAPI::toStringValue(bundle_watermark_attachment_delete.value()));
    }
    if (bundle_watermark_attachment_file.hasValue())
    {
        input.add_file("bundle_watermark_attachment_file", bundle_watermark_attachment_file.value().local_filename, bundle_watermark_attachment_file.value().request_filename, bundle_watermark_attachment_file.value().mime_type);
    }
    if (bundle_watermark_value.hasValue())
    {
        input.add_var("bundle_watermark_value", ::OpenAPI::toStringValue(bundle_watermark_value.value()));
    }
    if (color2_left.hasValue())
    {
        input.add_var("color2_left", ::OpenAPI::toStringValue(color2_left.value()));
    }
    if (color2_link.hasValue())
    {
        input.add_var("color2_link", ::OpenAPI::toStringValue(color2_link.value()));
    }
    if (color2_text.hasValue())
    {
        input.add_var("color2_text", ::OpenAPI::toStringValue(color2_text.value()));
    }
    if (color2_top.hasValue())
    {
        input.add_var("color2_top", ::OpenAPI::toStringValue(color2_top.value()));
    }
    if (color2_top_text.hasValue())
    {
        input.add_var("color2_top_text", ::OpenAPI::toStringValue(color2_top_text.value()));
    }
    if (custom_namespace.hasValue())
    {
        input.add_var("custom_namespace", ::OpenAPI::toStringValue(custom_namespace.value()));
    }
    if (days_to_retain_backups.hasValue())
    {
        input.add_var("days_to_retain_backups", ::OpenAPI::toStringValue(days_to_retain_backups.value()));
    }
    if (default_time_zone.hasValue())
    {
        input.add_var("default_time_zone", ::OpenAPI::toStringValue(default_time_zone.value()));
    }
    if (desktop_app.hasValue())
    {
        input.add_var("desktop_app", ::OpenAPI::toStringValue(desktop_app.value()));
    }
    if (desktop_app_session_ip_pinning.hasValue())
    {
        input.add_var("desktop_app_session_ip_pinning", ::OpenAPI::toStringValue(desktop_app_session_ip_pinning.value()));
    }
    if (desktop_app_session_lifetime.hasValue())
    {
        input.add_var("desktop_app_session_lifetime", ::OpenAPI::toStringValue(desktop_app_session_lifetime.value()));
    }
    if (disable_2fa_with_delay.hasValue())
    {
        input.add_var("disable_2fa_with_delay", ::OpenAPI::toStringValue(disable_2fa_with_delay.value()));
    }
    if (disable_files_certificate_generation.hasValue())
    {
        input.add_var("disable_files_certificate_generation", ::OpenAPI::toStringValue(disable_files_certificate_generation.value()));
    }
    if (disable_password_reset.hasValue())
    {
        input.add_var("disable_password_reset", ::OpenAPI::toStringValue(disable_password_reset.value()));
    }
    if (disable_users_from_inactivity_period_days.hasValue())
    {
        input.add_var("disable_users_from_inactivity_period_days", ::OpenAPI::toStringValue(disable_users_from_inactivity_period_days.value()));
    }
    if (disallowed_countries.hasValue())
    {
        input.add_var("disallowed_countries", ::OpenAPI::toStringValue(disallowed_countries.value()));
    }
    if (domain.hasValue())
    {
        input.add_var("domain", ::OpenAPI::toStringValue(domain.value()));
    }
    if (domain_hsts_header.hasValue())
    {
        input.add_var("domain_hsts_header", ::OpenAPI::toStringValue(domain_hsts_header.value()));
    }
    if (domain_letsencrypt_chain.hasValue())
    {
        input.add_var("domain_letsencrypt_chain", ::OpenAPI::toStringValue(domain_letsencrypt_chain.value()));
    }
    if (email.hasValue())
    {
        input.add_var("email", ::OpenAPI::toStringValue(email.value()));
    }
    if (folder_permissions_groups_only.hasValue())
    {
        input.add_var("folder_permissions_groups_only", ::OpenAPI::toStringValue(folder_permissions_groups_only.value()));
    }
    if (ftp_enabled.hasValue())
    {
        input.add_var("ftp_enabled", ::OpenAPI::toStringValue(ftp_enabled.value()));
    }
    if (icon128_delete.hasValue())
    {
        input.add_var("icon128_delete", ::OpenAPI::toStringValue(icon128_delete.value()));
    }
    if (icon128_file.hasValue())
    {
        input.add_file("icon128_file", icon128_file.value().local_filename, icon128_file.value().request_filename, icon128_file.value().mime_type);
    }
    if (icon16_delete.hasValue())
    {
        input.add_var("icon16_delete", ::OpenAPI::toStringValue(icon16_delete.value()));
    }
    if (icon16_file.hasValue())
    {
        input.add_file("icon16_file", icon16_file.value().local_filename, icon16_file.value().request_filename, icon16_file.value().mime_type);
    }
    if (icon32_delete.hasValue())
    {
        input.add_var("icon32_delete", ::OpenAPI::toStringValue(icon32_delete.value()));
    }
    if (icon32_file.hasValue())
    {
        input.add_file("icon32_file", icon32_file.value().local_filename, icon32_file.value().request_filename, icon32_file.value().mime_type);
    }
    if (icon48_delete.hasValue())
    {
        input.add_var("icon48_delete", ::OpenAPI::toStringValue(icon48_delete.value()));
    }
    if (icon48_file.hasValue())
    {
        input.add_file("icon48_file", icon48_file.value().local_filename, icon48_file.value().request_filename, icon48_file.value().mime_type);
    }
    if (immutable_files.hasValue())
    {
        input.add_var("immutable_files", ::OpenAPI::toStringValue(immutable_files.value()));
    }
    if (include_password_in_welcome_email.hasValue())
    {
        input.add_var("include_password_in_welcome_email", ::OpenAPI::toStringValue(include_password_in_welcome_email.value()));
    }
    if (language.hasValue())
    {
        input.add_var("language", ::OpenAPI::toStringValue(language.value()));
    }
    if (ldap_base_dn.hasValue())
    {
        input.add_var("ldap_base_dn", ::OpenAPI::toStringValue(ldap_base_dn.value()));
    }
    if (ldap_domain.hasValue())
    {
        input.add_var("ldap_domain", ::OpenAPI::toStringValue(ldap_domain.value()));
    }
    if (ldap_enabled.hasValue())
    {
        input.add_var("ldap_enabled", ::OpenAPI::toStringValue(ldap_enabled.value()));
    }
    if (ldap_group_action.hasValue())
    {
        input.add_var("ldap_group_action", ::OpenAPI::toStringValue(ldap_group_action.value()));
    }
    if (ldap_group_exclusion.hasValue())
    {
        input.add_var("ldap_group_exclusion", ::OpenAPI::toStringValue(ldap_group_exclusion.value()));
    }
    if (ldap_group_inclusion.hasValue())
    {
        input.add_var("ldap_group_inclusion", ::OpenAPI::toStringValue(ldap_group_inclusion.value()));
    }
    if (ldap_host.hasValue())
    {
        input.add_var("ldap_host", ::OpenAPI::toStringValue(ldap_host.value()));
    }
    if (ldap_host_2.hasValue())
    {
        input.add_var("ldap_host_2", ::OpenAPI::toStringValue(ldap_host_2.value()));
    }
    if (ldap_host_3.hasValue())
    {
        input.add_var("ldap_host_3", ::OpenAPI::toStringValue(ldap_host_3.value()));
    }
    if (ldap_password_change.hasValue())
    {
        input.add_var("ldap_password_change", ::OpenAPI::toStringValue(ldap_password_change.value()));
    }
    if (ldap_password_change_confirmation.hasValue())
    {
        input.add_var("ldap_password_change_confirmation", ::OpenAPI::toStringValue(ldap_password_change_confirmation.value()));
    }
    if (ldap_port.hasValue())
    {
        input.add_var("ldap_port", ::OpenAPI::toStringValue(ldap_port.value()));
    }
    if (ldap_secure.hasValue())
    {
        input.add_var("ldap_secure", ::OpenAPI::toStringValue(ldap_secure.value()));
    }
    if (ldap_type.hasValue())
    {
        input.add_var("ldap_type", ::OpenAPI::toStringValue(ldap_type.value()));
    }
    if (ldap_user_action.hasValue())
    {
        input.add_var("ldap_user_action", ::OpenAPI::toStringValue(ldap_user_action.value()));
    }
    if (ldap_user_include_groups.hasValue())
    {
        input.add_var("ldap_user_include_groups", ::OpenAPI::toStringValue(ldap_user_include_groups.value()));
    }
    if (ldap_username.hasValue())
    {
        input.add_var("ldap_username", ::OpenAPI::toStringValue(ldap_username.value()));
    }
    if (ldap_username_field.hasValue())
    {
        input.add_var("ldap_username_field", ::OpenAPI::toStringValue(ldap_username_field.value()));
    }
    if (login_help_text.hasValue())
    {
        input.add_var("login_help_text", ::OpenAPI::toStringValue(login_help_text.value()));
    }
    if (logo_delete.hasValue())
    {
        input.add_var("logo_delete", ::OpenAPI::toStringValue(logo_delete.value()));
    }
    if (logo_file.hasValue())
    {
        input.add_file("logo_file", logo_file.value().local_filename, logo_file.value().request_filename, logo_file.value().mime_type);
    }
    if (max_prior_passwords.hasValue())
    {
        input.add_var("max_prior_passwords", ::OpenAPI::toStringValue(max_prior_passwords.value()));
    }
    if (mobile_app.hasValue())
    {
        input.add_var("mobile_app", ::OpenAPI::toStringValue(mobile_app.value()));
    }
    if (mobile_app_session_ip_pinning.hasValue())
    {
        input.add_var("mobile_app_session_ip_pinning", ::OpenAPI::toStringValue(mobile_app_session_ip_pinning.value()));
    }
    if (mobile_app_session_lifetime.hasValue())
    {
        input.add_var("mobile_app_session_lifetime", ::OpenAPI::toStringValue(mobile_app_session_lifetime.value()));
    }
    if (motd_text.hasValue())
    {
        input.add_var("motd_text", ::OpenAPI::toStringValue(motd_text.value()));
    }
    if (motd_use_for_ftp.hasValue())
    {
        input.add_var("motd_use_for_ftp", ::OpenAPI::toStringValue(motd_use_for_ftp.value()));
    }
    if (motd_use_for_sftp.hasValue())
    {
        input.add_var("motd_use_for_sftp", ::OpenAPI::toStringValue(motd_use_for_sftp.value()));
    }
    if (name.hasValue())
    {
        input.add_var("name", ::OpenAPI::toStringValue(name.value()));
    }
    if (non_sso_groups_allowed.hasValue())
    {
        input.add_var("non_sso_groups_allowed", ::OpenAPI::toStringValue(non_sso_groups_allowed.value()));
    }
    if (non_sso_users_allowed.hasValue())
    {
        input.add_var("non_sso_users_allowed", ::OpenAPI::toStringValue(non_sso_users_allowed.value()));
    }
    if (office_integration_available.hasValue())
    {
        input.add_var("office_integration_available", ::OpenAPI::toStringValue(office_integration_available.value()));
    }
    if (office_integration_type.hasValue())
    {
        input.add_var("office_integration_type", ::OpenAPI::toStringValue(office_integration_type.value()));
    }
    if (opt_out_global.hasValue())
    {
        input.add_var("opt_out_global", ::OpenAPI::toStringValue(opt_out_global.value()));
    }
    if (password_min_length.hasValue())
    {
        input.add_var("password_min_length", ::OpenAPI::toStringValue(password_min_length.value()));
    }
    if (password_require_letter.hasValue())
    {
        input.add_var("password_require_letter", ::OpenAPI::toStringValue(password_require_letter.value()));
    }
    if (password_require_mixed.hasValue())
    {
        input.add_var("password_require_mixed", ::OpenAPI::toStringValue(password_require_mixed.value()));
    }
    if (password_require_number.hasValue())
    {
        input.add_var("password_require_number", ::OpenAPI::toStringValue(password_require_number.value()));
    }
    if (password_require_special.hasValue())
    {
        input.add_var("password_require_special", ::OpenAPI::toStringValue(password_require_special.value()));
    }
    if (password_require_unbreached.hasValue())
    {
        input.add_var("password_require_unbreached", ::OpenAPI::toStringValue(password_require_unbreached.value()));
    }
    if (password_requirements_apply_to_bundles.hasValue())
    {
        input.add_var("password_requirements_apply_to_bundles", ::OpenAPI::toStringValue(password_requirements_apply_to_bundles.value()));
    }
    if (password_validity_days.hasValue())
    {
        input.add_var("password_validity_days", ::OpenAPI::toStringValue(password_validity_days.value()));
    }
    if (pin_all_remote_servers_to_site_region.hasValue())
    {
        input.add_var("pin_all_remote_servers_to_site_region", ::OpenAPI::toStringValue(pin_all_remote_servers_to_site_region.value()));
    }
    if (reply_to_email.hasValue())
    {
        input.add_var("reply_to_email", ::OpenAPI::toStringValue(reply_to_email.value()));
    }
    if (require_2fa.hasValue())
    {
        input.add_var("require_2fa", ::OpenAPI::toStringValue(require_2fa.value()));
    }
    if (require_2fa_user_type.hasValue())
    {
        input.add_var("require_2fa_user_type", ::OpenAPI::toStringValue(require_2fa_user_type.value()));
    }
    if (session_expiry.hasValue())
    {
        input.add_var("session_expiry", ::OpenAPI::toStringValue(session_expiry.value()));
    }
    if (session_expiry_minutes.hasValue())
    {
        input.add_var("session_expiry_minutes", ::OpenAPI::toStringValue(session_expiry_minutes.value()));
    }
    if (session_pinned_by_ip.hasValue())
    {
        input.add_var("session_pinned_by_ip", ::OpenAPI::toStringValue(session_pinned_by_ip.value()));
    }
    if (sftp_enabled.hasValue())
    {
        input.add_var("sftp_enabled", ::OpenAPI::toStringValue(sftp_enabled.value()));
    }
    if (sftp_host_key_type.hasValue())
    {
        input.add_var("sftp_host_key_type", ::OpenAPI::toStringValue(sftp_host_key_type.value()));
    }
    if (sftp_insecure_ciphers.hasValue())
    {
        input.add_var("sftp_insecure_ciphers", ::OpenAPI::toStringValue(sftp_insecure_ciphers.value()));
    }
    if (sftp_user_root_enabled.hasValue())
    {
        input.add_var("sftp_user_root_enabled", ::OpenAPI::toStringValue(sftp_user_root_enabled.value()));
    }
    if (sharing_enabled.hasValue())
    {
        input.add_var("sharing_enabled", ::OpenAPI::toStringValue(sharing_enabled.value()));
    }
    if (show_request_access_link.hasValue())
    {
        input.add_var("show_request_access_link", ::OpenAPI::toStringValue(show_request_access_link.value()));
    }
    if (site_footer.hasValue())
    {
        input.add_var("site_footer", ::OpenAPI::toStringValue(site_footer.value()));
    }
    if (site_header.hasValue())
    {
        input.add_var("site_header", ::OpenAPI::toStringValue(site_header.value()));
    }
    if (smtp_address.hasValue())
    {
        input.add_var("smtp_address", ::OpenAPI::toStringValue(smtp_address.value()));
    }
    if (smtp_authentication.hasValue())
    {
        input.add_var("smtp_authentication", ::OpenAPI::toStringValue(smtp_authentication.value()));
    }
    if (smtp_from.hasValue())
    {
        input.add_var("smtp_from", ::OpenAPI::toStringValue(smtp_from.value()));
    }
    if (smtp_password.hasValue())
    {
        input.add_var("smtp_password", ::OpenAPI::toStringValue(smtp_password.value()));
    }
    if (smtp_port.hasValue())
    {
        input.add_var("smtp_port", ::OpenAPI::toStringValue(smtp_port.value()));
    }
    if (smtp_username.hasValue())
    {
        input.add_var("smtp_username", ::OpenAPI::toStringValue(smtp_username.value()));
    }
    if (ssl_required.hasValue())
    {
        input.add_var("ssl_required", ::OpenAPI::toStringValue(ssl_required.value()));
    }
    if (subdomain.hasValue())
    {
        input.add_var("subdomain", ::OpenAPI::toStringValue(subdomain.value()));
    }
    if (tls_disabled.hasValue())
    {
        input.add_var("tls_disabled", ::OpenAPI::toStringValue(tls_disabled.value()));
    }
    if (uploads_via_email_authentication.hasValue())
    {
        input.add_var("uploads_via_email_authentication", ::OpenAPI::toStringValue(uploads_via_email_authentication.value()));
    }
    if (use_provided_modified_at.hasValue())
    {
        input.add_var("use_provided_modified_at", ::OpenAPI::toStringValue(use_provided_modified_at.value()));
    }
    if (user_lockout.hasValue())
    {
        input.add_var("user_lockout", ::OpenAPI::toStringValue(user_lockout.value()));
    }
    if (user_lockout_lock_period.hasValue())
    {
        input.add_var("user_lockout_lock_period", ::OpenAPI::toStringValue(user_lockout_lock_period.value()));
    }
    if (user_lockout_tries.hasValue())
    {
        input.add_var("user_lockout_tries", ::OpenAPI::toStringValue(user_lockout_tries.value()));
    }
    if (user_lockout_within.hasValue())
    {
        input.add_var("user_lockout_within", ::OpenAPI::toStringValue(user_lockout_within.value()));
    }
    if (user_requests_enabled.hasValue())
    {
        input.add_var("user_requests_enabled", ::OpenAPI::toStringValue(user_requests_enabled.value()));
    }
    if (user_requests_notify_admins.hasValue())
    {
        input.add_var("user_requests_notify_admins", ::OpenAPI::toStringValue(user_requests_notify_admins.value()));
    }
    if (welcome_custom_text.hasValue())
    {
        input.add_var("welcome_custom_text", ::OpenAPI::toStringValue(welcome_custom_text.value()));
    }
    if (welcome_email_cc.hasValue())
    {
        input.add_var("welcome_email_cc", ::OpenAPI::toStringValue(welcome_email_cc.value()));
    }
    if (welcome_email_enabled.hasValue())
    {
        input.add_var("welcome_email_enabled", ::OpenAPI::toStringValue(welcome_email_enabled.value()));
    }
    if (welcome_email_subject.hasValue())
    {
        input.add_var("welcome_email_subject", ::OpenAPI::toStringValue(welcome_email_subject.value()));
    }
    if (welcome_screen.hasValue())
    {
        input.add_var("welcome_screen", ::OpenAPI::toStringValue(welcome_screen.value()));
    }
    if (windows_mode_ftp.hasValue())
    {
        input.add_var("windows_mode_ftp", ::OpenAPI::toStringValue(windows_mode_ftp.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISiteApi::patchSiteCallback);
    connect(this, &OAISiteApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISiteApi::patchSiteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISiteEntity output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT patchSiteSignal(output);
        Q_EMIT patchSiteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT patchSiteSignalE(output, error_type, error_str);
        Q_EMIT patchSiteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT patchSiteSignalError(output, error_type, error_str);
        Q_EMIT patchSiteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISiteApi::postSiteApiKeys(const ::OpenAPI::OptionalParam<QString> &description, const ::OpenAPI::OptionalParam<QDateTime> &expires_at, const ::OpenAPI::OptionalParam<QString> &name, const ::OpenAPI::OptionalParam<QString> &path, const ::OpenAPI::OptionalParam<QString> &permission_set, const ::OpenAPI::OptionalParam<qint32> &user_id) {
    QString fullPath = QString(_serverConfigs["postSiteApiKeys"][_serverIndices.value("postSiteApiKeys")].URL()+"/site/api_keys");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (description.hasValue())
    {
        input.add_var("description", ::OpenAPI::toStringValue(description.value()));
    }
    if (expires_at.hasValue())
    {
        input.add_var("expires_at", ::OpenAPI::toStringValue(expires_at.value()));
    }
    if (name.hasValue())
    {
        input.add_var("name", ::OpenAPI::toStringValue(name.value()));
    }
    if (path.hasValue())
    {
        input.add_var("path", ::OpenAPI::toStringValue(path.value()));
    }
    if (permission_set.hasValue())
    {
        input.add_var("permission_set", ::OpenAPI::toStringValue(permission_set.value()));
    }
    if (user_id.hasValue())
    {
        input.add_var("user_id", ::OpenAPI::toStringValue(user_id.value()));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISiteApi::postSiteApiKeysCallback);
    connect(this, &OAISiteApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISiteApi::postSiteApiKeysCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApiKeyEntity output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postSiteApiKeysSignal(output);
        Q_EMIT postSiteApiKeysSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postSiteApiKeysSignalE(output, error_type, error_str);
        Q_EMIT postSiteApiKeysSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postSiteApiKeysSignalError(output, error_type, error_str);
        Q_EMIT postSiteApiKeysSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISiteApi::postSiteTestWebhook(const QString &url, const ::OpenAPI::OptionalParam<QString> &action, const ::OpenAPI::OptionalParam<OAIObject> &body, const ::OpenAPI::OptionalParam<QString> &encoding, const ::OpenAPI::OptionalParam<OAIObject> &headers, const ::OpenAPI::OptionalParam<QString> &method) {
    QString fullPath = QString(_serverConfigs["postSiteTestWebhook"][_serverIndices.value("postSiteTestWebhook")].URL()+"/site/test-webhook");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (action.hasValue())
    {
        input.add_var("action", ::OpenAPI::toStringValue(action.value()));
    }
    if (body.hasValue())
    {
        input.add_var("body", ::OpenAPI::toStringValue(body.value()));
    }
    if (encoding.hasValue())
    {
        input.add_var("encoding", ::OpenAPI::toStringValue(encoding.value()));
    }
    if (headers.hasValue())
    {
        input.add_var("headers", ::OpenAPI::toStringValue(headers.value()));
    }
    if (method.hasValue())
    {
        input.add_var("method", ::OpenAPI::toStringValue(method.value()));
    }
    
    {
        input.add_var("url", ::OpenAPI::toStringValue(url));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISiteApi::postSiteTestWebhookCallback);
    connect(this, &OAISiteApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISiteApi::postSiteTestWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStatusEntity output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postSiteTestWebhookSignal(output);
        Q_EMIT postSiteTestWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postSiteTestWebhookSignalE(output, error_type, error_str);
        Q_EMIT postSiteTestWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postSiteTestWebhookSignalError(output, error_type, error_str);
        Q_EMIT postSiteTestWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISiteApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
