/*
 * Files.com API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@files.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ApiKeyEntity;
import java.io.File;
import org.openapitools.client.model.GroupUserEntity;
import java.time.OffsetDateTime;
import org.openapitools.client.model.PublicKeyEntity;
import org.openapitools.client.model.UserEntity;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UserApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public UserApi() {
        this(Configuration.getDefaultApiClient());
    }

    public UserApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getUserApiKeys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUserApiKeysCall(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/api_keys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(sortBy));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filter));
        }

        if (filterGt != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterGt));
        }

        if (filterGteq != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterGteq));
        }

        if (filterLt != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterLt));
        }

        if (filterLteq != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterLteq));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserApiKeysValidateBeforeCall(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq, final ApiCallback _callback) throws ApiException {
        return getUserApiKeysCall(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq, _callback);

    }

    /**
     * List Api Keys
     * List Api Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @return List&lt;ApiKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<ApiKeyEntity> getUserApiKeys(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq) throws ApiException {
        ApiResponse<List<ApiKeyEntity>> localVarResp = getUserApiKeysWithHttpInfo(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq);
        return localVarResp.getData();
    }

    /**
     * List Api Keys
     * List Api Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @return ApiResponse&lt;List&lt;ApiKeyEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ApiKeyEntity>> getUserApiKeysWithHttpInfo(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq) throws ApiException {
        okhttp3.Call localVarCall = getUserApiKeysValidateBeforeCall(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq, null);
        Type localVarReturnType = new TypeToken<List<ApiKeyEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Api Keys (asynchronously)
     * List Api Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUserApiKeysAsync(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq, final ApiCallback<List<ApiKeyEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserApiKeysValidateBeforeCall(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq, _callback);
        Type localVarReturnType = new TypeToken<List<ApiKeyEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getUserGroups
     * @param userId User ID.  If provided, will return group_users of this user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param groupId Group ID.  If provided, will return group_users of this group. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUserGroupsCall(Integer userId, String cursor, Integer perPage, Integer groupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/groups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserGroupsValidateBeforeCall(Integer userId, String cursor, Integer perPage, Integer groupId, final ApiCallback _callback) throws ApiException {
        return getUserGroupsCall(userId, cursor, perPage, groupId, _callback);

    }

    /**
     * List Group Users
     * List Group Users
     * @param userId User ID.  If provided, will return group_users of this user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param groupId Group ID.  If provided, will return group_users of this group. (optional)
     * @return List&lt;GroupUserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<GroupUserEntity> getUserGroups(Integer userId, String cursor, Integer perPage, Integer groupId) throws ApiException {
        ApiResponse<List<GroupUserEntity>> localVarResp = getUserGroupsWithHttpInfo(userId, cursor, perPage, groupId);
        return localVarResp.getData();
    }

    /**
     * List Group Users
     * List Group Users
     * @param userId User ID.  If provided, will return group_users of this user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param groupId Group ID.  If provided, will return group_users of this group. (optional)
     * @return ApiResponse&lt;List&lt;GroupUserEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<GroupUserEntity>> getUserGroupsWithHttpInfo(Integer userId, String cursor, Integer perPage, Integer groupId) throws ApiException {
        okhttp3.Call localVarCall = getUserGroupsValidateBeforeCall(userId, cursor, perPage, groupId, null);
        Type localVarReturnType = new TypeToken<List<GroupUserEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Group Users (asynchronously)
     * List Group Users
     * @param userId User ID.  If provided, will return group_users of this user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param groupId Group ID.  If provided, will return group_users of this group. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUserGroupsAsync(Integer userId, String cursor, Integer perPage, Integer groupId, final ApiCallback<List<GroupUserEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserGroupsValidateBeforeCall(userId, cursor, perPage, groupId, _callback);
        Type localVarReturnType = new TypeToken<List<GroupUserEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getUserPublicKeys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of PublicKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUserPublicKeysCall(Integer userId, String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/public_keys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserPublicKeysValidateBeforeCall(Integer userId, String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        return getUserPublicKeysCall(userId, cursor, perPage, _callback);

    }

    /**
     * List Public Keys
     * List Public Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return List&lt;PublicKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of PublicKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<PublicKeyEntity> getUserPublicKeys(Integer userId, String cursor, Integer perPage) throws ApiException {
        ApiResponse<List<PublicKeyEntity>> localVarResp = getUserPublicKeysWithHttpInfo(userId, cursor, perPage);
        return localVarResp.getData();
    }

    /**
     * List Public Keys
     * List Public Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return ApiResponse&lt;List&lt;PublicKeyEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of PublicKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<PublicKeyEntity>> getUserPublicKeysWithHttpInfo(Integer userId, String cursor, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = getUserPublicKeysValidateBeforeCall(userId, cursor, perPage, null);
        Type localVarReturnType = new TypeToken<List<PublicKeyEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Public Keys (asynchronously)
     * List Public Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of PublicKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUserPublicKeysAsync(Integer userId, String cursor, Integer perPage, final ApiCallback<List<PublicKeyEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserPublicKeysValidateBeforeCall(userId, cursor, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<PublicKeyEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for patchUser
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchUserCall(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (allowedIps != null) {
            localVarFormParams.put("allowed_ips", allowedIps);
        }

        if (announcementsRead != null) {
            localVarFormParams.put("announcements_read", announcementsRead);
        }

        if (attachmentsPermission != null) {
            localVarFormParams.put("attachments_permission", attachmentsPermission);
        }

        if (authenticateUntil != null) {
            localVarFormParams.put("authenticate_until", authenticateUntil);
        }

        if (authenticationMethod != null) {
            localVarFormParams.put("authentication_method", authenticationMethod);
        }

        if (avatarDelete != null) {
            localVarFormParams.put("avatar_delete", avatarDelete);
        }

        if (avatarFile != null) {
            localVarFormParams.put("avatar_file", avatarFile);
        }

        if (billingPermission != null) {
            localVarFormParams.put("billing_permission", billingPermission);
        }

        if (bypassInactiveDisable != null) {
            localVarFormParams.put("bypass_inactive_disable", bypassInactiveDisable);
        }

        if (bypassSiteAllowedIps != null) {
            localVarFormParams.put("bypass_site_allowed_ips", bypassSiteAllowedIps);
        }

        if (changePassword != null) {
            localVarFormParams.put("change_password", changePassword);
        }

        if (changePasswordConfirmation != null) {
            localVarFormParams.put("change_password_confirmation", changePasswordConfirmation);
        }

        if (company != null) {
            localVarFormParams.put("company", company);
        }

        if (davPermission != null) {
            localVarFormParams.put("dav_permission", davPermission);
        }

        if (disabled != null) {
            localVarFormParams.put("disabled", disabled);
        }

        if (email != null) {
            localVarFormParams.put("email", email);
        }

        if (ftpPermission != null) {
            localVarFormParams.put("ftp_permission", ftpPermission);
        }

        if (grantPermission != null) {
            localVarFormParams.put("grant_permission", grantPermission);
        }

        if (groupId != null) {
            localVarFormParams.put("group_id", groupId);
        }

        if (groupIds != null) {
            localVarFormParams.put("group_ids", groupIds);
        }

        if (headerText != null) {
            localVarFormParams.put("header_text", headerText);
        }

        if (importedPasswordHash != null) {
            localVarFormParams.put("imported_password_hash", importedPasswordHash);
        }

        if (language != null) {
            localVarFormParams.put("language", language);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (notes != null) {
            localVarFormParams.put("notes", notes);
        }

        if (notificationDailySendTime != null) {
            localVarFormParams.put("notification_daily_send_time", notificationDailySendTime);
        }

        if (officeIntegrationEnabled != null) {
            localVarFormParams.put("office_integration_enabled", officeIntegrationEnabled);
        }

        if (password != null) {
            localVarFormParams.put("password", password);
        }

        if (passwordConfirmation != null) {
            localVarFormParams.put("password_confirmation", passwordConfirmation);
        }

        if (passwordValidityDays != null) {
            localVarFormParams.put("password_validity_days", passwordValidityDays);
        }

        if (receiveAdminAlerts != null) {
            localVarFormParams.put("receive_admin_alerts", receiveAdminAlerts);
        }

        if (require2fa != null) {
            localVarFormParams.put("require_2fa", require2fa);
        }

        if (requirePasswordChange != null) {
            localVarFormParams.put("require_password_change", requirePasswordChange);
        }

        if (restapiPermission != null) {
            localVarFormParams.put("restapi_permission", restapiPermission);
        }

        if (selfManaged != null) {
            localVarFormParams.put("self_managed", selfManaged);
        }

        if (sftpPermission != null) {
            localVarFormParams.put("sftp_permission", sftpPermission);
        }

        if (siteAdmin != null) {
            localVarFormParams.put("site_admin", siteAdmin);
        }

        if (skipWelcomeScreen != null) {
            localVarFormParams.put("skip_welcome_screen", skipWelcomeScreen);
        }

        if (sslRequired != null) {
            localVarFormParams.put("ssl_required", sslRequired);
        }

        if (ssoStrategyId != null) {
            localVarFormParams.put("sso_strategy_id", ssoStrategyId);
        }

        if (subscribeToNewsletter != null) {
            localVarFormParams.put("subscribe_to_newsletter", subscribeToNewsletter);
        }

        if (timeZone != null) {
            localVarFormParams.put("time_zone", timeZone);
        }

        if (userRoot != null) {
            localVarFormParams.put("user_root", userRoot);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call patchUserValidateBeforeCall(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback _callback) throws ApiException {
        return patchUserCall(allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, _callback);

    }

    /**
     * Update User
     * Update User
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @return UserEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public UserEntity patchUser(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username) throws ApiException {
        ApiResponse<UserEntity> localVarResp = patchUserWithHttpInfo(allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username);
        return localVarResp.getData();
    }

    /**
     * Update User
     * Update User
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @return ApiResponse&lt;UserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UserEntity> patchUserWithHttpInfo(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username) throws ApiException {
        okhttp3.Call localVarCall = patchUserValidateBeforeCall(allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, null);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update User (asynchronously)
     * Update User
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchUserAsync(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback<UserEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = patchUserValidateBeforeCall(allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, _callback);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postUserApiKeys
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUserApiKeysCall(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/api_keys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (description != null) {
            localVarFormParams.put("description", description);
        }

        if (expiresAt != null) {
            localVarFormParams.put("expires_at", expiresAt);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (path != null) {
            localVarFormParams.put("path", path);
        }

        if (permissionSet != null) {
            localVarFormParams.put("permission_set", permissionSet);
        }

        if (userId != null) {
            localVarFormParams.put("user_id", userId);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postUserApiKeysValidateBeforeCall(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId, final ApiCallback _callback) throws ApiException {
        return postUserApiKeysCall(description, expiresAt, name, path, permissionSet, userId, _callback);

    }

    /**
     * Create Api Key
     * Create Api Key
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @return ApiKeyEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiKeyEntity postUserApiKeys(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId) throws ApiException {
        ApiResponse<ApiKeyEntity> localVarResp = postUserApiKeysWithHttpInfo(description, expiresAt, name, path, permissionSet, userId);
        return localVarResp.getData();
    }

    /**
     * Create Api Key
     * Create Api Key
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @return ApiResponse&lt;ApiKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiKeyEntity> postUserApiKeysWithHttpInfo(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId) throws ApiException {
        okhttp3.Call localVarCall = postUserApiKeysValidateBeforeCall(description, expiresAt, name, path, permissionSet, userId, null);
        Type localVarReturnType = new TypeToken<ApiKeyEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Api Key (asynchronously)
     * Create Api Key
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUserApiKeysAsync(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId, final ApiCallback<ApiKeyEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postUserApiKeysValidateBeforeCall(description, expiresAt, name, path, permissionSet, userId, _callback);
        Type localVarReturnType = new TypeToken<ApiKeyEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postUserPublicKeys
     * @param publicKey Actual contents of SSH key. (required)
     * @param title Internal reference for key. (required)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The PublicKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUserPublicKeysCall(String publicKey, String title, Integer userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/public_keys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (publicKey != null) {
            localVarFormParams.put("public_key", publicKey);
        }

        if (title != null) {
            localVarFormParams.put("title", title);
        }

        if (userId != null) {
            localVarFormParams.put("user_id", userId);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postUserPublicKeysValidateBeforeCall(String publicKey, String title, Integer userId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'publicKey' is set
        if (publicKey == null) {
            throw new ApiException("Missing the required parameter 'publicKey' when calling postUserPublicKeys(Async)");
        }

        // verify the required parameter 'title' is set
        if (title == null) {
            throw new ApiException("Missing the required parameter 'title' when calling postUserPublicKeys(Async)");
        }

        return postUserPublicKeysCall(publicKey, title, userId, _callback);

    }

    /**
     * Create Public Key
     * Create Public Key
     * @param publicKey Actual contents of SSH key. (required)
     * @param title Internal reference for key. (required)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @return PublicKeyEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The PublicKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public PublicKeyEntity postUserPublicKeys(String publicKey, String title, Integer userId) throws ApiException {
        ApiResponse<PublicKeyEntity> localVarResp = postUserPublicKeysWithHttpInfo(publicKey, title, userId);
        return localVarResp.getData();
    }

    /**
     * Create Public Key
     * Create Public Key
     * @param publicKey Actual contents of SSH key. (required)
     * @param title Internal reference for key. (required)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @return ApiResponse&lt;PublicKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The PublicKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PublicKeyEntity> postUserPublicKeysWithHttpInfo(String publicKey, String title, Integer userId) throws ApiException {
        okhttp3.Call localVarCall = postUserPublicKeysValidateBeforeCall(publicKey, title, userId, null);
        Type localVarReturnType = new TypeToken<PublicKeyEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Public Key (asynchronously)
     * Create Public Key
     * @param publicKey Actual contents of SSH key. (required)
     * @param title Internal reference for key. (required)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The PublicKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUserPublicKeysAsync(String publicKey, String title, Integer userId, final ApiCallback<PublicKeyEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postUserPublicKeysValidateBeforeCall(publicKey, title, userId, _callback);
        Type localVarReturnType = new TypeToken<PublicKeyEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
