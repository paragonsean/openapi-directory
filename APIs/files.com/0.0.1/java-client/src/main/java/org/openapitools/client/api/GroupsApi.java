/*
 * Files.com API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@files.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import org.openapitools.client.model.GroupEntity;
import org.openapitools.client.model.GroupUserEntity;
import java.time.OffsetDateTime;
import org.openapitools.client.model.PermissionEntity;
import org.openapitools.client.model.UserEntity;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GroupsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public GroupsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public GroupsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for deleteGroupsGroupIdMembershipsUserId
     * @param groupId Group ID from which to remove user. (required)
     * @param userId User ID to remove from group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteGroupsGroupIdMembershipsUserIdCall(Integer groupId, Integer userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{group_id}/memberships/{user_id}"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()))
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteGroupsGroupIdMembershipsUserIdValidateBeforeCall(Integer groupId, Integer userId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling deleteGroupsGroupIdMembershipsUserId(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling deleteGroupsGroupIdMembershipsUserId(Async)");
        }

        return deleteGroupsGroupIdMembershipsUserIdCall(groupId, userId, _callback);

    }

    /**
     * Delete Group User
     * Delete Group User
     * @param groupId Group ID from which to remove user. (required)
     * @param userId User ID to remove from group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public void deleteGroupsGroupIdMembershipsUserId(Integer groupId, Integer userId) throws ApiException {
        deleteGroupsGroupIdMembershipsUserIdWithHttpInfo(groupId, userId);
    }

    /**
     * Delete Group User
     * Delete Group User
     * @param groupId Group ID from which to remove user. (required)
     * @param userId User ID to remove from group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteGroupsGroupIdMembershipsUserIdWithHttpInfo(Integer groupId, Integer userId) throws ApiException {
        okhttp3.Call localVarCall = deleteGroupsGroupIdMembershipsUserIdValidateBeforeCall(groupId, userId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Group User (asynchronously)
     * Delete Group User
     * @param groupId Group ID from which to remove user. (required)
     * @param userId User ID to remove from group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteGroupsGroupIdMembershipsUserIdAsync(Integer groupId, Integer userId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteGroupsGroupIdMembershipsUserIdValidateBeforeCall(groupId, userId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteGroupsId
     * @param id Group ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteGroupsIdCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteGroupsIdValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteGroupsId(Async)");
        }

        return deleteGroupsIdCall(id, _callback);

    }

    /**
     * Delete Group
     * Delete Group
     * @param id Group ID. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public void deleteGroupsId(Integer id) throws ApiException {
        deleteGroupsIdWithHttpInfo(id);
    }

    /**
     * Delete Group
     * Delete Group
     * @param id Group ID. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteGroupsIdWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = deleteGroupsIdValidateBeforeCall(id, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Group (asynchronously)
     * Delete Group
     * @param id Group ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteGroupsIdAsync(Integer id, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteGroupsIdValidateBeforeCall(id, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroups
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[name]&#x3D;desc&#x60;). Valid fields are &#x60;name&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;name&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;name&#x60;. (optional)
     * @param ids Comma-separated list of group ids to include in results. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Groups objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsCall(String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String ids, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(sortBy));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filter));
        }

        if (filterPrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterPrefix));
        }

        if (ids != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ids", ids));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupsValidateBeforeCall(String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String ids, final ApiCallback _callback) throws ApiException {
        return getGroupsCall(cursor, perPage, sortBy, filter, filterPrefix, ids, _callback);

    }

    /**
     * List Groups
     * List Groups
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[name]&#x3D;desc&#x60;). Valid fields are &#x60;name&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;name&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;name&#x60;. (optional)
     * @param ids Comma-separated list of group ids to include in results. (optional)
     * @return List&lt;GroupEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Groups objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<GroupEntity> getGroups(String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String ids) throws ApiException {
        ApiResponse<List<GroupEntity>> localVarResp = getGroupsWithHttpInfo(cursor, perPage, sortBy, filter, filterPrefix, ids);
        return localVarResp.getData();
    }

    /**
     * List Groups
     * List Groups
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[name]&#x3D;desc&#x60;). Valid fields are &#x60;name&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;name&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;name&#x60;. (optional)
     * @param ids Comma-separated list of group ids to include in results. (optional)
     * @return ApiResponse&lt;List&lt;GroupEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Groups objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<GroupEntity>> getGroupsWithHttpInfo(String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String ids) throws ApiException {
        okhttp3.Call localVarCall = getGroupsValidateBeforeCall(cursor, perPage, sortBy, filter, filterPrefix, ids, null);
        Type localVarReturnType = new TypeToken<List<GroupEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Groups (asynchronously)
     * List Groups
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[name]&#x3D;desc&#x60;). Valid fields are &#x60;name&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;name&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;name&#x60;. (optional)
     * @param ids Comma-separated list of group ids to include in results. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Groups objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsAsync(String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String ids, final ApiCallback<List<GroupEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupsValidateBeforeCall(cursor, perPage, sortBy, filter, filterPrefix, ids, _callback);
        Type localVarReturnType = new TypeToken<List<GroupEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupsGroupIdPermissions
     * @param groupId DEPRECATED: Group ID.  If provided, will scope permissions to this group. Use &#x60;filter[group_id]&#x60; instead.&#x60; (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[group_id]&#x3D;desc&#x60;). Valid fields are &#x60;group_id&#x60;, &#x60;path&#x60;, &#x60;user_id&#x60; or &#x60;permission&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;group_id&#x60;, &#x60;user_id&#x60; or &#x60;path&#x60;. Valid field combinations are &#x60;[ group_id, path ]&#x60; and &#x60;[ user_id, path ]&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;path&#x60;. (optional)
     * @param path DEPRECATED: Permission path.  If provided, will scope permissions to this path. Use &#x60;filter[path]&#x60; instead. (optional)
     * @param userId DEPRECATED: User ID.  If provided, will scope permissions to this user. Use &#x60;filter[user_id]&#x60; instead.&#x60; (optional)
     * @param includeGroups If searching by user or group, also include user&#39;s permissions that are inherited from its groups? (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Permissions objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsGroupIdPermissionsCall(String groupId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String userId, Boolean includeGroups, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{group_id}/permissions"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(sortBy));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filter));
        }

        if (filterPrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterPrefix));
        }

        if (path != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("path", path));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (includeGroups != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_groups", includeGroups));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupsGroupIdPermissionsValidateBeforeCall(String groupId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String userId, Boolean includeGroups, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling getGroupsGroupIdPermissions(Async)");
        }

        return getGroupsGroupIdPermissionsCall(groupId, cursor, perPage, sortBy, filter, filterPrefix, path, userId, includeGroups, _callback);

    }

    /**
     * List Permissions
     * List Permissions
     * @param groupId DEPRECATED: Group ID.  If provided, will scope permissions to this group. Use &#x60;filter[group_id]&#x60; instead.&#x60; (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[group_id]&#x3D;desc&#x60;). Valid fields are &#x60;group_id&#x60;, &#x60;path&#x60;, &#x60;user_id&#x60; or &#x60;permission&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;group_id&#x60;, &#x60;user_id&#x60; or &#x60;path&#x60;. Valid field combinations are &#x60;[ group_id, path ]&#x60; and &#x60;[ user_id, path ]&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;path&#x60;. (optional)
     * @param path DEPRECATED: Permission path.  If provided, will scope permissions to this path. Use &#x60;filter[path]&#x60; instead. (optional)
     * @param userId DEPRECATED: User ID.  If provided, will scope permissions to this user. Use &#x60;filter[user_id]&#x60; instead.&#x60; (optional)
     * @param includeGroups If searching by user or group, also include user&#39;s permissions that are inherited from its groups? (optional)
     * @return List&lt;PermissionEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Permissions objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<PermissionEntity> getGroupsGroupIdPermissions(String groupId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String userId, Boolean includeGroups) throws ApiException {
        ApiResponse<List<PermissionEntity>> localVarResp = getGroupsGroupIdPermissionsWithHttpInfo(groupId, cursor, perPage, sortBy, filter, filterPrefix, path, userId, includeGroups);
        return localVarResp.getData();
    }

    /**
     * List Permissions
     * List Permissions
     * @param groupId DEPRECATED: Group ID.  If provided, will scope permissions to this group. Use &#x60;filter[group_id]&#x60; instead.&#x60; (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[group_id]&#x3D;desc&#x60;). Valid fields are &#x60;group_id&#x60;, &#x60;path&#x60;, &#x60;user_id&#x60; or &#x60;permission&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;group_id&#x60;, &#x60;user_id&#x60; or &#x60;path&#x60;. Valid field combinations are &#x60;[ group_id, path ]&#x60; and &#x60;[ user_id, path ]&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;path&#x60;. (optional)
     * @param path DEPRECATED: Permission path.  If provided, will scope permissions to this path. Use &#x60;filter[path]&#x60; instead. (optional)
     * @param userId DEPRECATED: User ID.  If provided, will scope permissions to this user. Use &#x60;filter[user_id]&#x60; instead.&#x60; (optional)
     * @param includeGroups If searching by user or group, also include user&#39;s permissions that are inherited from its groups? (optional)
     * @return ApiResponse&lt;List&lt;PermissionEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Permissions objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<PermissionEntity>> getGroupsGroupIdPermissionsWithHttpInfo(String groupId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String userId, Boolean includeGroups) throws ApiException {
        okhttp3.Call localVarCall = getGroupsGroupIdPermissionsValidateBeforeCall(groupId, cursor, perPage, sortBy, filter, filterPrefix, path, userId, includeGroups, null);
        Type localVarReturnType = new TypeToken<List<PermissionEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Permissions (asynchronously)
     * List Permissions
     * @param groupId DEPRECATED: Group ID.  If provided, will scope permissions to this group. Use &#x60;filter[group_id]&#x60; instead.&#x60; (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[group_id]&#x3D;desc&#x60;). Valid fields are &#x60;group_id&#x60;, &#x60;path&#x60;, &#x60;user_id&#x60; or &#x60;permission&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;group_id&#x60;, &#x60;user_id&#x60; or &#x60;path&#x60;. Valid field combinations are &#x60;[ group_id, path ]&#x60; and &#x60;[ user_id, path ]&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;path&#x60;. (optional)
     * @param path DEPRECATED: Permission path.  If provided, will scope permissions to this path. Use &#x60;filter[path]&#x60; instead. (optional)
     * @param userId DEPRECATED: User ID.  If provided, will scope permissions to this user. Use &#x60;filter[user_id]&#x60; instead.&#x60; (optional)
     * @param includeGroups If searching by user or group, also include user&#39;s permissions that are inherited from its groups? (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Permissions objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsGroupIdPermissionsAsync(String groupId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String userId, Boolean includeGroups, final ApiCallback<List<PermissionEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupsGroupIdPermissionsValidateBeforeCall(groupId, cursor, perPage, sortBy, filter, filterPrefix, path, userId, includeGroups, _callback);
        Type localVarReturnType = new TypeToken<List<PermissionEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupsGroupIdUsers
     * @param groupId Group ID.  If provided, will return group_users of this group. (required)
     * @param userId User ID.  If provided, will return group_users of this user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsGroupIdUsersCall(Integer groupId, Integer userId, String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{group_id}/users"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupsGroupIdUsersValidateBeforeCall(Integer groupId, Integer userId, String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling getGroupsGroupIdUsers(Async)");
        }

        return getGroupsGroupIdUsersCall(groupId, userId, cursor, perPage, _callback);

    }

    /**
     * List Group Users
     * List Group Users
     * @param groupId Group ID.  If provided, will return group_users of this group. (required)
     * @param userId User ID.  If provided, will return group_users of this user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return List&lt;GroupUserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<GroupUserEntity> getGroupsGroupIdUsers(Integer groupId, Integer userId, String cursor, Integer perPage) throws ApiException {
        ApiResponse<List<GroupUserEntity>> localVarResp = getGroupsGroupIdUsersWithHttpInfo(groupId, userId, cursor, perPage);
        return localVarResp.getData();
    }

    /**
     * List Group Users
     * List Group Users
     * @param groupId Group ID.  If provided, will return group_users of this group. (required)
     * @param userId User ID.  If provided, will return group_users of this user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return ApiResponse&lt;List&lt;GroupUserEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<GroupUserEntity>> getGroupsGroupIdUsersWithHttpInfo(Integer groupId, Integer userId, String cursor, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = getGroupsGroupIdUsersValidateBeforeCall(groupId, userId, cursor, perPage, null);
        Type localVarReturnType = new TypeToken<List<GroupUserEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Group Users (asynchronously)
     * List Group Users
     * @param groupId Group ID.  If provided, will return group_users of this group. (required)
     * @param userId User ID.  If provided, will return group_users of this user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsGroupIdUsersAsync(Integer groupId, Integer userId, String cursor, Integer perPage, final ApiCallback<List<GroupUserEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupsGroupIdUsersValidateBeforeCall(groupId, userId, cursor, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<GroupUserEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGroupsId
     * @param id Group ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsIdCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGroupsIdValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getGroupsId(Async)");
        }

        return getGroupsIdCall(id, _callback);

    }

    /**
     * Show Group
     * Show Group
     * @param id Group ID. (required)
     * @return GroupEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public GroupEntity getGroupsId(Integer id) throws ApiException {
        ApiResponse<GroupEntity> localVarResp = getGroupsIdWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Show Group
     * Show Group
     * @param id Group ID. (required)
     * @return ApiResponse&lt;GroupEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GroupEntity> getGroupsIdWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = getGroupsIdValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<GroupEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Show Group (asynchronously)
     * Show Group
     * @param id Group ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGroupsIdAsync(Integer id, final ApiCallback<GroupEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGroupsIdValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<GroupEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for patchGroupsGroupIdMembershipsUserId
     * @param groupId Group ID to add user to. (required)
     * @param userId User ID to add to group. (required)
     * @param admin Is the user a group administrator? (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The GroupUsers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchGroupsGroupIdMembershipsUserIdCall(Integer groupId, Integer userId, Boolean admin, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{group_id}/memberships/{user_id}"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()))
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (admin != null) {
            localVarFormParams.put("admin", admin);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call patchGroupsGroupIdMembershipsUserIdValidateBeforeCall(Integer groupId, Integer userId, Boolean admin, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling patchGroupsGroupIdMembershipsUserId(Async)");
        }

        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling patchGroupsGroupIdMembershipsUserId(Async)");
        }

        return patchGroupsGroupIdMembershipsUserIdCall(groupId, userId, admin, _callback);

    }

    /**
     * Update Group User
     * Update Group User
     * @param groupId Group ID to add user to. (required)
     * @param userId User ID to add to group. (required)
     * @param admin Is the user a group administrator? (optional)
     * @return GroupUserEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The GroupUsers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public GroupUserEntity patchGroupsGroupIdMembershipsUserId(Integer groupId, Integer userId, Boolean admin) throws ApiException {
        ApiResponse<GroupUserEntity> localVarResp = patchGroupsGroupIdMembershipsUserIdWithHttpInfo(groupId, userId, admin);
        return localVarResp.getData();
    }

    /**
     * Update Group User
     * Update Group User
     * @param groupId Group ID to add user to. (required)
     * @param userId User ID to add to group. (required)
     * @param admin Is the user a group administrator? (optional)
     * @return ApiResponse&lt;GroupUserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The GroupUsers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GroupUserEntity> patchGroupsGroupIdMembershipsUserIdWithHttpInfo(Integer groupId, Integer userId, Boolean admin) throws ApiException {
        okhttp3.Call localVarCall = patchGroupsGroupIdMembershipsUserIdValidateBeforeCall(groupId, userId, admin, null);
        Type localVarReturnType = new TypeToken<GroupUserEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Group User (asynchronously)
     * Update Group User
     * @param groupId Group ID to add user to. (required)
     * @param userId User ID to add to group. (required)
     * @param admin Is the user a group administrator? (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The GroupUsers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchGroupsGroupIdMembershipsUserIdAsync(Integer groupId, Integer userId, Boolean admin, final ApiCallback<GroupUserEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = patchGroupsGroupIdMembershipsUserIdValidateBeforeCall(groupId, userId, admin, _callback);
        Type localVarReturnType = new TypeToken<GroupUserEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for patchGroupsId
     * @param id Group ID. (required)
     * @param adminIds A list of group admin user ids. If sent as a string, should be comma-delimited. (optional)
     * @param name Group name. (optional)
     * @param notes Group notes. (optional)
     * @param userIds A list of user ids. If sent as a string, should be comma-delimited. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchGroupsIdCall(Integer id, String adminIds, String name, String notes, String userIds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (adminIds != null) {
            localVarFormParams.put("admin_ids", adminIds);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (notes != null) {
            localVarFormParams.put("notes", notes);
        }

        if (userIds != null) {
            localVarFormParams.put("user_ids", userIds);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call patchGroupsIdValidateBeforeCall(Integer id, String adminIds, String name, String notes, String userIds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling patchGroupsId(Async)");
        }

        return patchGroupsIdCall(id, adminIds, name, notes, userIds, _callback);

    }

    /**
     * Update Group
     * Update Group
     * @param id Group ID. (required)
     * @param adminIds A list of group admin user ids. If sent as a string, should be comma-delimited. (optional)
     * @param name Group name. (optional)
     * @param notes Group notes. (optional)
     * @param userIds A list of user ids. If sent as a string, should be comma-delimited. (optional)
     * @return GroupEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public GroupEntity patchGroupsId(Integer id, String adminIds, String name, String notes, String userIds) throws ApiException {
        ApiResponse<GroupEntity> localVarResp = patchGroupsIdWithHttpInfo(id, adminIds, name, notes, userIds);
        return localVarResp.getData();
    }

    /**
     * Update Group
     * Update Group
     * @param id Group ID. (required)
     * @param adminIds A list of group admin user ids. If sent as a string, should be comma-delimited. (optional)
     * @param name Group name. (optional)
     * @param notes Group notes. (optional)
     * @param userIds A list of user ids. If sent as a string, should be comma-delimited. (optional)
     * @return ApiResponse&lt;GroupEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GroupEntity> patchGroupsIdWithHttpInfo(Integer id, String adminIds, String name, String notes, String userIds) throws ApiException {
        okhttp3.Call localVarCall = patchGroupsIdValidateBeforeCall(id, adminIds, name, notes, userIds, null);
        Type localVarReturnType = new TypeToken<GroupEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Group (asynchronously)
     * Update Group
     * @param id Group ID. (required)
     * @param adminIds A list of group admin user ids. If sent as a string, should be comma-delimited. (optional)
     * @param name Group name. (optional)
     * @param notes Group notes. (optional)
     * @param userIds A list of user ids. If sent as a string, should be comma-delimited. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchGroupsIdAsync(Integer id, String adminIds, String name, String notes, String userIds, final ApiCallback<GroupEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = patchGroupsIdValidateBeforeCall(id, adminIds, name, notes, userIds, _callback);
        Type localVarReturnType = new TypeToken<GroupEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postGroups
     * @param adminIds A list of group admin user ids. If sent as a string, should be comma-delimited. (optional)
     * @param name Group name. (optional)
     * @param notes Group notes. (optional)
     * @param userIds A list of user ids. If sent as a string, should be comma-delimited. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postGroupsCall(String adminIds, String name, String notes, String userIds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (adminIds != null) {
            localVarFormParams.put("admin_ids", adminIds);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (notes != null) {
            localVarFormParams.put("notes", notes);
        }

        if (userIds != null) {
            localVarFormParams.put("user_ids", userIds);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postGroupsValidateBeforeCall(String adminIds, String name, String notes, String userIds, final ApiCallback _callback) throws ApiException {
        return postGroupsCall(adminIds, name, notes, userIds, _callback);

    }

    /**
     * Create Group
     * Create Group
     * @param adminIds A list of group admin user ids. If sent as a string, should be comma-delimited. (optional)
     * @param name Group name. (optional)
     * @param notes Group notes. (optional)
     * @param userIds A list of user ids. If sent as a string, should be comma-delimited. (optional)
     * @return GroupEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public GroupEntity postGroups(String adminIds, String name, String notes, String userIds) throws ApiException {
        ApiResponse<GroupEntity> localVarResp = postGroupsWithHttpInfo(adminIds, name, notes, userIds);
        return localVarResp.getData();
    }

    /**
     * Create Group
     * Create Group
     * @param adminIds A list of group admin user ids. If sent as a string, should be comma-delimited. (optional)
     * @param name Group name. (optional)
     * @param notes Group notes. (optional)
     * @param userIds A list of user ids. If sent as a string, should be comma-delimited. (optional)
     * @return ApiResponse&lt;GroupEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GroupEntity> postGroupsWithHttpInfo(String adminIds, String name, String notes, String userIds) throws ApiException {
        okhttp3.Call localVarCall = postGroupsValidateBeforeCall(adminIds, name, notes, userIds, null);
        Type localVarReturnType = new TypeToken<GroupEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Group (asynchronously)
     * Create Group
     * @param adminIds A list of group admin user ids. If sent as a string, should be comma-delimited. (optional)
     * @param name Group name. (optional)
     * @param notes Group notes. (optional)
     * @param userIds A list of user ids. If sent as a string, should be comma-delimited. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Groups object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postGroupsAsync(String adminIds, String name, String notes, String userIds, final ApiCallback<GroupEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postGroupsValidateBeforeCall(adminIds, name, notes, userIds, _callback);
        Type localVarReturnType = new TypeToken<GroupEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postGroupsGroupIdUsers
     * @param groupId Group ID to associate this user with. (required)
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postGroupsGroupIdUsersCall(Integer groupId, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/groups/{group_id}/users"
            .replace("{" + "group_id" + "}", localVarApiClient.escapeString(groupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (allowedIps != null) {
            localVarFormParams.put("allowed_ips", allowedIps);
        }

        if (announcementsRead != null) {
            localVarFormParams.put("announcements_read", announcementsRead);
        }

        if (attachmentsPermission != null) {
            localVarFormParams.put("attachments_permission", attachmentsPermission);
        }

        if (authenticateUntil != null) {
            localVarFormParams.put("authenticate_until", authenticateUntil);
        }

        if (authenticationMethod != null) {
            localVarFormParams.put("authentication_method", authenticationMethod);
        }

        if (avatarDelete != null) {
            localVarFormParams.put("avatar_delete", avatarDelete);
        }

        if (avatarFile != null) {
            localVarFormParams.put("avatar_file", avatarFile);
        }

        if (billingPermission != null) {
            localVarFormParams.put("billing_permission", billingPermission);
        }

        if (bypassInactiveDisable != null) {
            localVarFormParams.put("bypass_inactive_disable", bypassInactiveDisable);
        }

        if (bypassSiteAllowedIps != null) {
            localVarFormParams.put("bypass_site_allowed_ips", bypassSiteAllowedIps);
        }

        if (changePassword != null) {
            localVarFormParams.put("change_password", changePassword);
        }

        if (changePasswordConfirmation != null) {
            localVarFormParams.put("change_password_confirmation", changePasswordConfirmation);
        }

        if (company != null) {
            localVarFormParams.put("company", company);
        }

        if (davPermission != null) {
            localVarFormParams.put("dav_permission", davPermission);
        }

        if (disabled != null) {
            localVarFormParams.put("disabled", disabled);
        }

        if (email != null) {
            localVarFormParams.put("email", email);
        }

        if (ftpPermission != null) {
            localVarFormParams.put("ftp_permission", ftpPermission);
        }

        if (grantPermission != null) {
            localVarFormParams.put("grant_permission", grantPermission);
        }

        if (groupIds != null) {
            localVarFormParams.put("group_ids", groupIds);
        }

        if (headerText != null) {
            localVarFormParams.put("header_text", headerText);
        }

        if (importedPasswordHash != null) {
            localVarFormParams.put("imported_password_hash", importedPasswordHash);
        }

        if (language != null) {
            localVarFormParams.put("language", language);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (notes != null) {
            localVarFormParams.put("notes", notes);
        }

        if (notificationDailySendTime != null) {
            localVarFormParams.put("notification_daily_send_time", notificationDailySendTime);
        }

        if (officeIntegrationEnabled != null) {
            localVarFormParams.put("office_integration_enabled", officeIntegrationEnabled);
        }

        if (password != null) {
            localVarFormParams.put("password", password);
        }

        if (passwordConfirmation != null) {
            localVarFormParams.put("password_confirmation", passwordConfirmation);
        }

        if (passwordValidityDays != null) {
            localVarFormParams.put("password_validity_days", passwordValidityDays);
        }

        if (receiveAdminAlerts != null) {
            localVarFormParams.put("receive_admin_alerts", receiveAdminAlerts);
        }

        if (require2fa != null) {
            localVarFormParams.put("require_2fa", require2fa);
        }

        if (requirePasswordChange != null) {
            localVarFormParams.put("require_password_change", requirePasswordChange);
        }

        if (restapiPermission != null) {
            localVarFormParams.put("restapi_permission", restapiPermission);
        }

        if (selfManaged != null) {
            localVarFormParams.put("self_managed", selfManaged);
        }

        if (sftpPermission != null) {
            localVarFormParams.put("sftp_permission", sftpPermission);
        }

        if (siteAdmin != null) {
            localVarFormParams.put("site_admin", siteAdmin);
        }

        if (skipWelcomeScreen != null) {
            localVarFormParams.put("skip_welcome_screen", skipWelcomeScreen);
        }

        if (sslRequired != null) {
            localVarFormParams.put("ssl_required", sslRequired);
        }

        if (ssoStrategyId != null) {
            localVarFormParams.put("sso_strategy_id", ssoStrategyId);
        }

        if (subscribeToNewsletter != null) {
            localVarFormParams.put("subscribe_to_newsletter", subscribeToNewsletter);
        }

        if (timeZone != null) {
            localVarFormParams.put("time_zone", timeZone);
        }

        if (userRoot != null) {
            localVarFormParams.put("user_root", userRoot);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postGroupsGroupIdUsersValidateBeforeCall(Integer groupId, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupId' is set
        if (groupId == null) {
            throw new ApiException("Missing the required parameter 'groupId' when calling postGroupsGroupIdUsers(Async)");
        }

        return postGroupsGroupIdUsersCall(groupId, allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, _callback);

    }

    /**
     * Create User
     * Create User
     * @param groupId Group ID to associate this user with. (required)
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @return UserEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public UserEntity postGroupsGroupIdUsers(Integer groupId, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username) throws ApiException {
        ApiResponse<UserEntity> localVarResp = postGroupsGroupIdUsersWithHttpInfo(groupId, allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username);
        return localVarResp.getData();
    }

    /**
     * Create User
     * Create User
     * @param groupId Group ID to associate this user with. (required)
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @return ApiResponse&lt;UserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UserEntity> postGroupsGroupIdUsersWithHttpInfo(Integer groupId, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username) throws ApiException {
        okhttp3.Call localVarCall = postGroupsGroupIdUsersValidateBeforeCall(groupId, allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, null);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create User (asynchronously)
     * Create User
     * @param groupId Group ID to associate this user with. (required)
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postGroupsGroupIdUsersAsync(Integer groupId, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback<UserEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postGroupsGroupIdUsersValidateBeforeCall(groupId, allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, _callback);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
