/*
 * Files.com API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@files.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.RemoteServerConfigurationFileEntity;
import org.openapitools.client.model.RemoteServerEntity;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RemoteServersApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public RemoteServersApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RemoteServersApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for deleteRemoteServersId
     * @param id Remote Server ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteRemoteServersIdCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/remote_servers/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteRemoteServersIdValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteRemoteServersId(Async)");
        }

        return deleteRemoteServersIdCall(id, _callback);

    }

    /**
     * Delete Remote Server
     * Delete Remote Server
     * @param id Remote Server ID. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public void deleteRemoteServersId(Integer id) throws ApiException {
        deleteRemoteServersIdWithHttpInfo(id);
    }

    /**
     * Delete Remote Server
     * Delete Remote Server
     * @param id Remote Server ID. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteRemoteServersIdWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = deleteRemoteServersIdValidateBeforeCall(id, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Remote Server (asynchronously)
     * Delete Remote Server
     * @param id Remote Server ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteRemoteServersIdAsync(Integer id, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteRemoteServersIdValidateBeforeCall(id, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRemoteServers
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of RemoteServers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRemoteServersCall(String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/remote_servers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRemoteServersValidateBeforeCall(String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        return getRemoteServersCall(cursor, perPage, _callback);

    }

    /**
     * List Remote Servers
     * List Remote Servers
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return List&lt;RemoteServerEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of RemoteServers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<RemoteServerEntity> getRemoteServers(String cursor, Integer perPage) throws ApiException {
        ApiResponse<List<RemoteServerEntity>> localVarResp = getRemoteServersWithHttpInfo(cursor, perPage);
        return localVarResp.getData();
    }

    /**
     * List Remote Servers
     * List Remote Servers
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return ApiResponse&lt;List&lt;RemoteServerEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of RemoteServers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<RemoteServerEntity>> getRemoteServersWithHttpInfo(String cursor, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = getRemoteServersValidateBeforeCall(cursor, perPage, null);
        Type localVarReturnType = new TypeToken<List<RemoteServerEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Remote Servers (asynchronously)
     * List Remote Servers
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of RemoteServers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRemoteServersAsync(String cursor, Integer perPage, final ApiCallback<List<RemoteServerEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRemoteServersValidateBeforeCall(cursor, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<RemoteServerEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRemoteServersId
     * @param id Remote Server ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRemoteServersIdCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/remote_servers/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRemoteServersIdValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getRemoteServersId(Async)");
        }

        return getRemoteServersIdCall(id, _callback);

    }

    /**
     * Show Remote Server
     * Show Remote Server
     * @param id Remote Server ID. (required)
     * @return RemoteServerEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public RemoteServerEntity getRemoteServersId(Integer id) throws ApiException {
        ApiResponse<RemoteServerEntity> localVarResp = getRemoteServersIdWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Show Remote Server
     * Show Remote Server
     * @param id Remote Server ID. (required)
     * @return ApiResponse&lt;RemoteServerEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RemoteServerEntity> getRemoteServersIdWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = getRemoteServersIdValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<RemoteServerEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Show Remote Server (asynchronously)
     * Show Remote Server
     * @param id Remote Server ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRemoteServersIdAsync(Integer id, final ApiCallback<RemoteServerEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRemoteServersIdValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<RemoteServerEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRemoteServersIdConfigurationFile
     * @param id Remote Server ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRemoteServersIdConfigurationFileCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/remote_servers/{id}/configuration_file"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRemoteServersIdConfigurationFileValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getRemoteServersIdConfigurationFile(Async)");
        }

        return getRemoteServersIdConfigurationFileCall(id, _callback);

    }

    /**
     * Download configuration file (required for some Remote Server integrations, such as the Files.com Agent)
     * Download configuration file (required for some Remote Server integrations, such as the Files.com Agent)
     * @param id Remote Server ID. (required)
     * @return RemoteServerConfigurationFileEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public RemoteServerConfigurationFileEntity getRemoteServersIdConfigurationFile(Integer id) throws ApiException {
        ApiResponse<RemoteServerConfigurationFileEntity> localVarResp = getRemoteServersIdConfigurationFileWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Download configuration file (required for some Remote Server integrations, such as the Files.com Agent)
     * Download configuration file (required for some Remote Server integrations, such as the Files.com Agent)
     * @param id Remote Server ID. (required)
     * @return ApiResponse&lt;RemoteServerConfigurationFileEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RemoteServerConfigurationFileEntity> getRemoteServersIdConfigurationFileWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = getRemoteServersIdConfigurationFileValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<RemoteServerConfigurationFileEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Download configuration file (required for some Remote Server integrations, such as the Files.com Agent) (asynchronously)
     * Download configuration file (required for some Remote Server integrations, such as the Files.com Agent)
     * @param id Remote Server ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRemoteServersIdConfigurationFileAsync(Integer id, final ApiCallback<RemoteServerConfigurationFileEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRemoteServersIdConfigurationFileValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<RemoteServerConfigurationFileEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for patchRemoteServersId
     * @param id Remote Server ID. (required)
     * @param awsAccessKey AWS Access Key. (optional)
     * @param awsSecretKey AWS secret key. (optional)
     * @param azureBlobStorageAccessKey Azure Blob Storage secret key. (optional)
     * @param azureBlobStorageAccount Azure Blob Storage Account name (optional)
     * @param azureBlobStorageContainer Azure Blob Storage Container name (optional)
     * @param azureBlobStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageAccessKey Azure File Storage access key. (optional)
     * @param azureFilesStorageAccount Azure File Storage Account name (optional)
     * @param azureFilesStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageShareName Azure File Storage Share name (optional)
     * @param backblazeB2ApplicationKey Backblaze B2 Cloud Storage applicationKey. (optional)
     * @param backblazeB2Bucket Backblaze B2 Cloud Storage Bucket name (optional)
     * @param backblazeB2KeyId Backblaze B2 Cloud Storage keyID. (optional)
     * @param backblazeB2S3Endpoint Backblaze B2 Cloud Storage S3 Endpoint (optional)
     * @param enableDedicatedIps &#x60;true&#x60; if remote server only accepts connections from dedicated IPs (optional)
     * @param filebaseAccessKey Filebase Access Key. (optional)
     * @param filebaseBucket Filebase Bucket name (optional)
     * @param filebaseSecretKey Filebase secret key (optional)
     * @param filesAgentPermissionSet Local permissions for files agent. read_only, write_only, or read_write (optional)
     * @param filesAgentRoot Agent local root path (optional)
     * @param googleCloudStorageBucket Google Cloud Storage bucket name (optional)
     * @param googleCloudStorageCredentialsJson A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey (optional)
     * @param googleCloudStorageProjectId Google Cloud Project ID (optional)
     * @param hostname Hostname or IP address (optional)
     * @param maxConnections Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible). (optional)
     * @param name Internal name for your reference (optional)
     * @param oneDriveAccountType Either personal or business_other account types (optional)
     * @param password Password if needed. (optional)
     * @param pinToSiteRegion If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true. (optional)
     * @param port Port for remote server.  Not needed for S3. (optional)
     * @param privateKey Private key if needed. (optional)
     * @param privateKeyPassphrase Passphrase for private key if needed. (optional)
     * @param rackspaceApiKey Rackspace API key from the Rackspace Cloud Control Panel. (optional)
     * @param rackspaceContainer The name of the container (top level directory) where files will sync. (optional)
     * @param rackspaceRegion Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/ (optional)
     * @param rackspaceUsername Rackspace username used to login to the Rackspace Cloud Control Panel. (optional)
     * @param resetAuthentication Reset authenticated account (optional)
     * @param s3Bucket S3 bucket name (optional)
     * @param s3CompatibleAccessKey S3-compatible Access Key. (optional)
     * @param s3CompatibleBucket S3-compatible Bucket name (optional)
     * @param s3CompatibleEndpoint S3-compatible endpoint (optional)
     * @param s3CompatibleRegion S3-compatible endpoint (optional)
     * @param s3CompatibleSecretKey S3-compatible secret key (optional)
     * @param s3Region S3 region (optional)
     * @param serverCertificate Remote server certificate (optional)
     * @param serverHostKey Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts (optional)
     * @param serverType Remote server type. (optional)
     * @param ssl Should we require SSL? (optional)
     * @param sslCertificate SSL client certificate. (optional)
     * @param username Remote server username.  Not needed for S3 buckets. (optional)
     * @param wasabiAccessKey Wasabi access key. (optional)
     * @param wasabiBucket Wasabi Bucket name (optional)
     * @param wasabiRegion Wasabi region (optional)
     * @param wasabiSecretKey Wasabi secret key. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchRemoteServersIdCall(Integer id, String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/remote_servers/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (awsAccessKey != null) {
            localVarFormParams.put("aws_access_key", awsAccessKey);
        }

        if (awsSecretKey != null) {
            localVarFormParams.put("aws_secret_key", awsSecretKey);
        }

        if (azureBlobStorageAccessKey != null) {
            localVarFormParams.put("azure_blob_storage_access_key", azureBlobStorageAccessKey);
        }

        if (azureBlobStorageAccount != null) {
            localVarFormParams.put("azure_blob_storage_account", azureBlobStorageAccount);
        }

        if (azureBlobStorageContainer != null) {
            localVarFormParams.put("azure_blob_storage_container", azureBlobStorageContainer);
        }

        if (azureBlobStorageSasToken != null) {
            localVarFormParams.put("azure_blob_storage_sas_token", azureBlobStorageSasToken);
        }

        if (azureFilesStorageAccessKey != null) {
            localVarFormParams.put("azure_files_storage_access_key", azureFilesStorageAccessKey);
        }

        if (azureFilesStorageAccount != null) {
            localVarFormParams.put("azure_files_storage_account", azureFilesStorageAccount);
        }

        if (azureFilesStorageSasToken != null) {
            localVarFormParams.put("azure_files_storage_sas_token", azureFilesStorageSasToken);
        }

        if (azureFilesStorageShareName != null) {
            localVarFormParams.put("azure_files_storage_share_name", azureFilesStorageShareName);
        }

        if (backblazeB2ApplicationKey != null) {
            localVarFormParams.put("backblaze_b2_application_key", backblazeB2ApplicationKey);
        }

        if (backblazeB2Bucket != null) {
            localVarFormParams.put("backblaze_b2_bucket", backblazeB2Bucket);
        }

        if (backblazeB2KeyId != null) {
            localVarFormParams.put("backblaze_b2_key_id", backblazeB2KeyId);
        }

        if (backblazeB2S3Endpoint != null) {
            localVarFormParams.put("backblaze_b2_s3_endpoint", backblazeB2S3Endpoint);
        }

        if (enableDedicatedIps != null) {
            localVarFormParams.put("enable_dedicated_ips", enableDedicatedIps);
        }

        if (filebaseAccessKey != null) {
            localVarFormParams.put("filebase_access_key", filebaseAccessKey);
        }

        if (filebaseBucket != null) {
            localVarFormParams.put("filebase_bucket", filebaseBucket);
        }

        if (filebaseSecretKey != null) {
            localVarFormParams.put("filebase_secret_key", filebaseSecretKey);
        }

        if (filesAgentPermissionSet != null) {
            localVarFormParams.put("files_agent_permission_set", filesAgentPermissionSet);
        }

        if (filesAgentRoot != null) {
            localVarFormParams.put("files_agent_root", filesAgentRoot);
        }

        if (googleCloudStorageBucket != null) {
            localVarFormParams.put("google_cloud_storage_bucket", googleCloudStorageBucket);
        }

        if (googleCloudStorageCredentialsJson != null) {
            localVarFormParams.put("google_cloud_storage_credentials_json", googleCloudStorageCredentialsJson);
        }

        if (googleCloudStorageProjectId != null) {
            localVarFormParams.put("google_cloud_storage_project_id", googleCloudStorageProjectId);
        }

        if (hostname != null) {
            localVarFormParams.put("hostname", hostname);
        }

        if (maxConnections != null) {
            localVarFormParams.put("max_connections", maxConnections);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (oneDriveAccountType != null) {
            localVarFormParams.put("one_drive_account_type", oneDriveAccountType);
        }

        if (password != null) {
            localVarFormParams.put("password", password);
        }

        if (pinToSiteRegion != null) {
            localVarFormParams.put("pin_to_site_region", pinToSiteRegion);
        }

        if (port != null) {
            localVarFormParams.put("port", port);
        }

        if (privateKey != null) {
            localVarFormParams.put("private_key", privateKey);
        }

        if (privateKeyPassphrase != null) {
            localVarFormParams.put("private_key_passphrase", privateKeyPassphrase);
        }

        if (rackspaceApiKey != null) {
            localVarFormParams.put("rackspace_api_key", rackspaceApiKey);
        }

        if (rackspaceContainer != null) {
            localVarFormParams.put("rackspace_container", rackspaceContainer);
        }

        if (rackspaceRegion != null) {
            localVarFormParams.put("rackspace_region", rackspaceRegion);
        }

        if (rackspaceUsername != null) {
            localVarFormParams.put("rackspace_username", rackspaceUsername);
        }

        if (resetAuthentication != null) {
            localVarFormParams.put("reset_authentication", resetAuthentication);
        }

        if (s3Bucket != null) {
            localVarFormParams.put("s3_bucket", s3Bucket);
        }

        if (s3CompatibleAccessKey != null) {
            localVarFormParams.put("s3_compatible_access_key", s3CompatibleAccessKey);
        }

        if (s3CompatibleBucket != null) {
            localVarFormParams.put("s3_compatible_bucket", s3CompatibleBucket);
        }

        if (s3CompatibleEndpoint != null) {
            localVarFormParams.put("s3_compatible_endpoint", s3CompatibleEndpoint);
        }

        if (s3CompatibleRegion != null) {
            localVarFormParams.put("s3_compatible_region", s3CompatibleRegion);
        }

        if (s3CompatibleSecretKey != null) {
            localVarFormParams.put("s3_compatible_secret_key", s3CompatibleSecretKey);
        }

        if (s3Region != null) {
            localVarFormParams.put("s3_region", s3Region);
        }

        if (serverCertificate != null) {
            localVarFormParams.put("server_certificate", serverCertificate);
        }

        if (serverHostKey != null) {
            localVarFormParams.put("server_host_key", serverHostKey);
        }

        if (serverType != null) {
            localVarFormParams.put("server_type", serverType);
        }

        if (ssl != null) {
            localVarFormParams.put("ssl", ssl);
        }

        if (sslCertificate != null) {
            localVarFormParams.put("ssl_certificate", sslCertificate);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        if (wasabiAccessKey != null) {
            localVarFormParams.put("wasabi_access_key", wasabiAccessKey);
        }

        if (wasabiBucket != null) {
            localVarFormParams.put("wasabi_bucket", wasabiBucket);
        }

        if (wasabiRegion != null) {
            localVarFormParams.put("wasabi_region", wasabiRegion);
        }

        if (wasabiSecretKey != null) {
            localVarFormParams.put("wasabi_secret_key", wasabiSecretKey);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call patchRemoteServersIdValidateBeforeCall(Integer id, String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling patchRemoteServersId(Async)");
        }

        return patchRemoteServersIdCall(id, awsAccessKey, awsSecretKey, azureBlobStorageAccessKey, azureBlobStorageAccount, azureBlobStorageContainer, azureBlobStorageSasToken, azureFilesStorageAccessKey, azureFilesStorageAccount, azureFilesStorageSasToken, azureFilesStorageShareName, backblazeB2ApplicationKey, backblazeB2Bucket, backblazeB2KeyId, backblazeB2S3Endpoint, enableDedicatedIps, filebaseAccessKey, filebaseBucket, filebaseSecretKey, filesAgentPermissionSet, filesAgentRoot, googleCloudStorageBucket, googleCloudStorageCredentialsJson, googleCloudStorageProjectId, hostname, maxConnections, name, oneDriveAccountType, password, pinToSiteRegion, port, privateKey, privateKeyPassphrase, rackspaceApiKey, rackspaceContainer, rackspaceRegion, rackspaceUsername, resetAuthentication, s3Bucket, s3CompatibleAccessKey, s3CompatibleBucket, s3CompatibleEndpoint, s3CompatibleRegion, s3CompatibleSecretKey, s3Region, serverCertificate, serverHostKey, serverType, ssl, sslCertificate, username, wasabiAccessKey, wasabiBucket, wasabiRegion, wasabiSecretKey, _callback);

    }

    /**
     * Update Remote Server
     * Update Remote Server
     * @param id Remote Server ID. (required)
     * @param awsAccessKey AWS Access Key. (optional)
     * @param awsSecretKey AWS secret key. (optional)
     * @param azureBlobStorageAccessKey Azure Blob Storage secret key. (optional)
     * @param azureBlobStorageAccount Azure Blob Storage Account name (optional)
     * @param azureBlobStorageContainer Azure Blob Storage Container name (optional)
     * @param azureBlobStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageAccessKey Azure File Storage access key. (optional)
     * @param azureFilesStorageAccount Azure File Storage Account name (optional)
     * @param azureFilesStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageShareName Azure File Storage Share name (optional)
     * @param backblazeB2ApplicationKey Backblaze B2 Cloud Storage applicationKey. (optional)
     * @param backblazeB2Bucket Backblaze B2 Cloud Storage Bucket name (optional)
     * @param backblazeB2KeyId Backblaze B2 Cloud Storage keyID. (optional)
     * @param backblazeB2S3Endpoint Backblaze B2 Cloud Storage S3 Endpoint (optional)
     * @param enableDedicatedIps &#x60;true&#x60; if remote server only accepts connections from dedicated IPs (optional)
     * @param filebaseAccessKey Filebase Access Key. (optional)
     * @param filebaseBucket Filebase Bucket name (optional)
     * @param filebaseSecretKey Filebase secret key (optional)
     * @param filesAgentPermissionSet Local permissions for files agent. read_only, write_only, or read_write (optional)
     * @param filesAgentRoot Agent local root path (optional)
     * @param googleCloudStorageBucket Google Cloud Storage bucket name (optional)
     * @param googleCloudStorageCredentialsJson A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey (optional)
     * @param googleCloudStorageProjectId Google Cloud Project ID (optional)
     * @param hostname Hostname or IP address (optional)
     * @param maxConnections Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible). (optional)
     * @param name Internal name for your reference (optional)
     * @param oneDriveAccountType Either personal or business_other account types (optional)
     * @param password Password if needed. (optional)
     * @param pinToSiteRegion If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true. (optional)
     * @param port Port for remote server.  Not needed for S3. (optional)
     * @param privateKey Private key if needed. (optional)
     * @param privateKeyPassphrase Passphrase for private key if needed. (optional)
     * @param rackspaceApiKey Rackspace API key from the Rackspace Cloud Control Panel. (optional)
     * @param rackspaceContainer The name of the container (top level directory) where files will sync. (optional)
     * @param rackspaceRegion Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/ (optional)
     * @param rackspaceUsername Rackspace username used to login to the Rackspace Cloud Control Panel. (optional)
     * @param resetAuthentication Reset authenticated account (optional)
     * @param s3Bucket S3 bucket name (optional)
     * @param s3CompatibleAccessKey S3-compatible Access Key. (optional)
     * @param s3CompatibleBucket S3-compatible Bucket name (optional)
     * @param s3CompatibleEndpoint S3-compatible endpoint (optional)
     * @param s3CompatibleRegion S3-compatible endpoint (optional)
     * @param s3CompatibleSecretKey S3-compatible secret key (optional)
     * @param s3Region S3 region (optional)
     * @param serverCertificate Remote server certificate (optional)
     * @param serverHostKey Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts (optional)
     * @param serverType Remote server type. (optional)
     * @param ssl Should we require SSL? (optional)
     * @param sslCertificate SSL client certificate. (optional)
     * @param username Remote server username.  Not needed for S3 buckets. (optional)
     * @param wasabiAccessKey Wasabi access key. (optional)
     * @param wasabiBucket Wasabi Bucket name (optional)
     * @param wasabiRegion Wasabi region (optional)
     * @param wasabiSecretKey Wasabi secret key. (optional)
     * @return RemoteServerEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public RemoteServerEntity patchRemoteServersId(Integer id, String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey) throws ApiException {
        ApiResponse<RemoteServerEntity> localVarResp = patchRemoteServersIdWithHttpInfo(id, awsAccessKey, awsSecretKey, azureBlobStorageAccessKey, azureBlobStorageAccount, azureBlobStorageContainer, azureBlobStorageSasToken, azureFilesStorageAccessKey, azureFilesStorageAccount, azureFilesStorageSasToken, azureFilesStorageShareName, backblazeB2ApplicationKey, backblazeB2Bucket, backblazeB2KeyId, backblazeB2S3Endpoint, enableDedicatedIps, filebaseAccessKey, filebaseBucket, filebaseSecretKey, filesAgentPermissionSet, filesAgentRoot, googleCloudStorageBucket, googleCloudStorageCredentialsJson, googleCloudStorageProjectId, hostname, maxConnections, name, oneDriveAccountType, password, pinToSiteRegion, port, privateKey, privateKeyPassphrase, rackspaceApiKey, rackspaceContainer, rackspaceRegion, rackspaceUsername, resetAuthentication, s3Bucket, s3CompatibleAccessKey, s3CompatibleBucket, s3CompatibleEndpoint, s3CompatibleRegion, s3CompatibleSecretKey, s3Region, serverCertificate, serverHostKey, serverType, ssl, sslCertificate, username, wasabiAccessKey, wasabiBucket, wasabiRegion, wasabiSecretKey);
        return localVarResp.getData();
    }

    /**
     * Update Remote Server
     * Update Remote Server
     * @param id Remote Server ID. (required)
     * @param awsAccessKey AWS Access Key. (optional)
     * @param awsSecretKey AWS secret key. (optional)
     * @param azureBlobStorageAccessKey Azure Blob Storage secret key. (optional)
     * @param azureBlobStorageAccount Azure Blob Storage Account name (optional)
     * @param azureBlobStorageContainer Azure Blob Storage Container name (optional)
     * @param azureBlobStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageAccessKey Azure File Storage access key. (optional)
     * @param azureFilesStorageAccount Azure File Storage Account name (optional)
     * @param azureFilesStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageShareName Azure File Storage Share name (optional)
     * @param backblazeB2ApplicationKey Backblaze B2 Cloud Storage applicationKey. (optional)
     * @param backblazeB2Bucket Backblaze B2 Cloud Storage Bucket name (optional)
     * @param backblazeB2KeyId Backblaze B2 Cloud Storage keyID. (optional)
     * @param backblazeB2S3Endpoint Backblaze B2 Cloud Storage S3 Endpoint (optional)
     * @param enableDedicatedIps &#x60;true&#x60; if remote server only accepts connections from dedicated IPs (optional)
     * @param filebaseAccessKey Filebase Access Key. (optional)
     * @param filebaseBucket Filebase Bucket name (optional)
     * @param filebaseSecretKey Filebase secret key (optional)
     * @param filesAgentPermissionSet Local permissions for files agent. read_only, write_only, or read_write (optional)
     * @param filesAgentRoot Agent local root path (optional)
     * @param googleCloudStorageBucket Google Cloud Storage bucket name (optional)
     * @param googleCloudStorageCredentialsJson A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey (optional)
     * @param googleCloudStorageProjectId Google Cloud Project ID (optional)
     * @param hostname Hostname or IP address (optional)
     * @param maxConnections Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible). (optional)
     * @param name Internal name for your reference (optional)
     * @param oneDriveAccountType Either personal or business_other account types (optional)
     * @param password Password if needed. (optional)
     * @param pinToSiteRegion If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true. (optional)
     * @param port Port for remote server.  Not needed for S3. (optional)
     * @param privateKey Private key if needed. (optional)
     * @param privateKeyPassphrase Passphrase for private key if needed. (optional)
     * @param rackspaceApiKey Rackspace API key from the Rackspace Cloud Control Panel. (optional)
     * @param rackspaceContainer The name of the container (top level directory) where files will sync. (optional)
     * @param rackspaceRegion Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/ (optional)
     * @param rackspaceUsername Rackspace username used to login to the Rackspace Cloud Control Panel. (optional)
     * @param resetAuthentication Reset authenticated account (optional)
     * @param s3Bucket S3 bucket name (optional)
     * @param s3CompatibleAccessKey S3-compatible Access Key. (optional)
     * @param s3CompatibleBucket S3-compatible Bucket name (optional)
     * @param s3CompatibleEndpoint S3-compatible endpoint (optional)
     * @param s3CompatibleRegion S3-compatible endpoint (optional)
     * @param s3CompatibleSecretKey S3-compatible secret key (optional)
     * @param s3Region S3 region (optional)
     * @param serverCertificate Remote server certificate (optional)
     * @param serverHostKey Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts (optional)
     * @param serverType Remote server type. (optional)
     * @param ssl Should we require SSL? (optional)
     * @param sslCertificate SSL client certificate. (optional)
     * @param username Remote server username.  Not needed for S3 buckets. (optional)
     * @param wasabiAccessKey Wasabi access key. (optional)
     * @param wasabiBucket Wasabi Bucket name (optional)
     * @param wasabiRegion Wasabi region (optional)
     * @param wasabiSecretKey Wasabi secret key. (optional)
     * @return ApiResponse&lt;RemoteServerEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RemoteServerEntity> patchRemoteServersIdWithHttpInfo(Integer id, String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey) throws ApiException {
        okhttp3.Call localVarCall = patchRemoteServersIdValidateBeforeCall(id, awsAccessKey, awsSecretKey, azureBlobStorageAccessKey, azureBlobStorageAccount, azureBlobStorageContainer, azureBlobStorageSasToken, azureFilesStorageAccessKey, azureFilesStorageAccount, azureFilesStorageSasToken, azureFilesStorageShareName, backblazeB2ApplicationKey, backblazeB2Bucket, backblazeB2KeyId, backblazeB2S3Endpoint, enableDedicatedIps, filebaseAccessKey, filebaseBucket, filebaseSecretKey, filesAgentPermissionSet, filesAgentRoot, googleCloudStorageBucket, googleCloudStorageCredentialsJson, googleCloudStorageProjectId, hostname, maxConnections, name, oneDriveAccountType, password, pinToSiteRegion, port, privateKey, privateKeyPassphrase, rackspaceApiKey, rackspaceContainer, rackspaceRegion, rackspaceUsername, resetAuthentication, s3Bucket, s3CompatibleAccessKey, s3CompatibleBucket, s3CompatibleEndpoint, s3CompatibleRegion, s3CompatibleSecretKey, s3Region, serverCertificate, serverHostKey, serverType, ssl, sslCertificate, username, wasabiAccessKey, wasabiBucket, wasabiRegion, wasabiSecretKey, null);
        Type localVarReturnType = new TypeToken<RemoteServerEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Remote Server (asynchronously)
     * Update Remote Server
     * @param id Remote Server ID. (required)
     * @param awsAccessKey AWS Access Key. (optional)
     * @param awsSecretKey AWS secret key. (optional)
     * @param azureBlobStorageAccessKey Azure Blob Storage secret key. (optional)
     * @param azureBlobStorageAccount Azure Blob Storage Account name (optional)
     * @param azureBlobStorageContainer Azure Blob Storage Container name (optional)
     * @param azureBlobStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageAccessKey Azure File Storage access key. (optional)
     * @param azureFilesStorageAccount Azure File Storage Account name (optional)
     * @param azureFilesStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageShareName Azure File Storage Share name (optional)
     * @param backblazeB2ApplicationKey Backblaze B2 Cloud Storage applicationKey. (optional)
     * @param backblazeB2Bucket Backblaze B2 Cloud Storage Bucket name (optional)
     * @param backblazeB2KeyId Backblaze B2 Cloud Storage keyID. (optional)
     * @param backblazeB2S3Endpoint Backblaze B2 Cloud Storage S3 Endpoint (optional)
     * @param enableDedicatedIps &#x60;true&#x60; if remote server only accepts connections from dedicated IPs (optional)
     * @param filebaseAccessKey Filebase Access Key. (optional)
     * @param filebaseBucket Filebase Bucket name (optional)
     * @param filebaseSecretKey Filebase secret key (optional)
     * @param filesAgentPermissionSet Local permissions for files agent. read_only, write_only, or read_write (optional)
     * @param filesAgentRoot Agent local root path (optional)
     * @param googleCloudStorageBucket Google Cloud Storage bucket name (optional)
     * @param googleCloudStorageCredentialsJson A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey (optional)
     * @param googleCloudStorageProjectId Google Cloud Project ID (optional)
     * @param hostname Hostname or IP address (optional)
     * @param maxConnections Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible). (optional)
     * @param name Internal name for your reference (optional)
     * @param oneDriveAccountType Either personal or business_other account types (optional)
     * @param password Password if needed. (optional)
     * @param pinToSiteRegion If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true. (optional)
     * @param port Port for remote server.  Not needed for S3. (optional)
     * @param privateKey Private key if needed. (optional)
     * @param privateKeyPassphrase Passphrase for private key if needed. (optional)
     * @param rackspaceApiKey Rackspace API key from the Rackspace Cloud Control Panel. (optional)
     * @param rackspaceContainer The name of the container (top level directory) where files will sync. (optional)
     * @param rackspaceRegion Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/ (optional)
     * @param rackspaceUsername Rackspace username used to login to the Rackspace Cloud Control Panel. (optional)
     * @param resetAuthentication Reset authenticated account (optional)
     * @param s3Bucket S3 bucket name (optional)
     * @param s3CompatibleAccessKey S3-compatible Access Key. (optional)
     * @param s3CompatibleBucket S3-compatible Bucket name (optional)
     * @param s3CompatibleEndpoint S3-compatible endpoint (optional)
     * @param s3CompatibleRegion S3-compatible endpoint (optional)
     * @param s3CompatibleSecretKey S3-compatible secret key (optional)
     * @param s3Region S3 region (optional)
     * @param serverCertificate Remote server certificate (optional)
     * @param serverHostKey Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts (optional)
     * @param serverType Remote server type. (optional)
     * @param ssl Should we require SSL? (optional)
     * @param sslCertificate SSL client certificate. (optional)
     * @param username Remote server username.  Not needed for S3 buckets. (optional)
     * @param wasabiAccessKey Wasabi access key. (optional)
     * @param wasabiBucket Wasabi Bucket name (optional)
     * @param wasabiRegion Wasabi region (optional)
     * @param wasabiSecretKey Wasabi secret key. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchRemoteServersIdAsync(Integer id, String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey, final ApiCallback<RemoteServerEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = patchRemoteServersIdValidateBeforeCall(id, awsAccessKey, awsSecretKey, azureBlobStorageAccessKey, azureBlobStorageAccount, azureBlobStorageContainer, azureBlobStorageSasToken, azureFilesStorageAccessKey, azureFilesStorageAccount, azureFilesStorageSasToken, azureFilesStorageShareName, backblazeB2ApplicationKey, backblazeB2Bucket, backblazeB2KeyId, backblazeB2S3Endpoint, enableDedicatedIps, filebaseAccessKey, filebaseBucket, filebaseSecretKey, filesAgentPermissionSet, filesAgentRoot, googleCloudStorageBucket, googleCloudStorageCredentialsJson, googleCloudStorageProjectId, hostname, maxConnections, name, oneDriveAccountType, password, pinToSiteRegion, port, privateKey, privateKeyPassphrase, rackspaceApiKey, rackspaceContainer, rackspaceRegion, rackspaceUsername, resetAuthentication, s3Bucket, s3CompatibleAccessKey, s3CompatibleBucket, s3CompatibleEndpoint, s3CompatibleRegion, s3CompatibleSecretKey, s3Region, serverCertificate, serverHostKey, serverType, ssl, sslCertificate, username, wasabiAccessKey, wasabiBucket, wasabiRegion, wasabiSecretKey, _callback);
        Type localVarReturnType = new TypeToken<RemoteServerEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postRemoteServers
     * @param awsAccessKey AWS Access Key. (optional)
     * @param awsSecretKey AWS secret key. (optional)
     * @param azureBlobStorageAccessKey Azure Blob Storage secret key. (optional)
     * @param azureBlobStorageAccount Azure Blob Storage Account name (optional)
     * @param azureBlobStorageContainer Azure Blob Storage Container name (optional)
     * @param azureBlobStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageAccessKey Azure File Storage access key. (optional)
     * @param azureFilesStorageAccount Azure File Storage Account name (optional)
     * @param azureFilesStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageShareName Azure File Storage Share name (optional)
     * @param backblazeB2ApplicationKey Backblaze B2 Cloud Storage applicationKey. (optional)
     * @param backblazeB2Bucket Backblaze B2 Cloud Storage Bucket name (optional)
     * @param backblazeB2KeyId Backblaze B2 Cloud Storage keyID. (optional)
     * @param backblazeB2S3Endpoint Backblaze B2 Cloud Storage S3 Endpoint (optional)
     * @param enableDedicatedIps &#x60;true&#x60; if remote server only accepts connections from dedicated IPs (optional)
     * @param filebaseAccessKey Filebase Access Key. (optional)
     * @param filebaseBucket Filebase Bucket name (optional)
     * @param filebaseSecretKey Filebase secret key (optional)
     * @param filesAgentPermissionSet Local permissions for files agent. read_only, write_only, or read_write (optional)
     * @param filesAgentRoot Agent local root path (optional)
     * @param googleCloudStorageBucket Google Cloud Storage bucket name (optional)
     * @param googleCloudStorageCredentialsJson A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey (optional)
     * @param googleCloudStorageProjectId Google Cloud Project ID (optional)
     * @param hostname Hostname or IP address (optional)
     * @param maxConnections Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible). (optional)
     * @param name Internal name for your reference (optional)
     * @param oneDriveAccountType Either personal or business_other account types (optional)
     * @param password Password if needed. (optional)
     * @param pinToSiteRegion If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true. (optional)
     * @param port Port for remote server.  Not needed for S3. (optional)
     * @param privateKey Private key if needed. (optional)
     * @param privateKeyPassphrase Passphrase for private key if needed. (optional)
     * @param rackspaceApiKey Rackspace API key from the Rackspace Cloud Control Panel. (optional)
     * @param rackspaceContainer The name of the container (top level directory) where files will sync. (optional)
     * @param rackspaceRegion Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/ (optional)
     * @param rackspaceUsername Rackspace username used to login to the Rackspace Cloud Control Panel. (optional)
     * @param resetAuthentication Reset authenticated account (optional)
     * @param s3Bucket S3 bucket name (optional)
     * @param s3CompatibleAccessKey S3-compatible Access Key. (optional)
     * @param s3CompatibleBucket S3-compatible Bucket name (optional)
     * @param s3CompatibleEndpoint S3-compatible endpoint (optional)
     * @param s3CompatibleRegion S3-compatible endpoint (optional)
     * @param s3CompatibleSecretKey S3-compatible secret key (optional)
     * @param s3Region S3 region (optional)
     * @param serverCertificate Remote server certificate (optional)
     * @param serverHostKey Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts (optional)
     * @param serverType Remote server type. (optional)
     * @param ssl Should we require SSL? (optional)
     * @param sslCertificate SSL client certificate. (optional)
     * @param username Remote server username.  Not needed for S3 buckets. (optional)
     * @param wasabiAccessKey Wasabi access key. (optional)
     * @param wasabiBucket Wasabi Bucket name (optional)
     * @param wasabiRegion Wasabi region (optional)
     * @param wasabiSecretKey Wasabi secret key. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postRemoteServersCall(String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/remote_servers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (awsAccessKey != null) {
            localVarFormParams.put("aws_access_key", awsAccessKey);
        }

        if (awsSecretKey != null) {
            localVarFormParams.put("aws_secret_key", awsSecretKey);
        }

        if (azureBlobStorageAccessKey != null) {
            localVarFormParams.put("azure_blob_storage_access_key", azureBlobStorageAccessKey);
        }

        if (azureBlobStorageAccount != null) {
            localVarFormParams.put("azure_blob_storage_account", azureBlobStorageAccount);
        }

        if (azureBlobStorageContainer != null) {
            localVarFormParams.put("azure_blob_storage_container", azureBlobStorageContainer);
        }

        if (azureBlobStorageSasToken != null) {
            localVarFormParams.put("azure_blob_storage_sas_token", azureBlobStorageSasToken);
        }

        if (azureFilesStorageAccessKey != null) {
            localVarFormParams.put("azure_files_storage_access_key", azureFilesStorageAccessKey);
        }

        if (azureFilesStorageAccount != null) {
            localVarFormParams.put("azure_files_storage_account", azureFilesStorageAccount);
        }

        if (azureFilesStorageSasToken != null) {
            localVarFormParams.put("azure_files_storage_sas_token", azureFilesStorageSasToken);
        }

        if (azureFilesStorageShareName != null) {
            localVarFormParams.put("azure_files_storage_share_name", azureFilesStorageShareName);
        }

        if (backblazeB2ApplicationKey != null) {
            localVarFormParams.put("backblaze_b2_application_key", backblazeB2ApplicationKey);
        }

        if (backblazeB2Bucket != null) {
            localVarFormParams.put("backblaze_b2_bucket", backblazeB2Bucket);
        }

        if (backblazeB2KeyId != null) {
            localVarFormParams.put("backblaze_b2_key_id", backblazeB2KeyId);
        }

        if (backblazeB2S3Endpoint != null) {
            localVarFormParams.put("backblaze_b2_s3_endpoint", backblazeB2S3Endpoint);
        }

        if (enableDedicatedIps != null) {
            localVarFormParams.put("enable_dedicated_ips", enableDedicatedIps);
        }

        if (filebaseAccessKey != null) {
            localVarFormParams.put("filebase_access_key", filebaseAccessKey);
        }

        if (filebaseBucket != null) {
            localVarFormParams.put("filebase_bucket", filebaseBucket);
        }

        if (filebaseSecretKey != null) {
            localVarFormParams.put("filebase_secret_key", filebaseSecretKey);
        }

        if (filesAgentPermissionSet != null) {
            localVarFormParams.put("files_agent_permission_set", filesAgentPermissionSet);
        }

        if (filesAgentRoot != null) {
            localVarFormParams.put("files_agent_root", filesAgentRoot);
        }

        if (googleCloudStorageBucket != null) {
            localVarFormParams.put("google_cloud_storage_bucket", googleCloudStorageBucket);
        }

        if (googleCloudStorageCredentialsJson != null) {
            localVarFormParams.put("google_cloud_storage_credentials_json", googleCloudStorageCredentialsJson);
        }

        if (googleCloudStorageProjectId != null) {
            localVarFormParams.put("google_cloud_storage_project_id", googleCloudStorageProjectId);
        }

        if (hostname != null) {
            localVarFormParams.put("hostname", hostname);
        }

        if (maxConnections != null) {
            localVarFormParams.put("max_connections", maxConnections);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (oneDriveAccountType != null) {
            localVarFormParams.put("one_drive_account_type", oneDriveAccountType);
        }

        if (password != null) {
            localVarFormParams.put("password", password);
        }

        if (pinToSiteRegion != null) {
            localVarFormParams.put("pin_to_site_region", pinToSiteRegion);
        }

        if (port != null) {
            localVarFormParams.put("port", port);
        }

        if (privateKey != null) {
            localVarFormParams.put("private_key", privateKey);
        }

        if (privateKeyPassphrase != null) {
            localVarFormParams.put("private_key_passphrase", privateKeyPassphrase);
        }

        if (rackspaceApiKey != null) {
            localVarFormParams.put("rackspace_api_key", rackspaceApiKey);
        }

        if (rackspaceContainer != null) {
            localVarFormParams.put("rackspace_container", rackspaceContainer);
        }

        if (rackspaceRegion != null) {
            localVarFormParams.put("rackspace_region", rackspaceRegion);
        }

        if (rackspaceUsername != null) {
            localVarFormParams.put("rackspace_username", rackspaceUsername);
        }

        if (resetAuthentication != null) {
            localVarFormParams.put("reset_authentication", resetAuthentication);
        }

        if (s3Bucket != null) {
            localVarFormParams.put("s3_bucket", s3Bucket);
        }

        if (s3CompatibleAccessKey != null) {
            localVarFormParams.put("s3_compatible_access_key", s3CompatibleAccessKey);
        }

        if (s3CompatibleBucket != null) {
            localVarFormParams.put("s3_compatible_bucket", s3CompatibleBucket);
        }

        if (s3CompatibleEndpoint != null) {
            localVarFormParams.put("s3_compatible_endpoint", s3CompatibleEndpoint);
        }

        if (s3CompatibleRegion != null) {
            localVarFormParams.put("s3_compatible_region", s3CompatibleRegion);
        }

        if (s3CompatibleSecretKey != null) {
            localVarFormParams.put("s3_compatible_secret_key", s3CompatibleSecretKey);
        }

        if (s3Region != null) {
            localVarFormParams.put("s3_region", s3Region);
        }

        if (serverCertificate != null) {
            localVarFormParams.put("server_certificate", serverCertificate);
        }

        if (serverHostKey != null) {
            localVarFormParams.put("server_host_key", serverHostKey);
        }

        if (serverType != null) {
            localVarFormParams.put("server_type", serverType);
        }

        if (ssl != null) {
            localVarFormParams.put("ssl", ssl);
        }

        if (sslCertificate != null) {
            localVarFormParams.put("ssl_certificate", sslCertificate);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        if (wasabiAccessKey != null) {
            localVarFormParams.put("wasabi_access_key", wasabiAccessKey);
        }

        if (wasabiBucket != null) {
            localVarFormParams.put("wasabi_bucket", wasabiBucket);
        }

        if (wasabiRegion != null) {
            localVarFormParams.put("wasabi_region", wasabiRegion);
        }

        if (wasabiSecretKey != null) {
            localVarFormParams.put("wasabi_secret_key", wasabiSecretKey);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postRemoteServersValidateBeforeCall(String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey, final ApiCallback _callback) throws ApiException {
        return postRemoteServersCall(awsAccessKey, awsSecretKey, azureBlobStorageAccessKey, azureBlobStorageAccount, azureBlobStorageContainer, azureBlobStorageSasToken, azureFilesStorageAccessKey, azureFilesStorageAccount, azureFilesStorageSasToken, azureFilesStorageShareName, backblazeB2ApplicationKey, backblazeB2Bucket, backblazeB2KeyId, backblazeB2S3Endpoint, enableDedicatedIps, filebaseAccessKey, filebaseBucket, filebaseSecretKey, filesAgentPermissionSet, filesAgentRoot, googleCloudStorageBucket, googleCloudStorageCredentialsJson, googleCloudStorageProjectId, hostname, maxConnections, name, oneDriveAccountType, password, pinToSiteRegion, port, privateKey, privateKeyPassphrase, rackspaceApiKey, rackspaceContainer, rackspaceRegion, rackspaceUsername, resetAuthentication, s3Bucket, s3CompatibleAccessKey, s3CompatibleBucket, s3CompatibleEndpoint, s3CompatibleRegion, s3CompatibleSecretKey, s3Region, serverCertificate, serverHostKey, serverType, ssl, sslCertificate, username, wasabiAccessKey, wasabiBucket, wasabiRegion, wasabiSecretKey, _callback);

    }

    /**
     * Create Remote Server
     * Create Remote Server
     * @param awsAccessKey AWS Access Key. (optional)
     * @param awsSecretKey AWS secret key. (optional)
     * @param azureBlobStorageAccessKey Azure Blob Storage secret key. (optional)
     * @param azureBlobStorageAccount Azure Blob Storage Account name (optional)
     * @param azureBlobStorageContainer Azure Blob Storage Container name (optional)
     * @param azureBlobStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageAccessKey Azure File Storage access key. (optional)
     * @param azureFilesStorageAccount Azure File Storage Account name (optional)
     * @param azureFilesStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageShareName Azure File Storage Share name (optional)
     * @param backblazeB2ApplicationKey Backblaze B2 Cloud Storage applicationKey. (optional)
     * @param backblazeB2Bucket Backblaze B2 Cloud Storage Bucket name (optional)
     * @param backblazeB2KeyId Backblaze B2 Cloud Storage keyID. (optional)
     * @param backblazeB2S3Endpoint Backblaze B2 Cloud Storage S3 Endpoint (optional)
     * @param enableDedicatedIps &#x60;true&#x60; if remote server only accepts connections from dedicated IPs (optional)
     * @param filebaseAccessKey Filebase Access Key. (optional)
     * @param filebaseBucket Filebase Bucket name (optional)
     * @param filebaseSecretKey Filebase secret key (optional)
     * @param filesAgentPermissionSet Local permissions for files agent. read_only, write_only, or read_write (optional)
     * @param filesAgentRoot Agent local root path (optional)
     * @param googleCloudStorageBucket Google Cloud Storage bucket name (optional)
     * @param googleCloudStorageCredentialsJson A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey (optional)
     * @param googleCloudStorageProjectId Google Cloud Project ID (optional)
     * @param hostname Hostname or IP address (optional)
     * @param maxConnections Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible). (optional)
     * @param name Internal name for your reference (optional)
     * @param oneDriveAccountType Either personal or business_other account types (optional)
     * @param password Password if needed. (optional)
     * @param pinToSiteRegion If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true. (optional)
     * @param port Port for remote server.  Not needed for S3. (optional)
     * @param privateKey Private key if needed. (optional)
     * @param privateKeyPassphrase Passphrase for private key if needed. (optional)
     * @param rackspaceApiKey Rackspace API key from the Rackspace Cloud Control Panel. (optional)
     * @param rackspaceContainer The name of the container (top level directory) where files will sync. (optional)
     * @param rackspaceRegion Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/ (optional)
     * @param rackspaceUsername Rackspace username used to login to the Rackspace Cloud Control Panel. (optional)
     * @param resetAuthentication Reset authenticated account (optional)
     * @param s3Bucket S3 bucket name (optional)
     * @param s3CompatibleAccessKey S3-compatible Access Key. (optional)
     * @param s3CompatibleBucket S3-compatible Bucket name (optional)
     * @param s3CompatibleEndpoint S3-compatible endpoint (optional)
     * @param s3CompatibleRegion S3-compatible endpoint (optional)
     * @param s3CompatibleSecretKey S3-compatible secret key (optional)
     * @param s3Region S3 region (optional)
     * @param serverCertificate Remote server certificate (optional)
     * @param serverHostKey Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts (optional)
     * @param serverType Remote server type. (optional)
     * @param ssl Should we require SSL? (optional)
     * @param sslCertificate SSL client certificate. (optional)
     * @param username Remote server username.  Not needed for S3 buckets. (optional)
     * @param wasabiAccessKey Wasabi access key. (optional)
     * @param wasabiBucket Wasabi Bucket name (optional)
     * @param wasabiRegion Wasabi region (optional)
     * @param wasabiSecretKey Wasabi secret key. (optional)
     * @return RemoteServerEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public RemoteServerEntity postRemoteServers(String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey) throws ApiException {
        ApiResponse<RemoteServerEntity> localVarResp = postRemoteServersWithHttpInfo(awsAccessKey, awsSecretKey, azureBlobStorageAccessKey, azureBlobStorageAccount, azureBlobStorageContainer, azureBlobStorageSasToken, azureFilesStorageAccessKey, azureFilesStorageAccount, azureFilesStorageSasToken, azureFilesStorageShareName, backblazeB2ApplicationKey, backblazeB2Bucket, backblazeB2KeyId, backblazeB2S3Endpoint, enableDedicatedIps, filebaseAccessKey, filebaseBucket, filebaseSecretKey, filesAgentPermissionSet, filesAgentRoot, googleCloudStorageBucket, googleCloudStorageCredentialsJson, googleCloudStorageProjectId, hostname, maxConnections, name, oneDriveAccountType, password, pinToSiteRegion, port, privateKey, privateKeyPassphrase, rackspaceApiKey, rackspaceContainer, rackspaceRegion, rackspaceUsername, resetAuthentication, s3Bucket, s3CompatibleAccessKey, s3CompatibleBucket, s3CompatibleEndpoint, s3CompatibleRegion, s3CompatibleSecretKey, s3Region, serverCertificate, serverHostKey, serverType, ssl, sslCertificate, username, wasabiAccessKey, wasabiBucket, wasabiRegion, wasabiSecretKey);
        return localVarResp.getData();
    }

    /**
     * Create Remote Server
     * Create Remote Server
     * @param awsAccessKey AWS Access Key. (optional)
     * @param awsSecretKey AWS secret key. (optional)
     * @param azureBlobStorageAccessKey Azure Blob Storage secret key. (optional)
     * @param azureBlobStorageAccount Azure Blob Storage Account name (optional)
     * @param azureBlobStorageContainer Azure Blob Storage Container name (optional)
     * @param azureBlobStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageAccessKey Azure File Storage access key. (optional)
     * @param azureFilesStorageAccount Azure File Storage Account name (optional)
     * @param azureFilesStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageShareName Azure File Storage Share name (optional)
     * @param backblazeB2ApplicationKey Backblaze B2 Cloud Storage applicationKey. (optional)
     * @param backblazeB2Bucket Backblaze B2 Cloud Storage Bucket name (optional)
     * @param backblazeB2KeyId Backblaze B2 Cloud Storage keyID. (optional)
     * @param backblazeB2S3Endpoint Backblaze B2 Cloud Storage S3 Endpoint (optional)
     * @param enableDedicatedIps &#x60;true&#x60; if remote server only accepts connections from dedicated IPs (optional)
     * @param filebaseAccessKey Filebase Access Key. (optional)
     * @param filebaseBucket Filebase Bucket name (optional)
     * @param filebaseSecretKey Filebase secret key (optional)
     * @param filesAgentPermissionSet Local permissions for files agent. read_only, write_only, or read_write (optional)
     * @param filesAgentRoot Agent local root path (optional)
     * @param googleCloudStorageBucket Google Cloud Storage bucket name (optional)
     * @param googleCloudStorageCredentialsJson A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey (optional)
     * @param googleCloudStorageProjectId Google Cloud Project ID (optional)
     * @param hostname Hostname or IP address (optional)
     * @param maxConnections Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible). (optional)
     * @param name Internal name for your reference (optional)
     * @param oneDriveAccountType Either personal or business_other account types (optional)
     * @param password Password if needed. (optional)
     * @param pinToSiteRegion If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true. (optional)
     * @param port Port for remote server.  Not needed for S3. (optional)
     * @param privateKey Private key if needed. (optional)
     * @param privateKeyPassphrase Passphrase for private key if needed. (optional)
     * @param rackspaceApiKey Rackspace API key from the Rackspace Cloud Control Panel. (optional)
     * @param rackspaceContainer The name of the container (top level directory) where files will sync. (optional)
     * @param rackspaceRegion Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/ (optional)
     * @param rackspaceUsername Rackspace username used to login to the Rackspace Cloud Control Panel. (optional)
     * @param resetAuthentication Reset authenticated account (optional)
     * @param s3Bucket S3 bucket name (optional)
     * @param s3CompatibleAccessKey S3-compatible Access Key. (optional)
     * @param s3CompatibleBucket S3-compatible Bucket name (optional)
     * @param s3CompatibleEndpoint S3-compatible endpoint (optional)
     * @param s3CompatibleRegion S3-compatible endpoint (optional)
     * @param s3CompatibleSecretKey S3-compatible secret key (optional)
     * @param s3Region S3 region (optional)
     * @param serverCertificate Remote server certificate (optional)
     * @param serverHostKey Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts (optional)
     * @param serverType Remote server type. (optional)
     * @param ssl Should we require SSL? (optional)
     * @param sslCertificate SSL client certificate. (optional)
     * @param username Remote server username.  Not needed for S3 buckets. (optional)
     * @param wasabiAccessKey Wasabi access key. (optional)
     * @param wasabiBucket Wasabi Bucket name (optional)
     * @param wasabiRegion Wasabi region (optional)
     * @param wasabiSecretKey Wasabi secret key. (optional)
     * @return ApiResponse&lt;RemoteServerEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RemoteServerEntity> postRemoteServersWithHttpInfo(String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey) throws ApiException {
        okhttp3.Call localVarCall = postRemoteServersValidateBeforeCall(awsAccessKey, awsSecretKey, azureBlobStorageAccessKey, azureBlobStorageAccount, azureBlobStorageContainer, azureBlobStorageSasToken, azureFilesStorageAccessKey, azureFilesStorageAccount, azureFilesStorageSasToken, azureFilesStorageShareName, backblazeB2ApplicationKey, backblazeB2Bucket, backblazeB2KeyId, backblazeB2S3Endpoint, enableDedicatedIps, filebaseAccessKey, filebaseBucket, filebaseSecretKey, filesAgentPermissionSet, filesAgentRoot, googleCloudStorageBucket, googleCloudStorageCredentialsJson, googleCloudStorageProjectId, hostname, maxConnections, name, oneDriveAccountType, password, pinToSiteRegion, port, privateKey, privateKeyPassphrase, rackspaceApiKey, rackspaceContainer, rackspaceRegion, rackspaceUsername, resetAuthentication, s3Bucket, s3CompatibleAccessKey, s3CompatibleBucket, s3CompatibleEndpoint, s3CompatibleRegion, s3CompatibleSecretKey, s3Region, serverCertificate, serverHostKey, serverType, ssl, sslCertificate, username, wasabiAccessKey, wasabiBucket, wasabiRegion, wasabiSecretKey, null);
        Type localVarReturnType = new TypeToken<RemoteServerEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Remote Server (asynchronously)
     * Create Remote Server
     * @param awsAccessKey AWS Access Key. (optional)
     * @param awsSecretKey AWS secret key. (optional)
     * @param azureBlobStorageAccessKey Azure Blob Storage secret key. (optional)
     * @param azureBlobStorageAccount Azure Blob Storage Account name (optional)
     * @param azureBlobStorageContainer Azure Blob Storage Container name (optional)
     * @param azureBlobStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageAccessKey Azure File Storage access key. (optional)
     * @param azureFilesStorageAccount Azure File Storage Account name (optional)
     * @param azureFilesStorageSasToken Shared Access Signature (SAS) token (optional)
     * @param azureFilesStorageShareName Azure File Storage Share name (optional)
     * @param backblazeB2ApplicationKey Backblaze B2 Cloud Storage applicationKey. (optional)
     * @param backblazeB2Bucket Backblaze B2 Cloud Storage Bucket name (optional)
     * @param backblazeB2KeyId Backblaze B2 Cloud Storage keyID. (optional)
     * @param backblazeB2S3Endpoint Backblaze B2 Cloud Storage S3 Endpoint (optional)
     * @param enableDedicatedIps &#x60;true&#x60; if remote server only accepts connections from dedicated IPs (optional)
     * @param filebaseAccessKey Filebase Access Key. (optional)
     * @param filebaseBucket Filebase Bucket name (optional)
     * @param filebaseSecretKey Filebase secret key (optional)
     * @param filesAgentPermissionSet Local permissions for files agent. read_only, write_only, or read_write (optional)
     * @param filesAgentRoot Agent local root path (optional)
     * @param googleCloudStorageBucket Google Cloud Storage bucket name (optional)
     * @param googleCloudStorageCredentialsJson A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey (optional)
     * @param googleCloudStorageProjectId Google Cloud Project ID (optional)
     * @param hostname Hostname or IP address (optional)
     * @param maxConnections Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible). (optional)
     * @param name Internal name for your reference (optional)
     * @param oneDriveAccountType Either personal or business_other account types (optional)
     * @param password Password if needed. (optional)
     * @param pinToSiteRegion If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true. (optional)
     * @param port Port for remote server.  Not needed for S3. (optional)
     * @param privateKey Private key if needed. (optional)
     * @param privateKeyPassphrase Passphrase for private key if needed. (optional)
     * @param rackspaceApiKey Rackspace API key from the Rackspace Cloud Control Panel. (optional)
     * @param rackspaceContainer The name of the container (top level directory) where files will sync. (optional)
     * @param rackspaceRegion Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/ (optional)
     * @param rackspaceUsername Rackspace username used to login to the Rackspace Cloud Control Panel. (optional)
     * @param resetAuthentication Reset authenticated account (optional)
     * @param s3Bucket S3 bucket name (optional)
     * @param s3CompatibleAccessKey S3-compatible Access Key. (optional)
     * @param s3CompatibleBucket S3-compatible Bucket name (optional)
     * @param s3CompatibleEndpoint S3-compatible endpoint (optional)
     * @param s3CompatibleRegion S3-compatible endpoint (optional)
     * @param s3CompatibleSecretKey S3-compatible secret key (optional)
     * @param s3Region S3 region (optional)
     * @param serverCertificate Remote server certificate (optional)
     * @param serverHostKey Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts (optional)
     * @param serverType Remote server type. (optional)
     * @param ssl Should we require SSL? (optional)
     * @param sslCertificate SSL client certificate. (optional)
     * @param username Remote server username.  Not needed for S3 buckets. (optional)
     * @param wasabiAccessKey Wasabi access key. (optional)
     * @param wasabiBucket Wasabi Bucket name (optional)
     * @param wasabiRegion Wasabi region (optional)
     * @param wasabiSecretKey Wasabi secret key. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postRemoteServersAsync(String awsAccessKey, String awsSecretKey, String azureBlobStorageAccessKey, String azureBlobStorageAccount, String azureBlobStorageContainer, String azureBlobStorageSasToken, String azureFilesStorageAccessKey, String azureFilesStorageAccount, String azureFilesStorageSasToken, String azureFilesStorageShareName, String backblazeB2ApplicationKey, String backblazeB2Bucket, String backblazeB2KeyId, String backblazeB2S3Endpoint, Boolean enableDedicatedIps, String filebaseAccessKey, String filebaseBucket, String filebaseSecretKey, String filesAgentPermissionSet, String filesAgentRoot, String googleCloudStorageBucket, String googleCloudStorageCredentialsJson, String googleCloudStorageProjectId, String hostname, Integer maxConnections, String name, String oneDriveAccountType, String password, Boolean pinToSiteRegion, Integer port, String privateKey, String privateKeyPassphrase, String rackspaceApiKey, String rackspaceContainer, String rackspaceRegion, String rackspaceUsername, Boolean resetAuthentication, String s3Bucket, String s3CompatibleAccessKey, String s3CompatibleBucket, String s3CompatibleEndpoint, String s3CompatibleRegion, String s3CompatibleSecretKey, String s3Region, String serverCertificate, String serverHostKey, String serverType, String ssl, String sslCertificate, String username, String wasabiAccessKey, String wasabiBucket, String wasabiRegion, String wasabiSecretKey, final ApiCallback<RemoteServerEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postRemoteServersValidateBeforeCall(awsAccessKey, awsSecretKey, azureBlobStorageAccessKey, azureBlobStorageAccount, azureBlobStorageContainer, azureBlobStorageSasToken, azureFilesStorageAccessKey, azureFilesStorageAccount, azureFilesStorageSasToken, azureFilesStorageShareName, backblazeB2ApplicationKey, backblazeB2Bucket, backblazeB2KeyId, backblazeB2S3Endpoint, enableDedicatedIps, filebaseAccessKey, filebaseBucket, filebaseSecretKey, filesAgentPermissionSet, filesAgentRoot, googleCloudStorageBucket, googleCloudStorageCredentialsJson, googleCloudStorageProjectId, hostname, maxConnections, name, oneDriveAccountType, password, pinToSiteRegion, port, privateKey, privateKeyPassphrase, rackspaceApiKey, rackspaceContainer, rackspaceRegion, rackspaceUsername, resetAuthentication, s3Bucket, s3CompatibleAccessKey, s3CompatibleBucket, s3CompatibleEndpoint, s3CompatibleRegion, s3CompatibleSecretKey, s3Region, serverCertificate, serverHostKey, serverType, ssl, sslCertificate, username, wasabiAccessKey, wasabiBucket, wasabiRegion, wasabiSecretKey, _callback);
        Type localVarReturnType = new TypeToken<RemoteServerEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postRemoteServersIdConfigurationFile
     * @param id Remote Server ID. (required)
     * @param apiToken Files Agent API Token (optional)
     * @param configVersion agent config version (optional)
     * @param hostname  (optional)
     * @param permissionSet  (optional)
     * @param port Incoming port for files agent connections (optional)
     * @param privateKey private key (optional)
     * @param publicKey public key (optional)
     * @param root Agent local root path (optional)
     * @param serverHostKey  (optional)
     * @param status either running or shutdown (optional)
     * @param subdomain  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postRemoteServersIdConfigurationFileCall(Integer id, String apiToken, String configVersion, String hostname, String permissionSet, Integer port, String privateKey, String publicKey, String root, String serverHostKey, String status, String subdomain, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/remote_servers/{id}/configuration_file"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiToken != null) {
            localVarFormParams.put("api_token", apiToken);
        }

        if (configVersion != null) {
            localVarFormParams.put("config_version", configVersion);
        }

        if (hostname != null) {
            localVarFormParams.put("hostname", hostname);
        }

        if (permissionSet != null) {
            localVarFormParams.put("permission_set", permissionSet);
        }

        if (port != null) {
            localVarFormParams.put("port", port);
        }

        if (privateKey != null) {
            localVarFormParams.put("private_key", privateKey);
        }

        if (publicKey != null) {
            localVarFormParams.put("public_key", publicKey);
        }

        if (root != null) {
            localVarFormParams.put("root", root);
        }

        if (serverHostKey != null) {
            localVarFormParams.put("server_host_key", serverHostKey);
        }

        if (status != null) {
            localVarFormParams.put("status", status);
        }

        if (subdomain != null) {
            localVarFormParams.put("subdomain", subdomain);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postRemoteServersIdConfigurationFileValidateBeforeCall(Integer id, String apiToken, String configVersion, String hostname, String permissionSet, Integer port, String privateKey, String publicKey, String root, String serverHostKey, String status, String subdomain, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling postRemoteServersIdConfigurationFile(Async)");
        }

        return postRemoteServersIdConfigurationFileCall(id, apiToken, configVersion, hostname, permissionSet, port, privateKey, publicKey, root, serverHostKey, status, subdomain, _callback);

    }

    /**
     * Post local changes, check in, and download configuration file (used by some Remote Server integrations, such as the Files.com Agent)
     * Post local changes, check in, and download configuration file (used by some Remote Server integrations, such as the Files.com Agent)
     * @param id Remote Server ID. (required)
     * @param apiToken Files Agent API Token (optional)
     * @param configVersion agent config version (optional)
     * @param hostname  (optional)
     * @param permissionSet  (optional)
     * @param port Incoming port for files agent connections (optional)
     * @param privateKey private key (optional)
     * @param publicKey public key (optional)
     * @param root Agent local root path (optional)
     * @param serverHostKey  (optional)
     * @param status either running or shutdown (optional)
     * @param subdomain  (optional)
     * @return RemoteServerConfigurationFileEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public RemoteServerConfigurationFileEntity postRemoteServersIdConfigurationFile(Integer id, String apiToken, String configVersion, String hostname, String permissionSet, Integer port, String privateKey, String publicKey, String root, String serverHostKey, String status, String subdomain) throws ApiException {
        ApiResponse<RemoteServerConfigurationFileEntity> localVarResp = postRemoteServersIdConfigurationFileWithHttpInfo(id, apiToken, configVersion, hostname, permissionSet, port, privateKey, publicKey, root, serverHostKey, status, subdomain);
        return localVarResp.getData();
    }

    /**
     * Post local changes, check in, and download configuration file (used by some Remote Server integrations, such as the Files.com Agent)
     * Post local changes, check in, and download configuration file (used by some Remote Server integrations, such as the Files.com Agent)
     * @param id Remote Server ID. (required)
     * @param apiToken Files Agent API Token (optional)
     * @param configVersion agent config version (optional)
     * @param hostname  (optional)
     * @param permissionSet  (optional)
     * @param port Incoming port for files agent connections (optional)
     * @param privateKey private key (optional)
     * @param publicKey public key (optional)
     * @param root Agent local root path (optional)
     * @param serverHostKey  (optional)
     * @param status either running or shutdown (optional)
     * @param subdomain  (optional)
     * @return ApiResponse&lt;RemoteServerConfigurationFileEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RemoteServerConfigurationFileEntity> postRemoteServersIdConfigurationFileWithHttpInfo(Integer id, String apiToken, String configVersion, String hostname, String permissionSet, Integer port, String privateKey, String publicKey, String root, String serverHostKey, String status, String subdomain) throws ApiException {
        okhttp3.Call localVarCall = postRemoteServersIdConfigurationFileValidateBeforeCall(id, apiToken, configVersion, hostname, permissionSet, port, privateKey, publicKey, root, serverHostKey, status, subdomain, null);
        Type localVarReturnType = new TypeToken<RemoteServerConfigurationFileEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Post local changes, check in, and download configuration file (used by some Remote Server integrations, such as the Files.com Agent) (asynchronously)
     * Post local changes, check in, and download configuration file (used by some Remote Server integrations, such as the Files.com Agent)
     * @param id Remote Server ID. (required)
     * @param apiToken Files Agent API Token (optional)
     * @param configVersion agent config version (optional)
     * @param hostname  (optional)
     * @param permissionSet  (optional)
     * @param port Incoming port for files agent connections (optional)
     * @param privateKey private key (optional)
     * @param publicKey public key (optional)
     * @param root Agent local root path (optional)
     * @param serverHostKey  (optional)
     * @param status either running or shutdown (optional)
     * @param subdomain  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The RemoteServers object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postRemoteServersIdConfigurationFileAsync(Integer id, String apiToken, String configVersion, String hostname, String permissionSet, Integer port, String privateKey, String publicKey, String root, String serverHostKey, String status, String subdomain, final ApiCallback<RemoteServerConfigurationFileEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postRemoteServersIdConfigurationFileValidateBeforeCall(id, apiToken, configVersion, hostname, permissionSet, port, privateKey, publicKey, root, serverHostKey, status, subdomain, _callback);
        Type localVarReturnType = new TypeToken<RemoteServerConfigurationFileEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
