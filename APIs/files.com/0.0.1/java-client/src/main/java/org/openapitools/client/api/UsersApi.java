/*
 * Files.com API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@files.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ApiKeyEntity;
import java.io.File;
import org.openapitools.client.model.GroupUserEntity;
import java.time.OffsetDateTime;
import org.openapitools.client.model.PermissionEntity;
import org.openapitools.client.model.PublicKeyEntity;
import org.openapitools.client.model.UserCipherUseEntity;
import org.openapitools.client.model.UserEntity;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UsersApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public UsersApi() {
        this(Configuration.getDefaultApiClient());
    }

    public UsersApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for deleteUsersId
     * @param id User ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteUsersIdCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteUsersIdValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteUsersId(Async)");
        }

        return deleteUsersIdCall(id, _callback);

    }

    /**
     * Delete User
     * Delete User
     * @param id User ID. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public void deleteUsersId(Integer id) throws ApiException {
        deleteUsersIdWithHttpInfo(id);
    }

    /**
     * Delete User
     * Delete User
     * @param id User ID. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteUsersIdWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = deleteUsersIdValidateBeforeCall(id, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete User (asynchronously)
     * Delete User
     * @param id User ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteUsersIdAsync(Integer id, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteUsersIdValidateBeforeCall(id, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getUsers
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[authenticate_until]&#x3D;desc&#x60;). Valid fields are &#x60;authenticate_until&#x60;, &#x60;active&#x60;, &#x60;email&#x60;, &#x60;last_desktop_login_at&#x60;, &#x60;last_login_at&#x60;, &#x60;username&#x60;, &#x60;company&#x60;, &#x60;name&#x60;, &#x60;site_admin&#x60;, &#x60;receive_admin_alerts&#x60;, &#x60;password_validity_days&#x60;, &#x60;ssl_required&#x60; or &#x60;not_site_admin&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;username&#x60;, &#x60;email&#x60;, &#x60;company&#x60;, &#x60;site_admin&#x60;, &#x60;password_validity_days&#x60;, &#x60;ssl_required&#x60;, &#x60;last_login_at&#x60;, &#x60;authenticate_until&#x60; or &#x60;not_site_admin&#x60;. Valid field combinations are &#x60;[ not_site_admin, username ]&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;username&#x60;, &#x60;email&#x60; or &#x60;company&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param ids comma-separated list of User IDs (optional)
     * @param qUsername List users matching username. (optional)
     * @param qEmail List users matching email. (optional)
     * @param qNotes List users matching notes field. (optional)
     * @param qAdmin If &#x60;true&#x60;, list only admin users. (optional)
     * @param qAllowedIps If set, list only users with overridden allowed IP setting. (optional)
     * @param qPasswordValidityDays If set, list only users with overridden password validity days setting. (optional)
     * @param qSslRequired If set, list only users with overridden SSL required setting. (optional)
     * @param search Searches for partial matches of name, username, or email. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Users objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersCall(String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterPrefix, Object filterLt, Object filterLteq, String ids, String qUsername, String qEmail, String qNotes, String qAdmin, String qAllowedIps, String qPasswordValidityDays, String qSslRequired, String search, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(sortBy));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filter));
        }

        if (filterGt != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterGt));
        }

        if (filterGteq != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterGteq));
        }

        if (filterPrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterPrefix));
        }

        if (filterLt != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterLt));
        }

        if (filterLteq != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterLteq));
        }

        if (ids != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ids", ids));
        }

        if (qUsername != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q[username]", qUsername));
        }

        if (qEmail != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q[email]", qEmail));
        }

        if (qNotes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q[notes]", qNotes));
        }

        if (qAdmin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q[admin]", qAdmin));
        }

        if (qAllowedIps != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q[allowed_ips]", qAllowedIps));
        }

        if (qPasswordValidityDays != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q[password_validity_days]", qPasswordValidityDays));
        }

        if (qSslRequired != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q[ssl_required]", qSslRequired));
        }

        if (search != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("search", search));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUsersValidateBeforeCall(String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterPrefix, Object filterLt, Object filterLteq, String ids, String qUsername, String qEmail, String qNotes, String qAdmin, String qAllowedIps, String qPasswordValidityDays, String qSslRequired, String search, final ApiCallback _callback) throws ApiException {
        return getUsersCall(cursor, perPage, sortBy, filter, filterGt, filterGteq, filterPrefix, filterLt, filterLteq, ids, qUsername, qEmail, qNotes, qAdmin, qAllowedIps, qPasswordValidityDays, qSslRequired, search, _callback);

    }

    /**
     * List Users
     * List Users
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[authenticate_until]&#x3D;desc&#x60;). Valid fields are &#x60;authenticate_until&#x60;, &#x60;active&#x60;, &#x60;email&#x60;, &#x60;last_desktop_login_at&#x60;, &#x60;last_login_at&#x60;, &#x60;username&#x60;, &#x60;company&#x60;, &#x60;name&#x60;, &#x60;site_admin&#x60;, &#x60;receive_admin_alerts&#x60;, &#x60;password_validity_days&#x60;, &#x60;ssl_required&#x60; or &#x60;not_site_admin&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;username&#x60;, &#x60;email&#x60;, &#x60;company&#x60;, &#x60;site_admin&#x60;, &#x60;password_validity_days&#x60;, &#x60;ssl_required&#x60;, &#x60;last_login_at&#x60;, &#x60;authenticate_until&#x60; or &#x60;not_site_admin&#x60;. Valid field combinations are &#x60;[ not_site_admin, username ]&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;username&#x60;, &#x60;email&#x60; or &#x60;company&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param ids comma-separated list of User IDs (optional)
     * @param qUsername List users matching username. (optional)
     * @param qEmail List users matching email. (optional)
     * @param qNotes List users matching notes field. (optional)
     * @param qAdmin If &#x60;true&#x60;, list only admin users. (optional)
     * @param qAllowedIps If set, list only users with overridden allowed IP setting. (optional)
     * @param qPasswordValidityDays If set, list only users with overridden password validity days setting. (optional)
     * @param qSslRequired If set, list only users with overridden SSL required setting. (optional)
     * @param search Searches for partial matches of name, username, or email. (optional)
     * @return List&lt;UserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Users objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<UserEntity> getUsers(String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterPrefix, Object filterLt, Object filterLteq, String ids, String qUsername, String qEmail, String qNotes, String qAdmin, String qAllowedIps, String qPasswordValidityDays, String qSslRequired, String search) throws ApiException {
        ApiResponse<List<UserEntity>> localVarResp = getUsersWithHttpInfo(cursor, perPage, sortBy, filter, filterGt, filterGteq, filterPrefix, filterLt, filterLteq, ids, qUsername, qEmail, qNotes, qAdmin, qAllowedIps, qPasswordValidityDays, qSslRequired, search);
        return localVarResp.getData();
    }

    /**
     * List Users
     * List Users
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[authenticate_until]&#x3D;desc&#x60;). Valid fields are &#x60;authenticate_until&#x60;, &#x60;active&#x60;, &#x60;email&#x60;, &#x60;last_desktop_login_at&#x60;, &#x60;last_login_at&#x60;, &#x60;username&#x60;, &#x60;company&#x60;, &#x60;name&#x60;, &#x60;site_admin&#x60;, &#x60;receive_admin_alerts&#x60;, &#x60;password_validity_days&#x60;, &#x60;ssl_required&#x60; or &#x60;not_site_admin&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;username&#x60;, &#x60;email&#x60;, &#x60;company&#x60;, &#x60;site_admin&#x60;, &#x60;password_validity_days&#x60;, &#x60;ssl_required&#x60;, &#x60;last_login_at&#x60;, &#x60;authenticate_until&#x60; or &#x60;not_site_admin&#x60;. Valid field combinations are &#x60;[ not_site_admin, username ]&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;username&#x60;, &#x60;email&#x60; or &#x60;company&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param ids comma-separated list of User IDs (optional)
     * @param qUsername List users matching username. (optional)
     * @param qEmail List users matching email. (optional)
     * @param qNotes List users matching notes field. (optional)
     * @param qAdmin If &#x60;true&#x60;, list only admin users. (optional)
     * @param qAllowedIps If set, list only users with overridden allowed IP setting. (optional)
     * @param qPasswordValidityDays If set, list only users with overridden password validity days setting. (optional)
     * @param qSslRequired If set, list only users with overridden SSL required setting. (optional)
     * @param search Searches for partial matches of name, username, or email. (optional)
     * @return ApiResponse&lt;List&lt;UserEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Users objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<UserEntity>> getUsersWithHttpInfo(String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterPrefix, Object filterLt, Object filterLteq, String ids, String qUsername, String qEmail, String qNotes, String qAdmin, String qAllowedIps, String qPasswordValidityDays, String qSslRequired, String search) throws ApiException {
        okhttp3.Call localVarCall = getUsersValidateBeforeCall(cursor, perPage, sortBy, filter, filterGt, filterGteq, filterPrefix, filterLt, filterLteq, ids, qUsername, qEmail, qNotes, qAdmin, qAllowedIps, qPasswordValidityDays, qSslRequired, search, null);
        Type localVarReturnType = new TypeToken<List<UserEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Users (asynchronously)
     * List Users
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[authenticate_until]&#x3D;desc&#x60;). Valid fields are &#x60;authenticate_until&#x60;, &#x60;active&#x60;, &#x60;email&#x60;, &#x60;last_desktop_login_at&#x60;, &#x60;last_login_at&#x60;, &#x60;username&#x60;, &#x60;company&#x60;, &#x60;name&#x60;, &#x60;site_admin&#x60;, &#x60;receive_admin_alerts&#x60;, &#x60;password_validity_days&#x60;, &#x60;ssl_required&#x60; or &#x60;not_site_admin&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;username&#x60;, &#x60;email&#x60;, &#x60;company&#x60;, &#x60;site_admin&#x60;, &#x60;password_validity_days&#x60;, &#x60;ssl_required&#x60;, &#x60;last_login_at&#x60;, &#x60;authenticate_until&#x60; or &#x60;not_site_admin&#x60;. Valid field combinations are &#x60;[ not_site_admin, username ]&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;username&#x60;, &#x60;email&#x60; or &#x60;company&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;password_validity_days&#x60;, &#x60;last_login_at&#x60; or &#x60;authenticate_until&#x60;. (optional)
     * @param ids comma-separated list of User IDs (optional)
     * @param qUsername List users matching username. (optional)
     * @param qEmail List users matching email. (optional)
     * @param qNotes List users matching notes field. (optional)
     * @param qAdmin If &#x60;true&#x60;, list only admin users. (optional)
     * @param qAllowedIps If set, list only users with overridden allowed IP setting. (optional)
     * @param qPasswordValidityDays If set, list only users with overridden password validity days setting. (optional)
     * @param qSslRequired If set, list only users with overridden SSL required setting. (optional)
     * @param search Searches for partial matches of name, username, or email. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Users objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersAsync(String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterPrefix, Object filterLt, Object filterLteq, String ids, String qUsername, String qEmail, String qNotes, String qAdmin, String qAllowedIps, String qPasswordValidityDays, String qSslRequired, String search, final ApiCallback<List<UserEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUsersValidateBeforeCall(cursor, perPage, sortBy, filter, filterGt, filterGteq, filterPrefix, filterLt, filterLteq, ids, qUsername, qEmail, qNotes, qAdmin, qAllowedIps, qPasswordValidityDays, qSslRequired, search, _callback);
        Type localVarReturnType = new TypeToken<List<UserEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getUsersId
     * @param id User ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersIdCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUsersIdValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getUsersId(Async)");
        }

        return getUsersIdCall(id, _callback);

    }

    /**
     * Show User
     * Show User
     * @param id User ID. (required)
     * @return UserEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public UserEntity getUsersId(Integer id) throws ApiException {
        ApiResponse<UserEntity> localVarResp = getUsersIdWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Show User
     * Show User
     * @param id User ID. (required)
     * @return ApiResponse&lt;UserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UserEntity> getUsersIdWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = getUsersIdValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Show User (asynchronously)
     * Show User
     * @param id User ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersIdAsync(Integer id, final ApiCallback<UserEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUsersIdValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getUsersUserIdApiKeys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdApiKeysCall(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/api_keys"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(sortBy));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filter));
        }

        if (filterGt != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterGt));
        }

        if (filterGteq != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterGteq));
        }

        if (filterLt != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterLt));
        }

        if (filterLteq != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterLteq));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUsersUserIdApiKeysValidateBeforeCall(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getUsersUserIdApiKeys(Async)");
        }

        return getUsersUserIdApiKeysCall(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq, _callback);

    }

    /**
     * List Api Keys
     * List Api Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @return List&lt;ApiKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<ApiKeyEntity> getUsersUserIdApiKeys(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq) throws ApiException {
        ApiResponse<List<ApiKeyEntity>> localVarResp = getUsersUserIdApiKeysWithHttpInfo(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq);
        return localVarResp.getData();
    }

    /**
     * List Api Keys
     * List Api Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @return ApiResponse&lt;List&lt;ApiKeyEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ApiKeyEntity>> getUsersUserIdApiKeysWithHttpInfo(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq) throws ApiException {
        okhttp3.Call localVarCall = getUsersUserIdApiKeysValidateBeforeCall(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq, null);
        Type localVarReturnType = new TypeToken<List<ApiKeyEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Api Keys (asynchronously)
     * List Api Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdApiKeysAsync(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq, final ApiCallback<List<ApiKeyEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUsersUserIdApiKeysValidateBeforeCall(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq, _callback);
        Type localVarReturnType = new TypeToken<List<ApiKeyEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getUsersUserIdCipherUses
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of UserCipherUses objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdCipherUsesCall(Integer userId, String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/cipher_uses"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUsersUserIdCipherUsesValidateBeforeCall(Integer userId, String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getUsersUserIdCipherUses(Async)");
        }

        return getUsersUserIdCipherUsesCall(userId, cursor, perPage, _callback);

    }

    /**
     * List User Cipher Uses
     * List User Cipher Uses
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return List&lt;UserCipherUseEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of UserCipherUses objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<UserCipherUseEntity> getUsersUserIdCipherUses(Integer userId, String cursor, Integer perPage) throws ApiException {
        ApiResponse<List<UserCipherUseEntity>> localVarResp = getUsersUserIdCipherUsesWithHttpInfo(userId, cursor, perPage);
        return localVarResp.getData();
    }

    /**
     * List User Cipher Uses
     * List User Cipher Uses
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return ApiResponse&lt;List&lt;UserCipherUseEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of UserCipherUses objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<UserCipherUseEntity>> getUsersUserIdCipherUsesWithHttpInfo(Integer userId, String cursor, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = getUsersUserIdCipherUsesValidateBeforeCall(userId, cursor, perPage, null);
        Type localVarReturnType = new TypeToken<List<UserCipherUseEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List User Cipher Uses (asynchronously)
     * List User Cipher Uses
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of UserCipherUses objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdCipherUsesAsync(Integer userId, String cursor, Integer perPage, final ApiCallback<List<UserCipherUseEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUsersUserIdCipherUsesValidateBeforeCall(userId, cursor, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<UserCipherUseEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getUsersUserIdGroups
     * @param userId User ID.  If provided, will return group_users of this user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param groupId Group ID.  If provided, will return group_users of this group. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdGroupsCall(Integer userId, String cursor, Integer perPage, Integer groupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/groups"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUsersUserIdGroupsValidateBeforeCall(Integer userId, String cursor, Integer perPage, Integer groupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getUsersUserIdGroups(Async)");
        }

        return getUsersUserIdGroupsCall(userId, cursor, perPage, groupId, _callback);

    }

    /**
     * List Group Users
     * List Group Users
     * @param userId User ID.  If provided, will return group_users of this user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param groupId Group ID.  If provided, will return group_users of this group. (optional)
     * @return List&lt;GroupUserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<GroupUserEntity> getUsersUserIdGroups(Integer userId, String cursor, Integer perPage, Integer groupId) throws ApiException {
        ApiResponse<List<GroupUserEntity>> localVarResp = getUsersUserIdGroupsWithHttpInfo(userId, cursor, perPage, groupId);
        return localVarResp.getData();
    }

    /**
     * List Group Users
     * List Group Users
     * @param userId User ID.  If provided, will return group_users of this user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param groupId Group ID.  If provided, will return group_users of this group. (optional)
     * @return ApiResponse&lt;List&lt;GroupUserEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<GroupUserEntity>> getUsersUserIdGroupsWithHttpInfo(Integer userId, String cursor, Integer perPage, Integer groupId) throws ApiException {
        okhttp3.Call localVarCall = getUsersUserIdGroupsValidateBeforeCall(userId, cursor, perPage, groupId, null);
        Type localVarReturnType = new TypeToken<List<GroupUserEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Group Users (asynchronously)
     * List Group Users
     * @param userId User ID.  If provided, will return group_users of this user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param groupId Group ID.  If provided, will return group_users of this group. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of GroupUsers objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdGroupsAsync(Integer userId, String cursor, Integer perPage, Integer groupId, final ApiCallback<List<GroupUserEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUsersUserIdGroupsValidateBeforeCall(userId, cursor, perPage, groupId, _callback);
        Type localVarReturnType = new TypeToken<List<GroupUserEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getUsersUserIdPermissions
     * @param userId DEPRECATED: User ID.  If provided, will scope permissions to this user. Use &#x60;filter[user_id]&#x60; instead.&#x60; (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[group_id]&#x3D;desc&#x60;). Valid fields are &#x60;group_id&#x60;, &#x60;path&#x60;, &#x60;user_id&#x60; or &#x60;permission&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;group_id&#x60;, &#x60;user_id&#x60; or &#x60;path&#x60;. Valid field combinations are &#x60;[ group_id, path ]&#x60; and &#x60;[ user_id, path ]&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;path&#x60;. (optional)
     * @param path DEPRECATED: Permission path.  If provided, will scope permissions to this path. Use &#x60;filter[path]&#x60; instead. (optional)
     * @param groupId DEPRECATED: Group ID.  If provided, will scope permissions to this group. Use &#x60;filter[group_id]&#x60; instead.&#x60; (optional)
     * @param includeGroups If searching by user or group, also include user&#39;s permissions that are inherited from its groups? (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Permissions objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdPermissionsCall(String userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String groupId, Boolean includeGroups, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/permissions"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(sortBy));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filter));
        }

        if (filterPrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterPrefix));
        }

        if (path != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("path", path));
        }

        if (groupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("group_id", groupId));
        }

        if (includeGroups != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_groups", includeGroups));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUsersUserIdPermissionsValidateBeforeCall(String userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String groupId, Boolean includeGroups, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getUsersUserIdPermissions(Async)");
        }

        return getUsersUserIdPermissionsCall(userId, cursor, perPage, sortBy, filter, filterPrefix, path, groupId, includeGroups, _callback);

    }

    /**
     * List Permissions
     * List Permissions
     * @param userId DEPRECATED: User ID.  If provided, will scope permissions to this user. Use &#x60;filter[user_id]&#x60; instead.&#x60; (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[group_id]&#x3D;desc&#x60;). Valid fields are &#x60;group_id&#x60;, &#x60;path&#x60;, &#x60;user_id&#x60; or &#x60;permission&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;group_id&#x60;, &#x60;user_id&#x60; or &#x60;path&#x60;. Valid field combinations are &#x60;[ group_id, path ]&#x60; and &#x60;[ user_id, path ]&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;path&#x60;. (optional)
     * @param path DEPRECATED: Permission path.  If provided, will scope permissions to this path. Use &#x60;filter[path]&#x60; instead. (optional)
     * @param groupId DEPRECATED: Group ID.  If provided, will scope permissions to this group. Use &#x60;filter[group_id]&#x60; instead.&#x60; (optional)
     * @param includeGroups If searching by user or group, also include user&#39;s permissions that are inherited from its groups? (optional)
     * @return List&lt;PermissionEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Permissions objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<PermissionEntity> getUsersUserIdPermissions(String userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String groupId, Boolean includeGroups) throws ApiException {
        ApiResponse<List<PermissionEntity>> localVarResp = getUsersUserIdPermissionsWithHttpInfo(userId, cursor, perPage, sortBy, filter, filterPrefix, path, groupId, includeGroups);
        return localVarResp.getData();
    }

    /**
     * List Permissions
     * List Permissions
     * @param userId DEPRECATED: User ID.  If provided, will scope permissions to this user. Use &#x60;filter[user_id]&#x60; instead.&#x60; (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[group_id]&#x3D;desc&#x60;). Valid fields are &#x60;group_id&#x60;, &#x60;path&#x60;, &#x60;user_id&#x60; or &#x60;permission&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;group_id&#x60;, &#x60;user_id&#x60; or &#x60;path&#x60;. Valid field combinations are &#x60;[ group_id, path ]&#x60; and &#x60;[ user_id, path ]&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;path&#x60;. (optional)
     * @param path DEPRECATED: Permission path.  If provided, will scope permissions to this path. Use &#x60;filter[path]&#x60; instead. (optional)
     * @param groupId DEPRECATED: Group ID.  If provided, will scope permissions to this group. Use &#x60;filter[group_id]&#x60; instead.&#x60; (optional)
     * @param includeGroups If searching by user or group, also include user&#39;s permissions that are inherited from its groups? (optional)
     * @return ApiResponse&lt;List&lt;PermissionEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Permissions objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<PermissionEntity>> getUsersUserIdPermissionsWithHttpInfo(String userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String groupId, Boolean includeGroups) throws ApiException {
        okhttp3.Call localVarCall = getUsersUserIdPermissionsValidateBeforeCall(userId, cursor, perPage, sortBy, filter, filterPrefix, path, groupId, includeGroups, null);
        Type localVarReturnType = new TypeToken<List<PermissionEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Permissions (asynchronously)
     * List Permissions
     * @param userId DEPRECATED: User ID.  If provided, will scope permissions to this user. Use &#x60;filter[user_id]&#x60; instead.&#x60; (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[group_id]&#x3D;desc&#x60;). Valid fields are &#x60;group_id&#x60;, &#x60;path&#x60;, &#x60;user_id&#x60; or &#x60;permission&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;group_id&#x60;, &#x60;user_id&#x60; or &#x60;path&#x60;. Valid field combinations are &#x60;[ group_id, path ]&#x60; and &#x60;[ user_id, path ]&#x60;. (optional)
     * @param filterPrefix If set, return records where the specified field is prefixed by the supplied value. Valid fields are &#x60;path&#x60;. (optional)
     * @param path DEPRECATED: Permission path.  If provided, will scope permissions to this path. Use &#x60;filter[path]&#x60; instead. (optional)
     * @param groupId DEPRECATED: Group ID.  If provided, will scope permissions to this group. Use &#x60;filter[group_id]&#x60; instead.&#x60; (optional)
     * @param includeGroups If searching by user or group, also include user&#39;s permissions that are inherited from its groups? (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of Permissions objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdPermissionsAsync(String userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterPrefix, String path, String groupId, Boolean includeGroups, final ApiCallback<List<PermissionEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUsersUserIdPermissionsValidateBeforeCall(userId, cursor, perPage, sortBy, filter, filterPrefix, path, groupId, includeGroups, _callback);
        Type localVarReturnType = new TypeToken<List<PermissionEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getUsersUserIdPublicKeys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of PublicKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdPublicKeysCall(Integer userId, String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/public_keys"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUsersUserIdPublicKeysValidateBeforeCall(Integer userId, String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling getUsersUserIdPublicKeys(Async)");
        }

        return getUsersUserIdPublicKeysCall(userId, cursor, perPage, _callback);

    }

    /**
     * List Public Keys
     * List Public Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return List&lt;PublicKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of PublicKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<PublicKeyEntity> getUsersUserIdPublicKeys(Integer userId, String cursor, Integer perPage) throws ApiException {
        ApiResponse<List<PublicKeyEntity>> localVarResp = getUsersUserIdPublicKeysWithHttpInfo(userId, cursor, perPage);
        return localVarResp.getData();
    }

    /**
     * List Public Keys
     * List Public Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return ApiResponse&lt;List&lt;PublicKeyEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of PublicKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<PublicKeyEntity>> getUsersUserIdPublicKeysWithHttpInfo(Integer userId, String cursor, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = getUsersUserIdPublicKeysValidateBeforeCall(userId, cursor, perPage, null);
        Type localVarReturnType = new TypeToken<List<PublicKeyEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Public Keys (asynchronously)
     * List Public Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of PublicKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getUsersUserIdPublicKeysAsync(Integer userId, String cursor, Integer perPage, final ApiCallback<List<PublicKeyEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUsersUserIdPublicKeysValidateBeforeCall(userId, cursor, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<PublicKeyEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for patchUsersId
     * @param id User ID. (required)
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchUsersIdCall(Integer id, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (allowedIps != null) {
            localVarFormParams.put("allowed_ips", allowedIps);
        }

        if (announcementsRead != null) {
            localVarFormParams.put("announcements_read", announcementsRead);
        }

        if (attachmentsPermission != null) {
            localVarFormParams.put("attachments_permission", attachmentsPermission);
        }

        if (authenticateUntil != null) {
            localVarFormParams.put("authenticate_until", authenticateUntil);
        }

        if (authenticationMethod != null) {
            localVarFormParams.put("authentication_method", authenticationMethod);
        }

        if (avatarDelete != null) {
            localVarFormParams.put("avatar_delete", avatarDelete);
        }

        if (avatarFile != null) {
            localVarFormParams.put("avatar_file", avatarFile);
        }

        if (billingPermission != null) {
            localVarFormParams.put("billing_permission", billingPermission);
        }

        if (bypassInactiveDisable != null) {
            localVarFormParams.put("bypass_inactive_disable", bypassInactiveDisable);
        }

        if (bypassSiteAllowedIps != null) {
            localVarFormParams.put("bypass_site_allowed_ips", bypassSiteAllowedIps);
        }

        if (changePassword != null) {
            localVarFormParams.put("change_password", changePassword);
        }

        if (changePasswordConfirmation != null) {
            localVarFormParams.put("change_password_confirmation", changePasswordConfirmation);
        }

        if (company != null) {
            localVarFormParams.put("company", company);
        }

        if (davPermission != null) {
            localVarFormParams.put("dav_permission", davPermission);
        }

        if (disabled != null) {
            localVarFormParams.put("disabled", disabled);
        }

        if (email != null) {
            localVarFormParams.put("email", email);
        }

        if (ftpPermission != null) {
            localVarFormParams.put("ftp_permission", ftpPermission);
        }

        if (grantPermission != null) {
            localVarFormParams.put("grant_permission", grantPermission);
        }

        if (groupId != null) {
            localVarFormParams.put("group_id", groupId);
        }

        if (groupIds != null) {
            localVarFormParams.put("group_ids", groupIds);
        }

        if (headerText != null) {
            localVarFormParams.put("header_text", headerText);
        }

        if (importedPasswordHash != null) {
            localVarFormParams.put("imported_password_hash", importedPasswordHash);
        }

        if (language != null) {
            localVarFormParams.put("language", language);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (notes != null) {
            localVarFormParams.put("notes", notes);
        }

        if (notificationDailySendTime != null) {
            localVarFormParams.put("notification_daily_send_time", notificationDailySendTime);
        }

        if (officeIntegrationEnabled != null) {
            localVarFormParams.put("office_integration_enabled", officeIntegrationEnabled);
        }

        if (password != null) {
            localVarFormParams.put("password", password);
        }

        if (passwordConfirmation != null) {
            localVarFormParams.put("password_confirmation", passwordConfirmation);
        }

        if (passwordValidityDays != null) {
            localVarFormParams.put("password_validity_days", passwordValidityDays);
        }

        if (receiveAdminAlerts != null) {
            localVarFormParams.put("receive_admin_alerts", receiveAdminAlerts);
        }

        if (require2fa != null) {
            localVarFormParams.put("require_2fa", require2fa);
        }

        if (requirePasswordChange != null) {
            localVarFormParams.put("require_password_change", requirePasswordChange);
        }

        if (restapiPermission != null) {
            localVarFormParams.put("restapi_permission", restapiPermission);
        }

        if (selfManaged != null) {
            localVarFormParams.put("self_managed", selfManaged);
        }

        if (sftpPermission != null) {
            localVarFormParams.put("sftp_permission", sftpPermission);
        }

        if (siteAdmin != null) {
            localVarFormParams.put("site_admin", siteAdmin);
        }

        if (skipWelcomeScreen != null) {
            localVarFormParams.put("skip_welcome_screen", skipWelcomeScreen);
        }

        if (sslRequired != null) {
            localVarFormParams.put("ssl_required", sslRequired);
        }

        if (ssoStrategyId != null) {
            localVarFormParams.put("sso_strategy_id", ssoStrategyId);
        }

        if (subscribeToNewsletter != null) {
            localVarFormParams.put("subscribe_to_newsletter", subscribeToNewsletter);
        }

        if (timeZone != null) {
            localVarFormParams.put("time_zone", timeZone);
        }

        if (userRoot != null) {
            localVarFormParams.put("user_root", userRoot);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call patchUsersIdValidateBeforeCall(Integer id, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling patchUsersId(Async)");
        }

        return patchUsersIdCall(id, allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, _callback);

    }

    /**
     * Update User
     * Update User
     * @param id User ID. (required)
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @return UserEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public UserEntity patchUsersId(Integer id, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username) throws ApiException {
        ApiResponse<UserEntity> localVarResp = patchUsersIdWithHttpInfo(id, allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username);
        return localVarResp.getData();
    }

    /**
     * Update User
     * Update User
     * @param id User ID. (required)
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @return ApiResponse&lt;UserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UserEntity> patchUsersIdWithHttpInfo(Integer id, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username) throws ApiException {
        okhttp3.Call localVarCall = patchUsersIdValidateBeforeCall(id, allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, null);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update User (asynchronously)
     * Update User
     * @param id User ID. (required)
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchUsersIdAsync(Integer id, String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback<UserEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = patchUsersIdValidateBeforeCall(id, allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, _callback);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postUsers
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersCall(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (allowedIps != null) {
            localVarFormParams.put("allowed_ips", allowedIps);
        }

        if (announcementsRead != null) {
            localVarFormParams.put("announcements_read", announcementsRead);
        }

        if (attachmentsPermission != null) {
            localVarFormParams.put("attachments_permission", attachmentsPermission);
        }

        if (authenticateUntil != null) {
            localVarFormParams.put("authenticate_until", authenticateUntil);
        }

        if (authenticationMethod != null) {
            localVarFormParams.put("authentication_method", authenticationMethod);
        }

        if (avatarDelete != null) {
            localVarFormParams.put("avatar_delete", avatarDelete);
        }

        if (avatarFile != null) {
            localVarFormParams.put("avatar_file", avatarFile);
        }

        if (billingPermission != null) {
            localVarFormParams.put("billing_permission", billingPermission);
        }

        if (bypassInactiveDisable != null) {
            localVarFormParams.put("bypass_inactive_disable", bypassInactiveDisable);
        }

        if (bypassSiteAllowedIps != null) {
            localVarFormParams.put("bypass_site_allowed_ips", bypassSiteAllowedIps);
        }

        if (changePassword != null) {
            localVarFormParams.put("change_password", changePassword);
        }

        if (changePasswordConfirmation != null) {
            localVarFormParams.put("change_password_confirmation", changePasswordConfirmation);
        }

        if (company != null) {
            localVarFormParams.put("company", company);
        }

        if (davPermission != null) {
            localVarFormParams.put("dav_permission", davPermission);
        }

        if (disabled != null) {
            localVarFormParams.put("disabled", disabled);
        }

        if (email != null) {
            localVarFormParams.put("email", email);
        }

        if (ftpPermission != null) {
            localVarFormParams.put("ftp_permission", ftpPermission);
        }

        if (grantPermission != null) {
            localVarFormParams.put("grant_permission", grantPermission);
        }

        if (groupId != null) {
            localVarFormParams.put("group_id", groupId);
        }

        if (groupIds != null) {
            localVarFormParams.put("group_ids", groupIds);
        }

        if (headerText != null) {
            localVarFormParams.put("header_text", headerText);
        }

        if (importedPasswordHash != null) {
            localVarFormParams.put("imported_password_hash", importedPasswordHash);
        }

        if (language != null) {
            localVarFormParams.put("language", language);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (notes != null) {
            localVarFormParams.put("notes", notes);
        }

        if (notificationDailySendTime != null) {
            localVarFormParams.put("notification_daily_send_time", notificationDailySendTime);
        }

        if (officeIntegrationEnabled != null) {
            localVarFormParams.put("office_integration_enabled", officeIntegrationEnabled);
        }

        if (password != null) {
            localVarFormParams.put("password", password);
        }

        if (passwordConfirmation != null) {
            localVarFormParams.put("password_confirmation", passwordConfirmation);
        }

        if (passwordValidityDays != null) {
            localVarFormParams.put("password_validity_days", passwordValidityDays);
        }

        if (receiveAdminAlerts != null) {
            localVarFormParams.put("receive_admin_alerts", receiveAdminAlerts);
        }

        if (require2fa != null) {
            localVarFormParams.put("require_2fa", require2fa);
        }

        if (requirePasswordChange != null) {
            localVarFormParams.put("require_password_change", requirePasswordChange);
        }

        if (restapiPermission != null) {
            localVarFormParams.put("restapi_permission", restapiPermission);
        }

        if (selfManaged != null) {
            localVarFormParams.put("self_managed", selfManaged);
        }

        if (sftpPermission != null) {
            localVarFormParams.put("sftp_permission", sftpPermission);
        }

        if (siteAdmin != null) {
            localVarFormParams.put("site_admin", siteAdmin);
        }

        if (skipWelcomeScreen != null) {
            localVarFormParams.put("skip_welcome_screen", skipWelcomeScreen);
        }

        if (sslRequired != null) {
            localVarFormParams.put("ssl_required", sslRequired);
        }

        if (ssoStrategyId != null) {
            localVarFormParams.put("sso_strategy_id", ssoStrategyId);
        }

        if (subscribeToNewsletter != null) {
            localVarFormParams.put("subscribe_to_newsletter", subscribeToNewsletter);
        }

        if (timeZone != null) {
            localVarFormParams.put("time_zone", timeZone);
        }

        if (userRoot != null) {
            localVarFormParams.put("user_root", userRoot);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postUsersValidateBeforeCall(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback _callback) throws ApiException {
        return postUsersCall(allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, _callback);

    }

    /**
     * Create User
     * Create User
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @return UserEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public UserEntity postUsers(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username) throws ApiException {
        ApiResponse<UserEntity> localVarResp = postUsersWithHttpInfo(allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username);
        return localVarResp.getData();
    }

    /**
     * Create User
     * Create User
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @return ApiResponse&lt;UserEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UserEntity> postUsersWithHttpInfo(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username) throws ApiException {
        okhttp3.Call localVarCall = postUsersValidateBeforeCall(allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, null);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create User (asynchronously)
     * Create User
     * @param allowedIps A list of allowed IPs if applicable.  Newline delimited (optional)
     * @param announcementsRead Signifies that the user has read all the announcements in the UI. (optional)
     * @param attachmentsPermission DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead. (optional)
     * @param authenticateUntil Scheduled Date/Time at which user will be deactivated (optional)
     * @param authenticationMethod How is this user authenticated? (optional)
     * @param avatarDelete If true, the avatar will be deleted. (optional)
     * @param avatarFile An image file for your user avatar. (optional)
     * @param billingPermission Allow this user to perform operations on the account, payments, and invoices? (optional)
     * @param bypassInactiveDisable Exempt this user from being disabled based on inactivity? (optional)
     * @param bypassSiteAllowedIps Allow this user to skip site-wide IP blacklists? (optional)
     * @param changePassword Used for changing a password on an existing user. (optional)
     * @param changePasswordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;change_password&#x60;. (optional)
     * @param company User&#39;s company (optional)
     * @param davPermission Can the user connect with WebDAV? (optional)
     * @param disabled Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting. (optional)
     * @param email User&#39;s email. (optional)
     * @param ftpPermission Can the user access with FTP/FTPS? (optional)
     * @param grantPermission Permission to grant on the user root.  Can be blank or &#x60;full&#x60;, &#x60;read&#x60;, &#x60;write&#x60;, &#x60;list&#x60;, &#x60;read+write&#x60;, or &#x60;list+write&#x60; (optional)
     * @param groupId Group ID to associate this user with. (optional)
     * @param groupIds A list of group ids to associate this user with.  Comma delimited. (optional)
     * @param headerText Text to display to the user in the header of the UI (optional)
     * @param importedPasswordHash Pre-calculated hash of the user&#39;s password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256. (optional)
     * @param language Preferred language (optional)
     * @param name User&#39;s full name (optional)
     * @param notes Any internal notes on the user (optional)
     * @param notificationDailySendTime Hour of the day at which daily notifications should be sent. Can be in range 0 to 23 (optional)
     * @param officeIntegrationEnabled Enable integration with Office for the web? (optional)
     * @param password User password. (optional)
     * @param passwordConfirmation Optional, but if provided, we will ensure that it matches the value sent in &#x60;password&#x60;. (optional)
     * @param passwordValidityDays Number of days to allow user to use the same password (optional)
     * @param receiveAdminAlerts Should the user receive admin alerts such a certificate expiration notifications and overages? (optional)
     * @param require2fa 2FA required setting (optional)
     * @param requirePasswordChange Is a password change required upon next user login? (optional)
     * @param restapiPermission Can this user access the REST API? (optional)
     * @param selfManaged Does this user manage it&#39;s own credentials or is it a shared/bot user? (optional)
     * @param sftpPermission Can the user access with SFTP? (optional)
     * @param siteAdmin Is the user an administrator for this site? (optional)
     * @param skipWelcomeScreen Skip Welcome page in the UI? (optional)
     * @param sslRequired SSL required setting (optional)
     * @param ssoStrategyId SSO (Single Sign On) strategy ID for the user, if applicable. (optional)
     * @param subscribeToNewsletter Is the user subscribed to the newsletter? (optional)
     * @param timeZone User time zone (optional)
     * @param userRoot Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface. (optional)
     * @param username User&#39;s username (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The Users object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersAsync(String allowedIps, Boolean announcementsRead, Boolean attachmentsPermission, OffsetDateTime authenticateUntil, String authenticationMethod, Boolean avatarDelete, File avatarFile, Boolean billingPermission, Boolean bypassInactiveDisable, Boolean bypassSiteAllowedIps, String changePassword, String changePasswordConfirmation, String company, Boolean davPermission, Boolean disabled, String email, Boolean ftpPermission, String grantPermission, Integer groupId, String groupIds, String headerText, String importedPasswordHash, String language, String name, String notes, Integer notificationDailySendTime, Boolean officeIntegrationEnabled, String password, String passwordConfirmation, Integer passwordValidityDays, Boolean receiveAdminAlerts, String require2fa, Boolean requirePasswordChange, Boolean restapiPermission, Boolean selfManaged, Boolean sftpPermission, Boolean siteAdmin, Boolean skipWelcomeScreen, String sslRequired, Integer ssoStrategyId, Boolean subscribeToNewsletter, String timeZone, String userRoot, String username, final ApiCallback<UserEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postUsersValidateBeforeCall(allowedIps, announcementsRead, attachmentsPermission, authenticateUntil, authenticationMethod, avatarDelete, avatarFile, billingPermission, bypassInactiveDisable, bypassSiteAllowedIps, changePassword, changePasswordConfirmation, company, davPermission, disabled, email, ftpPermission, grantPermission, groupId, groupIds, headerText, importedPasswordHash, language, name, notes, notificationDailySendTime, officeIntegrationEnabled, password, passwordConfirmation, passwordValidityDays, receiveAdminAlerts, require2fa, requirePasswordChange, restapiPermission, selfManaged, sftpPermission, siteAdmin, skipWelcomeScreen, sslRequired, ssoStrategyId, subscribeToNewsletter, timeZone, userRoot, username, _callback);
        Type localVarReturnType = new TypeToken<UserEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postUsersId2faReset
     * @param id User ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersId2faResetCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/2fa/reset"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postUsersId2faResetValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling postUsersId2faReset(Async)");
        }

        return postUsersId2faResetCall(id, _callback);

    }

    /**
     * Trigger 2FA Reset process for user who has lost access to their existing 2FA methods.
     * Trigger 2FA Reset process for user who has lost access to their existing 2FA methods.
     * @param id User ID. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public void postUsersId2faReset(Integer id) throws ApiException {
        postUsersId2faResetWithHttpInfo(id);
    }

    /**
     * Trigger 2FA Reset process for user who has lost access to their existing 2FA methods.
     * Trigger 2FA Reset process for user who has lost access to their existing 2FA methods.
     * @param id User ID. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> postUsersId2faResetWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = postUsersId2faResetValidateBeforeCall(id, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Trigger 2FA Reset process for user who has lost access to their existing 2FA methods. (asynchronously)
     * Trigger 2FA Reset process for user who has lost access to their existing 2FA methods.
     * @param id User ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersId2faResetAsync(Integer id, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = postUsersId2faResetValidateBeforeCall(id, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for postUsersIdResendWelcomeEmail
     * @param id User ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersIdResendWelcomeEmailCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/resend_welcome_email"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postUsersIdResendWelcomeEmailValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling postUsersIdResendWelcomeEmail(Async)");
        }

        return postUsersIdResendWelcomeEmailCall(id, _callback);

    }

    /**
     * Resend user welcome email
     * Resend user welcome email
     * @param id User ID. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public void postUsersIdResendWelcomeEmail(Integer id) throws ApiException {
        postUsersIdResendWelcomeEmailWithHttpInfo(id);
    }

    /**
     * Resend user welcome email
     * Resend user welcome email
     * @param id User ID. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> postUsersIdResendWelcomeEmailWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = postUsersIdResendWelcomeEmailValidateBeforeCall(id, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Resend user welcome email (asynchronously)
     * Resend user welcome email
     * @param id User ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersIdResendWelcomeEmailAsync(Integer id, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = postUsersIdResendWelcomeEmailValidateBeforeCall(id, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for postUsersIdUnlock
     * @param id User ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersIdUnlockCall(Integer id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/unlock"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postUsersIdUnlockValidateBeforeCall(Integer id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling postUsersIdUnlock(Async)");
        }

        return postUsersIdUnlockCall(id, _callback);

    }

    /**
     * Unlock user who has been locked out due to failed logins.
     * Unlock user who has been locked out due to failed logins.
     * @param id User ID. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public void postUsersIdUnlock(Integer id) throws ApiException {
        postUsersIdUnlockWithHttpInfo(id);
    }

    /**
     * Unlock user who has been locked out due to failed logins.
     * Unlock user who has been locked out due to failed logins.
     * @param id User ID. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> postUsersIdUnlockWithHttpInfo(Integer id) throws ApiException {
        okhttp3.Call localVarCall = postUsersIdUnlockValidateBeforeCall(id, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Unlock user who has been locked out due to failed logins. (asynchronously)
     * Unlock user who has been locked out due to failed logins.
     * @param id User ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No body. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersIdUnlockAsync(Integer id, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = postUsersIdUnlockValidateBeforeCall(id, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for postUsersUserIdApiKeys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersUserIdApiKeysCall(Integer userId, String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/api_keys"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (description != null) {
            localVarFormParams.put("description", description);
        }

        if (expiresAt != null) {
            localVarFormParams.put("expires_at", expiresAt);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (path != null) {
            localVarFormParams.put("path", path);
        }

        if (permissionSet != null) {
            localVarFormParams.put("permission_set", permissionSet);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postUsersUserIdApiKeysValidateBeforeCall(Integer userId, String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling postUsersUserIdApiKeys(Async)");
        }

        return postUsersUserIdApiKeysCall(userId, description, expiresAt, name, path, permissionSet, _callback);

    }

    /**
     * Create Api Key
     * Create Api Key
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @return ApiKeyEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiKeyEntity postUsersUserIdApiKeys(Integer userId, String description, OffsetDateTime expiresAt, String name, String path, String permissionSet) throws ApiException {
        ApiResponse<ApiKeyEntity> localVarResp = postUsersUserIdApiKeysWithHttpInfo(userId, description, expiresAt, name, path, permissionSet);
        return localVarResp.getData();
    }

    /**
     * Create Api Key
     * Create Api Key
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @return ApiResponse&lt;ApiKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiKeyEntity> postUsersUserIdApiKeysWithHttpInfo(Integer userId, String description, OffsetDateTime expiresAt, String name, String path, String permissionSet) throws ApiException {
        okhttp3.Call localVarCall = postUsersUserIdApiKeysValidateBeforeCall(userId, description, expiresAt, name, path, permissionSet, null);
        Type localVarReturnType = new TypeToken<ApiKeyEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Api Key (asynchronously)
     * Create Api Key
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersUserIdApiKeysAsync(Integer userId, String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, final ApiCallback<ApiKeyEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postUsersUserIdApiKeysValidateBeforeCall(userId, description, expiresAt, name, path, permissionSet, _callback);
        Type localVarReturnType = new TypeToken<ApiKeyEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postUsersUserIdPublicKeys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param publicKey Actual contents of SSH key. (required)
     * @param title Internal reference for key. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The PublicKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersUserIdPublicKeysCall(Integer userId, String publicKey, String title, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{user_id}/public_keys"
            .replace("{" + "user_id" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (publicKey != null) {
            localVarFormParams.put("public_key", publicKey);
        }

        if (title != null) {
            localVarFormParams.put("title", title);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postUsersUserIdPublicKeysValidateBeforeCall(Integer userId, String publicKey, String title, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling postUsersUserIdPublicKeys(Async)");
        }

        // verify the required parameter 'publicKey' is set
        if (publicKey == null) {
            throw new ApiException("Missing the required parameter 'publicKey' when calling postUsersUserIdPublicKeys(Async)");
        }

        // verify the required parameter 'title' is set
        if (title == null) {
            throw new ApiException("Missing the required parameter 'title' when calling postUsersUserIdPublicKeys(Async)");
        }

        return postUsersUserIdPublicKeysCall(userId, publicKey, title, _callback);

    }

    /**
     * Create Public Key
     * Create Public Key
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param publicKey Actual contents of SSH key. (required)
     * @param title Internal reference for key. (required)
     * @return PublicKeyEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The PublicKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public PublicKeyEntity postUsersUserIdPublicKeys(Integer userId, String publicKey, String title) throws ApiException {
        ApiResponse<PublicKeyEntity> localVarResp = postUsersUserIdPublicKeysWithHttpInfo(userId, publicKey, title);
        return localVarResp.getData();
    }

    /**
     * Create Public Key
     * Create Public Key
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param publicKey Actual contents of SSH key. (required)
     * @param title Internal reference for key. (required)
     * @return ApiResponse&lt;PublicKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The PublicKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PublicKeyEntity> postUsersUserIdPublicKeysWithHttpInfo(Integer userId, String publicKey, String title) throws ApiException {
        okhttp3.Call localVarCall = postUsersUserIdPublicKeysValidateBeforeCall(userId, publicKey, title, null);
        Type localVarReturnType = new TypeToken<PublicKeyEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Public Key (asynchronously)
     * Create Public Key
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (required)
     * @param publicKey Actual contents of SSH key. (required)
     * @param title Internal reference for key. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The PublicKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postUsersUserIdPublicKeysAsync(Integer userId, String publicKey, String title, final ApiCallback<PublicKeyEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postUsersUserIdPublicKeysValidateBeforeCall(userId, publicKey, title, _callback);
        Type localVarReturnType = new TypeToken<PublicKeyEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
