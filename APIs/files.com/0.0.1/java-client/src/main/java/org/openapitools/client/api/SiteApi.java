/*
 * Files.com API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@files.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ApiKeyEntity;
import org.openapitools.client.model.DnsRecordEntity;
import java.io.File;
import org.openapitools.client.model.IpAddressEntity;
import java.time.OffsetDateTime;
import org.openapitools.client.model.SiteEntity;
import org.openapitools.client.model.StatusEntity;
import org.openapitools.client.model.UsageSnapshotEntity;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SiteApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SiteApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SiteApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getSite
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/site";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSiteValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getSiteCall(_callback);

    }

    /**
     * Show site settings
     * Show site settings
     * @return SiteEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public SiteEntity getSite() throws ApiException {
        ApiResponse<SiteEntity> localVarResp = getSiteWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Show site settings
     * Show site settings
     * @return ApiResponse&lt;SiteEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SiteEntity> getSiteWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getSiteValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<SiteEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Show site settings (asynchronously)
     * Show site settings
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteAsync(final ApiCallback<SiteEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSiteValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<SiteEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSiteApiKeys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteApiKeysCall(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/site/api_keys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("user_id", userId));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(sortBy));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filter));
        }

        if (filterGt != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterGt));
        }

        if (filterGteq != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterGteq));
        }

        if (filterLt != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterLt));
        }

        if (filterLteq != null) {
            localVarQueryParams.addAll(localVarApiClient.freeFormParameterToPairs(filterLteq));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSiteApiKeysValidateBeforeCall(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq, final ApiCallback _callback) throws ApiException {
        return getSiteApiKeysCall(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq, _callback);

    }

    /**
     * List Api Keys
     * List Api Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @return List&lt;ApiKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<ApiKeyEntity> getSiteApiKeys(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq) throws ApiException {
        ApiResponse<List<ApiKeyEntity>> localVarResp = getSiteApiKeysWithHttpInfo(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq);
        return localVarResp.getData();
    }

    /**
     * List Api Keys
     * List Api Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @return ApiResponse&lt;List&lt;ApiKeyEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ApiKeyEntity>> getSiteApiKeysWithHttpInfo(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq) throws ApiException {
        okhttp3.Call localVarCall = getSiteApiKeysValidateBeforeCall(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq, null);
        Type localVarReturnType = new TypeToken<List<ApiKeyEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Api Keys (asynchronously)
     * List Api Keys
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param sortBy If set, sort records by the specified field in either &#x60;asc&#x60; or &#x60;desc&#x60; direction (e.g. &#x60;sort_by[expires_at]&#x3D;desc&#x60;). Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filter If set, return records where the specified field is equal to the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGt If set, return records where the specified field is greater than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterGteq If set, return records where the specified field is greater than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLt If set, return records where the specified field is less than the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param filterLteq If set, return records where the specified field is less than or equal the supplied value. Valid fields are &#x60;expires_at&#x60;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of ApiKeys objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteApiKeysAsync(Integer userId, String cursor, Integer perPage, Object sortBy, Object filter, Object filterGt, Object filterGteq, Object filterLt, Object filterLteq, final ApiCallback<List<ApiKeyEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSiteApiKeysValidateBeforeCall(userId, cursor, perPage, sortBy, filter, filterGt, filterGteq, filterLt, filterLteq, _callback);
        Type localVarReturnType = new TypeToken<List<ApiKeyEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSiteDnsRecords
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of DnsRecords objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteDnsRecordsCall(String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/site/dns_records";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSiteDnsRecordsValidateBeforeCall(String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        return getSiteDnsRecordsCall(cursor, perPage, _callback);

    }

    /**
     * Show site DNS configuration.
     * Show site DNS configuration.
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return List&lt;DnsRecordEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of DnsRecords objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<DnsRecordEntity> getSiteDnsRecords(String cursor, Integer perPage) throws ApiException {
        ApiResponse<List<DnsRecordEntity>> localVarResp = getSiteDnsRecordsWithHttpInfo(cursor, perPage);
        return localVarResp.getData();
    }

    /**
     * Show site DNS configuration.
     * Show site DNS configuration.
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return ApiResponse&lt;List&lt;DnsRecordEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of DnsRecords objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DnsRecordEntity>> getSiteDnsRecordsWithHttpInfo(String cursor, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = getSiteDnsRecordsValidateBeforeCall(cursor, perPage, null);
        Type localVarReturnType = new TypeToken<List<DnsRecordEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Show site DNS configuration. (asynchronously)
     * Show site DNS configuration.
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of DnsRecords objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteDnsRecordsAsync(String cursor, Integer perPage, final ApiCallback<List<DnsRecordEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSiteDnsRecordsValidateBeforeCall(cursor, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<DnsRecordEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSiteIpAddresses
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of IpAddresses objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteIpAddressesCall(String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/site/ip_addresses";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSiteIpAddressesValidateBeforeCall(String cursor, Integer perPage, final ApiCallback _callback) throws ApiException {
        return getSiteIpAddressesCall(cursor, perPage, _callback);

    }

    /**
     * List IP Addresses associated with the current site
     * List IP Addresses associated with the current site
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return List&lt;IpAddressEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of IpAddresses objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public List<IpAddressEntity> getSiteIpAddresses(String cursor, Integer perPage) throws ApiException {
        ApiResponse<List<IpAddressEntity>> localVarResp = getSiteIpAddressesWithHttpInfo(cursor, perPage);
        return localVarResp.getData();
    }

    /**
     * List IP Addresses associated with the current site
     * List IP Addresses associated with the current site
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @return ApiResponse&lt;List&lt;IpAddressEntity&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of IpAddresses objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<IpAddressEntity>> getSiteIpAddressesWithHttpInfo(String cursor, Integer perPage) throws ApiException {
        okhttp3.Call localVarCall = getSiteIpAddressesValidateBeforeCall(cursor, perPage, null);
        Type localVarReturnType = new TypeToken<List<IpAddressEntity>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List IP Addresses associated with the current site (asynchronously)
     * List IP Addresses associated with the current site
     * @param cursor Used for pagination.  When a list request has more records available, cursors are provided in the response headers &#x60;X-Files-Cursor-Next&#x60; and &#x60;X-Files-Cursor-Prev&#x60;.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination. (optional)
     * @param perPage Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of IpAddresses objects. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteIpAddressesAsync(String cursor, Integer perPage, final ApiCallback<List<IpAddressEntity>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSiteIpAddressesValidateBeforeCall(cursor, perPage, _callback);
        Type localVarReturnType = new TypeToken<List<IpAddressEntity>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSiteUsage
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteUsageCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/site/usage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSiteUsageValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getSiteUsageCall(_callback);

    }

    /**
     * Get the most recent usage snapshot (usage data for billing purposes) for a Site.
     * Get the most recent usage snapshot (usage data for billing purposes) for a Site.
     * @return UsageSnapshotEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public UsageSnapshotEntity getSiteUsage() throws ApiException {
        ApiResponse<UsageSnapshotEntity> localVarResp = getSiteUsageWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Get the most recent usage snapshot (usage data for billing purposes) for a Site.
     * Get the most recent usage snapshot (usage data for billing purposes) for a Site.
     * @return ApiResponse&lt;UsageSnapshotEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UsageSnapshotEntity> getSiteUsageWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getSiteUsageValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<UsageSnapshotEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get the most recent usage snapshot (usage data for billing purposes) for a Site. (asynchronously)
     * Get the most recent usage snapshot (usage data for billing purposes) for a Site.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSiteUsageAsync(final ApiCallback<UsageSnapshotEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSiteUsageValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<UsageSnapshotEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for patchSite
     * @param activeSftpHostKeyId Id of the currently selected custom SFTP Host Key (optional)
     * @param allowBundleNames Are manual Bundle names allowed? (optional)
     * @param allowed2faMethodBypassForFtpSftpDav Are users allowed to configure their two factor authentication to be bypassed for FTP/SFTP/WebDAV? (optional)
     * @param allowed2faMethodSms Is SMS two factor authentication allowed? (optional)
     * @param allowed2faMethodTotp Is TOTP two factor authentication allowed? (optional)
     * @param allowed2faMethodU2f Is U2F two factor authentication allowed? (optional)
     * @param allowed2faMethodWebauthn Is WebAuthn two factor authentication allowed? (optional)
     * @param allowed2faMethodYubi Is yubikey two factor authentication allowed? (optional)
     * @param allowedCountries Comma seperated list of allowed Country codes (optional)
     * @param allowedIps List of allowed IP addresses (optional)
     * @param askAboutOverwrites If false, rename conflicting files instead of asking for overwrite confirmation.  Only applies to web interface. (optional)
     * @param bundleActivityNotifications Do Bundle owners receive activity notifications? (optional)
     * @param bundleExpiration Site-wide Bundle expiration in days (optional)
     * @param bundlePasswordRequired Do Bundles require password protection? (optional)
     * @param bundleRegistrationNotifications Do Bundle owners receive registration notification? (optional)
     * @param bundleRequireShareRecipient Do Bundles require recipients for sharing? (optional)
     * @param bundleUploadReceiptNotifications Do Bundle uploaders receive upload confirmation notifications? (optional)
     * @param bundleWatermarkAttachmentDelete If true, will delete the file stored in bundle_watermark_attachment (optional)
     * @param bundleWatermarkAttachmentFile  (optional)
     * @param bundleWatermarkValue Preview watermark settings applied to all bundle items. Uses the same keys as Behavior.value (optional)
     * @param color2Left Page link and button color (optional)
     * @param color2Link Top bar link color (optional)
     * @param color2Text Page link and button color (optional)
     * @param color2Top Top bar background color (optional)
     * @param color2TopText Top bar text color (optional)
     * @param customNamespace Is this site using a custom namespace for users? (optional)
     * @param daysToRetainBackups Number of days to keep deleted files (optional)
     * @param defaultTimeZone Site default time zone (optional)
     * @param desktopApp Is the desktop app enabled? (optional)
     * @param desktopAppSessionIpPinning Is desktop app session IP pinning enabled? (optional)
     * @param desktopAppSessionLifetime Desktop app session lifetime (in hours) (optional)
     * @param disable2faWithDelay If set to true, we will begin the process of disabling 2FA on this site. (optional)
     * @param disableFilesCertificateGeneration If set, Files.com will not set the CAA records required to generate future SSL certificates for this domain. (optional)
     * @param disablePasswordReset Is password reset disabled? (optional)
     * @param disableUsersFromInactivityPeriodDays If greater than zero, users will unable to login if they do not show activity within this number of days. (optional)
     * @param disallowedCountries Comma seperated list of disallowed Country codes (optional)
     * @param domain Custom domain (optional)
     * @param domainHstsHeader Send HSTS (HTTP Strict Transport Security) header when visitors access the site via a custom domain? (optional)
     * @param domainLetsencryptChain Letsencrypt chain to use when registering SSL Certificate for domain. (optional)
     * @param email Main email for this site (optional)
     * @param folderPermissionsGroupsOnly If true, permissions for this site must be bound to a group (not a user). Otherwise, permissions must be bound to a user. (optional)
     * @param ftpEnabled Is FTP enabled? (optional)
     * @param icon128Delete If true, will delete the file stored in icon128 (optional)
     * @param icon128File  (optional)
     * @param icon16Delete If true, will delete the file stored in icon16 (optional)
     * @param icon16File  (optional)
     * @param icon32Delete If true, will delete the file stored in icon32 (optional)
     * @param icon32File  (optional)
     * @param icon48Delete If true, will delete the file stored in icon48 (optional)
     * @param icon48File  (optional)
     * @param immutableFiles Are files protected from modification? (optional)
     * @param includePasswordInWelcomeEmail Include password in emails to new users? (optional)
     * @param language Site default language (optional)
     * @param ldapBaseDn Base DN for looking up users in LDAP server (optional)
     * @param ldapDomain Domain name that will be appended to usernames (optional)
     * @param ldapEnabled Main LDAP setting: is LDAP enabled? (optional)
     * @param ldapGroupAction Should we sync groups from LDAP server? (optional)
     * @param ldapGroupExclusion Comma or newline separated list of group names (with optional wildcards) to exclude when syncing. (optional)
     * @param ldapGroupInclusion Comma or newline separated list of group names (with optional wildcards) to include when syncing. (optional)
     * @param ldapHost LDAP host (optional)
     * @param ldapHost2 LDAP backup host (optional)
     * @param ldapHost3 LDAP backup host (optional)
     * @param ldapPasswordChange New LDAP password. (optional)
     * @param ldapPasswordChangeConfirmation Confirm new LDAP password. (optional)
     * @param ldapPort LDAP port (optional)
     * @param ldapSecure Use secure LDAP? (optional)
     * @param ldapType LDAP type (optional)
     * @param ldapUserAction Should we sync users from LDAP server? (optional)
     * @param ldapUserIncludeGroups Comma or newline separated list of group names (with optional wildcards) - if provided, only users in these groups will be added or synced. (optional)
     * @param ldapUsername Username for signing in to LDAP server. (optional)
     * @param ldapUsernameField LDAP username field (optional)
     * @param loginHelpText Login help text (optional)
     * @param logoDelete If true, will delete the file stored in logo (optional)
     * @param logoFile  (optional)
     * @param maxPriorPasswords Number of prior passwords to disallow (optional)
     * @param mobileApp Is the mobile app enabled? (optional)
     * @param mobileAppSessionIpPinning Is mobile app session IP pinning enabled? (optional)
     * @param mobileAppSessionLifetime Mobile app session lifetime (in hours) (optional)
     * @param motdText A message to show users when they connect via FTP or SFTP. (optional)
     * @param motdUseForFtp Show message to users connecting via FTP (optional)
     * @param motdUseForSftp Show message to users connecting via SFTP (optional)
     * @param name Site name (optional)
     * @param nonSsoGroupsAllowed If true, groups can be manually created / modified / deleted by Site Admins. Otherwise, groups can only be managed via your SSO provider. (optional)
     * @param nonSsoUsersAllowed If true, users can be manually created / modified / deleted by Site Admins. Otherwise, users can only be managed via your SSO provider. (optional)
     * @param officeIntegrationAvailable Allow users to use Office for the web? (optional)
     * @param officeIntegrationType Office integration application used to edit and view the MS Office documents (optional)
     * @param optOutGlobal Use servers in the USA only? (optional)
     * @param passwordMinLength Shortest password length for users (optional)
     * @param passwordRequireLetter Require a letter in passwords? (optional)
     * @param passwordRequireMixed Require lower and upper case letters in passwords? (optional)
     * @param passwordRequireNumber Require a number in passwords? (optional)
     * @param passwordRequireSpecial Require special characters in password? (optional)
     * @param passwordRequireUnbreached Require passwords that have not been previously breached? (see https://haveibeenpwned.com/) (optional)
     * @param passwordRequirementsApplyToBundles Require bundles&#39; passwords, and passwords for other items (inboxes, public shares, etc.) to conform to the same requirements as users&#39; passwords? (optional)
     * @param passwordValidityDays Number of days password is valid (optional)
     * @param pinAllRemoteServersToSiteRegion If true, we will ensure that all internal communications with any remote server are made through the primary region of the site. This setting overrides individual remote server settings. (optional)
     * @param replyToEmail Reply-to email for this site (optional)
     * @param require2fa Require two-factor authentication for all users? (optional)
     * @param require2faUserType What type of user is required to use two-factor authentication (when require_2fa is set to &#x60;true&#x60; for this site)? (optional)
     * @param sessionExpiry Session expiry in hours (optional)
     * @param sessionExpiryMinutes Session expiry in minutes (optional)
     * @param sessionPinnedByIp Are sessions locked to the same IP? (i.e. do users need to log in again if they change IPs?) (optional)
     * @param sftpEnabled Is SFTP enabled? (optional)
     * @param sftpHostKeyType Sftp Host Key Type (optional)
     * @param sftpInsecureCiphers Are Insecure Ciphers allowed for SFTP?  Note:  Settting TLS Disabled -&gt; True will always allow insecure ciphers for SFTP as well.  Enabling this is insecure. (optional)
     * @param sftpUserRootEnabled Use user FTP roots also for SFTP? (optional)
     * @param sharingEnabled Allow bundle creation (optional)
     * @param showRequestAccessLink Show request access link for users without access?  Currently unused. (optional)
     * @param siteFooter Custom site footer text (optional)
     * @param siteHeader Custom site header text (optional)
     * @param smtpAddress SMTP server hostname or IP (optional)
     * @param smtpAuthentication SMTP server authentication type (optional)
     * @param smtpFrom From address to use when mailing through custom SMTP (optional)
     * @param smtpPassword Password for SMTP server. (optional)
     * @param smtpPort SMTP server port (optional)
     * @param smtpUsername SMTP server username (optional)
     * @param sslRequired Is SSL required?  Disabling this is insecure. (optional)
     * @param subdomain Site subdomain (optional)
     * @param tlsDisabled Are Insecure TLS and SFTP Ciphers allowed?  Enabling this is insecure. (optional)
     * @param uploadsViaEmailAuthentication Do incoming emails in the Inboxes require checking for SPF/DKIM/DMARC? (optional)
     * @param useProvidedModifiedAt Allow uploaders to set &#x60;provided_modified_at&#x60; for uploaded files? (optional)
     * @param userLockout Will users be locked out after incorrect login attempts? (optional)
     * @param userLockoutLockPeriod How many hours to lock user out for failed password? (optional)
     * @param userLockoutTries Number of login tries within &#x60;user_lockout_within&#x60; hours before users are locked out (optional)
     * @param userLockoutWithin Number of hours for user lockout window (optional)
     * @param userRequestsEnabled Enable User Requests feature (optional)
     * @param userRequestsNotifyAdmins Send email to site admins when a user request is received? (optional)
     * @param welcomeCustomText Custom text send in user welcome email (optional)
     * @param welcomeEmailCc Include this email in welcome emails if enabled (optional)
     * @param welcomeEmailEnabled Will the welcome email be sent to new users? (optional)
     * @param welcomeEmailSubject Include this email subject in welcome emails if enabled (optional)
     * @param welcomeScreen Does the welcome screen appear? (optional)
     * @param windowsModeFtp Does FTP user Windows emulation mode? (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchSiteCall(Integer activeSftpHostKeyId, Boolean allowBundleNames, Boolean allowed2faMethodBypassForFtpSftpDav, Boolean allowed2faMethodSms, Boolean allowed2faMethodTotp, Boolean allowed2faMethodU2f, Boolean allowed2faMethodWebauthn, Boolean allowed2faMethodYubi, String allowedCountries, String allowedIps, Boolean askAboutOverwrites, String bundleActivityNotifications, Integer bundleExpiration, Boolean bundlePasswordRequired, String bundleRegistrationNotifications, Boolean bundleRequireShareRecipient, String bundleUploadReceiptNotifications, Boolean bundleWatermarkAttachmentDelete, File bundleWatermarkAttachmentFile, Object bundleWatermarkValue, String color2Left, String color2Link, String color2Text, String color2Top, String color2TopText, Boolean customNamespace, Integer daysToRetainBackups, String defaultTimeZone, Boolean desktopApp, Boolean desktopAppSessionIpPinning, Integer desktopAppSessionLifetime, Boolean disable2faWithDelay, Boolean disableFilesCertificateGeneration, Boolean disablePasswordReset, Integer disableUsersFromInactivityPeriodDays, String disallowedCountries, String domain, Boolean domainHstsHeader, String domainLetsencryptChain, String email, Boolean folderPermissionsGroupsOnly, Boolean ftpEnabled, Boolean icon128Delete, File icon128File, Boolean icon16Delete, File icon16File, Boolean icon32Delete, File icon32File, Boolean icon48Delete, File icon48File, Boolean immutableFiles, Boolean includePasswordInWelcomeEmail, String language, String ldapBaseDn, String ldapDomain, Boolean ldapEnabled, String ldapGroupAction, String ldapGroupExclusion, String ldapGroupInclusion, String ldapHost, String ldapHost2, String ldapHost3, String ldapPasswordChange, String ldapPasswordChangeConfirmation, Integer ldapPort, Boolean ldapSecure, String ldapType, String ldapUserAction, String ldapUserIncludeGroups, String ldapUsername, String ldapUsernameField, String loginHelpText, Boolean logoDelete, File logoFile, Integer maxPriorPasswords, Boolean mobileApp, Boolean mobileAppSessionIpPinning, Integer mobileAppSessionLifetime, String motdText, Boolean motdUseForFtp, Boolean motdUseForSftp, String name, Boolean nonSsoGroupsAllowed, Boolean nonSsoUsersAllowed, Boolean officeIntegrationAvailable, String officeIntegrationType, Boolean optOutGlobal, Integer passwordMinLength, Boolean passwordRequireLetter, Boolean passwordRequireMixed, Boolean passwordRequireNumber, Boolean passwordRequireSpecial, Boolean passwordRequireUnbreached, Boolean passwordRequirementsApplyToBundles, Integer passwordValidityDays, Boolean pinAllRemoteServersToSiteRegion, String replyToEmail, Boolean require2fa, String require2faUserType, Double sessionExpiry, Integer sessionExpiryMinutes, Boolean sessionPinnedByIp, Boolean sftpEnabled, String sftpHostKeyType, Boolean sftpInsecureCiphers, Boolean sftpUserRootEnabled, Boolean sharingEnabled, Boolean showRequestAccessLink, String siteFooter, String siteHeader, String smtpAddress, String smtpAuthentication, String smtpFrom, String smtpPassword, Integer smtpPort, String smtpUsername, Boolean sslRequired, String subdomain, Boolean tlsDisabled, Boolean uploadsViaEmailAuthentication, Boolean useProvidedModifiedAt, Boolean userLockout, Integer userLockoutLockPeriod, Integer userLockoutTries, Integer userLockoutWithin, Boolean userRequestsEnabled, Boolean userRequestsNotifyAdmins, String welcomeCustomText, String welcomeEmailCc, Boolean welcomeEmailEnabled, String welcomeEmailSubject, String welcomeScreen, Boolean windowsModeFtp, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/site";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (activeSftpHostKeyId != null) {
            localVarFormParams.put("active_sftp_host_key_id", activeSftpHostKeyId);
        }

        if (allowBundleNames != null) {
            localVarFormParams.put("allow_bundle_names", allowBundleNames);
        }

        if (allowed2faMethodBypassForFtpSftpDav != null) {
            localVarFormParams.put("allowed_2fa_method_bypass_for_ftp_sftp_dav", allowed2faMethodBypassForFtpSftpDav);
        }

        if (allowed2faMethodSms != null) {
            localVarFormParams.put("allowed_2fa_method_sms", allowed2faMethodSms);
        }

        if (allowed2faMethodTotp != null) {
            localVarFormParams.put("allowed_2fa_method_totp", allowed2faMethodTotp);
        }

        if (allowed2faMethodU2f != null) {
            localVarFormParams.put("allowed_2fa_method_u2f", allowed2faMethodU2f);
        }

        if (allowed2faMethodWebauthn != null) {
            localVarFormParams.put("allowed_2fa_method_webauthn", allowed2faMethodWebauthn);
        }

        if (allowed2faMethodYubi != null) {
            localVarFormParams.put("allowed_2fa_method_yubi", allowed2faMethodYubi);
        }

        if (allowedCountries != null) {
            localVarFormParams.put("allowed_countries", allowedCountries);
        }

        if (allowedIps != null) {
            localVarFormParams.put("allowed_ips", allowedIps);
        }

        if (askAboutOverwrites != null) {
            localVarFormParams.put("ask_about_overwrites", askAboutOverwrites);
        }

        if (bundleActivityNotifications != null) {
            localVarFormParams.put("bundle_activity_notifications", bundleActivityNotifications);
        }

        if (bundleExpiration != null) {
            localVarFormParams.put("bundle_expiration", bundleExpiration);
        }

        if (bundlePasswordRequired != null) {
            localVarFormParams.put("bundle_password_required", bundlePasswordRequired);
        }

        if (bundleRegistrationNotifications != null) {
            localVarFormParams.put("bundle_registration_notifications", bundleRegistrationNotifications);
        }

        if (bundleRequireShareRecipient != null) {
            localVarFormParams.put("bundle_require_share_recipient", bundleRequireShareRecipient);
        }

        if (bundleUploadReceiptNotifications != null) {
            localVarFormParams.put("bundle_upload_receipt_notifications", bundleUploadReceiptNotifications);
        }

        if (bundleWatermarkAttachmentDelete != null) {
            localVarFormParams.put("bundle_watermark_attachment_delete", bundleWatermarkAttachmentDelete);
        }

        if (bundleWatermarkAttachmentFile != null) {
            localVarFormParams.put("bundle_watermark_attachment_file", bundleWatermarkAttachmentFile);
        }

        if (bundleWatermarkValue != null) {
            localVarFormParams.put("bundle_watermark_value", bundleWatermarkValue);
        }

        if (color2Left != null) {
            localVarFormParams.put("color2_left", color2Left);
        }

        if (color2Link != null) {
            localVarFormParams.put("color2_link", color2Link);
        }

        if (color2Text != null) {
            localVarFormParams.put("color2_text", color2Text);
        }

        if (color2Top != null) {
            localVarFormParams.put("color2_top", color2Top);
        }

        if (color2TopText != null) {
            localVarFormParams.put("color2_top_text", color2TopText);
        }

        if (customNamespace != null) {
            localVarFormParams.put("custom_namespace", customNamespace);
        }

        if (daysToRetainBackups != null) {
            localVarFormParams.put("days_to_retain_backups", daysToRetainBackups);
        }

        if (defaultTimeZone != null) {
            localVarFormParams.put("default_time_zone", defaultTimeZone);
        }

        if (desktopApp != null) {
            localVarFormParams.put("desktop_app", desktopApp);
        }

        if (desktopAppSessionIpPinning != null) {
            localVarFormParams.put("desktop_app_session_ip_pinning", desktopAppSessionIpPinning);
        }

        if (desktopAppSessionLifetime != null) {
            localVarFormParams.put("desktop_app_session_lifetime", desktopAppSessionLifetime);
        }

        if (disable2faWithDelay != null) {
            localVarFormParams.put("disable_2fa_with_delay", disable2faWithDelay);
        }

        if (disableFilesCertificateGeneration != null) {
            localVarFormParams.put("disable_files_certificate_generation", disableFilesCertificateGeneration);
        }

        if (disablePasswordReset != null) {
            localVarFormParams.put("disable_password_reset", disablePasswordReset);
        }

        if (disableUsersFromInactivityPeriodDays != null) {
            localVarFormParams.put("disable_users_from_inactivity_period_days", disableUsersFromInactivityPeriodDays);
        }

        if (disallowedCountries != null) {
            localVarFormParams.put("disallowed_countries", disallowedCountries);
        }

        if (domain != null) {
            localVarFormParams.put("domain", domain);
        }

        if (domainHstsHeader != null) {
            localVarFormParams.put("domain_hsts_header", domainHstsHeader);
        }

        if (domainLetsencryptChain != null) {
            localVarFormParams.put("domain_letsencrypt_chain", domainLetsencryptChain);
        }

        if (email != null) {
            localVarFormParams.put("email", email);
        }

        if (folderPermissionsGroupsOnly != null) {
            localVarFormParams.put("folder_permissions_groups_only", folderPermissionsGroupsOnly);
        }

        if (ftpEnabled != null) {
            localVarFormParams.put("ftp_enabled", ftpEnabled);
        }

        if (icon128Delete != null) {
            localVarFormParams.put("icon128_delete", icon128Delete);
        }

        if (icon128File != null) {
            localVarFormParams.put("icon128_file", icon128File);
        }

        if (icon16Delete != null) {
            localVarFormParams.put("icon16_delete", icon16Delete);
        }

        if (icon16File != null) {
            localVarFormParams.put("icon16_file", icon16File);
        }

        if (icon32Delete != null) {
            localVarFormParams.put("icon32_delete", icon32Delete);
        }

        if (icon32File != null) {
            localVarFormParams.put("icon32_file", icon32File);
        }

        if (icon48Delete != null) {
            localVarFormParams.put("icon48_delete", icon48Delete);
        }

        if (icon48File != null) {
            localVarFormParams.put("icon48_file", icon48File);
        }

        if (immutableFiles != null) {
            localVarFormParams.put("immutable_files", immutableFiles);
        }

        if (includePasswordInWelcomeEmail != null) {
            localVarFormParams.put("include_password_in_welcome_email", includePasswordInWelcomeEmail);
        }

        if (language != null) {
            localVarFormParams.put("language", language);
        }

        if (ldapBaseDn != null) {
            localVarFormParams.put("ldap_base_dn", ldapBaseDn);
        }

        if (ldapDomain != null) {
            localVarFormParams.put("ldap_domain", ldapDomain);
        }

        if (ldapEnabled != null) {
            localVarFormParams.put("ldap_enabled", ldapEnabled);
        }

        if (ldapGroupAction != null) {
            localVarFormParams.put("ldap_group_action", ldapGroupAction);
        }

        if (ldapGroupExclusion != null) {
            localVarFormParams.put("ldap_group_exclusion", ldapGroupExclusion);
        }

        if (ldapGroupInclusion != null) {
            localVarFormParams.put("ldap_group_inclusion", ldapGroupInclusion);
        }

        if (ldapHost != null) {
            localVarFormParams.put("ldap_host", ldapHost);
        }

        if (ldapHost2 != null) {
            localVarFormParams.put("ldap_host_2", ldapHost2);
        }

        if (ldapHost3 != null) {
            localVarFormParams.put("ldap_host_3", ldapHost3);
        }

        if (ldapPasswordChange != null) {
            localVarFormParams.put("ldap_password_change", ldapPasswordChange);
        }

        if (ldapPasswordChangeConfirmation != null) {
            localVarFormParams.put("ldap_password_change_confirmation", ldapPasswordChangeConfirmation);
        }

        if (ldapPort != null) {
            localVarFormParams.put("ldap_port", ldapPort);
        }

        if (ldapSecure != null) {
            localVarFormParams.put("ldap_secure", ldapSecure);
        }

        if (ldapType != null) {
            localVarFormParams.put("ldap_type", ldapType);
        }

        if (ldapUserAction != null) {
            localVarFormParams.put("ldap_user_action", ldapUserAction);
        }

        if (ldapUserIncludeGroups != null) {
            localVarFormParams.put("ldap_user_include_groups", ldapUserIncludeGroups);
        }

        if (ldapUsername != null) {
            localVarFormParams.put("ldap_username", ldapUsername);
        }

        if (ldapUsernameField != null) {
            localVarFormParams.put("ldap_username_field", ldapUsernameField);
        }

        if (loginHelpText != null) {
            localVarFormParams.put("login_help_text", loginHelpText);
        }

        if (logoDelete != null) {
            localVarFormParams.put("logo_delete", logoDelete);
        }

        if (logoFile != null) {
            localVarFormParams.put("logo_file", logoFile);
        }

        if (maxPriorPasswords != null) {
            localVarFormParams.put("max_prior_passwords", maxPriorPasswords);
        }

        if (mobileApp != null) {
            localVarFormParams.put("mobile_app", mobileApp);
        }

        if (mobileAppSessionIpPinning != null) {
            localVarFormParams.put("mobile_app_session_ip_pinning", mobileAppSessionIpPinning);
        }

        if (mobileAppSessionLifetime != null) {
            localVarFormParams.put("mobile_app_session_lifetime", mobileAppSessionLifetime);
        }

        if (motdText != null) {
            localVarFormParams.put("motd_text", motdText);
        }

        if (motdUseForFtp != null) {
            localVarFormParams.put("motd_use_for_ftp", motdUseForFtp);
        }

        if (motdUseForSftp != null) {
            localVarFormParams.put("motd_use_for_sftp", motdUseForSftp);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (nonSsoGroupsAllowed != null) {
            localVarFormParams.put("non_sso_groups_allowed", nonSsoGroupsAllowed);
        }

        if (nonSsoUsersAllowed != null) {
            localVarFormParams.put("non_sso_users_allowed", nonSsoUsersAllowed);
        }

        if (officeIntegrationAvailable != null) {
            localVarFormParams.put("office_integration_available", officeIntegrationAvailable);
        }

        if (officeIntegrationType != null) {
            localVarFormParams.put("office_integration_type", officeIntegrationType);
        }

        if (optOutGlobal != null) {
            localVarFormParams.put("opt_out_global", optOutGlobal);
        }

        if (passwordMinLength != null) {
            localVarFormParams.put("password_min_length", passwordMinLength);
        }

        if (passwordRequireLetter != null) {
            localVarFormParams.put("password_require_letter", passwordRequireLetter);
        }

        if (passwordRequireMixed != null) {
            localVarFormParams.put("password_require_mixed", passwordRequireMixed);
        }

        if (passwordRequireNumber != null) {
            localVarFormParams.put("password_require_number", passwordRequireNumber);
        }

        if (passwordRequireSpecial != null) {
            localVarFormParams.put("password_require_special", passwordRequireSpecial);
        }

        if (passwordRequireUnbreached != null) {
            localVarFormParams.put("password_require_unbreached", passwordRequireUnbreached);
        }

        if (passwordRequirementsApplyToBundles != null) {
            localVarFormParams.put("password_requirements_apply_to_bundles", passwordRequirementsApplyToBundles);
        }

        if (passwordValidityDays != null) {
            localVarFormParams.put("password_validity_days", passwordValidityDays);
        }

        if (pinAllRemoteServersToSiteRegion != null) {
            localVarFormParams.put("pin_all_remote_servers_to_site_region", pinAllRemoteServersToSiteRegion);
        }

        if (replyToEmail != null) {
            localVarFormParams.put("reply_to_email", replyToEmail);
        }

        if (require2fa != null) {
            localVarFormParams.put("require_2fa", require2fa);
        }

        if (require2faUserType != null) {
            localVarFormParams.put("require_2fa_user_type", require2faUserType);
        }

        if (sessionExpiry != null) {
            localVarFormParams.put("session_expiry", sessionExpiry);
        }

        if (sessionExpiryMinutes != null) {
            localVarFormParams.put("session_expiry_minutes", sessionExpiryMinutes);
        }

        if (sessionPinnedByIp != null) {
            localVarFormParams.put("session_pinned_by_ip", sessionPinnedByIp);
        }

        if (sftpEnabled != null) {
            localVarFormParams.put("sftp_enabled", sftpEnabled);
        }

        if (sftpHostKeyType != null) {
            localVarFormParams.put("sftp_host_key_type", sftpHostKeyType);
        }

        if (sftpInsecureCiphers != null) {
            localVarFormParams.put("sftp_insecure_ciphers", sftpInsecureCiphers);
        }

        if (sftpUserRootEnabled != null) {
            localVarFormParams.put("sftp_user_root_enabled", sftpUserRootEnabled);
        }

        if (sharingEnabled != null) {
            localVarFormParams.put("sharing_enabled", sharingEnabled);
        }

        if (showRequestAccessLink != null) {
            localVarFormParams.put("show_request_access_link", showRequestAccessLink);
        }

        if (siteFooter != null) {
            localVarFormParams.put("site_footer", siteFooter);
        }

        if (siteHeader != null) {
            localVarFormParams.put("site_header", siteHeader);
        }

        if (smtpAddress != null) {
            localVarFormParams.put("smtp_address", smtpAddress);
        }

        if (smtpAuthentication != null) {
            localVarFormParams.put("smtp_authentication", smtpAuthentication);
        }

        if (smtpFrom != null) {
            localVarFormParams.put("smtp_from", smtpFrom);
        }

        if (smtpPassword != null) {
            localVarFormParams.put("smtp_password", smtpPassword);
        }

        if (smtpPort != null) {
            localVarFormParams.put("smtp_port", smtpPort);
        }

        if (smtpUsername != null) {
            localVarFormParams.put("smtp_username", smtpUsername);
        }

        if (sslRequired != null) {
            localVarFormParams.put("ssl_required", sslRequired);
        }

        if (subdomain != null) {
            localVarFormParams.put("subdomain", subdomain);
        }

        if (tlsDisabled != null) {
            localVarFormParams.put("tls_disabled", tlsDisabled);
        }

        if (uploadsViaEmailAuthentication != null) {
            localVarFormParams.put("uploads_via_email_authentication", uploadsViaEmailAuthentication);
        }

        if (useProvidedModifiedAt != null) {
            localVarFormParams.put("use_provided_modified_at", useProvidedModifiedAt);
        }

        if (userLockout != null) {
            localVarFormParams.put("user_lockout", userLockout);
        }

        if (userLockoutLockPeriod != null) {
            localVarFormParams.put("user_lockout_lock_period", userLockoutLockPeriod);
        }

        if (userLockoutTries != null) {
            localVarFormParams.put("user_lockout_tries", userLockoutTries);
        }

        if (userLockoutWithin != null) {
            localVarFormParams.put("user_lockout_within", userLockoutWithin);
        }

        if (userRequestsEnabled != null) {
            localVarFormParams.put("user_requests_enabled", userRequestsEnabled);
        }

        if (userRequestsNotifyAdmins != null) {
            localVarFormParams.put("user_requests_notify_admins", userRequestsNotifyAdmins);
        }

        if (welcomeCustomText != null) {
            localVarFormParams.put("welcome_custom_text", welcomeCustomText);
        }

        if (welcomeEmailCc != null) {
            localVarFormParams.put("welcome_email_cc", welcomeEmailCc);
        }

        if (welcomeEmailEnabled != null) {
            localVarFormParams.put("welcome_email_enabled", welcomeEmailEnabled);
        }

        if (welcomeEmailSubject != null) {
            localVarFormParams.put("welcome_email_subject", welcomeEmailSubject);
        }

        if (welcomeScreen != null) {
            localVarFormParams.put("welcome_screen", welcomeScreen);
        }

        if (windowsModeFtp != null) {
            localVarFormParams.put("windows_mode_ftp", windowsModeFtp);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call patchSiteValidateBeforeCall(Integer activeSftpHostKeyId, Boolean allowBundleNames, Boolean allowed2faMethodBypassForFtpSftpDav, Boolean allowed2faMethodSms, Boolean allowed2faMethodTotp, Boolean allowed2faMethodU2f, Boolean allowed2faMethodWebauthn, Boolean allowed2faMethodYubi, String allowedCountries, String allowedIps, Boolean askAboutOverwrites, String bundleActivityNotifications, Integer bundleExpiration, Boolean bundlePasswordRequired, String bundleRegistrationNotifications, Boolean bundleRequireShareRecipient, String bundleUploadReceiptNotifications, Boolean bundleWatermarkAttachmentDelete, File bundleWatermarkAttachmentFile, Object bundleWatermarkValue, String color2Left, String color2Link, String color2Text, String color2Top, String color2TopText, Boolean customNamespace, Integer daysToRetainBackups, String defaultTimeZone, Boolean desktopApp, Boolean desktopAppSessionIpPinning, Integer desktopAppSessionLifetime, Boolean disable2faWithDelay, Boolean disableFilesCertificateGeneration, Boolean disablePasswordReset, Integer disableUsersFromInactivityPeriodDays, String disallowedCountries, String domain, Boolean domainHstsHeader, String domainLetsencryptChain, String email, Boolean folderPermissionsGroupsOnly, Boolean ftpEnabled, Boolean icon128Delete, File icon128File, Boolean icon16Delete, File icon16File, Boolean icon32Delete, File icon32File, Boolean icon48Delete, File icon48File, Boolean immutableFiles, Boolean includePasswordInWelcomeEmail, String language, String ldapBaseDn, String ldapDomain, Boolean ldapEnabled, String ldapGroupAction, String ldapGroupExclusion, String ldapGroupInclusion, String ldapHost, String ldapHost2, String ldapHost3, String ldapPasswordChange, String ldapPasswordChangeConfirmation, Integer ldapPort, Boolean ldapSecure, String ldapType, String ldapUserAction, String ldapUserIncludeGroups, String ldapUsername, String ldapUsernameField, String loginHelpText, Boolean logoDelete, File logoFile, Integer maxPriorPasswords, Boolean mobileApp, Boolean mobileAppSessionIpPinning, Integer mobileAppSessionLifetime, String motdText, Boolean motdUseForFtp, Boolean motdUseForSftp, String name, Boolean nonSsoGroupsAllowed, Boolean nonSsoUsersAllowed, Boolean officeIntegrationAvailable, String officeIntegrationType, Boolean optOutGlobal, Integer passwordMinLength, Boolean passwordRequireLetter, Boolean passwordRequireMixed, Boolean passwordRequireNumber, Boolean passwordRequireSpecial, Boolean passwordRequireUnbreached, Boolean passwordRequirementsApplyToBundles, Integer passwordValidityDays, Boolean pinAllRemoteServersToSiteRegion, String replyToEmail, Boolean require2fa, String require2faUserType, Double sessionExpiry, Integer sessionExpiryMinutes, Boolean sessionPinnedByIp, Boolean sftpEnabled, String sftpHostKeyType, Boolean sftpInsecureCiphers, Boolean sftpUserRootEnabled, Boolean sharingEnabled, Boolean showRequestAccessLink, String siteFooter, String siteHeader, String smtpAddress, String smtpAuthentication, String smtpFrom, String smtpPassword, Integer smtpPort, String smtpUsername, Boolean sslRequired, String subdomain, Boolean tlsDisabled, Boolean uploadsViaEmailAuthentication, Boolean useProvidedModifiedAt, Boolean userLockout, Integer userLockoutLockPeriod, Integer userLockoutTries, Integer userLockoutWithin, Boolean userRequestsEnabled, Boolean userRequestsNotifyAdmins, String welcomeCustomText, String welcomeEmailCc, Boolean welcomeEmailEnabled, String welcomeEmailSubject, String welcomeScreen, Boolean windowsModeFtp, final ApiCallback _callback) throws ApiException {
        return patchSiteCall(activeSftpHostKeyId, allowBundleNames, allowed2faMethodBypassForFtpSftpDav, allowed2faMethodSms, allowed2faMethodTotp, allowed2faMethodU2f, allowed2faMethodWebauthn, allowed2faMethodYubi, allowedCountries, allowedIps, askAboutOverwrites, bundleActivityNotifications, bundleExpiration, bundlePasswordRequired, bundleRegistrationNotifications, bundleRequireShareRecipient, bundleUploadReceiptNotifications, bundleWatermarkAttachmentDelete, bundleWatermarkAttachmentFile, bundleWatermarkValue, color2Left, color2Link, color2Text, color2Top, color2TopText, customNamespace, daysToRetainBackups, defaultTimeZone, desktopApp, desktopAppSessionIpPinning, desktopAppSessionLifetime, disable2faWithDelay, disableFilesCertificateGeneration, disablePasswordReset, disableUsersFromInactivityPeriodDays, disallowedCountries, domain, domainHstsHeader, domainLetsencryptChain, email, folderPermissionsGroupsOnly, ftpEnabled, icon128Delete, icon128File, icon16Delete, icon16File, icon32Delete, icon32File, icon48Delete, icon48File, immutableFiles, includePasswordInWelcomeEmail, language, ldapBaseDn, ldapDomain, ldapEnabled, ldapGroupAction, ldapGroupExclusion, ldapGroupInclusion, ldapHost, ldapHost2, ldapHost3, ldapPasswordChange, ldapPasswordChangeConfirmation, ldapPort, ldapSecure, ldapType, ldapUserAction, ldapUserIncludeGroups, ldapUsername, ldapUsernameField, loginHelpText, logoDelete, logoFile, maxPriorPasswords, mobileApp, mobileAppSessionIpPinning, mobileAppSessionLifetime, motdText, motdUseForFtp, motdUseForSftp, name, nonSsoGroupsAllowed, nonSsoUsersAllowed, officeIntegrationAvailable, officeIntegrationType, optOutGlobal, passwordMinLength, passwordRequireLetter, passwordRequireMixed, passwordRequireNumber, passwordRequireSpecial, passwordRequireUnbreached, passwordRequirementsApplyToBundles, passwordValidityDays, pinAllRemoteServersToSiteRegion, replyToEmail, require2fa, require2faUserType, sessionExpiry, sessionExpiryMinutes, sessionPinnedByIp, sftpEnabled, sftpHostKeyType, sftpInsecureCiphers, sftpUserRootEnabled, sharingEnabled, showRequestAccessLink, siteFooter, siteHeader, smtpAddress, smtpAuthentication, smtpFrom, smtpPassword, smtpPort, smtpUsername, sslRequired, subdomain, tlsDisabled, uploadsViaEmailAuthentication, useProvidedModifiedAt, userLockout, userLockoutLockPeriod, userLockoutTries, userLockoutWithin, userRequestsEnabled, userRequestsNotifyAdmins, welcomeCustomText, welcomeEmailCc, welcomeEmailEnabled, welcomeEmailSubject, welcomeScreen, windowsModeFtp, _callback);

    }

    /**
     * Update site settings.
     * Update site settings.
     * @param activeSftpHostKeyId Id of the currently selected custom SFTP Host Key (optional)
     * @param allowBundleNames Are manual Bundle names allowed? (optional)
     * @param allowed2faMethodBypassForFtpSftpDav Are users allowed to configure their two factor authentication to be bypassed for FTP/SFTP/WebDAV? (optional)
     * @param allowed2faMethodSms Is SMS two factor authentication allowed? (optional)
     * @param allowed2faMethodTotp Is TOTP two factor authentication allowed? (optional)
     * @param allowed2faMethodU2f Is U2F two factor authentication allowed? (optional)
     * @param allowed2faMethodWebauthn Is WebAuthn two factor authentication allowed? (optional)
     * @param allowed2faMethodYubi Is yubikey two factor authentication allowed? (optional)
     * @param allowedCountries Comma seperated list of allowed Country codes (optional)
     * @param allowedIps List of allowed IP addresses (optional)
     * @param askAboutOverwrites If false, rename conflicting files instead of asking for overwrite confirmation.  Only applies to web interface. (optional)
     * @param bundleActivityNotifications Do Bundle owners receive activity notifications? (optional)
     * @param bundleExpiration Site-wide Bundle expiration in days (optional)
     * @param bundlePasswordRequired Do Bundles require password protection? (optional)
     * @param bundleRegistrationNotifications Do Bundle owners receive registration notification? (optional)
     * @param bundleRequireShareRecipient Do Bundles require recipients for sharing? (optional)
     * @param bundleUploadReceiptNotifications Do Bundle uploaders receive upload confirmation notifications? (optional)
     * @param bundleWatermarkAttachmentDelete If true, will delete the file stored in bundle_watermark_attachment (optional)
     * @param bundleWatermarkAttachmentFile  (optional)
     * @param bundleWatermarkValue Preview watermark settings applied to all bundle items. Uses the same keys as Behavior.value (optional)
     * @param color2Left Page link and button color (optional)
     * @param color2Link Top bar link color (optional)
     * @param color2Text Page link and button color (optional)
     * @param color2Top Top bar background color (optional)
     * @param color2TopText Top bar text color (optional)
     * @param customNamespace Is this site using a custom namespace for users? (optional)
     * @param daysToRetainBackups Number of days to keep deleted files (optional)
     * @param defaultTimeZone Site default time zone (optional)
     * @param desktopApp Is the desktop app enabled? (optional)
     * @param desktopAppSessionIpPinning Is desktop app session IP pinning enabled? (optional)
     * @param desktopAppSessionLifetime Desktop app session lifetime (in hours) (optional)
     * @param disable2faWithDelay If set to true, we will begin the process of disabling 2FA on this site. (optional)
     * @param disableFilesCertificateGeneration If set, Files.com will not set the CAA records required to generate future SSL certificates for this domain. (optional)
     * @param disablePasswordReset Is password reset disabled? (optional)
     * @param disableUsersFromInactivityPeriodDays If greater than zero, users will unable to login if they do not show activity within this number of days. (optional)
     * @param disallowedCountries Comma seperated list of disallowed Country codes (optional)
     * @param domain Custom domain (optional)
     * @param domainHstsHeader Send HSTS (HTTP Strict Transport Security) header when visitors access the site via a custom domain? (optional)
     * @param domainLetsencryptChain Letsencrypt chain to use when registering SSL Certificate for domain. (optional)
     * @param email Main email for this site (optional)
     * @param folderPermissionsGroupsOnly If true, permissions for this site must be bound to a group (not a user). Otherwise, permissions must be bound to a user. (optional)
     * @param ftpEnabled Is FTP enabled? (optional)
     * @param icon128Delete If true, will delete the file stored in icon128 (optional)
     * @param icon128File  (optional)
     * @param icon16Delete If true, will delete the file stored in icon16 (optional)
     * @param icon16File  (optional)
     * @param icon32Delete If true, will delete the file stored in icon32 (optional)
     * @param icon32File  (optional)
     * @param icon48Delete If true, will delete the file stored in icon48 (optional)
     * @param icon48File  (optional)
     * @param immutableFiles Are files protected from modification? (optional)
     * @param includePasswordInWelcomeEmail Include password in emails to new users? (optional)
     * @param language Site default language (optional)
     * @param ldapBaseDn Base DN for looking up users in LDAP server (optional)
     * @param ldapDomain Domain name that will be appended to usernames (optional)
     * @param ldapEnabled Main LDAP setting: is LDAP enabled? (optional)
     * @param ldapGroupAction Should we sync groups from LDAP server? (optional)
     * @param ldapGroupExclusion Comma or newline separated list of group names (with optional wildcards) to exclude when syncing. (optional)
     * @param ldapGroupInclusion Comma or newline separated list of group names (with optional wildcards) to include when syncing. (optional)
     * @param ldapHost LDAP host (optional)
     * @param ldapHost2 LDAP backup host (optional)
     * @param ldapHost3 LDAP backup host (optional)
     * @param ldapPasswordChange New LDAP password. (optional)
     * @param ldapPasswordChangeConfirmation Confirm new LDAP password. (optional)
     * @param ldapPort LDAP port (optional)
     * @param ldapSecure Use secure LDAP? (optional)
     * @param ldapType LDAP type (optional)
     * @param ldapUserAction Should we sync users from LDAP server? (optional)
     * @param ldapUserIncludeGroups Comma or newline separated list of group names (with optional wildcards) - if provided, only users in these groups will be added or synced. (optional)
     * @param ldapUsername Username for signing in to LDAP server. (optional)
     * @param ldapUsernameField LDAP username field (optional)
     * @param loginHelpText Login help text (optional)
     * @param logoDelete If true, will delete the file stored in logo (optional)
     * @param logoFile  (optional)
     * @param maxPriorPasswords Number of prior passwords to disallow (optional)
     * @param mobileApp Is the mobile app enabled? (optional)
     * @param mobileAppSessionIpPinning Is mobile app session IP pinning enabled? (optional)
     * @param mobileAppSessionLifetime Mobile app session lifetime (in hours) (optional)
     * @param motdText A message to show users when they connect via FTP or SFTP. (optional)
     * @param motdUseForFtp Show message to users connecting via FTP (optional)
     * @param motdUseForSftp Show message to users connecting via SFTP (optional)
     * @param name Site name (optional)
     * @param nonSsoGroupsAllowed If true, groups can be manually created / modified / deleted by Site Admins. Otherwise, groups can only be managed via your SSO provider. (optional)
     * @param nonSsoUsersAllowed If true, users can be manually created / modified / deleted by Site Admins. Otherwise, users can only be managed via your SSO provider. (optional)
     * @param officeIntegrationAvailable Allow users to use Office for the web? (optional)
     * @param officeIntegrationType Office integration application used to edit and view the MS Office documents (optional)
     * @param optOutGlobal Use servers in the USA only? (optional)
     * @param passwordMinLength Shortest password length for users (optional)
     * @param passwordRequireLetter Require a letter in passwords? (optional)
     * @param passwordRequireMixed Require lower and upper case letters in passwords? (optional)
     * @param passwordRequireNumber Require a number in passwords? (optional)
     * @param passwordRequireSpecial Require special characters in password? (optional)
     * @param passwordRequireUnbreached Require passwords that have not been previously breached? (see https://haveibeenpwned.com/) (optional)
     * @param passwordRequirementsApplyToBundles Require bundles&#39; passwords, and passwords for other items (inboxes, public shares, etc.) to conform to the same requirements as users&#39; passwords? (optional)
     * @param passwordValidityDays Number of days password is valid (optional)
     * @param pinAllRemoteServersToSiteRegion If true, we will ensure that all internal communications with any remote server are made through the primary region of the site. This setting overrides individual remote server settings. (optional)
     * @param replyToEmail Reply-to email for this site (optional)
     * @param require2fa Require two-factor authentication for all users? (optional)
     * @param require2faUserType What type of user is required to use two-factor authentication (when require_2fa is set to &#x60;true&#x60; for this site)? (optional)
     * @param sessionExpiry Session expiry in hours (optional)
     * @param sessionExpiryMinutes Session expiry in minutes (optional)
     * @param sessionPinnedByIp Are sessions locked to the same IP? (i.e. do users need to log in again if they change IPs?) (optional)
     * @param sftpEnabled Is SFTP enabled? (optional)
     * @param sftpHostKeyType Sftp Host Key Type (optional)
     * @param sftpInsecureCiphers Are Insecure Ciphers allowed for SFTP?  Note:  Settting TLS Disabled -&gt; True will always allow insecure ciphers for SFTP as well.  Enabling this is insecure. (optional)
     * @param sftpUserRootEnabled Use user FTP roots also for SFTP? (optional)
     * @param sharingEnabled Allow bundle creation (optional)
     * @param showRequestAccessLink Show request access link for users without access?  Currently unused. (optional)
     * @param siteFooter Custom site footer text (optional)
     * @param siteHeader Custom site header text (optional)
     * @param smtpAddress SMTP server hostname or IP (optional)
     * @param smtpAuthentication SMTP server authentication type (optional)
     * @param smtpFrom From address to use when mailing through custom SMTP (optional)
     * @param smtpPassword Password for SMTP server. (optional)
     * @param smtpPort SMTP server port (optional)
     * @param smtpUsername SMTP server username (optional)
     * @param sslRequired Is SSL required?  Disabling this is insecure. (optional)
     * @param subdomain Site subdomain (optional)
     * @param tlsDisabled Are Insecure TLS and SFTP Ciphers allowed?  Enabling this is insecure. (optional)
     * @param uploadsViaEmailAuthentication Do incoming emails in the Inboxes require checking for SPF/DKIM/DMARC? (optional)
     * @param useProvidedModifiedAt Allow uploaders to set &#x60;provided_modified_at&#x60; for uploaded files? (optional)
     * @param userLockout Will users be locked out after incorrect login attempts? (optional)
     * @param userLockoutLockPeriod How many hours to lock user out for failed password? (optional)
     * @param userLockoutTries Number of login tries within &#x60;user_lockout_within&#x60; hours before users are locked out (optional)
     * @param userLockoutWithin Number of hours for user lockout window (optional)
     * @param userRequestsEnabled Enable User Requests feature (optional)
     * @param userRequestsNotifyAdmins Send email to site admins when a user request is received? (optional)
     * @param welcomeCustomText Custom text send in user welcome email (optional)
     * @param welcomeEmailCc Include this email in welcome emails if enabled (optional)
     * @param welcomeEmailEnabled Will the welcome email be sent to new users? (optional)
     * @param welcomeEmailSubject Include this email subject in welcome emails if enabled (optional)
     * @param welcomeScreen Does the welcome screen appear? (optional)
     * @param windowsModeFtp Does FTP user Windows emulation mode? (optional)
     * @return SiteEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public SiteEntity patchSite(Integer activeSftpHostKeyId, Boolean allowBundleNames, Boolean allowed2faMethodBypassForFtpSftpDav, Boolean allowed2faMethodSms, Boolean allowed2faMethodTotp, Boolean allowed2faMethodU2f, Boolean allowed2faMethodWebauthn, Boolean allowed2faMethodYubi, String allowedCountries, String allowedIps, Boolean askAboutOverwrites, String bundleActivityNotifications, Integer bundleExpiration, Boolean bundlePasswordRequired, String bundleRegistrationNotifications, Boolean bundleRequireShareRecipient, String bundleUploadReceiptNotifications, Boolean bundleWatermarkAttachmentDelete, File bundleWatermarkAttachmentFile, Object bundleWatermarkValue, String color2Left, String color2Link, String color2Text, String color2Top, String color2TopText, Boolean customNamespace, Integer daysToRetainBackups, String defaultTimeZone, Boolean desktopApp, Boolean desktopAppSessionIpPinning, Integer desktopAppSessionLifetime, Boolean disable2faWithDelay, Boolean disableFilesCertificateGeneration, Boolean disablePasswordReset, Integer disableUsersFromInactivityPeriodDays, String disallowedCountries, String domain, Boolean domainHstsHeader, String domainLetsencryptChain, String email, Boolean folderPermissionsGroupsOnly, Boolean ftpEnabled, Boolean icon128Delete, File icon128File, Boolean icon16Delete, File icon16File, Boolean icon32Delete, File icon32File, Boolean icon48Delete, File icon48File, Boolean immutableFiles, Boolean includePasswordInWelcomeEmail, String language, String ldapBaseDn, String ldapDomain, Boolean ldapEnabled, String ldapGroupAction, String ldapGroupExclusion, String ldapGroupInclusion, String ldapHost, String ldapHost2, String ldapHost3, String ldapPasswordChange, String ldapPasswordChangeConfirmation, Integer ldapPort, Boolean ldapSecure, String ldapType, String ldapUserAction, String ldapUserIncludeGroups, String ldapUsername, String ldapUsernameField, String loginHelpText, Boolean logoDelete, File logoFile, Integer maxPriorPasswords, Boolean mobileApp, Boolean mobileAppSessionIpPinning, Integer mobileAppSessionLifetime, String motdText, Boolean motdUseForFtp, Boolean motdUseForSftp, String name, Boolean nonSsoGroupsAllowed, Boolean nonSsoUsersAllowed, Boolean officeIntegrationAvailable, String officeIntegrationType, Boolean optOutGlobal, Integer passwordMinLength, Boolean passwordRequireLetter, Boolean passwordRequireMixed, Boolean passwordRequireNumber, Boolean passwordRequireSpecial, Boolean passwordRequireUnbreached, Boolean passwordRequirementsApplyToBundles, Integer passwordValidityDays, Boolean pinAllRemoteServersToSiteRegion, String replyToEmail, Boolean require2fa, String require2faUserType, Double sessionExpiry, Integer sessionExpiryMinutes, Boolean sessionPinnedByIp, Boolean sftpEnabled, String sftpHostKeyType, Boolean sftpInsecureCiphers, Boolean sftpUserRootEnabled, Boolean sharingEnabled, Boolean showRequestAccessLink, String siteFooter, String siteHeader, String smtpAddress, String smtpAuthentication, String smtpFrom, String smtpPassword, Integer smtpPort, String smtpUsername, Boolean sslRequired, String subdomain, Boolean tlsDisabled, Boolean uploadsViaEmailAuthentication, Boolean useProvidedModifiedAt, Boolean userLockout, Integer userLockoutLockPeriod, Integer userLockoutTries, Integer userLockoutWithin, Boolean userRequestsEnabled, Boolean userRequestsNotifyAdmins, String welcomeCustomText, String welcomeEmailCc, Boolean welcomeEmailEnabled, String welcomeEmailSubject, String welcomeScreen, Boolean windowsModeFtp) throws ApiException {
        ApiResponse<SiteEntity> localVarResp = patchSiteWithHttpInfo(activeSftpHostKeyId, allowBundleNames, allowed2faMethodBypassForFtpSftpDav, allowed2faMethodSms, allowed2faMethodTotp, allowed2faMethodU2f, allowed2faMethodWebauthn, allowed2faMethodYubi, allowedCountries, allowedIps, askAboutOverwrites, bundleActivityNotifications, bundleExpiration, bundlePasswordRequired, bundleRegistrationNotifications, bundleRequireShareRecipient, bundleUploadReceiptNotifications, bundleWatermarkAttachmentDelete, bundleWatermarkAttachmentFile, bundleWatermarkValue, color2Left, color2Link, color2Text, color2Top, color2TopText, customNamespace, daysToRetainBackups, defaultTimeZone, desktopApp, desktopAppSessionIpPinning, desktopAppSessionLifetime, disable2faWithDelay, disableFilesCertificateGeneration, disablePasswordReset, disableUsersFromInactivityPeriodDays, disallowedCountries, domain, domainHstsHeader, domainLetsencryptChain, email, folderPermissionsGroupsOnly, ftpEnabled, icon128Delete, icon128File, icon16Delete, icon16File, icon32Delete, icon32File, icon48Delete, icon48File, immutableFiles, includePasswordInWelcomeEmail, language, ldapBaseDn, ldapDomain, ldapEnabled, ldapGroupAction, ldapGroupExclusion, ldapGroupInclusion, ldapHost, ldapHost2, ldapHost3, ldapPasswordChange, ldapPasswordChangeConfirmation, ldapPort, ldapSecure, ldapType, ldapUserAction, ldapUserIncludeGroups, ldapUsername, ldapUsernameField, loginHelpText, logoDelete, logoFile, maxPriorPasswords, mobileApp, mobileAppSessionIpPinning, mobileAppSessionLifetime, motdText, motdUseForFtp, motdUseForSftp, name, nonSsoGroupsAllowed, nonSsoUsersAllowed, officeIntegrationAvailable, officeIntegrationType, optOutGlobal, passwordMinLength, passwordRequireLetter, passwordRequireMixed, passwordRequireNumber, passwordRequireSpecial, passwordRequireUnbreached, passwordRequirementsApplyToBundles, passwordValidityDays, pinAllRemoteServersToSiteRegion, replyToEmail, require2fa, require2faUserType, sessionExpiry, sessionExpiryMinutes, sessionPinnedByIp, sftpEnabled, sftpHostKeyType, sftpInsecureCiphers, sftpUserRootEnabled, sharingEnabled, showRequestAccessLink, siteFooter, siteHeader, smtpAddress, smtpAuthentication, smtpFrom, smtpPassword, smtpPort, smtpUsername, sslRequired, subdomain, tlsDisabled, uploadsViaEmailAuthentication, useProvidedModifiedAt, userLockout, userLockoutLockPeriod, userLockoutTries, userLockoutWithin, userRequestsEnabled, userRequestsNotifyAdmins, welcomeCustomText, welcomeEmailCc, welcomeEmailEnabled, welcomeEmailSubject, welcomeScreen, windowsModeFtp);
        return localVarResp.getData();
    }

    /**
     * Update site settings.
     * Update site settings.
     * @param activeSftpHostKeyId Id of the currently selected custom SFTP Host Key (optional)
     * @param allowBundleNames Are manual Bundle names allowed? (optional)
     * @param allowed2faMethodBypassForFtpSftpDav Are users allowed to configure their two factor authentication to be bypassed for FTP/SFTP/WebDAV? (optional)
     * @param allowed2faMethodSms Is SMS two factor authentication allowed? (optional)
     * @param allowed2faMethodTotp Is TOTP two factor authentication allowed? (optional)
     * @param allowed2faMethodU2f Is U2F two factor authentication allowed? (optional)
     * @param allowed2faMethodWebauthn Is WebAuthn two factor authentication allowed? (optional)
     * @param allowed2faMethodYubi Is yubikey two factor authentication allowed? (optional)
     * @param allowedCountries Comma seperated list of allowed Country codes (optional)
     * @param allowedIps List of allowed IP addresses (optional)
     * @param askAboutOverwrites If false, rename conflicting files instead of asking for overwrite confirmation.  Only applies to web interface. (optional)
     * @param bundleActivityNotifications Do Bundle owners receive activity notifications? (optional)
     * @param bundleExpiration Site-wide Bundle expiration in days (optional)
     * @param bundlePasswordRequired Do Bundles require password protection? (optional)
     * @param bundleRegistrationNotifications Do Bundle owners receive registration notification? (optional)
     * @param bundleRequireShareRecipient Do Bundles require recipients for sharing? (optional)
     * @param bundleUploadReceiptNotifications Do Bundle uploaders receive upload confirmation notifications? (optional)
     * @param bundleWatermarkAttachmentDelete If true, will delete the file stored in bundle_watermark_attachment (optional)
     * @param bundleWatermarkAttachmentFile  (optional)
     * @param bundleWatermarkValue Preview watermark settings applied to all bundle items. Uses the same keys as Behavior.value (optional)
     * @param color2Left Page link and button color (optional)
     * @param color2Link Top bar link color (optional)
     * @param color2Text Page link and button color (optional)
     * @param color2Top Top bar background color (optional)
     * @param color2TopText Top bar text color (optional)
     * @param customNamespace Is this site using a custom namespace for users? (optional)
     * @param daysToRetainBackups Number of days to keep deleted files (optional)
     * @param defaultTimeZone Site default time zone (optional)
     * @param desktopApp Is the desktop app enabled? (optional)
     * @param desktopAppSessionIpPinning Is desktop app session IP pinning enabled? (optional)
     * @param desktopAppSessionLifetime Desktop app session lifetime (in hours) (optional)
     * @param disable2faWithDelay If set to true, we will begin the process of disabling 2FA on this site. (optional)
     * @param disableFilesCertificateGeneration If set, Files.com will not set the CAA records required to generate future SSL certificates for this domain. (optional)
     * @param disablePasswordReset Is password reset disabled? (optional)
     * @param disableUsersFromInactivityPeriodDays If greater than zero, users will unable to login if they do not show activity within this number of days. (optional)
     * @param disallowedCountries Comma seperated list of disallowed Country codes (optional)
     * @param domain Custom domain (optional)
     * @param domainHstsHeader Send HSTS (HTTP Strict Transport Security) header when visitors access the site via a custom domain? (optional)
     * @param domainLetsencryptChain Letsencrypt chain to use when registering SSL Certificate for domain. (optional)
     * @param email Main email for this site (optional)
     * @param folderPermissionsGroupsOnly If true, permissions for this site must be bound to a group (not a user). Otherwise, permissions must be bound to a user. (optional)
     * @param ftpEnabled Is FTP enabled? (optional)
     * @param icon128Delete If true, will delete the file stored in icon128 (optional)
     * @param icon128File  (optional)
     * @param icon16Delete If true, will delete the file stored in icon16 (optional)
     * @param icon16File  (optional)
     * @param icon32Delete If true, will delete the file stored in icon32 (optional)
     * @param icon32File  (optional)
     * @param icon48Delete If true, will delete the file stored in icon48 (optional)
     * @param icon48File  (optional)
     * @param immutableFiles Are files protected from modification? (optional)
     * @param includePasswordInWelcomeEmail Include password in emails to new users? (optional)
     * @param language Site default language (optional)
     * @param ldapBaseDn Base DN for looking up users in LDAP server (optional)
     * @param ldapDomain Domain name that will be appended to usernames (optional)
     * @param ldapEnabled Main LDAP setting: is LDAP enabled? (optional)
     * @param ldapGroupAction Should we sync groups from LDAP server? (optional)
     * @param ldapGroupExclusion Comma or newline separated list of group names (with optional wildcards) to exclude when syncing. (optional)
     * @param ldapGroupInclusion Comma or newline separated list of group names (with optional wildcards) to include when syncing. (optional)
     * @param ldapHost LDAP host (optional)
     * @param ldapHost2 LDAP backup host (optional)
     * @param ldapHost3 LDAP backup host (optional)
     * @param ldapPasswordChange New LDAP password. (optional)
     * @param ldapPasswordChangeConfirmation Confirm new LDAP password. (optional)
     * @param ldapPort LDAP port (optional)
     * @param ldapSecure Use secure LDAP? (optional)
     * @param ldapType LDAP type (optional)
     * @param ldapUserAction Should we sync users from LDAP server? (optional)
     * @param ldapUserIncludeGroups Comma or newline separated list of group names (with optional wildcards) - if provided, only users in these groups will be added or synced. (optional)
     * @param ldapUsername Username for signing in to LDAP server. (optional)
     * @param ldapUsernameField LDAP username field (optional)
     * @param loginHelpText Login help text (optional)
     * @param logoDelete If true, will delete the file stored in logo (optional)
     * @param logoFile  (optional)
     * @param maxPriorPasswords Number of prior passwords to disallow (optional)
     * @param mobileApp Is the mobile app enabled? (optional)
     * @param mobileAppSessionIpPinning Is mobile app session IP pinning enabled? (optional)
     * @param mobileAppSessionLifetime Mobile app session lifetime (in hours) (optional)
     * @param motdText A message to show users when they connect via FTP or SFTP. (optional)
     * @param motdUseForFtp Show message to users connecting via FTP (optional)
     * @param motdUseForSftp Show message to users connecting via SFTP (optional)
     * @param name Site name (optional)
     * @param nonSsoGroupsAllowed If true, groups can be manually created / modified / deleted by Site Admins. Otherwise, groups can only be managed via your SSO provider. (optional)
     * @param nonSsoUsersAllowed If true, users can be manually created / modified / deleted by Site Admins. Otherwise, users can only be managed via your SSO provider. (optional)
     * @param officeIntegrationAvailable Allow users to use Office for the web? (optional)
     * @param officeIntegrationType Office integration application used to edit and view the MS Office documents (optional)
     * @param optOutGlobal Use servers in the USA only? (optional)
     * @param passwordMinLength Shortest password length for users (optional)
     * @param passwordRequireLetter Require a letter in passwords? (optional)
     * @param passwordRequireMixed Require lower and upper case letters in passwords? (optional)
     * @param passwordRequireNumber Require a number in passwords? (optional)
     * @param passwordRequireSpecial Require special characters in password? (optional)
     * @param passwordRequireUnbreached Require passwords that have not been previously breached? (see https://haveibeenpwned.com/) (optional)
     * @param passwordRequirementsApplyToBundles Require bundles&#39; passwords, and passwords for other items (inboxes, public shares, etc.) to conform to the same requirements as users&#39; passwords? (optional)
     * @param passwordValidityDays Number of days password is valid (optional)
     * @param pinAllRemoteServersToSiteRegion If true, we will ensure that all internal communications with any remote server are made through the primary region of the site. This setting overrides individual remote server settings. (optional)
     * @param replyToEmail Reply-to email for this site (optional)
     * @param require2fa Require two-factor authentication for all users? (optional)
     * @param require2faUserType What type of user is required to use two-factor authentication (when require_2fa is set to &#x60;true&#x60; for this site)? (optional)
     * @param sessionExpiry Session expiry in hours (optional)
     * @param sessionExpiryMinutes Session expiry in minutes (optional)
     * @param sessionPinnedByIp Are sessions locked to the same IP? (i.e. do users need to log in again if they change IPs?) (optional)
     * @param sftpEnabled Is SFTP enabled? (optional)
     * @param sftpHostKeyType Sftp Host Key Type (optional)
     * @param sftpInsecureCiphers Are Insecure Ciphers allowed for SFTP?  Note:  Settting TLS Disabled -&gt; True will always allow insecure ciphers for SFTP as well.  Enabling this is insecure. (optional)
     * @param sftpUserRootEnabled Use user FTP roots also for SFTP? (optional)
     * @param sharingEnabled Allow bundle creation (optional)
     * @param showRequestAccessLink Show request access link for users without access?  Currently unused. (optional)
     * @param siteFooter Custom site footer text (optional)
     * @param siteHeader Custom site header text (optional)
     * @param smtpAddress SMTP server hostname or IP (optional)
     * @param smtpAuthentication SMTP server authentication type (optional)
     * @param smtpFrom From address to use when mailing through custom SMTP (optional)
     * @param smtpPassword Password for SMTP server. (optional)
     * @param smtpPort SMTP server port (optional)
     * @param smtpUsername SMTP server username (optional)
     * @param sslRequired Is SSL required?  Disabling this is insecure. (optional)
     * @param subdomain Site subdomain (optional)
     * @param tlsDisabled Are Insecure TLS and SFTP Ciphers allowed?  Enabling this is insecure. (optional)
     * @param uploadsViaEmailAuthentication Do incoming emails in the Inboxes require checking for SPF/DKIM/DMARC? (optional)
     * @param useProvidedModifiedAt Allow uploaders to set &#x60;provided_modified_at&#x60; for uploaded files? (optional)
     * @param userLockout Will users be locked out after incorrect login attempts? (optional)
     * @param userLockoutLockPeriod How many hours to lock user out for failed password? (optional)
     * @param userLockoutTries Number of login tries within &#x60;user_lockout_within&#x60; hours before users are locked out (optional)
     * @param userLockoutWithin Number of hours for user lockout window (optional)
     * @param userRequestsEnabled Enable User Requests feature (optional)
     * @param userRequestsNotifyAdmins Send email to site admins when a user request is received? (optional)
     * @param welcomeCustomText Custom text send in user welcome email (optional)
     * @param welcomeEmailCc Include this email in welcome emails if enabled (optional)
     * @param welcomeEmailEnabled Will the welcome email be sent to new users? (optional)
     * @param welcomeEmailSubject Include this email subject in welcome emails if enabled (optional)
     * @param welcomeScreen Does the welcome screen appear? (optional)
     * @param windowsModeFtp Does FTP user Windows emulation mode? (optional)
     * @return ApiResponse&lt;SiteEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SiteEntity> patchSiteWithHttpInfo(Integer activeSftpHostKeyId, Boolean allowBundleNames, Boolean allowed2faMethodBypassForFtpSftpDav, Boolean allowed2faMethodSms, Boolean allowed2faMethodTotp, Boolean allowed2faMethodU2f, Boolean allowed2faMethodWebauthn, Boolean allowed2faMethodYubi, String allowedCountries, String allowedIps, Boolean askAboutOverwrites, String bundleActivityNotifications, Integer bundleExpiration, Boolean bundlePasswordRequired, String bundleRegistrationNotifications, Boolean bundleRequireShareRecipient, String bundleUploadReceiptNotifications, Boolean bundleWatermarkAttachmentDelete, File bundleWatermarkAttachmentFile, Object bundleWatermarkValue, String color2Left, String color2Link, String color2Text, String color2Top, String color2TopText, Boolean customNamespace, Integer daysToRetainBackups, String defaultTimeZone, Boolean desktopApp, Boolean desktopAppSessionIpPinning, Integer desktopAppSessionLifetime, Boolean disable2faWithDelay, Boolean disableFilesCertificateGeneration, Boolean disablePasswordReset, Integer disableUsersFromInactivityPeriodDays, String disallowedCountries, String domain, Boolean domainHstsHeader, String domainLetsencryptChain, String email, Boolean folderPermissionsGroupsOnly, Boolean ftpEnabled, Boolean icon128Delete, File icon128File, Boolean icon16Delete, File icon16File, Boolean icon32Delete, File icon32File, Boolean icon48Delete, File icon48File, Boolean immutableFiles, Boolean includePasswordInWelcomeEmail, String language, String ldapBaseDn, String ldapDomain, Boolean ldapEnabled, String ldapGroupAction, String ldapGroupExclusion, String ldapGroupInclusion, String ldapHost, String ldapHost2, String ldapHost3, String ldapPasswordChange, String ldapPasswordChangeConfirmation, Integer ldapPort, Boolean ldapSecure, String ldapType, String ldapUserAction, String ldapUserIncludeGroups, String ldapUsername, String ldapUsernameField, String loginHelpText, Boolean logoDelete, File logoFile, Integer maxPriorPasswords, Boolean mobileApp, Boolean mobileAppSessionIpPinning, Integer mobileAppSessionLifetime, String motdText, Boolean motdUseForFtp, Boolean motdUseForSftp, String name, Boolean nonSsoGroupsAllowed, Boolean nonSsoUsersAllowed, Boolean officeIntegrationAvailable, String officeIntegrationType, Boolean optOutGlobal, Integer passwordMinLength, Boolean passwordRequireLetter, Boolean passwordRequireMixed, Boolean passwordRequireNumber, Boolean passwordRequireSpecial, Boolean passwordRequireUnbreached, Boolean passwordRequirementsApplyToBundles, Integer passwordValidityDays, Boolean pinAllRemoteServersToSiteRegion, String replyToEmail, Boolean require2fa, String require2faUserType, Double sessionExpiry, Integer sessionExpiryMinutes, Boolean sessionPinnedByIp, Boolean sftpEnabled, String sftpHostKeyType, Boolean sftpInsecureCiphers, Boolean sftpUserRootEnabled, Boolean sharingEnabled, Boolean showRequestAccessLink, String siteFooter, String siteHeader, String smtpAddress, String smtpAuthentication, String smtpFrom, String smtpPassword, Integer smtpPort, String smtpUsername, Boolean sslRequired, String subdomain, Boolean tlsDisabled, Boolean uploadsViaEmailAuthentication, Boolean useProvidedModifiedAt, Boolean userLockout, Integer userLockoutLockPeriod, Integer userLockoutTries, Integer userLockoutWithin, Boolean userRequestsEnabled, Boolean userRequestsNotifyAdmins, String welcomeCustomText, String welcomeEmailCc, Boolean welcomeEmailEnabled, String welcomeEmailSubject, String welcomeScreen, Boolean windowsModeFtp) throws ApiException {
        okhttp3.Call localVarCall = patchSiteValidateBeforeCall(activeSftpHostKeyId, allowBundleNames, allowed2faMethodBypassForFtpSftpDav, allowed2faMethodSms, allowed2faMethodTotp, allowed2faMethodU2f, allowed2faMethodWebauthn, allowed2faMethodYubi, allowedCountries, allowedIps, askAboutOverwrites, bundleActivityNotifications, bundleExpiration, bundlePasswordRequired, bundleRegistrationNotifications, bundleRequireShareRecipient, bundleUploadReceiptNotifications, bundleWatermarkAttachmentDelete, bundleWatermarkAttachmentFile, bundleWatermarkValue, color2Left, color2Link, color2Text, color2Top, color2TopText, customNamespace, daysToRetainBackups, defaultTimeZone, desktopApp, desktopAppSessionIpPinning, desktopAppSessionLifetime, disable2faWithDelay, disableFilesCertificateGeneration, disablePasswordReset, disableUsersFromInactivityPeriodDays, disallowedCountries, domain, domainHstsHeader, domainLetsencryptChain, email, folderPermissionsGroupsOnly, ftpEnabled, icon128Delete, icon128File, icon16Delete, icon16File, icon32Delete, icon32File, icon48Delete, icon48File, immutableFiles, includePasswordInWelcomeEmail, language, ldapBaseDn, ldapDomain, ldapEnabled, ldapGroupAction, ldapGroupExclusion, ldapGroupInclusion, ldapHost, ldapHost2, ldapHost3, ldapPasswordChange, ldapPasswordChangeConfirmation, ldapPort, ldapSecure, ldapType, ldapUserAction, ldapUserIncludeGroups, ldapUsername, ldapUsernameField, loginHelpText, logoDelete, logoFile, maxPriorPasswords, mobileApp, mobileAppSessionIpPinning, mobileAppSessionLifetime, motdText, motdUseForFtp, motdUseForSftp, name, nonSsoGroupsAllowed, nonSsoUsersAllowed, officeIntegrationAvailable, officeIntegrationType, optOutGlobal, passwordMinLength, passwordRequireLetter, passwordRequireMixed, passwordRequireNumber, passwordRequireSpecial, passwordRequireUnbreached, passwordRequirementsApplyToBundles, passwordValidityDays, pinAllRemoteServersToSiteRegion, replyToEmail, require2fa, require2faUserType, sessionExpiry, sessionExpiryMinutes, sessionPinnedByIp, sftpEnabled, sftpHostKeyType, sftpInsecureCiphers, sftpUserRootEnabled, sharingEnabled, showRequestAccessLink, siteFooter, siteHeader, smtpAddress, smtpAuthentication, smtpFrom, smtpPassword, smtpPort, smtpUsername, sslRequired, subdomain, tlsDisabled, uploadsViaEmailAuthentication, useProvidedModifiedAt, userLockout, userLockoutLockPeriod, userLockoutTries, userLockoutWithin, userRequestsEnabled, userRequestsNotifyAdmins, welcomeCustomText, welcomeEmailCc, welcomeEmailEnabled, welcomeEmailSubject, welcomeScreen, windowsModeFtp, null);
        Type localVarReturnType = new TypeToken<SiteEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update site settings. (asynchronously)
     * Update site settings.
     * @param activeSftpHostKeyId Id of the currently selected custom SFTP Host Key (optional)
     * @param allowBundleNames Are manual Bundle names allowed? (optional)
     * @param allowed2faMethodBypassForFtpSftpDav Are users allowed to configure their two factor authentication to be bypassed for FTP/SFTP/WebDAV? (optional)
     * @param allowed2faMethodSms Is SMS two factor authentication allowed? (optional)
     * @param allowed2faMethodTotp Is TOTP two factor authentication allowed? (optional)
     * @param allowed2faMethodU2f Is U2F two factor authentication allowed? (optional)
     * @param allowed2faMethodWebauthn Is WebAuthn two factor authentication allowed? (optional)
     * @param allowed2faMethodYubi Is yubikey two factor authentication allowed? (optional)
     * @param allowedCountries Comma seperated list of allowed Country codes (optional)
     * @param allowedIps List of allowed IP addresses (optional)
     * @param askAboutOverwrites If false, rename conflicting files instead of asking for overwrite confirmation.  Only applies to web interface. (optional)
     * @param bundleActivityNotifications Do Bundle owners receive activity notifications? (optional)
     * @param bundleExpiration Site-wide Bundle expiration in days (optional)
     * @param bundlePasswordRequired Do Bundles require password protection? (optional)
     * @param bundleRegistrationNotifications Do Bundle owners receive registration notification? (optional)
     * @param bundleRequireShareRecipient Do Bundles require recipients for sharing? (optional)
     * @param bundleUploadReceiptNotifications Do Bundle uploaders receive upload confirmation notifications? (optional)
     * @param bundleWatermarkAttachmentDelete If true, will delete the file stored in bundle_watermark_attachment (optional)
     * @param bundleWatermarkAttachmentFile  (optional)
     * @param bundleWatermarkValue Preview watermark settings applied to all bundle items. Uses the same keys as Behavior.value (optional)
     * @param color2Left Page link and button color (optional)
     * @param color2Link Top bar link color (optional)
     * @param color2Text Page link and button color (optional)
     * @param color2Top Top bar background color (optional)
     * @param color2TopText Top bar text color (optional)
     * @param customNamespace Is this site using a custom namespace for users? (optional)
     * @param daysToRetainBackups Number of days to keep deleted files (optional)
     * @param defaultTimeZone Site default time zone (optional)
     * @param desktopApp Is the desktop app enabled? (optional)
     * @param desktopAppSessionIpPinning Is desktop app session IP pinning enabled? (optional)
     * @param desktopAppSessionLifetime Desktop app session lifetime (in hours) (optional)
     * @param disable2faWithDelay If set to true, we will begin the process of disabling 2FA on this site. (optional)
     * @param disableFilesCertificateGeneration If set, Files.com will not set the CAA records required to generate future SSL certificates for this domain. (optional)
     * @param disablePasswordReset Is password reset disabled? (optional)
     * @param disableUsersFromInactivityPeriodDays If greater than zero, users will unable to login if they do not show activity within this number of days. (optional)
     * @param disallowedCountries Comma seperated list of disallowed Country codes (optional)
     * @param domain Custom domain (optional)
     * @param domainHstsHeader Send HSTS (HTTP Strict Transport Security) header when visitors access the site via a custom domain? (optional)
     * @param domainLetsencryptChain Letsencrypt chain to use when registering SSL Certificate for domain. (optional)
     * @param email Main email for this site (optional)
     * @param folderPermissionsGroupsOnly If true, permissions for this site must be bound to a group (not a user). Otherwise, permissions must be bound to a user. (optional)
     * @param ftpEnabled Is FTP enabled? (optional)
     * @param icon128Delete If true, will delete the file stored in icon128 (optional)
     * @param icon128File  (optional)
     * @param icon16Delete If true, will delete the file stored in icon16 (optional)
     * @param icon16File  (optional)
     * @param icon32Delete If true, will delete the file stored in icon32 (optional)
     * @param icon32File  (optional)
     * @param icon48Delete If true, will delete the file stored in icon48 (optional)
     * @param icon48File  (optional)
     * @param immutableFiles Are files protected from modification? (optional)
     * @param includePasswordInWelcomeEmail Include password in emails to new users? (optional)
     * @param language Site default language (optional)
     * @param ldapBaseDn Base DN for looking up users in LDAP server (optional)
     * @param ldapDomain Domain name that will be appended to usernames (optional)
     * @param ldapEnabled Main LDAP setting: is LDAP enabled? (optional)
     * @param ldapGroupAction Should we sync groups from LDAP server? (optional)
     * @param ldapGroupExclusion Comma or newline separated list of group names (with optional wildcards) to exclude when syncing. (optional)
     * @param ldapGroupInclusion Comma or newline separated list of group names (with optional wildcards) to include when syncing. (optional)
     * @param ldapHost LDAP host (optional)
     * @param ldapHost2 LDAP backup host (optional)
     * @param ldapHost3 LDAP backup host (optional)
     * @param ldapPasswordChange New LDAP password. (optional)
     * @param ldapPasswordChangeConfirmation Confirm new LDAP password. (optional)
     * @param ldapPort LDAP port (optional)
     * @param ldapSecure Use secure LDAP? (optional)
     * @param ldapType LDAP type (optional)
     * @param ldapUserAction Should we sync users from LDAP server? (optional)
     * @param ldapUserIncludeGroups Comma or newline separated list of group names (with optional wildcards) - if provided, only users in these groups will be added or synced. (optional)
     * @param ldapUsername Username for signing in to LDAP server. (optional)
     * @param ldapUsernameField LDAP username field (optional)
     * @param loginHelpText Login help text (optional)
     * @param logoDelete If true, will delete the file stored in logo (optional)
     * @param logoFile  (optional)
     * @param maxPriorPasswords Number of prior passwords to disallow (optional)
     * @param mobileApp Is the mobile app enabled? (optional)
     * @param mobileAppSessionIpPinning Is mobile app session IP pinning enabled? (optional)
     * @param mobileAppSessionLifetime Mobile app session lifetime (in hours) (optional)
     * @param motdText A message to show users when they connect via FTP or SFTP. (optional)
     * @param motdUseForFtp Show message to users connecting via FTP (optional)
     * @param motdUseForSftp Show message to users connecting via SFTP (optional)
     * @param name Site name (optional)
     * @param nonSsoGroupsAllowed If true, groups can be manually created / modified / deleted by Site Admins. Otherwise, groups can only be managed via your SSO provider. (optional)
     * @param nonSsoUsersAllowed If true, users can be manually created / modified / deleted by Site Admins. Otherwise, users can only be managed via your SSO provider. (optional)
     * @param officeIntegrationAvailable Allow users to use Office for the web? (optional)
     * @param officeIntegrationType Office integration application used to edit and view the MS Office documents (optional)
     * @param optOutGlobal Use servers in the USA only? (optional)
     * @param passwordMinLength Shortest password length for users (optional)
     * @param passwordRequireLetter Require a letter in passwords? (optional)
     * @param passwordRequireMixed Require lower and upper case letters in passwords? (optional)
     * @param passwordRequireNumber Require a number in passwords? (optional)
     * @param passwordRequireSpecial Require special characters in password? (optional)
     * @param passwordRequireUnbreached Require passwords that have not been previously breached? (see https://haveibeenpwned.com/) (optional)
     * @param passwordRequirementsApplyToBundles Require bundles&#39; passwords, and passwords for other items (inboxes, public shares, etc.) to conform to the same requirements as users&#39; passwords? (optional)
     * @param passwordValidityDays Number of days password is valid (optional)
     * @param pinAllRemoteServersToSiteRegion If true, we will ensure that all internal communications with any remote server are made through the primary region of the site. This setting overrides individual remote server settings. (optional)
     * @param replyToEmail Reply-to email for this site (optional)
     * @param require2fa Require two-factor authentication for all users? (optional)
     * @param require2faUserType What type of user is required to use two-factor authentication (when require_2fa is set to &#x60;true&#x60; for this site)? (optional)
     * @param sessionExpiry Session expiry in hours (optional)
     * @param sessionExpiryMinutes Session expiry in minutes (optional)
     * @param sessionPinnedByIp Are sessions locked to the same IP? (i.e. do users need to log in again if they change IPs?) (optional)
     * @param sftpEnabled Is SFTP enabled? (optional)
     * @param sftpHostKeyType Sftp Host Key Type (optional)
     * @param sftpInsecureCiphers Are Insecure Ciphers allowed for SFTP?  Note:  Settting TLS Disabled -&gt; True will always allow insecure ciphers for SFTP as well.  Enabling this is insecure. (optional)
     * @param sftpUserRootEnabled Use user FTP roots also for SFTP? (optional)
     * @param sharingEnabled Allow bundle creation (optional)
     * @param showRequestAccessLink Show request access link for users without access?  Currently unused. (optional)
     * @param siteFooter Custom site footer text (optional)
     * @param siteHeader Custom site header text (optional)
     * @param smtpAddress SMTP server hostname or IP (optional)
     * @param smtpAuthentication SMTP server authentication type (optional)
     * @param smtpFrom From address to use when mailing through custom SMTP (optional)
     * @param smtpPassword Password for SMTP server. (optional)
     * @param smtpPort SMTP server port (optional)
     * @param smtpUsername SMTP server username (optional)
     * @param sslRequired Is SSL required?  Disabling this is insecure. (optional)
     * @param subdomain Site subdomain (optional)
     * @param tlsDisabled Are Insecure TLS and SFTP Ciphers allowed?  Enabling this is insecure. (optional)
     * @param uploadsViaEmailAuthentication Do incoming emails in the Inboxes require checking for SPF/DKIM/DMARC? (optional)
     * @param useProvidedModifiedAt Allow uploaders to set &#x60;provided_modified_at&#x60; for uploaded files? (optional)
     * @param userLockout Will users be locked out after incorrect login attempts? (optional)
     * @param userLockoutLockPeriod How many hours to lock user out for failed password? (optional)
     * @param userLockoutTries Number of login tries within &#x60;user_lockout_within&#x60; hours before users are locked out (optional)
     * @param userLockoutWithin Number of hours for user lockout window (optional)
     * @param userRequestsEnabled Enable User Requests feature (optional)
     * @param userRequestsNotifyAdmins Send email to site admins when a user request is received? (optional)
     * @param welcomeCustomText Custom text send in user welcome email (optional)
     * @param welcomeEmailCc Include this email in welcome emails if enabled (optional)
     * @param welcomeEmailEnabled Will the welcome email be sent to new users? (optional)
     * @param welcomeEmailSubject Include this email subject in welcome emails if enabled (optional)
     * @param welcomeScreen Does the welcome screen appear? (optional)
     * @param windowsModeFtp Does FTP user Windows emulation mode? (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Site object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call patchSiteAsync(Integer activeSftpHostKeyId, Boolean allowBundleNames, Boolean allowed2faMethodBypassForFtpSftpDav, Boolean allowed2faMethodSms, Boolean allowed2faMethodTotp, Boolean allowed2faMethodU2f, Boolean allowed2faMethodWebauthn, Boolean allowed2faMethodYubi, String allowedCountries, String allowedIps, Boolean askAboutOverwrites, String bundleActivityNotifications, Integer bundleExpiration, Boolean bundlePasswordRequired, String bundleRegistrationNotifications, Boolean bundleRequireShareRecipient, String bundleUploadReceiptNotifications, Boolean bundleWatermarkAttachmentDelete, File bundleWatermarkAttachmentFile, Object bundleWatermarkValue, String color2Left, String color2Link, String color2Text, String color2Top, String color2TopText, Boolean customNamespace, Integer daysToRetainBackups, String defaultTimeZone, Boolean desktopApp, Boolean desktopAppSessionIpPinning, Integer desktopAppSessionLifetime, Boolean disable2faWithDelay, Boolean disableFilesCertificateGeneration, Boolean disablePasswordReset, Integer disableUsersFromInactivityPeriodDays, String disallowedCountries, String domain, Boolean domainHstsHeader, String domainLetsencryptChain, String email, Boolean folderPermissionsGroupsOnly, Boolean ftpEnabled, Boolean icon128Delete, File icon128File, Boolean icon16Delete, File icon16File, Boolean icon32Delete, File icon32File, Boolean icon48Delete, File icon48File, Boolean immutableFiles, Boolean includePasswordInWelcomeEmail, String language, String ldapBaseDn, String ldapDomain, Boolean ldapEnabled, String ldapGroupAction, String ldapGroupExclusion, String ldapGroupInclusion, String ldapHost, String ldapHost2, String ldapHost3, String ldapPasswordChange, String ldapPasswordChangeConfirmation, Integer ldapPort, Boolean ldapSecure, String ldapType, String ldapUserAction, String ldapUserIncludeGroups, String ldapUsername, String ldapUsernameField, String loginHelpText, Boolean logoDelete, File logoFile, Integer maxPriorPasswords, Boolean mobileApp, Boolean mobileAppSessionIpPinning, Integer mobileAppSessionLifetime, String motdText, Boolean motdUseForFtp, Boolean motdUseForSftp, String name, Boolean nonSsoGroupsAllowed, Boolean nonSsoUsersAllowed, Boolean officeIntegrationAvailable, String officeIntegrationType, Boolean optOutGlobal, Integer passwordMinLength, Boolean passwordRequireLetter, Boolean passwordRequireMixed, Boolean passwordRequireNumber, Boolean passwordRequireSpecial, Boolean passwordRequireUnbreached, Boolean passwordRequirementsApplyToBundles, Integer passwordValidityDays, Boolean pinAllRemoteServersToSiteRegion, String replyToEmail, Boolean require2fa, String require2faUserType, Double sessionExpiry, Integer sessionExpiryMinutes, Boolean sessionPinnedByIp, Boolean sftpEnabled, String sftpHostKeyType, Boolean sftpInsecureCiphers, Boolean sftpUserRootEnabled, Boolean sharingEnabled, Boolean showRequestAccessLink, String siteFooter, String siteHeader, String smtpAddress, String smtpAuthentication, String smtpFrom, String smtpPassword, Integer smtpPort, String smtpUsername, Boolean sslRequired, String subdomain, Boolean tlsDisabled, Boolean uploadsViaEmailAuthentication, Boolean useProvidedModifiedAt, Boolean userLockout, Integer userLockoutLockPeriod, Integer userLockoutTries, Integer userLockoutWithin, Boolean userRequestsEnabled, Boolean userRequestsNotifyAdmins, String welcomeCustomText, String welcomeEmailCc, Boolean welcomeEmailEnabled, String welcomeEmailSubject, String welcomeScreen, Boolean windowsModeFtp, final ApiCallback<SiteEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = patchSiteValidateBeforeCall(activeSftpHostKeyId, allowBundleNames, allowed2faMethodBypassForFtpSftpDav, allowed2faMethodSms, allowed2faMethodTotp, allowed2faMethodU2f, allowed2faMethodWebauthn, allowed2faMethodYubi, allowedCountries, allowedIps, askAboutOverwrites, bundleActivityNotifications, bundleExpiration, bundlePasswordRequired, bundleRegistrationNotifications, bundleRequireShareRecipient, bundleUploadReceiptNotifications, bundleWatermarkAttachmentDelete, bundleWatermarkAttachmentFile, bundleWatermarkValue, color2Left, color2Link, color2Text, color2Top, color2TopText, customNamespace, daysToRetainBackups, defaultTimeZone, desktopApp, desktopAppSessionIpPinning, desktopAppSessionLifetime, disable2faWithDelay, disableFilesCertificateGeneration, disablePasswordReset, disableUsersFromInactivityPeriodDays, disallowedCountries, domain, domainHstsHeader, domainLetsencryptChain, email, folderPermissionsGroupsOnly, ftpEnabled, icon128Delete, icon128File, icon16Delete, icon16File, icon32Delete, icon32File, icon48Delete, icon48File, immutableFiles, includePasswordInWelcomeEmail, language, ldapBaseDn, ldapDomain, ldapEnabled, ldapGroupAction, ldapGroupExclusion, ldapGroupInclusion, ldapHost, ldapHost2, ldapHost3, ldapPasswordChange, ldapPasswordChangeConfirmation, ldapPort, ldapSecure, ldapType, ldapUserAction, ldapUserIncludeGroups, ldapUsername, ldapUsernameField, loginHelpText, logoDelete, logoFile, maxPriorPasswords, mobileApp, mobileAppSessionIpPinning, mobileAppSessionLifetime, motdText, motdUseForFtp, motdUseForSftp, name, nonSsoGroupsAllowed, nonSsoUsersAllowed, officeIntegrationAvailable, officeIntegrationType, optOutGlobal, passwordMinLength, passwordRequireLetter, passwordRequireMixed, passwordRequireNumber, passwordRequireSpecial, passwordRequireUnbreached, passwordRequirementsApplyToBundles, passwordValidityDays, pinAllRemoteServersToSiteRegion, replyToEmail, require2fa, require2faUserType, sessionExpiry, sessionExpiryMinutes, sessionPinnedByIp, sftpEnabled, sftpHostKeyType, sftpInsecureCiphers, sftpUserRootEnabled, sharingEnabled, showRequestAccessLink, siteFooter, siteHeader, smtpAddress, smtpAuthentication, smtpFrom, smtpPassword, smtpPort, smtpUsername, sslRequired, subdomain, tlsDisabled, uploadsViaEmailAuthentication, useProvidedModifiedAt, userLockout, userLockoutLockPeriod, userLockoutTries, userLockoutWithin, userRequestsEnabled, userRequestsNotifyAdmins, welcomeCustomText, welcomeEmailCc, welcomeEmailEnabled, welcomeEmailSubject, welcomeScreen, windowsModeFtp, _callback);
        Type localVarReturnType = new TypeToken<SiteEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postSiteApiKeys
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSiteApiKeysCall(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/site/api_keys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (description != null) {
            localVarFormParams.put("description", description);
        }

        if (expiresAt != null) {
            localVarFormParams.put("expires_at", expiresAt);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (path != null) {
            localVarFormParams.put("path", path);
        }

        if (permissionSet != null) {
            localVarFormParams.put("permission_set", permissionSet);
        }

        if (userId != null) {
            localVarFormParams.put("user_id", userId);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postSiteApiKeysValidateBeforeCall(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId, final ApiCallback _callback) throws ApiException {
        return postSiteApiKeysCall(description, expiresAt, name, path, permissionSet, userId, _callback);

    }

    /**
     * Create Api Key
     * Create Api Key
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @return ApiKeyEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiKeyEntity postSiteApiKeys(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId) throws ApiException {
        ApiResponse<ApiKeyEntity> localVarResp = postSiteApiKeysWithHttpInfo(description, expiresAt, name, path, permissionSet, userId);
        return localVarResp.getData();
    }

    /**
     * Create Api Key
     * Create Api Key
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @return ApiResponse&lt;ApiKeyEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiKeyEntity> postSiteApiKeysWithHttpInfo(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId) throws ApiException {
        okhttp3.Call localVarCall = postSiteApiKeysValidateBeforeCall(description, expiresAt, name, path, permissionSet, userId, null);
        Type localVarReturnType = new TypeToken<ApiKeyEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Api Key (asynchronously)
     * Create Api Key
     * @param description User-supplied description of API key. (optional)
     * @param expiresAt API Key expiration date (optional)
     * @param name Internal name for the API Key.  For your use. (optional)
     * @param path Folder path restriction for this api key. (optional)
     * @param permissionSet Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know. (optional, default to full)
     * @param userId User ID.  Provide a value of &#x60;0&#x60; to operate the current session&#39;s user. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The ApiKeys object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSiteApiKeysAsync(String description, OffsetDateTime expiresAt, String name, String path, String permissionSet, Integer userId, final ApiCallback<ApiKeyEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postSiteApiKeysValidateBeforeCall(description, expiresAt, name, path, permissionSet, userId, _callback);
        Type localVarReturnType = new TypeToken<ApiKeyEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postSiteTestWebhook
     * @param url URL for testing the webhook. (required)
     * @param action action for test body (optional)
     * @param body Additional body parameters. (optional)
     * @param encoding HTTP encoding method.  Can be JSON, XML, or RAW (form data). (optional)
     * @param headers Additional request headers. (optional)
     * @param method HTTP method(GET or POST). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Behaviors object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSiteTestWebhookCall(String url, String action, Object body, String encoding, Object headers, String method, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/site/test-webhook";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (action != null) {
            localVarFormParams.put("action", action);
        }

        if (body != null) {
            localVarFormParams.put("body", body);
        }

        if (encoding != null) {
            localVarFormParams.put("encoding", encoding);
        }

        if (headers != null) {
            localVarFormParams.put("headers", headers);
        }

        if (method != null) {
            localVarFormParams.put("method", method);
        }

        if (url != null) {
            localVarFormParams.put("url", url);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postSiteTestWebhookValidateBeforeCall(String url, String action, Object body, String encoding, Object headers, String method, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling postSiteTestWebhook(Async)");
        }

        return postSiteTestWebhookCall(url, action, body, encoding, headers, method, _callback);

    }

    /**
     * Test webhook.
     * Test webhook.
     * @param url URL for testing the webhook. (required)
     * @param action action for test body (optional)
     * @param body Additional body parameters. (optional)
     * @param encoding HTTP encoding method.  Can be JSON, XML, or RAW (form data). (optional)
     * @param headers Additional request headers. (optional)
     * @param method HTTP method(GET or POST). (optional)
     * @return StatusEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Behaviors object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public StatusEntity postSiteTestWebhook(String url, String action, Object body, String encoding, Object headers, String method) throws ApiException {
        ApiResponse<StatusEntity> localVarResp = postSiteTestWebhookWithHttpInfo(url, action, body, encoding, headers, method);
        return localVarResp.getData();
    }

    /**
     * Test webhook.
     * Test webhook.
     * @param url URL for testing the webhook. (required)
     * @param action action for test body (optional)
     * @param body Additional body parameters. (optional)
     * @param encoding HTTP encoding method.  Can be JSON, XML, or RAW (form data). (optional)
     * @param headers Additional request headers. (optional)
     * @param method HTTP method(GET or POST). (optional)
     * @return ApiResponse&lt;StatusEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Behaviors object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<StatusEntity> postSiteTestWebhookWithHttpInfo(String url, String action, Object body, String encoding, Object headers, String method) throws ApiException {
        okhttp3.Call localVarCall = postSiteTestWebhookValidateBeforeCall(url, action, body, encoding, headers, method, null);
        Type localVarReturnType = new TypeToken<StatusEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Test webhook. (asynchronously)
     * Test webhook.
     * @param url URL for testing the webhook. (required)
     * @param action action for test body (optional)
     * @param body Additional body parameters. (optional)
     * @param encoding HTTP encoding method.  Can be JSON, XML, or RAW (form data). (optional)
     * @param headers Additional request headers. (optional)
     * @param method HTTP method(GET or POST). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Behaviors object. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> Precondition Failed </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 423 </td><td> Locked </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too Many Requests </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSiteTestWebhookAsync(String url, String action, Object body, String encoding, Object headers, String method, final ApiCallback<StatusEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = postSiteTestWebhookValidateBeforeCall(url, action, body, encoding, headers, method, _callback);
        Type localVarReturnType = new TypeToken<StatusEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
