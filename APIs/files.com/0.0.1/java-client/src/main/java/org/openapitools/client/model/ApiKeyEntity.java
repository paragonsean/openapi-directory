/*
 * Files.com API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@files.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * List Api Keys
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:28:32.972969-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ApiKeyEntity {
  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DESCRIPTIVE_LABEL = "descriptive_label";
  @SerializedName(SERIALIZED_NAME_DESCRIPTIVE_LABEL)
  private String descriptiveLabel;

  public static final String SERIALIZED_NAME_EXPIRES_AT = "expires_at";
  @SerializedName(SERIALIZED_NAME_EXPIRES_AT)
  private OffsetDateTime expiresAt;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Integer id;

  public static final String SERIALIZED_NAME_KEY = "key";
  @SerializedName(SERIALIZED_NAME_KEY)
  private String key;

  public static final String SERIALIZED_NAME_LAST_USE_AT = "last_use_at";
  @SerializedName(SERIALIZED_NAME_LAST_USE_AT)
  private OffsetDateTime lastUseAt;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PATH = "path";
  @SerializedName(SERIALIZED_NAME_PATH)
  private String path;

  /**
   * Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know.
   */
  @JsonAdapter(PermissionSetEnum.Adapter.class)
  public enum PermissionSetEnum {
    NONE("none"),
    
    FULL("full"),
    
    DESKTOP_APP("desktop_app"),
    
    SYNC_APP("sync_app"),
    
    OFFICE_INTEGRATION("office_integration"),
    
    MOBILE_APP("mobile_app");

    private String value;

    PermissionSetEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PermissionSetEnum fromValue(String value) {
      for (PermissionSetEnum b : PermissionSetEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PermissionSetEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PermissionSetEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PermissionSetEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PermissionSetEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PermissionSetEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PERMISSION_SET = "permission_set";
  @SerializedName(SERIALIZED_NAME_PERMISSION_SET)
  private PermissionSetEnum permissionSet;

  public static final String SERIALIZED_NAME_PLATFORM = "platform";
  @SerializedName(SERIALIZED_NAME_PLATFORM)
  private String platform;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private String url;

  public static final String SERIALIZED_NAME_USER_ID = "user_id";
  @SerializedName(SERIALIZED_NAME_USER_ID)
  private Integer userId;

  public ApiKeyEntity() {
  }

  public ApiKeyEntity createdAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
    return this;
  }

  /**
   * Time which API Key was created
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public ApiKeyEntity description(String description) {
    this.description = description;
    return this;
  }

  /**
   * User-supplied description of API key.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public ApiKeyEntity descriptiveLabel(String descriptiveLabel) {
    this.descriptiveLabel = descriptiveLabel;
    return this;
  }

  /**
   * Unique label that describes this API key.  Useful for external systems where you may have API keys from multiple accounts and want a human-readable label for each key.
   * @return descriptiveLabel
   */
  @javax.annotation.Nullable
  public String getDescriptiveLabel() {
    return descriptiveLabel;
  }

  public void setDescriptiveLabel(String descriptiveLabel) {
    this.descriptiveLabel = descriptiveLabel;
  }


  public ApiKeyEntity expiresAt(OffsetDateTime expiresAt) {
    this.expiresAt = expiresAt;
    return this;
  }

  /**
   * API Key expiration date
   * @return expiresAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getExpiresAt() {
    return expiresAt;
  }

  public void setExpiresAt(OffsetDateTime expiresAt) {
    this.expiresAt = expiresAt;
  }


  public ApiKeyEntity id(Integer id) {
    this.id = id;
    return this;
  }

  /**
   * API Key ID
   * @return id
   */
  @javax.annotation.Nullable
  public Integer getId() {
    return id;
  }

  public void setId(Integer id) {
    this.id = id;
  }


  public ApiKeyEntity key(String key) {
    this.key = key;
    return this;
  }

  /**
   * API Key actual key string
   * @return key
   */
  @javax.annotation.Nullable
  public String getKey() {
    return key;
  }

  public void setKey(String key) {
    this.key = key;
  }


  public ApiKeyEntity lastUseAt(OffsetDateTime lastUseAt) {
    this.lastUseAt = lastUseAt;
    return this;
  }

  /**
   * API Key last used - note this value is only updated once per 3 hour period, so the &#39;actual&#39; time of last use may be up to 3 hours later than this timestamp.
   * @return lastUseAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastUseAt() {
    return lastUseAt;
  }

  public void setLastUseAt(OffsetDateTime lastUseAt) {
    this.lastUseAt = lastUseAt;
  }


  public ApiKeyEntity name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Internal name for the API Key.  For your use.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public ApiKeyEntity path(String path) {
    this.path = path;
    return this;
  }

  /**
   * Folder path restriction for this api key.
   * @return path
   */
  @javax.annotation.Nullable
  public String getPath() {
    return path;
  }

  public void setPath(String path) {
    this.path = path;
  }


  public ApiKeyEntity permissionSet(PermissionSetEnum permissionSet) {
    this.permissionSet = permissionSet;
    return this;
  }

  /**
   * Permissions for this API Key.  Keys with the &#x60;desktop_app&#x60; permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know.
   * @return permissionSet
   */
  @javax.annotation.Nullable
  public PermissionSetEnum getPermissionSet() {
    return permissionSet;
  }

  public void setPermissionSet(PermissionSetEnum permissionSet) {
    this.permissionSet = permissionSet;
  }


  public ApiKeyEntity platform(String platform) {
    this.platform = platform;
    return this;
  }

  /**
   * If this API key represents a Desktop app, what platform was it created on?
   * @return platform
   */
  @javax.annotation.Nullable
  public String getPlatform() {
    return platform;
  }

  public void setPlatform(String platform) {
    this.platform = platform;
  }


  public ApiKeyEntity url(String url) {
    this.url = url;
    return this;
  }

  /**
   * URL for API host.
   * @return url
   */
  @javax.annotation.Nullable
  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }


  public ApiKeyEntity userId(Integer userId) {
    this.userId = userId;
    return this;
  }

  /**
   * User ID for the owner of this API Key.  May be blank for Site-wide API Keys.
   * @return userId
   */
  @javax.annotation.Nullable
  public Integer getUserId() {
    return userId;
  }

  public void setUserId(Integer userId) {
    this.userId = userId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApiKeyEntity apiKeyEntity = (ApiKeyEntity) o;
    return Objects.equals(this.createdAt, apiKeyEntity.createdAt) &&
        Objects.equals(this.description, apiKeyEntity.description) &&
        Objects.equals(this.descriptiveLabel, apiKeyEntity.descriptiveLabel) &&
        Objects.equals(this.expiresAt, apiKeyEntity.expiresAt) &&
        Objects.equals(this.id, apiKeyEntity.id) &&
        Objects.equals(this.key, apiKeyEntity.key) &&
        Objects.equals(this.lastUseAt, apiKeyEntity.lastUseAt) &&
        Objects.equals(this.name, apiKeyEntity.name) &&
        Objects.equals(this.path, apiKeyEntity.path) &&
        Objects.equals(this.permissionSet, apiKeyEntity.permissionSet) &&
        Objects.equals(this.platform, apiKeyEntity.platform) &&
        Objects.equals(this.url, apiKeyEntity.url) &&
        Objects.equals(this.userId, apiKeyEntity.userId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createdAt, description, descriptiveLabel, expiresAt, id, key, lastUseAt, name, path, permissionSet, platform, url, userId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApiKeyEntity {\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    descriptiveLabel: ").append(toIndentedString(descriptiveLabel)).append("\n");
    sb.append("    expiresAt: ").append(toIndentedString(expiresAt)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    lastUseAt: ").append(toIndentedString(lastUseAt)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    permissionSet: ").append(toIndentedString(permissionSet)).append("\n");
    sb.append("    platform: ").append(toIndentedString(platform)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    userId: ").append(toIndentedString(userId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("created_at");
    openapiFields.add("description");
    openapiFields.add("descriptive_label");
    openapiFields.add("expires_at");
    openapiFields.add("id");
    openapiFields.add("key");
    openapiFields.add("last_use_at");
    openapiFields.add("name");
    openapiFields.add("path");
    openapiFields.add("permission_set");
    openapiFields.add("platform");
    openapiFields.add("url");
    openapiFields.add("user_id");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ApiKeyEntity
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ApiKeyEntity.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApiKeyEntity is not found in the empty JSON string", ApiKeyEntity.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ApiKeyEntity.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ApiKeyEntity` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("descriptive_label") != null && !jsonObj.get("descriptive_label").isJsonNull()) && !jsonObj.get("descriptive_label").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `descriptive_label` to be a primitive type in the JSON string but got `%s`", jsonObj.get("descriptive_label").toString()));
      }
      if ((jsonObj.get("key") != null && !jsonObj.get("key").isJsonNull()) && !jsonObj.get("key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("path") != null && !jsonObj.get("path").isJsonNull()) && !jsonObj.get("path").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `path` to be a primitive type in the JSON string but got `%s`", jsonObj.get("path").toString()));
      }
      if ((jsonObj.get("permission_set") != null && !jsonObj.get("permission_set").isJsonNull()) && !jsonObj.get("permission_set").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `permission_set` to be a primitive type in the JSON string but got `%s`", jsonObj.get("permission_set").toString()));
      }
      // validate the optional field `permission_set`
      if (jsonObj.get("permission_set") != null && !jsonObj.get("permission_set").isJsonNull()) {
        PermissionSetEnum.validateJsonElement(jsonObj.get("permission_set"));
      }
      if ((jsonObj.get("platform") != null && !jsonObj.get("platform").isJsonNull()) && !jsonObj.get("platform").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `platform` to be a primitive type in the JSON string but got `%s`", jsonObj.get("platform").toString()));
      }
      if ((jsonObj.get("url") != null && !jsonObj.get("url").isJsonNull()) && !jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApiKeyEntity.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApiKeyEntity' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApiKeyEntity> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApiKeyEntity.class));

       return (TypeAdapter<T>) new TypeAdapter<ApiKeyEntity>() {
           @Override
           public void write(JsonWriter out, ApiKeyEntity value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ApiKeyEntity read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ApiKeyEntity given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ApiKeyEntity
   * @throws IOException if the JSON string is invalid with respect to ApiKeyEntity
   */
  public static ApiKeyEntity fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApiKeyEntity.class);
  }

  /**
   * Convert an instance of ApiKeyEntity to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

