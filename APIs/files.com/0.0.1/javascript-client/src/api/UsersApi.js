/**
 * Files.com API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@files.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import ApiKeyEntity from '../model/ApiKeyEntity';
import GroupUserEntity from '../model/GroupUserEntity';
import PermissionEntity from '../model/PermissionEntity';
import PublicKeyEntity from '../model/PublicKeyEntity';
import UserCipherUseEntity from '../model/UserCipherUseEntity';
import UserEntity from '../model/UserEntity';

/**
* Users service.
* @module api/UsersApi
* @version 0.0.1
*/
export default class UsersApi {

    /**
    * Constructs a new UsersApi. 
    * @alias module:api/UsersApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the deleteUsersId operation.
     * @callback module:api/UsersApi~deleteUsersIdCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Delete User
     * Delete User
     * @param {Number} id User ID.
     * @param {module:api/UsersApi~deleteUsersIdCallback} callback The callback function, accepting three arguments: error, data, response
     */
    deleteUsersId(id, callback) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling deleteUsersId");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/users/{id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getUsers operation.
     * @callback module:api/UsersApi~getUsersCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/UserEntity>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List Users
     * List Users
     * @param {Object} opts Optional parameters
     * @param {String} [cursor] Used for pagination.  When a list request has more records available, cursors are provided in the response headers `X-Files-Cursor-Next` and `X-Files-Cursor-Prev`.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination.
     * @param {Number} [perPage] Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended).
     * @param {Object.<String, Object>} [sortBy] If set, sort records by the specified field in either `asc` or `desc` direction (e.g. `sort_by[authenticate_until]=desc`). Valid fields are `authenticate_until`, `active`, `email`, `last_desktop_login_at`, `last_login_at`, `username`, `company`, `name`, `site_admin`, `receive_admin_alerts`, `password_validity_days`, `ssl_required` or `not_site_admin`.
     * @param {Object.<String, Object>} [filter] If set, return records where the specified field is equal to the supplied value. Valid fields are `username`, `email`, `company`, `site_admin`, `password_validity_days`, `ssl_required`, `last_login_at`, `authenticate_until` or `not_site_admin`. Valid field combinations are `[ not_site_admin, username ]`.
     * @param {Object.<String, Object>} [filterGt] If set, return records where the specified field is greater than the supplied value. Valid fields are `password_validity_days`, `last_login_at` or `authenticate_until`.
     * @param {Object.<String, Object>} [filterGteq] If set, return records where the specified field is greater than or equal the supplied value. Valid fields are `password_validity_days`, `last_login_at` or `authenticate_until`.
     * @param {Object.<String, Object>} [filterPrefix] If set, return records where the specified field is prefixed by the supplied value. Valid fields are `username`, `email` or `company`.
     * @param {Object.<String, Object>} [filterLt] If set, return records where the specified field is less than the supplied value. Valid fields are `password_validity_days`, `last_login_at` or `authenticate_until`.
     * @param {Object.<String, Object>} [filterLteq] If set, return records where the specified field is less than or equal the supplied value. Valid fields are `password_validity_days`, `last_login_at` or `authenticate_until`.
     * @param {String} [ids] comma-separated list of User IDs
     * @param {String} [qUsername] List users matching username.
     * @param {String} [qEmail] List users matching email.
     * @param {String} [qNotes] List users matching notes field.
     * @param {String} [qAdmin] If `true`, list only admin users.
     * @param {String} [qAllowedIps] If set, list only users with overridden allowed IP setting.
     * @param {String} [qPasswordValidityDays] If set, list only users with overridden password validity days setting.
     * @param {String} [qSslRequired] If set, list only users with overridden SSL required setting.
     * @param {String} [search] Searches for partial matches of name, username, or email.
     * @param {module:api/UsersApi~getUsersCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/UserEntity>}
     */
    getUsers(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'cursor': opts['cursor'],
        'per_page': opts['perPage'],
        'sort_by': opts['sortBy'],
        'filter': opts['filter'],
        'filter_gt': opts['filterGt'],
        'filter_gteq': opts['filterGteq'],
        'filter_prefix': opts['filterPrefix'],
        'filter_lt': opts['filterLt'],
        'filter_lteq': opts['filterLteq'],
        'ids': opts['ids'],
        'q[username]': opts['qUsername'],
        'q[email]': opts['qEmail'],
        'q[notes]': opts['qNotes'],
        'q[admin]': opts['qAdmin'],
        'q[allowed_ips]': opts['qAllowedIps'],
        'q[password_validity_days]': opts['qPasswordValidityDays'],
        'q[ssl_required]': opts['qSslRequired'],
        'search': opts['search']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [UserEntity];
      return this.apiClient.callApi(
        '/users', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getUsersId operation.
     * @callback module:api/UsersApi~getUsersIdCallback
     * @param {String} error Error message, if any.
     * @param {module:model/UserEntity} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Show User
     * Show User
     * @param {Number} id User ID.
     * @param {module:api/UsersApi~getUsersIdCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/UserEntity}
     */
    getUsersId(id, callback) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling getUsersId");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = UserEntity;
      return this.apiClient.callApi(
        '/users/{id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getUsersUserIdApiKeys operation.
     * @callback module:api/UsersApi~getUsersUserIdApiKeysCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/ApiKeyEntity>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List Api Keys
     * List Api Keys
     * @param {Number} userId User ID.  Provide a value of `0` to operate the current session's user.
     * @param {Object} opts Optional parameters
     * @param {String} [cursor] Used for pagination.  When a list request has more records available, cursors are provided in the response headers `X-Files-Cursor-Next` and `X-Files-Cursor-Prev`.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination.
     * @param {Number} [perPage] Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended).
     * @param {Object.<String, Object>} [sortBy] If set, sort records by the specified field in either `asc` or `desc` direction (e.g. `sort_by[expires_at]=desc`). Valid fields are `expires_at`.
     * @param {Object.<String, Object>} [filter] If set, return records where the specified field is equal to the supplied value. Valid fields are `expires_at`.
     * @param {Object.<String, Object>} [filterGt] If set, return records where the specified field is greater than the supplied value. Valid fields are `expires_at`.
     * @param {Object.<String, Object>} [filterGteq] If set, return records where the specified field is greater than or equal the supplied value. Valid fields are `expires_at`.
     * @param {Object.<String, Object>} [filterLt] If set, return records where the specified field is less than the supplied value. Valid fields are `expires_at`.
     * @param {Object.<String, Object>} [filterLteq] If set, return records where the specified field is less than or equal the supplied value. Valid fields are `expires_at`.
     * @param {module:api/UsersApi~getUsersUserIdApiKeysCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/ApiKeyEntity>}
     */
    getUsersUserIdApiKeys(userId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling getUsersUserIdApiKeys");
      }

      let pathParams = {
        'user_id': userId
      };
      let queryParams = {
        'cursor': opts['cursor'],
        'per_page': opts['perPage'],
        'sort_by': opts['sortBy'],
        'filter': opts['filter'],
        'filter_gt': opts['filterGt'],
        'filter_gteq': opts['filterGteq'],
        'filter_lt': opts['filterLt'],
        'filter_lteq': opts['filterLteq']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [ApiKeyEntity];
      return this.apiClient.callApi(
        '/users/{user_id}/api_keys', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getUsersUserIdCipherUses operation.
     * @callback module:api/UsersApi~getUsersUserIdCipherUsesCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/UserCipherUseEntity>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List User Cipher Uses
     * List User Cipher Uses
     * @param {Number} userId User ID.  Provide a value of `0` to operate the current session's user.
     * @param {Object} opts Optional parameters
     * @param {String} [cursor] Used for pagination.  When a list request has more records available, cursors are provided in the response headers `X-Files-Cursor-Next` and `X-Files-Cursor-Prev`.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination.
     * @param {Number} [perPage] Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended).
     * @param {module:api/UsersApi~getUsersUserIdCipherUsesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/UserCipherUseEntity>}
     */
    getUsersUserIdCipherUses(userId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling getUsersUserIdCipherUses");
      }

      let pathParams = {
        'user_id': userId
      };
      let queryParams = {
        'cursor': opts['cursor'],
        'per_page': opts['perPage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [UserCipherUseEntity];
      return this.apiClient.callApi(
        '/users/{user_id}/cipher_uses', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getUsersUserIdGroups operation.
     * @callback module:api/UsersApi~getUsersUserIdGroupsCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/GroupUserEntity>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List Group Users
     * List Group Users
     * @param {Number} userId User ID.  If provided, will return group_users of this user.
     * @param {Object} opts Optional parameters
     * @param {String} [cursor] Used for pagination.  When a list request has more records available, cursors are provided in the response headers `X-Files-Cursor-Next` and `X-Files-Cursor-Prev`.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination.
     * @param {Number} [perPage] Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended).
     * @param {Number} [groupId] Group ID.  If provided, will return group_users of this group.
     * @param {module:api/UsersApi~getUsersUserIdGroupsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/GroupUserEntity>}
     */
    getUsersUserIdGroups(userId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling getUsersUserIdGroups");
      }

      let pathParams = {
        'user_id': userId
      };
      let queryParams = {
        'cursor': opts['cursor'],
        'per_page': opts['perPage'],
        'group_id': opts['groupId']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [GroupUserEntity];
      return this.apiClient.callApi(
        '/users/{user_id}/groups', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getUsersUserIdPermissions operation.
     * @callback module:api/UsersApi~getUsersUserIdPermissionsCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/PermissionEntity>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List Permissions
     * List Permissions
     * @param {String} userId DEPRECATED: User ID.  If provided, will scope permissions to this user. Use `filter[user_id]` instead.`
     * @param {Object} opts Optional parameters
     * @param {String} [cursor] Used for pagination.  When a list request has more records available, cursors are provided in the response headers `X-Files-Cursor-Next` and `X-Files-Cursor-Prev`.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination.
     * @param {Number} [perPage] Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended).
     * @param {Object.<String, Object>} [sortBy] If set, sort records by the specified field in either `asc` or `desc` direction (e.g. `sort_by[group_id]=desc`). Valid fields are `group_id`, `path`, `user_id` or `permission`.
     * @param {Object.<String, Object>} [filter] If set, return records where the specified field is equal to the supplied value. Valid fields are `group_id`, `user_id` or `path`. Valid field combinations are `[ group_id, path ]` and `[ user_id, path ]`.
     * @param {Object.<String, Object>} [filterPrefix] If set, return records where the specified field is prefixed by the supplied value. Valid fields are `path`.
     * @param {String} [path] DEPRECATED: Permission path.  If provided, will scope permissions to this path. Use `filter[path]` instead.
     * @param {String} [groupId] DEPRECATED: Group ID.  If provided, will scope permissions to this group. Use `filter[group_id]` instead.`
     * @param {Boolean} [includeGroups] If searching by user or group, also include user's permissions that are inherited from its groups?
     * @param {module:api/UsersApi~getUsersUserIdPermissionsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/PermissionEntity>}
     */
    getUsersUserIdPermissions(userId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling getUsersUserIdPermissions");
      }

      let pathParams = {
        'user_id': userId
      };
      let queryParams = {
        'cursor': opts['cursor'],
        'per_page': opts['perPage'],
        'sort_by': opts['sortBy'],
        'filter': opts['filter'],
        'filter_prefix': opts['filterPrefix'],
        'path': opts['path'],
        'group_id': opts['groupId'],
        'include_groups': opts['includeGroups']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [PermissionEntity];
      return this.apiClient.callApi(
        '/users/{user_id}/permissions', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getUsersUserIdPublicKeys operation.
     * @callback module:api/UsersApi~getUsersUserIdPublicKeysCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/PublicKeyEntity>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List Public Keys
     * List Public Keys
     * @param {Number} userId User ID.  Provide a value of `0` to operate the current session's user.
     * @param {Object} opts Optional parameters
     * @param {String} [cursor] Used for pagination.  When a list request has more records available, cursors are provided in the response headers `X-Files-Cursor-Next` and `X-Files-Cursor-Prev`.  Send one of those cursor value here to resume an existing list from the next available record.  Note: many of our SDKs have iterator methods that will automatically handle cursor-based pagination.
     * @param {Number} [perPage] Number of records to show per page.  (Max: 10,000, 1,000 or less is recommended).
     * @param {module:api/UsersApi~getUsersUserIdPublicKeysCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/PublicKeyEntity>}
     */
    getUsersUserIdPublicKeys(userId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling getUsersUserIdPublicKeys");
      }

      let pathParams = {
        'user_id': userId
      };
      let queryParams = {
        'cursor': opts['cursor'],
        'per_page': opts['perPage']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [PublicKeyEntity];
      return this.apiClient.callApi(
        '/users/{user_id}/public_keys', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the patchUsersId operation.
     * @callback module:api/UsersApi~patchUsersIdCallback
     * @param {String} error Error message, if any.
     * @param {module:model/UserEntity} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update User
     * Update User
     * @param {Number} id User ID.
     * @param {Object} opts Optional parameters
     * @param {String} [allowedIps] A list of allowed IPs if applicable.  Newline delimited
     * @param {Boolean} [announcementsRead] Signifies that the user has read all the announcements in the UI.
     * @param {Boolean} [attachmentsPermission] DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead.
     * @param {Date} [authenticateUntil] Scheduled Date/Time at which user will be deactivated
     * @param {module:model/String} [authenticationMethod] How is this user authenticated?
     * @param {Boolean} [avatarDelete] If true, the avatar will be deleted.
     * @param {File} [avatarFile] An image file for your user avatar.
     * @param {Boolean} [billingPermission] Allow this user to perform operations on the account, payments, and invoices?
     * @param {Boolean} [bypassInactiveDisable] Exempt this user from being disabled based on inactivity?
     * @param {Boolean} [bypassSiteAllowedIps] Allow this user to skip site-wide IP blacklists?
     * @param {String} [changePassword] Used for changing a password on an existing user.
     * @param {String} [changePasswordConfirmation] Optional, but if provided, we will ensure that it matches the value sent in `change_password`.
     * @param {String} [company] User's company
     * @param {Boolean} [davPermission] Can the user connect with WebDAV?
     * @param {Boolean} [disabled] Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting.
     * @param {String} [email] User's email.
     * @param {Boolean} [ftpPermission] Can the user access with FTP/FTPS?
     * @param {String} [grantPermission] Permission to grant on the user root.  Can be blank or `full`, `read`, `write`, `list`, `read+write`, or `list+write`
     * @param {Number} [groupId] Group ID to associate this user with.
     * @param {String} [groupIds] A list of group ids to associate this user with.  Comma delimited.
     * @param {String} [headerText] Text to display to the user in the header of the UI
     * @param {String} [importedPasswordHash] Pre-calculated hash of the user's password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256.
     * @param {String} [language] Preferred language
     * @param {String} [name] User's full name
     * @param {String} [notes] Any internal notes on the user
     * @param {Number} [notificationDailySendTime] Hour of the day at which daily notifications should be sent. Can be in range 0 to 23
     * @param {Boolean} [officeIntegrationEnabled] Enable integration with Office for the web?
     * @param {String} [password] User password.
     * @param {String} [passwordConfirmation] Optional, but if provided, we will ensure that it matches the value sent in `password`.
     * @param {Number} [passwordValidityDays] Number of days to allow user to use the same password
     * @param {Boolean} [receiveAdminAlerts] Should the user receive admin alerts such a certificate expiration notifications and overages?
     * @param {module:model/String} [require2fa] 2FA required setting
     * @param {Boolean} [requirePasswordChange] Is a password change required upon next user login?
     * @param {Boolean} [restapiPermission] Can this user access the REST API?
     * @param {Boolean} [selfManaged] Does this user manage it's own credentials or is it a shared/bot user?
     * @param {Boolean} [sftpPermission] Can the user access with SFTP?
     * @param {Boolean} [siteAdmin] Is the user an administrator for this site?
     * @param {Boolean} [skipWelcomeScreen] Skip Welcome page in the UI?
     * @param {module:model/String} [sslRequired] SSL required setting
     * @param {Number} [ssoStrategyId] SSO (Single Sign On) strategy ID for the user, if applicable.
     * @param {Boolean} [subscribeToNewsletter] Is the user subscribed to the newsletter?
     * @param {String} [timeZone] User time zone
     * @param {String} [userRoot] Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface.
     * @param {String} [username] User's username
     * @param {module:api/UsersApi~patchUsersIdCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/UserEntity}
     */
    patchUsersId(id, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling patchUsersId");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'allowed_ips': opts['allowedIps'],
        'announcements_read': opts['announcementsRead'],
        'attachments_permission': opts['attachmentsPermission'],
        'authenticate_until': opts['authenticateUntil'],
        'authentication_method': opts['authenticationMethod'],
        'avatar_delete': opts['avatarDelete'],
        'avatar_file': opts['avatarFile'],
        'billing_permission': opts['billingPermission'],
        'bypass_inactive_disable': opts['bypassInactiveDisable'],
        'bypass_site_allowed_ips': opts['bypassSiteAllowedIps'],
        'change_password': opts['changePassword'],
        'change_password_confirmation': opts['changePasswordConfirmation'],
        'company': opts['company'],
        'dav_permission': opts['davPermission'],
        'disabled': opts['disabled'],
        'email': opts['email'],
        'ftp_permission': opts['ftpPermission'],
        'grant_permission': opts['grantPermission'],
        'group_id': opts['groupId'],
        'group_ids': opts['groupIds'],
        'header_text': opts['headerText'],
        'imported_password_hash': opts['importedPasswordHash'],
        'language': opts['language'],
        'name': opts['name'],
        'notes': opts['notes'],
        'notification_daily_send_time': opts['notificationDailySendTime'],
        'office_integration_enabled': opts['officeIntegrationEnabled'],
        'password': opts['password'],
        'password_confirmation': opts['passwordConfirmation'],
        'password_validity_days': opts['passwordValidityDays'],
        'receive_admin_alerts': opts['receiveAdminAlerts'],
        'require_2fa': opts['require2fa'],
        'require_password_change': opts['requirePasswordChange'],
        'restapi_permission': opts['restapiPermission'],
        'self_managed': opts['selfManaged'],
        'sftp_permission': opts['sftpPermission'],
        'site_admin': opts['siteAdmin'],
        'skip_welcome_screen': opts['skipWelcomeScreen'],
        'ssl_required': opts['sslRequired'],
        'sso_strategy_id': opts['ssoStrategyId'],
        'subscribe_to_newsletter': opts['subscribeToNewsletter'],
        'time_zone': opts['timeZone'],
        'user_root': opts['userRoot'],
        'username': opts['username']
      };

      let authNames = [];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = UserEntity;
      return this.apiClient.callApi(
        '/users/{id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the postUsers operation.
     * @callback module:api/UsersApi~postUsersCallback
     * @param {String} error Error message, if any.
     * @param {module:model/UserEntity} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create User
     * Create User
     * @param {Object} opts Optional parameters
     * @param {String} [allowedIps] A list of allowed IPs if applicable.  Newline delimited
     * @param {Boolean} [announcementsRead] Signifies that the user has read all the announcements in the UI.
     * @param {Boolean} [attachmentsPermission] DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead.
     * @param {Date} [authenticateUntil] Scheduled Date/Time at which user will be deactivated
     * @param {module:model/String} [authenticationMethod] How is this user authenticated?
     * @param {Boolean} [avatarDelete] If true, the avatar will be deleted.
     * @param {File} [avatarFile] An image file for your user avatar.
     * @param {Boolean} [billingPermission] Allow this user to perform operations on the account, payments, and invoices?
     * @param {Boolean} [bypassInactiveDisable] Exempt this user from being disabled based on inactivity?
     * @param {Boolean} [bypassSiteAllowedIps] Allow this user to skip site-wide IP blacklists?
     * @param {String} [changePassword] Used for changing a password on an existing user.
     * @param {String} [changePasswordConfirmation] Optional, but if provided, we will ensure that it matches the value sent in `change_password`.
     * @param {String} [company] User's company
     * @param {Boolean} [davPermission] Can the user connect with WebDAV?
     * @param {Boolean} [disabled] Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting.
     * @param {String} [email] User's email.
     * @param {Boolean} [ftpPermission] Can the user access with FTP/FTPS?
     * @param {String} [grantPermission] Permission to grant on the user root.  Can be blank or `full`, `read`, `write`, `list`, `read+write`, or `list+write`
     * @param {Number} [groupId] Group ID to associate this user with.
     * @param {String} [groupIds] A list of group ids to associate this user with.  Comma delimited.
     * @param {String} [headerText] Text to display to the user in the header of the UI
     * @param {String} [importedPasswordHash] Pre-calculated hash of the user's password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256.
     * @param {String} [language] Preferred language
     * @param {String} [name] User's full name
     * @param {String} [notes] Any internal notes on the user
     * @param {Number} [notificationDailySendTime] Hour of the day at which daily notifications should be sent. Can be in range 0 to 23
     * @param {Boolean} [officeIntegrationEnabled] Enable integration with Office for the web?
     * @param {String} [password] User password.
     * @param {String} [passwordConfirmation] Optional, but if provided, we will ensure that it matches the value sent in `password`.
     * @param {Number} [passwordValidityDays] Number of days to allow user to use the same password
     * @param {Boolean} [receiveAdminAlerts] Should the user receive admin alerts such a certificate expiration notifications and overages?
     * @param {module:model/String} [require2fa] 2FA required setting
     * @param {Boolean} [requirePasswordChange] Is a password change required upon next user login?
     * @param {Boolean} [restapiPermission] Can this user access the REST API?
     * @param {Boolean} [selfManaged] Does this user manage it's own credentials or is it a shared/bot user?
     * @param {Boolean} [sftpPermission] Can the user access with SFTP?
     * @param {Boolean} [siteAdmin] Is the user an administrator for this site?
     * @param {Boolean} [skipWelcomeScreen] Skip Welcome page in the UI?
     * @param {module:model/String} [sslRequired] SSL required setting
     * @param {Number} [ssoStrategyId] SSO (Single Sign On) strategy ID for the user, if applicable.
     * @param {Boolean} [subscribeToNewsletter] Is the user subscribed to the newsletter?
     * @param {String} [timeZone] User time zone
     * @param {String} [userRoot] Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface.
     * @param {String} [username] User's username
     * @param {module:api/UsersApi~postUsersCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/UserEntity}
     */
    postUsers(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'allowed_ips': opts['allowedIps'],
        'announcements_read': opts['announcementsRead'],
        'attachments_permission': opts['attachmentsPermission'],
        'authenticate_until': opts['authenticateUntil'],
        'authentication_method': opts['authenticationMethod'],
        'avatar_delete': opts['avatarDelete'],
        'avatar_file': opts['avatarFile'],
        'billing_permission': opts['billingPermission'],
        'bypass_inactive_disable': opts['bypassInactiveDisable'],
        'bypass_site_allowed_ips': opts['bypassSiteAllowedIps'],
        'change_password': opts['changePassword'],
        'change_password_confirmation': opts['changePasswordConfirmation'],
        'company': opts['company'],
        'dav_permission': opts['davPermission'],
        'disabled': opts['disabled'],
        'email': opts['email'],
        'ftp_permission': opts['ftpPermission'],
        'grant_permission': opts['grantPermission'],
        'group_id': opts['groupId'],
        'group_ids': opts['groupIds'],
        'header_text': opts['headerText'],
        'imported_password_hash': opts['importedPasswordHash'],
        'language': opts['language'],
        'name': opts['name'],
        'notes': opts['notes'],
        'notification_daily_send_time': opts['notificationDailySendTime'],
        'office_integration_enabled': opts['officeIntegrationEnabled'],
        'password': opts['password'],
        'password_confirmation': opts['passwordConfirmation'],
        'password_validity_days': opts['passwordValidityDays'],
        'receive_admin_alerts': opts['receiveAdminAlerts'],
        'require_2fa': opts['require2fa'],
        'require_password_change': opts['requirePasswordChange'],
        'restapi_permission': opts['restapiPermission'],
        'self_managed': opts['selfManaged'],
        'sftp_permission': opts['sftpPermission'],
        'site_admin': opts['siteAdmin'],
        'skip_welcome_screen': opts['skipWelcomeScreen'],
        'ssl_required': opts['sslRequired'],
        'sso_strategy_id': opts['ssoStrategyId'],
        'subscribe_to_newsletter': opts['subscribeToNewsletter'],
        'time_zone': opts['timeZone'],
        'user_root': opts['userRoot'],
        'username': opts['username']
      };

      let authNames = [];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = UserEntity;
      return this.apiClient.callApi(
        '/users', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the postUsersId2faReset operation.
     * @callback module:api/UsersApi~postUsersId2faResetCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Trigger 2FA Reset process for user who has lost access to their existing 2FA methods.
     * Trigger 2FA Reset process for user who has lost access to their existing 2FA methods.
     * @param {Number} id User ID.
     * @param {module:api/UsersApi~postUsersId2faResetCallback} callback The callback function, accepting three arguments: error, data, response
     */
    postUsersId2faReset(id, callback) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling postUsersId2faReset");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/users/{id}/2fa/reset', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the postUsersIdResendWelcomeEmail operation.
     * @callback module:api/UsersApi~postUsersIdResendWelcomeEmailCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Resend user welcome email
     * Resend user welcome email
     * @param {Number} id User ID.
     * @param {module:api/UsersApi~postUsersIdResendWelcomeEmailCallback} callback The callback function, accepting three arguments: error, data, response
     */
    postUsersIdResendWelcomeEmail(id, callback) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling postUsersIdResendWelcomeEmail");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/users/{id}/resend_welcome_email', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the postUsersIdUnlock operation.
     * @callback module:api/UsersApi~postUsersIdUnlockCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Unlock user who has been locked out due to failed logins.
     * Unlock user who has been locked out due to failed logins.
     * @param {Number} id User ID.
     * @param {module:api/UsersApi~postUsersIdUnlockCallback} callback The callback function, accepting three arguments: error, data, response
     */
    postUsersIdUnlock(id, callback) {
      let postBody = null;
      // verify the required parameter 'id' is set
      if (id === undefined || id === null) {
        throw new Error("Missing the required parameter 'id' when calling postUsersIdUnlock");
      }

      let pathParams = {
        'id': id
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;
      return this.apiClient.callApi(
        '/users/{id}/unlock', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the postUsersUserIdApiKeys operation.
     * @callback module:api/UsersApi~postUsersUserIdApiKeysCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ApiKeyEntity} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create Api Key
     * Create Api Key
     * @param {Number} userId User ID.  Provide a value of `0` to operate the current session's user.
     * @param {Object} opts Optional parameters
     * @param {String} [description] User-supplied description of API key.
     * @param {Date} [expiresAt] API Key expiration date
     * @param {String} [name] Internal name for the API Key.  For your use.
     * @param {String} [path] Folder path restriction for this api key.
     * @param {module:model/String} [permissionSet = 'full')] Permissions for this API Key.  Keys with the `desktop_app` permission set only have the ability to do the functions provided in our Desktop App (File and Share Link operations).  Additional permission sets may become available in the future, such as for a Site Admin to give a key with no administrator privileges.  If you have ideas for permission sets, please let us know.
     * @param {module:api/UsersApi~postUsersUserIdApiKeysCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ApiKeyEntity}
     */
    postUsersUserIdApiKeys(userId, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling postUsersUserIdApiKeys");
      }

      let pathParams = {
        'user_id': userId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'description': opts['description'],
        'expires_at': opts['expiresAt'],
        'name': opts['name'],
        'path': opts['path'],
        'permission_set': opts['permissionSet']
      };

      let authNames = [];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = ApiKeyEntity;
      return this.apiClient.callApi(
        '/users/{user_id}/api_keys', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the postUsersUserIdPublicKeys operation.
     * @callback module:api/UsersApi~postUsersUserIdPublicKeysCallback
     * @param {String} error Error message, if any.
     * @param {module:model/PublicKeyEntity} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create Public Key
     * Create Public Key
     * @param {Number} userId User ID.  Provide a value of `0` to operate the current session's user.
     * @param {String} publicKey Actual contents of SSH key.
     * @param {String} title Internal reference for key.
     * @param {module:api/UsersApi~postUsersUserIdPublicKeysCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/PublicKeyEntity}
     */
    postUsersUserIdPublicKeys(userId, publicKey, title, callback) {
      let postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling postUsersUserIdPublicKeys");
      }
      // verify the required parameter 'publicKey' is set
      if (publicKey === undefined || publicKey === null) {
        throw new Error("Missing the required parameter 'publicKey' when calling postUsersUserIdPublicKeys");
      }
      // verify the required parameter 'title' is set
      if (title === undefined || title === null) {
        throw new Error("Missing the required parameter 'title' when calling postUsersUserIdPublicKeys");
      }

      let pathParams = {
        'user_id': userId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'public_key': publicKey,
        'title': title
      };

      let authNames = [];
      let contentTypes = ['multipart/form-data'];
      let accepts = ['application/json'];
      let returnType = PublicKeyEntity;
      return this.apiClient.callApi(
        '/users/{user_id}/public_keys', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
