/*
 * Meraki Dashboard API
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 23 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 
 *
 * The version of the OpenAPI document: 0.0.0-streaming
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.UpdateNetworkSsidRequestApTagsAndVlanIdsInner;
import org.openapitools.client.model.UpdateNetworkSsidRequestRadiusAccountingServersInner;
import org.openapitools.client.model.UpdateNetworkSsidRequestRadiusServersInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateNetworkSsidRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:58:53.186925-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateNetworkSsidRequest {
  public static final String SERIALIZED_NAME_AP_TAGS_AND_VLAN_IDS = "apTagsAndVlanIds";
  @SerializedName(SERIALIZED_NAME_AP_TAGS_AND_VLAN_IDS)
  private List<UpdateNetworkSsidRequestApTagsAndVlanIdsInner> apTagsAndVlanIds = new ArrayList<>();

  /**
   * The association control method for the SSID (&#39;open&#39;, &#39;open-enhanced&#39;, &#39;psk&#39;, &#39;open-with-radius&#39;, &#39;open-with-nac&#39;, &#39;8021x-meraki&#39;, &#39;8021x-nac&#39;, &#39;8021x-radius&#39;, &#39;8021x-google&#39;, &#39;8021x-localradius&#39;, &#39;ipsk-with-radius&#39; or &#39;ipsk-without-radius&#39;)
   */
  @JsonAdapter(AuthModeEnum.Adapter.class)
  public enum AuthModeEnum {
    _8021X_GOOGLE("8021x-google"),
    
    _8021X_LOCALRADIUS("8021x-localradius"),
    
    _8021X_MERAKI("8021x-meraki"),
    
    _8021X_NAC("8021x-nac"),
    
    _8021X_RADIUS("8021x-radius"),
    
    IPSK_WITH_RADIUS("ipsk-with-radius"),
    
    IPSK_WITHOUT_RADIUS("ipsk-without-radius"),
    
    OPEN("open"),
    
    OPEN_ENHANCED("open-enhanced"),
    
    OPEN_WITH_NAC("open-with-nac"),
    
    OPEN_WITH_RADIUS("open-with-radius"),
    
    PSK("psk");

    private String value;

    AuthModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AuthModeEnum fromValue(String value) {
      for (AuthModeEnum b : AuthModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AuthModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AuthModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AuthModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AuthModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AuthModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AUTH_MODE = "authMode";
  @SerializedName(SERIALIZED_NAME_AUTH_MODE)
  private AuthModeEnum authMode;

  public static final String SERIALIZED_NAME_AVAILABILITY_TAGS = "availabilityTags";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_TAGS)
  private List<String> availabilityTags = new ArrayList<>();

  public static final String SERIALIZED_NAME_AVAILABLE_ON_ALL_APS = "availableOnAllAps";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_ON_ALL_APS)
  private Boolean availableOnAllAps;

  public static final String SERIALIZED_NAME_BAND_SELECTION = "bandSelection";
  @SerializedName(SERIALIZED_NAME_BAND_SELECTION)
  private String bandSelection;

  public static final String SERIALIZED_NAME_CONCENTRATOR_NETWORK_ID = "concentratorNetworkId";
  @SerializedName(SERIALIZED_NAME_CONCENTRATOR_NETWORK_ID)
  private String concentratorNetworkId;

  public static final String SERIALIZED_NAME_DEFAULT_VLAN_ID = "defaultVlanId";
  @SerializedName(SERIALIZED_NAME_DEFAULT_VLAN_ID)
  private Integer defaultVlanId;

  public static final String SERIALIZED_NAME_DISASSOCIATE_CLIENTS_ON_VPN_FAILOVER = "disassociateClientsOnVpnFailover";
  @SerializedName(SERIALIZED_NAME_DISASSOCIATE_CLIENTS_ON_VPN_FAILOVER)
  private Boolean disassociateClientsOnVpnFailover;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  /**
   * The psk encryption mode for the SSID (&#39;wep&#39; or &#39;wpa&#39;). This param is only valid if the authMode is &#39;psk&#39;
   */
  @JsonAdapter(EncryptionModeEnum.Adapter.class)
  public enum EncryptionModeEnum {
    WEP("wep"),
    
    WPA("wpa");

    private String value;

    EncryptionModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EncryptionModeEnum fromValue(String value) {
      for (EncryptionModeEnum b : EncryptionModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EncryptionModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EncryptionModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EncryptionModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EncryptionModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EncryptionModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ENCRYPTION_MODE = "encryptionMode";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_MODE)
  private EncryptionModeEnum encryptionMode;

  /**
   * Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
   */
  @JsonAdapter(EnterpriseAdminAccessEnum.Adapter.class)
  public enum EnterpriseAdminAccessEnum {
    DISABLED("access disabled"),
    
    ENABLED("access enabled");

    private String value;

    EnterpriseAdminAccessEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EnterpriseAdminAccessEnum fromValue(String value) {
      for (EnterpriseAdminAccessEnum b : EnterpriseAdminAccessEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EnterpriseAdminAccessEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EnterpriseAdminAccessEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EnterpriseAdminAccessEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EnterpriseAdminAccessEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EnterpriseAdminAccessEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ENTERPRISE_ADMIN_ACCESS = "enterpriseAdminAccess";
  @SerializedName(SERIALIZED_NAME_ENTERPRISE_ADMIN_ACCESS)
  private EnterpriseAdminAccessEnum enterpriseAdminAccess;

  public static final String SERIALIZED_NAME_IP_ASSIGNMENT_MODE = "ipAssignmentMode";
  @SerializedName(SERIALIZED_NAME_IP_ASSIGNMENT_MODE)
  private String ipAssignmentMode;

  public static final String SERIALIZED_NAME_LAN_ISOLATION_ENABLED = "lanIsolationEnabled";
  @SerializedName(SERIALIZED_NAME_LAN_ISOLATION_ENABLED)
  private Boolean lanIsolationEnabled;

  public static final String SERIALIZED_NAME_MIN_BITRATE = "minBitrate";
  @SerializedName(SERIALIZED_NAME_MIN_BITRATE)
  private Float minBitrate;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PER_CLIENT_BANDWIDTH_LIMIT_DOWN = "perClientBandwidthLimitDown";
  @SerializedName(SERIALIZED_NAME_PER_CLIENT_BANDWIDTH_LIMIT_DOWN)
  private Integer perClientBandwidthLimitDown;

  public static final String SERIALIZED_NAME_PER_CLIENT_BANDWIDTH_LIMIT_UP = "perClientBandwidthLimitUp";
  @SerializedName(SERIALIZED_NAME_PER_CLIENT_BANDWIDTH_LIMIT_UP)
  private Integer perClientBandwidthLimitUp;

  public static final String SERIALIZED_NAME_PSK = "psk";
  @SerializedName(SERIALIZED_NAME_PSK)
  private String psk;

  public static final String SERIALIZED_NAME_RADIUS_ACCOUNTING_ENABLED = "radiusAccountingEnabled";
  @SerializedName(SERIALIZED_NAME_RADIUS_ACCOUNTING_ENABLED)
  private Boolean radiusAccountingEnabled;

  public static final String SERIALIZED_NAME_RADIUS_ACCOUNTING_SERVERS = "radiusAccountingServers";
  @SerializedName(SERIALIZED_NAME_RADIUS_ACCOUNTING_SERVERS)
  private List<UpdateNetworkSsidRequestRadiusAccountingServersInner> radiusAccountingServers = new ArrayList<>();

  public static final String SERIALIZED_NAME_RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES = "radiusAttributeForGroupPolicies";
  @SerializedName(SERIALIZED_NAME_RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES)
  private String radiusAttributeForGroupPolicies;

  public static final String SERIALIZED_NAME_RADIUS_COA_ENABLED = "radiusCoaEnabled";
  @SerializedName(SERIALIZED_NAME_RADIUS_COA_ENABLED)
  private Boolean radiusCoaEnabled;

  /**
   * This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable (&#39;Deny access&#39; or &#39;Allow access&#39;)
   */
  @JsonAdapter(RadiusFailoverPolicyEnum.Adapter.class)
  public enum RadiusFailoverPolicyEnum {
    ALLOW_ACCESS("Allow access"),
    
    DENY_ACCESS("Deny access");

    private String value;

    RadiusFailoverPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RadiusFailoverPolicyEnum fromValue(String value) {
      for (RadiusFailoverPolicyEnum b : RadiusFailoverPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RadiusFailoverPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RadiusFailoverPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RadiusFailoverPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RadiusFailoverPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RadiusFailoverPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RADIUS_FAILOVER_POLICY = "radiusFailoverPolicy";
  @SerializedName(SERIALIZED_NAME_RADIUS_FAILOVER_POLICY)
  private RadiusFailoverPolicyEnum radiusFailoverPolicy;

  /**
   * This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts (&#39;Strict priority order&#39; or &#39;Round robin&#39;)
   */
  @JsonAdapter(RadiusLoadBalancingPolicyEnum.Adapter.class)
  public enum RadiusLoadBalancingPolicyEnum {
    ROUND_ROBIN("Round robin"),
    
    STRICT_PRIORITY_ORDER("Strict priority order");

    private String value;

    RadiusLoadBalancingPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RadiusLoadBalancingPolicyEnum fromValue(String value) {
      for (RadiusLoadBalancingPolicyEnum b : RadiusLoadBalancingPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RadiusLoadBalancingPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RadiusLoadBalancingPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RadiusLoadBalancingPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RadiusLoadBalancingPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RadiusLoadBalancingPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RADIUS_LOAD_BALANCING_POLICY = "radiusLoadBalancingPolicy";
  @SerializedName(SERIALIZED_NAME_RADIUS_LOAD_BALANCING_POLICY)
  private RadiusLoadBalancingPolicyEnum radiusLoadBalancingPolicy;

  public static final String SERIALIZED_NAME_RADIUS_OVERRIDE = "radiusOverride";
  @SerializedName(SERIALIZED_NAME_RADIUS_OVERRIDE)
  private Boolean radiusOverride;

  public static final String SERIALIZED_NAME_RADIUS_SERVERS = "radiusServers";
  @SerializedName(SERIALIZED_NAME_RADIUS_SERVERS)
  private List<UpdateNetworkSsidRequestRadiusServersInner> radiusServers = new ArrayList<>();

  public static final String SERIALIZED_NAME_SECONDARY_CONCENTRATOR_NETWORK_ID = "secondaryConcentratorNetworkId";
  @SerializedName(SERIALIZED_NAME_SECONDARY_CONCENTRATOR_NETWORK_ID)
  private String secondaryConcentratorNetworkId;

  /**
   * The type of splash page for the SSID (&#39;None&#39;, &#39;Click-through splash page&#39;, &#39;Billing&#39;, &#39;Password-protected with Meraki RADIUS&#39;, &#39;Password-protected with custom RADIUS&#39;, &#39;Password-protected with Active Directory&#39;, &#39;Password-protected with LDAP&#39;, &#39;SMS authentication&#39;, &#39;Systems Manager Sentry&#39;, &#39;Facebook Wi-Fi&#39;, &#39;Google OAuth&#39;, &#39;Sponsored guest&#39;, &#39;Cisco ISE&#39; or &#39;Google Apps domain&#39;). This attribute is not supported for template children.
   */
  @JsonAdapter(SplashPageEnum.Adapter.class)
  public enum SplashPageEnum {
    BILLING("Billing"),
    
    CISCO_ISE("Cisco ISE"),
    
    CLICK_THROUGH_SPLASH_PAGE("Click-through splash page"),
    
    FACEBOOK_WI_FI("Facebook Wi-Fi"),
    
    GOOGLE_APPS_DOMAIN("Google Apps domain"),
    
    GOOGLE_O_AUTH("Google OAuth"),
    
    NONE("None"),
    
    PASSWORD_PROTECTED_WITH_ACTIVE_DIRECTORY("Password-protected with Active Directory"),
    
    PASSWORD_PROTECTED_WITH_LDAP("Password-protected with LDAP"),
    
    PASSWORD_PROTECTED_WITH_MERAKI_RADIUS("Password-protected with Meraki RADIUS"),
    
    PASSWORD_PROTECTED_WITH_CUSTOM_RADIUS("Password-protected with custom RADIUS"),
    
    SMS_AUTHENTICATION("SMS authentication"),
    
    SPONSORED_GUEST("Sponsored guest"),
    
    SYSTEMS_MANAGER_SENTRY("Systems Manager Sentry");

    private String value;

    SplashPageEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SplashPageEnum fromValue(String value) {
      for (SplashPageEnum b : SplashPageEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SplashPageEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SplashPageEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SplashPageEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SplashPageEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SplashPageEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SPLASH_PAGE = "splashPage";
  @SerializedName(SERIALIZED_NAME_SPLASH_PAGE)
  private SplashPageEnum splashPage;

  public static final String SERIALIZED_NAME_USE_VLAN_TAGGING = "useVlanTagging";
  @SerializedName(SERIALIZED_NAME_USE_VLAN_TAGGING)
  private Boolean useVlanTagging;

  public static final String SERIALIZED_NAME_VISIBLE = "visible";
  @SerializedName(SERIALIZED_NAME_VISIBLE)
  private Boolean visible;

  public static final String SERIALIZED_NAME_VLAN_ID = "vlanId";
  @SerializedName(SERIALIZED_NAME_VLAN_ID)
  private Integer vlanId;

  public static final String SERIALIZED_NAME_WALLED_GARDEN_ENABLED = "walledGardenEnabled";
  @SerializedName(SERIALIZED_NAME_WALLED_GARDEN_ENABLED)
  private Boolean walledGardenEnabled;

  public static final String SERIALIZED_NAME_WALLED_GARDEN_RANGES = "walledGardenRanges";
  @SerializedName(SERIALIZED_NAME_WALLED_GARDEN_RANGES)
  private String walledGardenRanges;

  /**
   * The types of WPA encryption. (&#39;WPA1 only&#39;, &#39;WPA1 and WPA2&#39;, &#39;WPA2 only&#39;, &#39;WPA3 Transition Mode&#39;, &#39;WPA3 only&#39; or &#39;WPA3 192-bit Security&#39;)
   */
  @JsonAdapter(WpaEncryptionModeEnum.Adapter.class)
  public enum WpaEncryptionModeEnum {
    WPA1_AND_WPA2("WPA1 and WPA2"),
    
    WPA1_ONLY("WPA1 only"),
    
    WPA2_ONLY("WPA2 only"),
    
    WPA3_192_BIT_SECURITY("WPA3 192-bit Security"),
    
    WPA3_TRANSITION_MODE("WPA3 Transition Mode"),
    
    WPA3_ONLY("WPA3 only");

    private String value;

    WpaEncryptionModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static WpaEncryptionModeEnum fromValue(String value) {
      for (WpaEncryptionModeEnum b : WpaEncryptionModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<WpaEncryptionModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final WpaEncryptionModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public WpaEncryptionModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return WpaEncryptionModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      WpaEncryptionModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_WPA_ENCRYPTION_MODE = "wpaEncryptionMode";
  @SerializedName(SERIALIZED_NAME_WPA_ENCRYPTION_MODE)
  private WpaEncryptionModeEnum wpaEncryptionMode;

  public UpdateNetworkSsidRequest() {
  }

  public UpdateNetworkSsidRequest apTagsAndVlanIds(List<UpdateNetworkSsidRequestApTagsAndVlanIdsInner> apTagsAndVlanIds) {
    this.apTagsAndVlanIds = apTagsAndVlanIds;
    return this;
  }

  public UpdateNetworkSsidRequest addApTagsAndVlanIdsItem(UpdateNetworkSsidRequestApTagsAndVlanIdsInner apTagsAndVlanIdsItem) {
    if (this.apTagsAndVlanIds == null) {
      this.apTagsAndVlanIds = new ArrayList<>();
    }
    this.apTagsAndVlanIds.add(apTagsAndVlanIdsItem);
    return this;
  }

  /**
   * The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
   * @return apTagsAndVlanIds
   */
  @javax.annotation.Nullable
  public List<UpdateNetworkSsidRequestApTagsAndVlanIdsInner> getApTagsAndVlanIds() {
    return apTagsAndVlanIds;
  }

  public void setApTagsAndVlanIds(List<UpdateNetworkSsidRequestApTagsAndVlanIdsInner> apTagsAndVlanIds) {
    this.apTagsAndVlanIds = apTagsAndVlanIds;
  }


  public UpdateNetworkSsidRequest authMode(AuthModeEnum authMode) {
    this.authMode = authMode;
    return this;
  }

  /**
   * The association control method for the SSID (&#39;open&#39;, &#39;open-enhanced&#39;, &#39;psk&#39;, &#39;open-with-radius&#39;, &#39;open-with-nac&#39;, &#39;8021x-meraki&#39;, &#39;8021x-nac&#39;, &#39;8021x-radius&#39;, &#39;8021x-google&#39;, &#39;8021x-localradius&#39;, &#39;ipsk-with-radius&#39; or &#39;ipsk-without-radius&#39;)
   * @return authMode
   */
  @javax.annotation.Nullable
  public AuthModeEnum getAuthMode() {
    return authMode;
  }

  public void setAuthMode(AuthModeEnum authMode) {
    this.authMode = authMode;
  }


  public UpdateNetworkSsidRequest availabilityTags(List<String> availabilityTags) {
    this.availabilityTags = availabilityTags;
    return this;
  }

  public UpdateNetworkSsidRequest addAvailabilityTagsItem(String availabilityTagsItem) {
    if (this.availabilityTags == null) {
      this.availabilityTags = new ArrayList<>();
    }
    this.availabilityTags.add(availabilityTagsItem);
    return this;
  }

  /**
   * Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
   * @return availabilityTags
   */
  @javax.annotation.Nullable
  public List<String> getAvailabilityTags() {
    return availabilityTags;
  }

  public void setAvailabilityTags(List<String> availabilityTags) {
    this.availabilityTags = availabilityTags;
  }


  public UpdateNetworkSsidRequest availableOnAllAps(Boolean availableOnAllAps) {
    this.availableOnAllAps = availableOnAllAps;
    return this;
  }

  /**
   * Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
   * @return availableOnAllAps
   */
  @javax.annotation.Nullable
  public Boolean getAvailableOnAllAps() {
    return availableOnAllAps;
  }

  public void setAvailableOnAllAps(Boolean availableOnAllAps) {
    this.availableOnAllAps = availableOnAllAps;
  }


  public UpdateNetworkSsidRequest bandSelection(String bandSelection) {
    this.bandSelection = bandSelection;
    return this;
  }

  /**
   * The client-serving radio frequencies of this SSID in the default indoor RF profile. (&#39;Dual band operation&#39;, &#39;5 GHz band only&#39; or &#39;Dual band operation with Band Steering&#39;)
   * @return bandSelection
   */
  @javax.annotation.Nullable
  public String getBandSelection() {
    return bandSelection;
  }

  public void setBandSelection(String bandSelection) {
    this.bandSelection = bandSelection;
  }


  public UpdateNetworkSsidRequest concentratorNetworkId(String concentratorNetworkId) {
    this.concentratorNetworkId = concentratorNetworkId;
    return this;
  }

  /**
   * The concentrator to use when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;.
   * @return concentratorNetworkId
   */
  @javax.annotation.Nullable
  public String getConcentratorNetworkId() {
    return concentratorNetworkId;
  }

  public void setConcentratorNetworkId(String concentratorNetworkId) {
    this.concentratorNetworkId = concentratorNetworkId;
  }


  public UpdateNetworkSsidRequest defaultVlanId(Integer defaultVlanId) {
    this.defaultVlanId = defaultVlanId;
    return this;
  }

  /**
   * The default VLAN ID used for &#39;all other APs&#39;. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
   * @return defaultVlanId
   */
  @javax.annotation.Nullable
  public Integer getDefaultVlanId() {
    return defaultVlanId;
  }

  public void setDefaultVlanId(Integer defaultVlanId) {
    this.defaultVlanId = defaultVlanId;
  }


  public UpdateNetworkSsidRequest disassociateClientsOnVpnFailover(Boolean disassociateClientsOnVpnFailover) {
    this.disassociateClientsOnVpnFailover = disassociateClientsOnVpnFailover;
    return this;
  }

  /**
   * Disassociate clients when &#39;VPN&#39; concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is &#39;VPN&#39;.
   * @return disassociateClientsOnVpnFailover
   */
  @javax.annotation.Nullable
  public Boolean getDisassociateClientsOnVpnFailover() {
    return disassociateClientsOnVpnFailover;
  }

  public void setDisassociateClientsOnVpnFailover(Boolean disassociateClientsOnVpnFailover) {
    this.disassociateClientsOnVpnFailover = disassociateClientsOnVpnFailover;
  }


  public UpdateNetworkSsidRequest enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * Whether or not the SSID is enabled
   * @return enabled
   */
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public UpdateNetworkSsidRequest encryptionMode(EncryptionModeEnum encryptionMode) {
    this.encryptionMode = encryptionMode;
    return this;
  }

  /**
   * The psk encryption mode for the SSID (&#39;wep&#39; or &#39;wpa&#39;). This param is only valid if the authMode is &#39;psk&#39;
   * @return encryptionMode
   */
  @javax.annotation.Nullable
  public EncryptionModeEnum getEncryptionMode() {
    return encryptionMode;
  }

  public void setEncryptionMode(EncryptionModeEnum encryptionMode) {
    this.encryptionMode = encryptionMode;
  }


  public UpdateNetworkSsidRequest enterpriseAdminAccess(EnterpriseAdminAccessEnum enterpriseAdminAccess) {
    this.enterpriseAdminAccess = enterpriseAdminAccess;
    return this;
  }

  /**
   * Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
   * @return enterpriseAdminAccess
   */
  @javax.annotation.Nullable
  public EnterpriseAdminAccessEnum getEnterpriseAdminAccess() {
    return enterpriseAdminAccess;
  }

  public void setEnterpriseAdminAccess(EnterpriseAdminAccessEnum enterpriseAdminAccess) {
    this.enterpriseAdminAccess = enterpriseAdminAccess;
  }


  public UpdateNetworkSsidRequest ipAssignmentMode(String ipAssignmentMode) {
    this.ipAssignmentMode = ipAssignmentMode;
    return this;
  }

  /**
   * The client IP assignment mode (&#39;NAT mode&#39;, &#39;Bridge mode&#39;, &#39;Layer 3 roaming&#39;, &#39;Ethernet over GRE&#39;, &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;)
   * @return ipAssignmentMode
   */
  @javax.annotation.Nullable
  public String getIpAssignmentMode() {
    return ipAssignmentMode;
  }

  public void setIpAssignmentMode(String ipAssignmentMode) {
    this.ipAssignmentMode = ipAssignmentMode;
  }


  public UpdateNetworkSsidRequest lanIsolationEnabled(Boolean lanIsolationEnabled) {
    this.lanIsolationEnabled = lanIsolationEnabled;
    return this;
  }

  /**
   * Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is &#39;Bridge mode&#39;.
   * @return lanIsolationEnabled
   */
  @javax.annotation.Nullable
  public Boolean getLanIsolationEnabled() {
    return lanIsolationEnabled;
  }

  public void setLanIsolationEnabled(Boolean lanIsolationEnabled) {
    this.lanIsolationEnabled = lanIsolationEnabled;
  }


  public UpdateNetworkSsidRequest minBitrate(Float minBitrate) {
    this.minBitrate = minBitrate;
    return this;
  }

  /**
   * The minimum bitrate in Mbps of this SSID in the default indoor RF profile. (&#39;1&#39;, &#39;2&#39;, &#39;5.5&#39;, &#39;6&#39;, &#39;9&#39;, &#39;11&#39;, &#39;12&#39;, &#39;18&#39;, &#39;24&#39;, &#39;36&#39;, &#39;48&#39; or &#39;54&#39;)
   * @return minBitrate
   */
  @javax.annotation.Nullable
  public Float getMinBitrate() {
    return minBitrate;
  }

  public void setMinBitrate(Float minBitrate) {
    this.minBitrate = minBitrate;
  }


  public UpdateNetworkSsidRequest name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the SSID
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public UpdateNetworkSsidRequest perClientBandwidthLimitDown(Integer perClientBandwidthLimitDown) {
    this.perClientBandwidthLimitDown = perClientBandwidthLimitDown;
    return this;
  }

  /**
   * The download bandwidth limit in Kbps. (0 represents no limit.)
   * @return perClientBandwidthLimitDown
   */
  @javax.annotation.Nullable
  public Integer getPerClientBandwidthLimitDown() {
    return perClientBandwidthLimitDown;
  }

  public void setPerClientBandwidthLimitDown(Integer perClientBandwidthLimitDown) {
    this.perClientBandwidthLimitDown = perClientBandwidthLimitDown;
  }


  public UpdateNetworkSsidRequest perClientBandwidthLimitUp(Integer perClientBandwidthLimitUp) {
    this.perClientBandwidthLimitUp = perClientBandwidthLimitUp;
    return this;
  }

  /**
   * The upload bandwidth limit in Kbps. (0 represents no limit.)
   * @return perClientBandwidthLimitUp
   */
  @javax.annotation.Nullable
  public Integer getPerClientBandwidthLimitUp() {
    return perClientBandwidthLimitUp;
  }

  public void setPerClientBandwidthLimitUp(Integer perClientBandwidthLimitUp) {
    this.perClientBandwidthLimitUp = perClientBandwidthLimitUp;
  }


  public UpdateNetworkSsidRequest psk(String psk) {
    this.psk = psk;
    return this;
  }

  /**
   * The passkey for the SSID. This param is only valid if the authMode is &#39;psk&#39;
   * @return psk
   */
  @javax.annotation.Nullable
  public String getPsk() {
    return psk;
  }

  public void setPsk(String psk) {
    this.psk = psk;
  }


  public UpdateNetworkSsidRequest radiusAccountingEnabled(Boolean radiusAccountingEnabled) {
    this.radiusAccountingEnabled = radiusAccountingEnabled;
    return this;
  }

  /**
   * Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
   * @return radiusAccountingEnabled
   */
  @javax.annotation.Nullable
  public Boolean getRadiusAccountingEnabled() {
    return radiusAccountingEnabled;
  }

  public void setRadiusAccountingEnabled(Boolean radiusAccountingEnabled) {
    this.radiusAccountingEnabled = radiusAccountingEnabled;
  }


  public UpdateNetworkSsidRequest radiusAccountingServers(List<UpdateNetworkSsidRequestRadiusAccountingServersInner> radiusAccountingServers) {
    this.radiusAccountingServers = radiusAccountingServers;
    return this;
  }

  public UpdateNetworkSsidRequest addRadiusAccountingServersItem(UpdateNetworkSsidRequestRadiusAccountingServersInner radiusAccountingServersItem) {
    if (this.radiusAccountingServers == null) {
      this.radiusAccountingServers = new ArrayList<>();
    }
    this.radiusAccountingServers.add(radiusAccountingServersItem);
    return this;
  }

  /**
   * The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39; and radiusAccountingEnabled is &#39;true&#39;
   * @return radiusAccountingServers
   */
  @javax.annotation.Nullable
  public List<UpdateNetworkSsidRequestRadiusAccountingServersInner> getRadiusAccountingServers() {
    return radiusAccountingServers;
  }

  public void setRadiusAccountingServers(List<UpdateNetworkSsidRequestRadiusAccountingServersInner> radiusAccountingServers) {
    this.radiusAccountingServers = radiusAccountingServers;
  }


  public UpdateNetworkSsidRequest radiusAttributeForGroupPolicies(String radiusAttributeForGroupPolicies) {
    this.radiusAttributeForGroupPolicies = radiusAttributeForGroupPolicies;
    return this;
  }

  /**
   * Specify the RADIUS attribute used to look up group policies (&#39;Filter-Id&#39;, &#39;Reply-Message&#39;, &#39;Airespace-ACL-Name&#39; or &#39;Aruba-User-Role&#39;). Access points must receive this attribute in the RADIUS Access-Accept message
   * @return radiusAttributeForGroupPolicies
   */
  @javax.annotation.Nullable
  public String getRadiusAttributeForGroupPolicies() {
    return radiusAttributeForGroupPolicies;
  }

  public void setRadiusAttributeForGroupPolicies(String radiusAttributeForGroupPolicies) {
    this.radiusAttributeForGroupPolicies = radiusAttributeForGroupPolicies;
  }


  public UpdateNetworkSsidRequest radiusCoaEnabled(Boolean radiusCoaEnabled) {
    this.radiusCoaEnabled = radiusCoaEnabled;
    return this;
  }

  /**
   * If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
   * @return radiusCoaEnabled
   */
  @javax.annotation.Nullable
  public Boolean getRadiusCoaEnabled() {
    return radiusCoaEnabled;
  }

  public void setRadiusCoaEnabled(Boolean radiusCoaEnabled) {
    this.radiusCoaEnabled = radiusCoaEnabled;
  }


  public UpdateNetworkSsidRequest radiusFailoverPolicy(RadiusFailoverPolicyEnum radiusFailoverPolicy) {
    this.radiusFailoverPolicy = radiusFailoverPolicy;
    return this;
  }

  /**
   * This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable (&#39;Deny access&#39; or &#39;Allow access&#39;)
   * @return radiusFailoverPolicy
   */
  @javax.annotation.Nullable
  public RadiusFailoverPolicyEnum getRadiusFailoverPolicy() {
    return radiusFailoverPolicy;
  }

  public void setRadiusFailoverPolicy(RadiusFailoverPolicyEnum radiusFailoverPolicy) {
    this.radiusFailoverPolicy = radiusFailoverPolicy;
  }


  public UpdateNetworkSsidRequest radiusLoadBalancingPolicy(RadiusLoadBalancingPolicyEnum radiusLoadBalancingPolicy) {
    this.radiusLoadBalancingPolicy = radiusLoadBalancingPolicy;
    return this;
  }

  /**
   * This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts (&#39;Strict priority order&#39; or &#39;Round robin&#39;)
   * @return radiusLoadBalancingPolicy
   */
  @javax.annotation.Nullable
  public RadiusLoadBalancingPolicyEnum getRadiusLoadBalancingPolicy() {
    return radiusLoadBalancingPolicy;
  }

  public void setRadiusLoadBalancingPolicy(RadiusLoadBalancingPolicyEnum radiusLoadBalancingPolicy) {
    this.radiusLoadBalancingPolicy = radiusLoadBalancingPolicy;
  }


  public UpdateNetworkSsidRequest radiusOverride(Boolean radiusOverride) {
    this.radiusOverride = radiusOverride;
    return this;
  }

  /**
   * If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is &#39;NAT mode&#39;.
   * @return radiusOverride
   */
  @javax.annotation.Nullable
  public Boolean getRadiusOverride() {
    return radiusOverride;
  }

  public void setRadiusOverride(Boolean radiusOverride) {
    this.radiusOverride = radiusOverride;
  }


  public UpdateNetworkSsidRequest radiusServers(List<UpdateNetworkSsidRequestRadiusServersInner> radiusServers) {
    this.radiusServers = radiusServers;
    return this;
  }

  public UpdateNetworkSsidRequest addRadiusServersItem(UpdateNetworkSsidRequestRadiusServersInner radiusServersItem) {
    if (this.radiusServers == null) {
      this.radiusServers = new ArrayList<>();
    }
    this.radiusServers.add(radiusServersItem);
    return this;
  }

  /**
   * The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
   * @return radiusServers
   */
  @javax.annotation.Nullable
  public List<UpdateNetworkSsidRequestRadiusServersInner> getRadiusServers() {
    return radiusServers;
  }

  public void setRadiusServers(List<UpdateNetworkSsidRequestRadiusServersInner> radiusServers) {
    this.radiusServers = radiusServers;
  }


  public UpdateNetworkSsidRequest secondaryConcentratorNetworkId(String secondaryConcentratorNetworkId) {
    this.secondaryConcentratorNetworkId = secondaryConcentratorNetworkId;
    return this;
  }

  /**
   * The secondary concentrator to use when the ipAssignmentMode is &#39;VPN&#39;. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. (&#39;disabled&#39; represents no secondary concentrator.)
   * @return secondaryConcentratorNetworkId
   */
  @javax.annotation.Nullable
  public String getSecondaryConcentratorNetworkId() {
    return secondaryConcentratorNetworkId;
  }

  public void setSecondaryConcentratorNetworkId(String secondaryConcentratorNetworkId) {
    this.secondaryConcentratorNetworkId = secondaryConcentratorNetworkId;
  }


  public UpdateNetworkSsidRequest splashPage(SplashPageEnum splashPage) {
    this.splashPage = splashPage;
    return this;
  }

  /**
   * The type of splash page for the SSID (&#39;None&#39;, &#39;Click-through splash page&#39;, &#39;Billing&#39;, &#39;Password-protected with Meraki RADIUS&#39;, &#39;Password-protected with custom RADIUS&#39;, &#39;Password-protected with Active Directory&#39;, &#39;Password-protected with LDAP&#39;, &#39;SMS authentication&#39;, &#39;Systems Manager Sentry&#39;, &#39;Facebook Wi-Fi&#39;, &#39;Google OAuth&#39;, &#39;Sponsored guest&#39;, &#39;Cisco ISE&#39; or &#39;Google Apps domain&#39;). This attribute is not supported for template children.
   * @return splashPage
   */
  @javax.annotation.Nullable
  public SplashPageEnum getSplashPage() {
    return splashPage;
  }

  public void setSplashPage(SplashPageEnum splashPage) {
    this.splashPage = splashPage;
  }


  public UpdateNetworkSsidRequest useVlanTagging(Boolean useVlanTagging) {
    this.useVlanTagging = useVlanTagging;
    return this;
  }

  /**
   * Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
   * @return useVlanTagging
   */
  @javax.annotation.Nullable
  public Boolean getUseVlanTagging() {
    return useVlanTagging;
  }

  public void setUseVlanTagging(Boolean useVlanTagging) {
    this.useVlanTagging = useVlanTagging;
  }


  public UpdateNetworkSsidRequest visible(Boolean visible) {
    this.visible = visible;
    return this;
  }

  /**
   * Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
   * @return visible
   */
  @javax.annotation.Nullable
  public Boolean getVisible() {
    return visible;
  }

  public void setVisible(Boolean visible) {
    this.visible = visible;
  }


  public UpdateNetworkSsidRequest vlanId(Integer vlanId) {
    this.vlanId = vlanId;
    return this;
  }

  /**
   * The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;
   * @return vlanId
   */
  @javax.annotation.Nullable
  public Integer getVlanId() {
    return vlanId;
  }

  public void setVlanId(Integer vlanId) {
    this.vlanId = vlanId;
  }


  public UpdateNetworkSsidRequest walledGardenEnabled(Boolean walledGardenEnabled) {
    this.walledGardenEnabled = walledGardenEnabled;
    return this;
  }

  /**
   * Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
   * @return walledGardenEnabled
   */
  @javax.annotation.Nullable
  public Boolean getWalledGardenEnabled() {
    return walledGardenEnabled;
  }

  public void setWalledGardenEnabled(Boolean walledGardenEnabled) {
    this.walledGardenEnabled = walledGardenEnabled;
  }


  public UpdateNetworkSsidRequest walledGardenRanges(String walledGardenRanges) {
    this.walledGardenRanges = walledGardenRanges;
    return this;
  }

  /**
   * Specify your walled garden by entering space-separated addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. 192.168.1.1/24 192.168.37.10/32 www.yahoo.com *.google.com). Meraki&#39;s splash page is automatically included in your walled garden.
   * @return walledGardenRanges
   */
  @javax.annotation.Nullable
  public String getWalledGardenRanges() {
    return walledGardenRanges;
  }

  public void setWalledGardenRanges(String walledGardenRanges) {
    this.walledGardenRanges = walledGardenRanges;
  }


  public UpdateNetworkSsidRequest wpaEncryptionMode(WpaEncryptionModeEnum wpaEncryptionMode) {
    this.wpaEncryptionMode = wpaEncryptionMode;
    return this;
  }

  /**
   * The types of WPA encryption. (&#39;WPA1 only&#39;, &#39;WPA1 and WPA2&#39;, &#39;WPA2 only&#39;, &#39;WPA3 Transition Mode&#39;, &#39;WPA3 only&#39; or &#39;WPA3 192-bit Security&#39;)
   * @return wpaEncryptionMode
   */
  @javax.annotation.Nullable
  public WpaEncryptionModeEnum getWpaEncryptionMode() {
    return wpaEncryptionMode;
  }

  public void setWpaEncryptionMode(WpaEncryptionModeEnum wpaEncryptionMode) {
    this.wpaEncryptionMode = wpaEncryptionMode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateNetworkSsidRequest updateNetworkSsidRequest = (UpdateNetworkSsidRequest) o;
    return Objects.equals(this.apTagsAndVlanIds, updateNetworkSsidRequest.apTagsAndVlanIds) &&
        Objects.equals(this.authMode, updateNetworkSsidRequest.authMode) &&
        Objects.equals(this.availabilityTags, updateNetworkSsidRequest.availabilityTags) &&
        Objects.equals(this.availableOnAllAps, updateNetworkSsidRequest.availableOnAllAps) &&
        Objects.equals(this.bandSelection, updateNetworkSsidRequest.bandSelection) &&
        Objects.equals(this.concentratorNetworkId, updateNetworkSsidRequest.concentratorNetworkId) &&
        Objects.equals(this.defaultVlanId, updateNetworkSsidRequest.defaultVlanId) &&
        Objects.equals(this.disassociateClientsOnVpnFailover, updateNetworkSsidRequest.disassociateClientsOnVpnFailover) &&
        Objects.equals(this.enabled, updateNetworkSsidRequest.enabled) &&
        Objects.equals(this.encryptionMode, updateNetworkSsidRequest.encryptionMode) &&
        Objects.equals(this.enterpriseAdminAccess, updateNetworkSsidRequest.enterpriseAdminAccess) &&
        Objects.equals(this.ipAssignmentMode, updateNetworkSsidRequest.ipAssignmentMode) &&
        Objects.equals(this.lanIsolationEnabled, updateNetworkSsidRequest.lanIsolationEnabled) &&
        Objects.equals(this.minBitrate, updateNetworkSsidRequest.minBitrate) &&
        Objects.equals(this.name, updateNetworkSsidRequest.name) &&
        Objects.equals(this.perClientBandwidthLimitDown, updateNetworkSsidRequest.perClientBandwidthLimitDown) &&
        Objects.equals(this.perClientBandwidthLimitUp, updateNetworkSsidRequest.perClientBandwidthLimitUp) &&
        Objects.equals(this.psk, updateNetworkSsidRequest.psk) &&
        Objects.equals(this.radiusAccountingEnabled, updateNetworkSsidRequest.radiusAccountingEnabled) &&
        Objects.equals(this.radiusAccountingServers, updateNetworkSsidRequest.radiusAccountingServers) &&
        Objects.equals(this.radiusAttributeForGroupPolicies, updateNetworkSsidRequest.radiusAttributeForGroupPolicies) &&
        Objects.equals(this.radiusCoaEnabled, updateNetworkSsidRequest.radiusCoaEnabled) &&
        Objects.equals(this.radiusFailoverPolicy, updateNetworkSsidRequest.radiusFailoverPolicy) &&
        Objects.equals(this.radiusLoadBalancingPolicy, updateNetworkSsidRequest.radiusLoadBalancingPolicy) &&
        Objects.equals(this.radiusOverride, updateNetworkSsidRequest.radiusOverride) &&
        Objects.equals(this.radiusServers, updateNetworkSsidRequest.radiusServers) &&
        Objects.equals(this.secondaryConcentratorNetworkId, updateNetworkSsidRequest.secondaryConcentratorNetworkId) &&
        Objects.equals(this.splashPage, updateNetworkSsidRequest.splashPage) &&
        Objects.equals(this.useVlanTagging, updateNetworkSsidRequest.useVlanTagging) &&
        Objects.equals(this.visible, updateNetworkSsidRequest.visible) &&
        Objects.equals(this.vlanId, updateNetworkSsidRequest.vlanId) &&
        Objects.equals(this.walledGardenEnabled, updateNetworkSsidRequest.walledGardenEnabled) &&
        Objects.equals(this.walledGardenRanges, updateNetworkSsidRequest.walledGardenRanges) &&
        Objects.equals(this.wpaEncryptionMode, updateNetworkSsidRequest.wpaEncryptionMode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(apTagsAndVlanIds, authMode, availabilityTags, availableOnAllAps, bandSelection, concentratorNetworkId, defaultVlanId, disassociateClientsOnVpnFailover, enabled, encryptionMode, enterpriseAdminAccess, ipAssignmentMode, lanIsolationEnabled, minBitrate, name, perClientBandwidthLimitDown, perClientBandwidthLimitUp, psk, radiusAccountingEnabled, radiusAccountingServers, radiusAttributeForGroupPolicies, radiusCoaEnabled, radiusFailoverPolicy, radiusLoadBalancingPolicy, radiusOverride, radiusServers, secondaryConcentratorNetworkId, splashPage, useVlanTagging, visible, vlanId, walledGardenEnabled, walledGardenRanges, wpaEncryptionMode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateNetworkSsidRequest {\n");
    sb.append("    apTagsAndVlanIds: ").append(toIndentedString(apTagsAndVlanIds)).append("\n");
    sb.append("    authMode: ").append(toIndentedString(authMode)).append("\n");
    sb.append("    availabilityTags: ").append(toIndentedString(availabilityTags)).append("\n");
    sb.append("    availableOnAllAps: ").append(toIndentedString(availableOnAllAps)).append("\n");
    sb.append("    bandSelection: ").append(toIndentedString(bandSelection)).append("\n");
    sb.append("    concentratorNetworkId: ").append(toIndentedString(concentratorNetworkId)).append("\n");
    sb.append("    defaultVlanId: ").append(toIndentedString(defaultVlanId)).append("\n");
    sb.append("    disassociateClientsOnVpnFailover: ").append(toIndentedString(disassociateClientsOnVpnFailover)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    encryptionMode: ").append(toIndentedString(encryptionMode)).append("\n");
    sb.append("    enterpriseAdminAccess: ").append(toIndentedString(enterpriseAdminAccess)).append("\n");
    sb.append("    ipAssignmentMode: ").append(toIndentedString(ipAssignmentMode)).append("\n");
    sb.append("    lanIsolationEnabled: ").append(toIndentedString(lanIsolationEnabled)).append("\n");
    sb.append("    minBitrate: ").append(toIndentedString(minBitrate)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    perClientBandwidthLimitDown: ").append(toIndentedString(perClientBandwidthLimitDown)).append("\n");
    sb.append("    perClientBandwidthLimitUp: ").append(toIndentedString(perClientBandwidthLimitUp)).append("\n");
    sb.append("    psk: ").append(toIndentedString(psk)).append("\n");
    sb.append("    radiusAccountingEnabled: ").append(toIndentedString(radiusAccountingEnabled)).append("\n");
    sb.append("    radiusAccountingServers: ").append(toIndentedString(radiusAccountingServers)).append("\n");
    sb.append("    radiusAttributeForGroupPolicies: ").append(toIndentedString(radiusAttributeForGroupPolicies)).append("\n");
    sb.append("    radiusCoaEnabled: ").append(toIndentedString(radiusCoaEnabled)).append("\n");
    sb.append("    radiusFailoverPolicy: ").append(toIndentedString(radiusFailoverPolicy)).append("\n");
    sb.append("    radiusLoadBalancingPolicy: ").append(toIndentedString(radiusLoadBalancingPolicy)).append("\n");
    sb.append("    radiusOverride: ").append(toIndentedString(radiusOverride)).append("\n");
    sb.append("    radiusServers: ").append(toIndentedString(radiusServers)).append("\n");
    sb.append("    secondaryConcentratorNetworkId: ").append(toIndentedString(secondaryConcentratorNetworkId)).append("\n");
    sb.append("    splashPage: ").append(toIndentedString(splashPage)).append("\n");
    sb.append("    useVlanTagging: ").append(toIndentedString(useVlanTagging)).append("\n");
    sb.append("    visible: ").append(toIndentedString(visible)).append("\n");
    sb.append("    vlanId: ").append(toIndentedString(vlanId)).append("\n");
    sb.append("    walledGardenEnabled: ").append(toIndentedString(walledGardenEnabled)).append("\n");
    sb.append("    walledGardenRanges: ").append(toIndentedString(walledGardenRanges)).append("\n");
    sb.append("    wpaEncryptionMode: ").append(toIndentedString(wpaEncryptionMode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("apTagsAndVlanIds");
    openapiFields.add("authMode");
    openapiFields.add("availabilityTags");
    openapiFields.add("availableOnAllAps");
    openapiFields.add("bandSelection");
    openapiFields.add("concentratorNetworkId");
    openapiFields.add("defaultVlanId");
    openapiFields.add("disassociateClientsOnVpnFailover");
    openapiFields.add("enabled");
    openapiFields.add("encryptionMode");
    openapiFields.add("enterpriseAdminAccess");
    openapiFields.add("ipAssignmentMode");
    openapiFields.add("lanIsolationEnabled");
    openapiFields.add("minBitrate");
    openapiFields.add("name");
    openapiFields.add("perClientBandwidthLimitDown");
    openapiFields.add("perClientBandwidthLimitUp");
    openapiFields.add("psk");
    openapiFields.add("radiusAccountingEnabled");
    openapiFields.add("radiusAccountingServers");
    openapiFields.add("radiusAttributeForGroupPolicies");
    openapiFields.add("radiusCoaEnabled");
    openapiFields.add("radiusFailoverPolicy");
    openapiFields.add("radiusLoadBalancingPolicy");
    openapiFields.add("radiusOverride");
    openapiFields.add("radiusServers");
    openapiFields.add("secondaryConcentratorNetworkId");
    openapiFields.add("splashPage");
    openapiFields.add("useVlanTagging");
    openapiFields.add("visible");
    openapiFields.add("vlanId");
    openapiFields.add("walledGardenEnabled");
    openapiFields.add("walledGardenRanges");
    openapiFields.add("wpaEncryptionMode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateNetworkSsidRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateNetworkSsidRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateNetworkSsidRequest is not found in the empty JSON string", UpdateNetworkSsidRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateNetworkSsidRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateNetworkSsidRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("apTagsAndVlanIds") != null && !jsonObj.get("apTagsAndVlanIds").isJsonNull()) {
        JsonArray jsonArrayapTagsAndVlanIds = jsonObj.getAsJsonArray("apTagsAndVlanIds");
        if (jsonArrayapTagsAndVlanIds != null) {
          // ensure the json data is an array
          if (!jsonObj.get("apTagsAndVlanIds").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `apTagsAndVlanIds` to be an array in the JSON string but got `%s`", jsonObj.get("apTagsAndVlanIds").toString()));
          }

          // validate the optional field `apTagsAndVlanIds` (array)
          for (int i = 0; i < jsonArrayapTagsAndVlanIds.size(); i++) {
            UpdateNetworkSsidRequestApTagsAndVlanIdsInner.validateJsonElement(jsonArrayapTagsAndVlanIds.get(i));
          };
        }
      }
      if ((jsonObj.get("authMode") != null && !jsonObj.get("authMode").isJsonNull()) && !jsonObj.get("authMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authMode").toString()));
      }
      // validate the optional field `authMode`
      if (jsonObj.get("authMode") != null && !jsonObj.get("authMode").isJsonNull()) {
        AuthModeEnum.validateJsonElement(jsonObj.get("authMode"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("availabilityTags") != null && !jsonObj.get("availabilityTags").isJsonNull() && !jsonObj.get("availabilityTags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `availabilityTags` to be an array in the JSON string but got `%s`", jsonObj.get("availabilityTags").toString()));
      }
      if ((jsonObj.get("bandSelection") != null && !jsonObj.get("bandSelection").isJsonNull()) && !jsonObj.get("bandSelection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bandSelection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bandSelection").toString()));
      }
      if ((jsonObj.get("concentratorNetworkId") != null && !jsonObj.get("concentratorNetworkId").isJsonNull()) && !jsonObj.get("concentratorNetworkId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `concentratorNetworkId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("concentratorNetworkId").toString()));
      }
      if ((jsonObj.get("encryptionMode") != null && !jsonObj.get("encryptionMode").isJsonNull()) && !jsonObj.get("encryptionMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `encryptionMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("encryptionMode").toString()));
      }
      // validate the optional field `encryptionMode`
      if (jsonObj.get("encryptionMode") != null && !jsonObj.get("encryptionMode").isJsonNull()) {
        EncryptionModeEnum.validateJsonElement(jsonObj.get("encryptionMode"));
      }
      if ((jsonObj.get("enterpriseAdminAccess") != null && !jsonObj.get("enterpriseAdminAccess").isJsonNull()) && !jsonObj.get("enterpriseAdminAccess").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `enterpriseAdminAccess` to be a primitive type in the JSON string but got `%s`", jsonObj.get("enterpriseAdminAccess").toString()));
      }
      // validate the optional field `enterpriseAdminAccess`
      if (jsonObj.get("enterpriseAdminAccess") != null && !jsonObj.get("enterpriseAdminAccess").isJsonNull()) {
        EnterpriseAdminAccessEnum.validateJsonElement(jsonObj.get("enterpriseAdminAccess"));
      }
      if ((jsonObj.get("ipAssignmentMode") != null && !jsonObj.get("ipAssignmentMode").isJsonNull()) && !jsonObj.get("ipAssignmentMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipAssignmentMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipAssignmentMode").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("psk") != null && !jsonObj.get("psk").isJsonNull()) && !jsonObj.get("psk").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `psk` to be a primitive type in the JSON string but got `%s`", jsonObj.get("psk").toString()));
      }
      if (jsonObj.get("radiusAccountingServers") != null && !jsonObj.get("radiusAccountingServers").isJsonNull()) {
        JsonArray jsonArrayradiusAccountingServers = jsonObj.getAsJsonArray("radiusAccountingServers");
        if (jsonArrayradiusAccountingServers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("radiusAccountingServers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `radiusAccountingServers` to be an array in the JSON string but got `%s`", jsonObj.get("radiusAccountingServers").toString()));
          }

          // validate the optional field `radiusAccountingServers` (array)
          for (int i = 0; i < jsonArrayradiusAccountingServers.size(); i++) {
            UpdateNetworkSsidRequestRadiusAccountingServersInner.validateJsonElement(jsonArrayradiusAccountingServers.get(i));
          };
        }
      }
      if ((jsonObj.get("radiusAttributeForGroupPolicies") != null && !jsonObj.get("radiusAttributeForGroupPolicies").isJsonNull()) && !jsonObj.get("radiusAttributeForGroupPolicies").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `radiusAttributeForGroupPolicies` to be a primitive type in the JSON string but got `%s`", jsonObj.get("radiusAttributeForGroupPolicies").toString()));
      }
      if ((jsonObj.get("radiusFailoverPolicy") != null && !jsonObj.get("radiusFailoverPolicy").isJsonNull()) && !jsonObj.get("radiusFailoverPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `radiusFailoverPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("radiusFailoverPolicy").toString()));
      }
      // validate the optional field `radiusFailoverPolicy`
      if (jsonObj.get("radiusFailoverPolicy") != null && !jsonObj.get("radiusFailoverPolicy").isJsonNull()) {
        RadiusFailoverPolicyEnum.validateJsonElement(jsonObj.get("radiusFailoverPolicy"));
      }
      if ((jsonObj.get("radiusLoadBalancingPolicy") != null && !jsonObj.get("radiusLoadBalancingPolicy").isJsonNull()) && !jsonObj.get("radiusLoadBalancingPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `radiusLoadBalancingPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("radiusLoadBalancingPolicy").toString()));
      }
      // validate the optional field `radiusLoadBalancingPolicy`
      if (jsonObj.get("radiusLoadBalancingPolicy") != null && !jsonObj.get("radiusLoadBalancingPolicy").isJsonNull()) {
        RadiusLoadBalancingPolicyEnum.validateJsonElement(jsonObj.get("radiusLoadBalancingPolicy"));
      }
      if (jsonObj.get("radiusServers") != null && !jsonObj.get("radiusServers").isJsonNull()) {
        JsonArray jsonArrayradiusServers = jsonObj.getAsJsonArray("radiusServers");
        if (jsonArrayradiusServers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("radiusServers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `radiusServers` to be an array in the JSON string but got `%s`", jsonObj.get("radiusServers").toString()));
          }

          // validate the optional field `radiusServers` (array)
          for (int i = 0; i < jsonArrayradiusServers.size(); i++) {
            UpdateNetworkSsidRequestRadiusServersInner.validateJsonElement(jsonArrayradiusServers.get(i));
          };
        }
      }
      if ((jsonObj.get("secondaryConcentratorNetworkId") != null && !jsonObj.get("secondaryConcentratorNetworkId").isJsonNull()) && !jsonObj.get("secondaryConcentratorNetworkId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secondaryConcentratorNetworkId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secondaryConcentratorNetworkId").toString()));
      }
      if ((jsonObj.get("splashPage") != null && !jsonObj.get("splashPage").isJsonNull()) && !jsonObj.get("splashPage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `splashPage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("splashPage").toString()));
      }
      // validate the optional field `splashPage`
      if (jsonObj.get("splashPage") != null && !jsonObj.get("splashPage").isJsonNull()) {
        SplashPageEnum.validateJsonElement(jsonObj.get("splashPage"));
      }
      if ((jsonObj.get("walledGardenRanges") != null && !jsonObj.get("walledGardenRanges").isJsonNull()) && !jsonObj.get("walledGardenRanges").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `walledGardenRanges` to be a primitive type in the JSON string but got `%s`", jsonObj.get("walledGardenRanges").toString()));
      }
      if ((jsonObj.get("wpaEncryptionMode") != null && !jsonObj.get("wpaEncryptionMode").isJsonNull()) && !jsonObj.get("wpaEncryptionMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `wpaEncryptionMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("wpaEncryptionMode").toString()));
      }
      // validate the optional field `wpaEncryptionMode`
      if (jsonObj.get("wpaEncryptionMode") != null && !jsonObj.get("wpaEncryptionMode").isJsonNull()) {
        WpaEncryptionModeEnum.validateJsonElement(jsonObj.get("wpaEncryptionMode"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateNetworkSsidRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateNetworkSsidRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateNetworkSsidRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateNetworkSsidRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateNetworkSsidRequest>() {
           @Override
           public void write(JsonWriter out, UpdateNetworkSsidRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateNetworkSsidRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateNetworkSsidRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateNetworkSsidRequest
   * @throws IOException if the JSON string is invalid with respect to UpdateNetworkSsidRequest
   */
  public static UpdateNetworkSsidRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateNetworkSsidRequest.class);
  }

  /**
   * Convert an instance of UpdateNetworkSsidRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

