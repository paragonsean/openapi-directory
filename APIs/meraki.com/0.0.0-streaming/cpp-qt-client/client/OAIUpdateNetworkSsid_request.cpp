/**
 * Meraki Dashboard API
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 23 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 
 *
 * The version of the OpenAPI document: 0.0.0-streaming
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIUpdateNetworkSsid_request.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIUpdateNetworkSsid_request::OAIUpdateNetworkSsid_request(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIUpdateNetworkSsid_request::OAIUpdateNetworkSsid_request() {
    this->initializeModel();
}

OAIUpdateNetworkSsid_request::~OAIUpdateNetworkSsid_request() {}

void OAIUpdateNetworkSsid_request::initializeModel() {

    m_ap_tags_and_vlan_ids_isSet = false;
    m_ap_tags_and_vlan_ids_isValid = false;

    m_auth_mode_isSet = false;
    m_auth_mode_isValid = false;

    m_availability_tags_isSet = false;
    m_availability_tags_isValid = false;

    m_available_on_all_aps_isSet = false;
    m_available_on_all_aps_isValid = false;

    m_band_selection_isSet = false;
    m_band_selection_isValid = false;

    m_concentrator_network_id_isSet = false;
    m_concentrator_network_id_isValid = false;

    m_default_vlan_id_isSet = false;
    m_default_vlan_id_isValid = false;

    m_disassociate_clients_on_vpn_failover_isSet = false;
    m_disassociate_clients_on_vpn_failover_isValid = false;

    m_enabled_isSet = false;
    m_enabled_isValid = false;

    m_encryption_mode_isSet = false;
    m_encryption_mode_isValid = false;

    m_enterprise_admin_access_isSet = false;
    m_enterprise_admin_access_isValid = false;

    m_ip_assignment_mode_isSet = false;
    m_ip_assignment_mode_isValid = false;

    m_lan_isolation_enabled_isSet = false;
    m_lan_isolation_enabled_isValid = false;

    m_min_bitrate_isSet = false;
    m_min_bitrate_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_per_client_bandwidth_limit_down_isSet = false;
    m_per_client_bandwidth_limit_down_isValid = false;

    m_per_client_bandwidth_limit_up_isSet = false;
    m_per_client_bandwidth_limit_up_isValid = false;

    m_psk_isSet = false;
    m_psk_isValid = false;

    m_radius_accounting_enabled_isSet = false;
    m_radius_accounting_enabled_isValid = false;

    m_radius_accounting_servers_isSet = false;
    m_radius_accounting_servers_isValid = false;

    m_radius_attribute_for_group_policies_isSet = false;
    m_radius_attribute_for_group_policies_isValid = false;

    m_radius_coa_enabled_isSet = false;
    m_radius_coa_enabled_isValid = false;

    m_radius_failover_policy_isSet = false;
    m_radius_failover_policy_isValid = false;

    m_radius_load_balancing_policy_isSet = false;
    m_radius_load_balancing_policy_isValid = false;

    m_radius_override_isSet = false;
    m_radius_override_isValid = false;

    m_radius_servers_isSet = false;
    m_radius_servers_isValid = false;

    m_secondary_concentrator_network_id_isSet = false;
    m_secondary_concentrator_network_id_isValid = false;

    m_splash_page_isSet = false;
    m_splash_page_isValid = false;

    m_use_vlan_tagging_isSet = false;
    m_use_vlan_tagging_isValid = false;

    m_visible_isSet = false;
    m_visible_isValid = false;

    m_vlan_id_isSet = false;
    m_vlan_id_isValid = false;

    m_walled_garden_enabled_isSet = false;
    m_walled_garden_enabled_isValid = false;

    m_walled_garden_ranges_isSet = false;
    m_walled_garden_ranges_isValid = false;

    m_wpa_encryption_mode_isSet = false;
    m_wpa_encryption_mode_isValid = false;
}

void OAIUpdateNetworkSsid_request::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIUpdateNetworkSsid_request::fromJsonObject(QJsonObject json) {

    m_ap_tags_and_vlan_ids_isValid = ::OpenAPI::fromJsonValue(m_ap_tags_and_vlan_ids, json[QString("apTagsAndVlanIds")]);
    m_ap_tags_and_vlan_ids_isSet = !json[QString("apTagsAndVlanIds")].isNull() && m_ap_tags_and_vlan_ids_isValid;

    m_auth_mode_isValid = ::OpenAPI::fromJsonValue(m_auth_mode, json[QString("authMode")]);
    m_auth_mode_isSet = !json[QString("authMode")].isNull() && m_auth_mode_isValid;

    m_availability_tags_isValid = ::OpenAPI::fromJsonValue(m_availability_tags, json[QString("availabilityTags")]);
    m_availability_tags_isSet = !json[QString("availabilityTags")].isNull() && m_availability_tags_isValid;

    m_available_on_all_aps_isValid = ::OpenAPI::fromJsonValue(m_available_on_all_aps, json[QString("availableOnAllAps")]);
    m_available_on_all_aps_isSet = !json[QString("availableOnAllAps")].isNull() && m_available_on_all_aps_isValid;

    m_band_selection_isValid = ::OpenAPI::fromJsonValue(m_band_selection, json[QString("bandSelection")]);
    m_band_selection_isSet = !json[QString("bandSelection")].isNull() && m_band_selection_isValid;

    m_concentrator_network_id_isValid = ::OpenAPI::fromJsonValue(m_concentrator_network_id, json[QString("concentratorNetworkId")]);
    m_concentrator_network_id_isSet = !json[QString("concentratorNetworkId")].isNull() && m_concentrator_network_id_isValid;

    m_default_vlan_id_isValid = ::OpenAPI::fromJsonValue(m_default_vlan_id, json[QString("defaultVlanId")]);
    m_default_vlan_id_isSet = !json[QString("defaultVlanId")].isNull() && m_default_vlan_id_isValid;

    m_disassociate_clients_on_vpn_failover_isValid = ::OpenAPI::fromJsonValue(m_disassociate_clients_on_vpn_failover, json[QString("disassociateClientsOnVpnFailover")]);
    m_disassociate_clients_on_vpn_failover_isSet = !json[QString("disassociateClientsOnVpnFailover")].isNull() && m_disassociate_clients_on_vpn_failover_isValid;

    m_enabled_isValid = ::OpenAPI::fromJsonValue(m_enabled, json[QString("enabled")]);
    m_enabled_isSet = !json[QString("enabled")].isNull() && m_enabled_isValid;

    m_encryption_mode_isValid = ::OpenAPI::fromJsonValue(m_encryption_mode, json[QString("encryptionMode")]);
    m_encryption_mode_isSet = !json[QString("encryptionMode")].isNull() && m_encryption_mode_isValid;

    m_enterprise_admin_access_isValid = ::OpenAPI::fromJsonValue(m_enterprise_admin_access, json[QString("enterpriseAdminAccess")]);
    m_enterprise_admin_access_isSet = !json[QString("enterpriseAdminAccess")].isNull() && m_enterprise_admin_access_isValid;

    m_ip_assignment_mode_isValid = ::OpenAPI::fromJsonValue(m_ip_assignment_mode, json[QString("ipAssignmentMode")]);
    m_ip_assignment_mode_isSet = !json[QString("ipAssignmentMode")].isNull() && m_ip_assignment_mode_isValid;

    m_lan_isolation_enabled_isValid = ::OpenAPI::fromJsonValue(m_lan_isolation_enabled, json[QString("lanIsolationEnabled")]);
    m_lan_isolation_enabled_isSet = !json[QString("lanIsolationEnabled")].isNull() && m_lan_isolation_enabled_isValid;

    m_min_bitrate_isValid = ::OpenAPI::fromJsonValue(m_min_bitrate, json[QString("minBitrate")]);
    m_min_bitrate_isSet = !json[QString("minBitrate")].isNull() && m_min_bitrate_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_per_client_bandwidth_limit_down_isValid = ::OpenAPI::fromJsonValue(m_per_client_bandwidth_limit_down, json[QString("perClientBandwidthLimitDown")]);
    m_per_client_bandwidth_limit_down_isSet = !json[QString("perClientBandwidthLimitDown")].isNull() && m_per_client_bandwidth_limit_down_isValid;

    m_per_client_bandwidth_limit_up_isValid = ::OpenAPI::fromJsonValue(m_per_client_bandwidth_limit_up, json[QString("perClientBandwidthLimitUp")]);
    m_per_client_bandwidth_limit_up_isSet = !json[QString("perClientBandwidthLimitUp")].isNull() && m_per_client_bandwidth_limit_up_isValid;

    m_psk_isValid = ::OpenAPI::fromJsonValue(m_psk, json[QString("psk")]);
    m_psk_isSet = !json[QString("psk")].isNull() && m_psk_isValid;

    m_radius_accounting_enabled_isValid = ::OpenAPI::fromJsonValue(m_radius_accounting_enabled, json[QString("radiusAccountingEnabled")]);
    m_radius_accounting_enabled_isSet = !json[QString("radiusAccountingEnabled")].isNull() && m_radius_accounting_enabled_isValid;

    m_radius_accounting_servers_isValid = ::OpenAPI::fromJsonValue(m_radius_accounting_servers, json[QString("radiusAccountingServers")]);
    m_radius_accounting_servers_isSet = !json[QString("radiusAccountingServers")].isNull() && m_radius_accounting_servers_isValid;

    m_radius_attribute_for_group_policies_isValid = ::OpenAPI::fromJsonValue(m_radius_attribute_for_group_policies, json[QString("radiusAttributeForGroupPolicies")]);
    m_radius_attribute_for_group_policies_isSet = !json[QString("radiusAttributeForGroupPolicies")].isNull() && m_radius_attribute_for_group_policies_isValid;

    m_radius_coa_enabled_isValid = ::OpenAPI::fromJsonValue(m_radius_coa_enabled, json[QString("radiusCoaEnabled")]);
    m_radius_coa_enabled_isSet = !json[QString("radiusCoaEnabled")].isNull() && m_radius_coa_enabled_isValid;

    m_radius_failover_policy_isValid = ::OpenAPI::fromJsonValue(m_radius_failover_policy, json[QString("radiusFailoverPolicy")]);
    m_radius_failover_policy_isSet = !json[QString("radiusFailoverPolicy")].isNull() && m_radius_failover_policy_isValid;

    m_radius_load_balancing_policy_isValid = ::OpenAPI::fromJsonValue(m_radius_load_balancing_policy, json[QString("radiusLoadBalancingPolicy")]);
    m_radius_load_balancing_policy_isSet = !json[QString("radiusLoadBalancingPolicy")].isNull() && m_radius_load_balancing_policy_isValid;

    m_radius_override_isValid = ::OpenAPI::fromJsonValue(m_radius_override, json[QString("radiusOverride")]);
    m_radius_override_isSet = !json[QString("radiusOverride")].isNull() && m_radius_override_isValid;

    m_radius_servers_isValid = ::OpenAPI::fromJsonValue(m_radius_servers, json[QString("radiusServers")]);
    m_radius_servers_isSet = !json[QString("radiusServers")].isNull() && m_radius_servers_isValid;

    m_secondary_concentrator_network_id_isValid = ::OpenAPI::fromJsonValue(m_secondary_concentrator_network_id, json[QString("secondaryConcentratorNetworkId")]);
    m_secondary_concentrator_network_id_isSet = !json[QString("secondaryConcentratorNetworkId")].isNull() && m_secondary_concentrator_network_id_isValid;

    m_splash_page_isValid = ::OpenAPI::fromJsonValue(m_splash_page, json[QString("splashPage")]);
    m_splash_page_isSet = !json[QString("splashPage")].isNull() && m_splash_page_isValid;

    m_use_vlan_tagging_isValid = ::OpenAPI::fromJsonValue(m_use_vlan_tagging, json[QString("useVlanTagging")]);
    m_use_vlan_tagging_isSet = !json[QString("useVlanTagging")].isNull() && m_use_vlan_tagging_isValid;

    m_visible_isValid = ::OpenAPI::fromJsonValue(m_visible, json[QString("visible")]);
    m_visible_isSet = !json[QString("visible")].isNull() && m_visible_isValid;

    m_vlan_id_isValid = ::OpenAPI::fromJsonValue(m_vlan_id, json[QString("vlanId")]);
    m_vlan_id_isSet = !json[QString("vlanId")].isNull() && m_vlan_id_isValid;

    m_walled_garden_enabled_isValid = ::OpenAPI::fromJsonValue(m_walled_garden_enabled, json[QString("walledGardenEnabled")]);
    m_walled_garden_enabled_isSet = !json[QString("walledGardenEnabled")].isNull() && m_walled_garden_enabled_isValid;

    m_walled_garden_ranges_isValid = ::OpenAPI::fromJsonValue(m_walled_garden_ranges, json[QString("walledGardenRanges")]);
    m_walled_garden_ranges_isSet = !json[QString("walledGardenRanges")].isNull() && m_walled_garden_ranges_isValid;

    m_wpa_encryption_mode_isValid = ::OpenAPI::fromJsonValue(m_wpa_encryption_mode, json[QString("wpaEncryptionMode")]);
    m_wpa_encryption_mode_isSet = !json[QString("wpaEncryptionMode")].isNull() && m_wpa_encryption_mode_isValid;
}

QString OAIUpdateNetworkSsid_request::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIUpdateNetworkSsid_request::asJsonObject() const {
    QJsonObject obj;
    if (m_ap_tags_and_vlan_ids.size() > 0) {
        obj.insert(QString("apTagsAndVlanIds"), ::OpenAPI::toJsonValue(m_ap_tags_and_vlan_ids));
    }
    if (m_auth_mode_isSet) {
        obj.insert(QString("authMode"), ::OpenAPI::toJsonValue(m_auth_mode));
    }
    if (m_availability_tags.size() > 0) {
        obj.insert(QString("availabilityTags"), ::OpenAPI::toJsonValue(m_availability_tags));
    }
    if (m_available_on_all_aps_isSet) {
        obj.insert(QString("availableOnAllAps"), ::OpenAPI::toJsonValue(m_available_on_all_aps));
    }
    if (m_band_selection_isSet) {
        obj.insert(QString("bandSelection"), ::OpenAPI::toJsonValue(m_band_selection));
    }
    if (m_concentrator_network_id_isSet) {
        obj.insert(QString("concentratorNetworkId"), ::OpenAPI::toJsonValue(m_concentrator_network_id));
    }
    if (m_default_vlan_id_isSet) {
        obj.insert(QString("defaultVlanId"), ::OpenAPI::toJsonValue(m_default_vlan_id));
    }
    if (m_disassociate_clients_on_vpn_failover_isSet) {
        obj.insert(QString("disassociateClientsOnVpnFailover"), ::OpenAPI::toJsonValue(m_disassociate_clients_on_vpn_failover));
    }
    if (m_enabled_isSet) {
        obj.insert(QString("enabled"), ::OpenAPI::toJsonValue(m_enabled));
    }
    if (m_encryption_mode_isSet) {
        obj.insert(QString("encryptionMode"), ::OpenAPI::toJsonValue(m_encryption_mode));
    }
    if (m_enterprise_admin_access_isSet) {
        obj.insert(QString("enterpriseAdminAccess"), ::OpenAPI::toJsonValue(m_enterprise_admin_access));
    }
    if (m_ip_assignment_mode_isSet) {
        obj.insert(QString("ipAssignmentMode"), ::OpenAPI::toJsonValue(m_ip_assignment_mode));
    }
    if (m_lan_isolation_enabled_isSet) {
        obj.insert(QString("lanIsolationEnabled"), ::OpenAPI::toJsonValue(m_lan_isolation_enabled));
    }
    if (m_min_bitrate_isSet) {
        obj.insert(QString("minBitrate"), ::OpenAPI::toJsonValue(m_min_bitrate));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_per_client_bandwidth_limit_down_isSet) {
        obj.insert(QString("perClientBandwidthLimitDown"), ::OpenAPI::toJsonValue(m_per_client_bandwidth_limit_down));
    }
    if (m_per_client_bandwidth_limit_up_isSet) {
        obj.insert(QString("perClientBandwidthLimitUp"), ::OpenAPI::toJsonValue(m_per_client_bandwidth_limit_up));
    }
    if (m_psk_isSet) {
        obj.insert(QString("psk"), ::OpenAPI::toJsonValue(m_psk));
    }
    if (m_radius_accounting_enabled_isSet) {
        obj.insert(QString("radiusAccountingEnabled"), ::OpenAPI::toJsonValue(m_radius_accounting_enabled));
    }
    if (m_radius_accounting_servers.size() > 0) {
        obj.insert(QString("radiusAccountingServers"), ::OpenAPI::toJsonValue(m_radius_accounting_servers));
    }
    if (m_radius_attribute_for_group_policies_isSet) {
        obj.insert(QString("radiusAttributeForGroupPolicies"), ::OpenAPI::toJsonValue(m_radius_attribute_for_group_policies));
    }
    if (m_radius_coa_enabled_isSet) {
        obj.insert(QString("radiusCoaEnabled"), ::OpenAPI::toJsonValue(m_radius_coa_enabled));
    }
    if (m_radius_failover_policy_isSet) {
        obj.insert(QString("radiusFailoverPolicy"), ::OpenAPI::toJsonValue(m_radius_failover_policy));
    }
    if (m_radius_load_balancing_policy_isSet) {
        obj.insert(QString("radiusLoadBalancingPolicy"), ::OpenAPI::toJsonValue(m_radius_load_balancing_policy));
    }
    if (m_radius_override_isSet) {
        obj.insert(QString("radiusOverride"), ::OpenAPI::toJsonValue(m_radius_override));
    }
    if (m_radius_servers.size() > 0) {
        obj.insert(QString("radiusServers"), ::OpenAPI::toJsonValue(m_radius_servers));
    }
    if (m_secondary_concentrator_network_id_isSet) {
        obj.insert(QString("secondaryConcentratorNetworkId"), ::OpenAPI::toJsonValue(m_secondary_concentrator_network_id));
    }
    if (m_splash_page_isSet) {
        obj.insert(QString("splashPage"), ::OpenAPI::toJsonValue(m_splash_page));
    }
    if (m_use_vlan_tagging_isSet) {
        obj.insert(QString("useVlanTagging"), ::OpenAPI::toJsonValue(m_use_vlan_tagging));
    }
    if (m_visible_isSet) {
        obj.insert(QString("visible"), ::OpenAPI::toJsonValue(m_visible));
    }
    if (m_vlan_id_isSet) {
        obj.insert(QString("vlanId"), ::OpenAPI::toJsonValue(m_vlan_id));
    }
    if (m_walled_garden_enabled_isSet) {
        obj.insert(QString("walledGardenEnabled"), ::OpenAPI::toJsonValue(m_walled_garden_enabled));
    }
    if (m_walled_garden_ranges_isSet) {
        obj.insert(QString("walledGardenRanges"), ::OpenAPI::toJsonValue(m_walled_garden_ranges));
    }
    if (m_wpa_encryption_mode_isSet) {
        obj.insert(QString("wpaEncryptionMode"), ::OpenAPI::toJsonValue(m_wpa_encryption_mode));
    }
    return obj;
}

QList<OAIUpdateNetworkSsid_request_apTagsAndVlanIds_inner> OAIUpdateNetworkSsid_request::getApTagsAndVlanIds() const {
    return m_ap_tags_and_vlan_ids;
}
void OAIUpdateNetworkSsid_request::setApTagsAndVlanIds(const QList<OAIUpdateNetworkSsid_request_apTagsAndVlanIds_inner> &ap_tags_and_vlan_ids) {
    m_ap_tags_and_vlan_ids = ap_tags_and_vlan_ids;
    m_ap_tags_and_vlan_ids_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_ap_tags_and_vlan_ids_Set() const{
    return m_ap_tags_and_vlan_ids_isSet;
}

bool OAIUpdateNetworkSsid_request::is_ap_tags_and_vlan_ids_Valid() const{
    return m_ap_tags_and_vlan_ids_isValid;
}

QString OAIUpdateNetworkSsid_request::getAuthMode() const {
    return m_auth_mode;
}
void OAIUpdateNetworkSsid_request::setAuthMode(const QString &auth_mode) {
    m_auth_mode = auth_mode;
    m_auth_mode_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_auth_mode_Set() const{
    return m_auth_mode_isSet;
}

bool OAIUpdateNetworkSsid_request::is_auth_mode_Valid() const{
    return m_auth_mode_isValid;
}

QList<QString> OAIUpdateNetworkSsid_request::getAvailabilityTags() const {
    return m_availability_tags;
}
void OAIUpdateNetworkSsid_request::setAvailabilityTags(const QList<QString> &availability_tags) {
    m_availability_tags = availability_tags;
    m_availability_tags_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_availability_tags_Set() const{
    return m_availability_tags_isSet;
}

bool OAIUpdateNetworkSsid_request::is_availability_tags_Valid() const{
    return m_availability_tags_isValid;
}

bool OAIUpdateNetworkSsid_request::isAvailableOnAllAps() const {
    return m_available_on_all_aps;
}
void OAIUpdateNetworkSsid_request::setAvailableOnAllAps(const bool &available_on_all_aps) {
    m_available_on_all_aps = available_on_all_aps;
    m_available_on_all_aps_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_available_on_all_aps_Set() const{
    return m_available_on_all_aps_isSet;
}

bool OAIUpdateNetworkSsid_request::is_available_on_all_aps_Valid() const{
    return m_available_on_all_aps_isValid;
}

QString OAIUpdateNetworkSsid_request::getBandSelection() const {
    return m_band_selection;
}
void OAIUpdateNetworkSsid_request::setBandSelection(const QString &band_selection) {
    m_band_selection = band_selection;
    m_band_selection_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_band_selection_Set() const{
    return m_band_selection_isSet;
}

bool OAIUpdateNetworkSsid_request::is_band_selection_Valid() const{
    return m_band_selection_isValid;
}

QString OAIUpdateNetworkSsid_request::getConcentratorNetworkId() const {
    return m_concentrator_network_id;
}
void OAIUpdateNetworkSsid_request::setConcentratorNetworkId(const QString &concentrator_network_id) {
    m_concentrator_network_id = concentrator_network_id;
    m_concentrator_network_id_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_concentrator_network_id_Set() const{
    return m_concentrator_network_id_isSet;
}

bool OAIUpdateNetworkSsid_request::is_concentrator_network_id_Valid() const{
    return m_concentrator_network_id_isValid;
}

qint32 OAIUpdateNetworkSsid_request::getDefaultVlanId() const {
    return m_default_vlan_id;
}
void OAIUpdateNetworkSsid_request::setDefaultVlanId(const qint32 &default_vlan_id) {
    m_default_vlan_id = default_vlan_id;
    m_default_vlan_id_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_default_vlan_id_Set() const{
    return m_default_vlan_id_isSet;
}

bool OAIUpdateNetworkSsid_request::is_default_vlan_id_Valid() const{
    return m_default_vlan_id_isValid;
}

bool OAIUpdateNetworkSsid_request::isDisassociateClientsOnVpnFailover() const {
    return m_disassociate_clients_on_vpn_failover;
}
void OAIUpdateNetworkSsid_request::setDisassociateClientsOnVpnFailover(const bool &disassociate_clients_on_vpn_failover) {
    m_disassociate_clients_on_vpn_failover = disassociate_clients_on_vpn_failover;
    m_disassociate_clients_on_vpn_failover_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_disassociate_clients_on_vpn_failover_Set() const{
    return m_disassociate_clients_on_vpn_failover_isSet;
}

bool OAIUpdateNetworkSsid_request::is_disassociate_clients_on_vpn_failover_Valid() const{
    return m_disassociate_clients_on_vpn_failover_isValid;
}

bool OAIUpdateNetworkSsid_request::isEnabled() const {
    return m_enabled;
}
void OAIUpdateNetworkSsid_request::setEnabled(const bool &enabled) {
    m_enabled = enabled;
    m_enabled_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_enabled_Set() const{
    return m_enabled_isSet;
}

bool OAIUpdateNetworkSsid_request::is_enabled_Valid() const{
    return m_enabled_isValid;
}

QString OAIUpdateNetworkSsid_request::getEncryptionMode() const {
    return m_encryption_mode;
}
void OAIUpdateNetworkSsid_request::setEncryptionMode(const QString &encryption_mode) {
    m_encryption_mode = encryption_mode;
    m_encryption_mode_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_encryption_mode_Set() const{
    return m_encryption_mode_isSet;
}

bool OAIUpdateNetworkSsid_request::is_encryption_mode_Valid() const{
    return m_encryption_mode_isValid;
}

QString OAIUpdateNetworkSsid_request::getEnterpriseAdminAccess() const {
    return m_enterprise_admin_access;
}
void OAIUpdateNetworkSsid_request::setEnterpriseAdminAccess(const QString &enterprise_admin_access) {
    m_enterprise_admin_access = enterprise_admin_access;
    m_enterprise_admin_access_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_enterprise_admin_access_Set() const{
    return m_enterprise_admin_access_isSet;
}

bool OAIUpdateNetworkSsid_request::is_enterprise_admin_access_Valid() const{
    return m_enterprise_admin_access_isValid;
}

QString OAIUpdateNetworkSsid_request::getIpAssignmentMode() const {
    return m_ip_assignment_mode;
}
void OAIUpdateNetworkSsid_request::setIpAssignmentMode(const QString &ip_assignment_mode) {
    m_ip_assignment_mode = ip_assignment_mode;
    m_ip_assignment_mode_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_ip_assignment_mode_Set() const{
    return m_ip_assignment_mode_isSet;
}

bool OAIUpdateNetworkSsid_request::is_ip_assignment_mode_Valid() const{
    return m_ip_assignment_mode_isValid;
}

bool OAIUpdateNetworkSsid_request::isLanIsolationEnabled() const {
    return m_lan_isolation_enabled;
}
void OAIUpdateNetworkSsid_request::setLanIsolationEnabled(const bool &lan_isolation_enabled) {
    m_lan_isolation_enabled = lan_isolation_enabled;
    m_lan_isolation_enabled_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_lan_isolation_enabled_Set() const{
    return m_lan_isolation_enabled_isSet;
}

bool OAIUpdateNetworkSsid_request::is_lan_isolation_enabled_Valid() const{
    return m_lan_isolation_enabled_isValid;
}

float OAIUpdateNetworkSsid_request::getMinBitrate() const {
    return m_min_bitrate;
}
void OAIUpdateNetworkSsid_request::setMinBitrate(const float &min_bitrate) {
    m_min_bitrate = min_bitrate;
    m_min_bitrate_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_min_bitrate_Set() const{
    return m_min_bitrate_isSet;
}

bool OAIUpdateNetworkSsid_request::is_min_bitrate_Valid() const{
    return m_min_bitrate_isValid;
}

QString OAIUpdateNetworkSsid_request::getName() const {
    return m_name;
}
void OAIUpdateNetworkSsid_request::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_name_Set() const{
    return m_name_isSet;
}

bool OAIUpdateNetworkSsid_request::is_name_Valid() const{
    return m_name_isValid;
}

qint32 OAIUpdateNetworkSsid_request::getPerClientBandwidthLimitDown() const {
    return m_per_client_bandwidth_limit_down;
}
void OAIUpdateNetworkSsid_request::setPerClientBandwidthLimitDown(const qint32 &per_client_bandwidth_limit_down) {
    m_per_client_bandwidth_limit_down = per_client_bandwidth_limit_down;
    m_per_client_bandwidth_limit_down_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_per_client_bandwidth_limit_down_Set() const{
    return m_per_client_bandwidth_limit_down_isSet;
}

bool OAIUpdateNetworkSsid_request::is_per_client_bandwidth_limit_down_Valid() const{
    return m_per_client_bandwidth_limit_down_isValid;
}

qint32 OAIUpdateNetworkSsid_request::getPerClientBandwidthLimitUp() const {
    return m_per_client_bandwidth_limit_up;
}
void OAIUpdateNetworkSsid_request::setPerClientBandwidthLimitUp(const qint32 &per_client_bandwidth_limit_up) {
    m_per_client_bandwidth_limit_up = per_client_bandwidth_limit_up;
    m_per_client_bandwidth_limit_up_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_per_client_bandwidth_limit_up_Set() const{
    return m_per_client_bandwidth_limit_up_isSet;
}

bool OAIUpdateNetworkSsid_request::is_per_client_bandwidth_limit_up_Valid() const{
    return m_per_client_bandwidth_limit_up_isValid;
}

QString OAIUpdateNetworkSsid_request::getPsk() const {
    return m_psk;
}
void OAIUpdateNetworkSsid_request::setPsk(const QString &psk) {
    m_psk = psk;
    m_psk_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_psk_Set() const{
    return m_psk_isSet;
}

bool OAIUpdateNetworkSsid_request::is_psk_Valid() const{
    return m_psk_isValid;
}

bool OAIUpdateNetworkSsid_request::isRadiusAccountingEnabled() const {
    return m_radius_accounting_enabled;
}
void OAIUpdateNetworkSsid_request::setRadiusAccountingEnabled(const bool &radius_accounting_enabled) {
    m_radius_accounting_enabled = radius_accounting_enabled;
    m_radius_accounting_enabled_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_radius_accounting_enabled_Set() const{
    return m_radius_accounting_enabled_isSet;
}

bool OAIUpdateNetworkSsid_request::is_radius_accounting_enabled_Valid() const{
    return m_radius_accounting_enabled_isValid;
}

QList<OAIUpdateNetworkSsid_request_radiusAccountingServers_inner> OAIUpdateNetworkSsid_request::getRadiusAccountingServers() const {
    return m_radius_accounting_servers;
}
void OAIUpdateNetworkSsid_request::setRadiusAccountingServers(const QList<OAIUpdateNetworkSsid_request_radiusAccountingServers_inner> &radius_accounting_servers) {
    m_radius_accounting_servers = radius_accounting_servers;
    m_radius_accounting_servers_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_radius_accounting_servers_Set() const{
    return m_radius_accounting_servers_isSet;
}

bool OAIUpdateNetworkSsid_request::is_radius_accounting_servers_Valid() const{
    return m_radius_accounting_servers_isValid;
}

QString OAIUpdateNetworkSsid_request::getRadiusAttributeForGroupPolicies() const {
    return m_radius_attribute_for_group_policies;
}
void OAIUpdateNetworkSsid_request::setRadiusAttributeForGroupPolicies(const QString &radius_attribute_for_group_policies) {
    m_radius_attribute_for_group_policies = radius_attribute_for_group_policies;
    m_radius_attribute_for_group_policies_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_radius_attribute_for_group_policies_Set() const{
    return m_radius_attribute_for_group_policies_isSet;
}

bool OAIUpdateNetworkSsid_request::is_radius_attribute_for_group_policies_Valid() const{
    return m_radius_attribute_for_group_policies_isValid;
}

bool OAIUpdateNetworkSsid_request::isRadiusCoaEnabled() const {
    return m_radius_coa_enabled;
}
void OAIUpdateNetworkSsid_request::setRadiusCoaEnabled(const bool &radius_coa_enabled) {
    m_radius_coa_enabled = radius_coa_enabled;
    m_radius_coa_enabled_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_radius_coa_enabled_Set() const{
    return m_radius_coa_enabled_isSet;
}

bool OAIUpdateNetworkSsid_request::is_radius_coa_enabled_Valid() const{
    return m_radius_coa_enabled_isValid;
}

QString OAIUpdateNetworkSsid_request::getRadiusFailoverPolicy() const {
    return m_radius_failover_policy;
}
void OAIUpdateNetworkSsid_request::setRadiusFailoverPolicy(const QString &radius_failover_policy) {
    m_radius_failover_policy = radius_failover_policy;
    m_radius_failover_policy_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_radius_failover_policy_Set() const{
    return m_radius_failover_policy_isSet;
}

bool OAIUpdateNetworkSsid_request::is_radius_failover_policy_Valid() const{
    return m_radius_failover_policy_isValid;
}

QString OAIUpdateNetworkSsid_request::getRadiusLoadBalancingPolicy() const {
    return m_radius_load_balancing_policy;
}
void OAIUpdateNetworkSsid_request::setRadiusLoadBalancingPolicy(const QString &radius_load_balancing_policy) {
    m_radius_load_balancing_policy = radius_load_balancing_policy;
    m_radius_load_balancing_policy_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_radius_load_balancing_policy_Set() const{
    return m_radius_load_balancing_policy_isSet;
}

bool OAIUpdateNetworkSsid_request::is_radius_load_balancing_policy_Valid() const{
    return m_radius_load_balancing_policy_isValid;
}

bool OAIUpdateNetworkSsid_request::isRadiusOverride() const {
    return m_radius_override;
}
void OAIUpdateNetworkSsid_request::setRadiusOverride(const bool &radius_override) {
    m_radius_override = radius_override;
    m_radius_override_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_radius_override_Set() const{
    return m_radius_override_isSet;
}

bool OAIUpdateNetworkSsid_request::is_radius_override_Valid() const{
    return m_radius_override_isValid;
}

QList<OAIUpdateNetworkSsid_request_radiusServers_inner> OAIUpdateNetworkSsid_request::getRadiusServers() const {
    return m_radius_servers;
}
void OAIUpdateNetworkSsid_request::setRadiusServers(const QList<OAIUpdateNetworkSsid_request_radiusServers_inner> &radius_servers) {
    m_radius_servers = radius_servers;
    m_radius_servers_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_radius_servers_Set() const{
    return m_radius_servers_isSet;
}

bool OAIUpdateNetworkSsid_request::is_radius_servers_Valid() const{
    return m_radius_servers_isValid;
}

QString OAIUpdateNetworkSsid_request::getSecondaryConcentratorNetworkId() const {
    return m_secondary_concentrator_network_id;
}
void OAIUpdateNetworkSsid_request::setSecondaryConcentratorNetworkId(const QString &secondary_concentrator_network_id) {
    m_secondary_concentrator_network_id = secondary_concentrator_network_id;
    m_secondary_concentrator_network_id_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_secondary_concentrator_network_id_Set() const{
    return m_secondary_concentrator_network_id_isSet;
}

bool OAIUpdateNetworkSsid_request::is_secondary_concentrator_network_id_Valid() const{
    return m_secondary_concentrator_network_id_isValid;
}

QString OAIUpdateNetworkSsid_request::getSplashPage() const {
    return m_splash_page;
}
void OAIUpdateNetworkSsid_request::setSplashPage(const QString &splash_page) {
    m_splash_page = splash_page;
    m_splash_page_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_splash_page_Set() const{
    return m_splash_page_isSet;
}

bool OAIUpdateNetworkSsid_request::is_splash_page_Valid() const{
    return m_splash_page_isValid;
}

bool OAIUpdateNetworkSsid_request::isUseVlanTagging() const {
    return m_use_vlan_tagging;
}
void OAIUpdateNetworkSsid_request::setUseVlanTagging(const bool &use_vlan_tagging) {
    m_use_vlan_tagging = use_vlan_tagging;
    m_use_vlan_tagging_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_use_vlan_tagging_Set() const{
    return m_use_vlan_tagging_isSet;
}

bool OAIUpdateNetworkSsid_request::is_use_vlan_tagging_Valid() const{
    return m_use_vlan_tagging_isValid;
}

bool OAIUpdateNetworkSsid_request::isVisible() const {
    return m_visible;
}
void OAIUpdateNetworkSsid_request::setVisible(const bool &visible) {
    m_visible = visible;
    m_visible_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_visible_Set() const{
    return m_visible_isSet;
}

bool OAIUpdateNetworkSsid_request::is_visible_Valid() const{
    return m_visible_isValid;
}

qint32 OAIUpdateNetworkSsid_request::getVlanId() const {
    return m_vlan_id;
}
void OAIUpdateNetworkSsid_request::setVlanId(const qint32 &vlan_id) {
    m_vlan_id = vlan_id;
    m_vlan_id_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_vlan_id_Set() const{
    return m_vlan_id_isSet;
}

bool OAIUpdateNetworkSsid_request::is_vlan_id_Valid() const{
    return m_vlan_id_isValid;
}

bool OAIUpdateNetworkSsid_request::isWalledGardenEnabled() const {
    return m_walled_garden_enabled;
}
void OAIUpdateNetworkSsid_request::setWalledGardenEnabled(const bool &walled_garden_enabled) {
    m_walled_garden_enabled = walled_garden_enabled;
    m_walled_garden_enabled_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_walled_garden_enabled_Set() const{
    return m_walled_garden_enabled_isSet;
}

bool OAIUpdateNetworkSsid_request::is_walled_garden_enabled_Valid() const{
    return m_walled_garden_enabled_isValid;
}

QString OAIUpdateNetworkSsid_request::getWalledGardenRanges() const {
    return m_walled_garden_ranges;
}
void OAIUpdateNetworkSsid_request::setWalledGardenRanges(const QString &walled_garden_ranges) {
    m_walled_garden_ranges = walled_garden_ranges;
    m_walled_garden_ranges_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_walled_garden_ranges_Set() const{
    return m_walled_garden_ranges_isSet;
}

bool OAIUpdateNetworkSsid_request::is_walled_garden_ranges_Valid() const{
    return m_walled_garden_ranges_isValid;
}

QString OAIUpdateNetworkSsid_request::getWpaEncryptionMode() const {
    return m_wpa_encryption_mode;
}
void OAIUpdateNetworkSsid_request::setWpaEncryptionMode(const QString &wpa_encryption_mode) {
    m_wpa_encryption_mode = wpa_encryption_mode;
    m_wpa_encryption_mode_isSet = true;
}

bool OAIUpdateNetworkSsid_request::is_wpa_encryption_mode_Set() const{
    return m_wpa_encryption_mode_isSet;
}

bool OAIUpdateNetworkSsid_request::is_wpa_encryption_mode_Valid() const{
    return m_wpa_encryption_mode_isValid;
}

bool OAIUpdateNetworkSsid_request::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_ap_tags_and_vlan_ids.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_auth_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_availability_tags.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_available_on_all_aps_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_band_selection_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_concentrator_network_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_default_vlan_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disassociate_clients_on_vpn_failover_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_encryption_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enterprise_admin_access_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ip_assignment_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lan_isolation_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_bitrate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_per_client_bandwidth_limit_down_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_per_client_bandwidth_limit_up_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_psk_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_radius_accounting_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_radius_accounting_servers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_radius_attribute_for_group_policies_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_radius_coa_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_radius_failover_policy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_radius_load_balancing_policy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_radius_override_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_radius_servers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_secondary_concentrator_network_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_splash_page_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_use_vlan_tagging_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_visible_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vlan_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_walled_garden_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_walled_garden_ranges_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_wpa_encryption_mode_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIUpdateNetworkSsid_request::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
