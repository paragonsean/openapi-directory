/**
 * Meraki Dashboard API
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 05 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 
 *
 * The version of the OpenAPI document: 1.32.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner() {
    this->initializeModel();
}

OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::~OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner() {}

void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::initializeModel() {

    m_client_id_isSet = false;
    m_client_id_isValid = false;

    m_device_isSet = false;
    m_device_isValid = false;

    m_ipv4_isSet = false;
    m_ipv4_isValid = false;

    m_is_allowed_isSet = false;
    m_is_allowed_isValid = false;

    m_is_configured_isSet = false;
    m_is_configured_isValid = false;

    m_last_ack_isSet = false;
    m_last_ack_isValid = false;

    m_last_packet_isSet = false;
    m_last_packet_isValid = false;

    m_last_seen_at_isSet = false;
    m_last_seen_at_isValid = false;

    m_mac_isSet = false;
    m_mac_isValid = false;

    m_seen_by_isSet = false;
    m_seen_by_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_vlan_isSet = false;
    m_vlan_isValid = false;
}

void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::fromJsonObject(QJsonObject json) {

    m_client_id_isValid = ::OpenAPI::fromJsonValue(m_client_id, json[QString("clientId")]);
    m_client_id_isSet = !json[QString("clientId")].isNull() && m_client_id_isValid;

    m_device_isValid = ::OpenAPI::fromJsonValue(m_device, json[QString("device")]);
    m_device_isSet = !json[QString("device")].isNull() && m_device_isValid;

    m_ipv4_isValid = ::OpenAPI::fromJsonValue(m_ipv4, json[QString("ipv4")]);
    m_ipv4_isSet = !json[QString("ipv4")].isNull() && m_ipv4_isValid;

    m_is_allowed_isValid = ::OpenAPI::fromJsonValue(m_is_allowed, json[QString("isAllowed")]);
    m_is_allowed_isSet = !json[QString("isAllowed")].isNull() && m_is_allowed_isValid;

    m_is_configured_isValid = ::OpenAPI::fromJsonValue(m_is_configured, json[QString("isConfigured")]);
    m_is_configured_isSet = !json[QString("isConfigured")].isNull() && m_is_configured_isValid;

    m_last_ack_isValid = ::OpenAPI::fromJsonValue(m_last_ack, json[QString("lastAck")]);
    m_last_ack_isSet = !json[QString("lastAck")].isNull() && m_last_ack_isValid;

    m_last_packet_isValid = ::OpenAPI::fromJsonValue(m_last_packet, json[QString("lastPacket")]);
    m_last_packet_isSet = !json[QString("lastPacket")].isNull() && m_last_packet_isValid;

    m_last_seen_at_isValid = ::OpenAPI::fromJsonValue(m_last_seen_at, json[QString("lastSeenAt")]);
    m_last_seen_at_isSet = !json[QString("lastSeenAt")].isNull() && m_last_seen_at_isValid;

    m_mac_isValid = ::OpenAPI::fromJsonValue(m_mac, json[QString("mac")]);
    m_mac_isSet = !json[QString("mac")].isNull() && m_mac_isValid;

    m_seen_by_isValid = ::OpenAPI::fromJsonValue(m_seen_by, json[QString("seenBy")]);
    m_seen_by_isSet = !json[QString("seenBy")].isNull() && m_seen_by_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_vlan_isValid = ::OpenAPI::fromJsonValue(m_vlan, json[QString("vlan")]);
    m_vlan_isSet = !json[QString("vlan")].isNull() && m_vlan_isValid;
}

QString OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::asJsonObject() const {
    QJsonObject obj;
    if (m_client_id_isSet) {
        obj.insert(QString("clientId"), ::OpenAPI::toJsonValue(m_client_id));
    }
    if (m_device.isSet()) {
        obj.insert(QString("device"), ::OpenAPI::toJsonValue(m_device));
    }
    if (m_ipv4.isSet()) {
        obj.insert(QString("ipv4"), ::OpenAPI::toJsonValue(m_ipv4));
    }
    if (m_is_allowed_isSet) {
        obj.insert(QString("isAllowed"), ::OpenAPI::toJsonValue(m_is_allowed));
    }
    if (m_is_configured_isSet) {
        obj.insert(QString("isConfigured"), ::OpenAPI::toJsonValue(m_is_configured));
    }
    if (m_last_ack.isSet()) {
        obj.insert(QString("lastAck"), ::OpenAPI::toJsonValue(m_last_ack));
    }
    if (m_last_packet.isSet()) {
        obj.insert(QString("lastPacket"), ::OpenAPI::toJsonValue(m_last_packet));
    }
    if (m_last_seen_at_isSet) {
        obj.insert(QString("lastSeenAt"), ::OpenAPI::toJsonValue(m_last_seen_at));
    }
    if (m_mac_isSet) {
        obj.insert(QString("mac"), ::OpenAPI::toJsonValue(m_mac));
    }
    if (m_seen_by.size() > 0) {
        obj.insert(QString("seenBy"), ::OpenAPI::toJsonValue(m_seen_by));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_vlan_isSet) {
        obj.insert(QString("vlan"), ::OpenAPI::toJsonValue(m_vlan));
    }
    return obj;
}

QString OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getClientId() const {
    return m_client_id;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setClientId(const QString &client_id) {
    m_client_id = client_id;
    m_client_id_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_client_id_Set() const{
    return m_client_id_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_client_id_Valid() const{
    return m_client_id_isValid;
}

OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_device OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getDevice() const {
    return m_device;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setDevice(const OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_device &device) {
    m_device = device;
    m_device_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_device_Set() const{
    return m_device_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_device_Valid() const{
    return m_device_isValid;
}

OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_ipv4 OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getIpv4() const {
    return m_ipv4;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setIpv4(const OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_ipv4 &ipv4) {
    m_ipv4 = ipv4;
    m_ipv4_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_ipv4_Set() const{
    return m_ipv4_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_ipv4_Valid() const{
    return m_ipv4_isValid;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::isIsAllowed() const {
    return m_is_allowed;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setIsAllowed(const bool &is_allowed) {
    m_is_allowed = is_allowed;
    m_is_allowed_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_is_allowed_Set() const{
    return m_is_allowed_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_is_allowed_Valid() const{
    return m_is_allowed_isValid;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::isIsConfigured() const {
    return m_is_configured;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setIsConfigured(const bool &is_configured) {
    m_is_configured = is_configured;
    m_is_configured_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_is_configured_Set() const{
    return m_is_configured_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_is_configured_Valid() const{
    return m_is_configured_isValid;
}

OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_lastAck OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getLastAck() const {
    return m_last_ack;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setLastAck(const OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_lastAck &last_ack) {
    m_last_ack = last_ack;
    m_last_ack_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_last_ack_Set() const{
    return m_last_ack_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_last_ack_Valid() const{
    return m_last_ack_isValid;
}

OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_lastPacket OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getLastPacket() const {
    return m_last_packet;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setLastPacket(const OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_lastPacket &last_packet) {
    m_last_packet = last_packet;
    m_last_packet_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_last_packet_Set() const{
    return m_last_packet_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_last_packet_Valid() const{
    return m_last_packet_isValid;
}

QDateTime OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getLastSeenAt() const {
    return m_last_seen_at;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setLastSeenAt(const QDateTime &last_seen_at) {
    m_last_seen_at = last_seen_at;
    m_last_seen_at_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_last_seen_at_Set() const{
    return m_last_seen_at_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_last_seen_at_Valid() const{
    return m_last_seen_at_isValid;
}

QString OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getMac() const {
    return m_mac;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setMac(const QString &mac) {
    m_mac = mac;
    m_mac_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_mac_Set() const{
    return m_mac_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_mac_Valid() const{
    return m_mac_isValid;
}

QList<OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_seenBy_inner> OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getSeenBy() const {
    return m_seen_by;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setSeenBy(const QList<OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner_seenBy_inner> &seen_by) {
    m_seen_by = seen_by;
    m_seen_by_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_seen_by_Set() const{
    return m_seen_by_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_seen_by_Valid() const{
    return m_seen_by_isValid;
}

QString OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getType() const {
    return m_type;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_type_Set() const{
    return m_type_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_type_Valid() const{
    return m_type_isValid;
}

qint32 OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::getVlan() const {
    return m_vlan;
}
void OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::setVlan(const qint32 &vlan) {
    m_vlan = vlan;
    m_vlan_isSet = true;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_vlan_Set() const{
    return m_vlan_isSet;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::is_vlan_Valid() const{
    return m_vlan_isValid;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_client_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_device.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ipv4.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_allowed_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_is_configured_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_ack.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_packet.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_seen_at_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_mac_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_seen_by.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vlan_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGetNetworkSwitchDhcpV4ServersSeen_200_response_inner::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
