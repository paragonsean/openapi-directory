/*
 * Meraki Dashboard API
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 05 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 
 *
 * The version of the OpenAPI document: 1.32.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GetOrganizationLicensingCotermLicenses200ResponseInnerCountsInner;
import org.openapitools.client.model.GetOrganizationLicensingCotermLicenses200ResponseInnerEditionsInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * GetOrganizationLicensingCotermLicenses200ResponseInner
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:58:52.491325-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GetOrganizationLicensingCotermLicenses200ResponseInner {
  public static final String SERIALIZED_NAME_CLAIMED_AT = "claimedAt";
  @SerializedName(SERIALIZED_NAME_CLAIMED_AT)
  private OffsetDateTime claimedAt;

  public static final String SERIALIZED_NAME_COUNTS = "counts";
  @SerializedName(SERIALIZED_NAME_COUNTS)
  private List<GetOrganizationLicensingCotermLicenses200ResponseInnerCountsInner> counts = new ArrayList<>();

  public static final String SERIALIZED_NAME_DURATION = "duration";
  @SerializedName(SERIALIZED_NAME_DURATION)
  private Integer duration;

  public static final String SERIALIZED_NAME_EDITIONS = "editions";
  @SerializedName(SERIALIZED_NAME_EDITIONS)
  private List<GetOrganizationLicensingCotermLicenses200ResponseInnerEditionsInner> editions = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXPIRED = "expired";
  @SerializedName(SERIALIZED_NAME_EXPIRED)
  private Boolean expired;

  public static final String SERIALIZED_NAME_INVALIDATED = "invalidated";
  @SerializedName(SERIALIZED_NAME_INVALIDATED)
  private Boolean invalidated;

  public static final String SERIALIZED_NAME_INVALIDATED_AT = "invalidatedAt";
  @SerializedName(SERIALIZED_NAME_INVALIDATED_AT)
  private OffsetDateTime invalidatedAt;

  public static final String SERIALIZED_NAME_KEY = "key";
  @SerializedName(SERIALIZED_NAME_KEY)
  private String key;

  /**
   * The operation mode of the license when it was claimed
   */
  @JsonAdapter(ModeEnum.Adapter.class)
  public enum ModeEnum {
    ADD_DEVICES("addDevices"),
    
    RENEW("renew");

    private String value;

    ModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ModeEnum fromValue(String value) {
      for (ModeEnum b : ModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MODE = "mode";
  @SerializedName(SERIALIZED_NAME_MODE)
  private ModeEnum mode;

  public static final String SERIALIZED_NAME_ORGANIZATION_ID = "organizationId";
  @SerializedName(SERIALIZED_NAME_ORGANIZATION_ID)
  private String organizationId;

  public static final String SERIALIZED_NAME_STARTED_AT = "startedAt";
  @SerializedName(SERIALIZED_NAME_STARTED_AT)
  private OffsetDateTime startedAt;

  public GetOrganizationLicensingCotermLicenses200ResponseInner() {
  }

  public GetOrganizationLicensingCotermLicenses200ResponseInner claimedAt(OffsetDateTime claimedAt) {
    this.claimedAt = claimedAt;
    return this;
  }

  /**
   * When the license was claimed into the organization
   * @return claimedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getClaimedAt() {
    return claimedAt;
  }

  public void setClaimedAt(OffsetDateTime claimedAt) {
    this.claimedAt = claimedAt;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner counts(List<GetOrganizationLicensingCotermLicenses200ResponseInnerCountsInner> counts) {
    this.counts = counts;
    return this;
  }

  public GetOrganizationLicensingCotermLicenses200ResponseInner addCountsItem(GetOrganizationLicensingCotermLicenses200ResponseInnerCountsInner countsItem) {
    if (this.counts == null) {
      this.counts = new ArrayList<>();
    }
    this.counts.add(countsItem);
    return this;
  }

  /**
   * The counts of the license by model type
   * @return counts
   */
  @javax.annotation.Nullable
  public List<GetOrganizationLicensingCotermLicenses200ResponseInnerCountsInner> getCounts() {
    return counts;
  }

  public void setCounts(List<GetOrganizationLicensingCotermLicenses200ResponseInnerCountsInner> counts) {
    this.counts = counts;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner duration(Integer duration) {
    this.duration = duration;
    return this;
  }

  /**
   * The duration (term length) of the license, measured in days
   * @return duration
   */
  @javax.annotation.Nullable
  public Integer getDuration() {
    return duration;
  }

  public void setDuration(Integer duration) {
    this.duration = duration;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner editions(List<GetOrganizationLicensingCotermLicenses200ResponseInnerEditionsInner> editions) {
    this.editions = editions;
    return this;
  }

  public GetOrganizationLicensingCotermLicenses200ResponseInner addEditionsItem(GetOrganizationLicensingCotermLicenses200ResponseInnerEditionsInner editionsItem) {
    if (this.editions == null) {
      this.editions = new ArrayList<>();
    }
    this.editions.add(editionsItem);
    return this;
  }

  /**
   * The editions of the license for each relevant product type
   * @return editions
   */
  @javax.annotation.Nullable
  public List<GetOrganizationLicensingCotermLicenses200ResponseInnerEditionsInner> getEditions() {
    return editions;
  }

  public void setEditions(List<GetOrganizationLicensingCotermLicenses200ResponseInnerEditionsInner> editions) {
    this.editions = editions;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner expired(Boolean expired) {
    this.expired = expired;
    return this;
  }

  /**
   * Flag to indicate if the license is expired
   * @return expired
   */
  @javax.annotation.Nullable
  public Boolean getExpired() {
    return expired;
  }

  public void setExpired(Boolean expired) {
    this.expired = expired;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner invalidated(Boolean invalidated) {
    this.invalidated = invalidated;
    return this;
  }

  /**
   * Flag to indicated that the license is invalidated
   * @return invalidated
   */
  @javax.annotation.Nullable
  public Boolean getInvalidated() {
    return invalidated;
  }

  public void setInvalidated(Boolean invalidated) {
    this.invalidated = invalidated;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner invalidatedAt(OffsetDateTime invalidatedAt) {
    this.invalidatedAt = invalidatedAt;
    return this;
  }

  /**
   * When the license was invalidated. Will be null for active licenses
   * @return invalidatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getInvalidatedAt() {
    return invalidatedAt;
  }

  public void setInvalidatedAt(OffsetDateTime invalidatedAt) {
    this.invalidatedAt = invalidatedAt;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner key(String key) {
    this.key = key;
    return this;
  }

  /**
   * The key of the license
   * @return key
   */
  @javax.annotation.Nullable
  public String getKey() {
    return key;
  }

  public void setKey(String key) {
    this.key = key;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner mode(ModeEnum mode) {
    this.mode = mode;
    return this;
  }

  /**
   * The operation mode of the license when it was claimed
   * @return mode
   */
  @javax.annotation.Nullable
  public ModeEnum getMode() {
    return mode;
  }

  public void setMode(ModeEnum mode) {
    this.mode = mode;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner organizationId(String organizationId) {
    this.organizationId = organizationId;
    return this;
  }

  /**
   * The ID of the organization that the license is claimed in
   * @return organizationId
   */
  @javax.annotation.Nullable
  public String getOrganizationId() {
    return organizationId;
  }

  public void setOrganizationId(String organizationId) {
    this.organizationId = organizationId;
  }


  public GetOrganizationLicensingCotermLicenses200ResponseInner startedAt(OffsetDateTime startedAt) {
    this.startedAt = startedAt;
    return this;
  }

  /**
   * When the license&#39;s term began (approximately the date when the license was created)
   * @return startedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartedAt() {
    return startedAt;
  }

  public void setStartedAt(OffsetDateTime startedAt) {
    this.startedAt = startedAt;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GetOrganizationLicensingCotermLicenses200ResponseInner getOrganizationLicensingCotermLicenses200ResponseInner = (GetOrganizationLicensingCotermLicenses200ResponseInner) o;
    return Objects.equals(this.claimedAt, getOrganizationLicensingCotermLicenses200ResponseInner.claimedAt) &&
        Objects.equals(this.counts, getOrganizationLicensingCotermLicenses200ResponseInner.counts) &&
        Objects.equals(this.duration, getOrganizationLicensingCotermLicenses200ResponseInner.duration) &&
        Objects.equals(this.editions, getOrganizationLicensingCotermLicenses200ResponseInner.editions) &&
        Objects.equals(this.expired, getOrganizationLicensingCotermLicenses200ResponseInner.expired) &&
        Objects.equals(this.invalidated, getOrganizationLicensingCotermLicenses200ResponseInner.invalidated) &&
        Objects.equals(this.invalidatedAt, getOrganizationLicensingCotermLicenses200ResponseInner.invalidatedAt) &&
        Objects.equals(this.key, getOrganizationLicensingCotermLicenses200ResponseInner.key) &&
        Objects.equals(this.mode, getOrganizationLicensingCotermLicenses200ResponseInner.mode) &&
        Objects.equals(this.organizationId, getOrganizationLicensingCotermLicenses200ResponseInner.organizationId) &&
        Objects.equals(this.startedAt, getOrganizationLicensingCotermLicenses200ResponseInner.startedAt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(claimedAt, counts, duration, editions, expired, invalidated, invalidatedAt, key, mode, organizationId, startedAt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GetOrganizationLicensingCotermLicenses200ResponseInner {\n");
    sb.append("    claimedAt: ").append(toIndentedString(claimedAt)).append("\n");
    sb.append("    counts: ").append(toIndentedString(counts)).append("\n");
    sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
    sb.append("    editions: ").append(toIndentedString(editions)).append("\n");
    sb.append("    expired: ").append(toIndentedString(expired)).append("\n");
    sb.append("    invalidated: ").append(toIndentedString(invalidated)).append("\n");
    sb.append("    invalidatedAt: ").append(toIndentedString(invalidatedAt)).append("\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    organizationId: ").append(toIndentedString(organizationId)).append("\n");
    sb.append("    startedAt: ").append(toIndentedString(startedAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("claimedAt");
    openapiFields.add("counts");
    openapiFields.add("duration");
    openapiFields.add("editions");
    openapiFields.add("expired");
    openapiFields.add("invalidated");
    openapiFields.add("invalidatedAt");
    openapiFields.add("key");
    openapiFields.add("mode");
    openapiFields.add("organizationId");
    openapiFields.add("startedAt");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GetOrganizationLicensingCotermLicenses200ResponseInner
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GetOrganizationLicensingCotermLicenses200ResponseInner.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GetOrganizationLicensingCotermLicenses200ResponseInner is not found in the empty JSON string", GetOrganizationLicensingCotermLicenses200ResponseInner.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GetOrganizationLicensingCotermLicenses200ResponseInner.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GetOrganizationLicensingCotermLicenses200ResponseInner` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("counts") != null && !jsonObj.get("counts").isJsonNull()) {
        JsonArray jsonArraycounts = jsonObj.getAsJsonArray("counts");
        if (jsonArraycounts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("counts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `counts` to be an array in the JSON string but got `%s`", jsonObj.get("counts").toString()));
          }

          // validate the optional field `counts` (array)
          for (int i = 0; i < jsonArraycounts.size(); i++) {
            GetOrganizationLicensingCotermLicenses200ResponseInnerCountsInner.validateJsonElement(jsonArraycounts.get(i));
          };
        }
      }
      if (jsonObj.get("editions") != null && !jsonObj.get("editions").isJsonNull()) {
        JsonArray jsonArrayeditions = jsonObj.getAsJsonArray("editions");
        if (jsonArrayeditions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("editions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `editions` to be an array in the JSON string but got `%s`", jsonObj.get("editions").toString()));
          }

          // validate the optional field `editions` (array)
          for (int i = 0; i < jsonArrayeditions.size(); i++) {
            GetOrganizationLicensingCotermLicenses200ResponseInnerEditionsInner.validateJsonElement(jsonArrayeditions.get(i));
          };
        }
      }
      if ((jsonObj.get("key") != null && !jsonObj.get("key").isJsonNull()) && !jsonObj.get("key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key").toString()));
      }
      if ((jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) && !jsonObj.get("mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mode").toString()));
      }
      // validate the optional field `mode`
      if (jsonObj.get("mode") != null && !jsonObj.get("mode").isJsonNull()) {
        ModeEnum.validateJsonElement(jsonObj.get("mode"));
      }
      if ((jsonObj.get("organizationId") != null && !jsonObj.get("organizationId").isJsonNull()) && !jsonObj.get("organizationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `organizationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("organizationId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GetOrganizationLicensingCotermLicenses200ResponseInner.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GetOrganizationLicensingCotermLicenses200ResponseInner' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GetOrganizationLicensingCotermLicenses200ResponseInner> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GetOrganizationLicensingCotermLicenses200ResponseInner.class));

       return (TypeAdapter<T>) new TypeAdapter<GetOrganizationLicensingCotermLicenses200ResponseInner>() {
           @Override
           public void write(JsonWriter out, GetOrganizationLicensingCotermLicenses200ResponseInner value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GetOrganizationLicensingCotermLicenses200ResponseInner read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GetOrganizationLicensingCotermLicenses200ResponseInner given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GetOrganizationLicensingCotermLicenses200ResponseInner
   * @throws IOException if the JSON string is invalid with respect to GetOrganizationLicensingCotermLicenses200ResponseInner
   */
  public static GetOrganizationLicensingCotermLicenses200ResponseInner fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GetOrganizationLicensingCotermLicenses200ResponseInner.class);
  }

  /**
   * Convert an instance of GetOrganizationLicensingCotermLicenses200ResponseInner to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

