/*
 * Meraki Dashboard API
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 05 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 
 *
 * The version of the OpenAPI document: 1.32.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GetOrganizationLoginSecurity200ResponseApiAuthentication;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateOrganizationLoginSecurityRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:58:52.491325-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateOrganizationLoginSecurityRequest {
  public static final String SERIALIZED_NAME_ACCOUNT_LOCKOUT_ATTEMPTS = "accountLockoutAttempts";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_LOCKOUT_ATTEMPTS)
  private Integer accountLockoutAttempts;

  public static final String SERIALIZED_NAME_API_AUTHENTICATION = "apiAuthentication";
  @SerializedName(SERIALIZED_NAME_API_AUTHENTICATION)
  private GetOrganizationLoginSecurity200ResponseApiAuthentication apiAuthentication;

  public static final String SERIALIZED_NAME_ENFORCE_ACCOUNT_LOCKOUT = "enforceAccountLockout";
  @SerializedName(SERIALIZED_NAME_ENFORCE_ACCOUNT_LOCKOUT)
  private Boolean enforceAccountLockout;

  public static final String SERIALIZED_NAME_ENFORCE_DIFFERENT_PASSWORDS = "enforceDifferentPasswords";
  @SerializedName(SERIALIZED_NAME_ENFORCE_DIFFERENT_PASSWORDS)
  private Boolean enforceDifferentPasswords;

  public static final String SERIALIZED_NAME_ENFORCE_IDLE_TIMEOUT = "enforceIdleTimeout";
  @SerializedName(SERIALIZED_NAME_ENFORCE_IDLE_TIMEOUT)
  private Boolean enforceIdleTimeout;

  public static final String SERIALIZED_NAME_ENFORCE_LOGIN_IP_RANGES = "enforceLoginIpRanges";
  @SerializedName(SERIALIZED_NAME_ENFORCE_LOGIN_IP_RANGES)
  private Boolean enforceLoginIpRanges;

  public static final String SERIALIZED_NAME_ENFORCE_PASSWORD_EXPIRATION = "enforcePasswordExpiration";
  @SerializedName(SERIALIZED_NAME_ENFORCE_PASSWORD_EXPIRATION)
  private Boolean enforcePasswordExpiration;

  public static final String SERIALIZED_NAME_ENFORCE_STRONG_PASSWORDS = "enforceStrongPasswords";
  @SerializedName(SERIALIZED_NAME_ENFORCE_STRONG_PASSWORDS)
  private Boolean enforceStrongPasswords;

  public static final String SERIALIZED_NAME_ENFORCE_TWO_FACTOR_AUTH = "enforceTwoFactorAuth";
  @SerializedName(SERIALIZED_NAME_ENFORCE_TWO_FACTOR_AUTH)
  private Boolean enforceTwoFactorAuth;

  public static final String SERIALIZED_NAME_IDLE_TIMEOUT_MINUTES = "idleTimeoutMinutes";
  @SerializedName(SERIALIZED_NAME_IDLE_TIMEOUT_MINUTES)
  private Integer idleTimeoutMinutes;

  public static final String SERIALIZED_NAME_LOGIN_IP_RANGES = "loginIpRanges";
  @SerializedName(SERIALIZED_NAME_LOGIN_IP_RANGES)
  private List<String> loginIpRanges = new ArrayList<>();

  public static final String SERIALIZED_NAME_NUM_DIFFERENT_PASSWORDS = "numDifferentPasswords";
  @SerializedName(SERIALIZED_NAME_NUM_DIFFERENT_PASSWORDS)
  private Integer numDifferentPasswords;

  public static final String SERIALIZED_NAME_PASSWORD_EXPIRATION_DAYS = "passwordExpirationDays";
  @SerializedName(SERIALIZED_NAME_PASSWORD_EXPIRATION_DAYS)
  private Integer passwordExpirationDays;

  public UpdateOrganizationLoginSecurityRequest() {
  }

  public UpdateOrganizationLoginSecurityRequest accountLockoutAttempts(Integer accountLockoutAttempts) {
    this.accountLockoutAttempts = accountLockoutAttempts;
    return this;
  }

  /**
   * Number of consecutive failed login attempts after which users&#39; accounts will be locked.
   * @return accountLockoutAttempts
   */
  @javax.annotation.Nullable
  public Integer getAccountLockoutAttempts() {
    return accountLockoutAttempts;
  }

  public void setAccountLockoutAttempts(Integer accountLockoutAttempts) {
    this.accountLockoutAttempts = accountLockoutAttempts;
  }


  public UpdateOrganizationLoginSecurityRequest apiAuthentication(GetOrganizationLoginSecurity200ResponseApiAuthentication apiAuthentication) {
    this.apiAuthentication = apiAuthentication;
    return this;
  }

  /**
   * Get apiAuthentication
   * @return apiAuthentication
   */
  @javax.annotation.Nullable
  public GetOrganizationLoginSecurity200ResponseApiAuthentication getApiAuthentication() {
    return apiAuthentication;
  }

  public void setApiAuthentication(GetOrganizationLoginSecurity200ResponseApiAuthentication apiAuthentication) {
    this.apiAuthentication = apiAuthentication;
  }


  public UpdateOrganizationLoginSecurityRequest enforceAccountLockout(Boolean enforceAccountLockout) {
    this.enforceAccountLockout = enforceAccountLockout;
    return this;
  }

  /**
   * Boolean indicating whether users&#39; Dashboard accounts will be locked out after a specified number of consecutive failed login attempts.
   * @return enforceAccountLockout
   */
  @javax.annotation.Nullable
  public Boolean getEnforceAccountLockout() {
    return enforceAccountLockout;
  }

  public void setEnforceAccountLockout(Boolean enforceAccountLockout) {
    this.enforceAccountLockout = enforceAccountLockout;
  }


  public UpdateOrganizationLoginSecurityRequest enforceDifferentPasswords(Boolean enforceDifferentPasswords) {
    this.enforceDifferentPasswords = enforceDifferentPasswords;
    return this;
  }

  /**
   * Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords.
   * @return enforceDifferentPasswords
   */
  @javax.annotation.Nullable
  public Boolean getEnforceDifferentPasswords() {
    return enforceDifferentPasswords;
  }

  public void setEnforceDifferentPasswords(Boolean enforceDifferentPasswords) {
    this.enforceDifferentPasswords = enforceDifferentPasswords;
  }


  public UpdateOrganizationLoginSecurityRequest enforceIdleTimeout(Boolean enforceIdleTimeout) {
    this.enforceIdleTimeout = enforceIdleTimeout;
    return this;
  }

  /**
   * Boolean indicating whether users will be logged out after being idle for the specified number of minutes.
   * @return enforceIdleTimeout
   */
  @javax.annotation.Nullable
  public Boolean getEnforceIdleTimeout() {
    return enforceIdleTimeout;
  }

  public void setEnforceIdleTimeout(Boolean enforceIdleTimeout) {
    this.enforceIdleTimeout = enforceIdleTimeout;
  }


  public UpdateOrganizationLoginSecurityRequest enforceLoginIpRanges(Boolean enforceLoginIpRanges) {
    this.enforceLoginIpRanges = enforceLoginIpRanges;
    return this;
  }

  /**
   * Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses.
   * @return enforceLoginIpRanges
   */
  @javax.annotation.Nullable
  public Boolean getEnforceLoginIpRanges() {
    return enforceLoginIpRanges;
  }

  public void setEnforceLoginIpRanges(Boolean enforceLoginIpRanges) {
    this.enforceLoginIpRanges = enforceLoginIpRanges;
  }


  public UpdateOrganizationLoginSecurityRequest enforcePasswordExpiration(Boolean enforcePasswordExpiration) {
    this.enforcePasswordExpiration = enforcePasswordExpiration;
    return this;
  }

  /**
   * Boolean indicating whether users are forced to change their password every X number of days.
   * @return enforcePasswordExpiration
   */
  @javax.annotation.Nullable
  public Boolean getEnforcePasswordExpiration() {
    return enforcePasswordExpiration;
  }

  public void setEnforcePasswordExpiration(Boolean enforcePasswordExpiration) {
    this.enforcePasswordExpiration = enforcePasswordExpiration;
  }


  public UpdateOrganizationLoginSecurityRequest enforceStrongPasswords(Boolean enforceStrongPasswords) {
    this.enforceStrongPasswords = enforceStrongPasswords;
    return this;
  }

  /**
   * Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol
   * @return enforceStrongPasswords
   */
  @javax.annotation.Nullable
  public Boolean getEnforceStrongPasswords() {
    return enforceStrongPasswords;
  }

  public void setEnforceStrongPasswords(Boolean enforceStrongPasswords) {
    this.enforceStrongPasswords = enforceStrongPasswords;
  }


  public UpdateOrganizationLoginSecurityRequest enforceTwoFactorAuth(Boolean enforceTwoFactorAuth) {
    this.enforceTwoFactorAuth = enforceTwoFactorAuth;
    return this;
  }

  /**
   * Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application.
   * @return enforceTwoFactorAuth
   */
  @javax.annotation.Nullable
  public Boolean getEnforceTwoFactorAuth() {
    return enforceTwoFactorAuth;
  }

  public void setEnforceTwoFactorAuth(Boolean enforceTwoFactorAuth) {
    this.enforceTwoFactorAuth = enforceTwoFactorAuth;
  }


  public UpdateOrganizationLoginSecurityRequest idleTimeoutMinutes(Integer idleTimeoutMinutes) {
    this.idleTimeoutMinutes = idleTimeoutMinutes;
    return this;
  }

  /**
   * Number of minutes users can remain idle before being logged out of their accounts.
   * @return idleTimeoutMinutes
   */
  @javax.annotation.Nullable
  public Integer getIdleTimeoutMinutes() {
    return idleTimeoutMinutes;
  }

  public void setIdleTimeoutMinutes(Integer idleTimeoutMinutes) {
    this.idleTimeoutMinutes = idleTimeoutMinutes;
  }


  public UpdateOrganizationLoginSecurityRequest loginIpRanges(List<String> loginIpRanges) {
    this.loginIpRanges = loginIpRanges;
    return this;
  }

  public UpdateOrganizationLoginSecurityRequest addLoginIpRangesItem(String loginIpRangesItem) {
    if (this.loginIpRanges == null) {
      this.loginIpRanges = new ArrayList<>();
    }
    this.loginIpRanges.add(loginIpRangesItem);
    return this;
  }

  /**
   * List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
   * @return loginIpRanges
   */
  @javax.annotation.Nullable
  public List<String> getLoginIpRanges() {
    return loginIpRanges;
  }

  public void setLoginIpRanges(List<String> loginIpRanges) {
    this.loginIpRanges = loginIpRanges;
  }


  public UpdateOrganizationLoginSecurityRequest numDifferentPasswords(Integer numDifferentPasswords) {
    this.numDifferentPasswords = numDifferentPasswords;
    return this;
  }

  /**
   * Number of recent passwords that new password must be distinct from.
   * @return numDifferentPasswords
   */
  @javax.annotation.Nullable
  public Integer getNumDifferentPasswords() {
    return numDifferentPasswords;
  }

  public void setNumDifferentPasswords(Integer numDifferentPasswords) {
    this.numDifferentPasswords = numDifferentPasswords;
  }


  public UpdateOrganizationLoginSecurityRequest passwordExpirationDays(Integer passwordExpirationDays) {
    this.passwordExpirationDays = passwordExpirationDays;
    return this;
  }

  /**
   * Number of days after which users will be forced to change their password.
   * @return passwordExpirationDays
   */
  @javax.annotation.Nullable
  public Integer getPasswordExpirationDays() {
    return passwordExpirationDays;
  }

  public void setPasswordExpirationDays(Integer passwordExpirationDays) {
    this.passwordExpirationDays = passwordExpirationDays;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateOrganizationLoginSecurityRequest updateOrganizationLoginSecurityRequest = (UpdateOrganizationLoginSecurityRequest) o;
    return Objects.equals(this.accountLockoutAttempts, updateOrganizationLoginSecurityRequest.accountLockoutAttempts) &&
        Objects.equals(this.apiAuthentication, updateOrganizationLoginSecurityRequest.apiAuthentication) &&
        Objects.equals(this.enforceAccountLockout, updateOrganizationLoginSecurityRequest.enforceAccountLockout) &&
        Objects.equals(this.enforceDifferentPasswords, updateOrganizationLoginSecurityRequest.enforceDifferentPasswords) &&
        Objects.equals(this.enforceIdleTimeout, updateOrganizationLoginSecurityRequest.enforceIdleTimeout) &&
        Objects.equals(this.enforceLoginIpRanges, updateOrganizationLoginSecurityRequest.enforceLoginIpRanges) &&
        Objects.equals(this.enforcePasswordExpiration, updateOrganizationLoginSecurityRequest.enforcePasswordExpiration) &&
        Objects.equals(this.enforceStrongPasswords, updateOrganizationLoginSecurityRequest.enforceStrongPasswords) &&
        Objects.equals(this.enforceTwoFactorAuth, updateOrganizationLoginSecurityRequest.enforceTwoFactorAuth) &&
        Objects.equals(this.idleTimeoutMinutes, updateOrganizationLoginSecurityRequest.idleTimeoutMinutes) &&
        Objects.equals(this.loginIpRanges, updateOrganizationLoginSecurityRequest.loginIpRanges) &&
        Objects.equals(this.numDifferentPasswords, updateOrganizationLoginSecurityRequest.numDifferentPasswords) &&
        Objects.equals(this.passwordExpirationDays, updateOrganizationLoginSecurityRequest.passwordExpirationDays);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountLockoutAttempts, apiAuthentication, enforceAccountLockout, enforceDifferentPasswords, enforceIdleTimeout, enforceLoginIpRanges, enforcePasswordExpiration, enforceStrongPasswords, enforceTwoFactorAuth, idleTimeoutMinutes, loginIpRanges, numDifferentPasswords, passwordExpirationDays);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateOrganizationLoginSecurityRequest {\n");
    sb.append("    accountLockoutAttempts: ").append(toIndentedString(accountLockoutAttempts)).append("\n");
    sb.append("    apiAuthentication: ").append(toIndentedString(apiAuthentication)).append("\n");
    sb.append("    enforceAccountLockout: ").append(toIndentedString(enforceAccountLockout)).append("\n");
    sb.append("    enforceDifferentPasswords: ").append(toIndentedString(enforceDifferentPasswords)).append("\n");
    sb.append("    enforceIdleTimeout: ").append(toIndentedString(enforceIdleTimeout)).append("\n");
    sb.append("    enforceLoginIpRanges: ").append(toIndentedString(enforceLoginIpRanges)).append("\n");
    sb.append("    enforcePasswordExpiration: ").append(toIndentedString(enforcePasswordExpiration)).append("\n");
    sb.append("    enforceStrongPasswords: ").append(toIndentedString(enforceStrongPasswords)).append("\n");
    sb.append("    enforceTwoFactorAuth: ").append(toIndentedString(enforceTwoFactorAuth)).append("\n");
    sb.append("    idleTimeoutMinutes: ").append(toIndentedString(idleTimeoutMinutes)).append("\n");
    sb.append("    loginIpRanges: ").append(toIndentedString(loginIpRanges)).append("\n");
    sb.append("    numDifferentPasswords: ").append(toIndentedString(numDifferentPasswords)).append("\n");
    sb.append("    passwordExpirationDays: ").append(toIndentedString(passwordExpirationDays)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountLockoutAttempts");
    openapiFields.add("apiAuthentication");
    openapiFields.add("enforceAccountLockout");
    openapiFields.add("enforceDifferentPasswords");
    openapiFields.add("enforceIdleTimeout");
    openapiFields.add("enforceLoginIpRanges");
    openapiFields.add("enforcePasswordExpiration");
    openapiFields.add("enforceStrongPasswords");
    openapiFields.add("enforceTwoFactorAuth");
    openapiFields.add("idleTimeoutMinutes");
    openapiFields.add("loginIpRanges");
    openapiFields.add("numDifferentPasswords");
    openapiFields.add("passwordExpirationDays");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateOrganizationLoginSecurityRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateOrganizationLoginSecurityRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateOrganizationLoginSecurityRequest is not found in the empty JSON string", UpdateOrganizationLoginSecurityRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateOrganizationLoginSecurityRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateOrganizationLoginSecurityRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `apiAuthentication`
      if (jsonObj.get("apiAuthentication") != null && !jsonObj.get("apiAuthentication").isJsonNull()) {
        GetOrganizationLoginSecurity200ResponseApiAuthentication.validateJsonElement(jsonObj.get("apiAuthentication"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("loginIpRanges") != null && !jsonObj.get("loginIpRanges").isJsonNull() && !jsonObj.get("loginIpRanges").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `loginIpRanges` to be an array in the JSON string but got `%s`", jsonObj.get("loginIpRanges").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateOrganizationLoginSecurityRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateOrganizationLoginSecurityRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateOrganizationLoginSecurityRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateOrganizationLoginSecurityRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateOrganizationLoginSecurityRequest>() {
           @Override
           public void write(JsonWriter out, UpdateOrganizationLoginSecurityRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateOrganizationLoginSecurityRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateOrganizationLoginSecurityRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateOrganizationLoginSecurityRequest
   * @throws IOException if the JSON string is invalid with respect to UpdateOrganizationLoginSecurityRequest
   */
  public static UpdateOrganizationLoginSecurityRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateOrganizationLoginSecurityRequest.class);
  }

  /**
   * Convert an instance of UpdateOrganizationLoginSecurityRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

