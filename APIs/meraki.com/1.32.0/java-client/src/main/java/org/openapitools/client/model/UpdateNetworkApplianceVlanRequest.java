/*
 * Meraki Dashboard API
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 05 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 
 *
 * The version of the OpenAPI document: 1.32.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.GetNetworkApplianceVlans200ResponseInnerDhcpOptionsInner;
import org.openapitools.client.model.GetNetworkApplianceVlans200ResponseInnerMandatoryDhcp;
import org.openapitools.client.model.UpdateNetworkApplianceSingleLanRequestIpv6;
import org.openapitools.client.model.UpdateNetworkApplianceStaticRouteRequestReservedIpRangesInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * UpdateNetworkApplianceVlanRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:58:52.491325-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class UpdateNetworkApplianceVlanRequest {
  public static final String SERIALIZED_NAME_APPLIANCE_IP = "applianceIp";
  @SerializedName(SERIALIZED_NAME_APPLIANCE_IP)
  private String applianceIp;

  public static final String SERIALIZED_NAME_CIDR = "cidr";
  @SerializedName(SERIALIZED_NAME_CIDR)
  private String cidr;

  public static final String SERIALIZED_NAME_DHCP_BOOT_FILENAME = "dhcpBootFilename";
  @SerializedName(SERIALIZED_NAME_DHCP_BOOT_FILENAME)
  private String dhcpBootFilename;

  public static final String SERIALIZED_NAME_DHCP_BOOT_NEXT_SERVER = "dhcpBootNextServer";
  @SerializedName(SERIALIZED_NAME_DHCP_BOOT_NEXT_SERVER)
  private String dhcpBootNextServer;

  public static final String SERIALIZED_NAME_DHCP_BOOT_OPTIONS_ENABLED = "dhcpBootOptionsEnabled";
  @SerializedName(SERIALIZED_NAME_DHCP_BOOT_OPTIONS_ENABLED)
  private Boolean dhcpBootOptionsEnabled;

  /**
   * The appliance&#39;s handling of DHCP requests on this VLAN. One of: &#39;Run a DHCP server&#39;, &#39;Relay DHCP to another server&#39; or &#39;Do not respond to DHCP requests&#39;
   */
  @JsonAdapter(DhcpHandlingEnum.Adapter.class)
  public enum DhcpHandlingEnum {
    DO_NOT_RESPOND_TO_DHCP_REQUESTS("Do not respond to DHCP requests"),
    
    RELAY_DHCP_TO_ANOTHER_SERVER("Relay DHCP to another server"),
    
    RUN_A_DHCP_SERVER("Run a DHCP server");

    private String value;

    DhcpHandlingEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DhcpHandlingEnum fromValue(String value) {
      for (DhcpHandlingEnum b : DhcpHandlingEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DhcpHandlingEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DhcpHandlingEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DhcpHandlingEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DhcpHandlingEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DhcpHandlingEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DHCP_HANDLING = "dhcpHandling";
  @SerializedName(SERIALIZED_NAME_DHCP_HANDLING)
  private DhcpHandlingEnum dhcpHandling;

  /**
   * The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: &#39;30 minutes&#39;, &#39;1 hour&#39;, &#39;4 hours&#39;, &#39;12 hours&#39;, &#39;1 day&#39; or &#39;1 week&#39;
   */
  @JsonAdapter(DhcpLeaseTimeEnum.Adapter.class)
  public enum DhcpLeaseTimeEnum {
    _1_DAY("1 day"),
    
    _1_HOUR("1 hour"),
    
    _1_WEEK("1 week"),
    
    _12_HOURS("12 hours"),
    
    _30_MINUTES("30 minutes"),
    
    _4_HOURS("4 hours");

    private String value;

    DhcpLeaseTimeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DhcpLeaseTimeEnum fromValue(String value) {
      for (DhcpLeaseTimeEnum b : DhcpLeaseTimeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DhcpLeaseTimeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DhcpLeaseTimeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DhcpLeaseTimeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DhcpLeaseTimeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DhcpLeaseTimeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DHCP_LEASE_TIME = "dhcpLeaseTime";
  @SerializedName(SERIALIZED_NAME_DHCP_LEASE_TIME)
  private DhcpLeaseTimeEnum dhcpLeaseTime;

  public static final String SERIALIZED_NAME_DHCP_OPTIONS = "dhcpOptions";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS)
  private List<GetNetworkApplianceVlans200ResponseInnerDhcpOptionsInner> dhcpOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_RELAY_SERVER_IPS = "dhcpRelayServerIps";
  @SerializedName(SERIALIZED_NAME_DHCP_RELAY_SERVER_IPS)
  private List<String> dhcpRelayServerIps = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNS_NAMESERVERS = "dnsNameservers";
  @SerializedName(SERIALIZED_NAME_DNS_NAMESERVERS)
  private String dnsNameservers;

  public static final String SERIALIZED_NAME_FIXED_IP_ASSIGNMENTS = "fixedIpAssignments";
  @SerializedName(SERIALIZED_NAME_FIXED_IP_ASSIGNMENTS)
  private Object fixedIpAssignments;

  public static final String SERIALIZED_NAME_GROUP_POLICY_ID = "groupPolicyId";
  @SerializedName(SERIALIZED_NAME_GROUP_POLICY_ID)
  private String groupPolicyId;

  public static final String SERIALIZED_NAME_IPV6 = "ipv6";
  @SerializedName(SERIALIZED_NAME_IPV6)
  private UpdateNetworkApplianceSingleLanRequestIpv6 ipv6;

  public static final String SERIALIZED_NAME_MANDATORY_DHCP = "mandatoryDhcp";
  @SerializedName(SERIALIZED_NAME_MANDATORY_DHCP)
  private GetNetworkApplianceVlans200ResponseInnerMandatoryDhcp mandatoryDhcp;

  public static final String SERIALIZED_NAME_MASK = "mask";
  @SerializedName(SERIALIZED_NAME_MASK)
  private Integer mask;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_RESERVED_IP_RANGES = "reservedIpRanges";
  @SerializedName(SERIALIZED_NAME_RESERVED_IP_RANGES)
  private List<UpdateNetworkApplianceStaticRouteRequestReservedIpRangesInner> reservedIpRanges = new ArrayList<>();

  public static final String SERIALIZED_NAME_SUBNET = "subnet";
  @SerializedName(SERIALIZED_NAME_SUBNET)
  private String subnet;

  /**
   * Type of subnetting of the VLAN. Applicable only for template network.
   */
  @JsonAdapter(TemplateVlanTypeEnum.Adapter.class)
  public enum TemplateVlanTypeEnum {
    SAME("same"),
    
    UNIQUE("unique");

    private String value;

    TemplateVlanTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TemplateVlanTypeEnum fromValue(String value) {
      for (TemplateVlanTypeEnum b : TemplateVlanTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TemplateVlanTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TemplateVlanTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TemplateVlanTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TemplateVlanTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TemplateVlanTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TEMPLATE_VLAN_TYPE = "templateVlanType";
  @SerializedName(SERIALIZED_NAME_TEMPLATE_VLAN_TYPE)
  private TemplateVlanTypeEnum templateVlanType;

  public static final String SERIALIZED_NAME_VPN_NAT_SUBNET = "vpnNatSubnet";
  @SerializedName(SERIALIZED_NAME_VPN_NAT_SUBNET)
  private String vpnNatSubnet;

  public UpdateNetworkApplianceVlanRequest() {
  }

  public UpdateNetworkApplianceVlanRequest applianceIp(String applianceIp) {
    this.applianceIp = applianceIp;
    return this;
  }

  /**
   * The local IP of the appliance on the VLAN
   * @return applianceIp
   */
  @javax.annotation.Nullable
  public String getApplianceIp() {
    return applianceIp;
  }

  public void setApplianceIp(String applianceIp) {
    this.applianceIp = applianceIp;
  }


  public UpdateNetworkApplianceVlanRequest cidr(String cidr) {
    this.cidr = cidr;
    return this;
  }

  /**
   * CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
   * @return cidr
   */
  @javax.annotation.Nullable
  public String getCidr() {
    return cidr;
  }

  public void setCidr(String cidr) {
    this.cidr = cidr;
  }


  public UpdateNetworkApplianceVlanRequest dhcpBootFilename(String dhcpBootFilename) {
    this.dhcpBootFilename = dhcpBootFilename;
    return this;
  }

  /**
   * DHCP boot option for boot filename
   * @return dhcpBootFilename
   */
  @javax.annotation.Nullable
  public String getDhcpBootFilename() {
    return dhcpBootFilename;
  }

  public void setDhcpBootFilename(String dhcpBootFilename) {
    this.dhcpBootFilename = dhcpBootFilename;
  }


  public UpdateNetworkApplianceVlanRequest dhcpBootNextServer(String dhcpBootNextServer) {
    this.dhcpBootNextServer = dhcpBootNextServer;
    return this;
  }

  /**
   * DHCP boot option to direct boot clients to the server to load the boot file from
   * @return dhcpBootNextServer
   */
  @javax.annotation.Nullable
  public String getDhcpBootNextServer() {
    return dhcpBootNextServer;
  }

  public void setDhcpBootNextServer(String dhcpBootNextServer) {
    this.dhcpBootNextServer = dhcpBootNextServer;
  }


  public UpdateNetworkApplianceVlanRequest dhcpBootOptionsEnabled(Boolean dhcpBootOptionsEnabled) {
    this.dhcpBootOptionsEnabled = dhcpBootOptionsEnabled;
    return this;
  }

  /**
   * Use DHCP boot options specified in other properties
   * @return dhcpBootOptionsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDhcpBootOptionsEnabled() {
    return dhcpBootOptionsEnabled;
  }

  public void setDhcpBootOptionsEnabled(Boolean dhcpBootOptionsEnabled) {
    this.dhcpBootOptionsEnabled = dhcpBootOptionsEnabled;
  }


  public UpdateNetworkApplianceVlanRequest dhcpHandling(DhcpHandlingEnum dhcpHandling) {
    this.dhcpHandling = dhcpHandling;
    return this;
  }

  /**
   * The appliance&#39;s handling of DHCP requests on this VLAN. One of: &#39;Run a DHCP server&#39;, &#39;Relay DHCP to another server&#39; or &#39;Do not respond to DHCP requests&#39;
   * @return dhcpHandling
   */
  @javax.annotation.Nullable
  public DhcpHandlingEnum getDhcpHandling() {
    return dhcpHandling;
  }

  public void setDhcpHandling(DhcpHandlingEnum dhcpHandling) {
    this.dhcpHandling = dhcpHandling;
  }


  public UpdateNetworkApplianceVlanRequest dhcpLeaseTime(DhcpLeaseTimeEnum dhcpLeaseTime) {
    this.dhcpLeaseTime = dhcpLeaseTime;
    return this;
  }

  /**
   * The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: &#39;30 minutes&#39;, &#39;1 hour&#39;, &#39;4 hours&#39;, &#39;12 hours&#39;, &#39;1 day&#39; or &#39;1 week&#39;
   * @return dhcpLeaseTime
   */
  @javax.annotation.Nullable
  public DhcpLeaseTimeEnum getDhcpLeaseTime() {
    return dhcpLeaseTime;
  }

  public void setDhcpLeaseTime(DhcpLeaseTimeEnum dhcpLeaseTime) {
    this.dhcpLeaseTime = dhcpLeaseTime;
  }


  public UpdateNetworkApplianceVlanRequest dhcpOptions(List<GetNetworkApplianceVlans200ResponseInnerDhcpOptionsInner> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
    return this;
  }

  public UpdateNetworkApplianceVlanRequest addDhcpOptionsItem(GetNetworkApplianceVlans200ResponseInnerDhcpOptionsInner dhcpOptionsItem) {
    if (this.dhcpOptions == null) {
      this.dhcpOptions = new ArrayList<>();
    }
    this.dhcpOptions.add(dhcpOptionsItem);
    return this;
  }

  /**
   * The list of DHCP options that will be included in DHCP responses. Each object in the list should have \&quot;code\&quot;, \&quot;type\&quot;, and \&quot;value\&quot; properties.
   * @return dhcpOptions
   */
  @javax.annotation.Nullable
  public List<GetNetworkApplianceVlans200ResponseInnerDhcpOptionsInner> getDhcpOptions() {
    return dhcpOptions;
  }

  public void setDhcpOptions(List<GetNetworkApplianceVlans200ResponseInnerDhcpOptionsInner> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
  }


  public UpdateNetworkApplianceVlanRequest dhcpRelayServerIps(List<String> dhcpRelayServerIps) {
    this.dhcpRelayServerIps = dhcpRelayServerIps;
    return this;
  }

  public UpdateNetworkApplianceVlanRequest addDhcpRelayServerIpsItem(String dhcpRelayServerIpsItem) {
    if (this.dhcpRelayServerIps == null) {
      this.dhcpRelayServerIps = new ArrayList<>();
    }
    this.dhcpRelayServerIps.add(dhcpRelayServerIpsItem);
    return this;
  }

  /**
   * The IPs of the DHCP servers that DHCP requests should be relayed to
   * @return dhcpRelayServerIps
   */
  @javax.annotation.Nullable
  public List<String> getDhcpRelayServerIps() {
    return dhcpRelayServerIps;
  }

  public void setDhcpRelayServerIps(List<String> dhcpRelayServerIps) {
    this.dhcpRelayServerIps = dhcpRelayServerIps;
  }


  public UpdateNetworkApplianceVlanRequest dnsNameservers(String dnsNameservers) {
    this.dnsNameservers = dnsNameservers;
    return this;
  }

  /**
   * The DNS nameservers used for DHCP responses, either \&quot;upstream_dns\&quot;, \&quot;google_dns\&quot;, \&quot;opendns\&quot;, or a newline seperated string of IP addresses or domain names
   * @return dnsNameservers
   */
  @javax.annotation.Nullable
  public String getDnsNameservers() {
    return dnsNameservers;
  }

  public void setDnsNameservers(String dnsNameservers) {
    this.dnsNameservers = dnsNameservers;
  }


  public UpdateNetworkApplianceVlanRequest fixedIpAssignments(Object fixedIpAssignments) {
    this.fixedIpAssignments = fixedIpAssignments;
    return this;
  }

  /**
   * The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain \&quot;ip\&quot; and \&quot;name\&quot; string fields. See the sample request/response for more details.
   * @return fixedIpAssignments
   */
  @javax.annotation.Nullable
  public Object getFixedIpAssignments() {
    return fixedIpAssignments;
  }

  public void setFixedIpAssignments(Object fixedIpAssignments) {
    this.fixedIpAssignments = fixedIpAssignments;
  }


  public UpdateNetworkApplianceVlanRequest groupPolicyId(String groupPolicyId) {
    this.groupPolicyId = groupPolicyId;
    return this;
  }

  /**
   * The id of the desired group policy to apply to the VLAN
   * @return groupPolicyId
   */
  @javax.annotation.Nullable
  public String getGroupPolicyId() {
    return groupPolicyId;
  }

  public void setGroupPolicyId(String groupPolicyId) {
    this.groupPolicyId = groupPolicyId;
  }


  public UpdateNetworkApplianceVlanRequest ipv6(UpdateNetworkApplianceSingleLanRequestIpv6 ipv6) {
    this.ipv6 = ipv6;
    return this;
  }

  /**
   * Get ipv6
   * @return ipv6
   */
  @javax.annotation.Nullable
  public UpdateNetworkApplianceSingleLanRequestIpv6 getIpv6() {
    return ipv6;
  }

  public void setIpv6(UpdateNetworkApplianceSingleLanRequestIpv6 ipv6) {
    this.ipv6 = ipv6;
  }


  public UpdateNetworkApplianceVlanRequest mandatoryDhcp(GetNetworkApplianceVlans200ResponseInnerMandatoryDhcp mandatoryDhcp) {
    this.mandatoryDhcp = mandatoryDhcp;
    return this;
  }

  /**
   * Get mandatoryDhcp
   * @return mandatoryDhcp
   */
  @javax.annotation.Nullable
  public GetNetworkApplianceVlans200ResponseInnerMandatoryDhcp getMandatoryDhcp() {
    return mandatoryDhcp;
  }

  public void setMandatoryDhcp(GetNetworkApplianceVlans200ResponseInnerMandatoryDhcp mandatoryDhcp) {
    this.mandatoryDhcp = mandatoryDhcp;
  }


  public UpdateNetworkApplianceVlanRequest mask(Integer mask) {
    this.mask = mask;
    return this;
  }

  /**
   * Mask used for the subnet of all bound to the template networks. Applicable only for template network.
   * @return mask
   */
  @javax.annotation.Nullable
  public Integer getMask() {
    return mask;
  }

  public void setMask(Integer mask) {
    this.mask = mask;
  }


  public UpdateNetworkApplianceVlanRequest name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the VLAN
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public UpdateNetworkApplianceVlanRequest reservedIpRanges(List<UpdateNetworkApplianceStaticRouteRequestReservedIpRangesInner> reservedIpRanges) {
    this.reservedIpRanges = reservedIpRanges;
    return this;
  }

  public UpdateNetworkApplianceVlanRequest addReservedIpRangesItem(UpdateNetworkApplianceStaticRouteRequestReservedIpRangesInner reservedIpRangesItem) {
    if (this.reservedIpRanges == null) {
      this.reservedIpRanges = new ArrayList<>();
    }
    this.reservedIpRanges.add(reservedIpRangesItem);
    return this;
  }

  /**
   * The DHCP reserved IP ranges on the VLAN
   * @return reservedIpRanges
   */
  @javax.annotation.Nullable
  public List<UpdateNetworkApplianceStaticRouteRequestReservedIpRangesInner> getReservedIpRanges() {
    return reservedIpRanges;
  }

  public void setReservedIpRanges(List<UpdateNetworkApplianceStaticRouteRequestReservedIpRangesInner> reservedIpRanges) {
    this.reservedIpRanges = reservedIpRanges;
  }


  public UpdateNetworkApplianceVlanRequest subnet(String subnet) {
    this.subnet = subnet;
    return this;
  }

  /**
   * The subnet of the VLAN
   * @return subnet
   */
  @javax.annotation.Nullable
  public String getSubnet() {
    return subnet;
  }

  public void setSubnet(String subnet) {
    this.subnet = subnet;
  }


  public UpdateNetworkApplianceVlanRequest templateVlanType(TemplateVlanTypeEnum templateVlanType) {
    this.templateVlanType = templateVlanType;
    return this;
  }

  /**
   * Type of subnetting of the VLAN. Applicable only for template network.
   * @return templateVlanType
   */
  @javax.annotation.Nullable
  public TemplateVlanTypeEnum getTemplateVlanType() {
    return templateVlanType;
  }

  public void setTemplateVlanType(TemplateVlanTypeEnum templateVlanType) {
    this.templateVlanType = templateVlanType;
  }


  public UpdateNetworkApplianceVlanRequest vpnNatSubnet(String vpnNatSubnet) {
    this.vpnNatSubnet = vpnNatSubnet;
    return this;
  }

  /**
   * The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
   * @return vpnNatSubnet
   */
  @javax.annotation.Nullable
  public String getVpnNatSubnet() {
    return vpnNatSubnet;
  }

  public void setVpnNatSubnet(String vpnNatSubnet) {
    this.vpnNatSubnet = vpnNatSubnet;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateNetworkApplianceVlanRequest updateNetworkApplianceVlanRequest = (UpdateNetworkApplianceVlanRequest) o;
    return Objects.equals(this.applianceIp, updateNetworkApplianceVlanRequest.applianceIp) &&
        Objects.equals(this.cidr, updateNetworkApplianceVlanRequest.cidr) &&
        Objects.equals(this.dhcpBootFilename, updateNetworkApplianceVlanRequest.dhcpBootFilename) &&
        Objects.equals(this.dhcpBootNextServer, updateNetworkApplianceVlanRequest.dhcpBootNextServer) &&
        Objects.equals(this.dhcpBootOptionsEnabled, updateNetworkApplianceVlanRequest.dhcpBootOptionsEnabled) &&
        Objects.equals(this.dhcpHandling, updateNetworkApplianceVlanRequest.dhcpHandling) &&
        Objects.equals(this.dhcpLeaseTime, updateNetworkApplianceVlanRequest.dhcpLeaseTime) &&
        Objects.equals(this.dhcpOptions, updateNetworkApplianceVlanRequest.dhcpOptions) &&
        Objects.equals(this.dhcpRelayServerIps, updateNetworkApplianceVlanRequest.dhcpRelayServerIps) &&
        Objects.equals(this.dnsNameservers, updateNetworkApplianceVlanRequest.dnsNameservers) &&
        Objects.equals(this.fixedIpAssignments, updateNetworkApplianceVlanRequest.fixedIpAssignments) &&
        Objects.equals(this.groupPolicyId, updateNetworkApplianceVlanRequest.groupPolicyId) &&
        Objects.equals(this.ipv6, updateNetworkApplianceVlanRequest.ipv6) &&
        Objects.equals(this.mandatoryDhcp, updateNetworkApplianceVlanRequest.mandatoryDhcp) &&
        Objects.equals(this.mask, updateNetworkApplianceVlanRequest.mask) &&
        Objects.equals(this.name, updateNetworkApplianceVlanRequest.name) &&
        Objects.equals(this.reservedIpRanges, updateNetworkApplianceVlanRequest.reservedIpRanges) &&
        Objects.equals(this.subnet, updateNetworkApplianceVlanRequest.subnet) &&
        Objects.equals(this.templateVlanType, updateNetworkApplianceVlanRequest.templateVlanType) &&
        Objects.equals(this.vpnNatSubnet, updateNetworkApplianceVlanRequest.vpnNatSubnet);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applianceIp, cidr, dhcpBootFilename, dhcpBootNextServer, dhcpBootOptionsEnabled, dhcpHandling, dhcpLeaseTime, dhcpOptions, dhcpRelayServerIps, dnsNameservers, fixedIpAssignments, groupPolicyId, ipv6, mandatoryDhcp, mask, name, reservedIpRanges, subnet, templateVlanType, vpnNatSubnet);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateNetworkApplianceVlanRequest {\n");
    sb.append("    applianceIp: ").append(toIndentedString(applianceIp)).append("\n");
    sb.append("    cidr: ").append(toIndentedString(cidr)).append("\n");
    sb.append("    dhcpBootFilename: ").append(toIndentedString(dhcpBootFilename)).append("\n");
    sb.append("    dhcpBootNextServer: ").append(toIndentedString(dhcpBootNextServer)).append("\n");
    sb.append("    dhcpBootOptionsEnabled: ").append(toIndentedString(dhcpBootOptionsEnabled)).append("\n");
    sb.append("    dhcpHandling: ").append(toIndentedString(dhcpHandling)).append("\n");
    sb.append("    dhcpLeaseTime: ").append(toIndentedString(dhcpLeaseTime)).append("\n");
    sb.append("    dhcpOptions: ").append(toIndentedString(dhcpOptions)).append("\n");
    sb.append("    dhcpRelayServerIps: ").append(toIndentedString(dhcpRelayServerIps)).append("\n");
    sb.append("    dnsNameservers: ").append(toIndentedString(dnsNameservers)).append("\n");
    sb.append("    fixedIpAssignments: ").append(toIndentedString(fixedIpAssignments)).append("\n");
    sb.append("    groupPolicyId: ").append(toIndentedString(groupPolicyId)).append("\n");
    sb.append("    ipv6: ").append(toIndentedString(ipv6)).append("\n");
    sb.append("    mandatoryDhcp: ").append(toIndentedString(mandatoryDhcp)).append("\n");
    sb.append("    mask: ").append(toIndentedString(mask)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    reservedIpRanges: ").append(toIndentedString(reservedIpRanges)).append("\n");
    sb.append("    subnet: ").append(toIndentedString(subnet)).append("\n");
    sb.append("    templateVlanType: ").append(toIndentedString(templateVlanType)).append("\n");
    sb.append("    vpnNatSubnet: ").append(toIndentedString(vpnNatSubnet)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("applianceIp");
    openapiFields.add("cidr");
    openapiFields.add("dhcpBootFilename");
    openapiFields.add("dhcpBootNextServer");
    openapiFields.add("dhcpBootOptionsEnabled");
    openapiFields.add("dhcpHandling");
    openapiFields.add("dhcpLeaseTime");
    openapiFields.add("dhcpOptions");
    openapiFields.add("dhcpRelayServerIps");
    openapiFields.add("dnsNameservers");
    openapiFields.add("fixedIpAssignments");
    openapiFields.add("groupPolicyId");
    openapiFields.add("ipv6");
    openapiFields.add("mandatoryDhcp");
    openapiFields.add("mask");
    openapiFields.add("name");
    openapiFields.add("reservedIpRanges");
    openapiFields.add("subnet");
    openapiFields.add("templateVlanType");
    openapiFields.add("vpnNatSubnet");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateNetworkApplianceVlanRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateNetworkApplianceVlanRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateNetworkApplianceVlanRequest is not found in the empty JSON string", UpdateNetworkApplianceVlanRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateNetworkApplianceVlanRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateNetworkApplianceVlanRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("applianceIp") != null && !jsonObj.get("applianceIp").isJsonNull()) && !jsonObj.get("applianceIp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `applianceIp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("applianceIp").toString()));
      }
      if ((jsonObj.get("cidr") != null && !jsonObj.get("cidr").isJsonNull()) && !jsonObj.get("cidr").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cidr` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cidr").toString()));
      }
      if ((jsonObj.get("dhcpBootFilename") != null && !jsonObj.get("dhcpBootFilename").isJsonNull()) && !jsonObj.get("dhcpBootFilename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dhcpBootFilename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dhcpBootFilename").toString()));
      }
      if ((jsonObj.get("dhcpBootNextServer") != null && !jsonObj.get("dhcpBootNextServer").isJsonNull()) && !jsonObj.get("dhcpBootNextServer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dhcpBootNextServer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dhcpBootNextServer").toString()));
      }
      if ((jsonObj.get("dhcpHandling") != null && !jsonObj.get("dhcpHandling").isJsonNull()) && !jsonObj.get("dhcpHandling").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dhcpHandling` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dhcpHandling").toString()));
      }
      // validate the optional field `dhcpHandling`
      if (jsonObj.get("dhcpHandling") != null && !jsonObj.get("dhcpHandling").isJsonNull()) {
        DhcpHandlingEnum.validateJsonElement(jsonObj.get("dhcpHandling"));
      }
      if ((jsonObj.get("dhcpLeaseTime") != null && !jsonObj.get("dhcpLeaseTime").isJsonNull()) && !jsonObj.get("dhcpLeaseTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dhcpLeaseTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dhcpLeaseTime").toString()));
      }
      // validate the optional field `dhcpLeaseTime`
      if (jsonObj.get("dhcpLeaseTime") != null && !jsonObj.get("dhcpLeaseTime").isJsonNull()) {
        DhcpLeaseTimeEnum.validateJsonElement(jsonObj.get("dhcpLeaseTime"));
      }
      if (jsonObj.get("dhcpOptions") != null && !jsonObj.get("dhcpOptions").isJsonNull()) {
        JsonArray jsonArraydhcpOptions = jsonObj.getAsJsonArray("dhcpOptions");
        if (jsonArraydhcpOptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcpOptions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcpOptions` to be an array in the JSON string but got `%s`", jsonObj.get("dhcpOptions").toString()));
          }

          // validate the optional field `dhcpOptions` (array)
          for (int i = 0; i < jsonArraydhcpOptions.size(); i++) {
            GetNetworkApplianceVlans200ResponseInnerDhcpOptionsInner.validateJsonElement(jsonArraydhcpOptions.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("dhcpRelayServerIps") != null && !jsonObj.get("dhcpRelayServerIps").isJsonNull() && !jsonObj.get("dhcpRelayServerIps").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `dhcpRelayServerIps` to be an array in the JSON string but got `%s`", jsonObj.get("dhcpRelayServerIps").toString()));
      }
      if ((jsonObj.get("dnsNameservers") != null && !jsonObj.get("dnsNameservers").isJsonNull()) && !jsonObj.get("dnsNameservers").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dnsNameservers` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dnsNameservers").toString()));
      }
      if ((jsonObj.get("groupPolicyId") != null && !jsonObj.get("groupPolicyId").isJsonNull()) && !jsonObj.get("groupPolicyId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `groupPolicyId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("groupPolicyId").toString()));
      }
      // validate the optional field `ipv6`
      if (jsonObj.get("ipv6") != null && !jsonObj.get("ipv6").isJsonNull()) {
        UpdateNetworkApplianceSingleLanRequestIpv6.validateJsonElement(jsonObj.get("ipv6"));
      }
      // validate the optional field `mandatoryDhcp`
      if (jsonObj.get("mandatoryDhcp") != null && !jsonObj.get("mandatoryDhcp").isJsonNull()) {
        GetNetworkApplianceVlans200ResponseInnerMandatoryDhcp.validateJsonElement(jsonObj.get("mandatoryDhcp"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("reservedIpRanges") != null && !jsonObj.get("reservedIpRanges").isJsonNull()) {
        JsonArray jsonArrayreservedIpRanges = jsonObj.getAsJsonArray("reservedIpRanges");
        if (jsonArrayreservedIpRanges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("reservedIpRanges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `reservedIpRanges` to be an array in the JSON string but got `%s`", jsonObj.get("reservedIpRanges").toString()));
          }

          // validate the optional field `reservedIpRanges` (array)
          for (int i = 0; i < jsonArrayreservedIpRanges.size(); i++) {
            UpdateNetworkApplianceStaticRouteRequestReservedIpRangesInner.validateJsonElement(jsonArrayreservedIpRanges.get(i));
          };
        }
      }
      if ((jsonObj.get("subnet") != null && !jsonObj.get("subnet").isJsonNull()) && !jsonObj.get("subnet").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnet` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnet").toString()));
      }
      if ((jsonObj.get("templateVlanType") != null && !jsonObj.get("templateVlanType").isJsonNull()) && !jsonObj.get("templateVlanType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `templateVlanType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("templateVlanType").toString()));
      }
      // validate the optional field `templateVlanType`
      if (jsonObj.get("templateVlanType") != null && !jsonObj.get("templateVlanType").isJsonNull()) {
        TemplateVlanTypeEnum.validateJsonElement(jsonObj.get("templateVlanType"));
      }
      if ((jsonObj.get("vpnNatSubnet") != null && !jsonObj.get("vpnNatSubnet").isJsonNull()) && !jsonObj.get("vpnNatSubnet").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vpnNatSubnet` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vpnNatSubnet").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateNetworkApplianceVlanRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateNetworkApplianceVlanRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateNetworkApplianceVlanRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateNetworkApplianceVlanRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateNetworkApplianceVlanRequest>() {
           @Override
           public void write(JsonWriter out, UpdateNetworkApplianceVlanRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateNetworkApplianceVlanRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateNetworkApplianceVlanRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateNetworkApplianceVlanRequest
   * @throws IOException if the JSON string is invalid with respect to UpdateNetworkApplianceVlanRequest
   */
  public static UpdateNetworkApplianceVlanRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateNetworkApplianceVlanRequest.class);
  }

  /**
   * Convert an instance of UpdateNetworkApplianceVlanRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

