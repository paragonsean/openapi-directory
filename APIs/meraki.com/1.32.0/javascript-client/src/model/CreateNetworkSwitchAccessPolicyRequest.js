/**
 * Meraki Dashboard API
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 05 April, 2023 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 
 *
 * The version of the OpenAPI document: 1.32.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import CreateNetworkSwitchAccessPolicyRequestRadiusAccountingServersInner from './CreateNetworkSwitchAccessPolicyRequestRadiusAccountingServersInner';
import CreateNetworkSwitchAccessPolicyRequestRadiusServersInner from './CreateNetworkSwitchAccessPolicyRequestRadiusServersInner';
import GetNetworkSwitchAccessPolicies200ResponseInnerDot1x from './GetNetworkSwitchAccessPolicies200ResponseInnerDot1x';
import GetNetworkSwitchAccessPolicies200ResponseInnerRadius from './GetNetworkSwitchAccessPolicies200ResponseInnerRadius';

/**
 * The CreateNetworkSwitchAccessPolicyRequest model module.
 * @module model/CreateNetworkSwitchAccessPolicyRequest
 * @version 1.32.0
 */
class CreateNetworkSwitchAccessPolicyRequest {
    /**
     * Constructs a new <code>CreateNetworkSwitchAccessPolicyRequest</code>.
     * @alias module:model/CreateNetworkSwitchAccessPolicyRequest
     * @param hostMode {module:model/CreateNetworkSwitchAccessPolicyRequest.HostModeEnum} Choose the Host Mode for the access policy.
     * @param name {String} Name of the access policy
     * @param radiusAccountingEnabled {Boolean} Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
     * @param radiusCoaSupportEnabled {Boolean} Change of authentication for RADIUS re-authentication and disconnection
     * @param radiusServers {Array.<module:model/CreateNetworkSwitchAccessPolicyRequestRadiusServersInner>} List of RADIUS servers to require connecting devices to authenticate against before granting network access
     * @param radiusTestingEnabled {Boolean} If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
     * @param urlRedirectWalledGardenEnabled {Boolean} Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
     */
    constructor(hostMode, name, radiusAccountingEnabled, radiusCoaSupportEnabled, radiusServers, radiusTestingEnabled, urlRedirectWalledGardenEnabled) { 
        
        CreateNetworkSwitchAccessPolicyRequest.initialize(this, hostMode, name, radiusAccountingEnabled, radiusCoaSupportEnabled, radiusServers, radiusTestingEnabled, urlRedirectWalledGardenEnabled);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, hostMode, name, radiusAccountingEnabled, radiusCoaSupportEnabled, radiusServers, radiusTestingEnabled, urlRedirectWalledGardenEnabled) { 
        obj['hostMode'] = hostMode;
        obj['name'] = name;
        obj['radiusAccountingEnabled'] = radiusAccountingEnabled;
        obj['radiusCoaSupportEnabled'] = radiusCoaSupportEnabled;
        obj['radiusServers'] = radiusServers;
        obj['radiusTestingEnabled'] = radiusTestingEnabled;
        obj['urlRedirectWalledGardenEnabled'] = urlRedirectWalledGardenEnabled;
    }

    /**
     * Constructs a <code>CreateNetworkSwitchAccessPolicyRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/CreateNetworkSwitchAccessPolicyRequest} obj Optional instance to populate.
     * @return {module:model/CreateNetworkSwitchAccessPolicyRequest} The populated <code>CreateNetworkSwitchAccessPolicyRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new CreateNetworkSwitchAccessPolicyRequest();

            if (data.hasOwnProperty('accessPolicyType')) {
                obj['accessPolicyType'] = ApiClient.convertToType(data['accessPolicyType'], 'String');
            }
            if (data.hasOwnProperty('dot1x')) {
                obj['dot1x'] = GetNetworkSwitchAccessPolicies200ResponseInnerDot1x.constructFromObject(data['dot1x']);
            }
            if (data.hasOwnProperty('guestPortBouncing')) {
                obj['guestPortBouncing'] = ApiClient.convertToType(data['guestPortBouncing'], 'Boolean');
            }
            if (data.hasOwnProperty('guestVlanId')) {
                obj['guestVlanId'] = ApiClient.convertToType(data['guestVlanId'], 'Number');
            }
            if (data.hasOwnProperty('hostMode')) {
                obj['hostMode'] = ApiClient.convertToType(data['hostMode'], 'String');
            }
            if (data.hasOwnProperty('increaseAccessSpeed')) {
                obj['increaseAccessSpeed'] = ApiClient.convertToType(data['increaseAccessSpeed'], 'Boolean');
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('radius')) {
                obj['radius'] = GetNetworkSwitchAccessPolicies200ResponseInnerRadius.constructFromObject(data['radius']);
            }
            if (data.hasOwnProperty('radiusAccountingEnabled')) {
                obj['radiusAccountingEnabled'] = ApiClient.convertToType(data['radiusAccountingEnabled'], 'Boolean');
            }
            if (data.hasOwnProperty('radiusAccountingServers')) {
                obj['radiusAccountingServers'] = ApiClient.convertToType(data['radiusAccountingServers'], [CreateNetworkSwitchAccessPolicyRequestRadiusAccountingServersInner]);
            }
            if (data.hasOwnProperty('radiusCoaSupportEnabled')) {
                obj['radiusCoaSupportEnabled'] = ApiClient.convertToType(data['radiusCoaSupportEnabled'], 'Boolean');
            }
            if (data.hasOwnProperty('radiusGroupAttribute')) {
                obj['radiusGroupAttribute'] = ApiClient.convertToType(data['radiusGroupAttribute'], 'String');
            }
            if (data.hasOwnProperty('radiusServers')) {
                obj['radiusServers'] = ApiClient.convertToType(data['radiusServers'], [CreateNetworkSwitchAccessPolicyRequestRadiusServersInner]);
            }
            if (data.hasOwnProperty('radiusTestingEnabled')) {
                obj['radiusTestingEnabled'] = ApiClient.convertToType(data['radiusTestingEnabled'], 'Boolean');
            }
            if (data.hasOwnProperty('urlRedirectWalledGardenEnabled')) {
                obj['urlRedirectWalledGardenEnabled'] = ApiClient.convertToType(data['urlRedirectWalledGardenEnabled'], 'Boolean');
            }
            if (data.hasOwnProperty('urlRedirectWalledGardenRanges')) {
                obj['urlRedirectWalledGardenRanges'] = ApiClient.convertToType(data['urlRedirectWalledGardenRanges'], ['String']);
            }
            if (data.hasOwnProperty('voiceVlanClients')) {
                obj['voiceVlanClients'] = ApiClient.convertToType(data['voiceVlanClients'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>CreateNetworkSwitchAccessPolicyRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>CreateNetworkSwitchAccessPolicyRequest</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of CreateNetworkSwitchAccessPolicyRequest.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['accessPolicyType'] && !(typeof data['accessPolicyType'] === 'string' || data['accessPolicyType'] instanceof String)) {
            throw new Error("Expected the field `accessPolicyType` to be a primitive type in the JSON string but got " + data['accessPolicyType']);
        }
        // validate the optional field `dot1x`
        if (data['dot1x']) { // data not null
          GetNetworkSwitchAccessPolicies200ResponseInnerDot1x.validateJSON(data['dot1x']);
        }
        // ensure the json data is a string
        if (data['hostMode'] && !(typeof data['hostMode'] === 'string' || data['hostMode'] instanceof String)) {
            throw new Error("Expected the field `hostMode` to be a primitive type in the JSON string but got " + data['hostMode']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // validate the optional field `radius`
        if (data['radius']) { // data not null
          GetNetworkSwitchAccessPolicies200ResponseInnerRadius.validateJSON(data['radius']);
        }
        if (data['radiusAccountingServers']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['radiusAccountingServers'])) {
                throw new Error("Expected the field `radiusAccountingServers` to be an array in the JSON data but got " + data['radiusAccountingServers']);
            }
            // validate the optional field `radiusAccountingServers` (array)
            for (const item of data['radiusAccountingServers']) {
                CreateNetworkSwitchAccessPolicyRequestRadiusAccountingServersInner.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['radiusGroupAttribute'] && !(typeof data['radiusGroupAttribute'] === 'string' || data['radiusGroupAttribute'] instanceof String)) {
            throw new Error("Expected the field `radiusGroupAttribute` to be a primitive type in the JSON string but got " + data['radiusGroupAttribute']);
        }
        if (data['radiusServers']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['radiusServers'])) {
                throw new Error("Expected the field `radiusServers` to be an array in the JSON data but got " + data['radiusServers']);
            }
            // validate the optional field `radiusServers` (array)
            for (const item of data['radiusServers']) {
                CreateNetworkSwitchAccessPolicyRequestRadiusServersInner.validateJSON(item);
            };
        }
        // ensure the json data is an array
        if (!Array.isArray(data['urlRedirectWalledGardenRanges'])) {
            throw new Error("Expected the field `urlRedirectWalledGardenRanges` to be an array in the JSON data but got " + data['urlRedirectWalledGardenRanges']);
        }

        return true;
    }


}

CreateNetworkSwitchAccessPolicyRequest.RequiredProperties = ["hostMode", "name", "radiusAccountingEnabled", "radiusCoaSupportEnabled", "radiusServers", "radiusTestingEnabled", "urlRedirectWalledGardenEnabled"];

/**
 * Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
 * @member {module:model/CreateNetworkSwitchAccessPolicyRequest.AccessPolicyTypeEnum} accessPolicyType
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['accessPolicyType'] = undefined;

/**
 * @member {module:model/GetNetworkSwitchAccessPolicies200ResponseInnerDot1x} dot1x
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['dot1x'] = undefined;

/**
 * If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
 * @member {Boolean} guestPortBouncing
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['guestPortBouncing'] = undefined;

/**
 * ID for the guest VLAN allow unauthorized devices access to limited network resources
 * @member {Number} guestVlanId
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['guestVlanId'] = undefined;

/**
 * Choose the Host Mode for the access policy.
 * @member {module:model/CreateNetworkSwitchAccessPolicyRequest.HostModeEnum} hostMode
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['hostMode'] = undefined;

/**
 * Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
 * @member {Boolean} increaseAccessSpeed
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['increaseAccessSpeed'] = undefined;

/**
 * Name of the access policy
 * @member {String} name
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['name'] = undefined;

/**
 * @member {module:model/GetNetworkSwitchAccessPolicies200ResponseInnerRadius} radius
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['radius'] = undefined;

/**
 * Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
 * @member {Boolean} radiusAccountingEnabled
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['radiusAccountingEnabled'] = undefined;

/**
 * List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
 * @member {Array.<module:model/CreateNetworkSwitchAccessPolicyRequestRadiusAccountingServersInner>} radiusAccountingServers
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['radiusAccountingServers'] = undefined;

/**
 * Change of authentication for RADIUS re-authentication and disconnection
 * @member {Boolean} radiusCoaSupportEnabled
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['radiusCoaSupportEnabled'] = undefined;

/**
 * Acceptable values are `\"\"` for None, or `\"11\"` for Group Policies ACL
 * @member {String} radiusGroupAttribute
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['radiusGroupAttribute'] = undefined;

/**
 * List of RADIUS servers to require connecting devices to authenticate against before granting network access
 * @member {Array.<module:model/CreateNetworkSwitchAccessPolicyRequestRadiusServersInner>} radiusServers
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['radiusServers'] = undefined;

/**
 * If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
 * @member {Boolean} radiusTestingEnabled
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['radiusTestingEnabled'] = undefined;

/**
 * Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
 * @member {Boolean} urlRedirectWalledGardenEnabled
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['urlRedirectWalledGardenEnabled'] = undefined;

/**
 * IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
 * @member {Array.<String>} urlRedirectWalledGardenRanges
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['urlRedirectWalledGardenRanges'] = undefined;

/**
 * CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
 * @member {Boolean} voiceVlanClients
 */
CreateNetworkSwitchAccessPolicyRequest.prototype['voiceVlanClients'] = undefined;





/**
 * Allowed values for the <code>accessPolicyType</code> property.
 * @enum {String}
 * @readonly
 */
CreateNetworkSwitchAccessPolicyRequest['AccessPolicyTypeEnum'] = {

    /**
     * value: "802.1x"
     * @const
     */
    "802.1x": "802.1x",

    /**
     * value: "Hybrid authentication"
     * @const
     */
    "Hybrid authentication": "Hybrid authentication",

    /**
     * value: "MAC authentication bypass"
     * @const
     */
    "MAC authentication bypass": "MAC authentication bypass"
};


/**
 * Allowed values for the <code>hostMode</code> property.
 * @enum {String}
 * @readonly
 */
CreateNetworkSwitchAccessPolicyRequest['HostModeEnum'] = {

    /**
     * value: "Multi-Auth"
     * @const
     */
    "Multi-Auth": "Multi-Auth",

    /**
     * value: "Multi-Domain"
     * @const
     */
    "Multi-Domain": "Multi-Domain",

    /**
     * value: "Multi-Host"
     * @const
     */
    "Multi-Host": "Multi-Host",

    /**
     * value: "Single-Host"
     * @const
     */
    "Single-Host": "Single-Host"
};



export default CreateNetworkSwitchAccessPolicyRequest;

