/*
 * OPTIMADE API
 * The [Open Databases Integration for Materials Design (OPTIMADE) consortium](https://www.optimade.org/) aims to make materials databases interoperational by developing a common REST API.  This specification is generated using [`optimade-python-tools`](https://github.com/Materials-Consortia/optimade-python-tools/tree/v0.16.0) v0.16.0.
 *
 * The version of the OpenAPI document: 1.1.0~develop
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ErrorResponse;
import org.openapitools.client.model.ReferenceResponseMany;
import org.openapitools.client.model.ReferenceResponseOne;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ReferencesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ReferencesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ReferencesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getReferencesReferencesGet
     * @param filter A filter string, in the format described in section API Filtering Format Specification of the specification. (optional, default to )
     * @param responseFormat The output format requested (see section Response Format). Defaults to the format string &#39;json&#39;, which specifies the standard output format described in this specification. Example: &#x60;http://example.com/v1/structures?response_format&#x3D;xml&#x60; (optional, default to json)
     * @param emailAddress An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: &#x60;http://example.com/v1/structures?email_address&#x3D;user@example.com&#x60; (optional, default to )
     * @param responseFields A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: &#x60;http://example.com/v1/structures?response_fields&#x3D;last_modified,nsites&#x60; (optional, default to )
     * @param sort If supporting sortable queries, an implementation MUST use the &#x60;sort&#x60; query parameter with format as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-sorting).  An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification.  If an implementation supports sorting for an entry listing endpoint, then the &#x60;/info/&lt;entries&gt;&#x60; endpoint MUST include, for each field name &#x60;&lt;fieldname&gt;&#x60; in its &#x60;data.properties.&lt;fieldname&gt;&#x60; response value that can be used for sorting, the key &#x60;sortable&#x60; with value &#x60;true&#x60;. If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the &#x60;sortable&#x60; key or set it equal to &#x60;false&#x60; for the specific field name. The set of field names, with &#x60;sortable&#x60; equal to &#x60;true&#x60; are allowed to be used in the \&quot;sort fields\&quot; list according to its definition in the JSON API 1.0 specification. The field &#x60;sortable&#x60; is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints. (optional, default to )
     * @param pageLimit Sets a numerical limit on the number of entries returned. See [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-pagination). The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example: &#x60;http://example.com/optimade/v1/structures?page_limit&#x3D;100&#x60; (optional, default to 20)
     * @param pageOffset RECOMMENDED for use with _offset-based_ pagination: using &#x60;page_offset&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. Example: Skip 50 structures and fetch up to 100: &#x60;/structures?page_offset&#x3D;50&amp;page_limit&#x3D;100&#x60;. (optional, default to 0)
     * @param pageNumber RECOMMENDED for use with _page-based_ pagination: using &#x60;page_number&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that &#x60;page_number&#x60; is 1-based. Example: Fetch page 2 of up to 50 structures per page: &#x60;/structures?page_number&#x3D;2&amp;page_limit&#x3D;50&#x60;. (optional, default to 0)
     * @param pageCursor RECOMMENDED for use with _cursor-based_ pagination: using &#x60;page_cursor&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. (optional, default to 0)
     * @param pageAbove RECOMMENDED for use with _value-based_ pagination: using &#x60;page_above&#x60;/&#x60;page_below&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. Example: Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing &#x60;id&#x60;, so &#x60;page_above&#x60; value refers to an &#x60;id&#x60; value): &#x60;/structures?page_above&#x3D;4000&amp;page_limit&#x3D;100&#x60;. (optional, default to 0)
     * @param pageBelow RECOMMENDED for use with _value-based_ pagination: using &#x60;page_above&#x60;/&#x60;page_below&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. (optional, default to 0)
     * @param include A server MAY implement the JSON API concept of returning [compound documents](https://jsonapi.org/format/1.0/#document-compound-documents) by utilizing the &#x60;include&#x60; query parameter as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-includes).  All related resource objects MUST be returned as part of an array value for the top-level &#x60;included&#x60; field, see the section JSON Response Schema: Common Fields.  The value of &#x60;include&#x60; MUST be a comma-separated list of \&quot;relationship paths\&quot;, as defined in the [JSON API](https://jsonapi.org/format/1.0/#fetching-includes). If relationship paths are not supported, or a server is unable to identify a relationship path a &#x60;400 Bad Request&#x60; response MUST be made.  The **default value** for &#x60;include&#x60; is &#x60;references&#x60;. This means &#x60;references&#x60; entries MUST always be included under the top-level field &#x60;included&#x60; as default, since a server assumes if &#x60;include&#x60; is not specified by a client in the request, it is still specified as &#x60;include&#x3D;references&#x60;. Note, if a client explicitly specifies &#x60;include&#x60; and leaves out &#x60;references&#x60;, &#x60;references&#x60; resource objects MUST NOT be included under the top-level field &#x60;included&#x60;, as per the definition of &#x60;included&#x60;, see section JSON Response Schema: Common Fields.  &gt; **Note**: A query with the parameter &#x60;include&#x60; set to the empty string means no related resource objects are to be returned under the top-level field &#x60;included&#x60;. (optional, default to references)
     * @param apiHint If the client provides the parameter, the value SHOULD have the format &#x60;vMAJOR&#x60; or &#x60;vMAJOR.MINOR&#x60;, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends &#x60;api_hint&#x3D;v1.0&#x60; to the query string, the hint provided is for major version 1 and minor version 0. (optional, default to )
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> Not Implemented </td><td>  -  </td></tr>
        <tr><td> 553 </td><td> Version Not Supported </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReferencesReferencesGetCall(String filter, String responseFormat, String emailAddress, String responseFields, String sort, Integer pageLimit, Integer pageOffset, Integer pageNumber, Integer pageCursor, Integer pageAbove, Integer pageBelow, String include, String apiHint, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/references";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (responseFormat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("response_format", responseFormat));
        }

        if (emailAddress != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("email_address", emailAddress));
        }

        if (responseFields != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("response_fields", responseFields));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (pageLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_limit", pageLimit));
        }

        if (pageOffset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_offset", pageOffset));
        }

        if (pageNumber != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_number", pageNumber));
        }

        if (pageCursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_cursor", pageCursor));
        }

        if (pageAbove != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_above", pageAbove));
        }

        if (pageBelow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_below", pageBelow));
        }

        if (include != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include", include));
        }

        if (apiHint != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_hint", apiHint));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReferencesReferencesGetValidateBeforeCall(String filter, String responseFormat, String emailAddress, String responseFields, String sort, Integer pageLimit, Integer pageOffset, Integer pageNumber, Integer pageCursor, Integer pageAbove, Integer pageBelow, String include, String apiHint, final ApiCallback _callback) throws ApiException {
        return getReferencesReferencesGetCall(filter, responseFormat, emailAddress, responseFields, sort, pageLimit, pageOffset, pageNumber, pageCursor, pageAbove, pageBelow, include, apiHint, _callback);

    }

    /**
     * Get References
     * 
     * @param filter A filter string, in the format described in section API Filtering Format Specification of the specification. (optional, default to )
     * @param responseFormat The output format requested (see section Response Format). Defaults to the format string &#39;json&#39;, which specifies the standard output format described in this specification. Example: &#x60;http://example.com/v1/structures?response_format&#x3D;xml&#x60; (optional, default to json)
     * @param emailAddress An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: &#x60;http://example.com/v1/structures?email_address&#x3D;user@example.com&#x60; (optional, default to )
     * @param responseFields A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: &#x60;http://example.com/v1/structures?response_fields&#x3D;last_modified,nsites&#x60; (optional, default to )
     * @param sort If supporting sortable queries, an implementation MUST use the &#x60;sort&#x60; query parameter with format as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-sorting).  An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification.  If an implementation supports sorting for an entry listing endpoint, then the &#x60;/info/&lt;entries&gt;&#x60; endpoint MUST include, for each field name &#x60;&lt;fieldname&gt;&#x60; in its &#x60;data.properties.&lt;fieldname&gt;&#x60; response value that can be used for sorting, the key &#x60;sortable&#x60; with value &#x60;true&#x60;. If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the &#x60;sortable&#x60; key or set it equal to &#x60;false&#x60; for the specific field name. The set of field names, with &#x60;sortable&#x60; equal to &#x60;true&#x60; are allowed to be used in the \&quot;sort fields\&quot; list according to its definition in the JSON API 1.0 specification. The field &#x60;sortable&#x60; is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints. (optional, default to )
     * @param pageLimit Sets a numerical limit on the number of entries returned. See [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-pagination). The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example: &#x60;http://example.com/optimade/v1/structures?page_limit&#x3D;100&#x60; (optional, default to 20)
     * @param pageOffset RECOMMENDED for use with _offset-based_ pagination: using &#x60;page_offset&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. Example: Skip 50 structures and fetch up to 100: &#x60;/structures?page_offset&#x3D;50&amp;page_limit&#x3D;100&#x60;. (optional, default to 0)
     * @param pageNumber RECOMMENDED for use with _page-based_ pagination: using &#x60;page_number&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that &#x60;page_number&#x60; is 1-based. Example: Fetch page 2 of up to 50 structures per page: &#x60;/structures?page_number&#x3D;2&amp;page_limit&#x3D;50&#x60;. (optional, default to 0)
     * @param pageCursor RECOMMENDED for use with _cursor-based_ pagination: using &#x60;page_cursor&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. (optional, default to 0)
     * @param pageAbove RECOMMENDED for use with _value-based_ pagination: using &#x60;page_above&#x60;/&#x60;page_below&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. Example: Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing &#x60;id&#x60;, so &#x60;page_above&#x60; value refers to an &#x60;id&#x60; value): &#x60;/structures?page_above&#x3D;4000&amp;page_limit&#x3D;100&#x60;. (optional, default to 0)
     * @param pageBelow RECOMMENDED for use with _value-based_ pagination: using &#x60;page_above&#x60;/&#x60;page_below&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. (optional, default to 0)
     * @param include A server MAY implement the JSON API concept of returning [compound documents](https://jsonapi.org/format/1.0/#document-compound-documents) by utilizing the &#x60;include&#x60; query parameter as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-includes).  All related resource objects MUST be returned as part of an array value for the top-level &#x60;included&#x60; field, see the section JSON Response Schema: Common Fields.  The value of &#x60;include&#x60; MUST be a comma-separated list of \&quot;relationship paths\&quot;, as defined in the [JSON API](https://jsonapi.org/format/1.0/#fetching-includes). If relationship paths are not supported, or a server is unable to identify a relationship path a &#x60;400 Bad Request&#x60; response MUST be made.  The **default value** for &#x60;include&#x60; is &#x60;references&#x60;. This means &#x60;references&#x60; entries MUST always be included under the top-level field &#x60;included&#x60; as default, since a server assumes if &#x60;include&#x60; is not specified by a client in the request, it is still specified as &#x60;include&#x3D;references&#x60;. Note, if a client explicitly specifies &#x60;include&#x60; and leaves out &#x60;references&#x60;, &#x60;references&#x60; resource objects MUST NOT be included under the top-level field &#x60;included&#x60;, as per the definition of &#x60;included&#x60;, see section JSON Response Schema: Common Fields.  &gt; **Note**: A query with the parameter &#x60;include&#x60; set to the empty string means no related resource objects are to be returned under the top-level field &#x60;included&#x60;. (optional, default to references)
     * @param apiHint If the client provides the parameter, the value SHOULD have the format &#x60;vMAJOR&#x60; or &#x60;vMAJOR.MINOR&#x60;, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends &#x60;api_hint&#x3D;v1.0&#x60; to the query string, the hint provided is for major version 1 and minor version 0. (optional, default to )
     * @return ReferenceResponseMany
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> Not Implemented </td><td>  -  </td></tr>
        <tr><td> 553 </td><td> Version Not Supported </td><td>  -  </td></tr>
     </table>
     */
    public ReferenceResponseMany getReferencesReferencesGet(String filter, String responseFormat, String emailAddress, String responseFields, String sort, Integer pageLimit, Integer pageOffset, Integer pageNumber, Integer pageCursor, Integer pageAbove, Integer pageBelow, String include, String apiHint) throws ApiException {
        ApiResponse<ReferenceResponseMany> localVarResp = getReferencesReferencesGetWithHttpInfo(filter, responseFormat, emailAddress, responseFields, sort, pageLimit, pageOffset, pageNumber, pageCursor, pageAbove, pageBelow, include, apiHint);
        return localVarResp.getData();
    }

    /**
     * Get References
     * 
     * @param filter A filter string, in the format described in section API Filtering Format Specification of the specification. (optional, default to )
     * @param responseFormat The output format requested (see section Response Format). Defaults to the format string &#39;json&#39;, which specifies the standard output format described in this specification. Example: &#x60;http://example.com/v1/structures?response_format&#x3D;xml&#x60; (optional, default to json)
     * @param emailAddress An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: &#x60;http://example.com/v1/structures?email_address&#x3D;user@example.com&#x60; (optional, default to )
     * @param responseFields A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: &#x60;http://example.com/v1/structures?response_fields&#x3D;last_modified,nsites&#x60; (optional, default to )
     * @param sort If supporting sortable queries, an implementation MUST use the &#x60;sort&#x60; query parameter with format as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-sorting).  An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification.  If an implementation supports sorting for an entry listing endpoint, then the &#x60;/info/&lt;entries&gt;&#x60; endpoint MUST include, for each field name &#x60;&lt;fieldname&gt;&#x60; in its &#x60;data.properties.&lt;fieldname&gt;&#x60; response value that can be used for sorting, the key &#x60;sortable&#x60; with value &#x60;true&#x60;. If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the &#x60;sortable&#x60; key or set it equal to &#x60;false&#x60; for the specific field name. The set of field names, with &#x60;sortable&#x60; equal to &#x60;true&#x60; are allowed to be used in the \&quot;sort fields\&quot; list according to its definition in the JSON API 1.0 specification. The field &#x60;sortable&#x60; is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints. (optional, default to )
     * @param pageLimit Sets a numerical limit on the number of entries returned. See [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-pagination). The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example: &#x60;http://example.com/optimade/v1/structures?page_limit&#x3D;100&#x60; (optional, default to 20)
     * @param pageOffset RECOMMENDED for use with _offset-based_ pagination: using &#x60;page_offset&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. Example: Skip 50 structures and fetch up to 100: &#x60;/structures?page_offset&#x3D;50&amp;page_limit&#x3D;100&#x60;. (optional, default to 0)
     * @param pageNumber RECOMMENDED for use with _page-based_ pagination: using &#x60;page_number&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that &#x60;page_number&#x60; is 1-based. Example: Fetch page 2 of up to 50 structures per page: &#x60;/structures?page_number&#x3D;2&amp;page_limit&#x3D;50&#x60;. (optional, default to 0)
     * @param pageCursor RECOMMENDED for use with _cursor-based_ pagination: using &#x60;page_cursor&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. (optional, default to 0)
     * @param pageAbove RECOMMENDED for use with _value-based_ pagination: using &#x60;page_above&#x60;/&#x60;page_below&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. Example: Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing &#x60;id&#x60;, so &#x60;page_above&#x60; value refers to an &#x60;id&#x60; value): &#x60;/structures?page_above&#x3D;4000&amp;page_limit&#x3D;100&#x60;. (optional, default to 0)
     * @param pageBelow RECOMMENDED for use with _value-based_ pagination: using &#x60;page_above&#x60;/&#x60;page_below&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. (optional, default to 0)
     * @param include A server MAY implement the JSON API concept of returning [compound documents](https://jsonapi.org/format/1.0/#document-compound-documents) by utilizing the &#x60;include&#x60; query parameter as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-includes).  All related resource objects MUST be returned as part of an array value for the top-level &#x60;included&#x60; field, see the section JSON Response Schema: Common Fields.  The value of &#x60;include&#x60; MUST be a comma-separated list of \&quot;relationship paths\&quot;, as defined in the [JSON API](https://jsonapi.org/format/1.0/#fetching-includes). If relationship paths are not supported, or a server is unable to identify a relationship path a &#x60;400 Bad Request&#x60; response MUST be made.  The **default value** for &#x60;include&#x60; is &#x60;references&#x60;. This means &#x60;references&#x60; entries MUST always be included under the top-level field &#x60;included&#x60; as default, since a server assumes if &#x60;include&#x60; is not specified by a client in the request, it is still specified as &#x60;include&#x3D;references&#x60;. Note, if a client explicitly specifies &#x60;include&#x60; and leaves out &#x60;references&#x60;, &#x60;references&#x60; resource objects MUST NOT be included under the top-level field &#x60;included&#x60;, as per the definition of &#x60;included&#x60;, see section JSON Response Schema: Common Fields.  &gt; **Note**: A query with the parameter &#x60;include&#x60; set to the empty string means no related resource objects are to be returned under the top-level field &#x60;included&#x60;. (optional, default to references)
     * @param apiHint If the client provides the parameter, the value SHOULD have the format &#x60;vMAJOR&#x60; or &#x60;vMAJOR.MINOR&#x60;, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends &#x60;api_hint&#x3D;v1.0&#x60; to the query string, the hint provided is for major version 1 and minor version 0. (optional, default to )
     * @return ApiResponse&lt;ReferenceResponseMany&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> Not Implemented </td><td>  -  </td></tr>
        <tr><td> 553 </td><td> Version Not Supported </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReferenceResponseMany> getReferencesReferencesGetWithHttpInfo(String filter, String responseFormat, String emailAddress, String responseFields, String sort, Integer pageLimit, Integer pageOffset, Integer pageNumber, Integer pageCursor, Integer pageAbove, Integer pageBelow, String include, String apiHint) throws ApiException {
        okhttp3.Call localVarCall = getReferencesReferencesGetValidateBeforeCall(filter, responseFormat, emailAddress, responseFields, sort, pageLimit, pageOffset, pageNumber, pageCursor, pageAbove, pageBelow, include, apiHint, null);
        Type localVarReturnType = new TypeToken<ReferenceResponseMany>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get References (asynchronously)
     * 
     * @param filter A filter string, in the format described in section API Filtering Format Specification of the specification. (optional, default to )
     * @param responseFormat The output format requested (see section Response Format). Defaults to the format string &#39;json&#39;, which specifies the standard output format described in this specification. Example: &#x60;http://example.com/v1/structures?response_format&#x3D;xml&#x60; (optional, default to json)
     * @param emailAddress An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: &#x60;http://example.com/v1/structures?email_address&#x3D;user@example.com&#x60; (optional, default to )
     * @param responseFields A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: &#x60;http://example.com/v1/structures?response_fields&#x3D;last_modified,nsites&#x60; (optional, default to )
     * @param sort If supporting sortable queries, an implementation MUST use the &#x60;sort&#x60; query parameter with format as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-sorting).  An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification.  If an implementation supports sorting for an entry listing endpoint, then the &#x60;/info/&lt;entries&gt;&#x60; endpoint MUST include, for each field name &#x60;&lt;fieldname&gt;&#x60; in its &#x60;data.properties.&lt;fieldname&gt;&#x60; response value that can be used for sorting, the key &#x60;sortable&#x60; with value &#x60;true&#x60;. If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the &#x60;sortable&#x60; key or set it equal to &#x60;false&#x60; for the specific field name. The set of field names, with &#x60;sortable&#x60; equal to &#x60;true&#x60; are allowed to be used in the \&quot;sort fields\&quot; list according to its definition in the JSON API 1.0 specification. The field &#x60;sortable&#x60; is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints. (optional, default to )
     * @param pageLimit Sets a numerical limit on the number of entries returned. See [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-pagination). The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example: &#x60;http://example.com/optimade/v1/structures?page_limit&#x3D;100&#x60; (optional, default to 20)
     * @param pageOffset RECOMMENDED for use with _offset-based_ pagination: using &#x60;page_offset&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. Example: Skip 50 structures and fetch up to 100: &#x60;/structures?page_offset&#x3D;50&amp;page_limit&#x3D;100&#x60;. (optional, default to 0)
     * @param pageNumber RECOMMENDED for use with _page-based_ pagination: using &#x60;page_number&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that &#x60;page_number&#x60; is 1-based. Example: Fetch page 2 of up to 50 structures per page: &#x60;/structures?page_number&#x3D;2&amp;page_limit&#x3D;50&#x60;. (optional, default to 0)
     * @param pageCursor RECOMMENDED for use with _cursor-based_ pagination: using &#x60;page_cursor&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. (optional, default to 0)
     * @param pageAbove RECOMMENDED for use with _value-based_ pagination: using &#x60;page_above&#x60;/&#x60;page_below&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. Example: Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing &#x60;id&#x60;, so &#x60;page_above&#x60; value refers to an &#x60;id&#x60; value): &#x60;/structures?page_above&#x3D;4000&amp;page_limit&#x3D;100&#x60;. (optional, default to 0)
     * @param pageBelow RECOMMENDED for use with _value-based_ pagination: using &#x60;page_above&#x60;/&#x60;page_below&#x60; and &#x60;page_limit&#x60; is RECOMMENDED. (optional, default to 0)
     * @param include A server MAY implement the JSON API concept of returning [compound documents](https://jsonapi.org/format/1.0/#document-compound-documents) by utilizing the &#x60;include&#x60; query parameter as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-includes).  All related resource objects MUST be returned as part of an array value for the top-level &#x60;included&#x60; field, see the section JSON Response Schema: Common Fields.  The value of &#x60;include&#x60; MUST be a comma-separated list of \&quot;relationship paths\&quot;, as defined in the [JSON API](https://jsonapi.org/format/1.0/#fetching-includes). If relationship paths are not supported, or a server is unable to identify a relationship path a &#x60;400 Bad Request&#x60; response MUST be made.  The **default value** for &#x60;include&#x60; is &#x60;references&#x60;. This means &#x60;references&#x60; entries MUST always be included under the top-level field &#x60;included&#x60; as default, since a server assumes if &#x60;include&#x60; is not specified by a client in the request, it is still specified as &#x60;include&#x3D;references&#x60;. Note, if a client explicitly specifies &#x60;include&#x60; and leaves out &#x60;references&#x60;, &#x60;references&#x60; resource objects MUST NOT be included under the top-level field &#x60;included&#x60;, as per the definition of &#x60;included&#x60;, see section JSON Response Schema: Common Fields.  &gt; **Note**: A query with the parameter &#x60;include&#x60; set to the empty string means no related resource objects are to be returned under the top-level field &#x60;included&#x60;. (optional, default to references)
     * @param apiHint If the client provides the parameter, the value SHOULD have the format &#x60;vMAJOR&#x60; or &#x60;vMAJOR.MINOR&#x60;, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends &#x60;api_hint&#x3D;v1.0&#x60; to the query string, the hint provided is for major version 1 and minor version 0. (optional, default to )
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> Not Implemented </td><td>  -  </td></tr>
        <tr><td> 553 </td><td> Version Not Supported </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReferencesReferencesGetAsync(String filter, String responseFormat, String emailAddress, String responseFields, String sort, Integer pageLimit, Integer pageOffset, Integer pageNumber, Integer pageCursor, Integer pageAbove, Integer pageBelow, String include, String apiHint, final ApiCallback<ReferenceResponseMany> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReferencesReferencesGetValidateBeforeCall(filter, responseFormat, emailAddress, responseFields, sort, pageLimit, pageOffset, pageNumber, pageCursor, pageAbove, pageBelow, include, apiHint, _callback);
        Type localVarReturnType = new TypeToken<ReferenceResponseMany>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSingleReferenceReferencesEntryIdGet
     * @param entryId  (required)
     * @param responseFormat The output format requested (see section Response Format). Defaults to the format string &#39;json&#39;, which specifies the standard output format described in this specification. Example: &#x60;http://example.com/v1/structures?response_format&#x3D;xml&#x60; (optional, default to json)
     * @param emailAddress An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: &#x60;http://example.com/v1/structures?email_address&#x3D;user@example.com&#x60; (optional, default to )
     * @param responseFields A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: &#x60;http://example.com/v1/structures?response_fields&#x3D;last_modified,nsites&#x60; (optional, default to )
     * @param include A server MAY implement the JSON API concept of returning [compound documents](https://jsonapi.org/format/1.0/#document-compound-documents) by utilizing the &#x60;include&#x60; query parameter as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-includes).  All related resource objects MUST be returned as part of an array value for the top-level &#x60;included&#x60; field, see the section JSON Response Schema: Common Fields.  The value of &#x60;include&#x60; MUST be a comma-separated list of \&quot;relationship paths\&quot;, as defined in the [JSON API](https://jsonapi.org/format/1.0/#fetching-includes). If relationship paths are not supported, or a server is unable to identify a relationship path a &#x60;400 Bad Request&#x60; response MUST be made.  The **default value** for &#x60;include&#x60; is &#x60;references&#x60;. This means &#x60;references&#x60; entries MUST always be included under the top-level field &#x60;included&#x60; as default, since a server assumes if &#x60;include&#x60; is not specified by a client in the request, it is still specified as &#x60;include&#x3D;references&#x60;. Note, if a client explicitly specifies &#x60;include&#x60; and leaves out &#x60;references&#x60;, &#x60;references&#x60; resource objects MUST NOT be included under the top-level field &#x60;included&#x60;, as per the definition of &#x60;included&#x60;, see section JSON Response Schema: Common Fields.  &gt; **Note**: A query with the parameter &#x60;include&#x60; set to the empty string means no related resource objects are to be returned under the top-level field &#x60;included&#x60;. (optional, default to references)
     * @param apiHint If the client provides the parameter, the value SHOULD have the format &#x60;vMAJOR&#x60; or &#x60;vMAJOR.MINOR&#x60;, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends &#x60;api_hint&#x3D;v1.0&#x60; to the query string, the hint provided is for major version 1 and minor version 0. (optional, default to )
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> Not Implemented </td><td>  -  </td></tr>
        <tr><td> 553 </td><td> Version Not Supported </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSingleReferenceReferencesEntryIdGetCall(String entryId, String responseFormat, String emailAddress, String responseFields, String include, String apiHint, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/references/{entry_id}"
            .replace("{" + "entry_id" + "}", localVarApiClient.escapeString(entryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (responseFormat != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("response_format", responseFormat));
        }

        if (emailAddress != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("email_address", emailAddress));
        }

        if (responseFields != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("response_fields", responseFields));
        }

        if (include != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include", include));
        }

        if (apiHint != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("api_hint", apiHint));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSingleReferenceReferencesEntryIdGetValidateBeforeCall(String entryId, String responseFormat, String emailAddress, String responseFields, String include, String apiHint, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'entryId' is set
        if (entryId == null) {
            throw new ApiException("Missing the required parameter 'entryId' when calling getSingleReferenceReferencesEntryIdGet(Async)");
        }

        return getSingleReferenceReferencesEntryIdGetCall(entryId, responseFormat, emailAddress, responseFields, include, apiHint, _callback);

    }

    /**
     * Get Single Reference
     * 
     * @param entryId  (required)
     * @param responseFormat The output format requested (see section Response Format). Defaults to the format string &#39;json&#39;, which specifies the standard output format described in this specification. Example: &#x60;http://example.com/v1/structures?response_format&#x3D;xml&#x60; (optional, default to json)
     * @param emailAddress An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: &#x60;http://example.com/v1/structures?email_address&#x3D;user@example.com&#x60; (optional, default to )
     * @param responseFields A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: &#x60;http://example.com/v1/structures?response_fields&#x3D;last_modified,nsites&#x60; (optional, default to )
     * @param include A server MAY implement the JSON API concept of returning [compound documents](https://jsonapi.org/format/1.0/#document-compound-documents) by utilizing the &#x60;include&#x60; query parameter as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-includes).  All related resource objects MUST be returned as part of an array value for the top-level &#x60;included&#x60; field, see the section JSON Response Schema: Common Fields.  The value of &#x60;include&#x60; MUST be a comma-separated list of \&quot;relationship paths\&quot;, as defined in the [JSON API](https://jsonapi.org/format/1.0/#fetching-includes). If relationship paths are not supported, or a server is unable to identify a relationship path a &#x60;400 Bad Request&#x60; response MUST be made.  The **default value** for &#x60;include&#x60; is &#x60;references&#x60;. This means &#x60;references&#x60; entries MUST always be included under the top-level field &#x60;included&#x60; as default, since a server assumes if &#x60;include&#x60; is not specified by a client in the request, it is still specified as &#x60;include&#x3D;references&#x60;. Note, if a client explicitly specifies &#x60;include&#x60; and leaves out &#x60;references&#x60;, &#x60;references&#x60; resource objects MUST NOT be included under the top-level field &#x60;included&#x60;, as per the definition of &#x60;included&#x60;, see section JSON Response Schema: Common Fields.  &gt; **Note**: A query with the parameter &#x60;include&#x60; set to the empty string means no related resource objects are to be returned under the top-level field &#x60;included&#x60;. (optional, default to references)
     * @param apiHint If the client provides the parameter, the value SHOULD have the format &#x60;vMAJOR&#x60; or &#x60;vMAJOR.MINOR&#x60;, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends &#x60;api_hint&#x3D;v1.0&#x60; to the query string, the hint provided is for major version 1 and minor version 0. (optional, default to )
     * @return ReferenceResponseOne
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> Not Implemented </td><td>  -  </td></tr>
        <tr><td> 553 </td><td> Version Not Supported </td><td>  -  </td></tr>
     </table>
     */
    public ReferenceResponseOne getSingleReferenceReferencesEntryIdGet(String entryId, String responseFormat, String emailAddress, String responseFields, String include, String apiHint) throws ApiException {
        ApiResponse<ReferenceResponseOne> localVarResp = getSingleReferenceReferencesEntryIdGetWithHttpInfo(entryId, responseFormat, emailAddress, responseFields, include, apiHint);
        return localVarResp.getData();
    }

    /**
     * Get Single Reference
     * 
     * @param entryId  (required)
     * @param responseFormat The output format requested (see section Response Format). Defaults to the format string &#39;json&#39;, which specifies the standard output format described in this specification. Example: &#x60;http://example.com/v1/structures?response_format&#x3D;xml&#x60; (optional, default to json)
     * @param emailAddress An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: &#x60;http://example.com/v1/structures?email_address&#x3D;user@example.com&#x60; (optional, default to )
     * @param responseFields A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: &#x60;http://example.com/v1/structures?response_fields&#x3D;last_modified,nsites&#x60; (optional, default to )
     * @param include A server MAY implement the JSON API concept of returning [compound documents](https://jsonapi.org/format/1.0/#document-compound-documents) by utilizing the &#x60;include&#x60; query parameter as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-includes).  All related resource objects MUST be returned as part of an array value for the top-level &#x60;included&#x60; field, see the section JSON Response Schema: Common Fields.  The value of &#x60;include&#x60; MUST be a comma-separated list of \&quot;relationship paths\&quot;, as defined in the [JSON API](https://jsonapi.org/format/1.0/#fetching-includes). If relationship paths are not supported, or a server is unable to identify a relationship path a &#x60;400 Bad Request&#x60; response MUST be made.  The **default value** for &#x60;include&#x60; is &#x60;references&#x60;. This means &#x60;references&#x60; entries MUST always be included under the top-level field &#x60;included&#x60; as default, since a server assumes if &#x60;include&#x60; is not specified by a client in the request, it is still specified as &#x60;include&#x3D;references&#x60;. Note, if a client explicitly specifies &#x60;include&#x60; and leaves out &#x60;references&#x60;, &#x60;references&#x60; resource objects MUST NOT be included under the top-level field &#x60;included&#x60;, as per the definition of &#x60;included&#x60;, see section JSON Response Schema: Common Fields.  &gt; **Note**: A query with the parameter &#x60;include&#x60; set to the empty string means no related resource objects are to be returned under the top-level field &#x60;included&#x60;. (optional, default to references)
     * @param apiHint If the client provides the parameter, the value SHOULD have the format &#x60;vMAJOR&#x60; or &#x60;vMAJOR.MINOR&#x60;, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends &#x60;api_hint&#x3D;v1.0&#x60; to the query string, the hint provided is for major version 1 and minor version 0. (optional, default to )
     * @return ApiResponse&lt;ReferenceResponseOne&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> Not Implemented </td><td>  -  </td></tr>
        <tr><td> 553 </td><td> Version Not Supported </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReferenceResponseOne> getSingleReferenceReferencesEntryIdGetWithHttpInfo(String entryId, String responseFormat, String emailAddress, String responseFields, String include, String apiHint) throws ApiException {
        okhttp3.Call localVarCall = getSingleReferenceReferencesEntryIdGetValidateBeforeCall(entryId, responseFormat, emailAddress, responseFields, include, apiHint, null);
        Type localVarReturnType = new TypeToken<ReferenceResponseOne>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Single Reference (asynchronously)
     * 
     * @param entryId  (required)
     * @param responseFormat The output format requested (see section Response Format). Defaults to the format string &#39;json&#39;, which specifies the standard output format described in this specification. Example: &#x60;http://example.com/v1/structures?response_format&#x3D;xml&#x60; (optional, default to json)
     * @param emailAddress An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: &#x60;http://example.com/v1/structures?email_address&#x3D;user@example.com&#x60; (optional, default to )
     * @param responseFields A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: &#x60;http://example.com/v1/structures?response_fields&#x3D;last_modified,nsites&#x60; (optional, default to )
     * @param include A server MAY implement the JSON API concept of returning [compound documents](https://jsonapi.org/format/1.0/#document-compound-documents) by utilizing the &#x60;include&#x60; query parameter as specified by [JSON API 1.0](https://jsonapi.org/format/1.0/#fetching-includes).  All related resource objects MUST be returned as part of an array value for the top-level &#x60;included&#x60; field, see the section JSON Response Schema: Common Fields.  The value of &#x60;include&#x60; MUST be a comma-separated list of \&quot;relationship paths\&quot;, as defined in the [JSON API](https://jsonapi.org/format/1.0/#fetching-includes). If relationship paths are not supported, or a server is unable to identify a relationship path a &#x60;400 Bad Request&#x60; response MUST be made.  The **default value** for &#x60;include&#x60; is &#x60;references&#x60;. This means &#x60;references&#x60; entries MUST always be included under the top-level field &#x60;included&#x60; as default, since a server assumes if &#x60;include&#x60; is not specified by a client in the request, it is still specified as &#x60;include&#x3D;references&#x60;. Note, if a client explicitly specifies &#x60;include&#x60; and leaves out &#x60;references&#x60;, &#x60;references&#x60; resource objects MUST NOT be included under the top-level field &#x60;included&#x60;, as per the definition of &#x60;included&#x60;, see section JSON Response Schema: Common Fields.  &gt; **Note**: A query with the parameter &#x60;include&#x60; set to the empty string means no related resource objects are to be returned under the top-level field &#x60;included&#x60;. (optional, default to references)
     * @param apiHint If the client provides the parameter, the value SHOULD have the format &#x60;vMAJOR&#x60; or &#x60;vMAJOR.MINOR&#x60;, where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends &#x60;api_hint&#x3D;v1.0&#x60; to the query string, the hint provided is for major version 1 and minor version 0. (optional, default to )
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal Server Error </td><td>  -  </td></tr>
        <tr><td> 501 </td><td> Not Implemented </td><td>  -  </td></tr>
        <tr><td> 553 </td><td> Version Not Supported </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSingleReferenceReferencesEntryIdGetAsync(String entryId, String responseFormat, String emailAddress, String responseFields, String include, String apiHint, final ApiCallback<ReferenceResponseOne> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSingleReferenceReferencesEntryIdGetValidateBeforeCall(entryId, responseFormat, emailAddress, responseFields, include, apiHint, _callback);
        Type localVarReturnType = new TypeToken<ReferenceResponseOne>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
