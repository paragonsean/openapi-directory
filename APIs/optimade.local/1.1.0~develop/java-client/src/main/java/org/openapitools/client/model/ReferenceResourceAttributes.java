/*
 * OPTIMADE API
 * The [Open Databases Integration for Materials Design (OPTIMADE) consortium](https://www.optimade.org/) aims to make materials databases interoperational by developing a common REST API.  This specification is generated using [`optimade-python-tools`](https://github.com/Materials-Consortia/optimade-python-tools/tree/v0.16.0) v0.16.0.
 *
 * The version of the OpenAPI document: 1.1.0~develop
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Person;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Model that stores the attributes of a reference.  Many properties match the meaning described in the [BibTeX specification](http://bibtexml.sourceforge.net/btxdoc.pdf).
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:56:45.612268-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ReferenceResourceAttributes {
  public static final String SERIALIZED_NAME_ADDRESS = "address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  private String address;

  public static final String SERIALIZED_NAME_ANNOTE = "annote";
  @SerializedName(SERIALIZED_NAME_ANNOTE)
  private String annote;

  public static final String SERIALIZED_NAME_AUTHORS = "authors";
  @SerializedName(SERIALIZED_NAME_AUTHORS)
  private List<Person> authors = new ArrayList<>();

  public static final String SERIALIZED_NAME_BIB_TYPE = "bib_type";
  @SerializedName(SERIALIZED_NAME_BIB_TYPE)
  private String bibType;

  public static final String SERIALIZED_NAME_BOOKTITLE = "booktitle";
  @SerializedName(SERIALIZED_NAME_BOOKTITLE)
  private String booktitle;

  public static final String SERIALIZED_NAME_CHAPTER = "chapter";
  @SerializedName(SERIALIZED_NAME_CHAPTER)
  private String chapter;

  public static final String SERIALIZED_NAME_CROSSREF = "crossref";
  @SerializedName(SERIALIZED_NAME_CROSSREF)
  private String crossref;

  public static final String SERIALIZED_NAME_DOI = "doi";
  @SerializedName(SERIALIZED_NAME_DOI)
  private String doi;

  public static final String SERIALIZED_NAME_EDITION = "edition";
  @SerializedName(SERIALIZED_NAME_EDITION)
  private String edition;

  public static final String SERIALIZED_NAME_EDITORS = "editors";
  @SerializedName(SERIALIZED_NAME_EDITORS)
  private List<Person> editors = new ArrayList<>();

  public static final String SERIALIZED_NAME_HOWPUBLISHED = "howpublished";
  @SerializedName(SERIALIZED_NAME_HOWPUBLISHED)
  private String howpublished;

  public static final String SERIALIZED_NAME_IMMUTABLE_ID = "immutable_id";
  @SerializedName(SERIALIZED_NAME_IMMUTABLE_ID)
  private String immutableId;

  public static final String SERIALIZED_NAME_INSTITUTION = "institution";
  @SerializedName(SERIALIZED_NAME_INSTITUTION)
  private String institution;

  public static final String SERIALIZED_NAME_JOURNAL = "journal";
  @SerializedName(SERIALIZED_NAME_JOURNAL)
  private String journal;

  public static final String SERIALIZED_NAME_KEY = "key";
  @SerializedName(SERIALIZED_NAME_KEY)
  private String key;

  public static final String SERIALIZED_NAME_LAST_MODIFIED = "last_modified";
  @SerializedName(SERIALIZED_NAME_LAST_MODIFIED)
  private OffsetDateTime lastModified;

  public static final String SERIALIZED_NAME_MONTH = "month";
  @SerializedName(SERIALIZED_NAME_MONTH)
  private String month;

  public static final String SERIALIZED_NAME_NOTE = "note";
  @SerializedName(SERIALIZED_NAME_NOTE)
  private String note;

  public static final String SERIALIZED_NAME_NUMBER = "number";
  @SerializedName(SERIALIZED_NAME_NUMBER)
  private String number;

  public static final String SERIALIZED_NAME_ORGANIZATION = "organization";
  @SerializedName(SERIALIZED_NAME_ORGANIZATION)
  private String organization;

  public static final String SERIALIZED_NAME_PAGES = "pages";
  @SerializedName(SERIALIZED_NAME_PAGES)
  private String pages;

  public static final String SERIALIZED_NAME_PUBLISHER = "publisher";
  @SerializedName(SERIALIZED_NAME_PUBLISHER)
  private String publisher;

  public static final String SERIALIZED_NAME_SCHOOL = "school";
  @SerializedName(SERIALIZED_NAME_SCHOOL)
  private String school;

  public static final String SERIALIZED_NAME_SERIES = "series";
  @SerializedName(SERIALIZED_NAME_SERIES)
  private String series;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private URI url;

  public static final String SERIALIZED_NAME_VOLUME = "volume";
  @SerializedName(SERIALIZED_NAME_VOLUME)
  private String volume;

  public static final String SERIALIZED_NAME_YEAR = "year";
  @SerializedName(SERIALIZED_NAME_YEAR)
  private String year;

  public ReferenceResourceAttributes() {
  }

  public ReferenceResourceAttributes address(String address) {
    this.address = address;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return address
   */
  @javax.annotation.Nullable
  public String getAddress() {
    return address;
  }

  public void setAddress(String address) {
    this.address = address;
  }


  public ReferenceResourceAttributes annote(String annote) {
    this.annote = annote;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return annote
   */
  @javax.annotation.Nullable
  public String getAnnote() {
    return annote;
  }

  public void setAnnote(String annote) {
    this.annote = annote;
  }


  public ReferenceResourceAttributes authors(List<Person> authors) {
    this.authors = authors;
    return this;
  }

  public ReferenceResourceAttributes addAuthorsItem(Person authorsItem) {
    if (this.authors == null) {
      this.authors = new ArrayList<>();
    }
    this.authors.add(authorsItem);
    return this;
  }

  /**
   * List of person objects containing the authors of the reference.
   * @return authors
   */
  @javax.annotation.Nullable
  public List<Person> getAuthors() {
    return authors;
  }

  public void setAuthors(List<Person> authors) {
    this.authors = authors;
  }


  public ReferenceResourceAttributes bibType(String bibType) {
    this.bibType = bibType;
    return this;
  }

  /**
   * Type of the reference, corresponding to the **type** property in the BiBTeX specification.
   * @return bibType
   */
  @javax.annotation.Nullable
  public String getBibType() {
    return bibType;
  }

  public void setBibType(String bibType) {
    this.bibType = bibType;
  }


  public ReferenceResourceAttributes booktitle(String booktitle) {
    this.booktitle = booktitle;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return booktitle
   */
  @javax.annotation.Nullable
  public String getBooktitle() {
    return booktitle;
  }

  public void setBooktitle(String booktitle) {
    this.booktitle = booktitle;
  }


  public ReferenceResourceAttributes chapter(String chapter) {
    this.chapter = chapter;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return chapter
   */
  @javax.annotation.Nullable
  public String getChapter() {
    return chapter;
  }

  public void setChapter(String chapter) {
    this.chapter = chapter;
  }


  public ReferenceResourceAttributes crossref(String crossref) {
    this.crossref = crossref;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return crossref
   */
  @javax.annotation.Nullable
  public String getCrossref() {
    return crossref;
  }

  public void setCrossref(String crossref) {
    this.crossref = crossref;
  }


  public ReferenceResourceAttributes doi(String doi) {
    this.doi = doi;
    return this;
  }

  /**
   * The digital object identifier of the reference.
   * @return doi
   */
  @javax.annotation.Nullable
  public String getDoi() {
    return doi;
  }

  public void setDoi(String doi) {
    this.doi = doi;
  }


  public ReferenceResourceAttributes edition(String edition) {
    this.edition = edition;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return edition
   */
  @javax.annotation.Nullable
  public String getEdition() {
    return edition;
  }

  public void setEdition(String edition) {
    this.edition = edition;
  }


  public ReferenceResourceAttributes editors(List<Person> editors) {
    this.editors = editors;
    return this;
  }

  public ReferenceResourceAttributes addEditorsItem(Person editorsItem) {
    if (this.editors == null) {
      this.editors = new ArrayList<>();
    }
    this.editors.add(editorsItem);
    return this;
  }

  /**
   * List of person objects containing the editors of the reference.
   * @return editors
   */
  @javax.annotation.Nullable
  public List<Person> getEditors() {
    return editors;
  }

  public void setEditors(List<Person> editors) {
    this.editors = editors;
  }


  public ReferenceResourceAttributes howpublished(String howpublished) {
    this.howpublished = howpublished;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return howpublished
   */
  @javax.annotation.Nullable
  public String getHowpublished() {
    return howpublished;
  }

  public void setHowpublished(String howpublished) {
    this.howpublished = howpublished;
  }


  public ReferenceResourceAttributes immutableId(String immutableId) {
    this.immutableId = immutableId;
    return this;
  }

  /**
   * The entry&#39;s immutable ID (e.g., an UUID). This is important for databases having preferred IDs that point to \&quot;the latest version\&quot; of a record, but still offer access to older variants. This ID maps to the version-specific record, in case it changes in the future.  - **Type**: string.  - **Requirements/Conventions**:     - **Support**: OPTIONAL support in implementations, i.e., MAY be &#x60;null&#x60;.     - **Query**: MUST be a queryable property with support for all mandatory filter features.  - **Examples**:     - &#x60;\&quot;8bd3e750-b477-41a0-9b11-3a799f21b44f\&quot;&#x60;     - &#x60;\&quot;fjeiwoj,54;@&#x3D;%&lt;&gt;#32\&quot;&#x60; (Strings that are not URL-safe are allowed.)
   * @return immutableId
   */
  @javax.annotation.Nullable
  public String getImmutableId() {
    return immutableId;
  }

  public void setImmutableId(String immutableId) {
    this.immutableId = immutableId;
  }


  public ReferenceResourceAttributes institution(String institution) {
    this.institution = institution;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return institution
   */
  @javax.annotation.Nullable
  public String getInstitution() {
    return institution;
  }

  public void setInstitution(String institution) {
    this.institution = institution;
  }


  public ReferenceResourceAttributes journal(String journal) {
    this.journal = journal;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return journal
   */
  @javax.annotation.Nullable
  public String getJournal() {
    return journal;
  }

  public void setJournal(String journal) {
    this.journal = journal;
  }


  public ReferenceResourceAttributes key(String key) {
    this.key = key;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return key
   */
  @javax.annotation.Nullable
  public String getKey() {
    return key;
  }

  public void setKey(String key) {
    this.key = key;
  }


  public ReferenceResourceAttributes lastModified(OffsetDateTime lastModified) {
    this.lastModified = lastModified;
    return this;
  }

  /**
   * Date and time representing when the entry was last modified.  - **Type**: timestamp.  - **Requirements/Conventions**:     - **Support**: SHOULD be supported by all implementations, i.e., SHOULD NOT be &#x60;null&#x60;.     - **Query**: MUST be a queryable property with support for all mandatory filter features.     - **Response**: REQUIRED in the response unless the query parameter &#x60;response_fields&#x60; is present and does not include this property.  - **Example**:     - As part of JSON response format: &#x60;\&quot;2007-04-05T14:30:20Z\&quot;&#x60; (i.e., encoded as an [RFC 3339 Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6) string.)
   * @return lastModified
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getLastModified() {
    return lastModified;
  }

  public void setLastModified(OffsetDateTime lastModified) {
    this.lastModified = lastModified;
  }


  public ReferenceResourceAttributes month(String month) {
    this.month = month;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return month
   */
  @javax.annotation.Nullable
  public String getMonth() {
    return month;
  }

  public void setMonth(String month) {
    this.month = month;
  }


  public ReferenceResourceAttributes note(String note) {
    this.note = note;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return note
   */
  @javax.annotation.Nullable
  public String getNote() {
    return note;
  }

  public void setNote(String note) {
    this.note = note;
  }


  public ReferenceResourceAttributes number(String number) {
    this.number = number;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return number
   */
  @javax.annotation.Nullable
  public String getNumber() {
    return number;
  }

  public void setNumber(String number) {
    this.number = number;
  }


  public ReferenceResourceAttributes organization(String organization) {
    this.organization = organization;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return organization
   */
  @javax.annotation.Nullable
  public String getOrganization() {
    return organization;
  }

  public void setOrganization(String organization) {
    this.organization = organization;
  }


  public ReferenceResourceAttributes pages(String pages) {
    this.pages = pages;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return pages
   */
  @javax.annotation.Nullable
  public String getPages() {
    return pages;
  }

  public void setPages(String pages) {
    this.pages = pages;
  }


  public ReferenceResourceAttributes publisher(String publisher) {
    this.publisher = publisher;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return publisher
   */
  @javax.annotation.Nullable
  public String getPublisher() {
    return publisher;
  }

  public void setPublisher(String publisher) {
    this.publisher = publisher;
  }


  public ReferenceResourceAttributes school(String school) {
    this.school = school;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return school
   */
  @javax.annotation.Nullable
  public String getSchool() {
    return school;
  }

  public void setSchool(String school) {
    this.school = school;
  }


  public ReferenceResourceAttributes series(String series) {
    this.series = series;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return series
   */
  @javax.annotation.Nullable
  public String getSeries() {
    return series;
  }

  public void setSeries(String series) {
    this.series = series;
  }


  public ReferenceResourceAttributes title(String title) {
    this.title = title;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public ReferenceResourceAttributes url(URI url) {
    this.url = url;
    return this;
  }

  /**
   * The URL of the reference.
   * @return url
   */
  @javax.annotation.Nullable
  public URI getUrl() {
    return url;
  }

  public void setUrl(URI url) {
    this.url = url;
  }


  public ReferenceResourceAttributes volume(String volume) {
    this.volume = volume;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return volume
   */
  @javax.annotation.Nullable
  public String getVolume() {
    return volume;
  }

  public void setVolume(String volume) {
    this.volume = volume;
  }


  public ReferenceResourceAttributes year(String year) {
    this.year = year;
    return this;
  }

  /**
   * Meaning of property matches the BiBTeX specification.
   * @return year
   */
  @javax.annotation.Nullable
  public String getYear() {
    return year;
  }

  public void setYear(String year) {
    this.year = year;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReferenceResourceAttributes referenceResourceAttributes = (ReferenceResourceAttributes) o;
    return Objects.equals(this.address, referenceResourceAttributes.address) &&
        Objects.equals(this.annote, referenceResourceAttributes.annote) &&
        Objects.equals(this.authors, referenceResourceAttributes.authors) &&
        Objects.equals(this.bibType, referenceResourceAttributes.bibType) &&
        Objects.equals(this.booktitle, referenceResourceAttributes.booktitle) &&
        Objects.equals(this.chapter, referenceResourceAttributes.chapter) &&
        Objects.equals(this.crossref, referenceResourceAttributes.crossref) &&
        Objects.equals(this.doi, referenceResourceAttributes.doi) &&
        Objects.equals(this.edition, referenceResourceAttributes.edition) &&
        Objects.equals(this.editors, referenceResourceAttributes.editors) &&
        Objects.equals(this.howpublished, referenceResourceAttributes.howpublished) &&
        Objects.equals(this.immutableId, referenceResourceAttributes.immutableId) &&
        Objects.equals(this.institution, referenceResourceAttributes.institution) &&
        Objects.equals(this.journal, referenceResourceAttributes.journal) &&
        Objects.equals(this.key, referenceResourceAttributes.key) &&
        Objects.equals(this.lastModified, referenceResourceAttributes.lastModified) &&
        Objects.equals(this.month, referenceResourceAttributes.month) &&
        Objects.equals(this.note, referenceResourceAttributes.note) &&
        Objects.equals(this.number, referenceResourceAttributes.number) &&
        Objects.equals(this.organization, referenceResourceAttributes.organization) &&
        Objects.equals(this.pages, referenceResourceAttributes.pages) &&
        Objects.equals(this.publisher, referenceResourceAttributes.publisher) &&
        Objects.equals(this.school, referenceResourceAttributes.school) &&
        Objects.equals(this.series, referenceResourceAttributes.series) &&
        Objects.equals(this.title, referenceResourceAttributes.title) &&
        Objects.equals(this.url, referenceResourceAttributes.url) &&
        Objects.equals(this.volume, referenceResourceAttributes.volume) &&
        Objects.equals(this.year, referenceResourceAttributes.year);
  }

  @Override
  public int hashCode() {
    return Objects.hash(address, annote, authors, bibType, booktitle, chapter, crossref, doi, edition, editors, howpublished, immutableId, institution, journal, key, lastModified, month, note, number, organization, pages, publisher, school, series, title, url, volume, year);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReferenceResourceAttributes {\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    annote: ").append(toIndentedString(annote)).append("\n");
    sb.append("    authors: ").append(toIndentedString(authors)).append("\n");
    sb.append("    bibType: ").append(toIndentedString(bibType)).append("\n");
    sb.append("    booktitle: ").append(toIndentedString(booktitle)).append("\n");
    sb.append("    chapter: ").append(toIndentedString(chapter)).append("\n");
    sb.append("    crossref: ").append(toIndentedString(crossref)).append("\n");
    sb.append("    doi: ").append(toIndentedString(doi)).append("\n");
    sb.append("    edition: ").append(toIndentedString(edition)).append("\n");
    sb.append("    editors: ").append(toIndentedString(editors)).append("\n");
    sb.append("    howpublished: ").append(toIndentedString(howpublished)).append("\n");
    sb.append("    immutableId: ").append(toIndentedString(immutableId)).append("\n");
    sb.append("    institution: ").append(toIndentedString(institution)).append("\n");
    sb.append("    journal: ").append(toIndentedString(journal)).append("\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    lastModified: ").append(toIndentedString(lastModified)).append("\n");
    sb.append("    month: ").append(toIndentedString(month)).append("\n");
    sb.append("    note: ").append(toIndentedString(note)).append("\n");
    sb.append("    number: ").append(toIndentedString(number)).append("\n");
    sb.append("    organization: ").append(toIndentedString(organization)).append("\n");
    sb.append("    pages: ").append(toIndentedString(pages)).append("\n");
    sb.append("    publisher: ").append(toIndentedString(publisher)).append("\n");
    sb.append("    school: ").append(toIndentedString(school)).append("\n");
    sb.append("    series: ").append(toIndentedString(series)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    volume: ").append(toIndentedString(volume)).append("\n");
    sb.append("    year: ").append(toIndentedString(year)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("address");
    openapiFields.add("annote");
    openapiFields.add("authors");
    openapiFields.add("bib_type");
    openapiFields.add("booktitle");
    openapiFields.add("chapter");
    openapiFields.add("crossref");
    openapiFields.add("doi");
    openapiFields.add("edition");
    openapiFields.add("editors");
    openapiFields.add("howpublished");
    openapiFields.add("immutable_id");
    openapiFields.add("institution");
    openapiFields.add("journal");
    openapiFields.add("key");
    openapiFields.add("last_modified");
    openapiFields.add("month");
    openapiFields.add("note");
    openapiFields.add("number");
    openapiFields.add("organization");
    openapiFields.add("pages");
    openapiFields.add("publisher");
    openapiFields.add("school");
    openapiFields.add("series");
    openapiFields.add("title");
    openapiFields.add("url");
    openapiFields.add("volume");
    openapiFields.add("year");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("last_modified");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ReferenceResourceAttributes
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ReferenceResourceAttributes.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ReferenceResourceAttributes is not found in the empty JSON string", ReferenceResourceAttributes.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ReferenceResourceAttributes.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ReferenceResourceAttributes` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ReferenceResourceAttributes.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("address") != null && !jsonObj.get("address").isJsonNull()) && !jsonObj.get("address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("address").toString()));
      }
      if ((jsonObj.get("annote") != null && !jsonObj.get("annote").isJsonNull()) && !jsonObj.get("annote").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `annote` to be a primitive type in the JSON string but got `%s`", jsonObj.get("annote").toString()));
      }
      if (jsonObj.get("authors") != null && !jsonObj.get("authors").isJsonNull()) {
        JsonArray jsonArrayauthors = jsonObj.getAsJsonArray("authors");
        if (jsonArrayauthors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("authors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `authors` to be an array in the JSON string but got `%s`", jsonObj.get("authors").toString()));
          }

          // validate the optional field `authors` (array)
          for (int i = 0; i < jsonArrayauthors.size(); i++) {
            Person.validateJsonElement(jsonArrayauthors.get(i));
          };
        }
      }
      if ((jsonObj.get("bib_type") != null && !jsonObj.get("bib_type").isJsonNull()) && !jsonObj.get("bib_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bib_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bib_type").toString()));
      }
      if ((jsonObj.get("booktitle") != null && !jsonObj.get("booktitle").isJsonNull()) && !jsonObj.get("booktitle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `booktitle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("booktitle").toString()));
      }
      if ((jsonObj.get("chapter") != null && !jsonObj.get("chapter").isJsonNull()) && !jsonObj.get("chapter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chapter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chapter").toString()));
      }
      if ((jsonObj.get("crossref") != null && !jsonObj.get("crossref").isJsonNull()) && !jsonObj.get("crossref").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `crossref` to be a primitive type in the JSON string but got `%s`", jsonObj.get("crossref").toString()));
      }
      if ((jsonObj.get("doi") != null && !jsonObj.get("doi").isJsonNull()) && !jsonObj.get("doi").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `doi` to be a primitive type in the JSON string but got `%s`", jsonObj.get("doi").toString()));
      }
      if ((jsonObj.get("edition") != null && !jsonObj.get("edition").isJsonNull()) && !jsonObj.get("edition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `edition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("edition").toString()));
      }
      if (jsonObj.get("editors") != null && !jsonObj.get("editors").isJsonNull()) {
        JsonArray jsonArrayeditors = jsonObj.getAsJsonArray("editors");
        if (jsonArrayeditors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("editors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `editors` to be an array in the JSON string but got `%s`", jsonObj.get("editors").toString()));
          }

          // validate the optional field `editors` (array)
          for (int i = 0; i < jsonArrayeditors.size(); i++) {
            Person.validateJsonElement(jsonArrayeditors.get(i));
          };
        }
      }
      if ((jsonObj.get("howpublished") != null && !jsonObj.get("howpublished").isJsonNull()) && !jsonObj.get("howpublished").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `howpublished` to be a primitive type in the JSON string but got `%s`", jsonObj.get("howpublished").toString()));
      }
      if ((jsonObj.get("immutable_id") != null && !jsonObj.get("immutable_id").isJsonNull()) && !jsonObj.get("immutable_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `immutable_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("immutable_id").toString()));
      }
      if ((jsonObj.get("institution") != null && !jsonObj.get("institution").isJsonNull()) && !jsonObj.get("institution").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `institution` to be a primitive type in the JSON string but got `%s`", jsonObj.get("institution").toString()));
      }
      if ((jsonObj.get("journal") != null && !jsonObj.get("journal").isJsonNull()) && !jsonObj.get("journal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `journal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("journal").toString()));
      }
      if ((jsonObj.get("key") != null && !jsonObj.get("key").isJsonNull()) && !jsonObj.get("key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key").toString()));
      }
      if ((jsonObj.get("month") != null && !jsonObj.get("month").isJsonNull()) && !jsonObj.get("month").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `month` to be a primitive type in the JSON string but got `%s`", jsonObj.get("month").toString()));
      }
      if ((jsonObj.get("note") != null && !jsonObj.get("note").isJsonNull()) && !jsonObj.get("note").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `note` to be a primitive type in the JSON string but got `%s`", jsonObj.get("note").toString()));
      }
      if ((jsonObj.get("number") != null && !jsonObj.get("number").isJsonNull()) && !jsonObj.get("number").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `number` to be a primitive type in the JSON string but got `%s`", jsonObj.get("number").toString()));
      }
      if ((jsonObj.get("organization") != null && !jsonObj.get("organization").isJsonNull()) && !jsonObj.get("organization").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `organization` to be a primitive type in the JSON string but got `%s`", jsonObj.get("organization").toString()));
      }
      if ((jsonObj.get("pages") != null && !jsonObj.get("pages").isJsonNull()) && !jsonObj.get("pages").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pages` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pages").toString()));
      }
      if ((jsonObj.get("publisher") != null && !jsonObj.get("publisher").isJsonNull()) && !jsonObj.get("publisher").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `publisher` to be a primitive type in the JSON string but got `%s`", jsonObj.get("publisher").toString()));
      }
      if ((jsonObj.get("school") != null && !jsonObj.get("school").isJsonNull()) && !jsonObj.get("school").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `school` to be a primitive type in the JSON string but got `%s`", jsonObj.get("school").toString()));
      }
      if ((jsonObj.get("series") != null && !jsonObj.get("series").isJsonNull()) && !jsonObj.get("series").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `series` to be a primitive type in the JSON string but got `%s`", jsonObj.get("series").toString()));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
      if ((jsonObj.get("url") != null && !jsonObj.get("url").isJsonNull()) && !jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      if ((jsonObj.get("volume") != null && !jsonObj.get("volume").isJsonNull()) && !jsonObj.get("volume").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `volume` to be a primitive type in the JSON string but got `%s`", jsonObj.get("volume").toString()));
      }
      if ((jsonObj.get("year") != null && !jsonObj.get("year").isJsonNull()) && !jsonObj.get("year").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `year` to be a primitive type in the JSON string but got `%s`", jsonObj.get("year").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ReferenceResourceAttributes.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ReferenceResourceAttributes' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ReferenceResourceAttributes> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ReferenceResourceAttributes.class));

       return (TypeAdapter<T>) new TypeAdapter<ReferenceResourceAttributes>() {
           @Override
           public void write(JsonWriter out, ReferenceResourceAttributes value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ReferenceResourceAttributes read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ReferenceResourceAttributes given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ReferenceResourceAttributes
   * @throws IOException if the JSON string is invalid with respect to ReferenceResourceAttributes
   */
  public static ReferenceResourceAttributes fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ReferenceResourceAttributes.class);
  }

  /**
   * Convert an instance of ReferenceResourceAttributes to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

