/*
 * OPTIMADE API
 * The [Open Databases Integration for Materials Design (OPTIMADE) consortium](https://www.optimade.org/) aims to make materials databases interoperational by developing a common REST API.  This specification is generated using [`optimade-python-tools`](https://github.com/Materials-Consortia/optimade-python-tools/tree/v0.16.0) v0.16.0.
 *
 * The version of the OpenAPI document: 1.1.0~develop
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A list describing the species of the sites of this structure.  Species can represent pure chemical elements, virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements, and/or a location to which there are attached atoms, i.e., atoms whose precise location are unknown beyond that they are attached to that position (frequently used to indicate hydrogen atoms attached to another element, e.g., a carbon with three attached hydrogens might represent a methyl group, -CH3).  - **Examples**:     - &#x60;[ {\&quot;name\&quot;: \&quot;Ti\&quot;, \&quot;chemical_symbols\&quot;: [\&quot;Ti\&quot;], \&quot;concentration\&quot;: [1.0]} ]&#x60;: any site with this species is occupied by a Ti atom.     - &#x60;[ {\&quot;name\&quot;: \&quot;Ti\&quot;, \&quot;chemical_symbols\&quot;: [\&quot;Ti\&quot;, \&quot;vacancy\&quot;], \&quot;concentration\&quot;: [0.9, 0.1]} ]&#x60;: any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability.     - &#x60;[ {\&quot;name\&quot;: \&quot;BaCa\&quot;, \&quot;chemical_symbols\&quot;: [\&quot;vacancy\&quot;, \&quot;Ba\&quot;, \&quot;Ca\&quot;], \&quot;concentration\&quot;: [0.05, 0.45, 0.5], \&quot;mass\&quot;: [0.0, 137.327, 40.078]} ]&#x60;: any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u.     - &#x60;[ {\&quot;name\&quot;: \&quot;C12\&quot;, \&quot;chemical_symbols\&quot;: [\&quot;C\&quot;], \&quot;concentration\&quot;: [1.0], \&quot;mass\&quot;: [12.0]} ]&#x60;: any site with this species is occupied by a carbon isotope with mass 12.     - &#x60;[ {\&quot;name\&quot;: \&quot;C13\&quot;, \&quot;chemical_symbols\&quot;: [\&quot;C\&quot;], \&quot;concentration\&quot;: [1.0], \&quot;mass\&quot;: [13.0]} ]&#x60;: any site with this species is occupied by a carbon isotope with mass 13.     - &#x60;[ {\&quot;name\&quot;: \&quot;CH3\&quot;, \&quot;chemical_symbols\&quot;: [\&quot;C\&quot;], \&quot;concentration\&quot;: [1.0], \&quot;attached\&quot;: [\&quot;H\&quot;], \&quot;nattached\&quot;: [3]} ]&#x60;: any site with this species is occupied by a methyl group, -CH3, which is represented without specifying precise positions of the hydrogen atoms.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:56:45.612268-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Species {
  public static final String SERIALIZED_NAME_ATTACHED = "attached";
  @SerializedName(SERIALIZED_NAME_ATTACHED)
  private List<String> attached = new ArrayList<>();

  public static final String SERIALIZED_NAME_CHEMICAL_SYMBOLS = "chemical_symbols";
  @SerializedName(SERIALIZED_NAME_CHEMICAL_SYMBOLS)
  private List<String> chemicalSymbols = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONCENTRATION = "concentration";
  @SerializedName(SERIALIZED_NAME_CONCENTRATION)
  private List<BigDecimal> concentration = new ArrayList<>();

  public static final String SERIALIZED_NAME_MASS = "mass";
  @SerializedName(SERIALIZED_NAME_MASS)
  private List<BigDecimal> mass = new ArrayList<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NATTACHED = "nattached";
  @SerializedName(SERIALIZED_NAME_NATTACHED)
  private List<Integer> nattached = new ArrayList<>();

  public static final String SERIALIZED_NAME_ORIGINAL_NAME = "original_name";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_NAME)
  private String originalName;

  public Species() {
  }

  public Species attached(List<String> attached) {
    this.attached = attached;
    return this;
  }

  public Species addAttachedItem(String attachedItem) {
    if (this.attached == null) {
      this.attached = new ArrayList<>();
    }
    this.attached.add(attachedItem);
    return this;
  }

  /**
   * If provided MUST be a list of length 1 or more of strings of chemical symbols for the elements attached to this site, or \&quot;X\&quot; for a non-chemical element.
   * @return attached
   */
  @javax.annotation.Nullable
  public List<String> getAttached() {
    return attached;
  }

  public void setAttached(List<String> attached) {
    this.attached = attached;
  }


  public Species chemicalSymbols(List<String> chemicalSymbols) {
    this.chemicalSymbols = chemicalSymbols;
    return this;
  }

  public Species addChemicalSymbolsItem(String chemicalSymbolsItem) {
    if (this.chemicalSymbols == null) {
      this.chemicalSymbols = new ArrayList<>();
    }
    this.chemicalSymbols.add(chemicalSymbolsItem);
    return this;
  }

  /**
   * MUST be a list of strings of all chemical elements composing this species. Each item of the list MUST be one of the following:  - a valid chemical-element name, or - the special value &#x60;\&quot;X\&quot;&#x60; to represent a non-chemical element, or - the special value &#x60;\&quot;vacancy\&quot;&#x60; to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the &#x60;concentration&#x60; list, see below).  If any one entry in the &#x60;species&#x60; list has a &#x60;chemical_symbols&#x60; list that is longer than 1 element, the correct flag MUST be set in the list &#x60;structure_features&#x60;.
   * @return chemicalSymbols
   */
  @javax.annotation.Nonnull
  public List<String> getChemicalSymbols() {
    return chemicalSymbols;
  }

  public void setChemicalSymbols(List<String> chemicalSymbols) {
    this.chemicalSymbols = chemicalSymbols;
  }


  public Species concentration(List<BigDecimal> concentration) {
    this.concentration = concentration;
    return this;
  }

  public Species addConcentrationItem(BigDecimal concentrationItem) {
    if (this.concentration == null) {
      this.concentration = new ArrayList<>();
    }
    this.concentration.add(concentrationItem);
    return this;
  }

  /**
   * MUST be a list of floats, with same length as &#x60;chemical_symbols&#x60;. The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories:  - Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations &#x60;1/3&#x60; and &#x60;2/3&#x60;, the concentration might look something like &#x60;[0.33333333333, 0.66666666666]&#x60;. If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. - Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data.  Note that concentrations are uncorrelated between different site (even of the same species).
   * @return concentration
   */
  @javax.annotation.Nonnull
  public List<BigDecimal> getConcentration() {
    return concentration;
  }

  public void setConcentration(List<BigDecimal> concentration) {
    this.concentration = concentration;
  }


  public Species mass(List<BigDecimal> mass) {
    this.mass = mass;
    return this;
  }

  public Species addMassItem(BigDecimal massItem) {
    if (this.mass == null) {
      this.mass = new ArrayList<>();
    }
    this.mass.add(massItem);
    return this;
  }

  /**
   * If present MUST be a list of floats expressed in a.m.u. Elements denoting vacancies MUST have masses equal to 0.
   * @return mass
   */
  @javax.annotation.Nullable
  public List<BigDecimal> getMass() {
    return mass;
  }

  public void setMass(List<BigDecimal> mass) {
    this.mass = mass;
  }


  public Species name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Gives the name of the species; the **name** value MUST be unique in the &#x60;species&#x60; list.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Species nattached(List<Integer> nattached) {
    this.nattached = nattached;
    return this;
  }

  public Species addNattachedItem(Integer nattachedItem) {
    if (this.nattached == null) {
      this.nattached = new ArrayList<>();
    }
    this.nattached.add(nattachedItem);
    return this;
  }

  /**
   * If provided MUST be a list of length 1 or more of integers indicating the number of attached atoms of the kind specified in the value of the :field:&#x60;attached&#x60; key.
   * @return nattached
   */
  @javax.annotation.Nullable
  public List<Integer> getNattached() {
    return nattached;
  }

  public void setNattached(List<Integer> nattached) {
    this.nattached = nattached;
  }


  public Species originalName(String originalName) {
    this.originalName = originalName;
    return this;
  }

  /**
   * Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database.  Note: With regards to \&quot;source database\&quot;, we refer to the immediate source being queried via the OPTIMADE API implementation.
   * @return originalName
   */
  @javax.annotation.Nullable
  public String getOriginalName() {
    return originalName;
  }

  public void setOriginalName(String originalName) {
    this.originalName = originalName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Species species = (Species) o;
    return Objects.equals(this.attached, species.attached) &&
        Objects.equals(this.chemicalSymbols, species.chemicalSymbols) &&
        Objects.equals(this.concentration, species.concentration) &&
        Objects.equals(this.mass, species.mass) &&
        Objects.equals(this.name, species.name) &&
        Objects.equals(this.nattached, species.nattached) &&
        Objects.equals(this.originalName, species.originalName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(attached, chemicalSymbols, concentration, mass, name, nattached, originalName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Species {\n");
    sb.append("    attached: ").append(toIndentedString(attached)).append("\n");
    sb.append("    chemicalSymbols: ").append(toIndentedString(chemicalSymbols)).append("\n");
    sb.append("    concentration: ").append(toIndentedString(concentration)).append("\n");
    sb.append("    mass: ").append(toIndentedString(mass)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nattached: ").append(toIndentedString(nattached)).append("\n");
    sb.append("    originalName: ").append(toIndentedString(originalName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("attached");
    openapiFields.add("chemical_symbols");
    openapiFields.add("concentration");
    openapiFields.add("mass");
    openapiFields.add("name");
    openapiFields.add("nattached");
    openapiFields.add("original_name");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("chemical_symbols");
    openapiRequiredFields.add("concentration");
    openapiRequiredFields.add("name");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Species
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Species.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Species is not found in the empty JSON string", Species.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Species.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Species` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Species.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("attached") != null && !jsonObj.get("attached").isJsonNull() && !jsonObj.get("attached").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `attached` to be an array in the JSON string but got `%s`", jsonObj.get("attached").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("chemical_symbols") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("chemical_symbols").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `chemical_symbols` to be an array in the JSON string but got `%s`", jsonObj.get("chemical_symbols").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("concentration") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("concentration").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `concentration` to be an array in the JSON string but got `%s`", jsonObj.get("concentration").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("mass") != null && !jsonObj.get("mass").isJsonNull() && !jsonObj.get("mass").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `mass` to be an array in the JSON string but got `%s`", jsonObj.get("mass").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("nattached") != null && !jsonObj.get("nattached").isJsonNull() && !jsonObj.get("nattached").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `nattached` to be an array in the JSON string but got `%s`", jsonObj.get("nattached").toString()));
      }
      if ((jsonObj.get("original_name") != null && !jsonObj.get("original_name").isJsonNull()) && !jsonObj.get("original_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `original_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("original_name").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Species.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Species' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Species> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Species.class));

       return (TypeAdapter<T>) new TypeAdapter<Species>() {
           @Override
           public void write(JsonWriter out, Species value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Species read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Species given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Species
   * @throws IOException if the JSON string is invalid with respect to Species
   */
  public static Species fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Species.class);
  }

  /**
   * Convert an instance of Species to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

