/**
 * Anchore Engine API Server
 * This is the Anchore Engine API. Provides the primary external API for users of the service.
 *
 * The version of the OpenAPI document: 0.1.20
 * Contact: nurmi@anchore.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVulnerability.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVulnerability::OAIVulnerability(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVulnerability::OAIVulnerability() {
    this->initializeModel();
}

OAIVulnerability::~OAIVulnerability() {}

void OAIVulnerability::initializeModel() {

    m_feed_isSet = false;
    m_feed_isValid = false;

    m_feed_group_isSet = false;
    m_feed_group_isValid = false;

    m_fix_isSet = false;
    m_fix_isValid = false;

    m_nvd_data_isSet = false;
    m_nvd_data_isValid = false;

    m_package_isSet = false;
    m_package_isValid = false;

    m_package_cpe_isSet = false;
    m_package_cpe_isValid = false;

    m_package_name_isSet = false;
    m_package_name_isValid = false;

    m_package_path_isSet = false;
    m_package_path_isValid = false;

    m_package_type_isSet = false;
    m_package_type_isValid = false;

    m_package_version_isSet = false;
    m_package_version_isValid = false;

    m_severity_isSet = false;
    m_severity_isValid = false;

    m_url_isSet = false;
    m_url_isValid = false;

    m_vendor_data_isSet = false;
    m_vendor_data_isValid = false;

    m_vuln_isSet = false;
    m_vuln_isValid = false;

    m_will_not_fix_isSet = false;
    m_will_not_fix_isValid = false;
}

void OAIVulnerability::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVulnerability::fromJsonObject(QJsonObject json) {

    m_feed_isValid = ::OpenAPI::fromJsonValue(m_feed, json[QString("feed")]);
    m_feed_isSet = !json[QString("feed")].isNull() && m_feed_isValid;

    m_feed_group_isValid = ::OpenAPI::fromJsonValue(m_feed_group, json[QString("feed_group")]);
    m_feed_group_isSet = !json[QString("feed_group")].isNull() && m_feed_group_isValid;

    m_fix_isValid = ::OpenAPI::fromJsonValue(m_fix, json[QString("fix")]);
    m_fix_isSet = !json[QString("fix")].isNull() && m_fix_isValid;

    m_nvd_data_isValid = ::OpenAPI::fromJsonValue(m_nvd_data, json[QString("nvd_data")]);
    m_nvd_data_isSet = !json[QString("nvd_data")].isNull() && m_nvd_data_isValid;

    m_package_isValid = ::OpenAPI::fromJsonValue(m_package, json[QString("package")]);
    m_package_isSet = !json[QString("package")].isNull() && m_package_isValid;

    m_package_cpe_isValid = ::OpenAPI::fromJsonValue(m_package_cpe, json[QString("package_cpe")]);
    m_package_cpe_isSet = !json[QString("package_cpe")].isNull() && m_package_cpe_isValid;

    m_package_name_isValid = ::OpenAPI::fromJsonValue(m_package_name, json[QString("package_name")]);
    m_package_name_isSet = !json[QString("package_name")].isNull() && m_package_name_isValid;

    m_package_path_isValid = ::OpenAPI::fromJsonValue(m_package_path, json[QString("package_path")]);
    m_package_path_isSet = !json[QString("package_path")].isNull() && m_package_path_isValid;

    m_package_type_isValid = ::OpenAPI::fromJsonValue(m_package_type, json[QString("package_type")]);
    m_package_type_isSet = !json[QString("package_type")].isNull() && m_package_type_isValid;

    m_package_version_isValid = ::OpenAPI::fromJsonValue(m_package_version, json[QString("package_version")]);
    m_package_version_isSet = !json[QString("package_version")].isNull() && m_package_version_isValid;

    m_severity_isValid = ::OpenAPI::fromJsonValue(m_severity, json[QString("severity")]);
    m_severity_isSet = !json[QString("severity")].isNull() && m_severity_isValid;

    m_url_isValid = ::OpenAPI::fromJsonValue(m_url, json[QString("url")]);
    m_url_isSet = !json[QString("url")].isNull() && m_url_isValid;

    m_vendor_data_isValid = ::OpenAPI::fromJsonValue(m_vendor_data, json[QString("vendor_data")]);
    m_vendor_data_isSet = !json[QString("vendor_data")].isNull() && m_vendor_data_isValid;

    m_vuln_isValid = ::OpenAPI::fromJsonValue(m_vuln, json[QString("vuln")]);
    m_vuln_isSet = !json[QString("vuln")].isNull() && m_vuln_isValid;

    m_will_not_fix_isValid = ::OpenAPI::fromJsonValue(m_will_not_fix, json[QString("will_not_fix")]);
    m_will_not_fix_isSet = !json[QString("will_not_fix")].isNull() && m_will_not_fix_isValid;
}

QString OAIVulnerability::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVulnerability::asJsonObject() const {
    QJsonObject obj;
    if (m_feed_isSet) {
        obj.insert(QString("feed"), ::OpenAPI::toJsonValue(m_feed));
    }
    if (m_feed_group_isSet) {
        obj.insert(QString("feed_group"), ::OpenAPI::toJsonValue(m_feed_group));
    }
    if (m_fix_isSet) {
        obj.insert(QString("fix"), ::OpenAPI::toJsonValue(m_fix));
    }
    if (m_nvd_data.size() > 0) {
        obj.insert(QString("nvd_data"), ::OpenAPI::toJsonValue(m_nvd_data));
    }
    if (m_package_isSet) {
        obj.insert(QString("package"), ::OpenAPI::toJsonValue(m_package));
    }
    if (m_package_cpe_isSet) {
        obj.insert(QString("package_cpe"), ::OpenAPI::toJsonValue(m_package_cpe));
    }
    if (m_package_name_isSet) {
        obj.insert(QString("package_name"), ::OpenAPI::toJsonValue(m_package_name));
    }
    if (m_package_path_isSet) {
        obj.insert(QString("package_path"), ::OpenAPI::toJsonValue(m_package_path));
    }
    if (m_package_type_isSet) {
        obj.insert(QString("package_type"), ::OpenAPI::toJsonValue(m_package_type));
    }
    if (m_package_version_isSet) {
        obj.insert(QString("package_version"), ::OpenAPI::toJsonValue(m_package_version));
    }
    if (m_severity_isSet) {
        obj.insert(QString("severity"), ::OpenAPI::toJsonValue(m_severity));
    }
    if (m_url_isSet) {
        obj.insert(QString("url"), ::OpenAPI::toJsonValue(m_url));
    }
    if (m_vendor_data.size() > 0) {
        obj.insert(QString("vendor_data"), ::OpenAPI::toJsonValue(m_vendor_data));
    }
    if (m_vuln_isSet) {
        obj.insert(QString("vuln"), ::OpenAPI::toJsonValue(m_vuln));
    }
    if (m_will_not_fix_isSet) {
        obj.insert(QString("will_not_fix"), ::OpenAPI::toJsonValue(m_will_not_fix));
    }
    return obj;
}

QString OAIVulnerability::getFeed() const {
    return m_feed;
}
void OAIVulnerability::setFeed(const QString &feed) {
    m_feed = feed;
    m_feed_isSet = true;
}

bool OAIVulnerability::is_feed_Set() const{
    return m_feed_isSet;
}

bool OAIVulnerability::is_feed_Valid() const{
    return m_feed_isValid;
}

QString OAIVulnerability::getFeedGroup() const {
    return m_feed_group;
}
void OAIVulnerability::setFeedGroup(const QString &feed_group) {
    m_feed_group = feed_group;
    m_feed_group_isSet = true;
}

bool OAIVulnerability::is_feed_group_Set() const{
    return m_feed_group_isSet;
}

bool OAIVulnerability::is_feed_group_Valid() const{
    return m_feed_group_isValid;
}

QString OAIVulnerability::getFix() const {
    return m_fix;
}
void OAIVulnerability::setFix(const QString &fix) {
    m_fix = fix;
    m_fix_isSet = true;
}

bool OAIVulnerability::is_fix_Set() const{
    return m_fix_isSet;
}

bool OAIVulnerability::is_fix_Valid() const{
    return m_fix_isValid;
}

QList<OAINvdDataObject> OAIVulnerability::getNvdData() const {
    return m_nvd_data;
}
void OAIVulnerability::setNvdData(const QList<OAINvdDataObject> &nvd_data) {
    m_nvd_data = nvd_data;
    m_nvd_data_isSet = true;
}

bool OAIVulnerability::is_nvd_data_Set() const{
    return m_nvd_data_isSet;
}

bool OAIVulnerability::is_nvd_data_Valid() const{
    return m_nvd_data_isValid;
}

QString OAIVulnerability::getPackage() const {
    return m_package;
}
void OAIVulnerability::setPackage(const QString &package) {
    m_package = package;
    m_package_isSet = true;
}

bool OAIVulnerability::is_package_Set() const{
    return m_package_isSet;
}

bool OAIVulnerability::is_package_Valid() const{
    return m_package_isValid;
}

QString OAIVulnerability::getPackageCpe() const {
    return m_package_cpe;
}
void OAIVulnerability::setPackageCpe(const QString &package_cpe) {
    m_package_cpe = package_cpe;
    m_package_cpe_isSet = true;
}

bool OAIVulnerability::is_package_cpe_Set() const{
    return m_package_cpe_isSet;
}

bool OAIVulnerability::is_package_cpe_Valid() const{
    return m_package_cpe_isValid;
}

QString OAIVulnerability::getPackageName() const {
    return m_package_name;
}
void OAIVulnerability::setPackageName(const QString &package_name) {
    m_package_name = package_name;
    m_package_name_isSet = true;
}

bool OAIVulnerability::is_package_name_Set() const{
    return m_package_name_isSet;
}

bool OAIVulnerability::is_package_name_Valid() const{
    return m_package_name_isValid;
}

QString OAIVulnerability::getPackagePath() const {
    return m_package_path;
}
void OAIVulnerability::setPackagePath(const QString &package_path) {
    m_package_path = package_path;
    m_package_path_isSet = true;
}

bool OAIVulnerability::is_package_path_Set() const{
    return m_package_path_isSet;
}

bool OAIVulnerability::is_package_path_Valid() const{
    return m_package_path_isValid;
}

QString OAIVulnerability::getPackageType() const {
    return m_package_type;
}
void OAIVulnerability::setPackageType(const QString &package_type) {
    m_package_type = package_type;
    m_package_type_isSet = true;
}

bool OAIVulnerability::is_package_type_Set() const{
    return m_package_type_isSet;
}

bool OAIVulnerability::is_package_type_Valid() const{
    return m_package_type_isValid;
}

QString OAIVulnerability::getPackageVersion() const {
    return m_package_version;
}
void OAIVulnerability::setPackageVersion(const QString &package_version) {
    m_package_version = package_version;
    m_package_version_isSet = true;
}

bool OAIVulnerability::is_package_version_Set() const{
    return m_package_version_isSet;
}

bool OAIVulnerability::is_package_version_Valid() const{
    return m_package_version_isValid;
}

QString OAIVulnerability::getSeverity() const {
    return m_severity;
}
void OAIVulnerability::setSeverity(const QString &severity) {
    m_severity = severity;
    m_severity_isSet = true;
}

bool OAIVulnerability::is_severity_Set() const{
    return m_severity_isSet;
}

bool OAIVulnerability::is_severity_Valid() const{
    return m_severity_isValid;
}

QString OAIVulnerability::getUrl() const {
    return m_url;
}
void OAIVulnerability::setUrl(const QString &url) {
    m_url = url;
    m_url_isSet = true;
}

bool OAIVulnerability::is_url_Set() const{
    return m_url_isSet;
}

bool OAIVulnerability::is_url_Valid() const{
    return m_url_isValid;
}

QList<OAIVendorDataObject> OAIVulnerability::getVendorData() const {
    return m_vendor_data;
}
void OAIVulnerability::setVendorData(const QList<OAIVendorDataObject> &vendor_data) {
    m_vendor_data = vendor_data;
    m_vendor_data_isSet = true;
}

bool OAIVulnerability::is_vendor_data_Set() const{
    return m_vendor_data_isSet;
}

bool OAIVulnerability::is_vendor_data_Valid() const{
    return m_vendor_data_isValid;
}

QString OAIVulnerability::getVuln() const {
    return m_vuln;
}
void OAIVulnerability::setVuln(const QString &vuln) {
    m_vuln = vuln;
    m_vuln_isSet = true;
}

bool OAIVulnerability::is_vuln_Set() const{
    return m_vuln_isSet;
}

bool OAIVulnerability::is_vuln_Valid() const{
    return m_vuln_isValid;
}

bool OAIVulnerability::isWillNotFix() const {
    return m_will_not_fix;
}
void OAIVulnerability::setWillNotFix(const bool &will_not_fix) {
    m_will_not_fix = will_not_fix;
    m_will_not_fix_isSet = true;
}

bool OAIVulnerability::is_will_not_fix_Set() const{
    return m_will_not_fix_isSet;
}

bool OAIVulnerability::is_will_not_fix_Valid() const{
    return m_will_not_fix_isValid;
}

bool OAIVulnerability::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_feed_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_feed_group_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_fix_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_nvd_data.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_cpe_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_package_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_severity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_vendor_data.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_vuln_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_will_not_fix_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVulnerability::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
