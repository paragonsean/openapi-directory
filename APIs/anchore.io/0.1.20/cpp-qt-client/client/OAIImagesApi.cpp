/**
 * Anchore Engine API Server
 * This is the Anchore Engine API. Provides the primary external API for users of the service.
 *
 * The version of the OpenAPI document: 0.1.20
 * Contact: nurmi@anchore.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIImagesApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIImagesApi::OAIImagesApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIImagesApi::~OAIImagesApi() {
}

void OAIImagesApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    defaultConf.append(OAIServerConfiguration(
    QUrl("http://anchore.local"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("addImage", defaultConf);
    _serverIndices.insert("addImage", 0);
    _serverConfigs.insert("deleteImage", defaultConf);
    _serverIndices.insert("deleteImage", 0);
    _serverConfigs.insert("deleteImageByImageId", defaultConf);
    _serverIndices.insert("deleteImageByImageId", 0);
    _serverConfigs.insert("deleteImagesAsync", defaultConf);
    _serverIndices.insert("deleteImagesAsync", 0);
    _serverConfigs.insert("getImage", defaultConf);
    _serverIndices.insert("getImage", 0);
    _serverConfigs.insert("getImageByImageId", defaultConf);
    _serverIndices.insert("getImageByImageId", 0);
    _serverConfigs.insert("getImageContentByType", defaultConf);
    _serverIndices.insert("getImageContentByType", 0);
    _serverConfigs.insert("getImageContentByTypeFiles", defaultConf);
    _serverIndices.insert("getImageContentByTypeFiles", 0);
    _serverConfigs.insert("getImageContentByTypeImageId", defaultConf);
    _serverIndices.insert("getImageContentByTypeImageId", 0);
    _serverConfigs.insert("getImageContentByTypeImageIdFiles", defaultConf);
    _serverIndices.insert("getImageContentByTypeImageIdFiles", 0);
    _serverConfigs.insert("getImageContentByTypeImageIdJavapackage", defaultConf);
    _serverIndices.insert("getImageContentByTypeImageIdJavapackage", 0);
    _serverConfigs.insert("getImageContentByTypeJavapackage", defaultConf);
    _serverIndices.insert("getImageContentByTypeJavapackage", 0);
    _serverConfigs.insert("getImageContentByTypeMalware", defaultConf);
    _serverIndices.insert("getImageContentByTypeMalware", 0);
    _serverConfigs.insert("getImageMetadataByType", defaultConf);
    _serverIndices.insert("getImageMetadataByType", 0);
    _serverConfigs.insert("getImagePolicyCheck", defaultConf);
    _serverIndices.insert("getImagePolicyCheck", 0);
    _serverConfigs.insert("getImagePolicyCheckByImageId", defaultConf);
    _serverIndices.insert("getImagePolicyCheckByImageId", 0);
    _serverConfigs.insert("getImageSbomNative", defaultConf);
    _serverIndices.insert("getImageSbomNative", 0);
    _serverConfigs.insert("getImageVulnerabilitiesByType", defaultConf);
    _serverIndices.insert("getImageVulnerabilitiesByType", 0);
    _serverConfigs.insert("getImageVulnerabilitiesByTypeImageId", defaultConf);
    _serverIndices.insert("getImageVulnerabilitiesByTypeImageId", 0);
    _serverConfigs.insert("getImageVulnerabilityTypes", defaultConf);
    _serverIndices.insert("getImageVulnerabilityTypes", 0);
    _serverConfigs.insert("getImageVulnerabilityTypesByImageId", defaultConf);
    _serverIndices.insert("getImageVulnerabilityTypesByImageId", 0);
    _serverConfigs.insert("listImageContent", defaultConf);
    _serverIndices.insert("listImageContent", 0);
    _serverConfigs.insert("listImageContentByImageid", defaultConf);
    _serverIndices.insert("listImageContentByImageid", 0);
    _serverConfigs.insert("listImageMetadata", defaultConf);
    _serverIndices.insert("listImageMetadata", 0);
    _serverConfigs.insert("listImages", defaultConf);
    _serverIndices.insert("listImages", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIImagesApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIImagesApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIImagesApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIImagesApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIImagesApi::setUsername(const QString &username) {
    _username = username;
}

void OAIImagesApi::setPassword(const QString &password) {
    _password = password;
}


void OAIImagesApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIImagesApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIImagesApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIImagesApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIImagesApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIImagesApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIImagesApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIImagesApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIImagesApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIImagesApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIImagesApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIImagesApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIImagesApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIImagesApi::addImage(const OAIImageAnalysisRequest &oai_image_analysis_request, const ::OpenAPI::OptionalParam<bool> &force, const ::OpenAPI::OptionalParam<bool> &autosubscribe, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["addImage"][_serverIndices.value("addImage")].URL()+"/images");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (force.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "force", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("force")).append(querySuffix).append(QUrl::toPercentEncoding(force.stringValue()));
    }
    if (autosubscribe.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "autosubscribe", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("autosubscribe")).append(querySuffix).append(QUrl::toPercentEncoding(autosubscribe.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_image_analysis_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::addImageCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::addImageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIAnchoreImage> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIAnchoreImage val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT addImageSignal(output);
        Q_EMIT addImageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT addImageSignalE(output, error_type, error_str);
        Q_EMIT addImageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT addImageSignalError(output, error_type, error_str);
        Q_EMIT addImageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::deleteImage(const QString &image_digest, const ::OpenAPI::OptionalParam<bool> &force, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["deleteImage"][_serverIndices.value("deleteImage")].URL()+"/images/{imageDigest}");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (force.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "force", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("force")).append(querySuffix).append(QUrl::toPercentEncoding(force.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::deleteImageCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::deleteImageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDeleteImageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteImageSignal(output);
        Q_EMIT deleteImageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteImageSignalE(output, error_type, error_str);
        Q_EMIT deleteImageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteImageSignalError(output, error_type, error_str);
        Q_EMIT deleteImageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::deleteImageByImageId(const QString &image_id, const ::OpenAPI::OptionalParam<bool> &force, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["deleteImageByImageId"][_serverIndices.value("deleteImageByImageId")].URL()+"/images/by_id/{imageId}");
    
    
    {
        QString image_idPathParam("{");
        image_idPathParam.append("imageId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageId"+pathSuffix : pathPrefix;
        fullPath.replace(image_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (force.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "force", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("force")).append(querySuffix).append(QUrl::toPercentEncoding(force.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::deleteImageByImageIdCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::deleteImageByImageIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDeleteImageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteImageByImageIdSignal(output);
        Q_EMIT deleteImageByImageIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteImageByImageIdSignalE(output, error_type, error_str);
        Q_EMIT deleteImageByImageIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteImageByImageIdSignalError(output, error_type, error_str);
        Q_EMIT deleteImageByImageIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::deleteImagesAsync(const QList<QString> &image_digests, const ::OpenAPI::OptionalParam<bool> &force, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["deleteImagesAsync"][_serverIndices.value("deleteImagesAsync")].URL()+"/images");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "imageDigests", false);
        if (image_digests.size() > 0) {
            if (QString("csv").indexOf("multi") == 0) {
                for (QString t : image_digests) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("imageDigests=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("csv").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("imageDigests").append(querySuffix);
                qint32 count = 0;
                for (QString t : image_digests) {
                    if (count > 0) {
                        fullPath.append((false)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("imageDigests").append(querySuffix);
                qint32 count = 0;
                for (QString t : image_digests) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("imageDigests").append(querySuffix);
                qint32 count = 0;
                for (QString t : image_digests) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("imageDigests").append(querySuffix);
                qint32 count = 0;
                for (QString t : image_digests) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("csv").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("imageDigests").append(querySuffix);
                qint32 count = 0;
                for (QString t : image_digests) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (force.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "force", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("force")).append(querySuffix).append(QUrl::toPercentEncoding(force.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::deleteImagesAsyncCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::deleteImagesAsyncCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIDeleteImageResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIDeleteImageResponse val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteImagesAsyncSignal(output);
        Q_EMIT deleteImagesAsyncSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteImagesAsyncSignalE(output, error_type, error_str);
        Q_EMIT deleteImagesAsyncSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteImagesAsyncSignalError(output, error_type, error_str);
        Q_EMIT deleteImagesAsyncSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImage(const QString &image_digest, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImage"][_serverIndices.value("getImage")].URL()+"/images/{imageDigest}");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIAnchoreImage> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIAnchoreImage val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageSignal(output);
        Q_EMIT getImageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageSignalE(output, error_type, error_str);
        Q_EMIT getImageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageSignalError(output, error_type, error_str);
        Q_EMIT getImageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageByImageId(const QString &image_id, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageByImageId"][_serverIndices.value("getImageByImageId")].URL()+"/images/by_id/{imageId}");
    
    
    {
        QString image_idPathParam("{");
        image_idPathParam.append("imageId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageId"+pathSuffix : pathPrefix;
        fullPath.replace(image_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageByImageIdCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageByImageIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIAnchoreImage> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIAnchoreImage val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageByImageIdSignal(output);
        Q_EMIT getImageByImageIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageByImageIdSignalE(output, error_type, error_str);
        Q_EMIT getImageByImageIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageByImageIdSignalError(output, error_type, error_str);
        Q_EMIT getImageByImageIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageContentByType(const QString &image_digest, const QString &ctype, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageContentByType"][_serverIndices.value("getImageContentByType")].URL()+"/images/{imageDigest}/content/{ctype}");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    
    {
        QString ctypePathParam("{");
        ctypePathParam.append("ctype").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "ctype", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"ctype"+pathSuffix : pathPrefix;
        fullPath.replace(ctypePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(ctype)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageContentByTypeCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageContentByTypeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIContentPackageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageContentByTypeSignal(output);
        Q_EMIT getImageContentByTypeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageContentByTypeSignalE(output, error_type, error_str);
        Q_EMIT getImageContentByTypeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageContentByTypeSignalError(output, error_type, error_str);
        Q_EMIT getImageContentByTypeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageContentByTypeFiles(const QString &image_digest, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageContentByTypeFiles"][_serverIndices.value("getImageContentByTypeFiles")].URL()+"/images/{imageDigest}/content/files");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageContentByTypeFilesCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageContentByTypeFilesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIContentFilesResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageContentByTypeFilesSignal(output);
        Q_EMIT getImageContentByTypeFilesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageContentByTypeFilesSignalE(output, error_type, error_str);
        Q_EMIT getImageContentByTypeFilesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageContentByTypeFilesSignalError(output, error_type, error_str);
        Q_EMIT getImageContentByTypeFilesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageContentByTypeImageId(const QString &image_id, const QString &ctype, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageContentByTypeImageId"][_serverIndices.value("getImageContentByTypeImageId")].URL()+"/images/by_id/{imageId}/content/{ctype}");
    
    
    {
        QString image_idPathParam("{");
        image_idPathParam.append("imageId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageId"+pathSuffix : pathPrefix;
        fullPath.replace(image_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_id)));
    }
    
    {
        QString ctypePathParam("{");
        ctypePathParam.append("ctype").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "ctype", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"ctype"+pathSuffix : pathPrefix;
        fullPath.replace(ctypePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(ctype)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageContentByTypeImageIdCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageContentByTypeImageIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIContentPackageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageContentByTypeImageIdSignal(output);
        Q_EMIT getImageContentByTypeImageIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageContentByTypeImageIdSignalE(output, error_type, error_str);
        Q_EMIT getImageContentByTypeImageIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageContentByTypeImageIdSignalError(output, error_type, error_str);
        Q_EMIT getImageContentByTypeImageIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageContentByTypeImageIdFiles(const QString &image_id, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageContentByTypeImageIdFiles"][_serverIndices.value("getImageContentByTypeImageIdFiles")].URL()+"/images/by_id/{imageId}/content/files");
    
    
    {
        QString image_idPathParam("{");
        image_idPathParam.append("imageId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageId"+pathSuffix : pathPrefix;
        fullPath.replace(image_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageContentByTypeImageIdFilesCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageContentByTypeImageIdFilesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIContentFilesResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageContentByTypeImageIdFilesSignal(output);
        Q_EMIT getImageContentByTypeImageIdFilesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageContentByTypeImageIdFilesSignalE(output, error_type, error_str);
        Q_EMIT getImageContentByTypeImageIdFilesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageContentByTypeImageIdFilesSignalError(output, error_type, error_str);
        Q_EMIT getImageContentByTypeImageIdFilesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageContentByTypeImageIdJavapackage(const QString &image_id, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageContentByTypeImageIdJavapackage"][_serverIndices.value("getImageContentByTypeImageIdJavapackage")].URL()+"/images/by_id/{imageId}/content/java");
    
    
    {
        QString image_idPathParam("{");
        image_idPathParam.append("imageId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageId"+pathSuffix : pathPrefix;
        fullPath.replace(image_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageContentByTypeImageIdJavapackageCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageContentByTypeImageIdJavapackageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIContentJAVAPackageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageContentByTypeImageIdJavapackageSignal(output);
        Q_EMIT getImageContentByTypeImageIdJavapackageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageContentByTypeImageIdJavapackageSignalE(output, error_type, error_str);
        Q_EMIT getImageContentByTypeImageIdJavapackageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageContentByTypeImageIdJavapackageSignalError(output, error_type, error_str);
        Q_EMIT getImageContentByTypeImageIdJavapackageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageContentByTypeJavapackage(const QString &image_digest, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageContentByTypeJavapackage"][_serverIndices.value("getImageContentByTypeJavapackage")].URL()+"/images/{imageDigest}/content/java");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageContentByTypeJavapackageCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageContentByTypeJavapackageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIContentJAVAPackageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageContentByTypeJavapackageSignal(output);
        Q_EMIT getImageContentByTypeJavapackageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageContentByTypeJavapackageSignalE(output, error_type, error_str);
        Q_EMIT getImageContentByTypeJavapackageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageContentByTypeJavapackageSignalError(output, error_type, error_str);
        Q_EMIT getImageContentByTypeJavapackageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageContentByTypeMalware(const QString &image_digest, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageContentByTypeMalware"][_serverIndices.value("getImageContentByTypeMalware")].URL()+"/images/{imageDigest}/content/malware");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageContentByTypeMalwareCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageContentByTypeMalwareCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIContentMalwareResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageContentByTypeMalwareSignal(output);
        Q_EMIT getImageContentByTypeMalwareSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageContentByTypeMalwareSignalE(output, error_type, error_str);
        Q_EMIT getImageContentByTypeMalwareSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageContentByTypeMalwareSignalError(output, error_type, error_str);
        Q_EMIT getImageContentByTypeMalwareSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageMetadataByType(const QString &image_digest, const QString &mtype, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageMetadataByType"][_serverIndices.value("getImageMetadataByType")].URL()+"/images/{imageDigest}/metadata/{mtype}");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    
    {
        QString mtypePathParam("{");
        mtypePathParam.append("mtype").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "mtype", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"mtype"+pathSuffix : pathPrefix;
        fullPath.replace(mtypePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(mtype)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageMetadataByTypeCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageMetadataByTypeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMetadataResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageMetadataByTypeSignal(output);
        Q_EMIT getImageMetadataByTypeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageMetadataByTypeSignalE(output, error_type, error_str);
        Q_EMIT getImageMetadataByTypeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageMetadataByTypeSignalError(output, error_type, error_str);
        Q_EMIT getImageMetadataByTypeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImagePolicyCheck(const QString &image_digest, const QString &tag, const ::OpenAPI::OptionalParam<QString> &policy_id, const ::OpenAPI::OptionalParam<bool> &detail, const ::OpenAPI::OptionalParam<bool> &history, const ::OpenAPI::OptionalParam<bool> &interactive, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImagePolicyCheck"][_serverIndices.value("getImagePolicyCheck")].URL()+"/images/{imageDigest}/check");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (policy_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "policyId", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("policyId")).append(querySuffix).append(QUrl::toPercentEncoding(policy_id.stringValue()));
    }
    
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "tag", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("tag")).append(querySuffix).append(QUrl::toPercentEncoding(tag));
    }
    if (detail.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "detail", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("detail")).append(querySuffix).append(QUrl::toPercentEncoding(detail.stringValue()));
    }
    if (history.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "history", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("history")).append(querySuffix).append(QUrl::toPercentEncoding(history.stringValue()));
    }
    if (interactive.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "interactive", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("interactive")).append(querySuffix).append(QUrl::toPercentEncoding(interactive.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImagePolicyCheckCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImagePolicyCheckCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIObject> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIObject val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImagePolicyCheckSignal(output);
        Q_EMIT getImagePolicyCheckSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImagePolicyCheckSignalE(output, error_type, error_str);
        Q_EMIT getImagePolicyCheckSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImagePolicyCheckSignalError(output, error_type, error_str);
        Q_EMIT getImagePolicyCheckSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImagePolicyCheckByImageId(const QString &image_id, const QString &tag, const ::OpenAPI::OptionalParam<QString> &policy_id, const ::OpenAPI::OptionalParam<bool> &detail, const ::OpenAPI::OptionalParam<bool> &history, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImagePolicyCheckByImageId"][_serverIndices.value("getImagePolicyCheckByImageId")].URL()+"/images/by_id/{imageId}/check");
    
    
    {
        QString image_idPathParam("{");
        image_idPathParam.append("imageId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageId"+pathSuffix : pathPrefix;
        fullPath.replace(image_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (policy_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "policyId", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("policyId")).append(querySuffix).append(QUrl::toPercentEncoding(policy_id.stringValue()));
    }
    
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "tag", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("tag")).append(querySuffix).append(QUrl::toPercentEncoding(tag));
    }
    if (detail.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "detail", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("detail")).append(querySuffix).append(QUrl::toPercentEncoding(detail.stringValue()));
    }
    if (history.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "history", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("history")).append(querySuffix).append(QUrl::toPercentEncoding(history.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImagePolicyCheckByImageIdCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImagePolicyCheckByImageIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIObject> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIObject val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImagePolicyCheckByImageIdSignal(output);
        Q_EMIT getImagePolicyCheckByImageIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImagePolicyCheckByImageIdSignalE(output, error_type, error_str);
        Q_EMIT getImagePolicyCheckByImageIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImagePolicyCheckByImageIdSignalError(output, error_type, error_str);
        Q_EMIT getImagePolicyCheckByImageIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageSbomNative(const QString &image_digest, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageSbomNative"][_serverIndices.value("getImageSbomNative")].URL()+"/images/{imageDigest}/sboms/native");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageSbomNativeCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageSbomNativeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageSbomNativeSignal(output);
        Q_EMIT getImageSbomNativeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageSbomNativeSignalE(output, error_type, error_str);
        Q_EMIT getImageSbomNativeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageSbomNativeSignalError(output, error_type, error_str);
        Q_EMIT getImageSbomNativeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageVulnerabilitiesByType(const QString &image_digest, const QString &vtype, const ::OpenAPI::OptionalParam<bool> &force_refresh, const ::OpenAPI::OptionalParam<bool> &vendor_only, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageVulnerabilitiesByType"][_serverIndices.value("getImageVulnerabilitiesByType")].URL()+"/images/{imageDigest}/vuln/{vtype}");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    
    {
        QString vtypePathParam("{");
        vtypePathParam.append("vtype").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "vtype", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"vtype"+pathSuffix : pathPrefix;
        fullPath.replace(vtypePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(vtype)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (force_refresh.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "force_refresh", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("force_refresh")).append(querySuffix).append(QUrl::toPercentEncoding(force_refresh.stringValue()));
    }
    if (vendor_only.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "vendor_only", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("vendor_only")).append(querySuffix).append(QUrl::toPercentEncoding(vendor_only.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageVulnerabilitiesByTypeCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageVulnerabilitiesByTypeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIVulnerabilityResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageVulnerabilitiesByTypeSignal(output);
        Q_EMIT getImageVulnerabilitiesByTypeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageVulnerabilitiesByTypeSignalE(output, error_type, error_str);
        Q_EMIT getImageVulnerabilitiesByTypeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageVulnerabilitiesByTypeSignalError(output, error_type, error_str);
        Q_EMIT getImageVulnerabilitiesByTypeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageVulnerabilitiesByTypeImageId(const QString &image_id, const QString &vtype, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageVulnerabilitiesByTypeImageId"][_serverIndices.value("getImageVulnerabilitiesByTypeImageId")].URL()+"/images/by_id/{imageId}/vuln/{vtype}");
    
    
    {
        QString image_idPathParam("{");
        image_idPathParam.append("imageId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageId"+pathSuffix : pathPrefix;
        fullPath.replace(image_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_id)));
    }
    
    {
        QString vtypePathParam("{");
        vtypePathParam.append("vtype").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "vtype", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"vtype"+pathSuffix : pathPrefix;
        fullPath.replace(vtypePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(vtype)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageVulnerabilitiesByTypeImageIdCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageVulnerabilitiesByTypeImageIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIVulnerabilityResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageVulnerabilitiesByTypeImageIdSignal(output);
        Q_EMIT getImageVulnerabilitiesByTypeImageIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageVulnerabilitiesByTypeImageIdSignalE(output, error_type, error_str);
        Q_EMIT getImageVulnerabilitiesByTypeImageIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageVulnerabilitiesByTypeImageIdSignalError(output, error_type, error_str);
        Q_EMIT getImageVulnerabilitiesByTypeImageIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageVulnerabilityTypes(const QString &image_digest, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageVulnerabilityTypes"][_serverIndices.value("getImageVulnerabilityTypes")].URL()+"/images/{imageDigest}/vuln");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageVulnerabilityTypesCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageVulnerabilityTypesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageVulnerabilityTypesSignal(output);
        Q_EMIT getImageVulnerabilityTypesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageVulnerabilityTypesSignalE(output, error_type, error_str);
        Q_EMIT getImageVulnerabilityTypesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageVulnerabilityTypesSignalError(output, error_type, error_str);
        Q_EMIT getImageVulnerabilityTypesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::getImageVulnerabilityTypesByImageId(const QString &image_id, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["getImageVulnerabilityTypesByImageId"][_serverIndices.value("getImageVulnerabilityTypesByImageId")].URL()+"/images/by_id/{imageId}/vuln");
    
    
    {
        QString image_idPathParam("{");
        image_idPathParam.append("imageId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageId"+pathSuffix : pathPrefix;
        fullPath.replace(image_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::getImageVulnerabilityTypesByImageIdCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::getImageVulnerabilityTypesByImageIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getImageVulnerabilityTypesByImageIdSignal(output);
        Q_EMIT getImageVulnerabilityTypesByImageIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getImageVulnerabilityTypesByImageIdSignalE(output, error_type, error_str);
        Q_EMIT getImageVulnerabilityTypesByImageIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getImageVulnerabilityTypesByImageIdSignalError(output, error_type, error_str);
        Q_EMIT getImageVulnerabilityTypesByImageIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::listImageContent(const QString &image_digest, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["listImageContent"][_serverIndices.value("listImageContent")].URL()+"/images/{imageDigest}/content");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::listImageContentCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::listImageContentCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listImageContentSignal(output);
        Q_EMIT listImageContentSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listImageContentSignalE(output, error_type, error_str);
        Q_EMIT listImageContentSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listImageContentSignalError(output, error_type, error_str);
        Q_EMIT listImageContentSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::listImageContentByImageid(const QString &image_id, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["listImageContentByImageid"][_serverIndices.value("listImageContentByImageid")].URL()+"/images/by_id/{imageId}/content");
    
    
    {
        QString image_idPathParam("{");
        image_idPathParam.append("imageId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageId"+pathSuffix : pathPrefix;
        fullPath.replace(image_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::listImageContentByImageidCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::listImageContentByImageidCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listImageContentByImageidSignal(output);
        Q_EMIT listImageContentByImageidSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listImageContentByImageidSignalE(output, error_type, error_str);
        Q_EMIT listImageContentByImageidSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listImageContentByImageidSignalError(output, error_type, error_str);
        Q_EMIT listImageContentByImageidSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::listImageMetadata(const QString &image_digest, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["listImageMetadata"][_serverIndices.value("listImageMetadata")].URL()+"/images/{imageDigest}/metadata");
    
    
    {
        QString image_digestPathParam("{");
        image_digestPathParam.append("imageDigest").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "imageDigest", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"imageDigest"+pathSuffix : pathPrefix;
        fullPath.replace(image_digestPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(image_digest)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::listImageMetadataCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::listImageMetadataCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listImageMetadataSignal(output);
        Q_EMIT listImageMetadataSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listImageMetadataSignalE(output, error_type, error_str);
        Q_EMIT listImageMetadataSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listImageMetadataSignalError(output, error_type, error_str);
        Q_EMIT listImageMetadataSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::listImages(const ::OpenAPI::OptionalParam<bool> &history, const ::OpenAPI::OptionalParam<QString> &fulltag, const ::OpenAPI::OptionalParam<QString> &image_status, const ::OpenAPI::OptionalParam<QString> &analysis_status, const ::OpenAPI::OptionalParam<QString> &x_anchore_account) {
    QString fullPath = QString(_serverConfigs["listImages"][_serverIndices.value("listImages")].URL()+"/images");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (history.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "history", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("history")).append(querySuffix).append(QUrl::toPercentEncoding(history.stringValue()));
    }
    if (fulltag.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "fulltag", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("fulltag")).append(querySuffix).append(QUrl::toPercentEncoding(fulltag.stringValue()));
    }
    if (image_status.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "image_status", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("image_status")).append(querySuffix).append(QUrl::toPercentEncoding(image_status.stringValue()));
    }
    if (analysis_status.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "analysis_status", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("analysis_status")).append(querySuffix).append(QUrl::toPercentEncoding(analysis_status.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (x_anchore_account.hasValue())
    {
        if (!::OpenAPI::toStringValue(x_anchore_account.value()).isEmpty()) {
            input.headers.insert("x-anchore-account", ::OpenAPI::toStringValue(x_anchore_account.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIImagesApi::listImagesCallback);
    connect(this, &OAIImagesApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIImagesApi::listImagesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIAnchoreImage> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIAnchoreImage val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listImagesSignal(output);
        Q_EMIT listImagesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listImagesSignalE(output, error_type, error_str);
        Q_EMIT listImagesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listImagesSignalError(output, error_type, error_str);
        Q_EMIT listImagesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIImagesApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
