/**
 * Anchore Engine API Server
 * This is the Anchore Engine API. Provides the primary external API for users of the service.
 *
 * The version of the OpenAPI document: 0.1.20
 * Contact: nurmi@anchore.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import NvdDataObject from './NvdDataObject';
import PackageReference from './PackageReference';
import VendorDataObject from './VendorDataObject';
import VulnerabilityReference from './VulnerabilityReference';

/**
 * The StandaloneVulnerability model module.
 * @module model/StandaloneVulnerability
 * @version 0.1.20
 */
class StandaloneVulnerability {
    /**
     * Constructs a new <code>StandaloneVulnerability</code>.
     * A single vulnerability record in a single namespace, the unique key is the combination of the id and namespace
     * @alias module:model/StandaloneVulnerability
     */
    constructor() { 
        
        StandaloneVulnerability.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>StandaloneVulnerability</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/StandaloneVulnerability} obj Optional instance to populate.
     * @return {module:model/StandaloneVulnerability} The populated <code>StandaloneVulnerability</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new StandaloneVulnerability();

            if (data.hasOwnProperty('affected_packages')) {
                obj['affected_packages'] = ApiClient.convertToType(data['affected_packages'], [PackageReference]);
            }
            if (data.hasOwnProperty('description')) {
                obj['description'] = ApiClient.convertToType(data['description'], 'String');
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('link')) {
                obj['link'] = ApiClient.convertToType(data['link'], 'String');
            }
            if (data.hasOwnProperty('namespace')) {
                obj['namespace'] = ApiClient.convertToType(data['namespace'], 'String');
            }
            if (data.hasOwnProperty('nvd_data')) {
                obj['nvd_data'] = ApiClient.convertToType(data['nvd_data'], [NvdDataObject]);
            }
            if (data.hasOwnProperty('references')) {
                obj['references'] = ApiClient.convertToType(data['references'], [VulnerabilityReference]);
            }
            if (data.hasOwnProperty('severity')) {
                obj['severity'] = ApiClient.convertToType(data['severity'], 'String');
            }
            if (data.hasOwnProperty('vendor_data')) {
                obj['vendor_data'] = ApiClient.convertToType(data['vendor_data'], [VendorDataObject]);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>StandaloneVulnerability</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>StandaloneVulnerability</code>.
     */
    static validateJSON(data) {
        if (data['affected_packages']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['affected_packages'])) {
                throw new Error("Expected the field `affected_packages` to be an array in the JSON data but got " + data['affected_packages']);
            }
            // validate the optional field `affected_packages` (array)
            for (const item of data['affected_packages']) {
                PackageReference.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['description'] && !(typeof data['description'] === 'string' || data['description'] instanceof String)) {
            throw new Error("Expected the field `description` to be a primitive type in the JSON string but got " + data['description']);
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // ensure the json data is a string
        if (data['link'] && !(typeof data['link'] === 'string' || data['link'] instanceof String)) {
            throw new Error("Expected the field `link` to be a primitive type in the JSON string but got " + data['link']);
        }
        // ensure the json data is a string
        if (data['namespace'] && !(typeof data['namespace'] === 'string' || data['namespace'] instanceof String)) {
            throw new Error("Expected the field `namespace` to be a primitive type in the JSON string but got " + data['namespace']);
        }
        if (data['nvd_data']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['nvd_data'])) {
                throw new Error("Expected the field `nvd_data` to be an array in the JSON data but got " + data['nvd_data']);
            }
            // validate the optional field `nvd_data` (array)
            for (const item of data['nvd_data']) {
                NvdDataObject.validateJSON(item);
            };
        }
        if (data['references']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['references'])) {
                throw new Error("Expected the field `references` to be an array in the JSON data but got " + data['references']);
            }
            // validate the optional field `references` (array)
            for (const item of data['references']) {
                VulnerabilityReference.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['severity'] && !(typeof data['severity'] === 'string' || data['severity'] instanceof String)) {
            throw new Error("Expected the field `severity` to be a primitive type in the JSON string but got " + data['severity']);
        }
        if (data['vendor_data']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['vendor_data'])) {
                throw new Error("Expected the field `vendor_data` to be an array in the JSON data but got " + data['vendor_data']);
            }
            // validate the optional field `vendor_data` (array)
            for (const item of data['vendor_data']) {
                VendorDataObject.validateJSON(item);
            };
        }

        return true;
    }


}



/**
 * The array of packages (typically packages) that are vulnerable-to or provide fixes-for this vulnerability
 * @member {Array.<module:model/PackageReference>} affected_packages
 */
StandaloneVulnerability.prototype['affected_packages'] = undefined;

/**
 * Description of the vulnerability if available
 * @member {String} description
 */
StandaloneVulnerability.prototype['description'] = undefined;

/**
 * Vulnerability identifier. May be CVE-X, RHSA-X, etc. Not necessarily unique across namespaces
 * @member {String} id
 */
StandaloneVulnerability.prototype['id'] = undefined;

/**
 * URL for the upstream CVE record in the reporting source (e.g. ubuntu security tracker)
 * @member {String} link
 */
StandaloneVulnerability.prototype['link'] = undefined;

/**
 * The namespace for the vulnerability record to avoid conflicts for the same id in different distros or sources (e.g. deb vs ubuntu for same CVE)
 * @member {String} namespace
 */
StandaloneVulnerability.prototype['namespace'] = undefined;

/**
 * List of Nvd Data objects
 * @member {Array.<module:model/NvdDataObject>} nvd_data
 */
StandaloneVulnerability.prototype['nvd_data'] = undefined;

/**
 * List of references including
 * @member {Array.<module:model/VulnerabilityReference>} references
 */
StandaloneVulnerability.prototype['references'] = undefined;

/**
 * Severity label specific to the namepsace
 * @member {module:model/StandaloneVulnerability.SeverityEnum} severity
 */
StandaloneVulnerability.prototype['severity'] = undefined;

/**
 * List of Vendor Data objects
 * @member {Array.<module:model/VendorDataObject>} vendor_data
 */
StandaloneVulnerability.prototype['vendor_data'] = undefined;





/**
 * Allowed values for the <code>severity</code> property.
 * @enum {String}
 * @readonly
 */
StandaloneVulnerability['SeverityEnum'] = {

    /**
     * value: "Unknown"
     * @const
     */
    "Unknown": "Unknown",

    /**
     * value: "Negligible"
     * @const
     */
    "Negligible": "Negligible",

    /**
     * value: "Low"
     * @const
     */
    "Low": "Low",

    /**
     * value: "Medium"
     * @const
     */
    "Medium": "Medium",

    /**
     * value: "High"
     * @const
     */
    "High": "High",

    /**
     * value: "Critical"
     * @const
     */
    "Critical": "Critical"
};



export default StandaloneVulnerability;

