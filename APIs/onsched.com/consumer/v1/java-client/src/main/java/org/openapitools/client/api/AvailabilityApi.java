/*
 * OnSched Consumer API
 * Build secure and scalable custom apps for Online Booking. Our flexible API provides many options for availability and booking.  <br><br>  Take the API for a test drive. Just click on the Authorize button below and authenticate.   You can access our demo company profile if you are not a customer, or your own profile by using your assigned ClientId and Secret.  <br><br>  The API has two interfaces, consumer and setup.   <ul>  <li>  The consumer interface provides all the endpoints required for implementing consumer booking flows.  </li>  <li>  The setup interface provides endpoints for profile configuration and setup.  </li>  </ul>  Toggle freely between the two interfaces using the swagger tool bar option labelled 'Select a definition'.  
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.AvailabilityDayViewModel;
import org.openapitools.client.model.AvailabilityViewModel;
import java.time.OffsetDateTime;
import org.openapitools.client.model.UnavailableTimeListViewModel;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AvailabilityApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AvailabilityApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AvailabilityApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for consumerV1AvailabilityServiceIdStartDateEndDateDaysGet
     * @param serviceId Service Id for day availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for availability search (required)
     * @param endDate Format YYYY-MM-DD: End Date for availability search (required)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id to filter on (optional)
     * @param tzOffset Timezone offset to view availability for (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call consumerV1AvailabilityServiceIdStartDateEndDateDaysGetCall(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer tzOffset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/consumer/v1/availability/{serviceId}/{startDate}/{endDate}/days"
            .replace("{" + "serviceId" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "startDate" + "}", localVarApiClient.escapeString(startDate.toString()))
            .replace("{" + "endDate" + "}", localVarApiClient.escapeString(endDate.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (locationId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("locationId", locationId));
        }

        if (resourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("resourceId", resourceId));
        }

        if (tzOffset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tzOffset", tzOffset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call consumerV1AvailabilityServiceIdStartDateEndDateDaysGetValidateBeforeCall(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer tzOffset, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling consumerV1AvailabilityServiceIdStartDateEndDateDaysGet(Async)");
        }

        // verify the required parameter 'startDate' is set
        if (startDate == null) {
            throw new ApiException("Missing the required parameter 'startDate' when calling consumerV1AvailabilityServiceIdStartDateEndDateDaysGet(Async)");
        }

        // verify the required parameter 'endDate' is set
        if (endDate == null) {
            throw new ApiException("Missing the required parameter 'endDate' when calling consumerV1AvailabilityServiceIdStartDateEndDateDaysGet(Async)");
        }

        return consumerV1AvailabilityServiceIdStartDateEndDateDaysGetCall(serviceId, startDate, endDate, locationId, resourceId, tzOffset, _callback);

    }

    /**
     * Get Available Days
     * &lt;p&gt;This endpoint will return &lt;b&gt;Day Level Availability&lt;/b&gt; for the range of dates requested. For example, if the business is closed, or there is a public holiday this endpoint will return that the \&quot;Day is unavailable\&quot;.&lt;/p&gt;  &lt;p&gt;Day Availability is a high-level check for Holidays and Open/Available hours of a location, service and/or resource and should be used to restrict your choices of days available in your application to improve usability and performance.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;serviceId&lt;/b&gt; is required. The &lt;b&gt;startDate&lt;/b&gt; and &lt;b&gt;endDate&lt;/b&gt; are required and are formatted as: &lt;b&gt;YYYY-MM-DD&lt;/b&gt;&lt;/p&gt;  &lt;p&gt;The locationId is optional, however if not supplied it defaults to the Primary Business Location for open/closed hours information. It is recommended you always provide the locationId.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;resourceId&lt;/b&gt; is optional. If used the available days will be return day availability for the resource specified.&lt;/p&gt;  &lt;p&gt;The &lt;b&gt;tzOffset&lt;/b&gt; parameter should be used if the appointment requester, the end user, is in a different timezone than the location or resource.&lt;/p&gt;
     * @param serviceId Service Id for day availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for availability search (required)
     * @param endDate Format YYYY-MM-DD: End Date for availability search (required)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id to filter on (optional)
     * @param tzOffset Timezone offset to view availability for (optional)
     * @return AvailabilityDayViewModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AvailabilityDayViewModel consumerV1AvailabilityServiceIdStartDateEndDateDaysGet(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer tzOffset) throws ApiException {
        ApiResponse<AvailabilityDayViewModel> localVarResp = consumerV1AvailabilityServiceIdStartDateEndDateDaysGetWithHttpInfo(serviceId, startDate, endDate, locationId, resourceId, tzOffset);
        return localVarResp.getData();
    }

    /**
     * Get Available Days
     * &lt;p&gt;This endpoint will return &lt;b&gt;Day Level Availability&lt;/b&gt; for the range of dates requested. For example, if the business is closed, or there is a public holiday this endpoint will return that the \&quot;Day is unavailable\&quot;.&lt;/p&gt;  &lt;p&gt;Day Availability is a high-level check for Holidays and Open/Available hours of a location, service and/or resource and should be used to restrict your choices of days available in your application to improve usability and performance.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;serviceId&lt;/b&gt; is required. The &lt;b&gt;startDate&lt;/b&gt; and &lt;b&gt;endDate&lt;/b&gt; are required and are formatted as: &lt;b&gt;YYYY-MM-DD&lt;/b&gt;&lt;/p&gt;  &lt;p&gt;The locationId is optional, however if not supplied it defaults to the Primary Business Location for open/closed hours information. It is recommended you always provide the locationId.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;resourceId&lt;/b&gt; is optional. If used the available days will be return day availability for the resource specified.&lt;/p&gt;  &lt;p&gt;The &lt;b&gt;tzOffset&lt;/b&gt; parameter should be used if the appointment requester, the end user, is in a different timezone than the location or resource.&lt;/p&gt;
     * @param serviceId Service Id for day availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for availability search (required)
     * @param endDate Format YYYY-MM-DD: End Date for availability search (required)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id to filter on (optional)
     * @param tzOffset Timezone offset to view availability for (optional)
     * @return ApiResponse&lt;AvailabilityDayViewModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AvailabilityDayViewModel> consumerV1AvailabilityServiceIdStartDateEndDateDaysGetWithHttpInfo(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer tzOffset) throws ApiException {
        okhttp3.Call localVarCall = consumerV1AvailabilityServiceIdStartDateEndDateDaysGetValidateBeforeCall(serviceId, startDate, endDate, locationId, resourceId, tzOffset, null);
        Type localVarReturnType = new TypeToken<AvailabilityDayViewModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Available Days (asynchronously)
     * &lt;p&gt;This endpoint will return &lt;b&gt;Day Level Availability&lt;/b&gt; for the range of dates requested. For example, if the business is closed, or there is a public holiday this endpoint will return that the \&quot;Day is unavailable\&quot;.&lt;/p&gt;  &lt;p&gt;Day Availability is a high-level check for Holidays and Open/Available hours of a location, service and/or resource and should be used to restrict your choices of days available in your application to improve usability and performance.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;serviceId&lt;/b&gt; is required. The &lt;b&gt;startDate&lt;/b&gt; and &lt;b&gt;endDate&lt;/b&gt; are required and are formatted as: &lt;b&gt;YYYY-MM-DD&lt;/b&gt;&lt;/p&gt;  &lt;p&gt;The locationId is optional, however if not supplied it defaults to the Primary Business Location for open/closed hours information. It is recommended you always provide the locationId.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;resourceId&lt;/b&gt; is optional. If used the available days will be return day availability for the resource specified.&lt;/p&gt;  &lt;p&gt;The &lt;b&gt;tzOffset&lt;/b&gt; parameter should be used if the appointment requester, the end user, is in a different timezone than the location or resource.&lt;/p&gt;
     * @param serviceId Service Id for day availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for availability search (required)
     * @param endDate Format YYYY-MM-DD: End Date for availability search (required)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id to filter on (optional)
     * @param tzOffset Timezone offset to view availability for (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call consumerV1AvailabilityServiceIdStartDateEndDateDaysGetAsync(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer tzOffset, final ApiCallback<AvailabilityDayViewModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = consumerV1AvailabilityServiceIdStartDateEndDateDaysGetValidateBeforeCall(serviceId, startDate, endDate, locationId, resourceId, tzOffset, _callback);
        Type localVarReturnType = new TypeToken<AvailabilityDayViewModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for consumerV1AvailabilityServiceIdStartDateEndDateGet
     * @param serviceId Service Id for availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for availability search (required)
     * @param endDate Format YYYY-MM-DD: End Date for availability search (required)
     * @param startTime Format Military Time Start Time for availability search. Defaults to Business Hours Start (optional)
     * @param endTime Format Military Time. End Time for availability search. Defaults to Business Hours End (optional)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id for availability search (optional)
     * @param resourceGroupId Resource Group Id for availability search (optional)
     * @param resourceIds Comma separated Resource Id&#39;s for availability search (optional)
     * @param roundRobin Round robin choice 0&#x3D;none, 1&#x3D;random, 2&#x3D;balanced (optional)
     * @param duration Duration of the service if different from default (optional)
     * @param interval Booking Interval if different than the default (optional)
     * @param timezoneName Requested IANA timezone Id to view availability (optional)
     * @param tzOffset Request timezone offset to view availability (optional)
     * @param destination For calculating travel based availability, requires distance scope (optional)
     * @param dayAvailabilityStartDate Format YYYY-DD-YY: Start date for day availability, defaults to startDate (optional)
     * @param dayAvailability Number of days of day availability to return (optional)
     * @param firstDayAvailable Return available times for the first available day (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call consumerV1AvailabilityServiceIdStartDateEndDateGetCall(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, Integer startTime, Integer endTime, String locationId, String resourceId, String resourceGroupId, String resourceIds, String roundRobin, Integer duration, Integer interval, String timezoneName, Integer tzOffset, String destination, OffsetDateTime dayAvailabilityStartDate, Integer dayAvailability, Boolean firstDayAvailable, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/consumer/v1/availability/{serviceId}/{startDate}/{endDate}"
            .replace("{" + "serviceId" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "startDate" + "}", localVarApiClient.escapeString(startDate.toString()))
            .replace("{" + "endDate" + "}", localVarApiClient.escapeString(endDate.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (locationId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("locationId", locationId));
        }

        if (resourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("resourceId", resourceId));
        }

        if (resourceGroupId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("resourceGroupId", resourceGroupId));
        }

        if (resourceIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("resourceIds", resourceIds));
        }

        if (roundRobin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("roundRobin", roundRobin));
        }

        if (duration != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("duration", duration));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        if (timezoneName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timezoneName", timezoneName));
        }

        if (tzOffset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tzOffset", tzOffset));
        }

        if (destination != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("destination", destination));
        }

        if (dayAvailabilityStartDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dayAvailabilityStartDate", dayAvailabilityStartDate));
        }

        if (dayAvailability != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dayAvailability", dayAvailability));
        }

        if (firstDayAvailable != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("firstDayAvailable", firstDayAvailable));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call consumerV1AvailabilityServiceIdStartDateEndDateGetValidateBeforeCall(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, Integer startTime, Integer endTime, String locationId, String resourceId, String resourceGroupId, String resourceIds, String roundRobin, Integer duration, Integer interval, String timezoneName, Integer tzOffset, String destination, OffsetDateTime dayAvailabilityStartDate, Integer dayAvailability, Boolean firstDayAvailable, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling consumerV1AvailabilityServiceIdStartDateEndDateGet(Async)");
        }

        // verify the required parameter 'startDate' is set
        if (startDate == null) {
            throw new ApiException("Missing the required parameter 'startDate' when calling consumerV1AvailabilityServiceIdStartDateEndDateGet(Async)");
        }

        // verify the required parameter 'endDate' is set
        if (endDate == null) {
            throw new ApiException("Missing the required parameter 'endDate' when calling consumerV1AvailabilityServiceIdStartDateEndDateGet(Async)");
        }

        return consumerV1AvailabilityServiceIdStartDateEndDateGetCall(serviceId, startDate, endDate, startTime, endTime, locationId, resourceId, resourceGroupId, resourceIds, roundRobin, duration, interval, timezoneName, tzOffset, destination, dayAvailabilityStartDate, dayAvailability, firstDayAvailable, _callback);

    }

    /**
     * Get Available Times
     * &lt;p&gt;    &lt;b&gt;Choose your search criteria carefully. Availability is an expensive call.&lt;/b&gt; If you search availability for all resources, you should only do so for a single date. If you search availability for multiple dates, you should only do so for a specific resource by specifying the optional resourceId parameter.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;serviceId&lt;/b&gt; is required. The &lt;b&gt;startDate&lt;/b&gt; and &lt;b&gt;endDate&lt;/b&gt; are required and are formatted as: &lt;b&gt;YYYY-MM-DD&lt;/b&gt;&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;resourceId&lt;/b&gt; is optional, it is recommended if known at the time of availability call.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;timezoneName&lt;/b&gt; is optional, it allows you to specify the IANA formatted name for the end user&#39;s timezone to view availability. e.g., &lt;i&gt;America/New_York&lt;/i&gt;. &lt;b&gt;NOTE: This is the recommended approach for your implementation.&lt;/b&gt;  The \&quot;tzOffset\&quot; parameter remains for backward compatibility.  For JavaScript, use moment.js in your client for ease of timezone detection and selection. For iOS, use the name property of the NSTimeZone returned from the localTimeZone method. For .NET, consider NodaTime or TimeZoneConverter via NuGet. &lt;/p&gt;  &lt;p&gt;    &lt;b&gt;duration&lt;/b&gt; should only be populated if you allow the end user to select a duration, otherwise the service&#39;s duration will be used.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;startTime&lt;/b&gt; and &lt;b&gt;endTime&lt;/b&gt; are optional and are specified in &lt;b&gt;military time e.g., 800 &#x3D; 8:00am, 2230 &#x3D; 10:30pm&lt;/b&gt;. Note: You will only see availability within the boundary of your business location start and end times.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;dayAvailability&lt;/b&gt; will return day level availability for the number of days requested from the start date. See &lt;i&gt;GET /consumer/v1/availability/{serviceId}/{startDate}/{endDate}/days&lt;/i&gt; for details.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;firstDayAvailable&lt;/b&gt; only works with day availability. If set to true it will look for the first day available within the range specified by the dayAvailability parameter. The two parameters together can be a clever way to display availability for a week or month. Tip - pass in the beginning of the week or month, and available times are displayed for the first available date if exists.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;tzOffset&lt;/b&gt; allows you to pass in the timezone offset for the end user&#39;s timezone of choice, e.g., (-240) for EST. If you use this option, your application should be timezone aware. The requested timezone is specified as an offset (plus or minus) from GMT time.&lt;/p&gt;  &lt;p&gt;Availability can be complex. For further troubleshooting refer to the: &lt;i&gt;&lt;b&gt;GET /consumer/v1/availability/{serviceId}/{startDate}/{endDate}/unavailable&lt;/b&gt;&lt;/i&gt; endpoint. This endpoint will show you all unavailable times for a given date range. Available times are created from any unblocked time periods. For more information: &lt;a href&#x3D;\&quot;https://onsched.readme.io/docs/availability-overview\&quot;&gt;Availability Overview&lt;/a&gt;&lt;/p&gt;
     * @param serviceId Service Id for availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for availability search (required)
     * @param endDate Format YYYY-MM-DD: End Date for availability search (required)
     * @param startTime Format Military Time Start Time for availability search. Defaults to Business Hours Start (optional)
     * @param endTime Format Military Time. End Time for availability search. Defaults to Business Hours End (optional)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id for availability search (optional)
     * @param resourceGroupId Resource Group Id for availability search (optional)
     * @param resourceIds Comma separated Resource Id&#39;s for availability search (optional)
     * @param roundRobin Round robin choice 0&#x3D;none, 1&#x3D;random, 2&#x3D;balanced (optional)
     * @param duration Duration of the service if different from default (optional)
     * @param interval Booking Interval if different than the default (optional)
     * @param timezoneName Requested IANA timezone Id to view availability (optional)
     * @param tzOffset Request timezone offset to view availability (optional)
     * @param destination For calculating travel based availability, requires distance scope (optional)
     * @param dayAvailabilityStartDate Format YYYY-DD-YY: Start date for day availability, defaults to startDate (optional)
     * @param dayAvailability Number of days of day availability to return (optional)
     * @param firstDayAvailable Return available times for the first available day (optional)
     * @return AvailabilityViewModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AvailabilityViewModel consumerV1AvailabilityServiceIdStartDateEndDateGet(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, Integer startTime, Integer endTime, String locationId, String resourceId, String resourceGroupId, String resourceIds, String roundRobin, Integer duration, Integer interval, String timezoneName, Integer tzOffset, String destination, OffsetDateTime dayAvailabilityStartDate, Integer dayAvailability, Boolean firstDayAvailable) throws ApiException {
        ApiResponse<AvailabilityViewModel> localVarResp = consumerV1AvailabilityServiceIdStartDateEndDateGetWithHttpInfo(serviceId, startDate, endDate, startTime, endTime, locationId, resourceId, resourceGroupId, resourceIds, roundRobin, duration, interval, timezoneName, tzOffset, destination, dayAvailabilityStartDate, dayAvailability, firstDayAvailable);
        return localVarResp.getData();
    }

    /**
     * Get Available Times
     * &lt;p&gt;    &lt;b&gt;Choose your search criteria carefully. Availability is an expensive call.&lt;/b&gt; If you search availability for all resources, you should only do so for a single date. If you search availability for multiple dates, you should only do so for a specific resource by specifying the optional resourceId parameter.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;serviceId&lt;/b&gt; is required. The &lt;b&gt;startDate&lt;/b&gt; and &lt;b&gt;endDate&lt;/b&gt; are required and are formatted as: &lt;b&gt;YYYY-MM-DD&lt;/b&gt;&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;resourceId&lt;/b&gt; is optional, it is recommended if known at the time of availability call.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;timezoneName&lt;/b&gt; is optional, it allows you to specify the IANA formatted name for the end user&#39;s timezone to view availability. e.g., &lt;i&gt;America/New_York&lt;/i&gt;. &lt;b&gt;NOTE: This is the recommended approach for your implementation.&lt;/b&gt;  The \&quot;tzOffset\&quot; parameter remains for backward compatibility.  For JavaScript, use moment.js in your client for ease of timezone detection and selection. For iOS, use the name property of the NSTimeZone returned from the localTimeZone method. For .NET, consider NodaTime or TimeZoneConverter via NuGet. &lt;/p&gt;  &lt;p&gt;    &lt;b&gt;duration&lt;/b&gt; should only be populated if you allow the end user to select a duration, otherwise the service&#39;s duration will be used.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;startTime&lt;/b&gt; and &lt;b&gt;endTime&lt;/b&gt; are optional and are specified in &lt;b&gt;military time e.g., 800 &#x3D; 8:00am, 2230 &#x3D; 10:30pm&lt;/b&gt;. Note: You will only see availability within the boundary of your business location start and end times.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;dayAvailability&lt;/b&gt; will return day level availability for the number of days requested from the start date. See &lt;i&gt;GET /consumer/v1/availability/{serviceId}/{startDate}/{endDate}/days&lt;/i&gt; for details.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;firstDayAvailable&lt;/b&gt; only works with day availability. If set to true it will look for the first day available within the range specified by the dayAvailability parameter. The two parameters together can be a clever way to display availability for a week or month. Tip - pass in the beginning of the week or month, and available times are displayed for the first available date if exists.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;tzOffset&lt;/b&gt; allows you to pass in the timezone offset for the end user&#39;s timezone of choice, e.g., (-240) for EST. If you use this option, your application should be timezone aware. The requested timezone is specified as an offset (plus or minus) from GMT time.&lt;/p&gt;  &lt;p&gt;Availability can be complex. For further troubleshooting refer to the: &lt;i&gt;&lt;b&gt;GET /consumer/v1/availability/{serviceId}/{startDate}/{endDate}/unavailable&lt;/b&gt;&lt;/i&gt; endpoint. This endpoint will show you all unavailable times for a given date range. Available times are created from any unblocked time periods. For more information: &lt;a href&#x3D;\&quot;https://onsched.readme.io/docs/availability-overview\&quot;&gt;Availability Overview&lt;/a&gt;&lt;/p&gt;
     * @param serviceId Service Id for availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for availability search (required)
     * @param endDate Format YYYY-MM-DD: End Date for availability search (required)
     * @param startTime Format Military Time Start Time for availability search. Defaults to Business Hours Start (optional)
     * @param endTime Format Military Time. End Time for availability search. Defaults to Business Hours End (optional)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id for availability search (optional)
     * @param resourceGroupId Resource Group Id for availability search (optional)
     * @param resourceIds Comma separated Resource Id&#39;s for availability search (optional)
     * @param roundRobin Round robin choice 0&#x3D;none, 1&#x3D;random, 2&#x3D;balanced (optional)
     * @param duration Duration of the service if different from default (optional)
     * @param interval Booking Interval if different than the default (optional)
     * @param timezoneName Requested IANA timezone Id to view availability (optional)
     * @param tzOffset Request timezone offset to view availability (optional)
     * @param destination For calculating travel based availability, requires distance scope (optional)
     * @param dayAvailabilityStartDate Format YYYY-DD-YY: Start date for day availability, defaults to startDate (optional)
     * @param dayAvailability Number of days of day availability to return (optional)
     * @param firstDayAvailable Return available times for the first available day (optional)
     * @return ApiResponse&lt;AvailabilityViewModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AvailabilityViewModel> consumerV1AvailabilityServiceIdStartDateEndDateGetWithHttpInfo(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, Integer startTime, Integer endTime, String locationId, String resourceId, String resourceGroupId, String resourceIds, String roundRobin, Integer duration, Integer interval, String timezoneName, Integer tzOffset, String destination, OffsetDateTime dayAvailabilityStartDate, Integer dayAvailability, Boolean firstDayAvailable) throws ApiException {
        okhttp3.Call localVarCall = consumerV1AvailabilityServiceIdStartDateEndDateGetValidateBeforeCall(serviceId, startDate, endDate, startTime, endTime, locationId, resourceId, resourceGroupId, resourceIds, roundRobin, duration, interval, timezoneName, tzOffset, destination, dayAvailabilityStartDate, dayAvailability, firstDayAvailable, null);
        Type localVarReturnType = new TypeToken<AvailabilityViewModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Available Times (asynchronously)
     * &lt;p&gt;    &lt;b&gt;Choose your search criteria carefully. Availability is an expensive call.&lt;/b&gt; If you search availability for all resources, you should only do so for a single date. If you search availability for multiple dates, you should only do so for a specific resource by specifying the optional resourceId parameter.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;serviceId&lt;/b&gt; is required. The &lt;b&gt;startDate&lt;/b&gt; and &lt;b&gt;endDate&lt;/b&gt; are required and are formatted as: &lt;b&gt;YYYY-MM-DD&lt;/b&gt;&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;resourceId&lt;/b&gt; is optional, it is recommended if known at the time of availability call.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;timezoneName&lt;/b&gt; is optional, it allows you to specify the IANA formatted name for the end user&#39;s timezone to view availability. e.g., &lt;i&gt;America/New_York&lt;/i&gt;. &lt;b&gt;NOTE: This is the recommended approach for your implementation.&lt;/b&gt;  The \&quot;tzOffset\&quot; parameter remains for backward compatibility.  For JavaScript, use moment.js in your client for ease of timezone detection and selection. For iOS, use the name property of the NSTimeZone returned from the localTimeZone method. For .NET, consider NodaTime or TimeZoneConverter via NuGet. &lt;/p&gt;  &lt;p&gt;    &lt;b&gt;duration&lt;/b&gt; should only be populated if you allow the end user to select a duration, otherwise the service&#39;s duration will be used.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;startTime&lt;/b&gt; and &lt;b&gt;endTime&lt;/b&gt; are optional and are specified in &lt;b&gt;military time e.g., 800 &#x3D; 8:00am, 2230 &#x3D; 10:30pm&lt;/b&gt;. Note: You will only see availability within the boundary of your business location start and end times.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;dayAvailability&lt;/b&gt; will return day level availability for the number of days requested from the start date. See &lt;i&gt;GET /consumer/v1/availability/{serviceId}/{startDate}/{endDate}/days&lt;/i&gt; for details.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;firstDayAvailable&lt;/b&gt; only works with day availability. If set to true it will look for the first day available within the range specified by the dayAvailability parameter. The two parameters together can be a clever way to display availability for a week or month. Tip - pass in the beginning of the week or month, and available times are displayed for the first available date if exists.&lt;/p&gt;  &lt;p&gt;    &lt;b&gt;tzOffset&lt;/b&gt; allows you to pass in the timezone offset for the end user&#39;s timezone of choice, e.g., (-240) for EST. If you use this option, your application should be timezone aware. The requested timezone is specified as an offset (plus or minus) from GMT time.&lt;/p&gt;  &lt;p&gt;Availability can be complex. For further troubleshooting refer to the: &lt;i&gt;&lt;b&gt;GET /consumer/v1/availability/{serviceId}/{startDate}/{endDate}/unavailable&lt;/b&gt;&lt;/i&gt; endpoint. This endpoint will show you all unavailable times for a given date range. Available times are created from any unblocked time periods. For more information: &lt;a href&#x3D;\&quot;https://onsched.readme.io/docs/availability-overview\&quot;&gt;Availability Overview&lt;/a&gt;&lt;/p&gt;
     * @param serviceId Service Id for availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for availability search (required)
     * @param endDate Format YYYY-MM-DD: End Date for availability search (required)
     * @param startTime Format Military Time Start Time for availability search. Defaults to Business Hours Start (optional)
     * @param endTime Format Military Time. End Time for availability search. Defaults to Business Hours End (optional)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id for availability search (optional)
     * @param resourceGroupId Resource Group Id for availability search (optional)
     * @param resourceIds Comma separated Resource Id&#39;s for availability search (optional)
     * @param roundRobin Round robin choice 0&#x3D;none, 1&#x3D;random, 2&#x3D;balanced (optional)
     * @param duration Duration of the service if different from default (optional)
     * @param interval Booking Interval if different than the default (optional)
     * @param timezoneName Requested IANA timezone Id to view availability (optional)
     * @param tzOffset Request timezone offset to view availability (optional)
     * @param destination For calculating travel based availability, requires distance scope (optional)
     * @param dayAvailabilityStartDate Format YYYY-DD-YY: Start date for day availability, defaults to startDate (optional)
     * @param dayAvailability Number of days of day availability to return (optional)
     * @param firstDayAvailable Return available times for the first available day (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call consumerV1AvailabilityServiceIdStartDateEndDateGetAsync(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, Integer startTime, Integer endTime, String locationId, String resourceId, String resourceGroupId, String resourceIds, String roundRobin, Integer duration, Integer interval, String timezoneName, Integer tzOffset, String destination, OffsetDateTime dayAvailabilityStartDate, Integer dayAvailability, Boolean firstDayAvailable, final ApiCallback<AvailabilityViewModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = consumerV1AvailabilityServiceIdStartDateEndDateGetValidateBeforeCall(serviceId, startDate, endDate, startTime, endTime, locationId, resourceId, resourceGroupId, resourceIds, roundRobin, duration, interval, timezoneName, tzOffset, destination, dayAvailabilityStartDate, dayAvailability, firstDayAvailable, _callback);
        Type localVarReturnType = new TypeToken<AvailabilityViewModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGet
     * @param serviceId Service Id for availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for unavailable time search (required)
     * @param endDate Format YYYY-MM-DD: End Date for unavailable time search (required)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id to filter on (optional)
     * @param duration Duration of the service if different from default (optional)
     * @param tzOffset Request timezone offset to view unavailable times (optional)
     * @param skipTimePastUnavailability Set as true to remove Time Past (TP) blocks in the response (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGetCall(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer duration, Integer tzOffset, Boolean skipTimePastUnavailability, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/consumer/v1/availability/{serviceId}/{startDate}/{endDate}/unavailable"
            .replace("{" + "serviceId" + "}", localVarApiClient.escapeString(serviceId.toString()))
            .replace("{" + "startDate" + "}", localVarApiClient.escapeString(startDate.toString()))
            .replace("{" + "endDate" + "}", localVarApiClient.escapeString(endDate.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (locationId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("locationId", locationId));
        }

        if (resourceId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("resourceId", resourceId));
        }

        if (duration != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("duration", duration));
        }

        if (tzOffset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tzOffset", tzOffset));
        }

        if (skipTimePastUnavailability != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipTimePastUnavailability", skipTimePastUnavailability));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGetValidateBeforeCall(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer duration, Integer tzOffset, Boolean skipTimePastUnavailability, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'serviceId' is set
        if (serviceId == null) {
            throw new ApiException("Missing the required parameter 'serviceId' when calling consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGet(Async)");
        }

        // verify the required parameter 'startDate' is set
        if (startDate == null) {
            throw new ApiException("Missing the required parameter 'startDate' when calling consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGet(Async)");
        }

        // verify the required parameter 'endDate' is set
        if (endDate == null) {
            throw new ApiException("Missing the required parameter 'endDate' when calling consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGet(Async)");
        }

        return consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGetCall(serviceId, startDate, endDate, locationId, resourceId, duration, tzOffset, skipTimePastUnavailability, _callback);

    }

    /**
     * Get Unavailable Times
     * &lt;p&gt;This endpoint is used to show &lt;b&gt;Unavailable&lt;/b&gt; times and provides valuable information as to why a time slot is unavailable. If you question your availability results, populate the same parameters to this endpoint to find out why.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;serviceId&lt;/b&gt; is required. The &lt;b&gt;startDate&lt;/b&gt; and &lt;b&gt;endDate&lt;/b&gt; are required and are formatted as: &lt;b&gt;YYYY-MM-DD&lt;/b&gt;&lt;/p&gt;  &lt;p&gt;Location hours, holidays, services, resources, blocks, allocations, and appointments are just some of variables that may cause time slots to become unavailable. Use this endpoint to understand why you don&#39;t see availability.&lt;/p&gt;
     * @param serviceId Service Id for availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for unavailable time search (required)
     * @param endDate Format YYYY-MM-DD: End Date for unavailable time search (required)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id to filter on (optional)
     * @param duration Duration of the service if different from default (optional)
     * @param tzOffset Request timezone offset to view unavailable times (optional)
     * @param skipTimePastUnavailability Set as true to remove Time Past (TP) blocks in the response (optional)
     * @return UnavailableTimeListViewModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public UnavailableTimeListViewModel consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGet(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer duration, Integer tzOffset, Boolean skipTimePastUnavailability) throws ApiException {
        ApiResponse<UnavailableTimeListViewModel> localVarResp = consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGetWithHttpInfo(serviceId, startDate, endDate, locationId, resourceId, duration, tzOffset, skipTimePastUnavailability);
        return localVarResp.getData();
    }

    /**
     * Get Unavailable Times
     * &lt;p&gt;This endpoint is used to show &lt;b&gt;Unavailable&lt;/b&gt; times and provides valuable information as to why a time slot is unavailable. If you question your availability results, populate the same parameters to this endpoint to find out why.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;serviceId&lt;/b&gt; is required. The &lt;b&gt;startDate&lt;/b&gt; and &lt;b&gt;endDate&lt;/b&gt; are required and are formatted as: &lt;b&gt;YYYY-MM-DD&lt;/b&gt;&lt;/p&gt;  &lt;p&gt;Location hours, holidays, services, resources, blocks, allocations, and appointments are just some of variables that may cause time slots to become unavailable. Use this endpoint to understand why you don&#39;t see availability.&lt;/p&gt;
     * @param serviceId Service Id for availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for unavailable time search (required)
     * @param endDate Format YYYY-MM-DD: End Date for unavailable time search (required)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id to filter on (optional)
     * @param duration Duration of the service if different from default (optional)
     * @param tzOffset Request timezone offset to view unavailable times (optional)
     * @param skipTimePastUnavailability Set as true to remove Time Past (TP) blocks in the response (optional)
     * @return ApiResponse&lt;UnavailableTimeListViewModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UnavailableTimeListViewModel> consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGetWithHttpInfo(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer duration, Integer tzOffset, Boolean skipTimePastUnavailability) throws ApiException {
        okhttp3.Call localVarCall = consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGetValidateBeforeCall(serviceId, startDate, endDate, locationId, resourceId, duration, tzOffset, skipTimePastUnavailability, null);
        Type localVarReturnType = new TypeToken<UnavailableTimeListViewModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Unavailable Times (asynchronously)
     * &lt;p&gt;This endpoint is used to show &lt;b&gt;Unavailable&lt;/b&gt; times and provides valuable information as to why a time slot is unavailable. If you question your availability results, populate the same parameters to this endpoint to find out why.&lt;/p&gt;  &lt;p&gt;A &lt;b&gt;serviceId&lt;/b&gt; is required. The &lt;b&gt;startDate&lt;/b&gt; and &lt;b&gt;endDate&lt;/b&gt; are required and are formatted as: &lt;b&gt;YYYY-MM-DD&lt;/b&gt;&lt;/p&gt;  &lt;p&gt;Location hours, holidays, services, resources, blocks, allocations, and appointments are just some of variables that may cause time slots to become unavailable. Use this endpoint to understand why you don&#39;t see availability.&lt;/p&gt;
     * @param serviceId Service Id for availability search (required)
     * @param startDate Format YYYY-MM-DD: Start Date for unavailable time search (required)
     * @param endDate Format YYYY-MM-DD: End Date for unavailable time search (required)
     * @param locationId Id of business location, defaults to primary business location (optional)
     * @param resourceId Resource Id to filter on (optional)
     * @param duration Duration of the service if different from default (optional)
     * @param tzOffset Request timezone offset to view unavailable times (optional)
     * @param skipTimePastUnavailability Set as true to remove Time Past (TP) blocks in the response (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGetAsync(String serviceId, OffsetDateTime startDate, OffsetDateTime endDate, String locationId, String resourceId, Integer duration, Integer tzOffset, Boolean skipTimePastUnavailability, final ApiCallback<UnavailableTimeListViewModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = consumerV1AvailabilityServiceIdStartDateEndDateUnavailableGetValidateBeforeCall(serviceId, startDate, endDate, locationId, resourceId, duration, tzOffset, skipTimePastUnavailability, _callback);
        Type localVarReturnType = new TypeToken<UnavailableTimeListViewModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
