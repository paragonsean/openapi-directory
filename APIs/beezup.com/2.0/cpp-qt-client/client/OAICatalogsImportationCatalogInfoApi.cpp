/**
 * BeezUP Merchant API 
 * # The REST API of BeezUP system ## Overview The REST APIs provide programmatic access to read and write BeezUP data.  Basically, with this API you will be able to do everything like you were with your browser on https://go.beezup.com !  The main features are: - Register and manage your account - Create and manage and share your stores with your friends/co-workers. - Import your product catalog and schedule the auto importation - Search the channels your want to use - Configure your channels for your catalogs to export your product information:     - cost and general settings     - category and columns mappings     - your will be able to create and manage your custom column     - put in place exlusion filters based on simple conditions on your product data     - override product values     - get product vision for a channel catalog scope - Analyze and optimize your performance of your catalogs on all yours channels with different type of reportings by day, channel, category and by product. - Automatize your optimisation by using rules! - And of course... Manage your orders harvested from all your marketplaces:     - Synchronize your orders in an uniformized way     - Get the available actions and update the order status - ...and more!  ## Authentication credentials The public API with the base path **_/v2/public** have been put in place to give you an entry point to our system for the user registration, login and lost password. The public API does not require any credentials. We give you the some public list of values and public channels for our public commercial web site [www.beezup.com](http://www.beezup.com).  The user API with the base path **_/v2/user** requires a token which is available on this page: https://go.beezup.com/Account/MyAccount  ## Things to keep in mind ### API Rate Limits - The BeezUP REST API is limited to 100 calls/minute.  ### Media type The default media type for requests and responses is application/json. Where noted, some operations support other content types. If no additional content type is mentioned for a specific operation, then the media type is application/json.  ### Required content type The required and default encoding for the request and responses is UTF8.  ### Required date time format All our date time are formatted in ISO 8601 format: 2014-06-24T16:25:00Z.  ### Base URL The Base URL of the BeezUP API Order Management REST API conforms to the following template.  https://api.beezup.com  All URLs returned by the BeezUP API are relative to this base URL, and all requests to the REST API must use this base URL template.  You can test our API on https://api-docs.beezup.com/swagger-ui\\\\ You can contact us on [gitter, #BeezUP/API](https://gitter.im/BeezUP/API)
 *
 * The version of the OpenAPI document: 2.0
 * Contact: help@beezup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICatalogsImportationCatalogInfoApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAICatalogsImportationCatalogInfoApi::OAICatalogsImportationCatalogInfoApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAICatalogsImportationCatalogInfoApi::~OAICatalogsImportationCatalogInfoApi() {
}

void OAICatalogsImportationCatalogInfoApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api.beezup.com"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("importationConfigureCatalogColumn", defaultConf);
    _serverIndices.insert("importationConfigureCatalogColumn", 0);
    _serverConfigs.insert("importationDeleteCustomColumn", defaultConf);
    _serverIndices.insert("importationDeleteCustomColumn", 0);
    _serverConfigs.insert("importationGetCustomColumnExpression", defaultConf);
    _serverIndices.insert("importationGetCustomColumnExpression", 0);
    _serverConfigs.insert("importationGetCustomColumns", defaultConf);
    _serverIndices.insert("importationGetCustomColumns", 0);
    _serverConfigs.insert("importationGetDetectedCatalogColumns", defaultConf);
    _serverIndices.insert("importationGetDetectedCatalogColumns", 0);
    _serverConfigs.insert("importationGetProductSample", defaultConf);
    _serverIndices.insert("importationGetProductSample", 0);
    _serverConfigs.insert("importationGetProductSampleCustomColumnValue", defaultConf);
    _serverIndices.insert("importationGetProductSampleCustomColumnValue", 0);
    _serverConfigs.insert("importationIgnoreColumn", defaultConf);
    _serverIndices.insert("importationIgnoreColumn", 0);
    _serverConfigs.insert("importationMapCatalogColumn", defaultConf);
    _serverIndices.insert("importationMapCatalogColumn", 0);
    _serverConfigs.insert("importationMapCustomColumn", defaultConf);
    _serverIndices.insert("importationMapCustomColumn", 0);
    _serverConfigs.insert("importationReattendColumn", defaultConf);
    _serverIndices.insert("importationReattendColumn", 0);
    _serverConfigs.insert("importationSaveCustomColumn", defaultConf);
    _serverIndices.insert("importationSaveCustomColumn", 0);
    _serverConfigs.insert("importationUnmapCatalogColumn", defaultConf);
    _serverIndices.insert("importationUnmapCatalogColumn", 0);
    _serverConfigs.insert("importationUnmapCustomColumn", defaultConf);
    _serverIndices.insert("importationUnmapCustomColumn", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAICatalogsImportationCatalogInfoApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAICatalogsImportationCatalogInfoApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAICatalogsImportationCatalogInfoApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAICatalogsImportationCatalogInfoApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAICatalogsImportationCatalogInfoApi::setUsername(const QString &username) {
    _username = username;
}

void OAICatalogsImportationCatalogInfoApi::setPassword(const QString &password) {
    _password = password;
}


void OAICatalogsImportationCatalogInfoApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAICatalogsImportationCatalogInfoApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAICatalogsImportationCatalogInfoApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAICatalogsImportationCatalogInfoApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAICatalogsImportationCatalogInfoApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAICatalogsImportationCatalogInfoApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAICatalogsImportationCatalogInfoApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAICatalogsImportationCatalogInfoApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAICatalogsImportationCatalogInfoApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAICatalogsImportationCatalogInfoApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAICatalogsImportationCatalogInfoApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAICatalogsImportationCatalogInfoApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAICatalogsImportationCatalogInfoApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAICatalogsImportationCatalogInfoApi::importationConfigureCatalogColumn(const QString &store_id, const QString &execution_id, const QString &column_id, const OAIConfigureCatalogColumnCatalogRequest &oai_configure_catalog_column_catalog_request) {
    QString fullPath = QString(_serverConfigs["importationConfigureCatalogColumn"][_serverIndices.value("importationConfigureCatalogColumn")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_configure_catalog_column_catalog_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationConfigureCatalogColumnCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationConfigureCatalogColumnCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationConfigureCatalogColumnSignal();
        Q_EMIT importationConfigureCatalogColumnSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationConfigureCatalogColumnSignalE(error_type, error_str);
        Q_EMIT importationConfigureCatalogColumnSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationConfigureCatalogColumnSignalError(error_type, error_str);
        Q_EMIT importationConfigureCatalogColumnSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationDeleteCustomColumn(const QString &store_id, const QString &execution_id, const QString &column_id) {
    QString fullPath = QString(_serverConfigs["importationDeleteCustomColumn"][_serverIndices.value("importationDeleteCustomColumn")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns/{columnId}");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationDeleteCustomColumnCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationDeleteCustomColumnCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationDeleteCustomColumnSignal();
        Q_EMIT importationDeleteCustomColumnSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationDeleteCustomColumnSignalE(error_type, error_str);
        Q_EMIT importationDeleteCustomColumnSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationDeleteCustomColumnSignalError(error_type, error_str);
        Q_EMIT importationDeleteCustomColumnSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationGetCustomColumnExpression(const QString &store_id, const QString &execution_id, const QString &column_id) {
    QString fullPath = QString(_serverConfigs["importationGetCustomColumnExpression"][_serverIndices.value("importationGetCustomColumnExpression")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns/{columnId}/expression");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationGetCustomColumnExpressionCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationGetCustomColumnExpressionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationGetCustomColumnExpressionSignal(output);
        Q_EMIT importationGetCustomColumnExpressionSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationGetCustomColumnExpressionSignalE(output, error_type, error_str);
        Q_EMIT importationGetCustomColumnExpressionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationGetCustomColumnExpressionSignalError(output, error_type, error_str);
        Q_EMIT importationGetCustomColumnExpressionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationGetCustomColumns(const QString &store_id, const QString &execution_id) {
    QString fullPath = QString(_serverConfigs["importationGetCustomColumns"][_serverIndices.value("importationGetCustomColumns")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationGetCustomColumnsCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationGetCustomColumnsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIImportationCustomColumnList output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationGetCustomColumnsSignal(output);
        Q_EMIT importationGetCustomColumnsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationGetCustomColumnsSignalE(output, error_type, error_str);
        Q_EMIT importationGetCustomColumnsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationGetCustomColumnsSignalError(output, error_type, error_str);
        Q_EMIT importationGetCustomColumnsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationGetDetectedCatalogColumns(const QString &store_id, const QString &execution_id) {
    QString fullPath = QString(_serverConfigs["importationGetDetectedCatalogColumns"][_serverIndices.value("importationGetDetectedCatalogColumns")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationGetDetectedCatalogColumnsCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationGetDetectedCatalogColumnsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIDetectedCatalogColumnList output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationGetDetectedCatalogColumnsSignal(output);
        Q_EMIT importationGetDetectedCatalogColumnsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationGetDetectedCatalogColumnsSignalE(output, error_type, error_str);
        Q_EMIT importationGetDetectedCatalogColumnsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationGetDetectedCatalogColumnsSignalError(output, error_type, error_str);
        Q_EMIT importationGetDetectedCatalogColumnsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationGetProductSample(const QString &store_id, const QString &execution_id, const qint32 &product_sample_index) {
    QString fullPath = QString(_serverConfigs["importationGetProductSample"][_serverIndices.value("importationGetProductSample")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/productSamples/{productSampleIndex}");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString product_sample_indexPathParam("{");
        product_sample_indexPathParam.append("productSampleIndex").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "productSampleIndex", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"productSampleIndex"+pathSuffix : pathPrefix;
        fullPath.replace(product_sample_indexPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(product_sample_index)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationGetProductSampleCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationGetProductSampleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProductSample output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationGetProductSampleSignal(output);
        Q_EMIT importationGetProductSampleSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationGetProductSampleSignalE(output, error_type, error_str);
        Q_EMIT importationGetProductSampleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationGetProductSampleSignalError(output, error_type, error_str);
        Q_EMIT importationGetProductSampleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationGetProductSampleCustomColumnValue(const QString &store_id, const QString &execution_id, const qint32 &product_sample_index, const QString &column_id) {
    QString fullPath = QString(_serverConfigs["importationGetProductSampleCustomColumnValue"][_serverIndices.value("importationGetProductSampleCustomColumnValue")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/productSamples/{productSampleIndex}/customColumns/{columnId}");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString product_sample_indexPathParam("{");
        product_sample_indexPathParam.append("productSampleIndex").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "productSampleIndex", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"productSampleIndex"+pathSuffix : pathPrefix;
        fullPath.replace(product_sample_indexPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(product_sample_index)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationGetProductSampleCustomColumnValueCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationGetProductSampleCustomColumnValueCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationGetProductSampleCustomColumnValueSignal(output);
        Q_EMIT importationGetProductSampleCustomColumnValueSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationGetProductSampleCustomColumnValueSignalE(output, error_type, error_str);
        Q_EMIT importationGetProductSampleCustomColumnValueSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationGetProductSampleCustomColumnValueSignalError(output, error_type, error_str);
        Q_EMIT importationGetProductSampleCustomColumnValueSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationIgnoreColumn(const QString &store_id, const QString &execution_id, const QString &column_id) {
    QString fullPath = QString(_serverConfigs["importationIgnoreColumn"][_serverIndices.value("importationIgnoreColumn")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}/ignore");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationIgnoreColumnCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationIgnoreColumnCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationIgnoreColumnSignal();
        Q_EMIT importationIgnoreColumnSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationIgnoreColumnSignalE(error_type, error_str);
        Q_EMIT importationIgnoreColumnSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationIgnoreColumnSignalError(error_type, error_str);
        Q_EMIT importationIgnoreColumnSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationMapCatalogColumn(const QString &store_id, const QString &execution_id, const QString &column_id, const OAIMapBeezUPColumnRequest &oai_map_beez_up_column_request) {
    QString fullPath = QString(_serverConfigs["importationMapCatalogColumn"][_serverIndices.value("importationMapCatalogColumn")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}/map");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_map_beez_up_column_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationMapCatalogColumnCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationMapCatalogColumnCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationMapCatalogColumnSignal();
        Q_EMIT importationMapCatalogColumnSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationMapCatalogColumnSignalE(error_type, error_str);
        Q_EMIT importationMapCatalogColumnSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationMapCatalogColumnSignalError(error_type, error_str);
        Q_EMIT importationMapCatalogColumnSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationMapCustomColumn(const QString &store_id, const QString &execution_id, const QString &column_id, const OAIMapBeezUPColumnRequest &oai_map_beez_up_column_request) {
    QString fullPath = QString(_serverConfigs["importationMapCustomColumn"][_serverIndices.value("importationMapCustomColumn")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns/{columnId}/map");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_map_beez_up_column_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationMapCustomColumnCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationMapCustomColumnCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationMapCustomColumnSignal();
        Q_EMIT importationMapCustomColumnSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationMapCustomColumnSignalE(error_type, error_str);
        Q_EMIT importationMapCustomColumnSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationMapCustomColumnSignalError(error_type, error_str);
        Q_EMIT importationMapCustomColumnSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationReattendColumn(const QString &store_id, const QString &execution_id, const QString &column_id) {
    QString fullPath = QString(_serverConfigs["importationReattendColumn"][_serverIndices.value("importationReattendColumn")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}/reattend");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationReattendColumnCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationReattendColumnCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationReattendColumnSignal();
        Q_EMIT importationReattendColumnSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationReattendColumnSignalE(error_type, error_str);
        Q_EMIT importationReattendColumnSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationReattendColumnSignalError(error_type, error_str);
        Q_EMIT importationReattendColumnSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationSaveCustomColumn(const QString &store_id, const QString &execution_id, const QString &column_id, const OAIChangeCustomColumnRequest &oai_change_custom_column_request) {
    QString fullPath = QString(_serverConfigs["importationSaveCustomColumn"][_serverIndices.value("importationSaveCustomColumn")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns/{columnId}");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_change_custom_column_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationSaveCustomColumnCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationSaveCustomColumnCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationSaveCustomColumnSignal();
        Q_EMIT importationSaveCustomColumnSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationSaveCustomColumnSignalE(error_type, error_str);
        Q_EMIT importationSaveCustomColumnSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationSaveCustomColumnSignalError(error_type, error_str);
        Q_EMIT importationSaveCustomColumnSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationUnmapCatalogColumn(const QString &store_id, const QString &execution_id, const QString &column_id) {
    QString fullPath = QString(_serverConfigs["importationUnmapCatalogColumn"][_serverIndices.value("importationUnmapCatalogColumn")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}/unmap");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationUnmapCatalogColumnCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationUnmapCatalogColumnCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationUnmapCatalogColumnSignal();
        Q_EMIT importationUnmapCatalogColumnSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationUnmapCatalogColumnSignalE(error_type, error_str);
        Q_EMIT importationUnmapCatalogColumnSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationUnmapCatalogColumnSignalError(error_type, error_str);
        Q_EMIT importationUnmapCatalogColumnSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::importationUnmapCustomColumn(const QString &store_id, const QString &execution_id, const QString &column_id) {
    QString fullPath = QString(_serverConfigs["importationUnmapCustomColumn"][_serverIndices.value("importationUnmapCustomColumn")].URL()+"/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns/{columnId}/unmap");
    
    
    {
        QString store_idPathParam("{");
        store_idPathParam.append("storeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "storeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"storeId"+pathSuffix : pathPrefix;
        fullPath.replace(store_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(store_id)));
    }
    
    {
        QString execution_idPathParam("{");
        execution_idPathParam.append("executionId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "executionId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"executionId"+pathSuffix : pathPrefix;
        fullPath.replace(execution_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(execution_id)));
    }
    
    {
        QString column_idPathParam("{");
        column_idPathParam.append("columnId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "columnId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"columnId"+pathSuffix : pathPrefix;
        fullPath.replace(column_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(column_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAICatalogsImportationCatalogInfoApi::importationUnmapCustomColumnCallback);
    connect(this, &OAICatalogsImportationCatalogInfoApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAICatalogsImportationCatalogInfoApi::importationUnmapCustomColumnCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT importationUnmapCustomColumnSignal();
        Q_EMIT importationUnmapCustomColumnSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT importationUnmapCustomColumnSignalE(error_type, error_str);
        Q_EMIT importationUnmapCustomColumnSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT importationUnmapCustomColumnSignalError(error_type, error_str);
        Q_EMIT importationUnmapCustomColumnSignalErrorFull(worker, error_type, error_str);
    }
}

void OAICatalogsImportationCatalogInfoApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
