/**
 * Aggregators API Service
 * Aggregators API
 *
 * The version of the OpenAPI document: 0.6-99cfdac
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAPIV2Api.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIAPIV2Api::OAIAPIV2Api(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIAPIV2Api::~OAIAPIV2Api() {
}

void OAIAPIV2Api::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api.zeno.fm"),
    "Generated server url",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("createPodcast", defaultConf);
    _serverIndices.insert("createPodcast", 0);
    _serverConfigs.insert("createPodcastEpisode", defaultConf);
    _serverIndices.insert("createPodcastEpisode", 0);
    _serverConfigs.insert("deletePodcast", defaultConf);
    _serverIndices.insert("deletePodcast", 0);
    _serverConfigs.insert("deletePodcast1", defaultConf);
    _serverIndices.insert("deletePodcast1", 0);
    _serverConfigs.insert("getPartnerAggregatorStations", defaultConf);
    _serverIndices.insert("getPartnerAggregatorStations", 0);
    _serverConfigs.insert("getPodcast", defaultConf);
    _serverIndices.insert("getPodcast", 0);
    _serverConfigs.insert("getPodcastCategories", defaultConf);
    _serverIndices.insert("getPodcastCategories", 0);
    _serverConfigs.insert("getPodcastCountries", defaultConf);
    _serverIndices.insert("getPodcastCountries", 0);
    _serverConfigs.insert("getPodcastEpisode", defaultConf);
    _serverIndices.insert("getPodcastEpisode", 0);
    _serverConfigs.insert("getPodcastEpisodes", defaultConf);
    _serverIndices.insert("getPodcastEpisodes", 0);
    _serverConfigs.insert("getPodcastLanguages", defaultConf);
    _serverIndices.insert("getPodcastLanguages", 0);
    _serverConfigs.insert("getStationCountries", defaultConf);
    _serverIndices.insert("getStationCountries", 0);
    _serverConfigs.insert("getStationGenres", defaultConf);
    _serverIndices.insert("getStationGenres", 0);
    _serverConfigs.insert("getStationLanguages", defaultConf);
    _serverIndices.insert("getStationLanguages", 0);
    _serverConfigs.insert("searchPodcasts", defaultConf);
    _serverIndices.insert("searchPodcasts", 0);
    _serverConfigs.insert("searchStations", defaultConf);
    _serverIndices.insert("searchStations", 0);
    _serverConfigs.insert("updatePodcast", defaultConf);
    _serverIndices.insert("updatePodcast", 0);
    _serverConfigs.insert("updatePodcastEpisode", defaultConf);
    _serverIndices.insert("updatePodcastEpisode", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIAPIV2Api::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIAPIV2Api::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIAPIV2Api::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIAPIV2Api::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIAPIV2Api::setUsername(const QString &username) {
    _username = username;
}

void OAIAPIV2Api::setPassword(const QString &password) {
    _password = password;
}


void OAIAPIV2Api::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIAPIV2Api::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIAPIV2Api::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIAPIV2Api::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIAPIV2Api::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIAPIV2Api::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIAPIV2Api::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIAPIV2Api::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIAPIV2Api::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIAPIV2Api::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIAPIV2Api::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIAPIV2Api::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIAPIV2Api::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIAPIV2Api::createPodcast(const OAIHttpFileElement &file_logo, const OAIPodcast &podcast) {
    QString fullPath = QString(_serverConfigs["createPodcast"][_serverIndices.value("createPodcast")].URL()+"/api/v2/podcasts/create");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_file("file_logo", file_logo.local_filename, file_logo.request_filename, file_logo.mime_type);
    }
    
    {
        input.add_var("podcast", ::OpenAPI::toStringValue(podcast));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::createPodcastCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::createPodcastCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPodcast output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createPodcastSignal(output);
        Q_EMIT createPodcastSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createPodcastSignalE(output, error_type, error_str);
        Q_EMIT createPodcastSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createPodcastSignalError(output, error_type, error_str);
        Q_EMIT createPodcastSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::createPodcastEpisode(const QString &podcast_key, const OAIPodcastEpisode &episode, const OAIHttpFileElement &file_logo, const OAIHttpFileElement &file_media) {
    QString fullPath = QString(_serverConfigs["createPodcastEpisode"][_serverIndices.value("createPodcastEpisode")].URL()+"/api/v2/podcasts/{podcastKey}/episodes/create");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    
    {
        QString podcast_keyPathParam("{");
        podcast_keyPathParam.append("podcastKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "podcastKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"podcastKey"+pathSuffix : pathPrefix;
        fullPath.replace(podcast_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(podcast_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("episode", ::OpenAPI::toStringValue(episode));
    }
    
    {
        input.add_file("file_logo", file_logo.local_filename, file_logo.request_filename, file_logo.mime_type);
    }
    
    {
        input.add_file("file_media", file_media.local_filename, file_media.request_filename, file_media.mime_type);
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::createPodcastEpisodeCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::createPodcastEpisodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPodcastEpisode output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createPodcastEpisodeSignal(output);
        Q_EMIT createPodcastEpisodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createPodcastEpisodeSignalE(output, error_type, error_str);
        Q_EMIT createPodcastEpisodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createPodcastEpisodeSignalError(output, error_type, error_str);
        Q_EMIT createPodcastEpisodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::deletePodcast(const QString &podcast_key) {
    QString fullPath = QString(_serverConfigs["deletePodcast"][_serverIndices.value("deletePodcast")].URL()+"/api/v2/podcasts/{podcastKey}");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    
    {
        QString podcast_keyPathParam("{");
        podcast_keyPathParam.append("podcastKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "podcastKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"podcastKey"+pathSuffix : pathPrefix;
        fullPath.replace(podcast_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(podcast_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::deletePodcastCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::deletePodcastCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deletePodcastSignal();
        Q_EMIT deletePodcastSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deletePodcastSignalE(error_type, error_str);
        Q_EMIT deletePodcastSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deletePodcastSignalError(error_type, error_str);
        Q_EMIT deletePodcastSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::deletePodcast1(const QString &podcast_key, const QString &episode_key) {
    QString fullPath = QString(_serverConfigs["deletePodcast1"][_serverIndices.value("deletePodcast1")].URL()+"/api/v2/podcasts/{podcastKey}/episodes/{episodeKey}");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    
    {
        QString podcast_keyPathParam("{");
        podcast_keyPathParam.append("podcastKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "podcastKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"podcastKey"+pathSuffix : pathPrefix;
        fullPath.replace(podcast_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(podcast_key)));
    }
    
    {
        QString episode_keyPathParam("{");
        episode_keyPathParam.append("episodeKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "episodeKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"episodeKey"+pathSuffix : pathPrefix;
        fullPath.replace(episode_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(episode_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::deletePodcast1Callback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::deletePodcast1Callback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deletePodcast1Signal();
        Q_EMIT deletePodcast1SignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deletePodcast1SignalE(error_type, error_str);
        Q_EMIT deletePodcast1SignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deletePodcast1SignalError(error_type, error_str);
        Q_EMIT deletePodcast1SignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getPartnerAggregatorStations(const ::OpenAPI::OptionalParam<QString> &page, const ::OpenAPI::OptionalParam<QString> &hits_per_page) {
    QString fullPath = QString(_serverConfigs["getPartnerAggregatorStations"][_serverIndices.value("getPartnerAggregatorStations")].URL()+"/api/v2/stations/list");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "page", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("page")).append(querySuffix).append(QUrl::toPercentEncoding(page.stringValue()));
    }
    if (hits_per_page.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "hitsPerPage", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("hitsPerPage")).append(querySuffix).append(QUrl::toPercentEncoding(hits_per_page.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getPartnerAggregatorStationsCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getPartnerAggregatorStationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStationList output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPartnerAggregatorStationsSignal(output);
        Q_EMIT getPartnerAggregatorStationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPartnerAggregatorStationsSignalE(output, error_type, error_str);
        Q_EMIT getPartnerAggregatorStationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPartnerAggregatorStationsSignalError(output, error_type, error_str);
        Q_EMIT getPartnerAggregatorStationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getPodcast(const QString &podcast_key) {
    QString fullPath = QString(_serverConfigs["getPodcast"][_serverIndices.value("getPodcast")].URL()+"/api/v2/podcasts/{podcastKey}");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    
    {
        QString podcast_keyPathParam("{");
        podcast_keyPathParam.append("podcastKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "podcastKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"podcastKey"+pathSuffix : pathPrefix;
        fullPath.replace(podcast_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(podcast_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getPodcastCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getPodcastCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPodcast output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPodcastSignal(output);
        Q_EMIT getPodcastSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPodcastSignalE(output, error_type, error_str);
        Q_EMIT getPodcastSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPodcastSignalError(output, error_type, error_str);
        Q_EMIT getPodcastSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getPodcastCategories() {
    QString fullPath = QString(_serverConfigs["getPodcastCategories"][_serverIndices.value("getPodcastCategories")].URL()+"/api/v2/podcasts/categories");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getPodcastCategoriesCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getPodcastCategoriesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIPodcastCategory> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIPodcastCategory val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPodcastCategoriesSignal(output);
        Q_EMIT getPodcastCategoriesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPodcastCategoriesSignalE(output, error_type, error_str);
        Q_EMIT getPodcastCategoriesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPodcastCategoriesSignalError(output, error_type, error_str);
        Q_EMIT getPodcastCategoriesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getPodcastCountries() {
    QString fullPath = QString(_serverConfigs["getPodcastCountries"][_serverIndices.value("getPodcastCountries")].URL()+"/api/v2/podcasts/countries");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getPodcastCountriesCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getPodcastCountriesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAICountry> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAICountry val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPodcastCountriesSignal(output);
        Q_EMIT getPodcastCountriesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPodcastCountriesSignalE(output, error_type, error_str);
        Q_EMIT getPodcastCountriesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPodcastCountriesSignalError(output, error_type, error_str);
        Q_EMIT getPodcastCountriesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getPodcastEpisode(const QString &podcast_key, const QString &episode_key) {
    QString fullPath = QString(_serverConfigs["getPodcastEpisode"][_serverIndices.value("getPodcastEpisode")].URL()+"/api/v2/podcasts/{podcastKey}/episodes/{episodeKey}");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    
    {
        QString podcast_keyPathParam("{");
        podcast_keyPathParam.append("podcastKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "podcastKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"podcastKey"+pathSuffix : pathPrefix;
        fullPath.replace(podcast_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(podcast_key)));
    }
    
    {
        QString episode_keyPathParam("{");
        episode_keyPathParam.append("episodeKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "episodeKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"episodeKey"+pathSuffix : pathPrefix;
        fullPath.replace(episode_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(episode_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getPodcastEpisodeCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getPodcastEpisodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPodcastEpisode output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPodcastEpisodeSignal(output);
        Q_EMIT getPodcastEpisodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPodcastEpisodeSignalE(output, error_type, error_str);
        Q_EMIT getPodcastEpisodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPodcastEpisodeSignalError(output, error_type, error_str);
        Q_EMIT getPodcastEpisodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getPodcastEpisodes(const QString &podcast_key, const ::OpenAPI::OptionalParam<QString> &limit, const ::OpenAPI::OptionalParam<QString> &offset) {
    QString fullPath = QString(_serverConfigs["getPodcastEpisodes"][_serverIndices.value("getPodcastEpisodes")].URL()+"/api/v2/podcasts/{podcastKey}/episodes");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    
    {
        QString podcast_keyPathParam("{");
        podcast_keyPathParam.append("podcastKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "podcastKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"podcastKey"+pathSuffix : pathPrefix;
        fullPath.replace(podcast_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(podcast_key)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(limit.stringValue()));
    }
    if (offset.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(offset.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getPodcastEpisodesCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getPodcastEpisodesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPodcastEpisodeList output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPodcastEpisodesSignal(output);
        Q_EMIT getPodcastEpisodesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPodcastEpisodesSignalE(output, error_type, error_str);
        Q_EMIT getPodcastEpisodesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPodcastEpisodesSignalError(output, error_type, error_str);
        Q_EMIT getPodcastEpisodesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getPodcastLanguages() {
    QString fullPath = QString(_serverConfigs["getPodcastLanguages"][_serverIndices.value("getPodcastLanguages")].URL()+"/api/v2/podcasts/languages");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getPodcastLanguagesCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getPodcastLanguagesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILanguage> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAILanguage val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPodcastLanguagesSignal(output);
        Q_EMIT getPodcastLanguagesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPodcastLanguagesSignalE(output, error_type, error_str);
        Q_EMIT getPodcastLanguagesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPodcastLanguagesSignalError(output, error_type, error_str);
        Q_EMIT getPodcastLanguagesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getStationCountries() {
    QString fullPath = QString(_serverConfigs["getStationCountries"][_serverIndices.value("getStationCountries")].URL()+"/api/v2/stations/countries");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getStationCountriesCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getStationCountriesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAICountry> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAICountry val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getStationCountriesSignal(output);
        Q_EMIT getStationCountriesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getStationCountriesSignalE(output, error_type, error_str);
        Q_EMIT getStationCountriesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getStationCountriesSignalError(output, error_type, error_str);
        Q_EMIT getStationCountriesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getStationGenres() {
    QString fullPath = QString(_serverConfigs["getStationGenres"][_serverIndices.value("getStationGenres")].URL()+"/api/v2/stations/genres");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getStationGenresCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getStationGenresCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIStationGenre> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIStationGenre val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getStationGenresSignal(output);
        Q_EMIT getStationGenresSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getStationGenresSignalE(output, error_type, error_str);
        Q_EMIT getStationGenresSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getStationGenresSignalError(output, error_type, error_str);
        Q_EMIT getStationGenresSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::getStationLanguages() {
    QString fullPath = QString(_serverConfigs["getStationLanguages"][_serverIndices.value("getStationLanguages")].URL()+"/api/v2/stations/languages");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::getStationLanguagesCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::getStationLanguagesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILanguage> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAILanguage val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getStationLanguagesSignal(output);
        Q_EMIT getStationLanguagesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getStationLanguagesSignalE(output, error_type, error_str);
        Q_EMIT getStationLanguagesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getStationLanguagesSignalError(output, error_type, error_str);
        Q_EMIT getStationLanguagesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::searchPodcasts(const OAIPodcastSearchParams &oai_podcast_search_params) {
    QString fullPath = QString(_serverConfigs["searchPodcasts"][_serverIndices.value("searchPodcasts")].URL()+"/api/v2/podcasts/search");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_podcast_search_params.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::searchPodcastsCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::searchPodcastsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPodcastSearchResults output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT searchPodcastsSignal(output);
        Q_EMIT searchPodcastsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT searchPodcastsSignalE(output, error_type, error_str);
        Q_EMIT searchPodcastsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT searchPodcastsSignalError(output, error_type, error_str);
        Q_EMIT searchPodcastsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::searchStations(const OAIStationSearchParams &oai_station_search_params) {
    QString fullPath = QString(_serverConfigs["searchStations"][_serverIndices.value("searchStations")].URL()+"/api/v2/stations/search");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_station_search_params.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::searchStationsCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::searchStationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStationSearchResults output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT searchStationsSignal(output);
        Q_EMIT searchStationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT searchStationsSignalE(output, error_type, error_str);
        Q_EMIT searchStationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT searchStationsSignalError(output, error_type, error_str);
        Q_EMIT searchStationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::updatePodcast(const QString &podcast_key, const OAIPodcast &podcast, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &file_logo) {
    QString fullPath = QString(_serverConfigs["updatePodcast"][_serverIndices.value("updatePodcast")].URL()+"/api/v2/podcasts/{podcastKey}");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    
    {
        QString podcast_keyPathParam("{");
        podcast_keyPathParam.append("podcastKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "podcastKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"podcastKey"+pathSuffix : pathPrefix;
        fullPath.replace(podcast_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(podcast_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    if (file_logo.hasValue())
    {
        input.add_file("file_logo", file_logo.value().local_filename, file_logo.value().request_filename, file_logo.value().mime_type);
    }
    
    {
        input.add_var("podcast", ::OpenAPI::toStringValue(podcast));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::updatePodcastCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::updatePodcastCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPodcast output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updatePodcastSignal(output);
        Q_EMIT updatePodcastSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updatePodcastSignalE(output, error_type, error_str);
        Q_EMIT updatePodcastSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updatePodcastSignalError(output, error_type, error_str);
        Q_EMIT updatePodcastSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::updatePodcastEpisode(const QString &podcast_key, const QString &episode_key, const OAIPodcastEpisode &episode, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &file_logo) {
    QString fullPath = QString(_serverConfigs["updatePodcastEpisode"][_serverIndices.value("updatePodcastEpisode")].URL()+"/api/v2/podcasts/{podcastKey}/episodes/{episodeKey}");
    
    if (_apiKeys.contains("API_Key")) {
        addHeaders("API_Key",_apiKeys.find("API_Key").value());
    }
    
    
    {
        QString podcast_keyPathParam("{");
        podcast_keyPathParam.append("podcastKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "podcastKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"podcastKey"+pathSuffix : pathPrefix;
        fullPath.replace(podcast_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(podcast_key)));
    }
    
    {
        QString episode_keyPathParam("{");
        episode_keyPathParam.append("episodeKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "episodeKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"episodeKey"+pathSuffix : pathPrefix;
        fullPath.replace(episode_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(episode_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    
    {
        input.add_var("episode", ::OpenAPI::toStringValue(episode));
    }
    if (file_logo.hasValue())
    {
        input.add_file("file_logo", file_logo.value().local_filename, file_logo.value().request_filename, file_logo.value().mime_type);
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIAPIV2Api::updatePodcastEpisodeCallback);
    connect(this, &OAIAPIV2Api::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIAPIV2Api::updatePodcastEpisodeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPodcastEpisode output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updatePodcastEpisodeSignal(output);
        Q_EMIT updatePodcastEpisodeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updatePodcastEpisodeSignalE(output, error_type, error_str);
        Q_EMIT updatePodcastEpisodeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updatePodcastEpisodeSignalError(output, error_type, error_str);
        Q_EMIT updatePodcastEpisodeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIAPIV2Api::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
