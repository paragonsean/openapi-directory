/**
 * Neutrino API
 * The general-purpose API
 *
 * The version of the OpenAPI document: 3.6.4
 * Contact: ops@neutrinoapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import APIError from '../model/APIError';

/**
* Imaging service.
* @module api/ImagingApi
* @version 3.6.4
*/
export default class ImagingApi {

    /**
    * Constructs a new ImagingApi. 
    * @alias module:api/ImagingApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the hTMLRender operation.
     * @callback module:api/ImagingApi~hTMLRenderCallback
     * @param {String} error Error message, if any.
     * @param {File} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * HTML Render
     * Render HTML content to PDF, JPG or PNG
     * @param {String} content The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string
     * @param {Object} opts Optional parameters
     * @param {String} [css] Inject custom CSS into the HTML. e.g. 'body { background-color: red;}'
     * @param {Number} [delay = 0)] Number of seconds to wait before rendering the page (can be useful for pages with animations etc)
     * @param {String} [footer] The footer HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}
     * @param {String} [format = 'PDF')] Which format to output, available options are: PDF, PNG, JPG
     * @param {Boolean} [grayscale = false)] Render the final document in grayscale
     * @param {String} [header] The header HTML to insert into each page. The following dynamic tags are supported: {date}, {title}, {url}, {pageNumber}, {totalPages}
     * @param {Boolean} [ignoreCertificateErrors = false)] Ignore any TLS/SSL certificate errors
     * @param {Number} [imageHeight] If rendering to an image format (PNG or JPG) use this image height (in pixels). The default is automatic which dynamically sets the image height based on the content
     * @param {Number} [imageWidth = 1024)] If rendering to an image format (PNG or JPG) use this image width (in pixels)
     * @param {Boolean} [landscape = false)] Set the document to landscape orientation
     * @param {Number} [margin = 0)] The document margin (in mm)
     * @param {Number} [marginBottom = 0)] The document bottom margin (in mm)
     * @param {Number} [marginLeft = 0)] The document left margin (in mm)
     * @param {Number} [marginRight = 0)] The document right margin (in mm)
     * @param {Number} [marginTop = 0)] The document top margin (in mm)
     * @param {Number} [pageHeight] Set the PDF page height explicitly (in mm)
     * @param {String} [pageSize = 'A4')] Set the document page size, can be one of: A0 - A9, B0 - B10, Comm10E, DLE or Letter
     * @param {Number} [pageWidth] Set the PDF page width explicitly (in mm)
     * @param {Number} [timeout = 300)] Timeout in seconds. Give up if still trying to load the HTML content after this number of seconds
     * @param {String} [title] The document title
     * @param {Number} [zoom = 1)] Set the zoom factor when rendering the page (2.0 for double size, 0.5 for half size)
     * @param {module:api/ImagingApi~hTMLRenderCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link File}
     */
    hTMLRender(content, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'content' is set
      if (content === undefined || content === null) {
        throw new Error("Missing the required parameter 'content' when calling hTMLRender");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'content': content,
        'css': opts['css'],
        'delay': opts['delay'],
        'footer': opts['footer'],
        'format': opts['format'],
        'grayscale': opts['grayscale'],
        'header': opts['header'],
        'ignore-certificate-errors': opts['ignoreCertificateErrors'],
        'image-height': opts['imageHeight'],
        'image-width': opts['imageWidth'],
        'landscape': opts['landscape'],
        'margin': opts['margin'],
        'margin-bottom': opts['marginBottom'],
        'margin-left': opts['marginLeft'],
        'margin-right': opts['marginRight'],
        'margin-top': opts['marginTop'],
        'page-height': opts['pageHeight'],
        'page-size': opts['pageSize'],
        'page-width': opts['pageWidth'],
        'timeout': opts['timeout'],
        'title': opts['title'],
        'zoom': opts['zoom']
      };

      let authNames = ['api-key', 'user-id'];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/html-render', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the imageResize operation.
     * @callback module:api/ImagingApi~imageResizeCallback
     * @param {String} error Error message, if any.
     * @param {File} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Image Resize
     * Resize an image and output as either JPEG or PNG
     * @param {String} imageUrl The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data
     * @param {Number} width The width to resize to (in px)
     * @param {Object} opts Optional parameters
     * @param {String} [bgColor = 'transparent')] The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)
     * @param {String} [format = 'png')] The output image format, can be either png or jpg
     * @param {Number} [height] The height to resize to (in px). If you don't set this field then the height will be automatic based on the requested width and image aspect ratio
     * @param {String} [resizeMode = 'scale')] The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>
     * @param {module:api/ImagingApi~imageResizeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link File}
     */
    imageResize(imageUrl, width, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'imageUrl' is set
      if (imageUrl === undefined || imageUrl === null) {
        throw new Error("Missing the required parameter 'imageUrl' when calling imageResize");
      }
      // verify the required parameter 'width' is set
      if (width === undefined || width === null) {
        throw new Error("Missing the required parameter 'width' when calling imageResize");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'bg-color': opts['bgColor'],
        'format': opts['format'],
        'height': opts['height'],
        'image-url': imageUrl,
        'resize-mode': opts['resizeMode'],
        'width': width
      };

      let authNames = ['api-key', 'user-id'];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/image-resize', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the imageWatermark operation.
     * @callback module:api/ImagingApi~imageWatermarkCallback
     * @param {String} error Error message, if any.
     * @param {File} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Image Watermark
     * Watermark one image with another image
     * @param {String} imageUrl The URL or Base64 encoded Data URL for the source image. You can also upload an image file directly using multipart/form-data
     * @param {String} watermarkUrl The URL or Base64 encoded Data URL for the watermark image. You can also upload an image file directly using multipart/form-data
     * @param {Object} opts Optional parameters
     * @param {String} [bgColor = 'transparent')] The image background color in hexadecimal notation (e.g. #0000ff). For PNG output the special value of 'transparent' can also be used. For JPG output the default is black (#000000)
     * @param {String} [format = 'png')] The output image format, can be either png or jpg
     * @param {Number} [height] If set resize the resulting image to this height (in px)
     * @param {Number} [opacity = 50)] The opacity of the watermark (0 to 100)
     * @param {String} [position = 'center')] The position of the watermark image, possible values are: <br>center, top-left, top-center, top-right, bottom-left, bottom-center, bottom-right
     * @param {String} [resizeMode = 'scale')] The resize mode to use, we support 3 main resizing modes: <ul> <li><b>scale</b><br>Resize to within the width and height specified while preserving aspect ratio. In this mode the width or height will be automatically adjusted to fit the aspect ratio</li> <li><b>pad</b><br>Resize to exactly the width and height specified while preserving aspect ratio and pad any space left over. Any padded space will be filled in with the 'bg-color' value</li> <li><b>crop</b><br>Resize to exactly the width and height specified while preserving aspect ratio and crop any space which fall outside the area. The cropping window is centered on the original image</li> </ul>
     * @param {Number} [width] If set resize the resulting image to this width (in px)
     * @param {module:api/ImagingApi~imageWatermarkCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link File}
     */
    imageWatermark(imageUrl, watermarkUrl, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'imageUrl' is set
      if (imageUrl === undefined || imageUrl === null) {
        throw new Error("Missing the required parameter 'imageUrl' when calling imageWatermark");
      }
      // verify the required parameter 'watermarkUrl' is set
      if (watermarkUrl === undefined || watermarkUrl === null) {
        throw new Error("Missing the required parameter 'watermarkUrl' when calling imageWatermark");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'bg-color': opts['bgColor'],
        'format': opts['format'],
        'height': opts['height'],
        'image-url': imageUrl,
        'opacity': opts['opacity'],
        'position': opts['position'],
        'resize-mode': opts['resizeMode'],
        'watermark-url': watermarkUrl,
        'width': opts['width']
      };

      let authNames = ['api-key', 'user-id'];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/image-watermark', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the qRCode operation.
     * @callback module:api/ImagingApi~qRCodeCallback
     * @param {String} error Error message, if any.
     * @param {File} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * QR Code
     * Generate a QR code as a PNG image
     * @param {String} content The content to encode into the QR code (e.g. a URL or a phone number)
     * @param {Object} opts Optional parameters
     * @param {String} [bgColor = '#ffffff')] The QR code background color
     * @param {String} [fgColor = '#000000')] The QR code foreground color
     * @param {Number} [height = 256)] The height of the QR code (in px)
     * @param {Number} [width = 256)] The width of the QR code (in px)
     * @param {module:api/ImagingApi~qRCodeCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link File}
     */
    qRCode(content, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'content' is set
      if (content === undefined || content === null) {
        throw new Error("Missing the required parameter 'content' when calling qRCode");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'bg-color': opts['bgColor'],
        'content': content,
        'fg-color': opts['fgColor'],
        'height': opts['height'],
        'width': opts['width']
      };

      let authNames = ['api-key', 'user-id'];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/qr-code', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
