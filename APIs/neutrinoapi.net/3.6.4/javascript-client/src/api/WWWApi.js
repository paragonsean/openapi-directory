/**
 * Neutrino API
 * The general-purpose API
 *
 * The version of the OpenAPI document: 3.6.4
 * Contact: ops@neutrinoapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import APIError from '../model/APIError';
import BrowserBotResponse from '../model/BrowserBotResponse';
import URLInfoResponse from '../model/URLInfoResponse';

/**
* WWW service.
* @module api/WWWApi
* @version 3.6.4
*/
export default class WWWApi {

    /**
    * Constructs a new WWWApi. 
    * @alias module:api/WWWApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the browserBot operation.
     * @callback module:api/WWWApi~browserBotCallback
     * @param {String} error Error message, if any.
     * @param {module:model/BrowserBotResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Browser Bot
     * Browser bot can extract content, interact with keyboard and mouse events, and execute JavaScript on a website
     * @param {String} url The URL to load
     * @param {Object} opts Optional parameters
     * @param {Number} [delay = 3)] Delay in seconds to wait before capturing any page data, executing selectors or JavaScript
     * @param {Array.<String>} [exec] Execute JavaScript on the website. This parameter accepts JavaScript as either a string containing JavaScript or for sending multiple separate statements a JSON array or POST array can also be used. If a statement returns any value it will be returned in the 'exec-results' response. You can also use the following specially defined user interaction functions: <br> <br> <div> sleep(seconds); Just wait/sleep for the specified number of seconds. <br>click('selector'); Click on the first element matching the given selector. <br>focus('selector'); Focus on the first element matching the given selector. <br>keys('characters'); Send the specified keyboard characters. Use click() or focus() first to send keys to a specific element. <br>enter(); Send the Enter key. <br>tab(); Send the Tab key. <br> </div>
     * @param {Boolean} [ignoreCertificateErrors = false)] Ignore any TLS/SSL certificate errors and load the page anyway
     * @param {String} [selector] Extract content from the page DOM using this selector. Commonly known as a CSS selector, you can find a good reference <a href=\\\"https://www.w3schools.com/cssref/css_selectors.asp\\\">here</a>
     * @param {Number} [timeout = 30)] Timeout in seconds. Give up if still trying to load the page after this number of seconds
     * @param {String} [userAgent] Override the browsers default user-agent string with this one
     * @param {module:api/WWWApi~browserBotCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/BrowserBotResponse}
     */
    browserBot(url, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'url' is set
      if (url === undefined || url === null) {
        throw new Error("Missing the required parameter 'url' when calling browserBot");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'delay': opts['delay'],
        'exec': this.apiClient.buildCollectionParam(opts['exec'], 'csv'),
        'ignore-certificate-errors': opts['ignoreCertificateErrors'],
        'selector': opts['selector'],
        'timeout': opts['timeout'],
        'url': url,
        'user-agent': opts['userAgent']
      };

      let authNames = ['api-key', 'user-id'];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = ['application/json'];
      let returnType = BrowserBotResponse;
      return this.apiClient.callApi(
        '/browser-bot', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the hTMLClean operation.
     * @callback module:api/WWWApi~hTMLCleanCallback
     * @param {String} error Error message, if any.
     * @param {File} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * HTML Clean
     * Clean and sanitize untrusted HTML
     * @param {String} content The HTML content. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string
     * @param {String} outputType The level of sanitization, possible values are: <br><b>plain-text</b>: reduce the content to plain text only (no HTML tags at all) <br><b>simple-text</b>: allow only very basic text formatting tags like b, em, i, strong, u <br><b>basic-html</b>: allow advanced text formatting and hyper links <br><b>basic-html-with-images</b>: same as basic html but also allows image tags <br><b>advanced-html</b>: same as basic html with images but also allows many more common HTML tags like table, ul, dl, pre <br>
     * @param {module:api/WWWApi~hTMLCleanCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link File}
     */
    hTMLClean(content, outputType, callback) {
      let postBody = null;
      // verify the required parameter 'content' is set
      if (content === undefined || content === null) {
        throw new Error("Missing the required parameter 'content' when calling hTMLClean");
      }
      // verify the required parameter 'outputType' is set
      if (outputType === undefined || outputType === null) {
        throw new Error("Missing the required parameter 'outputType' when calling hTMLClean");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
        'content': content,
        'output-type': outputType
      };

      let authNames = ['api-key', 'user-id'];
      let contentTypes = ['application/x-www-form-urlencoded'];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/html-clean', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the uRLInfo operation.
     * @callback module:api/WWWApi~uRLInfoCallback
     * @param {String} error Error message, if any.
     * @param {module:model/URLInfoResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * URL Info
     * Parse, analyze and retrieve content from the supplied URL
     * @param {String} url The URL to probe
     * @param {Object} opts Optional parameters
     * @param {Boolean} [fetchContent = false)] If this URL responds with html, text, json or xml then return the response. This option is useful if you want to perform further processing on the URL content (e.g. with the HTML Extract or HTML Clean APIs)
     * @param {Boolean} [ignoreCertificateErrors = false)] Ignore any TLS/SSL certificate errors and load the URL anyway
     * @param {Number} [timeout = 60)] Timeout in seconds. Give up if still trying to load the URL after this number of seconds
     * @param {Number} [retry = 0)] If the request fails for any reason try again this many times
     * @param {module:api/WWWApi~uRLInfoCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/URLInfoResponse}
     */
    uRLInfo(url, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'url' is set
      if (url === undefined || url === null) {
        throw new Error("Missing the required parameter 'url' when calling uRLInfo");
      }

      let pathParams = {
      };
      let queryParams = {
        'url': url,
        'fetch-content': opts['fetchContent'],
        'ignore-certificate-errors': opts['ignoreCertificateErrors'],
        'timeout': opts['timeout'],
        'retry': opts['retry']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['api-key', 'user-id'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = URLInfoResponse;
      return this.apiClient.callApi(
        '/url-info', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
