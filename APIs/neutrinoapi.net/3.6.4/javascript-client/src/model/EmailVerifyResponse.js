/**
 * Neutrino API
 * The general-purpose API
 *
 * The version of the OpenAPI document: 3.6.4
 * Contact: ops@neutrinoapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The EmailVerifyResponse model module.
 * @module model/EmailVerifyResponse
 * @version 3.6.4
 */
class EmailVerifyResponse {
    /**
     * Constructs a new <code>EmailVerifyResponse</code>.
     * @alias module:model/EmailVerifyResponse
     * @param domain {String} The email domain
     * @param domainError {Boolean} True if this address has a domain error (e.g. no valid mail server records)
     * @param email {String} The email address. If you have used the fix-typos option then this will be the fixed address
     * @param isCatchAll {Boolean} True if this email domain has a catch-all policy (it will accept mail for any username)
     * @param isDeferred {Boolean} True if the mail server responded with a temporary failure (either a 4xx response code or unresponsive server). You can retry this address later, we recommend waiting at least 15 minutes before retrying
     * @param isDisposable {Boolean} True if this address is a disposable, temporary or darknet related email address
     * @param isFreemail {Boolean} True if this address is a free-mail address
     * @param isPersonal {Boolean} True if this address is for a person. False if this is a role based address, e.g. admin@, help@, office@, etc.
     * @param provider {String} The email service provider domain
     * @param smtpResponse {String} The raw SMTP response message received during verification
     * @param smtpStatus {String} The SMTP verification status for the address: <br> <ul> <li>ok - SMTP verification was successful, this is a real address that can receive mail</li> <li>invalid - this is not a valid email address (has either a domain or syntax error)</li> <li>absent - this address is not registered with the email service provider</li> <li>unresponsive - the mail server(s) for this address timed-out or refused to open an SMTP connection</li> <li>unknown - sorry, we could not reliably determine the real status of this address (this address may or may not exist)</li> </ul>
     * @param syntaxError {Boolean} True if this address has a syntax error
     * @param typosFixed {Boolean} True if typos have been fixed
     * @param valid {Boolean} Is this a valid email address (syntax and domain is valid)
     * @param verified {Boolean} True if this address has passed SMTP verification. Check the smtp-status and smtp-response fields for specific verification details
     */
    constructor(domain, domainError, email, isCatchAll, isDeferred, isDisposable, isFreemail, isPersonal, provider, smtpResponse, smtpStatus, syntaxError, typosFixed, valid, verified) { 
        
        EmailVerifyResponse.initialize(this, domain, domainError, email, isCatchAll, isDeferred, isDisposable, isFreemail, isPersonal, provider, smtpResponse, smtpStatus, syntaxError, typosFixed, valid, verified);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, domain, domainError, email, isCatchAll, isDeferred, isDisposable, isFreemail, isPersonal, provider, smtpResponse, smtpStatus, syntaxError, typosFixed, valid, verified) { 
        obj['domain'] = domain;
        obj['domain-error'] = domainError;
        obj['email'] = email;
        obj['is-catch-all'] = isCatchAll;
        obj['is-deferred'] = isDeferred;
        obj['is-disposable'] = isDisposable;
        obj['is-freemail'] = isFreemail;
        obj['is-personal'] = isPersonal;
        obj['provider'] = provider;
        obj['smtp-response'] = smtpResponse;
        obj['smtp-status'] = smtpStatus;
        obj['syntax-error'] = syntaxError;
        obj['typos-fixed'] = typosFixed;
        obj['valid'] = valid;
        obj['verified'] = verified;
    }

    /**
     * Constructs a <code>EmailVerifyResponse</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/EmailVerifyResponse} obj Optional instance to populate.
     * @return {module:model/EmailVerifyResponse} The populated <code>EmailVerifyResponse</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new EmailVerifyResponse();

            if (data.hasOwnProperty('domain')) {
                obj['domain'] = ApiClient.convertToType(data['domain'], 'String');
            }
            if (data.hasOwnProperty('domain-error')) {
                obj['domain-error'] = ApiClient.convertToType(data['domain-error'], 'Boolean');
            }
            if (data.hasOwnProperty('email')) {
                obj['email'] = ApiClient.convertToType(data['email'], 'String');
            }
            if (data.hasOwnProperty('is-catch-all')) {
                obj['is-catch-all'] = ApiClient.convertToType(data['is-catch-all'], 'Boolean');
            }
            if (data.hasOwnProperty('is-deferred')) {
                obj['is-deferred'] = ApiClient.convertToType(data['is-deferred'], 'Boolean');
            }
            if (data.hasOwnProperty('is-disposable')) {
                obj['is-disposable'] = ApiClient.convertToType(data['is-disposable'], 'Boolean');
            }
            if (data.hasOwnProperty('is-freemail')) {
                obj['is-freemail'] = ApiClient.convertToType(data['is-freemail'], 'Boolean');
            }
            if (data.hasOwnProperty('is-personal')) {
                obj['is-personal'] = ApiClient.convertToType(data['is-personal'], 'Boolean');
            }
            if (data.hasOwnProperty('provider')) {
                obj['provider'] = ApiClient.convertToType(data['provider'], 'String');
            }
            if (data.hasOwnProperty('smtp-response')) {
                obj['smtp-response'] = ApiClient.convertToType(data['smtp-response'], 'String');
            }
            if (data.hasOwnProperty('smtp-status')) {
                obj['smtp-status'] = ApiClient.convertToType(data['smtp-status'], 'String');
            }
            if (data.hasOwnProperty('syntax-error')) {
                obj['syntax-error'] = ApiClient.convertToType(data['syntax-error'], 'Boolean');
            }
            if (data.hasOwnProperty('typos-fixed')) {
                obj['typos-fixed'] = ApiClient.convertToType(data['typos-fixed'], 'Boolean');
            }
            if (data.hasOwnProperty('valid')) {
                obj['valid'] = ApiClient.convertToType(data['valid'], 'Boolean');
            }
            if (data.hasOwnProperty('verified')) {
                obj['verified'] = ApiClient.convertToType(data['verified'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>EmailVerifyResponse</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>EmailVerifyResponse</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of EmailVerifyResponse.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['domain'] && !(typeof data['domain'] === 'string' || data['domain'] instanceof String)) {
            throw new Error("Expected the field `domain` to be a primitive type in the JSON string but got " + data['domain']);
        }
        // ensure the json data is a string
        if (data['email'] && !(typeof data['email'] === 'string' || data['email'] instanceof String)) {
            throw new Error("Expected the field `email` to be a primitive type in the JSON string but got " + data['email']);
        }
        // ensure the json data is a string
        if (data['provider'] && !(typeof data['provider'] === 'string' || data['provider'] instanceof String)) {
            throw new Error("Expected the field `provider` to be a primitive type in the JSON string but got " + data['provider']);
        }
        // ensure the json data is a string
        if (data['smtp-response'] && !(typeof data['smtp-response'] === 'string' || data['smtp-response'] instanceof String)) {
            throw new Error("Expected the field `smtp-response` to be a primitive type in the JSON string but got " + data['smtp-response']);
        }
        // ensure the json data is a string
        if (data['smtp-status'] && !(typeof data['smtp-status'] === 'string' || data['smtp-status'] instanceof String)) {
            throw new Error("Expected the field `smtp-status` to be a primitive type in the JSON string but got " + data['smtp-status']);
        }

        return true;
    }


}

EmailVerifyResponse.RequiredProperties = ["domain", "domain-error", "email", "is-catch-all", "is-deferred", "is-disposable", "is-freemail", "is-personal", "provider", "smtp-response", "smtp-status", "syntax-error", "typos-fixed", "valid", "verified"];

/**
 * The email domain
 * @member {String} domain
 */
EmailVerifyResponse.prototype['domain'] = undefined;

/**
 * True if this address has a domain error (e.g. no valid mail server records)
 * @member {Boolean} domain-error
 */
EmailVerifyResponse.prototype['domain-error'] = undefined;

/**
 * The email address. If you have used the fix-typos option then this will be the fixed address
 * @member {String} email
 */
EmailVerifyResponse.prototype['email'] = undefined;

/**
 * True if this email domain has a catch-all policy (it will accept mail for any username)
 * @member {Boolean} is-catch-all
 */
EmailVerifyResponse.prototype['is-catch-all'] = undefined;

/**
 * True if the mail server responded with a temporary failure (either a 4xx response code or unresponsive server). You can retry this address later, we recommend waiting at least 15 minutes before retrying
 * @member {Boolean} is-deferred
 */
EmailVerifyResponse.prototype['is-deferred'] = undefined;

/**
 * True if this address is a disposable, temporary or darknet related email address
 * @member {Boolean} is-disposable
 */
EmailVerifyResponse.prototype['is-disposable'] = undefined;

/**
 * True if this address is a free-mail address
 * @member {Boolean} is-freemail
 */
EmailVerifyResponse.prototype['is-freemail'] = undefined;

/**
 * True if this address is for a person. False if this is a role based address, e.g. admin@, help@, office@, etc.
 * @member {Boolean} is-personal
 */
EmailVerifyResponse.prototype['is-personal'] = undefined;

/**
 * The email service provider domain
 * @member {String} provider
 */
EmailVerifyResponse.prototype['provider'] = undefined;

/**
 * The raw SMTP response message received during verification
 * @member {String} smtp-response
 */
EmailVerifyResponse.prototype['smtp-response'] = undefined;

/**
 * The SMTP verification status for the address: <br> <ul> <li>ok - SMTP verification was successful, this is a real address that can receive mail</li> <li>invalid - this is not a valid email address (has either a domain or syntax error)</li> <li>absent - this address is not registered with the email service provider</li> <li>unresponsive - the mail server(s) for this address timed-out or refused to open an SMTP connection</li> <li>unknown - sorry, we could not reliably determine the real status of this address (this address may or may not exist)</li> </ul>
 * @member {String} smtp-status
 */
EmailVerifyResponse.prototype['smtp-status'] = undefined;

/**
 * True if this address has a syntax error
 * @member {Boolean} syntax-error
 */
EmailVerifyResponse.prototype['syntax-error'] = undefined;

/**
 * True if typos have been fixed
 * @member {Boolean} typos-fixed
 */
EmailVerifyResponse.prototype['typos-fixed'] = undefined;

/**
 * Is this a valid email address (syntax and domain is valid)
 * @member {Boolean} valid
 */
EmailVerifyResponse.prototype['valid'] = undefined;

/**
 * True if this address has passed SMTP verification. Check the smtp-status and smtp-response fields for specific verification details
 * @member {Boolean} verified
 */
EmailVerifyResponse.prototype['verified'] = undefined;






export default EmailVerifyResponse;

