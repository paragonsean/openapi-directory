/**
 * Neutrino API
 * The general-purpose API
 *
 * The version of the OpenAPI document: 3.6.4
 * Contact: ops@neutrinoapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Timezone from './Timezone';

/**
 * The GeocodeReverseResponse model module.
 * @module model/GeocodeReverseResponse
 * @version 3.6.4
 */
class GeocodeReverseResponse {
    /**
     * Constructs a new <code>GeocodeReverseResponse</code>.
     * @alias module:model/GeocodeReverseResponse
     * @param address {String} The complete address using comma-separated values
     * @param addressComponents {Object.<String, String>} The components which make up the address such as road, city, state, etc
     * @param city {String} The city of the location
     * @param country {String} The country of the location
     * @param countryCode {String} The ISO 2-letter country code of the location
     * @param countryCode3 {String} The ISO 3-letter country code of the location
     * @param currencyCode {String} ISO 4217 currency code associated with the country
     * @param found {Boolean} True if these coordinates map to a real location
     * @param latitude {Number} The location latitude
     * @param locationTags {Array.<String>} Array of strings containing any location tags associated with the address. Tags are additional pieces of metadata about a specific location, there are thousands of different tags. Some examples of tags: shop, office, cafe, bank, pub
     * @param locationType {String} The detected location type ordered roughly from most to least precise, possible values are: <br> <ul> <li>address - indicates a precise street address</li> <li>street - accurate to the street level but may not point to the exact location of the house/building number</li> <li>city - accurate to the city level, this includes villages, towns, suburbs, etc</li> <li>postal-code - indicates a postal code area (no house or street information present)</li> <li>railway - location is part of a rail network such as a station or railway track</li> <li>natural - indicates a natural feature, for example a mountain peak or a waterway</li> <li>island - location is an island or archipelago</li> <li>administrative - indicates an administrative boundary such as a country, state or province</li> </ul>
     * @param longitude {Number} The location longitude
     * @param postalAddress {String} The formatted address using local standards suitable for printing on an envelope
     * @param postalCode {String} The postal code for the location
     * @param regionCode {String} The ISO 3166-2 region code for the location
     * @param state {String} The state of the location
     * @param timezone {Object.<String, module:model/Timezone>} Map containing timezone details for the location
     */
    constructor(address, addressComponents, city, country, countryCode, countryCode3, currencyCode, found, latitude, locationTags, locationType, longitude, postalAddress, postalCode, regionCode, state, timezone) { 
        
        GeocodeReverseResponse.initialize(this, address, addressComponents, city, country, countryCode, countryCode3, currencyCode, found, latitude, locationTags, locationType, longitude, postalAddress, postalCode, regionCode, state, timezone);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, address, addressComponents, city, country, countryCode, countryCode3, currencyCode, found, latitude, locationTags, locationType, longitude, postalAddress, postalCode, regionCode, state, timezone) { 
        obj['address'] = address;
        obj['address-components'] = addressComponents;
        obj['city'] = city;
        obj['country'] = country;
        obj['country-code'] = countryCode;
        obj['country-code3'] = countryCode3;
        obj['currency-code'] = currencyCode;
        obj['found'] = found;
        obj['latitude'] = latitude;
        obj['location-tags'] = locationTags;
        obj['location-type'] = locationType;
        obj['longitude'] = longitude;
        obj['postal-address'] = postalAddress;
        obj['postal-code'] = postalCode;
        obj['region-code'] = regionCode;
        obj['state'] = state;
        obj['timezone'] = timezone;
    }

    /**
     * Constructs a <code>GeocodeReverseResponse</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/GeocodeReverseResponse} obj Optional instance to populate.
     * @return {module:model/GeocodeReverseResponse} The populated <code>GeocodeReverseResponse</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new GeocodeReverseResponse();

            if (data.hasOwnProperty('address')) {
                obj['address'] = ApiClient.convertToType(data['address'], 'String');
            }
            if (data.hasOwnProperty('address-components')) {
                obj['address-components'] = ApiClient.convertToType(data['address-components'], {'String': 'String'});
            }
            if (data.hasOwnProperty('city')) {
                obj['city'] = ApiClient.convertToType(data['city'], 'String');
            }
            if (data.hasOwnProperty('country')) {
                obj['country'] = ApiClient.convertToType(data['country'], 'String');
            }
            if (data.hasOwnProperty('country-code')) {
                obj['country-code'] = ApiClient.convertToType(data['country-code'], 'String');
            }
            if (data.hasOwnProperty('country-code3')) {
                obj['country-code3'] = ApiClient.convertToType(data['country-code3'], 'String');
            }
            if (data.hasOwnProperty('currency-code')) {
                obj['currency-code'] = ApiClient.convertToType(data['currency-code'], 'String');
            }
            if (data.hasOwnProperty('found')) {
                obj['found'] = ApiClient.convertToType(data['found'], 'Boolean');
            }
            if (data.hasOwnProperty('latitude')) {
                obj['latitude'] = ApiClient.convertToType(data['latitude'], 'Number');
            }
            if (data.hasOwnProperty('location-tags')) {
                obj['location-tags'] = ApiClient.convertToType(data['location-tags'], ['String']);
            }
            if (data.hasOwnProperty('location-type')) {
                obj['location-type'] = ApiClient.convertToType(data['location-type'], 'String');
            }
            if (data.hasOwnProperty('longitude')) {
                obj['longitude'] = ApiClient.convertToType(data['longitude'], 'Number');
            }
            if (data.hasOwnProperty('postal-address')) {
                obj['postal-address'] = ApiClient.convertToType(data['postal-address'], 'String');
            }
            if (data.hasOwnProperty('postal-code')) {
                obj['postal-code'] = ApiClient.convertToType(data['postal-code'], 'String');
            }
            if (data.hasOwnProperty('region-code')) {
                obj['region-code'] = ApiClient.convertToType(data['region-code'], 'String');
            }
            if (data.hasOwnProperty('state')) {
                obj['state'] = ApiClient.convertToType(data['state'], 'String');
            }
            if (data.hasOwnProperty('timezone')) {
                obj['timezone'] = ApiClient.convertToType(data['timezone'], {'String': Timezone});
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>GeocodeReverseResponse</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>GeocodeReverseResponse</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of GeocodeReverseResponse.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['address'] && !(typeof data['address'] === 'string' || data['address'] instanceof String)) {
            throw new Error("Expected the field `address` to be a primitive type in the JSON string but got " + data['address']);
        }
        // ensure the json data is a string
        if (data['city'] && !(typeof data['city'] === 'string' || data['city'] instanceof String)) {
            throw new Error("Expected the field `city` to be a primitive type in the JSON string but got " + data['city']);
        }
        // ensure the json data is a string
        if (data['country'] && !(typeof data['country'] === 'string' || data['country'] instanceof String)) {
            throw new Error("Expected the field `country` to be a primitive type in the JSON string but got " + data['country']);
        }
        // ensure the json data is a string
        if (data['country-code'] && !(typeof data['country-code'] === 'string' || data['country-code'] instanceof String)) {
            throw new Error("Expected the field `country-code` to be a primitive type in the JSON string but got " + data['country-code']);
        }
        // ensure the json data is a string
        if (data['country-code3'] && !(typeof data['country-code3'] === 'string' || data['country-code3'] instanceof String)) {
            throw new Error("Expected the field `country-code3` to be a primitive type in the JSON string but got " + data['country-code3']);
        }
        // ensure the json data is a string
        if (data['currency-code'] && !(typeof data['currency-code'] === 'string' || data['currency-code'] instanceof String)) {
            throw new Error("Expected the field `currency-code` to be a primitive type in the JSON string but got " + data['currency-code']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['location-tags'])) {
            throw new Error("Expected the field `location-tags` to be an array in the JSON data but got " + data['location-tags']);
        }
        // ensure the json data is a string
        if (data['location-type'] && !(typeof data['location-type'] === 'string' || data['location-type'] instanceof String)) {
            throw new Error("Expected the field `location-type` to be a primitive type in the JSON string but got " + data['location-type']);
        }
        // ensure the json data is a string
        if (data['postal-address'] && !(typeof data['postal-address'] === 'string' || data['postal-address'] instanceof String)) {
            throw new Error("Expected the field `postal-address` to be a primitive type in the JSON string but got " + data['postal-address']);
        }
        // ensure the json data is a string
        if (data['postal-code'] && !(typeof data['postal-code'] === 'string' || data['postal-code'] instanceof String)) {
            throw new Error("Expected the field `postal-code` to be a primitive type in the JSON string but got " + data['postal-code']);
        }
        // ensure the json data is a string
        if (data['region-code'] && !(typeof data['region-code'] === 'string' || data['region-code'] instanceof String)) {
            throw new Error("Expected the field `region-code` to be a primitive type in the JSON string but got " + data['region-code']);
        }
        // ensure the json data is a string
        if (data['state'] && !(typeof data['state'] === 'string' || data['state'] instanceof String)) {
            throw new Error("Expected the field `state` to be a primitive type in the JSON string but got " + data['state']);
        }

        return true;
    }


}

GeocodeReverseResponse.RequiredProperties = ["address", "address-components", "city", "country", "country-code", "country-code3", "currency-code", "found", "latitude", "location-tags", "location-type", "longitude", "postal-address", "postal-code", "region-code", "state", "timezone"];

/**
 * The complete address using comma-separated values
 * @member {String} address
 */
GeocodeReverseResponse.prototype['address'] = undefined;

/**
 * The components which make up the address such as road, city, state, etc
 * @member {Object.<String, String>} address-components
 */
GeocodeReverseResponse.prototype['address-components'] = undefined;

/**
 * The city of the location
 * @member {String} city
 */
GeocodeReverseResponse.prototype['city'] = undefined;

/**
 * The country of the location
 * @member {String} country
 */
GeocodeReverseResponse.prototype['country'] = undefined;

/**
 * The ISO 2-letter country code of the location
 * @member {String} country-code
 */
GeocodeReverseResponse.prototype['country-code'] = undefined;

/**
 * The ISO 3-letter country code of the location
 * @member {String} country-code3
 */
GeocodeReverseResponse.prototype['country-code3'] = undefined;

/**
 * ISO 4217 currency code associated with the country
 * @member {String} currency-code
 */
GeocodeReverseResponse.prototype['currency-code'] = undefined;

/**
 * True if these coordinates map to a real location
 * @member {Boolean} found
 */
GeocodeReverseResponse.prototype['found'] = undefined;

/**
 * The location latitude
 * @member {Number} latitude
 */
GeocodeReverseResponse.prototype['latitude'] = undefined;

/**
 * Array of strings containing any location tags associated with the address. Tags are additional pieces of metadata about a specific location, there are thousands of different tags. Some examples of tags: shop, office, cafe, bank, pub
 * @member {Array.<String>} location-tags
 */
GeocodeReverseResponse.prototype['location-tags'] = undefined;

/**
 * The detected location type ordered roughly from most to least precise, possible values are: <br> <ul> <li>address - indicates a precise street address</li> <li>street - accurate to the street level but may not point to the exact location of the house/building number</li> <li>city - accurate to the city level, this includes villages, towns, suburbs, etc</li> <li>postal-code - indicates a postal code area (no house or street information present)</li> <li>railway - location is part of a rail network such as a station or railway track</li> <li>natural - indicates a natural feature, for example a mountain peak or a waterway</li> <li>island - location is an island or archipelago</li> <li>administrative - indicates an administrative boundary such as a country, state or province</li> </ul>
 * @member {String} location-type
 */
GeocodeReverseResponse.prototype['location-type'] = undefined;

/**
 * The location longitude
 * @member {Number} longitude
 */
GeocodeReverseResponse.prototype['longitude'] = undefined;

/**
 * The formatted address using local standards suitable for printing on an envelope
 * @member {String} postal-address
 */
GeocodeReverseResponse.prototype['postal-address'] = undefined;

/**
 * The postal code for the location
 * @member {String} postal-code
 */
GeocodeReverseResponse.prototype['postal-code'] = undefined;

/**
 * The ISO 3166-2 region code for the location
 * @member {String} region-code
 */
GeocodeReverseResponse.prototype['region-code'] = undefined;

/**
 * The state of the location
 * @member {String} state
 */
GeocodeReverseResponse.prototype['state'] = undefined;

/**
 * Map containing timezone details for the location
 * @member {Object.<String, module:model/Timezone>} timezone
 */
GeocodeReverseResponse.prototype['timezone'] = undefined;






export default GeocodeReverseResponse;

