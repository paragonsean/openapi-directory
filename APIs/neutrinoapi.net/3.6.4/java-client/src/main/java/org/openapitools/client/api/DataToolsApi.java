/*
 * Neutrino API
 * The general-purpose API
 *
 * The version of the OpenAPI document: 3.6.4
 * Contact: ops@neutrinoapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.APIError;
import org.openapitools.client.model.BadWordFilterResponse;
import org.openapitools.client.model.EmailValidateResponse;
import org.openapitools.client.model.PhoneValidateResponse;
import org.openapitools.client.model.UALookupResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DataToolsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DataToolsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DataToolsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for badWordFilter
     * @param content The content to scan. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
     * @param catalog Which catalog of bad words to use, we currently maintain two bad word catalogs: &lt;br&gt; &lt;ul&gt; &lt;li&gt;strict - the largest database of bad words which includes profanity, obscenity, sexual, rude, cuss, dirty, swear and objectionable words and phrases. This catalog is suitable for environments of all ages including educational or children&#39;s content&lt;/li&gt; &lt;li&gt;obscene - like the strict catalog but does not include any mild profanities, idiomatic phrases or words which are considered formal terminology. This catalog is suitable for adult environments where certain types of bad words are considered OK&lt;/li&gt; &lt;/ul&gt; (optional, default to strict)
     * @param censorCharacter The character to use to censor out the bad words found (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call badWordFilterCall(String content, String catalog, String censorCharacter, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/bad-word-filter";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (catalog != null) {
            localVarFormParams.put("catalog", catalog);
        }

        if (censorCharacter != null) {
            localVarFormParams.put("censor-character", censorCharacter);
        }

        if (content != null) {
            localVarFormParams.put("content", content);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api-key", "user-id" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call badWordFilterValidateBeforeCall(String content, String catalog, String censorCharacter, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'content' is set
        if (content == null) {
            throw new ApiException("Missing the required parameter 'content' when calling badWordFilter(Async)");
        }

        return badWordFilterCall(content, catalog, censorCharacter, _callback);

    }

    /**
     * Bad Word Filter
     * Detect bad words, swear words and profanity in a given text
     * @param content The content to scan. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
     * @param catalog Which catalog of bad words to use, we currently maintain two bad word catalogs: &lt;br&gt; &lt;ul&gt; &lt;li&gt;strict - the largest database of bad words which includes profanity, obscenity, sexual, rude, cuss, dirty, swear and objectionable words and phrases. This catalog is suitable for environments of all ages including educational or children&#39;s content&lt;/li&gt; &lt;li&gt;obscene - like the strict catalog but does not include any mild profanities, idiomatic phrases or words which are considered formal terminology. This catalog is suitable for adult environments where certain types of bad words are considered OK&lt;/li&gt; &lt;/ul&gt; (optional, default to strict)
     * @param censorCharacter The character to use to censor out the bad words found (optional)
     * @return BadWordFilterResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public BadWordFilterResponse badWordFilter(String content, String catalog, String censorCharacter) throws ApiException {
        ApiResponse<BadWordFilterResponse> localVarResp = badWordFilterWithHttpInfo(content, catalog, censorCharacter);
        return localVarResp.getData();
    }

    /**
     * Bad Word Filter
     * Detect bad words, swear words and profanity in a given text
     * @param content The content to scan. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
     * @param catalog Which catalog of bad words to use, we currently maintain two bad word catalogs: &lt;br&gt; &lt;ul&gt; &lt;li&gt;strict - the largest database of bad words which includes profanity, obscenity, sexual, rude, cuss, dirty, swear and objectionable words and phrases. This catalog is suitable for environments of all ages including educational or children&#39;s content&lt;/li&gt; &lt;li&gt;obscene - like the strict catalog but does not include any mild profanities, idiomatic phrases or words which are considered formal terminology. This catalog is suitable for adult environments where certain types of bad words are considered OK&lt;/li&gt; &lt;/ul&gt; (optional, default to strict)
     * @param censorCharacter The character to use to censor out the bad words found (optional)
     * @return ApiResponse&lt;BadWordFilterResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BadWordFilterResponse> badWordFilterWithHttpInfo(String content, String catalog, String censorCharacter) throws ApiException {
        okhttp3.Call localVarCall = badWordFilterValidateBeforeCall(content, catalog, censorCharacter, null);
        Type localVarReturnType = new TypeToken<BadWordFilterResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Bad Word Filter (asynchronously)
     * Detect bad words, swear words and profanity in a given text
     * @param content The content to scan. This can be either a URL to load from, a file upload (multipart/form-data) or an HTML content string (required)
     * @param catalog Which catalog of bad words to use, we currently maintain two bad word catalogs: &lt;br&gt; &lt;ul&gt; &lt;li&gt;strict - the largest database of bad words which includes profanity, obscenity, sexual, rude, cuss, dirty, swear and objectionable words and phrases. This catalog is suitable for environments of all ages including educational or children&#39;s content&lt;/li&gt; &lt;li&gt;obscene - like the strict catalog but does not include any mild profanities, idiomatic phrases or words which are considered formal terminology. This catalog is suitable for adult environments where certain types of bad words are considered OK&lt;/li&gt; &lt;/ul&gt; (optional, default to strict)
     * @param censorCharacter The character to use to censor out the bad words found (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call badWordFilterAsync(String content, String catalog, String censorCharacter, final ApiCallback<BadWordFilterResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = badWordFilterValidateBeforeCall(content, catalog, censorCharacter, _callback);
        Type localVarReturnType = new TypeToken<BadWordFilterResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for emailValidate
     * @param email An email address (required)
     * @param fixTypos Automatically attempt to fix typos in the address (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call emailValidateCall(String email, Boolean fixTypos, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/email-validate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (email != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("email", email));
        }

        if (fixTypos != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fix-typos", fixTypos));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api-key", "user-id" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call emailValidateValidateBeforeCall(String email, Boolean fixTypos, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'email' is set
        if (email == null) {
            throw new ApiException("Missing the required parameter 'email' when calling emailValidate(Async)");
        }

        return emailValidateCall(email, fixTypos, _callback);

    }

    /**
     * Email Validate
     * Parse, validate and clean an email address
     * @param email An email address (required)
     * @param fixTypos Automatically attempt to fix typos in the address (optional, default to false)
     * @return EmailValidateResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public EmailValidateResponse emailValidate(String email, Boolean fixTypos) throws ApiException {
        ApiResponse<EmailValidateResponse> localVarResp = emailValidateWithHttpInfo(email, fixTypos);
        return localVarResp.getData();
    }

    /**
     * Email Validate
     * Parse, validate and clean an email address
     * @param email An email address (required)
     * @param fixTypos Automatically attempt to fix typos in the address (optional, default to false)
     * @return ApiResponse&lt;EmailValidateResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<EmailValidateResponse> emailValidateWithHttpInfo(String email, Boolean fixTypos) throws ApiException {
        okhttp3.Call localVarCall = emailValidateValidateBeforeCall(email, fixTypos, null);
        Type localVarReturnType = new TypeToken<EmailValidateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Email Validate (asynchronously)
     * Parse, validate and clean an email address
     * @param email An email address (required)
     * @param fixTypos Automatically attempt to fix typos in the address (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call emailValidateAsync(String email, Boolean fixTypos, final ApiCallback<EmailValidateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = emailValidateValidateBeforeCall(email, fixTypos, _callback);
        Type localVarReturnType = new TypeToken<EmailValidateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for phoneValidate
     * @param number A phone number. This can be in international format (E.164) or local format. If passing local format you must also set either the &#39;country-code&#39; OR &#39;ip&#39; options as well (required)
     * @param countryCode ISO 2-letter country code, assume numbers are based in this country. If not set numbers are assumed to be in international format (with or without the leading + sign) (optional)
     * @param ip Pass in a users IP address and we will assume numbers are based in the country of the IP address (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call phoneValidateCall(String number, String countryCode, String ip, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/phone-validate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (number != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("number", number));
        }

        if (countryCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country-code", countryCode));
        }

        if (ip != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ip", ip));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api-key", "user-id" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call phoneValidateValidateBeforeCall(String number, String countryCode, String ip, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'number' is set
        if (number == null) {
            throw new ApiException("Missing the required parameter 'number' when calling phoneValidate(Async)");
        }

        return phoneValidateCall(number, countryCode, ip, _callback);

    }

    /**
     * Phone Validate
     * Parse, validate and get location information about a phone number
     * @param number A phone number. This can be in international format (E.164) or local format. If passing local format you must also set either the &#39;country-code&#39; OR &#39;ip&#39; options as well (required)
     * @param countryCode ISO 2-letter country code, assume numbers are based in this country. If not set numbers are assumed to be in international format (with or without the leading + sign) (optional)
     * @param ip Pass in a users IP address and we will assume numbers are based in the country of the IP address (optional)
     * @return PhoneValidateResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public PhoneValidateResponse phoneValidate(String number, String countryCode, String ip) throws ApiException {
        ApiResponse<PhoneValidateResponse> localVarResp = phoneValidateWithHttpInfo(number, countryCode, ip);
        return localVarResp.getData();
    }

    /**
     * Phone Validate
     * Parse, validate and get location information about a phone number
     * @param number A phone number. This can be in international format (E.164) or local format. If passing local format you must also set either the &#39;country-code&#39; OR &#39;ip&#39; options as well (required)
     * @param countryCode ISO 2-letter country code, assume numbers are based in this country. If not set numbers are assumed to be in international format (with or without the leading + sign) (optional)
     * @param ip Pass in a users IP address and we will assume numbers are based in the country of the IP address (optional)
     * @return ApiResponse&lt;PhoneValidateResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PhoneValidateResponse> phoneValidateWithHttpInfo(String number, String countryCode, String ip) throws ApiException {
        okhttp3.Call localVarCall = phoneValidateValidateBeforeCall(number, countryCode, ip, null);
        Type localVarReturnType = new TypeToken<PhoneValidateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Phone Validate (asynchronously)
     * Parse, validate and get location information about a phone number
     * @param number A phone number. This can be in international format (E.164) or local format. If passing local format you must also set either the &#39;country-code&#39; OR &#39;ip&#39; options as well (required)
     * @param countryCode ISO 2-letter country code, assume numbers are based in this country. If not set numbers are assumed to be in international format (with or without the leading + sign) (optional)
     * @param ip Pass in a users IP address and we will assume numbers are based in the country of the IP address (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call phoneValidateAsync(String number, String countryCode, String ip, final ApiCallback<PhoneValidateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = phoneValidateValidateBeforeCall(number, countryCode, ip, _callback);
        Type localVarReturnType = new TypeToken<PhoneValidateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for uALookup
     * @param ua The user-agent string to lookup. For client hints use the &#39;UA&#39; header or the JSON data directly from &#39;navigator.userAgentData.brands&#39; or &#39;navigator.userAgentData.getHighEntropyValues()&#39; (required)
     * @param uaVersion For client hints this corresponds to the &#39;UA-Full-Version&#39; header or &#39;uaFullVersion&#39; from NavigatorUAData (optional)
     * @param uaPlatform For client hints this corresponds to the &#39;UA-Platform&#39; header or &#39;platform&#39; from NavigatorUAData (optional)
     * @param uaPlatformVersion For client hints this corresponds to the &#39;UA-Platform-Version&#39; header or &#39;platformVersion&#39; from NavigatorUAData (optional)
     * @param uaMobile For client hints this corresponds to the &#39;UA-Mobile&#39; header or &#39;mobile&#39; from NavigatorUAData (optional)
     * @param deviceModel For client hints this corresponds to the &#39;UA-Model&#39; header or &#39;model&#39; from NavigatorUAData. &lt;br&gt;You can also use this parameter to lookup a device directly by its model name, model code or hardware code, on android you can get the model name from: https://developer.android.com/reference/android/os/Build.html#MODEL (optional)
     * @param deviceBrand This parameter is only used in combination with &#39;device-model&#39; when doing direct device lookups without any user-agent data. Set this to the brand or manufacturer name, this is required for accurate device detection with ambiguous model names. On android you can get the device brand from: https://developer.android.com/reference/android/os/Build#MANUFACTURER (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call uALookupCall(String ua, String uaVersion, String uaPlatform, String uaPlatformVersion, String uaMobile, String deviceModel, String deviceBrand, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/ua-lookup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (ua != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ua", ua));
        }

        if (uaVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ua-version", uaVersion));
        }

        if (uaPlatform != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ua-platform", uaPlatform));
        }

        if (uaPlatformVersion != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ua-platform-version", uaPlatformVersion));
        }

        if (uaMobile != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ua-mobile", uaMobile));
        }

        if (deviceModel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("device-model", deviceModel));
        }

        if (deviceBrand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("device-brand", deviceBrand));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api-key", "user-id" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uALookupValidateBeforeCall(String ua, String uaVersion, String uaPlatform, String uaPlatformVersion, String uaMobile, String deviceModel, String deviceBrand, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ua' is set
        if (ua == null) {
            throw new ApiException("Missing the required parameter 'ua' when calling uALookup(Async)");
        }

        return uALookupCall(ua, uaVersion, uaPlatform, uaPlatformVersion, uaMobile, deviceModel, deviceBrand, _callback);

    }

    /**
     * UA Lookup
     * Parse, validate and get detailed user-agent information from a user agent string or from client hints
     * @param ua The user-agent string to lookup. For client hints use the &#39;UA&#39; header or the JSON data directly from &#39;navigator.userAgentData.brands&#39; or &#39;navigator.userAgentData.getHighEntropyValues()&#39; (required)
     * @param uaVersion For client hints this corresponds to the &#39;UA-Full-Version&#39; header or &#39;uaFullVersion&#39; from NavigatorUAData (optional)
     * @param uaPlatform For client hints this corresponds to the &#39;UA-Platform&#39; header or &#39;platform&#39; from NavigatorUAData (optional)
     * @param uaPlatformVersion For client hints this corresponds to the &#39;UA-Platform-Version&#39; header or &#39;platformVersion&#39; from NavigatorUAData (optional)
     * @param uaMobile For client hints this corresponds to the &#39;UA-Mobile&#39; header or &#39;mobile&#39; from NavigatorUAData (optional)
     * @param deviceModel For client hints this corresponds to the &#39;UA-Model&#39; header or &#39;model&#39; from NavigatorUAData. &lt;br&gt;You can also use this parameter to lookup a device directly by its model name, model code or hardware code, on android you can get the model name from: https://developer.android.com/reference/android/os/Build.html#MODEL (optional)
     * @param deviceBrand This parameter is only used in combination with &#39;device-model&#39; when doing direct device lookups without any user-agent data. Set this to the brand or manufacturer name, this is required for accurate device detection with ambiguous model names. On android you can get the device brand from: https://developer.android.com/reference/android/os/Build#MANUFACTURER (optional)
     * @return UALookupResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public UALookupResponse uALookup(String ua, String uaVersion, String uaPlatform, String uaPlatformVersion, String uaMobile, String deviceModel, String deviceBrand) throws ApiException {
        ApiResponse<UALookupResponse> localVarResp = uALookupWithHttpInfo(ua, uaVersion, uaPlatform, uaPlatformVersion, uaMobile, deviceModel, deviceBrand);
        return localVarResp.getData();
    }

    /**
     * UA Lookup
     * Parse, validate and get detailed user-agent information from a user agent string or from client hints
     * @param ua The user-agent string to lookup. For client hints use the &#39;UA&#39; header or the JSON data directly from &#39;navigator.userAgentData.brands&#39; or &#39;navigator.userAgentData.getHighEntropyValues()&#39; (required)
     * @param uaVersion For client hints this corresponds to the &#39;UA-Full-Version&#39; header or &#39;uaFullVersion&#39; from NavigatorUAData (optional)
     * @param uaPlatform For client hints this corresponds to the &#39;UA-Platform&#39; header or &#39;platform&#39; from NavigatorUAData (optional)
     * @param uaPlatformVersion For client hints this corresponds to the &#39;UA-Platform-Version&#39; header or &#39;platformVersion&#39; from NavigatorUAData (optional)
     * @param uaMobile For client hints this corresponds to the &#39;UA-Mobile&#39; header or &#39;mobile&#39; from NavigatorUAData (optional)
     * @param deviceModel For client hints this corresponds to the &#39;UA-Model&#39; header or &#39;model&#39; from NavigatorUAData. &lt;br&gt;You can also use this parameter to lookup a device directly by its model name, model code or hardware code, on android you can get the model name from: https://developer.android.com/reference/android/os/Build.html#MODEL (optional)
     * @param deviceBrand This parameter is only used in combination with &#39;device-model&#39; when doing direct device lookups without any user-agent data. Set this to the brand or manufacturer name, this is required for accurate device detection with ambiguous model names. On android you can get the device brand from: https://developer.android.com/reference/android/os/Build#MANUFACTURER (optional)
     * @return ApiResponse&lt;UALookupResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UALookupResponse> uALookupWithHttpInfo(String ua, String uaVersion, String uaPlatform, String uaPlatformVersion, String uaMobile, String deviceModel, String deviceBrand) throws ApiException {
        okhttp3.Call localVarCall = uALookupValidateBeforeCall(ua, uaVersion, uaPlatform, uaPlatformVersion, uaMobile, deviceModel, deviceBrand, null);
        Type localVarReturnType = new TypeToken<UALookupResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * UA Lookup (asynchronously)
     * Parse, validate and get detailed user-agent information from a user agent string or from client hints
     * @param ua The user-agent string to lookup. For client hints use the &#39;UA&#39; header or the JSON data directly from &#39;navigator.userAgentData.brands&#39; or &#39;navigator.userAgentData.getHighEntropyValues()&#39; (required)
     * @param uaVersion For client hints this corresponds to the &#39;UA-Full-Version&#39; header or &#39;uaFullVersion&#39; from NavigatorUAData (optional)
     * @param uaPlatform For client hints this corresponds to the &#39;UA-Platform&#39; header or &#39;platform&#39; from NavigatorUAData (optional)
     * @param uaPlatformVersion For client hints this corresponds to the &#39;UA-Platform-Version&#39; header or &#39;platformVersion&#39; from NavigatorUAData (optional)
     * @param uaMobile For client hints this corresponds to the &#39;UA-Mobile&#39; header or &#39;mobile&#39; from NavigatorUAData (optional)
     * @param deviceModel For client hints this corresponds to the &#39;UA-Model&#39; header or &#39;model&#39; from NavigatorUAData. &lt;br&gt;You can also use this parameter to lookup a device directly by its model name, model code or hardware code, on android you can get the model name from: https://developer.android.com/reference/android/os/Build.html#MODEL (optional)
     * @param deviceBrand This parameter is only used in combination with &#39;device-model&#39; when doing direct device lookups without any user-agent data. Set this to the brand or manufacturer name, this is required for accurate device detection with ambiguous model names. On android you can get the device brand from: https://developer.android.com/reference/android/os/Build#MANUFACTURER (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Your API request has been rejected. Check error code for details </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You have failed to authenticate </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> We messed up, sorry! Your request has caused a fatal exception </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> We messed up, sorry! Your request has caused an error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call uALookupAsync(String ua, String uaVersion, String uaPlatform, String uaPlatformVersion, String uaMobile, String deviceModel, String deviceBrand, final ApiCallback<UALookupResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = uALookupValidateBeforeCall(ua, uaVersion, uaPlatform, uaPlatformVersion, uaMobile, deviceModel, deviceBrand, _callback);
        Type localVarReturnType = new TypeToken<UALookupResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
