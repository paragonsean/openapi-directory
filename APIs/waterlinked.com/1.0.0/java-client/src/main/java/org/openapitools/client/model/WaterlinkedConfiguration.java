/*
 * The Water Linked Underwater GPS API
 * API for the Water Linked Underwater GPS. For more details: http://www.waterlinked.com  Recommended approach for connecting to a Underwater GPS via the API is: - If \"GET /api/\" times out, the Underwater GPS is not running (on this IP address) - If \"GET /api/\" responds with 200 OK check that the api version returrned (eg \"v1\") is supported by the client (eg: also supports \"v1\"). - If the api version returned does not match what the client supports: give an error to the user and recommend upgrading. (Eg: response is \"v2\" while client only supports \"v1\") - If \"GET /api/\" responds with 301 Moved permanently. \"GET /api/v1/version\" to check if the kit has a version earlier than 1.5. - \"GET /api/v1/version\" will always respond with 200 OK on Underwater GPS earlier than 1.5 release.  Configuration API is is not considered stable and will potentially be changed
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration parameters (default view)
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:29:36.739042-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class WaterlinkedConfiguration {
  public static final String SERIALIZED_NAME_ANTENNA_ENABLED = "antenna_enabled";
  @SerializedName(SERIALIZED_NAME_ANTENNA_ENABLED)
  private Boolean antennaEnabled;

  public static final String SERIALIZED_NAME_CHANNEL = "channel";
  @SerializedName(SERIALIZED_NAME_CHANNEL)
  private Integer channel;

  /**
   * Compass provider setting
   */
  @JsonAdapter(CompassEnum.Adapter.class)
  public enum CompassEnum {
    ONBOARD("onboard"),
    
    STATIC("static"),
    
    EXTERNAL("external");

    private String value;

    CompassEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CompassEnum fromValue(String value) {
      for (CompassEnum b : CompassEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<CompassEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CompassEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CompassEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CompassEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      CompassEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_COMPASS = "compass";
  @SerializedName(SERIALIZED_NAME_COMPASS)
  private CompassEnum compass;

  /**
   * [Deprecated] Environment setting
   */
  @JsonAdapter(EnvironmentEnum.Adapter.class)
  public enum EnvironmentEnum {
    REFLECTIVE("reflective"),
    
    OPENWATER("openwater");

    private String value;

    EnvironmentEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EnvironmentEnum fromValue(String value) {
      for (EnvironmentEnum b : EnvironmentEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EnvironmentEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EnvironmentEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EnvironmentEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EnvironmentEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EnvironmentEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private EnvironmentEnum environment;

  public static final String SERIALIZED_NAME_EXTERNAL_PPS_ENABLED = "external_pps_enabled";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_PPS_ENABLED)
  private Boolean externalPpsEnabled;

  /**
   * GPS provider setting
   */
  @JsonAdapter(GpsEnum.Adapter.class)
  public enum GpsEnum {
    ONBOARD("onboard"),
    
    STATIC("static"),
    
    EXTERNAL("external");

    private String value;

    GpsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static GpsEnum fromValue(String value) {
      for (GpsEnum b : GpsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<GpsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final GpsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public GpsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return GpsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      GpsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_GPS = "gps";
  @SerializedName(SERIALIZED_NAME_GPS)
  private GpsEnum gps;

  public static final String SERIALIZED_NAME_IMU_VEHICLE_ENABLED = "imu_vehicle_enabled";
  @SerializedName(SERIALIZED_NAME_IMU_VEHICLE_ENABLED)
  private Boolean imuVehicleEnabled;

  /**
   * Locator type in use
   */
  @JsonAdapter(LocatorTypeEnum.Adapter.class)
  public enum LocatorTypeEnum {
    D1("d1"),
    
    A1("a1"),
    
    S2("s2"),
    
    P2("p2"),
    
    U1("u1");

    private String value;

    LocatorTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LocatorTypeEnum fromValue(String value) {
      for (LocatorTypeEnum b : LocatorTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LocatorTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LocatorTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LocatorTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LocatorTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LocatorTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LOCATOR_TYPE = "locator_type";
  @SerializedName(SERIALIZED_NAME_LOCATOR_TYPE)
  private LocatorTypeEnum locatorType;

  public static final String SERIALIZED_NAME_RANGE_MAX_X = "range_max_x";
  @SerializedName(SERIALIZED_NAME_RANGE_MAX_X)
  private BigDecimal rangeMaxX;

  public static final String SERIALIZED_NAME_RANGE_MAX_Y = "range_max_y";
  @SerializedName(SERIALIZED_NAME_RANGE_MAX_Y)
  private BigDecimal rangeMaxY;

  public static final String SERIALIZED_NAME_RANGE_MAX_Z = "range_max_z";
  @SerializedName(SERIALIZED_NAME_RANGE_MAX_Z)
  private BigDecimal rangeMaxZ;

  public static final String SERIALIZED_NAME_RANGE_MIN_X = "range_min_x";
  @SerializedName(SERIALIZED_NAME_RANGE_MIN_X)
  private BigDecimal rangeMinX;

  public static final String SERIALIZED_NAME_RANGE_MIN_Y = "range_min_y";
  @SerializedName(SERIALIZED_NAME_RANGE_MIN_Y)
  private BigDecimal rangeMinY;

  public static final String SERIALIZED_NAME_SEARCH_DIRECTION = "search_direction";
  @SerializedName(SERIALIZED_NAME_SEARCH_DIRECTION)
  private BigDecimal searchDirection;

  public static final String SERIALIZED_NAME_SEARCH_RADIUS = "search_radius";
  @SerializedName(SERIALIZED_NAME_SEARCH_RADIUS)
  private BigDecimal searchRadius;

  public static final String SERIALIZED_NAME_SEARCH_SECTOR = "search_sector";
  @SerializedName(SERIALIZED_NAME_SEARCH_SECTOR)
  private BigDecimal searchSector;

  public static final String SERIALIZED_NAME_SPEED_OF_SOUND = "speed_of_sound";
  @SerializedName(SERIALIZED_NAME_SPEED_OF_SOUND)
  private Integer speedOfSound;

  public static final String SERIALIZED_NAME_STATIC_LAT = "static_lat";
  @SerializedName(SERIALIZED_NAME_STATIC_LAT)
  private BigDecimal staticLat;

  public static final String SERIALIZED_NAME_STATIC_LON = "static_lon";
  @SerializedName(SERIALIZED_NAME_STATIC_LON)
  private BigDecimal staticLon;

  public static final String SERIALIZED_NAME_STATIC_ORIENTATION = "static_orientation";
  @SerializedName(SERIALIZED_NAME_STATIC_ORIENTATION)
  private BigDecimal staticOrientation;

  public WaterlinkedConfiguration() {
  }

  public WaterlinkedConfiguration antennaEnabled(Boolean antennaEnabled) {
    this.antennaEnabled = antennaEnabled;
    return this;
  }

  /**
   * Enable use of antenna
   * @return antennaEnabled
   */
  @javax.annotation.Nullable
  public Boolean getAntennaEnabled() {
    return antennaEnabled;
  }

  public void setAntennaEnabled(Boolean antennaEnabled) {
    this.antennaEnabled = antennaEnabled;
  }


  public WaterlinkedConfiguration channel(Integer channel) {
    this.channel = channel;
    return this;
  }

  /**
   * Channel to use
   * minimum: 0
   * maximum: 6000
   * @return channel
   */
  @javax.annotation.Nonnull
  public Integer getChannel() {
    return channel;
  }

  public void setChannel(Integer channel) {
    this.channel = channel;
  }


  public WaterlinkedConfiguration compass(CompassEnum compass) {
    this.compass = compass;
    return this;
  }

  /**
   * Compass provider setting
   * @return compass
   */
  @javax.annotation.Nonnull
  public CompassEnum getCompass() {
    return compass;
  }

  public void setCompass(CompassEnum compass) {
    this.compass = compass;
  }


  public WaterlinkedConfiguration environment(EnvironmentEnum environment) {
    this.environment = environment;
    return this;
  }

  /**
   * [Deprecated] Environment setting
   * @return environment
   */
  @javax.annotation.Nullable
  public EnvironmentEnum getEnvironment() {
    return environment;
  }

  public void setEnvironment(EnvironmentEnum environment) {
    this.environment = environment;
  }


  public WaterlinkedConfiguration externalPpsEnabled(Boolean externalPpsEnabled) {
    this.externalPpsEnabled = externalPpsEnabled;
    return this;
  }

  /**
   * Enable external PPS input to master
   * @return externalPpsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getExternalPpsEnabled() {
    return externalPpsEnabled;
  }

  public void setExternalPpsEnabled(Boolean externalPpsEnabled) {
    this.externalPpsEnabled = externalPpsEnabled;
  }


  public WaterlinkedConfiguration gps(GpsEnum gps) {
    this.gps = gps;
    return this;
  }

  /**
   * GPS provider setting
   * @return gps
   */
  @javax.annotation.Nonnull
  public GpsEnum getGps() {
    return gps;
  }

  public void setGps(GpsEnum gps) {
    this.gps = gps;
  }


  public WaterlinkedConfiguration imuVehicleEnabled(Boolean imuVehicleEnabled) {
    this.imuVehicleEnabled = imuVehicleEnabled;
    return this;
  }

  /**
   * [Deprecated] Enable IMU input from vehicle
   * @return imuVehicleEnabled
   */
  @javax.annotation.Nullable
  public Boolean getImuVehicleEnabled() {
    return imuVehicleEnabled;
  }

  public void setImuVehicleEnabled(Boolean imuVehicleEnabled) {
    this.imuVehicleEnabled = imuVehicleEnabled;
  }


  public WaterlinkedConfiguration locatorType(LocatorTypeEnum locatorType) {
    this.locatorType = locatorType;
    return this;
  }

  /**
   * Locator type in use
   * @return locatorType
   */
  @javax.annotation.Nonnull
  public LocatorTypeEnum getLocatorType() {
    return locatorType;
  }

  public void setLocatorType(LocatorTypeEnum locatorType) {
    this.locatorType = locatorType;
  }


  public WaterlinkedConfiguration rangeMaxX(BigDecimal rangeMaxX) {
    this.rangeMaxX = rangeMaxX;
    return this;
  }

  /**
   * [Deprecated] Max range (meters)
   * minimum: 0
   * maximum: 1E+2
   * @return rangeMaxX
   */
  @javax.annotation.Nullable
  public BigDecimal getRangeMaxX() {
    return rangeMaxX;
  }

  public void setRangeMaxX(BigDecimal rangeMaxX) {
    this.rangeMaxX = rangeMaxX;
  }


  public WaterlinkedConfiguration rangeMaxY(BigDecimal rangeMaxY) {
    this.rangeMaxY = rangeMaxY;
    return this;
  }

  /**
   * [Deprecated] Max range (meters)
   * minimum: 0
   * maximum: 1E+2
   * @return rangeMaxY
   */
  @javax.annotation.Nullable
  public BigDecimal getRangeMaxY() {
    return rangeMaxY;
  }

  public void setRangeMaxY(BigDecimal rangeMaxY) {
    this.rangeMaxY = rangeMaxY;
  }


  public WaterlinkedConfiguration rangeMaxZ(BigDecimal rangeMaxZ) {
    this.rangeMaxZ = rangeMaxZ;
    return this;
  }

  /**
   * [Deprecated] Max range (meters)
   * minimum: 0
   * maximum: 1E+2
   * @return rangeMaxZ
   */
  @javax.annotation.Nullable
  public BigDecimal getRangeMaxZ() {
    return rangeMaxZ;
  }

  public void setRangeMaxZ(BigDecimal rangeMaxZ) {
    this.rangeMaxZ = rangeMaxZ;
  }


  public WaterlinkedConfiguration rangeMinX(BigDecimal rangeMinX) {
    this.rangeMinX = rangeMinX;
    return this;
  }

  /**
   * [Deprecated] Max range (meters)
   * minimum: -1E+2
   * maximum: 0
   * @return rangeMinX
   */
  @javax.annotation.Nullable
  public BigDecimal getRangeMinX() {
    return rangeMinX;
  }

  public void setRangeMinX(BigDecimal rangeMinX) {
    this.rangeMinX = rangeMinX;
  }


  public WaterlinkedConfiguration rangeMinY(BigDecimal rangeMinY) {
    this.rangeMinY = rangeMinY;
    return this;
  }

  /**
   * [Deprecated] Max range (meters)
   * minimum: -1E+2
   * maximum: 0
   * @return rangeMinY
   */
  @javax.annotation.Nullable
  public BigDecimal getRangeMinY() {
    return rangeMinY;
  }

  public void setRangeMinY(BigDecimal rangeMinY) {
    this.rangeMinY = rangeMinY;
  }


  public WaterlinkedConfiguration searchDirection(BigDecimal searchDirection) {
    this.searchDirection = searchDirection;
    return this;
  }

  /**
   * Direction of circular search area section
   * minimum: 0
   * maximum: 3.6E+2
   * @return searchDirection
   */
  @javax.annotation.Nullable
  public BigDecimal getSearchDirection() {
    return searchDirection;
  }

  public void setSearchDirection(BigDecimal searchDirection) {
    this.searchDirection = searchDirection;
  }


  public WaterlinkedConfiguration searchRadius(BigDecimal searchRadius) {
    this.searchRadius = searchRadius;
    return this;
  }

  /**
   * Radius of circular search area
   * minimum: 1
   * maximum: 3E+2
   * @return searchRadius
   */
  @javax.annotation.Nullable
  public BigDecimal getSearchRadius() {
    return searchRadius;
  }

  public void setSearchRadius(BigDecimal searchRadius) {
    this.searchRadius = searchRadius;
  }


  public WaterlinkedConfiguration searchSector(BigDecimal searchSector) {
    this.searchSector = searchSector;
    return this;
  }

  /**
   * Sector angle of circular search area
   * minimum: 1
   * maximum: 3.6E+2
   * @return searchSector
   */
  @javax.annotation.Nullable
  public BigDecimal getSearchSector() {
    return searchSector;
  }

  public void setSearchSector(BigDecimal searchSector) {
    this.searchSector = searchSector;
  }


  public WaterlinkedConfiguration speedOfSound(Integer speedOfSound) {
    this.speedOfSound = speedOfSound;
    return this;
  }

  /**
   * Speed of sound use by the system
   * minimum: 1000
   * maximum: 2000
   * @return speedOfSound
   */
  @javax.annotation.Nullable
  public Integer getSpeedOfSound() {
    return speedOfSound;
  }

  public void setSpeedOfSound(Integer speedOfSound) {
    this.speedOfSound = speedOfSound;
  }


  public WaterlinkedConfiguration staticLat(BigDecimal staticLat) {
    this.staticLat = staticLat;
    return this;
  }

  /**
   * Latitude to use in static mode
   * minimum: -9E+1
   * maximum: 9E+1
   * @return staticLat
   */
  @javax.annotation.Nonnull
  public BigDecimal getStaticLat() {
    return staticLat;
  }

  public void setStaticLat(BigDecimal staticLat) {
    this.staticLat = staticLat;
  }


  public WaterlinkedConfiguration staticLon(BigDecimal staticLon) {
    this.staticLon = staticLon;
    return this;
  }

  /**
   * Longitude to use in static mode
   * minimum: -1.8E+2
   * maximum: 1.8E+2
   * @return staticLon
   */
  @javax.annotation.Nonnull
  public BigDecimal getStaticLon() {
    return staticLon;
  }

  public void setStaticLon(BigDecimal staticLon) {
    this.staticLon = staticLon;
  }


  public WaterlinkedConfiguration staticOrientation(BigDecimal staticOrientation) {
    this.staticOrientation = staticOrientation;
    return this;
  }

  /**
   * Orientation/compass reading to use in static mode (degrees)
   * minimum: 0
   * maximum: 359
   * @return staticOrientation
   */
  @javax.annotation.Nonnull
  public BigDecimal getStaticOrientation() {
    return staticOrientation;
  }

  public void setStaticOrientation(BigDecimal staticOrientation) {
    this.staticOrientation = staticOrientation;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WaterlinkedConfiguration waterlinkedConfiguration = (WaterlinkedConfiguration) o;
    return Objects.equals(this.antennaEnabled, waterlinkedConfiguration.antennaEnabled) &&
        Objects.equals(this.channel, waterlinkedConfiguration.channel) &&
        Objects.equals(this.compass, waterlinkedConfiguration.compass) &&
        Objects.equals(this.environment, waterlinkedConfiguration.environment) &&
        Objects.equals(this.externalPpsEnabled, waterlinkedConfiguration.externalPpsEnabled) &&
        Objects.equals(this.gps, waterlinkedConfiguration.gps) &&
        Objects.equals(this.imuVehicleEnabled, waterlinkedConfiguration.imuVehicleEnabled) &&
        Objects.equals(this.locatorType, waterlinkedConfiguration.locatorType) &&
        Objects.equals(this.rangeMaxX, waterlinkedConfiguration.rangeMaxX) &&
        Objects.equals(this.rangeMaxY, waterlinkedConfiguration.rangeMaxY) &&
        Objects.equals(this.rangeMaxZ, waterlinkedConfiguration.rangeMaxZ) &&
        Objects.equals(this.rangeMinX, waterlinkedConfiguration.rangeMinX) &&
        Objects.equals(this.rangeMinY, waterlinkedConfiguration.rangeMinY) &&
        Objects.equals(this.searchDirection, waterlinkedConfiguration.searchDirection) &&
        Objects.equals(this.searchRadius, waterlinkedConfiguration.searchRadius) &&
        Objects.equals(this.searchSector, waterlinkedConfiguration.searchSector) &&
        Objects.equals(this.speedOfSound, waterlinkedConfiguration.speedOfSound) &&
        Objects.equals(this.staticLat, waterlinkedConfiguration.staticLat) &&
        Objects.equals(this.staticLon, waterlinkedConfiguration.staticLon) &&
        Objects.equals(this.staticOrientation, waterlinkedConfiguration.staticOrientation);
  }

  @Override
  public int hashCode() {
    return Objects.hash(antennaEnabled, channel, compass, environment, externalPpsEnabled, gps, imuVehicleEnabled, locatorType, rangeMaxX, rangeMaxY, rangeMaxZ, rangeMinX, rangeMinY, searchDirection, searchRadius, searchSector, speedOfSound, staticLat, staticLon, staticOrientation);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WaterlinkedConfiguration {\n");
    sb.append("    antennaEnabled: ").append(toIndentedString(antennaEnabled)).append("\n");
    sb.append("    channel: ").append(toIndentedString(channel)).append("\n");
    sb.append("    compass: ").append(toIndentedString(compass)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    externalPpsEnabled: ").append(toIndentedString(externalPpsEnabled)).append("\n");
    sb.append("    gps: ").append(toIndentedString(gps)).append("\n");
    sb.append("    imuVehicleEnabled: ").append(toIndentedString(imuVehicleEnabled)).append("\n");
    sb.append("    locatorType: ").append(toIndentedString(locatorType)).append("\n");
    sb.append("    rangeMaxX: ").append(toIndentedString(rangeMaxX)).append("\n");
    sb.append("    rangeMaxY: ").append(toIndentedString(rangeMaxY)).append("\n");
    sb.append("    rangeMaxZ: ").append(toIndentedString(rangeMaxZ)).append("\n");
    sb.append("    rangeMinX: ").append(toIndentedString(rangeMinX)).append("\n");
    sb.append("    rangeMinY: ").append(toIndentedString(rangeMinY)).append("\n");
    sb.append("    searchDirection: ").append(toIndentedString(searchDirection)).append("\n");
    sb.append("    searchRadius: ").append(toIndentedString(searchRadius)).append("\n");
    sb.append("    searchSector: ").append(toIndentedString(searchSector)).append("\n");
    sb.append("    speedOfSound: ").append(toIndentedString(speedOfSound)).append("\n");
    sb.append("    staticLat: ").append(toIndentedString(staticLat)).append("\n");
    sb.append("    staticLon: ").append(toIndentedString(staticLon)).append("\n");
    sb.append("    staticOrientation: ").append(toIndentedString(staticOrientation)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("antenna_enabled");
    openapiFields.add("channel");
    openapiFields.add("compass");
    openapiFields.add("environment");
    openapiFields.add("external_pps_enabled");
    openapiFields.add("gps");
    openapiFields.add("imu_vehicle_enabled");
    openapiFields.add("locator_type");
    openapiFields.add("range_max_x");
    openapiFields.add("range_max_y");
    openapiFields.add("range_max_z");
    openapiFields.add("range_min_x");
    openapiFields.add("range_min_y");
    openapiFields.add("search_direction");
    openapiFields.add("search_radius");
    openapiFields.add("search_sector");
    openapiFields.add("speed_of_sound");
    openapiFields.add("static_lat");
    openapiFields.add("static_lon");
    openapiFields.add("static_orientation");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("channel");
    openapiRequiredFields.add("compass");
    openapiRequiredFields.add("gps");
    openapiRequiredFields.add("locator_type");
    openapiRequiredFields.add("static_lat");
    openapiRequiredFields.add("static_lon");
    openapiRequiredFields.add("static_orientation");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to WaterlinkedConfiguration
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!WaterlinkedConfiguration.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WaterlinkedConfiguration is not found in the empty JSON string", WaterlinkedConfiguration.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!WaterlinkedConfiguration.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `WaterlinkedConfiguration` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : WaterlinkedConfiguration.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("compass").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compass` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compass").toString()));
      }
      // validate the required field `compass`
      CompassEnum.validateJsonElement(jsonObj.get("compass"));
      if ((jsonObj.get("environment") != null && !jsonObj.get("environment").isJsonNull()) && !jsonObj.get("environment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `environment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("environment").toString()));
      }
      // validate the optional field `environment`
      if (jsonObj.get("environment") != null && !jsonObj.get("environment").isJsonNull()) {
        EnvironmentEnum.validateJsonElement(jsonObj.get("environment"));
      }
      if (!jsonObj.get("gps").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gps` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gps").toString()));
      }
      // validate the required field `gps`
      GpsEnum.validateJsonElement(jsonObj.get("gps"));
      if (!jsonObj.get("locator_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `locator_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("locator_type").toString()));
      }
      // validate the required field `locator_type`
      LocatorTypeEnum.validateJsonElement(jsonObj.get("locator_type"));
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WaterlinkedConfiguration.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WaterlinkedConfiguration' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WaterlinkedConfiguration> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WaterlinkedConfiguration.class));

       return (TypeAdapter<T>) new TypeAdapter<WaterlinkedConfiguration>() {
           @Override
           public void write(JsonWriter out, WaterlinkedConfiguration value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WaterlinkedConfiguration read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of WaterlinkedConfiguration given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of WaterlinkedConfiguration
   * @throws IOException if the JSON string is invalid with respect to WaterlinkedConfiguration
   */
  public static WaterlinkedConfiguration fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WaterlinkedConfiguration.class);
  }

  /**
   * Convert an instance of WaterlinkedConfiguration to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

