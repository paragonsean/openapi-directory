/**
 * The Water Linked Underwater GPS API
 * API for the Water Linked Underwater GPS. For more details: http://www.waterlinked.com  Recommended approach for connecting to a Underwater GPS via the API is: - If \"GET /api/\" times out, the Underwater GPS is not running (on this IP address) - If \"GET /api/\" responds with 200 OK check that the api version returrned (eg \"v1\") is supported by the client (eg: also supports \"v1\"). - If the api version returned does not match what the client supports: give an error to the user and recommend upgrading. (Eg: response is \"v2\" while client only supports \"v1\") - If \"GET /api/\" responds with 301 Moved permanently. \"GET /api/v1/version\" to check if the kit has a version earlier than 1.5. - \"GET /api/v1/version\" will always respond with 200 OK on Underwater GPS earlier than 1.5 release.  Configuration API is is not considered stable and will potentially be changed
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIWaterlinkedConfiguration.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIWaterlinkedConfiguration::OAIWaterlinkedConfiguration(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIWaterlinkedConfiguration::OAIWaterlinkedConfiguration() {
    this->initializeModel();
}

OAIWaterlinkedConfiguration::~OAIWaterlinkedConfiguration() {}

void OAIWaterlinkedConfiguration::initializeModel() {

    m_antenna_enabled_isSet = false;
    m_antenna_enabled_isValid = false;

    m_channel_isSet = false;
    m_channel_isValid = false;

    m_compass_isSet = false;
    m_compass_isValid = false;

    m_environment_isSet = false;
    m_environment_isValid = false;

    m_external_pps_enabled_isSet = false;
    m_external_pps_enabled_isValid = false;

    m_gps_isSet = false;
    m_gps_isValid = false;

    m_imu_vehicle_enabled_isSet = false;
    m_imu_vehicle_enabled_isValid = false;

    m_locator_type_isSet = false;
    m_locator_type_isValid = false;

    m_range_max_x_isSet = false;
    m_range_max_x_isValid = false;

    m_range_max_y_isSet = false;
    m_range_max_y_isValid = false;

    m_range_max_z_isSet = false;
    m_range_max_z_isValid = false;

    m_range_min_x_isSet = false;
    m_range_min_x_isValid = false;

    m_range_min_y_isSet = false;
    m_range_min_y_isValid = false;

    m_search_direction_isSet = false;
    m_search_direction_isValid = false;

    m_search_radius_isSet = false;
    m_search_radius_isValid = false;

    m_search_sector_isSet = false;
    m_search_sector_isValid = false;

    m_speed_of_sound_isSet = false;
    m_speed_of_sound_isValid = false;

    m_static_lat_isSet = false;
    m_static_lat_isValid = false;

    m_static_lon_isSet = false;
    m_static_lon_isValid = false;

    m_static_orientation_isSet = false;
    m_static_orientation_isValid = false;
}

void OAIWaterlinkedConfiguration::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIWaterlinkedConfiguration::fromJsonObject(QJsonObject json) {

    m_antenna_enabled_isValid = ::OpenAPI::fromJsonValue(m_antenna_enabled, json[QString("antenna_enabled")]);
    m_antenna_enabled_isSet = !json[QString("antenna_enabled")].isNull() && m_antenna_enabled_isValid;

    m_channel_isValid = ::OpenAPI::fromJsonValue(m_channel, json[QString("channel")]);
    m_channel_isSet = !json[QString("channel")].isNull() && m_channel_isValid;

    m_compass_isValid = ::OpenAPI::fromJsonValue(m_compass, json[QString("compass")]);
    m_compass_isSet = !json[QString("compass")].isNull() && m_compass_isValid;

    m_environment_isValid = ::OpenAPI::fromJsonValue(m_environment, json[QString("environment")]);
    m_environment_isSet = !json[QString("environment")].isNull() && m_environment_isValid;

    m_external_pps_enabled_isValid = ::OpenAPI::fromJsonValue(m_external_pps_enabled, json[QString("external_pps_enabled")]);
    m_external_pps_enabled_isSet = !json[QString("external_pps_enabled")].isNull() && m_external_pps_enabled_isValid;

    m_gps_isValid = ::OpenAPI::fromJsonValue(m_gps, json[QString("gps")]);
    m_gps_isSet = !json[QString("gps")].isNull() && m_gps_isValid;

    m_imu_vehicle_enabled_isValid = ::OpenAPI::fromJsonValue(m_imu_vehicle_enabled, json[QString("imu_vehicle_enabled")]);
    m_imu_vehicle_enabled_isSet = !json[QString("imu_vehicle_enabled")].isNull() && m_imu_vehicle_enabled_isValid;

    m_locator_type_isValid = ::OpenAPI::fromJsonValue(m_locator_type, json[QString("locator_type")]);
    m_locator_type_isSet = !json[QString("locator_type")].isNull() && m_locator_type_isValid;

    m_range_max_x_isValid = ::OpenAPI::fromJsonValue(m_range_max_x, json[QString("range_max_x")]);
    m_range_max_x_isSet = !json[QString("range_max_x")].isNull() && m_range_max_x_isValid;

    m_range_max_y_isValid = ::OpenAPI::fromJsonValue(m_range_max_y, json[QString("range_max_y")]);
    m_range_max_y_isSet = !json[QString("range_max_y")].isNull() && m_range_max_y_isValid;

    m_range_max_z_isValid = ::OpenAPI::fromJsonValue(m_range_max_z, json[QString("range_max_z")]);
    m_range_max_z_isSet = !json[QString("range_max_z")].isNull() && m_range_max_z_isValid;

    m_range_min_x_isValid = ::OpenAPI::fromJsonValue(m_range_min_x, json[QString("range_min_x")]);
    m_range_min_x_isSet = !json[QString("range_min_x")].isNull() && m_range_min_x_isValid;

    m_range_min_y_isValid = ::OpenAPI::fromJsonValue(m_range_min_y, json[QString("range_min_y")]);
    m_range_min_y_isSet = !json[QString("range_min_y")].isNull() && m_range_min_y_isValid;

    m_search_direction_isValid = ::OpenAPI::fromJsonValue(m_search_direction, json[QString("search_direction")]);
    m_search_direction_isSet = !json[QString("search_direction")].isNull() && m_search_direction_isValid;

    m_search_radius_isValid = ::OpenAPI::fromJsonValue(m_search_radius, json[QString("search_radius")]);
    m_search_radius_isSet = !json[QString("search_radius")].isNull() && m_search_radius_isValid;

    m_search_sector_isValid = ::OpenAPI::fromJsonValue(m_search_sector, json[QString("search_sector")]);
    m_search_sector_isSet = !json[QString("search_sector")].isNull() && m_search_sector_isValid;

    m_speed_of_sound_isValid = ::OpenAPI::fromJsonValue(m_speed_of_sound, json[QString("speed_of_sound")]);
    m_speed_of_sound_isSet = !json[QString("speed_of_sound")].isNull() && m_speed_of_sound_isValid;

    m_static_lat_isValid = ::OpenAPI::fromJsonValue(m_static_lat, json[QString("static_lat")]);
    m_static_lat_isSet = !json[QString("static_lat")].isNull() && m_static_lat_isValid;

    m_static_lon_isValid = ::OpenAPI::fromJsonValue(m_static_lon, json[QString("static_lon")]);
    m_static_lon_isSet = !json[QString("static_lon")].isNull() && m_static_lon_isValid;

    m_static_orientation_isValid = ::OpenAPI::fromJsonValue(m_static_orientation, json[QString("static_orientation")]);
    m_static_orientation_isSet = !json[QString("static_orientation")].isNull() && m_static_orientation_isValid;
}

QString OAIWaterlinkedConfiguration::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIWaterlinkedConfiguration::asJsonObject() const {
    QJsonObject obj;
    if (m_antenna_enabled_isSet) {
        obj.insert(QString("antenna_enabled"), ::OpenAPI::toJsonValue(m_antenna_enabled));
    }
    if (m_channel_isSet) {
        obj.insert(QString("channel"), ::OpenAPI::toJsonValue(m_channel));
    }
    if (m_compass_isSet) {
        obj.insert(QString("compass"), ::OpenAPI::toJsonValue(m_compass));
    }
    if (m_environment_isSet) {
        obj.insert(QString("environment"), ::OpenAPI::toJsonValue(m_environment));
    }
    if (m_external_pps_enabled_isSet) {
        obj.insert(QString("external_pps_enabled"), ::OpenAPI::toJsonValue(m_external_pps_enabled));
    }
    if (m_gps_isSet) {
        obj.insert(QString("gps"), ::OpenAPI::toJsonValue(m_gps));
    }
    if (m_imu_vehicle_enabled_isSet) {
        obj.insert(QString("imu_vehicle_enabled"), ::OpenAPI::toJsonValue(m_imu_vehicle_enabled));
    }
    if (m_locator_type_isSet) {
        obj.insert(QString("locator_type"), ::OpenAPI::toJsonValue(m_locator_type));
    }
    if (m_range_max_x_isSet) {
        obj.insert(QString("range_max_x"), ::OpenAPI::toJsonValue(m_range_max_x));
    }
    if (m_range_max_y_isSet) {
        obj.insert(QString("range_max_y"), ::OpenAPI::toJsonValue(m_range_max_y));
    }
    if (m_range_max_z_isSet) {
        obj.insert(QString("range_max_z"), ::OpenAPI::toJsonValue(m_range_max_z));
    }
    if (m_range_min_x_isSet) {
        obj.insert(QString("range_min_x"), ::OpenAPI::toJsonValue(m_range_min_x));
    }
    if (m_range_min_y_isSet) {
        obj.insert(QString("range_min_y"), ::OpenAPI::toJsonValue(m_range_min_y));
    }
    if (m_search_direction_isSet) {
        obj.insert(QString("search_direction"), ::OpenAPI::toJsonValue(m_search_direction));
    }
    if (m_search_radius_isSet) {
        obj.insert(QString("search_radius"), ::OpenAPI::toJsonValue(m_search_radius));
    }
    if (m_search_sector_isSet) {
        obj.insert(QString("search_sector"), ::OpenAPI::toJsonValue(m_search_sector));
    }
    if (m_speed_of_sound_isSet) {
        obj.insert(QString("speed_of_sound"), ::OpenAPI::toJsonValue(m_speed_of_sound));
    }
    if (m_static_lat_isSet) {
        obj.insert(QString("static_lat"), ::OpenAPI::toJsonValue(m_static_lat));
    }
    if (m_static_lon_isSet) {
        obj.insert(QString("static_lon"), ::OpenAPI::toJsonValue(m_static_lon));
    }
    if (m_static_orientation_isSet) {
        obj.insert(QString("static_orientation"), ::OpenAPI::toJsonValue(m_static_orientation));
    }
    return obj;
}

bool OAIWaterlinkedConfiguration::isAntennaEnabled() const {
    return m_antenna_enabled;
}
void OAIWaterlinkedConfiguration::setAntennaEnabled(const bool &antenna_enabled) {
    m_antenna_enabled = antenna_enabled;
    m_antenna_enabled_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_antenna_enabled_Set() const{
    return m_antenna_enabled_isSet;
}

bool OAIWaterlinkedConfiguration::is_antenna_enabled_Valid() const{
    return m_antenna_enabled_isValid;
}

qint32 OAIWaterlinkedConfiguration::getChannel() const {
    return m_channel;
}
void OAIWaterlinkedConfiguration::setChannel(const qint32 &channel) {
    m_channel = channel;
    m_channel_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_channel_Set() const{
    return m_channel_isSet;
}

bool OAIWaterlinkedConfiguration::is_channel_Valid() const{
    return m_channel_isValid;
}

QString OAIWaterlinkedConfiguration::getCompass() const {
    return m_compass;
}
void OAIWaterlinkedConfiguration::setCompass(const QString &compass) {
    m_compass = compass;
    m_compass_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_compass_Set() const{
    return m_compass_isSet;
}

bool OAIWaterlinkedConfiguration::is_compass_Valid() const{
    return m_compass_isValid;
}

QString OAIWaterlinkedConfiguration::getEnvironment() const {
    return m_environment;
}
void OAIWaterlinkedConfiguration::setEnvironment(const QString &environment) {
    m_environment = environment;
    m_environment_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_environment_Set() const{
    return m_environment_isSet;
}

bool OAIWaterlinkedConfiguration::is_environment_Valid() const{
    return m_environment_isValid;
}

bool OAIWaterlinkedConfiguration::isExternalPpsEnabled() const {
    return m_external_pps_enabled;
}
void OAIWaterlinkedConfiguration::setExternalPpsEnabled(const bool &external_pps_enabled) {
    m_external_pps_enabled = external_pps_enabled;
    m_external_pps_enabled_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_external_pps_enabled_Set() const{
    return m_external_pps_enabled_isSet;
}

bool OAIWaterlinkedConfiguration::is_external_pps_enabled_Valid() const{
    return m_external_pps_enabled_isValid;
}

QString OAIWaterlinkedConfiguration::getGps() const {
    return m_gps;
}
void OAIWaterlinkedConfiguration::setGps(const QString &gps) {
    m_gps = gps;
    m_gps_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_gps_Set() const{
    return m_gps_isSet;
}

bool OAIWaterlinkedConfiguration::is_gps_Valid() const{
    return m_gps_isValid;
}

bool OAIWaterlinkedConfiguration::isImuVehicleEnabled() const {
    return m_imu_vehicle_enabled;
}
void OAIWaterlinkedConfiguration::setImuVehicleEnabled(const bool &imu_vehicle_enabled) {
    m_imu_vehicle_enabled = imu_vehicle_enabled;
    m_imu_vehicle_enabled_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_imu_vehicle_enabled_Set() const{
    return m_imu_vehicle_enabled_isSet;
}

bool OAIWaterlinkedConfiguration::is_imu_vehicle_enabled_Valid() const{
    return m_imu_vehicle_enabled_isValid;
}

QString OAIWaterlinkedConfiguration::getLocatorType() const {
    return m_locator_type;
}
void OAIWaterlinkedConfiguration::setLocatorType(const QString &locator_type) {
    m_locator_type = locator_type;
    m_locator_type_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_locator_type_Set() const{
    return m_locator_type_isSet;
}

bool OAIWaterlinkedConfiguration::is_locator_type_Valid() const{
    return m_locator_type_isValid;
}

double OAIWaterlinkedConfiguration::getRangeMaxX() const {
    return m_range_max_x;
}
void OAIWaterlinkedConfiguration::setRangeMaxX(const double &range_max_x) {
    m_range_max_x = range_max_x;
    m_range_max_x_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_range_max_x_Set() const{
    return m_range_max_x_isSet;
}

bool OAIWaterlinkedConfiguration::is_range_max_x_Valid() const{
    return m_range_max_x_isValid;
}

double OAIWaterlinkedConfiguration::getRangeMaxY() const {
    return m_range_max_y;
}
void OAIWaterlinkedConfiguration::setRangeMaxY(const double &range_max_y) {
    m_range_max_y = range_max_y;
    m_range_max_y_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_range_max_y_Set() const{
    return m_range_max_y_isSet;
}

bool OAIWaterlinkedConfiguration::is_range_max_y_Valid() const{
    return m_range_max_y_isValid;
}

double OAIWaterlinkedConfiguration::getRangeMaxZ() const {
    return m_range_max_z;
}
void OAIWaterlinkedConfiguration::setRangeMaxZ(const double &range_max_z) {
    m_range_max_z = range_max_z;
    m_range_max_z_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_range_max_z_Set() const{
    return m_range_max_z_isSet;
}

bool OAIWaterlinkedConfiguration::is_range_max_z_Valid() const{
    return m_range_max_z_isValid;
}

double OAIWaterlinkedConfiguration::getRangeMinX() const {
    return m_range_min_x;
}
void OAIWaterlinkedConfiguration::setRangeMinX(const double &range_min_x) {
    m_range_min_x = range_min_x;
    m_range_min_x_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_range_min_x_Set() const{
    return m_range_min_x_isSet;
}

bool OAIWaterlinkedConfiguration::is_range_min_x_Valid() const{
    return m_range_min_x_isValid;
}

double OAIWaterlinkedConfiguration::getRangeMinY() const {
    return m_range_min_y;
}
void OAIWaterlinkedConfiguration::setRangeMinY(const double &range_min_y) {
    m_range_min_y = range_min_y;
    m_range_min_y_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_range_min_y_Set() const{
    return m_range_min_y_isSet;
}

bool OAIWaterlinkedConfiguration::is_range_min_y_Valid() const{
    return m_range_min_y_isValid;
}

double OAIWaterlinkedConfiguration::getSearchDirection() const {
    return m_search_direction;
}
void OAIWaterlinkedConfiguration::setSearchDirection(const double &search_direction) {
    m_search_direction = search_direction;
    m_search_direction_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_search_direction_Set() const{
    return m_search_direction_isSet;
}

bool OAIWaterlinkedConfiguration::is_search_direction_Valid() const{
    return m_search_direction_isValid;
}

double OAIWaterlinkedConfiguration::getSearchRadius() const {
    return m_search_radius;
}
void OAIWaterlinkedConfiguration::setSearchRadius(const double &search_radius) {
    m_search_radius = search_radius;
    m_search_radius_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_search_radius_Set() const{
    return m_search_radius_isSet;
}

bool OAIWaterlinkedConfiguration::is_search_radius_Valid() const{
    return m_search_radius_isValid;
}

double OAIWaterlinkedConfiguration::getSearchSector() const {
    return m_search_sector;
}
void OAIWaterlinkedConfiguration::setSearchSector(const double &search_sector) {
    m_search_sector = search_sector;
    m_search_sector_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_search_sector_Set() const{
    return m_search_sector_isSet;
}

bool OAIWaterlinkedConfiguration::is_search_sector_Valid() const{
    return m_search_sector_isValid;
}

qint32 OAIWaterlinkedConfiguration::getSpeedOfSound() const {
    return m_speed_of_sound;
}
void OAIWaterlinkedConfiguration::setSpeedOfSound(const qint32 &speed_of_sound) {
    m_speed_of_sound = speed_of_sound;
    m_speed_of_sound_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_speed_of_sound_Set() const{
    return m_speed_of_sound_isSet;
}

bool OAIWaterlinkedConfiguration::is_speed_of_sound_Valid() const{
    return m_speed_of_sound_isValid;
}

double OAIWaterlinkedConfiguration::getStaticLat() const {
    return m_static_lat;
}
void OAIWaterlinkedConfiguration::setStaticLat(const double &static_lat) {
    m_static_lat = static_lat;
    m_static_lat_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_static_lat_Set() const{
    return m_static_lat_isSet;
}

bool OAIWaterlinkedConfiguration::is_static_lat_Valid() const{
    return m_static_lat_isValid;
}

double OAIWaterlinkedConfiguration::getStaticLon() const {
    return m_static_lon;
}
void OAIWaterlinkedConfiguration::setStaticLon(const double &static_lon) {
    m_static_lon = static_lon;
    m_static_lon_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_static_lon_Set() const{
    return m_static_lon_isSet;
}

bool OAIWaterlinkedConfiguration::is_static_lon_Valid() const{
    return m_static_lon_isValid;
}

double OAIWaterlinkedConfiguration::getStaticOrientation() const {
    return m_static_orientation;
}
void OAIWaterlinkedConfiguration::setStaticOrientation(const double &static_orientation) {
    m_static_orientation = static_orientation;
    m_static_orientation_isSet = true;
}

bool OAIWaterlinkedConfiguration::is_static_orientation_Set() const{
    return m_static_orientation_isSet;
}

bool OAIWaterlinkedConfiguration::is_static_orientation_Valid() const{
    return m_static_orientation_isValid;
}

bool OAIWaterlinkedConfiguration::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_antenna_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_channel_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_compass_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_environment_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_external_pps_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gps_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_imu_vehicle_enabled_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_locator_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_range_max_x_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_range_max_y_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_range_max_z_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_range_min_x_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_range_min_y_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_search_direction_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_search_radius_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_search_sector_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_speed_of_sound_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_static_lat_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_static_lon_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_static_orientation_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIWaterlinkedConfiguration::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_channel_isValid && m_compass_isValid && m_gps_isValid && m_locator_type_isValid && m_static_lat_isValid && m_static_lon_isValid && m_static_orientation_isValid && true;
}

} // namespace OpenAPI
