/*
 * Mandrill
 * Mandrill is a reliable, scalable, and secure delivery API for transactional emails from websites and applications. It's ideal for sending data-driven transactional emails, including targeted e-commerce and personalized one-to-one messages. 
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.ApiKey;
import org.openapitools.client.model.Domain;
import org.openapitools.client.model.Email;
import org.openapitools.client.model.ExportsActivity;
import org.openapitools.client.model.ExportsInfoResponse;
import org.openapitools.client.model.ExportsListResponseInner;
import org.openapitools.client.model.ExportsSatus;
import org.openapitools.client.model.Id;
import org.openapitools.client.model.InboundAddRoute;
import org.openapitools.client.model.InboundDomainsResponseInner;
import org.openapitools.client.model.InboundInfo;
import org.openapitools.client.model.InboundRoutesResponseInner;
import org.openapitools.client.model.InboundSendRaw;
import org.openapitools.client.model.InboundSendRawResponseInner;
import org.openapitools.client.model.InboundUpdateRoute;
import org.openapitools.client.model.Ip;
import org.openapitools.client.model.IpDomain;
import org.openapitools.client.model.IpInfo;
import org.openapitools.client.model.IpsCheckCustomDnsResponse;
import org.openapitools.client.model.IpsDeletePoolResponse;
import org.openapitools.client.model.IpsDeleteResponse;
import org.openapitools.client.model.IpsListPoolsResponseInner;
import org.openapitools.client.model.IpsListPoolsResponseInnerIpsInner;
import org.openapitools.client.model.IpsPool;
import org.openapitools.client.model.IpsPoolKey;
import org.openapitools.client.model.IpsProvision;
import org.openapitools.client.model.IpsProvisionResponse;
import org.openapitools.client.model.IpsSetPool;
import org.openapitools.client.model.MessageSendStatusInner;
import org.openapitools.client.model.MessagesCancelScheduled;
import org.openapitools.client.model.MessagesContentResponse;
import org.openapitools.client.model.MessagesInfoResponse;
import org.openapitools.client.model.MessagesListScheduled;
import org.openapitools.client.model.MessagesListScheduledResponseInner;
import org.openapitools.client.model.MessagesParse;
import org.openapitools.client.model.MessagesParseResponse;
import org.openapitools.client.model.MessagesReschedule;
import org.openapitools.client.model.MessagesSearch;
import org.openapitools.client.model.MessagesSearchResponseInner;
import org.openapitools.client.model.MessagesSearchTimeSeries;
import org.openapitools.client.model.MessagesSend;
import org.openapitools.client.model.MessagesSendRaw;
import org.openapitools.client.model.MessagesSendTemplate;
import org.openapitools.client.model.MetadataInfo;
import org.openapitools.client.model.MetadataListResponseInner;
import org.openapitools.client.model.MetadataTemplate;
import org.openapitools.client.model.Name;
import org.openapitools.client.model.NotifyEmail;
import org.openapitools.client.model.RejectsAdd;
import org.openapitools.client.model.RejectsAddResponse;
import org.openapitools.client.model.RejectsDelete;
import org.openapitools.client.model.RejectsDeleteResponse;
import org.openapitools.client.model.RejectsList;
import org.openapitools.client.model.RejectsListResponseInner;
import org.openapitools.client.model.RejectsListResponseInnerSender;
import org.openapitools.client.model.Route;
import org.openapitools.client.model.SchedulingchangeInfo;
import org.openapitools.client.model.SenderAddress;
import org.openapitools.client.model.SenderDomainInfo;
import org.openapitools.client.model.SendersDomainsResponseInner;
import org.openapitools.client.model.SendersInfoResponse;
import org.openapitools.client.model.SendersVerifyDomain;
import org.openapitools.client.model.SendersVerifyDomainResponse;
import org.openapitools.client.model.SubaccountInfo;
import org.openapitools.client.model.SubaccountInfo2;
import org.openapitools.client.model.SubaccountsInfoResponse;
import org.openapitools.client.model.SubaccountsListResponseInner;
import org.openapitools.client.model.TagKey;
import org.openapitools.client.model.TagsDeleteResponse;
import org.openapitools.client.model.TagsInfoResponse;
import org.openapitools.client.model.TagsListResponseInner;
import org.openapitools.client.model.Template;
import org.openapitools.client.model.TemplateDetailed;
import org.openapitools.client.model.TemplatesList;
import org.openapitools.client.model.TemplatesListResponseInner;
import org.openapitools.client.model.TemplatesRender;
import org.openapitools.client.model.TemplatesRenderResponse;
import org.openapitools.client.model.TimeSeriesInner;
import org.openapitools.client.model.TimeseriesInner;
import org.openapitools.client.model.TrackingDomainStatus;
import org.openapitools.client.model.UrlInfosInner;
import org.openapitools.client.model.UrlKey;
import org.openapitools.client.model.UrlsTimeSeries;
import org.openapitools.client.model.UrlsTimeSeriesResponseInner;
import org.openapitools.client.model.UrlsTrackingDomainsResponseInner;
import org.openapitools.client.model.UsersInfoResponse;
import org.openapitools.client.model.UsersPing2Response;
import org.openapitools.client.model.Webhook;
import org.openapitools.client.model.WebhookKey;
import org.openapitools.client.model.WebhooksAdd;
import org.openapitools.client.model.WebhooksListResponseInner;
import org.openapitools.client.model.WebhooksUpdate;
import org.openapitools.client.model.WhitelistsAddResponse;
import org.openapitools.client.model.WhitelistsDeleteResponse;
import org.openapitools.client.model.WhitelistsListResponseInner;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for DefaultApi
 */
@Disabled
public class DefaultApiTest {

    private final DefaultApi api = new DefaultApi();

    /**
     * Begins an export of your activity history. The activity will be exported to a zip archive containing a single file named activity.csv in the same format as you would be able to export from your account&#39;s activity view. It includes the following fields: Date, Email Address, Sender, Subject, Status, Tags, Opens, Clicks, Bounce Detail. If you have configured any custom metadata fields, they will be included in the exported data.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void exportsActivityJsonPostTest() throws ApiException {
        ExportsActivity body = null;
        ExportsSatus response = api.exportsActivityJsonPost(body);
        // TODO: test validations
    }

    /**
     * Returns information about an export job. If the export job&#39;s state is &#39;complete&#39;, the returned data will include a URL you can use to fetch the results. Every export job produces a zip archive, but the format of the archive is distinct for each job type. The api calls that initiate exports include more details about the output format for that job type.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void exportsInfoJsonPostTest() throws ApiException {
        Id body = null;
        ExportsInfoResponse response = api.exportsInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Returns a list of your exports.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void exportsListJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<ExportsListResponseInner> response = api.exportsListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Begins an export of your rejection blacklist. The blacklist will be exported to a zip archive containing a single file named rejects.csv that includes the following fields: email, reason, detail, created_at, expires_at, last_event_at, expires_at.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void exportsRejectsJsonPostTest() throws ApiException {
        NotifyEmail body = null;
        ExportsSatus response = api.exportsRejectsJsonPost(body);
        // TODO: test validations
    }

    /**
     * Begins an export of your rejection whitelist. The whitelist will be exported to a zip archive containing a single file named whitelist.csv that includes the following fields: email, detail, created_at.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void exportsWhitelistJsonPostTest() throws ApiException {
        NotifyEmail body = null;
        ExportsSatus response = api.exportsWhitelistJsonPost(body);
        // TODO: test validations
    }

    /**
     * Add an inbound domain to your account
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void inboundAddDomainJsonPostTest() throws ApiException {
        Domain body = null;
        InboundInfo response = api.inboundAddDomainJsonPost(body);
        // TODO: test validations
    }

    /**
     * Add a new mailbox route to an inbound domain
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void inboundAddRouteJsonPostTest() throws ApiException {
        InboundAddRoute body = null;
        Route response = api.inboundAddRouteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Check the MX settings for an inbound domain. The domain must have already been added with the add-domain call
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void inboundCheckDomainJsonPostTest() throws ApiException {
        Domain body = null;
        InboundInfo response = api.inboundCheckDomainJsonPost(body);
        // TODO: test validations
    }

    /**
     * Delete an inbound domain from the account. All mail will stop routing for this domain immediately.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void inboundDeleteDomainJsonPostTest() throws ApiException {
        Domain body = null;
        InboundInfo response = api.inboundDeleteDomainJsonPost(body);
        // TODO: test validations
    }

    /**
     * Delete an existing inbound mailbox route
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void inboundDeleteRouteJsonPostTest() throws ApiException {
        Id body = null;
        Route response = api.inboundDeleteRouteJsonPost(body);
        // TODO: test validations
    }

    /**
     * List the domains that have been configured for inbound delivery
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void inboundDomainsJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<InboundDomainsResponseInner> response = api.inboundDomainsJsonPost(body);
        // TODO: test validations
    }

    /**
     * List the mailbox routes defined for an inbound domain
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void inboundRoutesJsonPostTest() throws ApiException {
        Domain body = null;
        List<InboundRoutesResponseInner> response = api.inboundRoutesJsonPost(body);
        // TODO: test validations
    }

    /**
     * Take a raw MIME document destined for a domain with inbound domains set up, and send it to the inbound hook exactly as if it had been sent over SMTP
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void inboundSendRawJsonPostTest() throws ApiException {
        InboundSendRaw body = null;
        List<InboundSendRawResponseInner> response = api.inboundSendRawJsonPost(body);
        // TODO: test validations
    }

    /**
     * Update the pattern or webhook of an existing inbound mailbox route. If null is provided for any fields, the values will remain unchanged.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void inboundUpdateRouteJsonPostTest() throws ApiException {
        InboundUpdateRoute body = null;
        Route response = api.inboundUpdateRouteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Cancels the warmup process for a dedicated IP.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsCancelWarmupJsonPostTest() throws ApiException {
        Ip body = null;
        IpInfo response = api.ipsCancelWarmupJsonPost(body);
        // TODO: test validations
    }

    /**
     * Tests whether a domain name is valid for use as the custom reverse DNS for a dedicated IP.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsCheckCustomDnsJsonPostTest() throws ApiException {
        IpDomain body = null;
        IpsCheckCustomDnsResponse response = api.ipsCheckCustomDnsJsonPost(body);
        // TODO: test validations
    }

    /**
     * Creates a pool and returns it. If a pool already exists with this name, no action will be performed.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsCreatePoolJsonPostTest() throws ApiException {
        IpsPoolKey body = null;
        IpsPool response = api.ipsCreatePoolJsonPost(body);
        // TODO: test validations
    }

    /**
     * Deletes a dedicated IP. This is permanent and cannot be undone.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsDeleteJsonPostTest() throws ApiException {
        Ip body = null;
        IpsDeleteResponse response = api.ipsDeleteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Deletes a pool. A pool must be empty before you can delete it, and you cannot delete your default pool.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsDeletePoolJsonPostTest() throws ApiException {
        IpsPoolKey body = null;
        IpsDeletePoolResponse response = api.ipsDeletePoolJsonPost(body);
        // TODO: test validations
    }

    /**
     * Retrieves information about a single dedicated ip.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsInfoJsonPostTest() throws ApiException {
        Ip body = null;
        IpInfo response = api.ipsInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Lists your dedicated IPs.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsListJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<IpsListPoolsResponseInnerIpsInner> response = api.ipsListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Lists your dedicated IP pools.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsListPoolsJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<IpsListPoolsResponseInner> response = api.ipsListPoolsJsonPost(body);
        // TODO: test validations
    }

    /**
     * Describes a single dedicated IP pool.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsPoolInfoJsonPostTest() throws ApiException {
        IpsPoolKey body = null;
        IpsPool response = api.ipsPoolInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Requests an additional dedicated IP for your account. Accounts may have one outstanding request at any time, and provisioning requests are processed within 24 hours.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsProvisionJsonPostTest() throws ApiException {
        IpsProvision body = null;
        IpsProvisionResponse response = api.ipsProvisionJsonPost(body);
        // TODO: test validations
    }

    /**
     * Configures the custom DNS name for a dedicated IP.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsSetCustomDnsJsonPostTest() throws ApiException {
        IpDomain body = null;
        IpInfo response = api.ipsSetCustomDnsJsonPost(body);
        // TODO: test validations
    }

    /**
     * Moves a dedicated IP to a different pool.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsSetPoolJsonPostTest() throws ApiException {
        IpsSetPool body = null;
        IpInfo response = api.ipsSetPoolJsonPost(body);
        // TODO: test validations
    }

    /**
     * Begins the warmup process for a dedicated IP. During the warmup process, Mandrill will gradually increase the percentage of your mail that is sent over the warming-up IP, over a period of roughly 30 days. The rest of your mail will be sent over shared IPs or other dedicated IPs in the same pool.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ipsStartWarmupJsonPostTest() throws ApiException {
        Ip body = null;
        IpInfo response = api.ipsStartWarmupJsonPost(body);
        // TODO: test validations
    }

    /**
     * Cancels a scheduled email.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesCancelScheduledJsonPostTest() throws ApiException {
        MessagesCancelScheduled body = null;
        SchedulingchangeInfo response = api.messagesCancelScheduledJsonPost(body);
        // TODO: test validations
    }

    /**
     * Get the full content of a recently sent message
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesContentJsonPostTest() throws ApiException {
        Id body = null;
        MessagesContentResponse response = api.messagesContentJsonPost(body);
        // TODO: test validations
    }

    /**
     * Get the information for a single recently sent message
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesInfoJsonPostTest() throws ApiException {
        Id body = null;
        MessagesInfoResponse response = api.messagesInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Queries your scheduled emails by sender or recipient, or both.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesListScheduledJsonPostTest() throws ApiException {
        MessagesListScheduled body = null;
        List<MessagesListScheduledResponseInner> response = api.messagesListScheduledJsonPost(body);
        // TODO: test validations
    }

    /**
     * Parse the full MIME document for an email message, returning the content of the message broken into its constituent pieces
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesParseJsonPostTest() throws ApiException {
        MessagesParse body = null;
        MessagesParseResponse response = api.messagesParseJsonPost(body);
        // TODO: test validations
    }

    /**
     * Reschedules a scheduled email.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesRescheduleJsonPostTest() throws ApiException {
        MessagesReschedule body = null;
        SchedulingchangeInfo response = api.messagesRescheduleJsonPost(body);
        // TODO: test validations
    }

    /**
     * Search the content of recently sent messages and optionally narrow by date range, tags and senders. This method may be called up to 20 times per minute. If you need the data more often, you can use /messages/info.json to get the information for a single message, or webhooks to push activity to your own application for querying.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesSearchJsonPostTest() throws ApiException {
        MessagesSearch body = null;
        List<MessagesSearchResponseInner> response = api.messagesSearchJsonPost(body);
        // TODO: test validations
    }

    /**
     * Search the content of recently sent messages and return the aggregated hourly stats for matching messages
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesSearchTimeSeriesJsonPostTest() throws ApiException {
        MessagesSearchTimeSeries body = null;
        List<TimeseriesInner> response = api.messagesSearchTimeSeriesJsonPost(body);
        // TODO: test validations
    }

    /**
     * Send a new transactional message through Mandrill
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesSendJsonPostTest() throws ApiException {
        MessagesSend body = null;
        List<MessageSendStatusInner> response = api.messagesSendJsonPost(body);
        // TODO: test validations
    }

    /**
     * Take a raw MIME document for a message, and send it exactly as if it were sent through Mandrill&#39;s SMTP servers
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesSendRawJsonPostTest() throws ApiException {
        MessagesSendRaw body = null;
        List<MessageSendStatusInner> response = api.messagesSendRawJsonPost(body);
        // TODO: test validations
    }

    /**
     * Send a new transactional message through Mandrill using a template
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void messagesSendTemplateJsonPostTest() throws ApiException {
        MessagesSendTemplate body = null;
        List<MessageSendStatusInner> response = api.messagesSendTemplateJsonPost(body);
        // TODO: test validations
    }

    /**
     * Add a new custom metadata field to be indexed for the account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void metadataAddJsonPostTest() throws ApiException {
        MetadataTemplate body = null;
        MetadataInfo response = api.metadataAddJsonPost(body);
        // TODO: test validations
    }

    /**
     * Delete an existing custom metadata field. Deletion isn&#39;t instataneous, and /metadata/list will continue to return the field until the asynchronous deletion process is complete.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void metadataDeleteJsonPostTest() throws ApiException {
        Name body = null;
        MetadataInfo response = api.metadataDeleteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Get the list of custom metadata fields indexed for the account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void metadataListJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<MetadataListResponseInner> response = api.metadataListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Update an existing custom metadata field.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void metadataUpdateJsonPostTest() throws ApiException {
        MetadataTemplate body = null;
        MetadataInfo response = api.metadataUpdateJsonPost(body);
        // TODO: test validations
    }

    /**
     * Adds an email to your email rejection blacklist. Addresses that you add manually will never expire and there is no reputation penalty for removing them from your blacklist. Attempting to blacklist an address that has been whitelisted will have no effect.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void rejectsAddJsonPostTest() throws ApiException {
        RejectsAdd body = null;
        RejectsAddResponse response = api.rejectsAddJsonPost(body);
        // TODO: test validations
    }

    /**
     * Deletes an email rejection. There is no limit to how many rejections you can remove from your blacklist, but keep in mind that each deletion has an affect on your reputation.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void rejectsDeleteJsonPostTest() throws ApiException {
        RejectsDelete body = null;
        RejectsDeleteResponse response = api.rejectsDeleteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Retrieves your email rejection blacklist. You can provide an email address to limit the results. Returns up to 1000 results. By default, entries that have expired are excluded from the results; set include_expired to true to include them.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void rejectsListJsonPostTest() throws ApiException {
        RejectsList body = null;
        List<RejectsListResponseInner> response = api.rejectsListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Adds a sender domain to your account. Sender domains are added automatically as you send, but you can use this call to add them ahead of time.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sendersAddDomainJsonPostTest() throws ApiException {
        Domain body = null;
        SenderDomainInfo response = api.sendersAddDomainJsonPost(body);
        // TODO: test validations
    }

    /**
     * Checks the SPF and DKIM settings for a domain. If you haven&#39;t already added this domain to your account, it will be added automatically.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sendersCheckDomainJsonPostTest() throws ApiException {
        Domain body = null;
        SenderDomainInfo response = api.sendersCheckDomainJsonPost(body);
        // TODO: test validations
    }

    /**
     * Returns the sender domains that have been added to this account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sendersDomainsJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<SendersDomainsResponseInner> response = api.sendersDomainsJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return more detailed information about a single sender, including aggregates of recent stats
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sendersInfoJsonPostTest() throws ApiException {
        SenderAddress body = null;
        SendersInfoResponse response = api.sendersInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return the senders that have tried to use this account.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sendersListJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<RejectsListResponseInnerSender> response = api.sendersListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return the recent history (hourly stats for the last 30 days) for a sender
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sendersTimeSeriesJsonPostTest() throws ApiException {
        SenderAddress body = null;
        List<TimeSeriesInner> response = api.sendersTimeSeriesJsonPost(body);
        // TODO: test validations
    }

    /**
     * Sends a verification email in order to verify ownership of a domain. Domain verification is an optional step to confirm ownership of a domain. Once a domain has been verified in a Mandrill account, other accounts may not have their messages signed by that domain unless they also verify the domain. This prevents other Mandrill accounts from sending mail signed by your domain.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sendersVerifyDomainJsonPostTest() throws ApiException {
        SendersVerifyDomain body = null;
        SendersVerifyDomainResponse response = api.sendersVerifyDomainJsonPost(body);
        // TODO: test validations
    }

    /**
     * Add a new subaccount
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subaccountsAddJsonPostTest() throws ApiException {
        SubaccountInfo body = null;
        SubaccountInfo2 response = api.subaccountsAddJsonPost(body);
        // TODO: test validations
    }

    /**
     * Delete an existing subaccount. Any email related to the subaccount will be saved, but stats will be removed and any future sending calls to this subaccount will fail.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subaccountsDeleteJsonPostTest() throws ApiException {
        Id body = null;
        SubaccountInfo2 response = api.subaccountsDeleteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Given the ID of an existing subaccount, return the data about it
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subaccountsInfoJsonPostTest() throws ApiException {
        Id body = null;
        SubaccountsInfoResponse response = api.subaccountsInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Get the list of subaccounts defined for the account, optionally filtered by a prefix
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subaccountsListJsonPostTest() throws ApiException {
        UrlKey body = null;
        List<SubaccountsListResponseInner> response = api.subaccountsListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Pause a subaccount&#39;s sending. Any future emails delivered to this subaccount will be queued for a maximum of 3 days until the subaccount is resumed.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subaccountsPauseJsonPostTest() throws ApiException {
        Id body = null;
        SubaccountInfo2 response = api.subaccountsPauseJsonPost(body);
        // TODO: test validations
    }

    /**
     * Resume a paused subaccount&#39;s sending
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subaccountsResumeJsonPostTest() throws ApiException {
        Id body = null;
        SubaccountInfo2 response = api.subaccountsResumeJsonPost(body);
        // TODO: test validations
    }

    /**
     * Update an existing subaccount
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subaccountsUpdateJsonPostTest() throws ApiException {
        SubaccountInfo body = null;
        SubaccountInfo2 response = api.subaccountsUpdateJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return the recent history (hourly stats for the last 30 days) for all tags
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tagsAllTimeSeriesJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<TimeseriesInner> response = api.tagsAllTimeSeriesJsonPost(body);
        // TODO: test validations
    }

    /**
     * Deletes a tag permanently. Deleting a tag removes the tag from any messages that have been sent, and also deletes the tag&#39;s stats. There is no way to undo this operation, so use it carefully.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tagsDeleteJsonPostTest() throws ApiException {
        TagKey body = null;
        TagsDeleteResponse response = api.tagsDeleteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return more detailed information about a single tag, including aggregates of recent stats
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tagsInfoJsonPostTest() throws ApiException {
        TagKey body = null;
        TagsInfoResponse response = api.tagsInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return all of the user-defined tag information
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tagsListJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<TagsListResponseInner> response = api.tagsListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return the recent history (hourly stats for the last 30 days) for a tag
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tagsTimeSeriesJsonPostTest() throws ApiException {
        TagKey body = null;
        List<TimeseriesInner> response = api.tagsTimeSeriesJsonPost(body);
        // TODO: test validations
    }

    /**
     * Add a new template
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void templatesAddJsonPostTest() throws ApiException {
        Template body = null;
        TemplateDetailed response = api.templatesAddJsonPost(body);
        // TODO: test validations
    }

    /**
     * Delete a template
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void templatesDeleteJsonPostTest() throws ApiException {
        Name body = null;
        TemplateDetailed response = api.templatesDeleteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Get the information for an existing template
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void templatesInfoJsonPostTest() throws ApiException {
        Name body = null;
        TemplateDetailed response = api.templatesInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return a list of all the templates available to this user
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void templatesListJsonPostTest() throws ApiException {
        TemplatesList body = null;
        List<TemplatesListResponseInner> response = api.templatesListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Publish the content for the template. Any new messages sent using this template will start using the content that was previously in draft.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void templatesPublishJsonPostTest() throws ApiException {
        Name body = null;
        TemplateDetailed response = api.templatesPublishJsonPost(body);
        // TODO: test validations
    }

    /**
     * Inject content and optionally merge fields into a template, returning the HTML that results
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void templatesRenderJsonPostTest() throws ApiException {
        TemplatesRender body = null;
        TemplatesRenderResponse response = api.templatesRenderJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return the recent history (hourly stats for the last 30 days) for a template
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void templatesTimeSeriesJsonPostTest() throws ApiException {
        Name body = null;
        List<TimeSeriesInner> response = api.templatesTimeSeriesJsonPost(body);
        // TODO: test validations
    }

    /**
     * Update the code for an existing template. If null is provided for any fields, the values will remain unchanged.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void templatesUpdateJsonPostTest() throws ApiException {
        Template body = null;
        TemplateDetailed response = api.templatesUpdateJsonPost(body);
        // TODO: test validations
    }

    /**
     * Add a tracking domain to your account
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void urlsAddTrackingDomainJsonPostTest() throws ApiException {
        Domain body = null;
        TrackingDomainStatus response = api.urlsAddTrackingDomainJsonPost(body);
        // TODO: test validations
    }

    /**
     * Checks the CNAME settings for a tracking domain. The domain must have been added already with the add-tracking-domain call
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void urlsCheckTrackingDomainJsonPostTest() throws ApiException {
        Domain body = null;
        TrackingDomainStatus response = api.urlsCheckTrackingDomainJsonPost(body);
        // TODO: test validations
    }

    /**
     * Get the 100 most clicked URLs
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void urlsListJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<UrlInfosInner> response = api.urlsListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return the 100 most clicked URLs that match the search query given
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void urlsSearchJsonPostTest() throws ApiException {
        UrlKey body = null;
        List<UrlInfosInner> response = api.urlsSearchJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return the recent history (hourly stats for the last 30 days) for a url
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void urlsTimeSeriesJsonPostTest() throws ApiException {
        UrlsTimeSeries body = null;
        List<UrlsTimeSeriesResponseInner> response = api.urlsTimeSeriesJsonPost(body);
        // TODO: test validations
    }

    /**
     * Get the list of tracking domains set up for this account
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void urlsTrackingDomainsJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<UrlsTrackingDomainsResponseInner> response = api.urlsTrackingDomainsJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return the information about the API-connected user
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersInfoJsonPostTest() throws ApiException {
        ApiKey body = null;
        UsersInfoResponse response = api.usersInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Validate an API key and respond to a ping (anal JSON parser version)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersPing2JsonPostTest() throws ApiException {
        ApiKey body = null;
        UsersPing2Response response = api.usersPing2JsonPost(body);
        // TODO: test validations
    }

    /**
     * Validate an API key and respond to a ping
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersPingJsonPostTest() throws ApiException {
        ApiKey body = null;
        api.usersPingJsonPost(body);
        // TODO: test validations
    }

    /**
     * Return the senders that have tried to use this account, both verified and unverified
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersSendersJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<RejectsListResponseInnerSender> response = api.usersSendersJsonPost(body);
        // TODO: test validations
    }

    /**
     * Add a new webhook
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webhooksAddJsonPostTest() throws ApiException {
        WebhooksAdd body = null;
        Webhook response = api.webhooksAddJsonPost(body);
        // TODO: test validations
    }

    /**
     * Delete an existing webhook
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webhooksDeleteJsonPostTest() throws ApiException {
        WebhookKey body = null;
        Webhook response = api.webhooksDeleteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Given the ID of an existing webhook, return the data about it
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webhooksInfoJsonPostTest() throws ApiException {
        WebhookKey body = null;
        Webhook response = api.webhooksInfoJsonPost(body);
        // TODO: test validations
    }

    /**
     * Get the list of all webhooks defined on the account
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webhooksListJsonPostTest() throws ApiException {
        ApiKey body = null;
        List<WebhooksListResponseInner> response = api.webhooksListJsonPost(body);
        // TODO: test validations
    }

    /**
     * Update an existing webhook
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void webhooksUpdateJsonPostTest() throws ApiException {
        WebhooksUpdate body = null;
        Webhook response = api.webhooksUpdateJsonPost(body);
        // TODO: test validations
    }

    /**
     * Adds an email to your email rejection whitelist. If the address is currently on your blacklist, that blacklist entry will be removed automatically.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void whitelistsAddJsonPostTest() throws ApiException {
        Email body = null;
        WhitelistsAddResponse response = api.whitelistsAddJsonPost(body);
        // TODO: test validations
    }

    /**
     * Removes an email address from the whitelist.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void whitelistsDeleteJsonPostTest() throws ApiException {
        Email body = null;
        WhitelistsDeleteResponse response = api.whitelistsDeleteJsonPost(body);
        // TODO: test validations
    }

    /**
     * Retrieves your email rejection whitelist. You can provide an email address or search prefix to limit the results. Returns up to 1000 results.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void whitelistsListJsonPostTest() throws ApiException {
        Email body = null;
        List<WhitelistsListResponseInner> response = api.whitelistsListJsonPost(body);
        // TODO: test validations
    }

}
