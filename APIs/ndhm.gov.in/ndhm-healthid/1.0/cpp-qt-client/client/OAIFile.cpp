/**
 * Health ID Service
 * It is important to standardize the process of identification of an individual across healthcare providers, to ensure that the created medical records are issued to the right individual or accessed by a Health Information User through appropriate consent.  In order to issue a Health ID to an individual, one only needs basic demographic details like Name, Year of Birth, Gender. In addition, citizens should be able to update contact information easily.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIFile.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIFile::OAIFile(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIFile::OAIFile() {
    this->initializeModel();
}

OAIFile::~OAIFile() {}

void OAIFile::initializeModel() {

    m_absolute_isSet = false;
    m_absolute_isValid = false;

    m_absolute_file_isSet = false;
    m_absolute_file_isValid = false;

    m_absolute_path_isSet = false;
    m_absolute_path_isValid = false;

    m_canonical_file_isSet = false;
    m_canonical_file_isValid = false;

    m_canonical_path_isSet = false;
    m_canonical_path_isValid = false;

    m_directory_isSet = false;
    m_directory_isValid = false;

    m_file_isSet = false;
    m_file_isValid = false;

    m_free_space_isSet = false;
    m_free_space_isValid = false;

    m_hidden_isSet = false;
    m_hidden_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_parent_isSet = false;
    m_parent_isValid = false;

    m_parent_file_isSet = false;
    m_parent_file_isValid = false;

    m_path_isSet = false;
    m_path_isValid = false;

    m_total_space_isSet = false;
    m_total_space_isValid = false;

    m_usable_space_isSet = false;
    m_usable_space_isValid = false;
}

void OAIFile::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIFile::fromJsonObject(QJsonObject json) {

    m_absolute_isValid = ::OpenAPI::fromJsonValue(m_absolute, json[QString("absolute")]);
    m_absolute_isSet = !json[QString("absolute")].isNull() && m_absolute_isValid;

    m_absolute_file_isValid = ::OpenAPI::fromJsonValue(m_absolute_file, json[QString("absoluteFile")]);
    m_absolute_file_isSet = !json[QString("absoluteFile")].isNull() && m_absolute_file_isValid;

    m_absolute_path_isValid = ::OpenAPI::fromJsonValue(m_absolute_path, json[QString("absolutePath")]);
    m_absolute_path_isSet = !json[QString("absolutePath")].isNull() && m_absolute_path_isValid;

    m_canonical_file_isValid = ::OpenAPI::fromJsonValue(m_canonical_file, json[QString("canonicalFile")]);
    m_canonical_file_isSet = !json[QString("canonicalFile")].isNull() && m_canonical_file_isValid;

    m_canonical_path_isValid = ::OpenAPI::fromJsonValue(m_canonical_path, json[QString("canonicalPath")]);
    m_canonical_path_isSet = !json[QString("canonicalPath")].isNull() && m_canonical_path_isValid;

    m_directory_isValid = ::OpenAPI::fromJsonValue(m_directory, json[QString("directory")]);
    m_directory_isSet = !json[QString("directory")].isNull() && m_directory_isValid;

    m_file_isValid = ::OpenAPI::fromJsonValue(m_file, json[QString("file")]);
    m_file_isSet = !json[QString("file")].isNull() && m_file_isValid;

    m_free_space_isValid = ::OpenAPI::fromJsonValue(m_free_space, json[QString("freeSpace")]);
    m_free_space_isSet = !json[QString("freeSpace")].isNull() && m_free_space_isValid;

    m_hidden_isValid = ::OpenAPI::fromJsonValue(m_hidden, json[QString("hidden")]);
    m_hidden_isSet = !json[QString("hidden")].isNull() && m_hidden_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_parent_isValid = ::OpenAPI::fromJsonValue(m_parent, json[QString("parent")]);
    m_parent_isSet = !json[QString("parent")].isNull() && m_parent_isValid;

    m_parent_file_isValid = ::OpenAPI::fromJsonValue(m_parent_file, json[QString("parentFile")]);
    m_parent_file_isSet = !json[QString("parentFile")].isNull() && m_parent_file_isValid;

    m_path_isValid = ::OpenAPI::fromJsonValue(m_path, json[QString("path")]);
    m_path_isSet = !json[QString("path")].isNull() && m_path_isValid;

    m_total_space_isValid = ::OpenAPI::fromJsonValue(m_total_space, json[QString("totalSpace")]);
    m_total_space_isSet = !json[QString("totalSpace")].isNull() && m_total_space_isValid;

    m_usable_space_isValid = ::OpenAPI::fromJsonValue(m_usable_space, json[QString("usableSpace")]);
    m_usable_space_isSet = !json[QString("usableSpace")].isNull() && m_usable_space_isValid;
}

QString OAIFile::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIFile::asJsonObject() const {
    QJsonObject obj;
    if (m_absolute_isSet) {
        obj.insert(QString("absolute"), ::OpenAPI::toJsonValue(m_absolute));
    }
    if (m_absolute_file.isSet()) {
        obj.insert(QString("absoluteFile"), ::OpenAPI::toJsonValue(m_absolute_file));
    }
    if (m_absolute_path_isSet) {
        obj.insert(QString("absolutePath"), ::OpenAPI::toJsonValue(m_absolute_path));
    }
    if (m_canonical_file.isSet()) {
        obj.insert(QString("canonicalFile"), ::OpenAPI::toJsonValue(m_canonical_file));
    }
    if (m_canonical_path_isSet) {
        obj.insert(QString("canonicalPath"), ::OpenAPI::toJsonValue(m_canonical_path));
    }
    if (m_directory_isSet) {
        obj.insert(QString("directory"), ::OpenAPI::toJsonValue(m_directory));
    }
    if (m_file_isSet) {
        obj.insert(QString("file"), ::OpenAPI::toJsonValue(m_file));
    }
    if (m_free_space_isSet) {
        obj.insert(QString("freeSpace"), ::OpenAPI::toJsonValue(m_free_space));
    }
    if (m_hidden_isSet) {
        obj.insert(QString("hidden"), ::OpenAPI::toJsonValue(m_hidden));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_parent_isSet) {
        obj.insert(QString("parent"), ::OpenAPI::toJsonValue(m_parent));
    }
    if (m_parent_file.isSet()) {
        obj.insert(QString("parentFile"), ::OpenAPI::toJsonValue(m_parent_file));
    }
    if (m_path_isSet) {
        obj.insert(QString("path"), ::OpenAPI::toJsonValue(m_path));
    }
    if (m_total_space_isSet) {
        obj.insert(QString("totalSpace"), ::OpenAPI::toJsonValue(m_total_space));
    }
    if (m_usable_space_isSet) {
        obj.insert(QString("usableSpace"), ::OpenAPI::toJsonValue(m_usable_space));
    }
    return obj;
}

bool OAIFile::isAbsolute() const {
    return m_absolute;
}
void OAIFile::setAbsolute(const bool &absolute) {
    m_absolute = absolute;
    m_absolute_isSet = true;
}

bool OAIFile::is_absolute_Set() const{
    return m_absolute_isSet;
}

bool OAIFile::is_absolute_Valid() const{
    return m_absolute_isValid;
}

OAIFile OAIFile::getAbsoluteFile() const {
    return m_absolute_file;
}
void OAIFile::setAbsoluteFile(const OAIFile &absolute_file) {
    m_absolute_file = absolute_file;
    m_absolute_file_isSet = true;
}

bool OAIFile::is_absolute_file_Set() const{
    return m_absolute_file_isSet;
}

bool OAIFile::is_absolute_file_Valid() const{
    return m_absolute_file_isValid;
}

QString OAIFile::getAbsolutePath() const {
    return m_absolute_path;
}
void OAIFile::setAbsolutePath(const QString &absolute_path) {
    m_absolute_path = absolute_path;
    m_absolute_path_isSet = true;
}

bool OAIFile::is_absolute_path_Set() const{
    return m_absolute_path_isSet;
}

bool OAIFile::is_absolute_path_Valid() const{
    return m_absolute_path_isValid;
}

OAIFile OAIFile::getCanonicalFile() const {
    return m_canonical_file;
}
void OAIFile::setCanonicalFile(const OAIFile &canonical_file) {
    m_canonical_file = canonical_file;
    m_canonical_file_isSet = true;
}

bool OAIFile::is_canonical_file_Set() const{
    return m_canonical_file_isSet;
}

bool OAIFile::is_canonical_file_Valid() const{
    return m_canonical_file_isValid;
}

QString OAIFile::getCanonicalPath() const {
    return m_canonical_path;
}
void OAIFile::setCanonicalPath(const QString &canonical_path) {
    m_canonical_path = canonical_path;
    m_canonical_path_isSet = true;
}

bool OAIFile::is_canonical_path_Set() const{
    return m_canonical_path_isSet;
}

bool OAIFile::is_canonical_path_Valid() const{
    return m_canonical_path_isValid;
}

bool OAIFile::isDirectory() const {
    return m_directory;
}
void OAIFile::setDirectory(const bool &directory) {
    m_directory = directory;
    m_directory_isSet = true;
}

bool OAIFile::is_directory_Set() const{
    return m_directory_isSet;
}

bool OAIFile::is_directory_Valid() const{
    return m_directory_isValid;
}

bool OAIFile::isFile() const {
    return m_file;
}
void OAIFile::setFile(const bool &file) {
    m_file = file;
    m_file_isSet = true;
}

bool OAIFile::is_file_Set() const{
    return m_file_isSet;
}

bool OAIFile::is_file_Valid() const{
    return m_file_isValid;
}

qint64 OAIFile::getFreeSpace() const {
    return m_free_space;
}
void OAIFile::setFreeSpace(const qint64 &free_space) {
    m_free_space = free_space;
    m_free_space_isSet = true;
}

bool OAIFile::is_free_space_Set() const{
    return m_free_space_isSet;
}

bool OAIFile::is_free_space_Valid() const{
    return m_free_space_isValid;
}

bool OAIFile::isHidden() const {
    return m_hidden;
}
void OAIFile::setHidden(const bool &hidden) {
    m_hidden = hidden;
    m_hidden_isSet = true;
}

bool OAIFile::is_hidden_Set() const{
    return m_hidden_isSet;
}

bool OAIFile::is_hidden_Valid() const{
    return m_hidden_isValid;
}

QString OAIFile::getName() const {
    return m_name;
}
void OAIFile::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIFile::is_name_Set() const{
    return m_name_isSet;
}

bool OAIFile::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIFile::getParent() const {
    return m_parent;
}
void OAIFile::setParent(const QString &parent) {
    m_parent = parent;
    m_parent_isSet = true;
}

bool OAIFile::is_parent_Set() const{
    return m_parent_isSet;
}

bool OAIFile::is_parent_Valid() const{
    return m_parent_isValid;
}

OAIFile OAIFile::getParentFile() const {
    return m_parent_file;
}
void OAIFile::setParentFile(const OAIFile &parent_file) {
    m_parent_file = parent_file;
    m_parent_file_isSet = true;
}

bool OAIFile::is_parent_file_Set() const{
    return m_parent_file_isSet;
}

bool OAIFile::is_parent_file_Valid() const{
    return m_parent_file_isValid;
}

QString OAIFile::getPath() const {
    return m_path;
}
void OAIFile::setPath(const QString &path) {
    m_path = path;
    m_path_isSet = true;
}

bool OAIFile::is_path_Set() const{
    return m_path_isSet;
}

bool OAIFile::is_path_Valid() const{
    return m_path_isValid;
}

qint64 OAIFile::getTotalSpace() const {
    return m_total_space;
}
void OAIFile::setTotalSpace(const qint64 &total_space) {
    m_total_space = total_space;
    m_total_space_isSet = true;
}

bool OAIFile::is_total_space_Set() const{
    return m_total_space_isSet;
}

bool OAIFile::is_total_space_Valid() const{
    return m_total_space_isValid;
}

qint64 OAIFile::getUsableSpace() const {
    return m_usable_space;
}
void OAIFile::setUsableSpace(const qint64 &usable_space) {
    m_usable_space = usable_space;
    m_usable_space_isSet = true;
}

bool OAIFile::is_usable_space_Set() const{
    return m_usable_space_isSet;
}

bool OAIFile::is_usable_space_Valid() const{
    return m_usable_space_isValid;
}

bool OAIFile::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_absolute_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_absolute_file.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_absolute_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_canonical_file.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_canonical_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_directory_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_file_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_free_space_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hidden_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_parent_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_parent_file.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_space_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_usable_space_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIFile::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
