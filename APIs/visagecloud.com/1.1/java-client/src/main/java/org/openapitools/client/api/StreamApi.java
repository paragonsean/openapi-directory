/*
 * VisageCloud
 * Face search, recognition & classification API. Just make a call to our REST API each time your app needs to access face recognition and classification capabilities.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: office@visagecloud.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.RestResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class StreamApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public StreamApi() {
        this(Configuration.getDefaultApiClient());
    }

    public StreamApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for addStreamUsingPOST
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param name The name of the stream that will be created (required)
     * @param url The url of the stream (required)
     * @param method Streaming method (optional, default to WEBRTC_PUSH)
     * @param username Username (optional)
     * @param password Password (optional)
     * @param skipFramesWithNoFaces Boolean value indicating whether you want the original picture to be stored for later retrieval (optional, default to true)
     * @param retentionTime Number of seconds for frames to be kept. Default is 605000s (7 days) (optional, default to 605000)
     * @param storeOriginalFrames Boolean value indicating whether you want the original picture to be stored for later retrieval (optional, default to false)
     * @param storeAttendanceFaces Boolean value indicating whether you want to store permanently store faces clippings of the recognized faces (optional, default to false)
     * @param storeAttendanceFrames Boolean value indicating whether you want to store permanently store frames with a recognized face in them (optional, default to false)
     * @param isActive Boolean value indicating whether the stream is currently active or not (optional, default to false)
     * @param associatedCollections List of collection ids which will be used to measure attendance (optional)
     * @param attributes Attributes of the stream (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addStreamUsingPOSTCall(String accessKey, String secretKey, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/stream";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (url != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url", url));
        }

        if (method != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("method", method));
        }

        if (username != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("username", username));
        }

        if (password != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("password", password));
        }

        if (skipFramesWithNoFaces != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipFramesWithNoFaces", skipFramesWithNoFaces));
        }

        if (retentionTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("retentionTime", retentionTime));
        }

        if (storeOriginalFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("storeOriginalFrames", storeOriginalFrames));
        }

        if (storeAttendanceFaces != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("storeAttendanceFaces", storeAttendanceFaces));
        }

        if (storeAttendanceFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("storeAttendanceFrames", storeAttendanceFrames));
        }

        if (isActive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isActive", isActive));
        }

        if (associatedCollections != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "associatedCollections", associatedCollections));
        }

        if (attributes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("attributes", attributes));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call addStreamUsingPOSTValidateBeforeCall(String accessKey, String secretKey, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling addStreamUsingPOST(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling addStreamUsingPOST(Async)");
        }

        // verify the required parameter 'name' is set
        if (name == null) {
            throw new ApiException("Missing the required parameter 'name' when calling addStreamUsingPOST(Async)");
        }

        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling addStreamUsingPOST(Async)");
        }

        return addStreamUsingPOSTCall(accessKey, secretKey, name, url, method, username, password, skipFramesWithNoFaces, retentionTime, storeOriginalFrames, storeAttendanceFaces, storeAttendanceFrames, isActive, associatedCollections, attributes, _callback);

    }

    /**
     * Create new stream with given name
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param name The name of the stream that will be created (required)
     * @param url The url of the stream (required)
     * @param method Streaming method (optional, default to WEBRTC_PUSH)
     * @param username Username (optional)
     * @param password Password (optional)
     * @param skipFramesWithNoFaces Boolean value indicating whether you want the original picture to be stored for later retrieval (optional, default to true)
     * @param retentionTime Number of seconds for frames to be kept. Default is 605000s (7 days) (optional, default to 605000)
     * @param storeOriginalFrames Boolean value indicating whether you want the original picture to be stored for later retrieval (optional, default to false)
     * @param storeAttendanceFaces Boolean value indicating whether you want to store permanently store faces clippings of the recognized faces (optional, default to false)
     * @param storeAttendanceFrames Boolean value indicating whether you want to store permanently store frames with a recognized face in them (optional, default to false)
     * @param isActive Boolean value indicating whether the stream is currently active or not (optional, default to false)
     * @param associatedCollections List of collection ids which will be used to measure attendance (optional)
     * @param attributes Attributes of the stream (optional)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse addStreamUsingPOST(String accessKey, String secretKey, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes) throws ApiException {
        ApiResponse<RestResponse> localVarResp = addStreamUsingPOSTWithHttpInfo(accessKey, secretKey, name, url, method, username, password, skipFramesWithNoFaces, retentionTime, storeOriginalFrames, storeAttendanceFaces, storeAttendanceFrames, isActive, associatedCollections, attributes);
        return localVarResp.getData();
    }

    /**
     * Create new stream with given name
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param name The name of the stream that will be created (required)
     * @param url The url of the stream (required)
     * @param method Streaming method (optional, default to WEBRTC_PUSH)
     * @param username Username (optional)
     * @param password Password (optional)
     * @param skipFramesWithNoFaces Boolean value indicating whether you want the original picture to be stored for later retrieval (optional, default to true)
     * @param retentionTime Number of seconds for frames to be kept. Default is 605000s (7 days) (optional, default to 605000)
     * @param storeOriginalFrames Boolean value indicating whether you want the original picture to be stored for later retrieval (optional, default to false)
     * @param storeAttendanceFaces Boolean value indicating whether you want to store permanently store faces clippings of the recognized faces (optional, default to false)
     * @param storeAttendanceFrames Boolean value indicating whether you want to store permanently store frames with a recognized face in them (optional, default to false)
     * @param isActive Boolean value indicating whether the stream is currently active or not (optional, default to false)
     * @param associatedCollections List of collection ids which will be used to measure attendance (optional)
     * @param attributes Attributes of the stream (optional)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> addStreamUsingPOSTWithHttpInfo(String accessKey, String secretKey, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes) throws ApiException {
        okhttp3.Call localVarCall = addStreamUsingPOSTValidateBeforeCall(accessKey, secretKey, name, url, method, username, password, skipFramesWithNoFaces, retentionTime, storeOriginalFrames, storeAttendanceFaces, storeAttendanceFrames, isActive, associatedCollections, attributes, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create new stream with given name (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param name The name of the stream that will be created (required)
     * @param url The url of the stream (required)
     * @param method Streaming method (optional, default to WEBRTC_PUSH)
     * @param username Username (optional)
     * @param password Password (optional)
     * @param skipFramesWithNoFaces Boolean value indicating whether you want the original picture to be stored for later retrieval (optional, default to true)
     * @param retentionTime Number of seconds for frames to be kept. Default is 605000s (7 days) (optional, default to 605000)
     * @param storeOriginalFrames Boolean value indicating whether you want the original picture to be stored for later retrieval (optional, default to false)
     * @param storeAttendanceFaces Boolean value indicating whether you want to store permanently store faces clippings of the recognized faces (optional, default to false)
     * @param storeAttendanceFrames Boolean value indicating whether you want to store permanently store frames with a recognized face in them (optional, default to false)
     * @param isActive Boolean value indicating whether the stream is currently active or not (optional, default to false)
     * @param associatedCollections List of collection ids which will be used to measure attendance (optional)
     * @param attributes Attributes of the stream (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call addStreamUsingPOSTAsync(String accessKey, String secretKey, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = addStreamUsingPOSTValidateBeforeCall(accessKey, secretKey, name, url, method, username, password, skipFramesWithNoFaces, retentionTime, storeOriginalFrames, storeAttendanceFaces, storeAttendanceFrames, isActive, associatedCollections, attributes, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cleanupStreamUsingPATCH
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be stopped (required)
     * @param interval Frames older than interval (seconds) will be cleaned up (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cleanupStreamUsingPATCHCall(String accessKey, String secretKey, String streamId, Integer interval, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/cleanup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        if (streamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamId", streamId));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cleanupStreamUsingPATCHValidateBeforeCall(String accessKey, String secretKey, String streamId, Integer interval, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling cleanupStreamUsingPATCH(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling cleanupStreamUsingPATCH(Async)");
        }

        // verify the required parameter 'streamId' is set
        if (streamId == null) {
            throw new ApiException("Missing the required parameter 'streamId' when calling cleanupStreamUsingPATCH(Async)");
        }

        // verify the required parameter 'interval' is set
        if (interval == null) {
            throw new ApiException("Missing the required parameter 'interval' when calling cleanupStreamUsingPATCH(Async)");
        }

        return cleanupStreamUsingPATCHCall(accessKey, secretKey, streamId, interval, _callback);

    }

    /**
     * Cleanup frames older than specified timeframe
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be stopped (required)
     * @param interval Frames older than interval (seconds) will be cleaned up (required)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse cleanupStreamUsingPATCH(String accessKey, String secretKey, String streamId, Integer interval) throws ApiException {
        ApiResponse<RestResponse> localVarResp = cleanupStreamUsingPATCHWithHttpInfo(accessKey, secretKey, streamId, interval);
        return localVarResp.getData();
    }

    /**
     * Cleanup frames older than specified timeframe
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be stopped (required)
     * @param interval Frames older than interval (seconds) will be cleaned up (required)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> cleanupStreamUsingPATCHWithHttpInfo(String accessKey, String secretKey, String streamId, Integer interval) throws ApiException {
        okhttp3.Call localVarCall = cleanupStreamUsingPATCHValidateBeforeCall(accessKey, secretKey, streamId, interval, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cleanup frames older than specified timeframe (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be stopped (required)
     * @param interval Frames older than interval (seconds) will be cleaned up (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cleanupStreamUsingPATCHAsync(String accessKey, String secretKey, String streamId, Integer interval, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = cleanupStreamUsingPATCHValidateBeforeCall(accessKey, secretKey, streamId, interval, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFrameImageUsingGET
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the frames will be retrieved (required)
     * @param timestamp Timestamp of frame to retrieve (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFrameImageUsingGETCall(String accessKey, String secretKey, String streamId, Long timestamp, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/frameImage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        if (streamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamId", streamId));
        }

        if (timestamp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("timestamp", timestamp));
        }

        final String[] localVarAccepts = {
            "image/jpeg"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFrameImageUsingGETValidateBeforeCall(String accessKey, String secretKey, String streamId, Long timestamp, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling getFrameImageUsingGET(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling getFrameImageUsingGET(Async)");
        }

        // verify the required parameter 'streamId' is set
        if (streamId == null) {
            throw new ApiException("Missing the required parameter 'streamId' when calling getFrameImageUsingGET(Async)");
        }

        // verify the required parameter 'timestamp' is set
        if (timestamp == null) {
            throw new ApiException("Missing the required parameter 'timestamp' when calling getFrameImageUsingGET(Async)");
        }

        return getFrameImageUsingGETCall(accessKey, secretKey, streamId, timestamp, _callback);

    }

    /**
     * Get individual frame image
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the frames will be retrieved (required)
     * @param timestamp Timestamp of frame to retrieve (required)
     * @return List&lt;byte[]&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public List<byte[]> getFrameImageUsingGET(String accessKey, String secretKey, String streamId, Long timestamp) throws ApiException {
        ApiResponse<List<byte[]>> localVarResp = getFrameImageUsingGETWithHttpInfo(accessKey, secretKey, streamId, timestamp);
        return localVarResp.getData();
    }

    /**
     * Get individual frame image
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the frames will be retrieved (required)
     * @param timestamp Timestamp of frame to retrieve (required)
     * @return ApiResponse&lt;List&lt;byte[]&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<byte[]>> getFrameImageUsingGETWithHttpInfo(String accessKey, String secretKey, String streamId, Long timestamp) throws ApiException {
        okhttp3.Call localVarCall = getFrameImageUsingGETValidateBeforeCall(accessKey, secretKey, streamId, timestamp, null);
        Type localVarReturnType = new TypeToken<List<byte[]>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get individual frame image (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the frames will be retrieved (required)
     * @param timestamp Timestamp of frame to retrieve (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFrameImageUsingGETAsync(String accessKey, String secretKey, String streamId, Long timestamp, final ApiCallback<List<byte[]>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFrameImageUsingGETValidateBeforeCall(accessKey, secretKey, streamId, timestamp, _callback);
        Type localVarReturnType = new TypeToken<List<byte[]>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getLastNAttedanceUsingGET
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamIds The id of the stream for which the frames will be retrieved (optional)
     * @param count How many frames to retrieve at a time (optional, default to 10)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLastNAttedanceUsingGETCall(String accessKey, String secretKey, List<String> streamIds, Integer count, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/attendance";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        if (streamIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "streamIds", streamIds));
        }

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getLastNAttedanceUsingGETValidateBeforeCall(String accessKey, String secretKey, List<String> streamIds, Integer count, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling getLastNAttedanceUsingGET(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling getLastNAttedanceUsingGET(Async)");
        }

        return getLastNAttedanceUsingGETCall(accessKey, secretKey, streamIds, count, _callback);

    }

    /**
     * Get last N recognized individuals from stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamIds The id of the stream for which the frames will be retrieved (optional)
     * @param count How many frames to retrieve at a time (optional, default to 10)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse getLastNAttedanceUsingGET(String accessKey, String secretKey, List<String> streamIds, Integer count) throws ApiException {
        ApiResponse<RestResponse> localVarResp = getLastNAttedanceUsingGETWithHttpInfo(accessKey, secretKey, streamIds, count);
        return localVarResp.getData();
    }

    /**
     * Get last N recognized individuals from stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamIds The id of the stream for which the frames will be retrieved (optional)
     * @param count How many frames to retrieve at a time (optional, default to 10)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> getLastNAttedanceUsingGETWithHttpInfo(String accessKey, String secretKey, List<String> streamIds, Integer count) throws ApiException {
        okhttp3.Call localVarCall = getLastNAttedanceUsingGETValidateBeforeCall(accessKey, secretKey, streamIds, count, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get last N recognized individuals from stream (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamIds The id of the stream for which the frames will be retrieved (optional)
     * @param count How many frames to retrieve at a time (optional, default to 10)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLastNAttedanceUsingGETAsync(String accessKey, String secretKey, List<String> streamIds, Integer count, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getLastNAttedanceUsingGETValidateBeforeCall(accessKey, secretKey, streamIds, count, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getLastNFramesUsingGET
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the frames will be retrieved (required)
     * @param count How many frames to retrieve at a time (optional, default to 10)
     * @param collectionId The collection id you want to run recognition against (optional)
     * @param labels Labels associated with the given picture or picture URL (optional)
     * @param attributeFilters Filters that will be applied on the recognition operation (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLastNFramesUsingGETCall(String accessKey, String secretKey, String streamId, Integer count, String collectionId, List<String> labels, List<String> attributeFilters, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/frames";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        if (streamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamId", streamId));
        }

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (labels != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "labels", labels));
        }

        if (attributeFilters != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "attributeFilters", attributeFilters));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getLastNFramesUsingGETValidateBeforeCall(String accessKey, String secretKey, String streamId, Integer count, String collectionId, List<String> labels, List<String> attributeFilters, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling getLastNFramesUsingGET(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling getLastNFramesUsingGET(Async)");
        }

        // verify the required parameter 'streamId' is set
        if (streamId == null) {
            throw new ApiException("Missing the required parameter 'streamId' when calling getLastNFramesUsingGET(Async)");
        }

        return getLastNFramesUsingGETCall(accessKey, secretKey, streamId, count, collectionId, labels, attributeFilters, _callback);

    }

    /**
     * Get last processed N frames from stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the frames will be retrieved (required)
     * @param count How many frames to retrieve at a time (optional, default to 10)
     * @param collectionId The collection id you want to run recognition against (optional)
     * @param labels Labels associated with the given picture or picture URL (optional)
     * @param attributeFilters Filters that will be applied on the recognition operation (optional)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse getLastNFramesUsingGET(String accessKey, String secretKey, String streamId, Integer count, String collectionId, List<String> labels, List<String> attributeFilters) throws ApiException {
        ApiResponse<RestResponse> localVarResp = getLastNFramesUsingGETWithHttpInfo(accessKey, secretKey, streamId, count, collectionId, labels, attributeFilters);
        return localVarResp.getData();
    }

    /**
     * Get last processed N frames from stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the frames will be retrieved (required)
     * @param count How many frames to retrieve at a time (optional, default to 10)
     * @param collectionId The collection id you want to run recognition against (optional)
     * @param labels Labels associated with the given picture or picture URL (optional)
     * @param attributeFilters Filters that will be applied on the recognition operation (optional)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> getLastNFramesUsingGETWithHttpInfo(String accessKey, String secretKey, String streamId, Integer count, String collectionId, List<String> labels, List<String> attributeFilters) throws ApiException {
        okhttp3.Call localVarCall = getLastNFramesUsingGETValidateBeforeCall(accessKey, secretKey, streamId, count, collectionId, labels, attributeFilters, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get last processed N frames from stream (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the frames will be retrieved (required)
     * @param count How many frames to retrieve at a time (optional, default to 10)
     * @param collectionId The collection id you want to run recognition against (optional)
     * @param labels Labels associated with the given picture or picture URL (optional)
     * @param attributeFilters Filters that will be applied on the recognition operation (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLastNFramesUsingGETAsync(String accessKey, String secretKey, String streamId, Integer count, String collectionId, List<String> labels, List<String> attributeFilters, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getLastNFramesUsingGETValidateBeforeCall(accessKey, secretKey, streamId, count, collectionId, labels, attributeFilters, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getStreamUsingGET
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the data will be retrieved (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getStreamUsingGETCall(String accessKey, String secretKey, String streamId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/{streamId}"
            .replace("{" + "streamId" + "}", localVarApiClient.escapeString(streamId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getStreamUsingGETValidateBeforeCall(String accessKey, String secretKey, String streamId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling getStreamUsingGET(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling getStreamUsingGET(Async)");
        }

        // verify the required parameter 'streamId' is set
        if (streamId == null) {
            throw new ApiException("Missing the required parameter 'streamId' when calling getStreamUsingGET(Async)");
        }

        return getStreamUsingGETCall(accessKey, secretKey, streamId, _callback);

    }

    /**
     * Get an existing stream with a given ID
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the data will be retrieved (required)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse getStreamUsingGET(String accessKey, String secretKey, String streamId) throws ApiException {
        ApiResponse<RestResponse> localVarResp = getStreamUsingGETWithHttpInfo(accessKey, secretKey, streamId);
        return localVarResp.getData();
    }

    /**
     * Get an existing stream with a given ID
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the data will be retrieved (required)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> getStreamUsingGETWithHttpInfo(String accessKey, String secretKey, String streamId) throws ApiException {
        okhttp3.Call localVarCall = getStreamUsingGETValidateBeforeCall(accessKey, secretKey, streamId, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get an existing stream with a given ID (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream for which the data will be retrieved (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getStreamUsingGETAsync(String accessKey, String secretKey, String streamId, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getStreamUsingGETValidateBeforeCall(accessKey, secretKey, streamId, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for removeStreamUsingDELETE
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param id The id of the stream that will be removed (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call removeStreamUsingDELETECall(String accessKey, String secretKey, String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call removeStreamUsingDELETEValidateBeforeCall(String accessKey, String secretKey, String id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling removeStreamUsingDELETE(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling removeStreamUsingDELETE(Async)");
        }

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling removeStreamUsingDELETE(Async)");
        }

        return removeStreamUsingDELETECall(accessKey, secretKey, id, _callback);

    }

    /**
     * Delete existing stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param id The id of the stream that will be removed (required)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse removeStreamUsingDELETE(String accessKey, String secretKey, String id) throws ApiException {
        ApiResponse<RestResponse> localVarResp = removeStreamUsingDELETEWithHttpInfo(accessKey, secretKey, id);
        return localVarResp.getData();
    }

    /**
     * Delete existing stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param id The id of the stream that will be removed (required)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> removeStreamUsingDELETEWithHttpInfo(String accessKey, String secretKey, String id) throws ApiException {
        okhttp3.Call localVarCall = removeStreamUsingDELETEValidateBeforeCall(accessKey, secretKey, id, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete existing stream (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param id The id of the stream that will be removed (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call removeStreamUsingDELETEAsync(String accessKey, String secretKey, String id, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = removeStreamUsingDELETEValidateBeforeCall(accessKey, secretKey, id, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for startStreamUsingPATCH
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be started (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startStreamUsingPATCHCall(String accessKey, String secretKey, String streamId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/start";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        if (streamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamId", streamId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call startStreamUsingPATCHValidateBeforeCall(String accessKey, String secretKey, String streamId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling startStreamUsingPATCH(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling startStreamUsingPATCH(Async)");
        }

        // verify the required parameter 'streamId' is set
        if (streamId == null) {
            throw new ApiException("Missing the required parameter 'streamId' when calling startStreamUsingPATCH(Async)");
        }

        return startStreamUsingPATCHCall(accessKey, secretKey, streamId, _callback);

    }

    /**
     * Start existing stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be started (required)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse startStreamUsingPATCH(String accessKey, String secretKey, String streamId) throws ApiException {
        ApiResponse<RestResponse> localVarResp = startStreamUsingPATCHWithHttpInfo(accessKey, secretKey, streamId);
        return localVarResp.getData();
    }

    /**
     * Start existing stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be started (required)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> startStreamUsingPATCHWithHttpInfo(String accessKey, String secretKey, String streamId) throws ApiException {
        okhttp3.Call localVarCall = startStreamUsingPATCHValidateBeforeCall(accessKey, secretKey, streamId, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Start existing stream (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be started (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startStreamUsingPATCHAsync(String accessKey, String secretKey, String streamId, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = startStreamUsingPATCHValidateBeforeCall(accessKey, secretKey, streamId, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for stopStreamUsingPATCH
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be stopped (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopStreamUsingPATCHCall(String accessKey, String secretKey, String streamId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/stop";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        if (streamId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("streamId", streamId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call stopStreamUsingPATCHValidateBeforeCall(String accessKey, String secretKey, String streamId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling stopStreamUsingPATCH(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling stopStreamUsingPATCH(Async)");
        }

        // verify the required parameter 'streamId' is set
        if (streamId == null) {
            throw new ApiException("Missing the required parameter 'streamId' when calling stopStreamUsingPATCH(Async)");
        }

        return stopStreamUsingPATCHCall(accessKey, secretKey, streamId, _callback);

    }

    /**
     * Stop existing stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be stopped (required)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse stopStreamUsingPATCH(String accessKey, String secretKey, String streamId) throws ApiException {
        ApiResponse<RestResponse> localVarResp = stopStreamUsingPATCHWithHttpInfo(accessKey, secretKey, streamId);
        return localVarResp.getData();
    }

    /**
     * Stop existing stream
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be stopped (required)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> stopStreamUsingPATCHWithHttpInfo(String accessKey, String secretKey, String streamId) throws ApiException {
        okhttp3.Call localVarCall = stopStreamUsingPATCHValidateBeforeCall(accessKey, secretKey, streamId, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Stop existing stream (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be stopped (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call stopStreamUsingPATCHAsync(String accessKey, String secretKey, String streamId, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = stopStreamUsingPATCHValidateBeforeCall(accessKey, secretKey, streamId, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for streamsByAccountUsingGET
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call streamsByAccountUsingGETCall(String accessKey, String secretKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/all";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call streamsByAccountUsingGETValidateBeforeCall(String accessKey, String secretKey, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling streamsByAccountUsingGET(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling streamsByAccountUsingGET(Async)");
        }

        return streamsByAccountUsingGETCall(accessKey, secretKey, _callback);

    }

    /**
     * Show status of all streams from account
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse streamsByAccountUsingGET(String accessKey, String secretKey) throws ApiException {
        ApiResponse<RestResponse> localVarResp = streamsByAccountUsingGETWithHttpInfo(accessKey, secretKey);
        return localVarResp.getData();
    }

    /**
     * Show status of all streams from account
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> streamsByAccountUsingGETWithHttpInfo(String accessKey, String secretKey) throws ApiException {
        okhttp3.Call localVarCall = streamsByAccountUsingGETValidateBeforeCall(accessKey, secretKey, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Show status of all streams from account (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey or readOnlyKey provided by VisageCloud (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call streamsByAccountUsingGETAsync(String accessKey, String secretKey, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = streamsByAccountUsingGETValidateBeforeCall(accessKey, secretKey, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateStreamUsingPATCH
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be updated (required)
     * @param name The name of the stream that will be updated (optional)
     * @param url The url of the stream (optional)
     * @param method Streaming method (optional)
     * @param username Username (optional)
     * @param password Password (optional)
     * @param skipFramesWithNoFaces Boolean value indicating whether you want the original picture to be stored for later retrieval (optional)
     * @param retentionTime Number of seconds for frames to be kept (optional)
     * @param storeOriginalFrames Boolean value indicating whether you want the original picture to be stored for later retrieval (optional)
     * @param storeAttendanceFaces Boolean value indicating whether you want to store permanently store faces clippings of the recognized faces (optional)
     * @param storeAttendanceFrames Boolean value indicating whether you want to store permanently store frames with a recognized face in them (optional)
     * @param isActive Boolean value indicating whether the stream is currently active or not (optional)
     * @param associatedCollections List of collection ids which will be used to measure attendance (optional)
     * @param attributes Attributes of the stream (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateStreamUsingPATCHCall(String accessKey, String secretKey, String streamId, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v1.1/stream/{streamId}"
            .replace("{" + "streamId" + "}", localVarApiClient.escapeString(streamId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (accessKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("accessKey", accessKey));
        }

        if (secretKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("secretKey", secretKey));
        }

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (url != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("url", url));
        }

        if (method != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("method", method));
        }

        if (username != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("username", username));
        }

        if (password != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("password", password));
        }

        if (skipFramesWithNoFaces != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipFramesWithNoFaces", skipFramesWithNoFaces));
        }

        if (retentionTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("retentionTime", retentionTime));
        }

        if (storeOriginalFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("storeOriginalFrames", storeOriginalFrames));
        }

        if (storeAttendanceFaces != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("storeAttendanceFaces", storeAttendanceFaces));
        }

        if (storeAttendanceFrames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("storeAttendanceFrames", storeAttendanceFrames));
        }

        if (isActive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isActive", isActive));
        }

        if (associatedCollections != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "associatedCollections", associatedCollections));
        }

        if (attributes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("attributes", attributes));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateStreamUsingPATCHValidateBeforeCall(String accessKey, String secretKey, String streamId, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accessKey' is set
        if (accessKey == null) {
            throw new ApiException("Missing the required parameter 'accessKey' when calling updateStreamUsingPATCH(Async)");
        }

        // verify the required parameter 'secretKey' is set
        if (secretKey == null) {
            throw new ApiException("Missing the required parameter 'secretKey' when calling updateStreamUsingPATCH(Async)");
        }

        // verify the required parameter 'streamId' is set
        if (streamId == null) {
            throw new ApiException("Missing the required parameter 'streamId' when calling updateStreamUsingPATCH(Async)");
        }

        return updateStreamUsingPATCHCall(accessKey, secretKey, streamId, name, url, method, username, password, skipFramesWithNoFaces, retentionTime, storeOriginalFrames, storeAttendanceFaces, storeAttendanceFrames, isActive, associatedCollections, attributes, _callback);

    }

    /**
     * Update an existing stream with a given ID
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be updated (required)
     * @param name The name of the stream that will be updated (optional)
     * @param url The url of the stream (optional)
     * @param method Streaming method (optional)
     * @param username Username (optional)
     * @param password Password (optional)
     * @param skipFramesWithNoFaces Boolean value indicating whether you want the original picture to be stored for later retrieval (optional)
     * @param retentionTime Number of seconds for frames to be kept (optional)
     * @param storeOriginalFrames Boolean value indicating whether you want the original picture to be stored for later retrieval (optional)
     * @param storeAttendanceFaces Boolean value indicating whether you want to store permanently store faces clippings of the recognized faces (optional)
     * @param storeAttendanceFrames Boolean value indicating whether you want to store permanently store frames with a recognized face in them (optional)
     * @param isActive Boolean value indicating whether the stream is currently active or not (optional)
     * @param associatedCollections List of collection ids which will be used to measure attendance (optional)
     * @param attributes Attributes of the stream (optional)
     * @return RestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public RestResponse updateStreamUsingPATCH(String accessKey, String secretKey, String streamId, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes) throws ApiException {
        ApiResponse<RestResponse> localVarResp = updateStreamUsingPATCHWithHttpInfo(accessKey, secretKey, streamId, name, url, method, username, password, skipFramesWithNoFaces, retentionTime, storeOriginalFrames, storeAttendanceFaces, storeAttendanceFrames, isActive, associatedCollections, attributes);
        return localVarResp.getData();
    }

    /**
     * Update an existing stream with a given ID
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be updated (required)
     * @param name The name of the stream that will be updated (optional)
     * @param url The url of the stream (optional)
     * @param method Streaming method (optional)
     * @param username Username (optional)
     * @param password Password (optional)
     * @param skipFramesWithNoFaces Boolean value indicating whether you want the original picture to be stored for later retrieval (optional)
     * @param retentionTime Number of seconds for frames to be kept (optional)
     * @param storeOriginalFrames Boolean value indicating whether you want the original picture to be stored for later retrieval (optional)
     * @param storeAttendanceFaces Boolean value indicating whether you want to store permanently store faces clippings of the recognized faces (optional)
     * @param storeAttendanceFrames Boolean value indicating whether you want to store permanently store frames with a recognized face in them (optional)
     * @param isActive Boolean value indicating whether the stream is currently active or not (optional)
     * @param associatedCollections List of collection ids which will be used to measure attendance (optional)
     * @param attributes Attributes of the stream (optional)
     * @return ApiResponse&lt;RestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestResponse> updateStreamUsingPATCHWithHttpInfo(String accessKey, String secretKey, String streamId, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes) throws ApiException {
        okhttp3.Call localVarCall = updateStreamUsingPATCHValidateBeforeCall(accessKey, secretKey, streamId, name, url, method, username, password, skipFramesWithNoFaces, retentionTime, storeOriginalFrames, storeAttendanceFaces, storeAttendanceFrames, isActive, associatedCollections, attributes, null);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update an existing stream with a given ID (asynchronously)
     * 
     * @param accessKey The accessKey provided by VisageCloud (required)
     * @param secretKey The secretKey provided by VisageCloud (required)
     * @param streamId The id of the stream that will be updated (required)
     * @param name The name of the stream that will be updated (optional)
     * @param url The url of the stream (optional)
     * @param method Streaming method (optional)
     * @param username Username (optional)
     * @param password Password (optional)
     * @param skipFramesWithNoFaces Boolean value indicating whether you want the original picture to be stored for later retrieval (optional)
     * @param retentionTime Number of seconds for frames to be kept (optional)
     * @param storeOriginalFrames Boolean value indicating whether you want the original picture to be stored for later retrieval (optional)
     * @param storeAttendanceFaces Boolean value indicating whether you want to store permanently store faces clippings of the recognized faces (optional)
     * @param storeAttendanceFrames Boolean value indicating whether you want to store permanently store frames with a recognized face in them (optional)
     * @param isActive Boolean value indicating whether the stream is currently active or not (optional)
     * @param associatedCollections List of collection ids which will be used to measure attendance (optional)
     * @param attributes Attributes of the stream (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateStreamUsingPATCHAsync(String accessKey, String secretKey, String streamId, String name, String url, String method, String username, String password, Boolean skipFramesWithNoFaces, Integer retentionTime, Boolean storeOriginalFrames, Boolean storeAttendanceFaces, Boolean storeAttendanceFrames, Boolean isActive, List<String> associatedCollections, String attributes, final ApiCallback<RestResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateStreamUsingPATCHValidateBeforeCall(accessKey, secretKey, streamId, name, url, method, username, password, skipFramesWithNoFaces, retentionTime, storeOriginalFrames, storeAttendanceFaces, storeAttendanceFrames, isActive, associatedCollections, attributes, _callback);
        Type localVarReturnType = new TypeToken<RestResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
