/*
 * Catalog Inventory
 * Catalog Inventory
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Source
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:28:50.311906-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Source {
  public static final String SERIALIZED_NAME_ARCHIVED_AT = "archived_at";
  @SerializedName(SERIALIZED_NAME_ARCHIVED_AT)
  private OffsetDateTime archivedAt;

  public static final String SERIALIZED_NAME_AVAILABILITY_MESSAGE = "availability_message";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_MESSAGE)
  private String availabilityMessage;

  public static final String SERIALIZED_NAME_AVAILABILITY_STATUS = "availability_status";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY_STATUS)
  private String availabilityStatus;

  public static final String SERIALIZED_NAME_CLOUD_CONNECTOR_ID = "cloud_connector_id";
  @SerializedName(SERIALIZED_NAME_CLOUD_CONNECTOR_ID)
  private String cloudConnectorId;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled = false;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_INFO = "info";
  @SerializedName(SERIALIZED_NAME_INFO)
  private Object info;

  public static final String SERIALIZED_NAME_LAST_AVAILABLE_AT = "last_available_at";
  @SerializedName(SERIALIZED_NAME_LAST_AVAILABLE_AT)
  private OffsetDateTime lastAvailableAt;

  public static final String SERIALIZED_NAME_LAST_CHECKED_AT = "last_checked_at";
  @SerializedName(SERIALIZED_NAME_LAST_CHECKED_AT)
  private OffsetDateTime lastCheckedAt;

  public static final String SERIALIZED_NAME_LAST_REFRESH_MESSAGE = "last_refresh_message";
  @SerializedName(SERIALIZED_NAME_LAST_REFRESH_MESSAGE)
  private String lastRefreshMessage;

  public static final String SERIALIZED_NAME_LAST_SUCCESSFUL_REFRESH_AT = "last_successful_refresh_at";
  @SerializedName(SERIALIZED_NAME_LAST_SUCCESSFUL_REFRESH_AT)
  private OffsetDateTime lastSuccessfulRefreshAt;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PREVIOUS_SHA = "previous_sha";
  @SerializedName(SERIALIZED_NAME_PREVIOUS_SHA)
  private String previousSha;

  public static final String SERIALIZED_NAME_PREVIOUS_SIZE = "previous_size";
  @SerializedName(SERIALIZED_NAME_PREVIOUS_SIZE)
  private Integer previousSize;

  public static final String SERIALIZED_NAME_REFRESH_FINISHED_AT = "refresh_finished_at";
  @SerializedName(SERIALIZED_NAME_REFRESH_FINISHED_AT)
  private OffsetDateTime refreshFinishedAt;

  public static final String SERIALIZED_NAME_REFRESH_STARTED_AT = "refresh_started_at";
  @SerializedName(SERIALIZED_NAME_REFRESH_STARTED_AT)
  private OffsetDateTime refreshStartedAt;

  public static final String SERIALIZED_NAME_REFRESH_STATE = "refresh_state";
  @SerializedName(SERIALIZED_NAME_REFRESH_STATE)
  private String refreshState;

  public static final String SERIALIZED_NAME_REFRESH_TASK_ID = "refresh_task_id";
  @SerializedName(SERIALIZED_NAME_REFRESH_TASK_ID)
  private UUID refreshTaskId;

  public static final String SERIALIZED_NAME_UID = "uid";
  @SerializedName(SERIALIZED_NAME_UID)
  private String uid;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  private OffsetDateTime updatedAt;

  public Source() {
  }

  public Source(
     OffsetDateTime archivedAt, 
     String availabilityMessage, 
     String cloudConnectorId, 
     OffsetDateTime createdAt, 
     Boolean enabled, 
     String id, 
     Object info, 
     OffsetDateTime lastAvailableAt, 
     OffsetDateTime lastCheckedAt, 
     String lastRefreshMessage, 
     OffsetDateTime lastSuccessfulRefreshAt, 
     String name, 
     String previousSha, 
     Integer previousSize, 
     OffsetDateTime refreshFinishedAt, 
     OffsetDateTime refreshStartedAt, 
     UUID refreshTaskId, 
     String uid, 
     OffsetDateTime updatedAt
  ) {
    this();
    this.archivedAt = archivedAt;
    this.availabilityMessage = availabilityMessage;
    this.cloudConnectorId = cloudConnectorId;
    this.createdAt = createdAt;
    this.enabled = enabled;
    this.id = id;
    this.info = info;
    this.lastAvailableAt = lastAvailableAt;
    this.lastCheckedAt = lastCheckedAt;
    this.lastRefreshMessage = lastRefreshMessage;
    this.lastSuccessfulRefreshAt = lastSuccessfulRefreshAt;
    this.name = name;
    this.previousSha = previousSha;
    this.previousSize = previousSize;
    this.refreshFinishedAt = refreshFinishedAt;
    this.refreshStartedAt = refreshStartedAt;
    this.refreshTaskId = refreshTaskId;
    this.uid = uid;
    this.updatedAt = updatedAt;
  }

  /**
   * Get archivedAt
   * @return archivedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getArchivedAt() {
    return archivedAt;
  }



  /**
   * Get availabilityMessage
   * @return availabilityMessage
   */
  @javax.annotation.Nullable
  public String getAvailabilityMessage() {
    return availabilityMessage;
  }



  public Source availabilityStatus(String availabilityStatus) {
    this.availabilityStatus = availabilityStatus;
    return this;
  }

  /**
   * Get availabilityStatus
   * @return availabilityStatus
   */
  @javax.annotation.Nullable
  public String getAvailabilityStatus() {
    return availabilityStatus;
  }

  public void setAvailabilityStatus(String availabilityStatus) {
    this.availabilityStatus = availabilityStatus;
  }


  /**
   * Get cloudConnectorId
   * @return cloudConnectorId
   */
  @javax.annotation.Nullable
  public String getCloudConnectorId() {
    return cloudConnectorId;
  }



  /**
   * Get createdAt
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  /**
   * Get enabled
   * @return enabled
   */
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }



  /**
   * ID of the resource
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  /**
   * Get info
   * @return info
   */
  @javax.annotation.Nullable
  public Object getInfo() {
    return info;
  }



  /**
   * Get lastAvailableAt
   * @return lastAvailableAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastAvailableAt() {
    return lastAvailableAt;
  }



  /**
   * Get lastCheckedAt
   * @return lastCheckedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastCheckedAt() {
    return lastCheckedAt;
  }



  /**
   * Get lastRefreshMessage
   * @return lastRefreshMessage
   */
  @javax.annotation.Nullable
  public String getLastRefreshMessage() {
    return lastRefreshMessage;
  }



  /**
   * Get lastSuccessfulRefreshAt
   * @return lastSuccessfulRefreshAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastSuccessfulRefreshAt() {
    return lastSuccessfulRefreshAt;
  }



  /**
   * Get name
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  /**
   * Get previousSha
   * @return previousSha
   */
  @javax.annotation.Nullable
  public String getPreviousSha() {
    return previousSha;
  }



  /**
   * Get previousSize
   * @return previousSize
   */
  @javax.annotation.Nullable
  public Integer getPreviousSize() {
    return previousSize;
  }



  /**
   * Get refreshFinishedAt
   * @return refreshFinishedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getRefreshFinishedAt() {
    return refreshFinishedAt;
  }



  /**
   * Get refreshStartedAt
   * @return refreshStartedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getRefreshStartedAt() {
    return refreshStartedAt;
  }



  public Source refreshState(String refreshState) {
    this.refreshState = refreshState;
    return this;
  }

  /**
   * Get refreshState
   * @return refreshState
   */
  @javax.annotation.Nullable
  public String getRefreshState() {
    return refreshState;
  }

  public void setRefreshState(String refreshState) {
    this.refreshState = refreshState;
  }


  /**
   * Get refreshTaskId
   * @return refreshTaskId
   */
  @javax.annotation.Nullable
  public UUID getRefreshTaskId() {
    return refreshTaskId;
  }



  /**
   * Get uid
   * @return uid
   */
  @javax.annotation.Nullable
  public String getUid() {
    return uid;
  }



  /**
   * Get updatedAt
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Source source = (Source) o;
    return Objects.equals(this.archivedAt, source.archivedAt) &&
        Objects.equals(this.availabilityMessage, source.availabilityMessage) &&
        Objects.equals(this.availabilityStatus, source.availabilityStatus) &&
        Objects.equals(this.cloudConnectorId, source.cloudConnectorId) &&
        Objects.equals(this.createdAt, source.createdAt) &&
        Objects.equals(this.enabled, source.enabled) &&
        Objects.equals(this.id, source.id) &&
        Objects.equals(this.info, source.info) &&
        Objects.equals(this.lastAvailableAt, source.lastAvailableAt) &&
        Objects.equals(this.lastCheckedAt, source.lastCheckedAt) &&
        Objects.equals(this.lastRefreshMessage, source.lastRefreshMessage) &&
        Objects.equals(this.lastSuccessfulRefreshAt, source.lastSuccessfulRefreshAt) &&
        Objects.equals(this.name, source.name) &&
        Objects.equals(this.previousSha, source.previousSha) &&
        Objects.equals(this.previousSize, source.previousSize) &&
        Objects.equals(this.refreshFinishedAt, source.refreshFinishedAt) &&
        Objects.equals(this.refreshStartedAt, source.refreshStartedAt) &&
        Objects.equals(this.refreshState, source.refreshState) &&
        Objects.equals(this.refreshTaskId, source.refreshTaskId) &&
        Objects.equals(this.uid, source.uid) &&
        Objects.equals(this.updatedAt, source.updatedAt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(archivedAt, availabilityMessage, availabilityStatus, cloudConnectorId, createdAt, enabled, id, info, lastAvailableAt, lastCheckedAt, lastRefreshMessage, lastSuccessfulRefreshAt, name, previousSha, previousSize, refreshFinishedAt, refreshStartedAt, refreshState, refreshTaskId, uid, updatedAt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Source {\n");
    sb.append("    archivedAt: ").append(toIndentedString(archivedAt)).append("\n");
    sb.append("    availabilityMessage: ").append(toIndentedString(availabilityMessage)).append("\n");
    sb.append("    availabilityStatus: ").append(toIndentedString(availabilityStatus)).append("\n");
    sb.append("    cloudConnectorId: ").append(toIndentedString(cloudConnectorId)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    info: ").append(toIndentedString(info)).append("\n");
    sb.append("    lastAvailableAt: ").append(toIndentedString(lastAvailableAt)).append("\n");
    sb.append("    lastCheckedAt: ").append(toIndentedString(lastCheckedAt)).append("\n");
    sb.append("    lastRefreshMessage: ").append(toIndentedString(lastRefreshMessage)).append("\n");
    sb.append("    lastSuccessfulRefreshAt: ").append(toIndentedString(lastSuccessfulRefreshAt)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    previousSha: ").append(toIndentedString(previousSha)).append("\n");
    sb.append("    previousSize: ").append(toIndentedString(previousSize)).append("\n");
    sb.append("    refreshFinishedAt: ").append(toIndentedString(refreshFinishedAt)).append("\n");
    sb.append("    refreshStartedAt: ").append(toIndentedString(refreshStartedAt)).append("\n");
    sb.append("    refreshState: ").append(toIndentedString(refreshState)).append("\n");
    sb.append("    refreshTaskId: ").append(toIndentedString(refreshTaskId)).append("\n");
    sb.append("    uid: ").append(toIndentedString(uid)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("archived_at");
    openapiFields.add("availability_message");
    openapiFields.add("availability_status");
    openapiFields.add("cloud_connector_id");
    openapiFields.add("created_at");
    openapiFields.add("enabled");
    openapiFields.add("id");
    openapiFields.add("info");
    openapiFields.add("last_available_at");
    openapiFields.add("last_checked_at");
    openapiFields.add("last_refresh_message");
    openapiFields.add("last_successful_refresh_at");
    openapiFields.add("name");
    openapiFields.add("previous_sha");
    openapiFields.add("previous_size");
    openapiFields.add("refresh_finished_at");
    openapiFields.add("refresh_started_at");
    openapiFields.add("refresh_state");
    openapiFields.add("refresh_task_id");
    openapiFields.add("uid");
    openapiFields.add("updated_at");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Source
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Source.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Source is not found in the empty JSON string", Source.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Source.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Source` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("availability_message") != null && !jsonObj.get("availability_message").isJsonNull()) && !jsonObj.get("availability_message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availability_message` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availability_message").toString()));
      }
      if ((jsonObj.get("availability_status") != null && !jsonObj.get("availability_status").isJsonNull()) && !jsonObj.get("availability_status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availability_status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availability_status").toString()));
      }
      if ((jsonObj.get("cloud_connector_id") != null && !jsonObj.get("cloud_connector_id").isJsonNull()) && !jsonObj.get("cloud_connector_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cloud_connector_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cloud_connector_id").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("last_refresh_message") != null && !jsonObj.get("last_refresh_message").isJsonNull()) && !jsonObj.get("last_refresh_message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `last_refresh_message` to be a primitive type in the JSON string but got `%s`", jsonObj.get("last_refresh_message").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("previous_sha") != null && !jsonObj.get("previous_sha").isJsonNull()) && !jsonObj.get("previous_sha").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `previous_sha` to be a primitive type in the JSON string but got `%s`", jsonObj.get("previous_sha").toString()));
      }
      if ((jsonObj.get("refresh_state") != null && !jsonObj.get("refresh_state").isJsonNull()) && !jsonObj.get("refresh_state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `refresh_state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("refresh_state").toString()));
      }
      if ((jsonObj.get("refresh_task_id") != null && !jsonObj.get("refresh_task_id").isJsonNull()) && !jsonObj.get("refresh_task_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `refresh_task_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("refresh_task_id").toString()));
      }
      if ((jsonObj.get("uid") != null && !jsonObj.get("uid").isJsonNull()) && !jsonObj.get("uid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uid").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Source.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Source' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Source> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Source.class));

       return (TypeAdapter<T>) new TypeAdapter<Source>() {
           @Override
           public void write(JsonWriter out, Source value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Source read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Source given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Source
   * @throws IOException if the JSON string is invalid with respect to Source
   */
  public static Source fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Source.class);
  }

  /**
   * Convert an instance of Source to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

