/**
 * Arespass
 * Analyzes a password and calculates its entropy.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import EcAlphabetSequenceInner from './EcAlphabetSequenceInner';
import EcEntropyDistributionInner from './EcEntropyDistributionInner';
import EcKeyboardSequenceInner from './EcKeyboardSequenceInner';
import EcNumberSequenceInner from './EcNumberSequenceInner';
import EcRepeatedCharsInner from './EcRepeatedCharsInner';
import EcTotalInner from './EcTotalInner';
import EcWordsInner from './EcWordsInner';

/**
 * The Ec model module.
 * @module model/Ec
 * @version 1.0
 */
class Ec {
    /**
     * Constructs a new <code>Ec</code>.
     * @alias module:model/Ec
     */
    constructor() { 
        
        Ec.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Ec</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Ec} obj Optional instance to populate.
     * @return {module:model/Ec} The populated <code>Ec</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Ec();

            if (data.hasOwnProperty('alphabetSequence')) {
                obj['alphabetSequence'] = ApiClient.convertToType(data['alphabetSequence'], [EcAlphabetSequenceInner]);
            }
            if (data.hasOwnProperty('apiVersion')) {
                obj['apiVersion'] = ApiClient.convertToType(data['apiVersion'], 'String');
            }
            if (data.hasOwnProperty('detectedKeyboard')) {
                obj['detectedKeyboard'] = ApiClient.convertToType(data['detectedKeyboard'], 'String');
            }
            if (data.hasOwnProperty('efficiency')) {
                obj['efficiency'] = ApiClient.convertToType(data['efficiency'], 'Number');
            }
            if (data.hasOwnProperty('entropy')) {
                obj['entropy'] = ApiClient.convertToType(data['entropy'], 'Number');
            }
            if (data.hasOwnProperty('entropyDistribution')) {
                obj['entropyDistribution'] = ApiClient.convertToType(data['entropyDistribution'], [EcEntropyDistributionInner]);
            }
            if (data.hasOwnProperty('idealEntropy')) {
                obj['idealEntropy'] = ApiClient.convertToType(data['idealEntropy'], 'Number');
            }
            if (data.hasOwnProperty('keyboardSequence')) {
                obj['keyboardSequence'] = ApiClient.convertToType(data['keyboardSequence'], [EcKeyboardSequenceInner]);
            }
            if (data.hasOwnProperty('l33tPassword')) {
                obj['l33tPassword'] = ApiClient.convertToType(data['l33tPassword'], 'String');
            }
            if (data.hasOwnProperty('nonUniformEntropyDistributionPenalty')) {
                obj['nonUniformEntropyDistributionPenalty'] = ApiClient.convertToType(data['nonUniformEntropyDistributionPenalty'], 'Number');
            }
            if (data.hasOwnProperty('numberSequence')) {
                obj['numberSequence'] = ApiClient.convertToType(data['numberSequence'], [EcNumberSequenceInner]);
            }
            if (data.hasOwnProperty('password')) {
                obj['password'] = ApiClient.convertToType(data['password'], 'String');
            }
            if (data.hasOwnProperty('passwordLength')) {
                obj['passwordLength'] = ApiClient.convertToType(data['passwordLength'], 'Number');
            }
            if (data.hasOwnProperty('penalty')) {
                obj['penalty'] = ApiClient.convertToType(data['penalty'], 'Number');
            }
            if (data.hasOwnProperty('repeatedChars')) {
                obj['repeatedChars'] = ApiClient.convertToType(data['repeatedChars'], [EcRepeatedCharsInner]);
            }
            if (data.hasOwnProperty('requestId')) {
                obj['requestId'] = ApiClient.convertToType(data['requestId'], 'String');
            }
            if (data.hasOwnProperty('requestTimestamp')) {
                obj['requestTimestamp'] = ApiClient.convertToType(data['requestTimestamp'], 'Number');
            }
            if (data.hasOwnProperty('summary')) {
                obj['summary'] = ApiClient.convertToType(data['summary'], ['String']);
            }
            if (data.hasOwnProperty('total')) {
                obj['total'] = ApiClient.convertToType(data['total'], [EcTotalInner]);
            }
            if (data.hasOwnProperty('words')) {
                obj['words'] = ApiClient.convertToType(data['words'], [EcWordsInner]);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Ec</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Ec</code>.
     */
    static validateJSON(data) {
        if (data['alphabetSequence']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['alphabetSequence'])) {
                throw new Error("Expected the field `alphabetSequence` to be an array in the JSON data but got " + data['alphabetSequence']);
            }
            // validate the optional field `alphabetSequence` (array)
            for (const item of data['alphabetSequence']) {
                EcAlphabetSequenceInner.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['apiVersion'] && !(typeof data['apiVersion'] === 'string' || data['apiVersion'] instanceof String)) {
            throw new Error("Expected the field `apiVersion` to be a primitive type in the JSON string but got " + data['apiVersion']);
        }
        // ensure the json data is a string
        if (data['detectedKeyboard'] && !(typeof data['detectedKeyboard'] === 'string' || data['detectedKeyboard'] instanceof String)) {
            throw new Error("Expected the field `detectedKeyboard` to be a primitive type in the JSON string but got " + data['detectedKeyboard']);
        }
        if (data['entropyDistribution']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['entropyDistribution'])) {
                throw new Error("Expected the field `entropyDistribution` to be an array in the JSON data but got " + data['entropyDistribution']);
            }
            // validate the optional field `entropyDistribution` (array)
            for (const item of data['entropyDistribution']) {
                EcEntropyDistributionInner.validateJSON(item);
            };
        }
        if (data['keyboardSequence']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['keyboardSequence'])) {
                throw new Error("Expected the field `keyboardSequence` to be an array in the JSON data but got " + data['keyboardSequence']);
            }
            // validate the optional field `keyboardSequence` (array)
            for (const item of data['keyboardSequence']) {
                EcKeyboardSequenceInner.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['l33tPassword'] && !(typeof data['l33tPassword'] === 'string' || data['l33tPassword'] instanceof String)) {
            throw new Error("Expected the field `l33tPassword` to be a primitive type in the JSON string but got " + data['l33tPassword']);
        }
        if (data['numberSequence']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['numberSequence'])) {
                throw new Error("Expected the field `numberSequence` to be an array in the JSON data but got " + data['numberSequence']);
            }
            // validate the optional field `numberSequence` (array)
            for (const item of data['numberSequence']) {
                EcNumberSequenceInner.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['password'] && !(typeof data['password'] === 'string' || data['password'] instanceof String)) {
            throw new Error("Expected the field `password` to be a primitive type in the JSON string but got " + data['password']);
        }
        if (data['repeatedChars']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['repeatedChars'])) {
                throw new Error("Expected the field `repeatedChars` to be an array in the JSON data but got " + data['repeatedChars']);
            }
            // validate the optional field `repeatedChars` (array)
            for (const item of data['repeatedChars']) {
                EcRepeatedCharsInner.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['requestId'] && !(typeof data['requestId'] === 'string' || data['requestId'] instanceof String)) {
            throw new Error("Expected the field `requestId` to be a primitive type in the JSON string but got " + data['requestId']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['summary'])) {
            throw new Error("Expected the field `summary` to be an array in the JSON data but got " + data['summary']);
        }
        if (data['total']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['total'])) {
                throw new Error("Expected the field `total` to be an array in the JSON data but got " + data['total']);
            }
            // validate the optional field `total` (array)
            for (const item of data['total']) {
                EcTotalInner.validateJSON(item);
            };
        }
        if (data['words']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['words'])) {
                throw new Error("Expected the field `words` to be an array in the JSON data but got " + data['words']);
            }
            // validate the optional field `words` (array)
            for (const item of data['words']) {
                EcWordsInner.validateJSON(item);
            };
        }

        return true;
    }


}



/**
 * **The penalty applied to each character that has been found to be part of an alphabet sequence.**  The penalty is a float number in the range [0, 1]. Full penalty, 0; no penalty, 1. 
 * @member {Array.<module:model/EcAlphabetSequenceInner>} alphabetSequence
 */
Ec.prototype['alphabetSequence'] = undefined;

/**
 * **This API version number.** 
 * @member {String} apiVersion
 */
Ec.prototype['apiVersion'] = undefined;

/**
 * **The detected keyboard, QWERTY or Dvorak.** 
 * @member {String} detectedKeyboard
 */
Ec.prototype['detectedKeyboard'] = undefined;

/**
 * **The ratio entropy / idealEntropy.**  It is a float number in the range [0, 1]. 
 * @member {Number} efficiency
 */
Ec.prototype['efficiency'] = undefined;

/**
 * **The entropy calculated for the input password.**  It is measured in bits. 
 * @member {Number} entropy
 */
Ec.prototype['entropy'] = undefined;

/**
 * **The distribution of the calculated entropy among the password characters.** 
 * @member {Array.<module:model/EcEntropyDistributionInner>} entropyDistribution
 */
Ec.prototype['entropyDistribution'] = undefined;

/**
 * **The Shannon entropy.**  The Shannon entropy is the entropy calculated if no penalizations - words, number sequence, alphabet sequence, etc - were found in the password.  It is measured in bits. 
 * @member {Number} idealEntropy
 */
Ec.prototype['idealEntropy'] = undefined;

/**
 * **The penalty applied to each character that has been found to be part of a keyboard sequence.**  The penalty is a float number in the range [0, 1]. Full penalty, 0; no penalty, 1. 
 * @member {Array.<module:model/EcKeyboardSequenceInner>} keyboardSequence
 */
Ec.prototype['keyboardSequence'] = undefined;

/**
 * The analyzed password after the l33t substitution.
 * @member {String} l33tPassword
 */
Ec.prototype['l33tPassword'] = undefined;

/**
 * **The penalty applied to the whole password because of irregular entropy distribution.**  This penalty is a float number in the range [0, 1]. Full penalty, 0; no penalty, 1. 
 * @member {Number} nonUniformEntropyDistributionPenalty
 */
Ec.prototype['nonUniformEntropyDistributionPenalty'] = undefined;

/**
 * **The penalty applied to each character that has been found to be part of a number sequence.**  The penalty is a float number in the range [0, 1]. Full penalty, 0; no penalty, 1. 
 * @member {Array.<module:model/EcNumberSequenceInner>} numberSequence
 */
Ec.prototype['numberSequence'] = undefined;

/**
 * The analyzed password.
 * @member {String} password
 */
Ec.prototype['password'] = undefined;

/**
 * The number of characters the password has.
 * @member {Number} passwordLength
 */
Ec.prototype['passwordLength'] = undefined;

/**
 * **The penalty applied to each character that has been found to be part of a word, number sequence, alphabet sequence, etc.**  The penalty is a float number in the range [0, 1]. Full penalty, 0; no penalty, 1.  Its value is equal to the value of the input parameter *penalty*. 
 * @member {Number} penalty
 */
Ec.prototype['penalty'] = undefined;

/**
 * **The penalty applied to each character that are repeated**  The penalty is a float number in the range [0, 1]. Full penalty, 0; no penalty, 1.           
 * @member {Array.<module:model/EcRepeatedCharsInner>} repeatedChars
 */
Ec.prototype['repeatedChars'] = undefined;

/**
 * **The identifier of the request that corresponds to this response.** 
 * @member {String} requestId
 */
Ec.prototype['requestId'] = undefined;

/**
 * **The timestamp for this response.**  Milliseconds from the epoch of 1970-01-01T00:00:00Z. 
 * @member {Number} requestTimestamp
 */
Ec.prototype['requestTimestamp'] = undefined;

/**
 * @member {Array.<String>} summary
 */
Ec.prototype['summary'] = undefined;

/**
 * **The total penalty applied to each character.**  The penalty is a float number in the range [0, 1]. Full penalty, 0; no penalty, 1. 
 * @member {Array.<module:model/EcTotalInner>} total
 */
Ec.prototype['total'] = undefined;

/**
 * **The penalty applied to each character that has been found to be part of a word.**  The penalty is a float number in the range [0, 1]. Full penalty, 0; no penalty, 1. 
 * @member {Array.<module:model/EcWordsInner>} words
 */
Ec.prototype['words'] = undefined;






export default Ec;

