/**
 * Arespass
 * Analyzes a password and calculates its entropy.
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIEc.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIEc::OAIEc(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIEc::OAIEc() {
    this->initializeModel();
}

OAIEc::~OAIEc() {}

void OAIEc::initializeModel() {

    m_alphabet_sequence_isSet = false;
    m_alphabet_sequence_isValid = false;

    m_api_version_isSet = false;
    m_api_version_isValid = false;

    m_detected_keyboard_isSet = false;
    m_detected_keyboard_isValid = false;

    m_efficiency_isSet = false;
    m_efficiency_isValid = false;

    m_entropy_isSet = false;
    m_entropy_isValid = false;

    m_entropy_distribution_isSet = false;
    m_entropy_distribution_isValid = false;

    m_ideal_entropy_isSet = false;
    m_ideal_entropy_isValid = false;

    m_keyboard_sequence_isSet = false;
    m_keyboard_sequence_isValid = false;

    m_l33t_password_isSet = false;
    m_l33t_password_isValid = false;

    m_non_uniform_entropy_distribution_penalty_isSet = false;
    m_non_uniform_entropy_distribution_penalty_isValid = false;

    m_number_sequence_isSet = false;
    m_number_sequence_isValid = false;

    m_password_isSet = false;
    m_password_isValid = false;

    m_password_length_isSet = false;
    m_password_length_isValid = false;

    m_penalty_isSet = false;
    m_penalty_isValid = false;

    m_repeated_chars_isSet = false;
    m_repeated_chars_isValid = false;

    m_request_id_isSet = false;
    m_request_id_isValid = false;

    m_request_timestamp_isSet = false;
    m_request_timestamp_isValid = false;

    m_summary_isSet = false;
    m_summary_isValid = false;

    m_total_isSet = false;
    m_total_isValid = false;

    m_words_isSet = false;
    m_words_isValid = false;
}

void OAIEc::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIEc::fromJsonObject(QJsonObject json) {

    m_alphabet_sequence_isValid = ::OpenAPI::fromJsonValue(m_alphabet_sequence, json[QString("alphabetSequence")]);
    m_alphabet_sequence_isSet = !json[QString("alphabetSequence")].isNull() && m_alphabet_sequence_isValid;

    m_api_version_isValid = ::OpenAPI::fromJsonValue(m_api_version, json[QString("apiVersion")]);
    m_api_version_isSet = !json[QString("apiVersion")].isNull() && m_api_version_isValid;

    m_detected_keyboard_isValid = ::OpenAPI::fromJsonValue(m_detected_keyboard, json[QString("detectedKeyboard")]);
    m_detected_keyboard_isSet = !json[QString("detectedKeyboard")].isNull() && m_detected_keyboard_isValid;

    m_efficiency_isValid = ::OpenAPI::fromJsonValue(m_efficiency, json[QString("efficiency")]);
    m_efficiency_isSet = !json[QString("efficiency")].isNull() && m_efficiency_isValid;

    m_entropy_isValid = ::OpenAPI::fromJsonValue(m_entropy, json[QString("entropy")]);
    m_entropy_isSet = !json[QString("entropy")].isNull() && m_entropy_isValid;

    m_entropy_distribution_isValid = ::OpenAPI::fromJsonValue(m_entropy_distribution, json[QString("entropyDistribution")]);
    m_entropy_distribution_isSet = !json[QString("entropyDistribution")].isNull() && m_entropy_distribution_isValid;

    m_ideal_entropy_isValid = ::OpenAPI::fromJsonValue(m_ideal_entropy, json[QString("idealEntropy")]);
    m_ideal_entropy_isSet = !json[QString("idealEntropy")].isNull() && m_ideal_entropy_isValid;

    m_keyboard_sequence_isValid = ::OpenAPI::fromJsonValue(m_keyboard_sequence, json[QString("keyboardSequence")]);
    m_keyboard_sequence_isSet = !json[QString("keyboardSequence")].isNull() && m_keyboard_sequence_isValid;

    m_l33t_password_isValid = ::OpenAPI::fromJsonValue(m_l33t_password, json[QString("l33tPassword")]);
    m_l33t_password_isSet = !json[QString("l33tPassword")].isNull() && m_l33t_password_isValid;

    m_non_uniform_entropy_distribution_penalty_isValid = ::OpenAPI::fromJsonValue(m_non_uniform_entropy_distribution_penalty, json[QString("nonUniformEntropyDistributionPenalty")]);
    m_non_uniform_entropy_distribution_penalty_isSet = !json[QString("nonUniformEntropyDistributionPenalty")].isNull() && m_non_uniform_entropy_distribution_penalty_isValid;

    m_number_sequence_isValid = ::OpenAPI::fromJsonValue(m_number_sequence, json[QString("numberSequence")]);
    m_number_sequence_isSet = !json[QString("numberSequence")].isNull() && m_number_sequence_isValid;

    m_password_isValid = ::OpenAPI::fromJsonValue(m_password, json[QString("password")]);
    m_password_isSet = !json[QString("password")].isNull() && m_password_isValid;

    m_password_length_isValid = ::OpenAPI::fromJsonValue(m_password_length, json[QString("passwordLength")]);
    m_password_length_isSet = !json[QString("passwordLength")].isNull() && m_password_length_isValid;

    m_penalty_isValid = ::OpenAPI::fromJsonValue(m_penalty, json[QString("penalty")]);
    m_penalty_isSet = !json[QString("penalty")].isNull() && m_penalty_isValid;

    m_repeated_chars_isValid = ::OpenAPI::fromJsonValue(m_repeated_chars, json[QString("repeatedChars")]);
    m_repeated_chars_isSet = !json[QString("repeatedChars")].isNull() && m_repeated_chars_isValid;

    m_request_id_isValid = ::OpenAPI::fromJsonValue(m_request_id, json[QString("requestId")]);
    m_request_id_isSet = !json[QString("requestId")].isNull() && m_request_id_isValid;

    m_request_timestamp_isValid = ::OpenAPI::fromJsonValue(m_request_timestamp, json[QString("requestTimestamp")]);
    m_request_timestamp_isSet = !json[QString("requestTimestamp")].isNull() && m_request_timestamp_isValid;

    m_summary_isValid = ::OpenAPI::fromJsonValue(m_summary, json[QString("summary")]);
    m_summary_isSet = !json[QString("summary")].isNull() && m_summary_isValid;

    m_total_isValid = ::OpenAPI::fromJsonValue(m_total, json[QString("total")]);
    m_total_isSet = !json[QString("total")].isNull() && m_total_isValid;

    m_words_isValid = ::OpenAPI::fromJsonValue(m_words, json[QString("words")]);
    m_words_isSet = !json[QString("words")].isNull() && m_words_isValid;
}

QString OAIEc::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIEc::asJsonObject() const {
    QJsonObject obj;
    if (m_alphabet_sequence.size() > 0) {
        obj.insert(QString("alphabetSequence"), ::OpenAPI::toJsonValue(m_alphabet_sequence));
    }
    if (m_api_version_isSet) {
        obj.insert(QString("apiVersion"), ::OpenAPI::toJsonValue(m_api_version));
    }
    if (m_detected_keyboard_isSet) {
        obj.insert(QString("detectedKeyboard"), ::OpenAPI::toJsonValue(m_detected_keyboard));
    }
    if (m_efficiency_isSet) {
        obj.insert(QString("efficiency"), ::OpenAPI::toJsonValue(m_efficiency));
    }
    if (m_entropy_isSet) {
        obj.insert(QString("entropy"), ::OpenAPI::toJsonValue(m_entropy));
    }
    if (m_entropy_distribution.size() > 0) {
        obj.insert(QString("entropyDistribution"), ::OpenAPI::toJsonValue(m_entropy_distribution));
    }
    if (m_ideal_entropy_isSet) {
        obj.insert(QString("idealEntropy"), ::OpenAPI::toJsonValue(m_ideal_entropy));
    }
    if (m_keyboard_sequence.size() > 0) {
        obj.insert(QString("keyboardSequence"), ::OpenAPI::toJsonValue(m_keyboard_sequence));
    }
    if (m_l33t_password_isSet) {
        obj.insert(QString("l33tPassword"), ::OpenAPI::toJsonValue(m_l33t_password));
    }
    if (m_non_uniform_entropy_distribution_penalty_isSet) {
        obj.insert(QString("nonUniformEntropyDistributionPenalty"), ::OpenAPI::toJsonValue(m_non_uniform_entropy_distribution_penalty));
    }
    if (m_number_sequence.size() > 0) {
        obj.insert(QString("numberSequence"), ::OpenAPI::toJsonValue(m_number_sequence));
    }
    if (m_password_isSet) {
        obj.insert(QString("password"), ::OpenAPI::toJsonValue(m_password));
    }
    if (m_password_length_isSet) {
        obj.insert(QString("passwordLength"), ::OpenAPI::toJsonValue(m_password_length));
    }
    if (m_penalty_isSet) {
        obj.insert(QString("penalty"), ::OpenAPI::toJsonValue(m_penalty));
    }
    if (m_repeated_chars.size() > 0) {
        obj.insert(QString("repeatedChars"), ::OpenAPI::toJsonValue(m_repeated_chars));
    }
    if (m_request_id_isSet) {
        obj.insert(QString("requestId"), ::OpenAPI::toJsonValue(m_request_id));
    }
    if (m_request_timestamp_isSet) {
        obj.insert(QString("requestTimestamp"), ::OpenAPI::toJsonValue(m_request_timestamp));
    }
    if (m_summary.size() > 0) {
        obj.insert(QString("summary"), ::OpenAPI::toJsonValue(m_summary));
    }
    if (m_total.size() > 0) {
        obj.insert(QString("total"), ::OpenAPI::toJsonValue(m_total));
    }
    if (m_words.size() > 0) {
        obj.insert(QString("words"), ::OpenAPI::toJsonValue(m_words));
    }
    return obj;
}

QList<OAIEc_alphabetSequence_inner> OAIEc::getAlphabetSequence() const {
    return m_alphabet_sequence;
}
void OAIEc::setAlphabetSequence(const QList<OAIEc_alphabetSequence_inner> &alphabet_sequence) {
    m_alphabet_sequence = alphabet_sequence;
    m_alphabet_sequence_isSet = true;
}

bool OAIEc::is_alphabet_sequence_Set() const{
    return m_alphabet_sequence_isSet;
}

bool OAIEc::is_alphabet_sequence_Valid() const{
    return m_alphabet_sequence_isValid;
}

QString OAIEc::getApiVersion() const {
    return m_api_version;
}
void OAIEc::setApiVersion(const QString &api_version) {
    m_api_version = api_version;
    m_api_version_isSet = true;
}

bool OAIEc::is_api_version_Set() const{
    return m_api_version_isSet;
}

bool OAIEc::is_api_version_Valid() const{
    return m_api_version_isValid;
}

QString OAIEc::getDetectedKeyboard() const {
    return m_detected_keyboard;
}
void OAIEc::setDetectedKeyboard(const QString &detected_keyboard) {
    m_detected_keyboard = detected_keyboard;
    m_detected_keyboard_isSet = true;
}

bool OAIEc::is_detected_keyboard_Set() const{
    return m_detected_keyboard_isSet;
}

bool OAIEc::is_detected_keyboard_Valid() const{
    return m_detected_keyboard_isValid;
}

double OAIEc::getEfficiency() const {
    return m_efficiency;
}
void OAIEc::setEfficiency(const double &efficiency) {
    m_efficiency = efficiency;
    m_efficiency_isSet = true;
}

bool OAIEc::is_efficiency_Set() const{
    return m_efficiency_isSet;
}

bool OAIEc::is_efficiency_Valid() const{
    return m_efficiency_isValid;
}

double OAIEc::getEntropy() const {
    return m_entropy;
}
void OAIEc::setEntropy(const double &entropy) {
    m_entropy = entropy;
    m_entropy_isSet = true;
}

bool OAIEc::is_entropy_Set() const{
    return m_entropy_isSet;
}

bool OAIEc::is_entropy_Valid() const{
    return m_entropy_isValid;
}

QList<OAIEc_entropyDistribution_inner> OAIEc::getEntropyDistribution() const {
    return m_entropy_distribution;
}
void OAIEc::setEntropyDistribution(const QList<OAIEc_entropyDistribution_inner> &entropy_distribution) {
    m_entropy_distribution = entropy_distribution;
    m_entropy_distribution_isSet = true;
}

bool OAIEc::is_entropy_distribution_Set() const{
    return m_entropy_distribution_isSet;
}

bool OAIEc::is_entropy_distribution_Valid() const{
    return m_entropy_distribution_isValid;
}

double OAIEc::getIdealEntropy() const {
    return m_ideal_entropy;
}
void OAIEc::setIdealEntropy(const double &ideal_entropy) {
    m_ideal_entropy = ideal_entropy;
    m_ideal_entropy_isSet = true;
}

bool OAIEc::is_ideal_entropy_Set() const{
    return m_ideal_entropy_isSet;
}

bool OAIEc::is_ideal_entropy_Valid() const{
    return m_ideal_entropy_isValid;
}

QList<OAIEc_keyboardSequence_inner> OAIEc::getKeyboardSequence() const {
    return m_keyboard_sequence;
}
void OAIEc::setKeyboardSequence(const QList<OAIEc_keyboardSequence_inner> &keyboard_sequence) {
    m_keyboard_sequence = keyboard_sequence;
    m_keyboard_sequence_isSet = true;
}

bool OAIEc::is_keyboard_sequence_Set() const{
    return m_keyboard_sequence_isSet;
}

bool OAIEc::is_keyboard_sequence_Valid() const{
    return m_keyboard_sequence_isValid;
}

QString OAIEc::getL33tPassword() const {
    return m_l33t_password;
}
void OAIEc::setL33tPassword(const QString &l33t_password) {
    m_l33t_password = l33t_password;
    m_l33t_password_isSet = true;
}

bool OAIEc::is_l33t_password_Set() const{
    return m_l33t_password_isSet;
}

bool OAIEc::is_l33t_password_Valid() const{
    return m_l33t_password_isValid;
}

double OAIEc::getNonUniformEntropyDistributionPenalty() const {
    return m_non_uniform_entropy_distribution_penalty;
}
void OAIEc::setNonUniformEntropyDistributionPenalty(const double &non_uniform_entropy_distribution_penalty) {
    m_non_uniform_entropy_distribution_penalty = non_uniform_entropy_distribution_penalty;
    m_non_uniform_entropy_distribution_penalty_isSet = true;
}

bool OAIEc::is_non_uniform_entropy_distribution_penalty_Set() const{
    return m_non_uniform_entropy_distribution_penalty_isSet;
}

bool OAIEc::is_non_uniform_entropy_distribution_penalty_Valid() const{
    return m_non_uniform_entropy_distribution_penalty_isValid;
}

QList<OAIEc_numberSequence_inner> OAIEc::getNumberSequence() const {
    return m_number_sequence;
}
void OAIEc::setNumberSequence(const QList<OAIEc_numberSequence_inner> &number_sequence) {
    m_number_sequence = number_sequence;
    m_number_sequence_isSet = true;
}

bool OAIEc::is_number_sequence_Set() const{
    return m_number_sequence_isSet;
}

bool OAIEc::is_number_sequence_Valid() const{
    return m_number_sequence_isValid;
}

QString OAIEc::getPassword() const {
    return m_password;
}
void OAIEc::setPassword(const QString &password) {
    m_password = password;
    m_password_isSet = true;
}

bool OAIEc::is_password_Set() const{
    return m_password_isSet;
}

bool OAIEc::is_password_Valid() const{
    return m_password_isValid;
}

qint32 OAIEc::getPasswordLength() const {
    return m_password_length;
}
void OAIEc::setPasswordLength(const qint32 &password_length) {
    m_password_length = password_length;
    m_password_length_isSet = true;
}

bool OAIEc::is_password_length_Set() const{
    return m_password_length_isSet;
}

bool OAIEc::is_password_length_Valid() const{
    return m_password_length_isValid;
}

double OAIEc::getPenalty() const {
    return m_penalty;
}
void OAIEc::setPenalty(const double &penalty) {
    m_penalty = penalty;
    m_penalty_isSet = true;
}

bool OAIEc::is_penalty_Set() const{
    return m_penalty_isSet;
}

bool OAIEc::is_penalty_Valid() const{
    return m_penalty_isValid;
}

QList<OAIEc_repeatedChars_inner> OAIEc::getRepeatedChars() const {
    return m_repeated_chars;
}
void OAIEc::setRepeatedChars(const QList<OAIEc_repeatedChars_inner> &repeated_chars) {
    m_repeated_chars = repeated_chars;
    m_repeated_chars_isSet = true;
}

bool OAIEc::is_repeated_chars_Set() const{
    return m_repeated_chars_isSet;
}

bool OAIEc::is_repeated_chars_Valid() const{
    return m_repeated_chars_isValid;
}

QString OAIEc::getRequestId() const {
    return m_request_id;
}
void OAIEc::setRequestId(const QString &request_id) {
    m_request_id = request_id;
    m_request_id_isSet = true;
}

bool OAIEc::is_request_id_Set() const{
    return m_request_id_isSet;
}

bool OAIEc::is_request_id_Valid() const{
    return m_request_id_isValid;
}

double OAIEc::getRequestTimestamp() const {
    return m_request_timestamp;
}
void OAIEc::setRequestTimestamp(const double &request_timestamp) {
    m_request_timestamp = request_timestamp;
    m_request_timestamp_isSet = true;
}

bool OAIEc::is_request_timestamp_Set() const{
    return m_request_timestamp_isSet;
}

bool OAIEc::is_request_timestamp_Valid() const{
    return m_request_timestamp_isValid;
}

QList<QString> OAIEc::getSummary() const {
    return m_summary;
}
void OAIEc::setSummary(const QList<QString> &summary) {
    m_summary = summary;
    m_summary_isSet = true;
}

bool OAIEc::is_summary_Set() const{
    return m_summary_isSet;
}

bool OAIEc::is_summary_Valid() const{
    return m_summary_isValid;
}

QList<OAIEc_total_inner> OAIEc::getTotal() const {
    return m_total;
}
void OAIEc::setTotal(const QList<OAIEc_total_inner> &total) {
    m_total = total;
    m_total_isSet = true;
}

bool OAIEc::is_total_Set() const{
    return m_total_isSet;
}

bool OAIEc::is_total_Valid() const{
    return m_total_isValid;
}

QList<OAIEc_words_inner> OAIEc::getWords() const {
    return m_words;
}
void OAIEc::setWords(const QList<OAIEc_words_inner> &words) {
    m_words = words;
    m_words_isSet = true;
}

bool OAIEc::is_words_Set() const{
    return m_words_isSet;
}

bool OAIEc::is_words_Valid() const{
    return m_words_isValid;
}

bool OAIEc::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_alphabet_sequence.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_api_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_detected_keyboard_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_efficiency_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_entropy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_entropy_distribution.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_ideal_entropy_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_keyboard_sequence.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_l33t_password_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_non_uniform_entropy_distribution_penalty_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_number_sequence.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_password_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_password_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_penalty_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_repeated_chars.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_request_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_request_timestamp_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_summary.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_total.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_words.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIEc::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
