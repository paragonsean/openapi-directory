/**
 * The Blue Alliance API v3
 * # Overview    Information and statistics about FIRST Robotics Competition teams and events.   # Authentication   All endpoints require an Auth Key to be passed in the header `X-TBA-Auth-Key`. If you do not have an auth key yet, you can obtain one from your [Account Page](/account).
 *
 * The version of the OpenAPI document: 3.8.2
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAITeam_Event_Status_rank_ranking.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAITeam_Event_Status_rank_ranking::OAITeam_Event_Status_rank_ranking(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAITeam_Event_Status_rank_ranking::OAITeam_Event_Status_rank_ranking() {
    this->initializeModel();
}

OAITeam_Event_Status_rank_ranking::~OAITeam_Event_Status_rank_ranking() {}

void OAITeam_Event_Status_rank_ranking::initializeModel() {

    m_dq_isSet = false;
    m_dq_isValid = false;

    m_matches_played_isSet = false;
    m_matches_played_isValid = false;

    m_qual_average_isSet = false;
    m_qual_average_isValid = false;

    m_rank_isSet = false;
    m_rank_isValid = false;

    m_record_isSet = false;
    m_record_isValid = false;

    m_sort_orders_isSet = false;
    m_sort_orders_isValid = false;

    m_team_key_isSet = false;
    m_team_key_isValid = false;
}

void OAITeam_Event_Status_rank_ranking::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAITeam_Event_Status_rank_ranking::fromJsonObject(QJsonObject json) {

    m_dq_isValid = ::OpenAPI::fromJsonValue(m_dq, json[QString("dq")]);
    m_dq_isSet = !json[QString("dq")].isNull() && m_dq_isValid;

    m_matches_played_isValid = ::OpenAPI::fromJsonValue(m_matches_played, json[QString("matches_played")]);
    m_matches_played_isSet = !json[QString("matches_played")].isNull() && m_matches_played_isValid;

    m_qual_average_isValid = ::OpenAPI::fromJsonValue(m_qual_average, json[QString("qual_average")]);
    m_qual_average_isSet = !json[QString("qual_average")].isNull() && m_qual_average_isValid;

    m_rank_isValid = ::OpenAPI::fromJsonValue(m_rank, json[QString("rank")]);
    m_rank_isSet = !json[QString("rank")].isNull() && m_rank_isValid;

    m_record_isValid = ::OpenAPI::fromJsonValue(m_record, json[QString("record")]);
    m_record_isSet = !json[QString("record")].isNull() && m_record_isValid;

    m_sort_orders_isValid = ::OpenAPI::fromJsonValue(m_sort_orders, json[QString("sort_orders")]);
    m_sort_orders_isSet = !json[QString("sort_orders")].isNull() && m_sort_orders_isValid;

    m_team_key_isValid = ::OpenAPI::fromJsonValue(m_team_key, json[QString("team_key")]);
    m_team_key_isSet = !json[QString("team_key")].isNull() && m_team_key_isValid;
}

QString OAITeam_Event_Status_rank_ranking::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAITeam_Event_Status_rank_ranking::asJsonObject() const {
    QJsonObject obj;
    if (m_dq_isSet) {
        obj.insert(QString("dq"), ::OpenAPI::toJsonValue(m_dq));
    }
    if (m_matches_played_isSet) {
        obj.insert(QString("matches_played"), ::OpenAPI::toJsonValue(m_matches_played));
    }
    if (m_qual_average_isSet) {
        obj.insert(QString("qual_average"), ::OpenAPI::toJsonValue(m_qual_average));
    }
    if (m_rank_isSet) {
        obj.insert(QString("rank"), ::OpenAPI::toJsonValue(m_rank));
    }
    if (m_record.isSet()) {
        obj.insert(QString("record"), ::OpenAPI::toJsonValue(m_record));
    }
    if (m_sort_orders.size() > 0) {
        obj.insert(QString("sort_orders"), ::OpenAPI::toJsonValue(m_sort_orders));
    }
    if (m_team_key_isSet) {
        obj.insert(QString("team_key"), ::OpenAPI::toJsonValue(m_team_key));
    }
    return obj;
}

qint32 OAITeam_Event_Status_rank_ranking::getDq() const {
    return m_dq;
}
void OAITeam_Event_Status_rank_ranking::setDq(const qint32 &dq) {
    m_dq = dq;
    m_dq_isSet = true;
}

bool OAITeam_Event_Status_rank_ranking::is_dq_Set() const{
    return m_dq_isSet;
}

bool OAITeam_Event_Status_rank_ranking::is_dq_Valid() const{
    return m_dq_isValid;
}

qint32 OAITeam_Event_Status_rank_ranking::getMatchesPlayed() const {
    return m_matches_played;
}
void OAITeam_Event_Status_rank_ranking::setMatchesPlayed(const qint32 &matches_played) {
    m_matches_played = matches_played;
    m_matches_played_isSet = true;
}

bool OAITeam_Event_Status_rank_ranking::is_matches_played_Set() const{
    return m_matches_played_isSet;
}

bool OAITeam_Event_Status_rank_ranking::is_matches_played_Valid() const{
    return m_matches_played_isValid;
}

double OAITeam_Event_Status_rank_ranking::getQualAverage() const {
    return m_qual_average;
}
void OAITeam_Event_Status_rank_ranking::setQualAverage(const double &qual_average) {
    m_qual_average = qual_average;
    m_qual_average_isSet = true;
}

bool OAITeam_Event_Status_rank_ranking::is_qual_average_Set() const{
    return m_qual_average_isSet;
}

bool OAITeam_Event_Status_rank_ranking::is_qual_average_Valid() const{
    return m_qual_average_isValid;
}

qint32 OAITeam_Event_Status_rank_ranking::getRank() const {
    return m_rank;
}
void OAITeam_Event_Status_rank_ranking::setRank(const qint32 &rank) {
    m_rank = rank;
    m_rank_isSet = true;
}

bool OAITeam_Event_Status_rank_ranking::is_rank_Set() const{
    return m_rank_isSet;
}

bool OAITeam_Event_Status_rank_ranking::is_rank_Valid() const{
    return m_rank_isValid;
}

OAIWLT_Record OAITeam_Event_Status_rank_ranking::getRecord() const {
    return m_record;
}
void OAITeam_Event_Status_rank_ranking::setRecord(const OAIWLT_Record &record) {
    m_record = record;
    m_record_isSet = true;
}

bool OAITeam_Event_Status_rank_ranking::is_record_Set() const{
    return m_record_isSet;
}

bool OAITeam_Event_Status_rank_ranking::is_record_Valid() const{
    return m_record_isValid;
}

QList<double> OAITeam_Event_Status_rank_ranking::getSortOrders() const {
    return m_sort_orders;
}
void OAITeam_Event_Status_rank_ranking::setSortOrders(const QList<double> &sort_orders) {
    m_sort_orders = sort_orders;
    m_sort_orders_isSet = true;
}

bool OAITeam_Event_Status_rank_ranking::is_sort_orders_Set() const{
    return m_sort_orders_isSet;
}

bool OAITeam_Event_Status_rank_ranking::is_sort_orders_Valid() const{
    return m_sort_orders_isValid;
}

QString OAITeam_Event_Status_rank_ranking::getTeamKey() const {
    return m_team_key;
}
void OAITeam_Event_Status_rank_ranking::setTeamKey(const QString &team_key) {
    m_team_key = team_key;
    m_team_key_isSet = true;
}

bool OAITeam_Event_Status_rank_ranking::is_team_key_Set() const{
    return m_team_key_isSet;
}

bool OAITeam_Event_Status_rank_ranking::is_team_key_Valid() const{
    return m_team_key_isValid;
}

bool OAITeam_Event_Status_rank_ranking::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_dq_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_matches_played_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_qual_average_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rank_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_record.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_sort_orders.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_team_key_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAITeam_Event_Status_rank_ranking::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
