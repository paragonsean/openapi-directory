/**
 * Fire Financial Services Business API
 * The fire.com API allows you to deeply integrate Business Account features into your application or back-office systems.  The API provides read access to your profile, accounts and transactions, event-driven notifications of activity on the account and payment initiation via batches. Each feature has its own HTTP endpoint and every endpoint has its own permission.   The API exposes 3 main areas of functionality: financial functions, service information and service configuration. ## Financial Functions These functions provide access to your account details, transactions, payee accounts, payment initiation etc. ## Service Functions These provide information about the fees and limits applied to your account. ## Service configuration These provide information about your service configs - applications, webhooks, API tokens, etc. 
 *
 * The version of the OpenAPI document: 1.0
 * Contact: api@fire.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import OrderDetails from './OrderDetails';

/**
 * The NewPaymentRequest model module.
 * @module model/NewPaymentRequest
 * @version 1.0
 */
class NewPaymentRequest {
    /**
     * Constructs a new <code>NewPaymentRequest</code>.
     * @alias module:model/NewPaymentRequest
     * @param currency {module:model/NewPaymentRequest.CurrencyEnum} Either `EUR` or `GBP`, and must correspond to the currency of the account the funds are being lodged into in the `icanTo`.
     * @param description {String} A public facing description of the request. This will be shown to the user when they tap or scan the request.
     * @param icanTo {Number} The ican of the account to collect the funds into. Must be one of your fire.com Accounts.
     * @param myRef {String} An internal description of the request.
     * @param type {module:model/NewPaymentRequest.TypeEnum} The type of Fire Open Payment that was created
     */
    constructor(currency, description, icanTo, myRef, type) { 
        
        NewPaymentRequest.initialize(this, currency, description, icanTo, myRef, type);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, currency, description, icanTo, myRef, type) { 
        obj['currency'] = currency;
        obj['description'] = description;
        obj['icanTo'] = icanTo;
        obj['myRef'] = myRef;
        obj['type'] = type;
    }

    /**
     * Constructs a <code>NewPaymentRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/NewPaymentRequest} obj Optional instance to populate.
     * @return {module:model/NewPaymentRequest} The populated <code>NewPaymentRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new NewPaymentRequest();

            if (data.hasOwnProperty('additionalFields')) {
                obj['additionalFields'] = ApiClient.convertToType(data['additionalFields'], 'String');
            }
            if (data.hasOwnProperty('amount')) {
                obj['amount'] = ApiClient.convertToType(data['amount'], 'Number');
            }
            if (data.hasOwnProperty('collectFields')) {
                obj['collectFields'] = ApiClient.convertToType(data['collectFields'], 'String');
            }
            if (data.hasOwnProperty('currency')) {
                obj['currency'] = ApiClient.convertToType(data['currency'], 'String');
            }
            if (data.hasOwnProperty('description')) {
                obj['description'] = ApiClient.convertToType(data['description'], 'String');
            }
            if (data.hasOwnProperty('expiry')) {
                obj['expiry'] = ApiClient.convertToType(data['expiry'], 'Date');
            }
            if (data.hasOwnProperty('icanTo')) {
                obj['icanTo'] = ApiClient.convertToType(data['icanTo'], 'Number');
            }
            if (data.hasOwnProperty('mandatoryFields')) {
                obj['mandatoryFields'] = ApiClient.convertToType(data['mandatoryFields'], 'String');
            }
            if (data.hasOwnProperty('maxNumberPayments')) {
                obj['maxNumberPayments'] = ApiClient.convertToType(data['maxNumberPayments'], 'Number');
            }
            if (data.hasOwnProperty('myRef')) {
                obj['myRef'] = ApiClient.convertToType(data['myRef'], 'String');
            }
            if (data.hasOwnProperty('orderDetails')) {
                obj['orderDetails'] = OrderDetails.constructFromObject(data['orderDetails']);
            }
            if (data.hasOwnProperty('returnUrl')) {
                obj['returnUrl'] = ApiClient.convertToType(data['returnUrl'], 'String');
            }
            if (data.hasOwnProperty('type')) {
                obj['type'] = ApiClient.convertToType(data['type'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>NewPaymentRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>NewPaymentRequest</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of NewPaymentRequest.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['additionalFields'] && !(typeof data['additionalFields'] === 'string' || data['additionalFields'] instanceof String)) {
            throw new Error("Expected the field `additionalFields` to be a primitive type in the JSON string but got " + data['additionalFields']);
        }
        // ensure the json data is a string
        if (data['collectFields'] && !(typeof data['collectFields'] === 'string' || data['collectFields'] instanceof String)) {
            throw new Error("Expected the field `collectFields` to be a primitive type in the JSON string but got " + data['collectFields']);
        }
        // ensure the json data is a string
        if (data['currency'] && !(typeof data['currency'] === 'string' || data['currency'] instanceof String)) {
            throw new Error("Expected the field `currency` to be a primitive type in the JSON string but got " + data['currency']);
        }
        // ensure the json data is a string
        if (data['description'] && !(typeof data['description'] === 'string' || data['description'] instanceof String)) {
            throw new Error("Expected the field `description` to be a primitive type in the JSON string but got " + data['description']);
        }
        // ensure the json data is a string
        if (data['mandatoryFields'] && !(typeof data['mandatoryFields'] === 'string' || data['mandatoryFields'] instanceof String)) {
            throw new Error("Expected the field `mandatoryFields` to be a primitive type in the JSON string but got " + data['mandatoryFields']);
        }
        // ensure the json data is a string
        if (data['myRef'] && !(typeof data['myRef'] === 'string' || data['myRef'] instanceof String)) {
            throw new Error("Expected the field `myRef` to be a primitive type in the JSON string but got " + data['myRef']);
        }
        // validate the optional field `orderDetails`
        if (data['orderDetails']) { // data not null
          OrderDetails.validateJSON(data['orderDetails']);
        }
        // ensure the json data is a string
        if (data['returnUrl'] && !(typeof data['returnUrl'] === 'string' || data['returnUrl'] instanceof String)) {
            throw new Error("Expected the field `returnUrl` to be a primitive type in the JSON string but got " + data['returnUrl']);
        }
        // ensure the json data is a string
        if (data['type'] && !(typeof data['type'] === 'string' || data['type'] instanceof String)) {
            throw new Error("Expected the field `type` to be a primitive type in the JSON string but got " + data['type']);
        }

        return true;
    }


}

NewPaymentRequest.RequiredProperties = ["currency", "description", "icanTo", "myRef", "type"];

/**
 * These fields will be dispalyed to the payer when using the hosted option. You can choose to display any of `ORDER_ID`, `PRODUCT_ID`, `CUSTOMER_ID`, `CUSTOMER_NUMBER` and `COMMENT2` to the payer.
 * @member {String} additionalFields
 */
NewPaymentRequest.prototype['additionalFields'] = undefined;

/**
 * The requested amount to pay. Note the last two digits represent pennies/cents, (e.g., £1.00 = 100).
 * @member {Number} amount
 */
NewPaymentRequest.prototype['amount'] = undefined;

/**
 * For the hosted option, the payer will be asked to fill in these fields but they will not be mandatory. You can choose to collect any of the payer's `ADDRESS`, `REFERENCE` and/or `COMMENT1`. If you choose to collect these fields from the payer, you cannot set 'delivery’, 'variableReference’ or 'comment1’ fields respectively.
 * @member {String} collectFields
 */
NewPaymentRequest.prototype['collectFields'] = undefined;

/**
 * Either `EUR` or `GBP`, and must correspond to the currency of the account the funds are being lodged into in the `icanTo`.
 * @member {module:model/NewPaymentRequest.CurrencyEnum} currency
 */
NewPaymentRequest.prototype['currency'] = undefined;

/**
 * A public facing description of the request. This will be shown to the user when they tap or scan the request.
 * @member {String} description
 */
NewPaymentRequest.prototype['description'] = undefined;

/**
 * This is the expiry of the payment request. After this time, the payment cannot be paid.
 * @member {Date} expiry
 */
NewPaymentRequest.prototype['expiry'] = undefined;

/**
 * The ican of the account to collect the funds into. Must be one of your fire.com Accounts.
 * @member {Number} icanTo
 */
NewPaymentRequest.prototype['icanTo'] = undefined;

/**
 * For the hosted option, these fields will be madatory for the payer to fill in on the hosted payment page. You can choose to collect any the payer's `ADDRESS`, `REFERENCE` and/or `COMMENT1`. If you choose to collect these fields from the payer, you cannot set 'delivery’, 'variableReference’ or 'comment1’ fields respectively.
 * @member {String} mandatoryFields
 */
NewPaymentRequest.prototype['mandatoryFields'] = undefined;

/**
 * The max number of people who can pay this request. Must be set to 1 for the ECOMMERCE_GOODS and ECOMMERCE_SERVICES types.
 * @member {Number} maxNumberPayments
 */
NewPaymentRequest.prototype['maxNumberPayments'] = undefined;

/**
 * An internal description of the request.
 * @member {String} myRef
 */
NewPaymentRequest.prototype['myRef'] = undefined;

/**
 * @member {module:model/OrderDetails} orderDetails
 */
NewPaymentRequest.prototype['orderDetails'] = undefined;

/**
 * The merchant return URL where the customer will be re-directed to with the result of the transaction.
 * @member {String} returnUrl
 */
NewPaymentRequest.prototype['returnUrl'] = undefined;

/**
 * The type of Fire Open Payment that was created
 * @member {module:model/NewPaymentRequest.TypeEnum} type
 */
NewPaymentRequest.prototype['type'] = undefined;





/**
 * Allowed values for the <code>currency</code> property.
 * @enum {String}
 * @readonly
 */
NewPaymentRequest['CurrencyEnum'] = {

    /**
     * value: "EUR"
     * @const
     */
    "EUR": "EUR",

    /**
     * value: "GBP"
     * @const
     */
    "GBP": "GBP"
};


/**
 * Allowed values for the <code>type</code> property.
 * @enum {String}
 * @readonly
 */
NewPaymentRequest['TypeEnum'] = {

    /**
     * value: "OTHER"
     * @const
     */
    "OTHER": "OTHER"
};



export default NewPaymentRequest;

