/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin
 *
 * The version of the OpenAPI document: 1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRealmsAdminApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIRealmsAdminApi::OAIRealmsAdminApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIRealmsAdminApi::~OAIRealmsAdminApi() {
}

void OAIRealmsAdminApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("http://keycloak.local"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("realmAdminEventsDelete", defaultConf);
    _serverIndices.insert("realmAdminEventsDelete", 0);
    _serverConfigs.insert("realmAdminEventsGet", defaultConf);
    _serverIndices.insert("realmAdminEventsGet", 0);
    _serverConfigs.insert("realmClearKeysCachePost", defaultConf);
    _serverIndices.insert("realmClearKeysCachePost", 0);
    _serverConfigs.insert("realmClearRealmCachePost", defaultConf);
    _serverIndices.insert("realmClearRealmCachePost", 0);
    _serverConfigs.insert("realmClearUserCachePost", defaultConf);
    _serverIndices.insert("realmClearUserCachePost", 0);
    _serverConfigs.insert("realmClientDescriptionConverterPost", defaultConf);
    _serverIndices.insert("realmClientDescriptionConverterPost", 0);
    _serverConfigs.insert("realmClientSessionStatsGet", defaultConf);
    _serverIndices.insert("realmClientSessionStatsGet", 0);
    _serverConfigs.insert("realmCredentialRegistratorsGet", defaultConf);
    _serverIndices.insert("realmCredentialRegistratorsGet", 0);
    _serverConfigs.insert("realmDefaultDefaultClientScopesClientScopeIdDelete", defaultConf);
    _serverIndices.insert("realmDefaultDefaultClientScopesClientScopeIdDelete", 0);
    _serverConfigs.insert("realmDefaultDefaultClientScopesClientScopeIdPut", defaultConf);
    _serverIndices.insert("realmDefaultDefaultClientScopesClientScopeIdPut", 0);
    _serverConfigs.insert("realmDefaultDefaultClientScopesGet", defaultConf);
    _serverIndices.insert("realmDefaultDefaultClientScopesGet", 0);
    _serverConfigs.insert("realmDefaultGroupsGet", defaultConf);
    _serverIndices.insert("realmDefaultGroupsGet", 0);
    _serverConfigs.insert("realmDefaultGroupsGroupIdDelete", defaultConf);
    _serverIndices.insert("realmDefaultGroupsGroupIdDelete", 0);
    _serverConfigs.insert("realmDefaultGroupsGroupIdPut", defaultConf);
    _serverIndices.insert("realmDefaultGroupsGroupIdPut", 0);
    _serverConfigs.insert("realmDefaultOptionalClientScopesClientScopeIdDelete", defaultConf);
    _serverIndices.insert("realmDefaultOptionalClientScopesClientScopeIdDelete", 0);
    _serverConfigs.insert("realmDefaultOptionalClientScopesClientScopeIdPut", defaultConf);
    _serverIndices.insert("realmDefaultOptionalClientScopesClientScopeIdPut", 0);
    _serverConfigs.insert("realmDefaultOptionalClientScopesGet", defaultConf);
    _serverIndices.insert("realmDefaultOptionalClientScopesGet", 0);
    _serverConfigs.insert("realmDelete", defaultConf);
    _serverIndices.insert("realmDelete", 0);
    _serverConfigs.insert("realmEventsConfigGet", defaultConf);
    _serverIndices.insert("realmEventsConfigGet", 0);
    _serverConfigs.insert("realmEventsConfigPut", defaultConf);
    _serverIndices.insert("realmEventsConfigPut", 0);
    _serverConfigs.insert("realmEventsDelete", defaultConf);
    _serverIndices.insert("realmEventsDelete", 0);
    _serverConfigs.insert("realmEventsGet", defaultConf);
    _serverIndices.insert("realmEventsGet", 0);
    _serverConfigs.insert("realmGet", defaultConf);
    _serverIndices.insert("realmGet", 0);
    _serverConfigs.insert("realmGroupByPathPathGet", defaultConf);
    _serverIndices.insert("realmGroupByPathPathGet", 0);
    _serverConfigs.insert("realmLogoutAllPost", defaultConf);
    _serverIndices.insert("realmLogoutAllPost", 0);
    _serverConfigs.insert("realmPartialExportPost", defaultConf);
    _serverIndices.insert("realmPartialExportPost", 0);
    _serverConfigs.insert("realmPartialImportPost", defaultConf);
    _serverIndices.insert("realmPartialImportPost", 0);
    _serverConfigs.insert("realmPushRevocationPost", defaultConf);
    _serverIndices.insert("realmPushRevocationPost", 0);
    _serverConfigs.insert("realmPut", defaultConf);
    _serverIndices.insert("realmPut", 0);
    _serverConfigs.insert("realmSessionsSessionDelete", defaultConf);
    _serverIndices.insert("realmSessionsSessionDelete", 0);
    _serverConfigs.insert("realmTestLDAPConnectionPost", defaultConf);
    _serverIndices.insert("realmTestLDAPConnectionPost", 0);
    _serverConfigs.insert("realmTestSMTPConnectionPost", defaultConf);
    _serverIndices.insert("realmTestSMTPConnectionPost", 0);
    _serverConfigs.insert("realmUsersManagementPermissionsGet", defaultConf);
    _serverIndices.insert("realmUsersManagementPermissionsGet", 0);
    _serverConfigs.insert("realmUsersManagementPermissionsPut", defaultConf);
    _serverIndices.insert("realmUsersManagementPermissionsPut", 0);
    _serverConfigs.insert("rootPost", defaultConf);
    _serverIndices.insert("rootPost", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIRealmsAdminApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIRealmsAdminApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIRealmsAdminApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIRealmsAdminApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIRealmsAdminApi::setUsername(const QString &username) {
    _username = username;
}

void OAIRealmsAdminApi::setPassword(const QString &password) {
    _password = password;
}


void OAIRealmsAdminApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIRealmsAdminApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIRealmsAdminApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIRealmsAdminApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIRealmsAdminApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIRealmsAdminApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIRealmsAdminApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIRealmsAdminApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIRealmsAdminApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIRealmsAdminApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIRealmsAdminApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIRealmsAdminApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIRealmsAdminApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIRealmsAdminApi::realmAdminEventsDelete(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmAdminEventsDelete"][_serverIndices.value("realmAdminEventsDelete")].URL()+"/{realm}/admin-events");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmAdminEventsDeleteCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmAdminEventsDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmAdminEventsDeleteSignal();
        Q_EMIT realmAdminEventsDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmAdminEventsDeleteSignalE(error_type, error_str);
        Q_EMIT realmAdminEventsDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmAdminEventsDeleteSignalError(error_type, error_str);
        Q_EMIT realmAdminEventsDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmAdminEventsGet(const QString &realm, const ::OpenAPI::OptionalParam<QString> &auth_client, const ::OpenAPI::OptionalParam<QString> &auth_ip_address, const ::OpenAPI::OptionalParam<QString> &auth_realm, const ::OpenAPI::OptionalParam<QString> &auth_user, const ::OpenAPI::OptionalParam<QString> &date_from, const ::OpenAPI::OptionalParam<QString> &date_to, const ::OpenAPI::OptionalParam<qint32> &first, const ::OpenAPI::OptionalParam<qint32> &max, const ::OpenAPI::OptionalParam<QList<QString>> &operation_types, const ::OpenAPI::OptionalParam<QString> &resource_path, const ::OpenAPI::OptionalParam<QList<QString>> &resource_types) {
    QString fullPath = QString(_serverConfigs["realmAdminEventsGet"][_serverIndices.value("realmAdminEventsGet")].URL()+"/{realm}/admin-events");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (auth_client.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "authClient", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("authClient")).append(querySuffix).append(QUrl::toPercentEncoding(auth_client.stringValue()));
    }
    if (auth_ip_address.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "authIpAddress", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("authIpAddress")).append(querySuffix).append(QUrl::toPercentEncoding(auth_ip_address.stringValue()));
    }
    if (auth_realm.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "authRealm", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("authRealm")).append(querySuffix).append(QUrl::toPercentEncoding(auth_realm.stringValue()));
    }
    if (auth_user.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "authUser", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("authUser")).append(querySuffix).append(QUrl::toPercentEncoding(auth_user.stringValue()));
    }
    if (date_from.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "dateFrom", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("dateFrom")).append(querySuffix).append(QUrl::toPercentEncoding(date_from.stringValue()));
    }
    if (date_to.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "dateTo", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("dateTo")).append(querySuffix).append(QUrl::toPercentEncoding(date_to.stringValue()));
    }
    if (first.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "first", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("first")).append(querySuffix).append(QUrl::toPercentEncoding(first.stringValue()));
    }
    if (max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "max", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("max")).append(querySuffix).append(QUrl::toPercentEncoding(max.stringValue()));
    }
    if (operation_types.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "operationTypes", true);
        if (operation_types.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : operation_types.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("operationTypes=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("operationTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : operation_types.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("operationTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : operation_types.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("operationTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : operation_types.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("operationTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : operation_types.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("operationTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : operation_types.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (resource_path.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "resourcePath", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("resourcePath")).append(querySuffix).append(QUrl::toPercentEncoding(resource_path.stringValue()));
    }
    if (resource_types.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "resourceTypes", true);
        if (resource_types.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : resource_types.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("resourceTypes=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("resourceTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : resource_types.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("resourceTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : resource_types.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("resourceTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : resource_types.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("resourceTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : resource_types.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("resourceTypes").append(querySuffix);
                qint32 count = 0;
                for (QString t : resource_types.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmAdminEventsGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmAdminEventsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIAdminEventRepresentation> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIAdminEventRepresentation val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmAdminEventsGetSignal(output);
        Q_EMIT realmAdminEventsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmAdminEventsGetSignalE(output, error_type, error_str);
        Q_EMIT realmAdminEventsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmAdminEventsGetSignalError(output, error_type, error_str);
        Q_EMIT realmAdminEventsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmClearKeysCachePost(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmClearKeysCachePost"][_serverIndices.value("realmClearKeysCachePost")].URL()+"/{realm}/clear-keys-cache");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmClearKeysCachePostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmClearKeysCachePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmClearKeysCachePostSignal();
        Q_EMIT realmClearKeysCachePostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmClearKeysCachePostSignalE(error_type, error_str);
        Q_EMIT realmClearKeysCachePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmClearKeysCachePostSignalError(error_type, error_str);
        Q_EMIT realmClearKeysCachePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmClearRealmCachePost(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmClearRealmCachePost"][_serverIndices.value("realmClearRealmCachePost")].URL()+"/{realm}/clear-realm-cache");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmClearRealmCachePostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmClearRealmCachePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmClearRealmCachePostSignal();
        Q_EMIT realmClearRealmCachePostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmClearRealmCachePostSignalE(error_type, error_str);
        Q_EMIT realmClearRealmCachePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmClearRealmCachePostSignalError(error_type, error_str);
        Q_EMIT realmClearRealmCachePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmClearUserCachePost(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmClearUserCachePost"][_serverIndices.value("realmClearUserCachePost")].URL()+"/{realm}/clear-user-cache");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmClearUserCachePostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmClearUserCachePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmClearUserCachePostSignal();
        Q_EMIT realmClearUserCachePostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmClearUserCachePostSignalE(error_type, error_str);
        Q_EMIT realmClearUserCachePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmClearUserCachePostSignalError(error_type, error_str);
        Q_EMIT realmClearUserCachePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmClientDescriptionConverterPost(const QString &realm, const QString &body) {
    QString fullPath = QString(_serverConfigs["realmClientDescriptionConverterPost"][_serverIndices.value("realmClientDescriptionConverterPost")].URL()+"/{realm}/client-description-converter");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        QByteArray output = body.toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmClientDescriptionConverterPostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmClientDescriptionConverterPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIClientRepresentation output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmClientDescriptionConverterPostSignal(output);
        Q_EMIT realmClientDescriptionConverterPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmClientDescriptionConverterPostSignalE(output, error_type, error_str);
        Q_EMIT realmClientDescriptionConverterPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmClientDescriptionConverterPostSignalError(output, error_type, error_str);
        Q_EMIT realmClientDescriptionConverterPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmClientSessionStatsGet(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmClientSessionStatsGet"][_serverIndices.value("realmClientSessionStatsGet")].URL()+"/{realm}/client-session-stats");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmClientSessionStatsGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmClientSessionStatsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QMap<QString, QJsonValue>> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QMap val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmClientSessionStatsGetSignal(output);
        Q_EMIT realmClientSessionStatsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmClientSessionStatsGetSignalE(output, error_type, error_str);
        Q_EMIT realmClientSessionStatsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmClientSessionStatsGetSignalError(output, error_type, error_str);
        Q_EMIT realmClientSessionStatsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmCredentialRegistratorsGet(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmCredentialRegistratorsGet"][_serverIndices.value("realmCredentialRegistratorsGet")].URL()+"/{realm}/credential-registrators");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmCredentialRegistratorsGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmCredentialRegistratorsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmCredentialRegistratorsGetSignal(output);
        Q_EMIT realmCredentialRegistratorsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmCredentialRegistratorsGetSignalE(output, error_type, error_str);
        Q_EMIT realmCredentialRegistratorsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmCredentialRegistratorsGetSignalError(output, error_type, error_str);
        Q_EMIT realmCredentialRegistratorsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDefaultDefaultClientScopesClientScopeIdDelete(const QString &realm, const QString &client_scope_id) {
    QString fullPath = QString(_serverConfigs["realmDefaultDefaultClientScopesClientScopeIdDelete"][_serverIndices.value("realmDefaultDefaultClientScopesClientScopeIdDelete")].URL()+"/{realm}/default-default-client-scopes/{clientScopeId}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    
    {
        QString client_scope_idPathParam("{");
        client_scope_idPathParam.append("clientScopeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "clientScopeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"clientScopeId"+pathSuffix : pathPrefix;
        fullPath.replace(client_scope_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(client_scope_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDefaultDefaultClientScopesClientScopeIdDeleteCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDefaultDefaultClientScopesClientScopeIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdDeleteSignal();
        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdDeleteSignalE(error_type, error_str);
        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdDeleteSignalError(error_type, error_str);
        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDefaultDefaultClientScopesClientScopeIdPut(const QString &realm, const QString &client_scope_id) {
    QString fullPath = QString(_serverConfigs["realmDefaultDefaultClientScopesClientScopeIdPut"][_serverIndices.value("realmDefaultDefaultClientScopesClientScopeIdPut")].URL()+"/{realm}/default-default-client-scopes/{clientScopeId}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    
    {
        QString client_scope_idPathParam("{");
        client_scope_idPathParam.append("clientScopeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "clientScopeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"clientScopeId"+pathSuffix : pathPrefix;
        fullPath.replace(client_scope_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(client_scope_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDefaultDefaultClientScopesClientScopeIdPutCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDefaultDefaultClientScopesClientScopeIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdPutSignal();
        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdPutSignalE(error_type, error_str);
        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdPutSignalError(error_type, error_str);
        Q_EMIT realmDefaultDefaultClientScopesClientScopeIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDefaultDefaultClientScopesGet(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmDefaultDefaultClientScopesGet"][_serverIndices.value("realmDefaultDefaultClientScopesGet")].URL()+"/{realm}/default-default-client-scopes");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDefaultDefaultClientScopesGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDefaultDefaultClientScopesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIClientScopeRepresentation> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIClientScopeRepresentation val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDefaultDefaultClientScopesGetSignal(output);
        Q_EMIT realmDefaultDefaultClientScopesGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDefaultDefaultClientScopesGetSignalE(output, error_type, error_str);
        Q_EMIT realmDefaultDefaultClientScopesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDefaultDefaultClientScopesGetSignalError(output, error_type, error_str);
        Q_EMIT realmDefaultDefaultClientScopesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDefaultGroupsGet(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmDefaultGroupsGet"][_serverIndices.value("realmDefaultGroupsGet")].URL()+"/{realm}/default-groups");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDefaultGroupsGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDefaultGroupsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGroupRepresentation> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGroupRepresentation val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDefaultGroupsGetSignal(output);
        Q_EMIT realmDefaultGroupsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDefaultGroupsGetSignalE(output, error_type, error_str);
        Q_EMIT realmDefaultGroupsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDefaultGroupsGetSignalError(output, error_type, error_str);
        Q_EMIT realmDefaultGroupsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDefaultGroupsGroupIdDelete(const QString &realm, const QString &group_id) {
    QString fullPath = QString(_serverConfigs["realmDefaultGroupsGroupIdDelete"][_serverIndices.value("realmDefaultGroupsGroupIdDelete")].URL()+"/{realm}/default-groups/{groupId}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    
    {
        QString group_idPathParam("{");
        group_idPathParam.append("groupId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "groupId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"groupId"+pathSuffix : pathPrefix;
        fullPath.replace(group_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(group_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDefaultGroupsGroupIdDeleteCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDefaultGroupsGroupIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDefaultGroupsGroupIdDeleteSignal();
        Q_EMIT realmDefaultGroupsGroupIdDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDefaultGroupsGroupIdDeleteSignalE(error_type, error_str);
        Q_EMIT realmDefaultGroupsGroupIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDefaultGroupsGroupIdDeleteSignalError(error_type, error_str);
        Q_EMIT realmDefaultGroupsGroupIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDefaultGroupsGroupIdPut(const QString &realm, const QString &group_id) {
    QString fullPath = QString(_serverConfigs["realmDefaultGroupsGroupIdPut"][_serverIndices.value("realmDefaultGroupsGroupIdPut")].URL()+"/{realm}/default-groups/{groupId}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    
    {
        QString group_idPathParam("{");
        group_idPathParam.append("groupId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "groupId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"groupId"+pathSuffix : pathPrefix;
        fullPath.replace(group_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(group_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDefaultGroupsGroupIdPutCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDefaultGroupsGroupIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDefaultGroupsGroupIdPutSignal();
        Q_EMIT realmDefaultGroupsGroupIdPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDefaultGroupsGroupIdPutSignalE(error_type, error_str);
        Q_EMIT realmDefaultGroupsGroupIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDefaultGroupsGroupIdPutSignalError(error_type, error_str);
        Q_EMIT realmDefaultGroupsGroupIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDefaultOptionalClientScopesClientScopeIdDelete(const QString &realm, const QString &client_scope_id) {
    QString fullPath = QString(_serverConfigs["realmDefaultOptionalClientScopesClientScopeIdDelete"][_serverIndices.value("realmDefaultOptionalClientScopesClientScopeIdDelete")].URL()+"/{realm}/default-optional-client-scopes/{clientScopeId}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    
    {
        QString client_scope_idPathParam("{");
        client_scope_idPathParam.append("clientScopeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "clientScopeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"clientScopeId"+pathSuffix : pathPrefix;
        fullPath.replace(client_scope_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(client_scope_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDefaultOptionalClientScopesClientScopeIdDeleteCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDefaultOptionalClientScopesClientScopeIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdDeleteSignal();
        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdDeleteSignalE(error_type, error_str);
        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdDeleteSignalError(error_type, error_str);
        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDefaultOptionalClientScopesClientScopeIdPut(const QString &realm, const QString &client_scope_id) {
    QString fullPath = QString(_serverConfigs["realmDefaultOptionalClientScopesClientScopeIdPut"][_serverIndices.value("realmDefaultOptionalClientScopesClientScopeIdPut")].URL()+"/{realm}/default-optional-client-scopes/{clientScopeId}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    
    {
        QString client_scope_idPathParam("{");
        client_scope_idPathParam.append("clientScopeId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "clientScopeId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"clientScopeId"+pathSuffix : pathPrefix;
        fullPath.replace(client_scope_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(client_scope_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDefaultOptionalClientScopesClientScopeIdPutCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDefaultOptionalClientScopesClientScopeIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdPutSignal();
        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdPutSignalE(error_type, error_str);
        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdPutSignalError(error_type, error_str);
        Q_EMIT realmDefaultOptionalClientScopesClientScopeIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDefaultOptionalClientScopesGet(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmDefaultOptionalClientScopesGet"][_serverIndices.value("realmDefaultOptionalClientScopesGet")].URL()+"/{realm}/default-optional-client-scopes");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDefaultOptionalClientScopesGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDefaultOptionalClientScopesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIClientScopeRepresentation> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIClientScopeRepresentation val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDefaultOptionalClientScopesGetSignal(output);
        Q_EMIT realmDefaultOptionalClientScopesGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDefaultOptionalClientScopesGetSignalE(output, error_type, error_str);
        Q_EMIT realmDefaultOptionalClientScopesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDefaultOptionalClientScopesGetSignalError(output, error_type, error_str);
        Q_EMIT realmDefaultOptionalClientScopesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmDelete(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmDelete"][_serverIndices.value("realmDelete")].URL()+"/{realm}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmDeleteCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmDeleteSignal();
        Q_EMIT realmDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmDeleteSignalE(error_type, error_str);
        Q_EMIT realmDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmDeleteSignalError(error_type, error_str);
        Q_EMIT realmDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmEventsConfigGet(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmEventsConfigGet"][_serverIndices.value("realmEventsConfigGet")].URL()+"/{realm}/events/config");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmEventsConfigGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmEventsConfigGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIRealmEventsConfigRepresentation output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmEventsConfigGetSignal(output);
        Q_EMIT realmEventsConfigGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmEventsConfigGetSignalE(output, error_type, error_str);
        Q_EMIT realmEventsConfigGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmEventsConfigGetSignalError(output, error_type, error_str);
        Q_EMIT realmEventsConfigGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmEventsConfigPut(const QString &realm, const OAIRealmEventsConfigRepresentation &oai_realm_events_config_representation) {
    QString fullPath = QString(_serverConfigs["realmEventsConfigPut"][_serverIndices.value("realmEventsConfigPut")].URL()+"/{realm}/events/config");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_realm_events_config_representation.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmEventsConfigPutCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmEventsConfigPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmEventsConfigPutSignal();
        Q_EMIT realmEventsConfigPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmEventsConfigPutSignalE(error_type, error_str);
        Q_EMIT realmEventsConfigPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmEventsConfigPutSignalError(error_type, error_str);
        Q_EMIT realmEventsConfigPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmEventsDelete(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmEventsDelete"][_serverIndices.value("realmEventsDelete")].URL()+"/{realm}/events");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmEventsDeleteCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmEventsDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmEventsDeleteSignal();
        Q_EMIT realmEventsDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmEventsDeleteSignalE(error_type, error_str);
        Q_EMIT realmEventsDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmEventsDeleteSignalError(error_type, error_str);
        Q_EMIT realmEventsDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmEventsGet(const QString &realm, const ::OpenAPI::OptionalParam<QString> &client, const ::OpenAPI::OptionalParam<QString> &date_from, const ::OpenAPI::OptionalParam<QString> &date_to, const ::OpenAPI::OptionalParam<qint32> &first, const ::OpenAPI::OptionalParam<QString> &ip_address, const ::OpenAPI::OptionalParam<qint32> &max, const ::OpenAPI::OptionalParam<QList<QString>> &type, const ::OpenAPI::OptionalParam<QString> &user) {
    QString fullPath = QString(_serverConfigs["realmEventsGet"][_serverIndices.value("realmEventsGet")].URL()+"/{realm}/events");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (client.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "client", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("client")).append(querySuffix).append(QUrl::toPercentEncoding(client.stringValue()));
    }
    if (date_from.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "dateFrom", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("dateFrom")).append(querySuffix).append(QUrl::toPercentEncoding(date_from.stringValue()));
    }
    if (date_to.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "dateTo", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("dateTo")).append(querySuffix).append(QUrl::toPercentEncoding(date_to.stringValue()));
    }
    if (first.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "first", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("first")).append(querySuffix).append(QUrl::toPercentEncoding(first.stringValue()));
    }
    if (ip_address.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "ipAddress", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("ipAddress")).append(querySuffix).append(QUrl::toPercentEncoding(ip_address.stringValue()));
    }
    if (max.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "max", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("max")).append(querySuffix).append(QUrl::toPercentEncoding(max.stringValue()));
    }
    if (type.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "type", true);
        if (type.value().size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                for (QString t : type.value()) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("type=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("type").append(querySuffix);
                qint32 count = 0;
                for (QString t : type.value()) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("type").append(querySuffix);
                qint32 count = 0;
                for (QString t : type.value()) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("type").append(querySuffix);
                qint32 count = 0;
                for (QString t : type.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("type").append(querySuffix);
                qint32 count = 0;
                for (QString t : type.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("type").append(querySuffix);
                qint32 count = 0;
                for (QString t : type.value()) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    if (user.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("user")).append(querySuffix).append(QUrl::toPercentEncoding(user.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmEventsGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmEventsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIEventRepresentation> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIEventRepresentation val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmEventsGetSignal(output);
        Q_EMIT realmEventsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmEventsGetSignalE(output, error_type, error_str);
        Q_EMIT realmEventsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmEventsGetSignalError(output, error_type, error_str);
        Q_EMIT realmEventsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmGet(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmGet"][_serverIndices.value("realmGet")].URL()+"/{realm}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIRealmRepresentation output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmGetSignal(output);
        Q_EMIT realmGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmGetSignalE(output, error_type, error_str);
        Q_EMIT realmGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmGetSignalError(output, error_type, error_str);
        Q_EMIT realmGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmGroupByPathPathGet(const QString &realm, const QString &path) {
    QString fullPath = QString(_serverConfigs["realmGroupByPathPathGet"][_serverIndices.value("realmGroupByPathPathGet")].URL()+"/{realm}/group-by-path/{path}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    
    {
        QString pathPathParam("{");
        pathPathParam.append("path").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "path", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"path"+pathSuffix : pathPrefix;
        fullPath.replace(pathPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(path)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmGroupByPathPathGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmGroupByPathPathGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGroupRepresentation output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmGroupByPathPathGetSignal(output);
        Q_EMIT realmGroupByPathPathGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmGroupByPathPathGetSignalE(output, error_type, error_str);
        Q_EMIT realmGroupByPathPathGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmGroupByPathPathGetSignalError(output, error_type, error_str);
        Q_EMIT realmGroupByPathPathGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmLogoutAllPost(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmLogoutAllPost"][_serverIndices.value("realmLogoutAllPost")].URL()+"/{realm}/logout-all");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmLogoutAllPostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmLogoutAllPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmLogoutAllPostSignal();
        Q_EMIT realmLogoutAllPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmLogoutAllPostSignalE(error_type, error_str);
        Q_EMIT realmLogoutAllPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmLogoutAllPostSignalError(error_type, error_str);
        Q_EMIT realmLogoutAllPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmPartialExportPost(const QString &realm, const ::OpenAPI::OptionalParam<bool> &export_clients, const ::OpenAPI::OptionalParam<bool> &export_groups_and_roles) {
    QString fullPath = QString(_serverConfigs["realmPartialExportPost"][_serverIndices.value("realmPartialExportPost")].URL()+"/{realm}/partial-export");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (export_clients.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "exportClients", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("exportClients")).append(querySuffix).append(QUrl::toPercentEncoding(export_clients.stringValue()));
    }
    if (export_groups_and_roles.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "exportGroupsAndRoles", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("exportGroupsAndRoles")).append(querySuffix).append(QUrl::toPercentEncoding(export_groups_and_roles.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmPartialExportPostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmPartialExportPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIRealmRepresentation output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmPartialExportPostSignal(output);
        Q_EMIT realmPartialExportPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmPartialExportPostSignalE(output, error_type, error_str);
        Q_EMIT realmPartialExportPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmPartialExportPostSignalError(output, error_type, error_str);
        Q_EMIT realmPartialExportPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmPartialImportPost(const QString &realm, const OAIPartialImportRepresentation &oai_partial_import_representation) {
    QString fullPath = QString(_serverConfigs["realmPartialImportPost"][_serverIndices.value("realmPartialImportPost")].URL()+"/{realm}/partialImport");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_partial_import_representation.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmPartialImportPostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmPartialImportPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmPartialImportPostSignal();
        Q_EMIT realmPartialImportPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmPartialImportPostSignalE(error_type, error_str);
        Q_EMIT realmPartialImportPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmPartialImportPostSignalError(error_type, error_str);
        Q_EMIT realmPartialImportPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmPushRevocationPost(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmPushRevocationPost"][_serverIndices.value("realmPushRevocationPost")].URL()+"/{realm}/push-revocation");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmPushRevocationPostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmPushRevocationPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmPushRevocationPostSignal();
        Q_EMIT realmPushRevocationPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmPushRevocationPostSignalE(error_type, error_str);
        Q_EMIT realmPushRevocationPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmPushRevocationPostSignalError(error_type, error_str);
        Q_EMIT realmPushRevocationPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmPut(const QString &realm, const OAIRealmRepresentation &oai_realm_representation) {
    QString fullPath = QString(_serverConfigs["realmPut"][_serverIndices.value("realmPut")].URL()+"/{realm}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_realm_representation.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmPutCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmPutSignal();
        Q_EMIT realmPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmPutSignalE(error_type, error_str);
        Q_EMIT realmPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmPutSignalError(error_type, error_str);
        Q_EMIT realmPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmSessionsSessionDelete(const QString &realm, const QString &session) {
    QString fullPath = QString(_serverConfigs["realmSessionsSessionDelete"][_serverIndices.value("realmSessionsSessionDelete")].URL()+"/{realm}/sessions/{session}");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    
    {
        QString sessionPathParam("{");
        sessionPathParam.append("session").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "session", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"session"+pathSuffix : pathPrefix;
        fullPath.replace(sessionPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(session)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmSessionsSessionDeleteCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmSessionsSessionDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmSessionsSessionDeleteSignal();
        Q_EMIT realmSessionsSessionDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmSessionsSessionDeleteSignalE(error_type, error_str);
        Q_EMIT realmSessionsSessionDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmSessionsSessionDeleteSignalError(error_type, error_str);
        Q_EMIT realmSessionsSessionDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmTestLDAPConnectionPost(const QString &realm, const OAITestLdapConnectionRepresentation &oai_test_ldap_connection_representation) {
    QString fullPath = QString(_serverConfigs["realmTestLDAPConnectionPost"][_serverIndices.value("realmTestLDAPConnectionPost")].URL()+"/{realm}/testLDAPConnection");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_test_ldap_connection_representation.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmTestLDAPConnectionPostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmTestLDAPConnectionPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmTestLDAPConnectionPostSignal();
        Q_EMIT realmTestLDAPConnectionPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmTestLDAPConnectionPostSignalE(error_type, error_str);
        Q_EMIT realmTestLDAPConnectionPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmTestLDAPConnectionPostSignalError(error_type, error_str);
        Q_EMIT realmTestLDAPConnectionPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmTestSMTPConnectionPost(const QString &realm, const QMap<QString, QJsonValue> &request_body) {
    QString fullPath = QString(_serverConfigs["realmTestSMTPConnectionPost"][_serverIndices.value("realmTestSMTPConnectionPost")].URL()+"/{realm}/testSMTPConnection");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        QJsonDocument doc(::OpenAPI::toJsonValue(request_body).toObject());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmTestSMTPConnectionPostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmTestSMTPConnectionPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmTestSMTPConnectionPostSignal();
        Q_EMIT realmTestSMTPConnectionPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmTestSMTPConnectionPostSignalE(error_type, error_str);
        Q_EMIT realmTestSMTPConnectionPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmTestSMTPConnectionPostSignalError(error_type, error_str);
        Q_EMIT realmTestSMTPConnectionPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmUsersManagementPermissionsGet(const QString &realm) {
    QString fullPath = QString(_serverConfigs["realmUsersManagementPermissionsGet"][_serverIndices.value("realmUsersManagementPermissionsGet")].URL()+"/{realm}/users-management-permissions");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmUsersManagementPermissionsGetCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmUsersManagementPermissionsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIManagementPermissionReference output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmUsersManagementPermissionsGetSignal(output);
        Q_EMIT realmUsersManagementPermissionsGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmUsersManagementPermissionsGetSignalE(output, error_type, error_str);
        Q_EMIT realmUsersManagementPermissionsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmUsersManagementPermissionsGetSignalError(output, error_type, error_str);
        Q_EMIT realmUsersManagementPermissionsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::realmUsersManagementPermissionsPut(const QString &realm, const OAIManagementPermissionReference &oai_management_permission_reference) {
    QString fullPath = QString(_serverConfigs["realmUsersManagementPermissionsPut"][_serverIndices.value("realmUsersManagementPermissionsPut")].URL()+"/{realm}/users-management-permissions");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString realmPathParam("{");
        realmPathParam.append("realm").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "realm", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"realm"+pathSuffix : pathPrefix;
        fullPath.replace(realmPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(realm)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_management_permission_reference.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::realmUsersManagementPermissionsPutCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::realmUsersManagementPermissionsPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIManagementPermissionReference output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT realmUsersManagementPermissionsPutSignal(output);
        Q_EMIT realmUsersManagementPermissionsPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT realmUsersManagementPermissionsPutSignalE(output, error_type, error_str);
        Q_EMIT realmUsersManagementPermissionsPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT realmUsersManagementPermissionsPutSignalError(output, error_type, error_str);
        Q_EMIT realmUsersManagementPermissionsPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::rootPost(const OAIRealmRepresentation &oai_realm_representation) {
    QString fullPath = QString(_serverConfigs["rootPost"][_serverIndices.value("rootPost")].URL()+"/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_realm_representation.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIRealmsAdminApi::rootPostCallback);
    connect(this, &OAIRealmsAdminApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIRealmsAdminApi::rootPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT rootPostSignal();
        Q_EMIT rootPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT rootPostSignalE(error_type, error_str);
        Q_EMIT rootPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT rootPostSignalError(error_type, error_str);
        Q_EMIT rootPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIRealmsAdminApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
