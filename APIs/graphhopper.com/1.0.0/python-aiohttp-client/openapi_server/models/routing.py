# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class Routing(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, calc_points: bool=False, consider_traffic: bool=False, curbside_strictness: str='soft', fail_fast: bool=True, network_data_provider: str='openstreetmap', return_snapped_waypoints: bool=False, snap_preventions: List[str]=None):
        """Routing - a model defined in OpenAPI

        :param calc_points: The calc_points of this Routing.
        :param consider_traffic: The consider_traffic of this Routing.
        :param curbside_strictness: The curbside_strictness of this Routing.
        :param fail_fast: The fail_fast of this Routing.
        :param network_data_provider: The network_data_provider of this Routing.
        :param return_snapped_waypoints: The return_snapped_waypoints of this Routing.
        :param snap_preventions: The snap_preventions of this Routing.
        """
        self.openapi_types = {
            'calc_points': bool,
            'consider_traffic': bool,
            'curbside_strictness': str,
            'fail_fast': bool,
            'network_data_provider': str,
            'return_snapped_waypoints': bool,
            'snap_preventions': List[str]
        }

        self.attribute_map = {
            'calc_points': 'calc_points',
            'consider_traffic': 'consider_traffic',
            'curbside_strictness': 'curbside_strictness',
            'fail_fast': 'fail_fast',
            'network_data_provider': 'network_data_provider',
            'return_snapped_waypoints': 'return_snapped_waypoints',
            'snap_preventions': 'snap_preventions'
        }

        self._calc_points = calc_points
        self._consider_traffic = consider_traffic
        self._curbside_strictness = curbside_strictness
        self._fail_fast = fail_fast
        self._network_data_provider = network_data_provider
        self._return_snapped_waypoints = return_snapped_waypoints
        self._snap_preventions = snap_preventions

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Routing':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Routing of this Routing.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def calc_points(self):
        """Gets the calc_points of this Routing.

        It lets you specify whether the API should provide you with route geometries for vehicle routes or not. Thus, you do not need to do extra routing to get the polyline for each route.

        :return: The calc_points of this Routing.
        :rtype: bool
        """
        return self._calc_points

    @calc_points.setter
    def calc_points(self, calc_points):
        """Sets the calc_points of this Routing.

        It lets you specify whether the API should provide you with route geometries for vehicle routes or not. Thus, you do not need to do extra routing to get the polyline for each route.

        :param calc_points: The calc_points of this Routing.
        :type calc_points: bool
        """

        self._calc_points = calc_points

    @property
    def consider_traffic(self):
        """Gets the consider_traffic of this Routing.

        indicates whether historical traffic information should be considered

        :return: The consider_traffic of this Routing.
        :rtype: bool
        """
        return self._consider_traffic

    @consider_traffic.setter
    def consider_traffic(self, consider_traffic):
        """Sets the consider_traffic of this Routing.

        indicates whether historical traffic information should be considered

        :param consider_traffic: The consider_traffic of this Routing.
        :type consider_traffic: bool
        """

        self._consider_traffic = consider_traffic

    @property
    def curbside_strictness(self):
        """Gets the curbside_strictness of this Routing.

        In some cases curbside constraints cannot be fulfilled. For example in one-way streets you cannot arrive at a building that is on the left side of the street such that the building is to the right of you (unless you drove the one-way street the wrong/illegal way). You can set the `curbside_strictness` to `soft` to ignore the curbside constraint in such cases or set it to `strict` to get an error response instead. You can also set it to `ignore` to ignore all curbside constraints (this is useful to compare the results with and without constraints without modifying every single address).

        :return: The curbside_strictness of this Routing.
        :rtype: str
        """
        return self._curbside_strictness

    @curbside_strictness.setter
    def curbside_strictness(self, curbside_strictness):
        """Sets the curbside_strictness of this Routing.

        In some cases curbside constraints cannot be fulfilled. For example in one-way streets you cannot arrive at a building that is on the left side of the street such that the building is to the right of you (unless you drove the one-way street the wrong/illegal way). You can set the `curbside_strictness` to `soft` to ignore the curbside constraint in such cases or set it to `strict` to get an error response instead. You can also set it to `ignore` to ignore all curbside constraints (this is useful to compare the results with and without constraints without modifying every single address).

        :param curbside_strictness: The curbside_strictness of this Routing.
        :type curbside_strictness: str
        """
        allowed_values = ["ignore", "soft", "strict"]  # noqa: E501
        if curbside_strictness not in allowed_values:
            raise ValueError(
                "Invalid value for `curbside_strictness` ({0}), must be one of {1}"
                .format(curbside_strictness, allowed_values)
            )

        self._curbside_strictness = curbside_strictness

    @property
    def fail_fast(self):
        """Gets the fail_fast of this Routing.

        indicates whether matrix calculation should fail fast when points cannot be connected

        :return: The fail_fast of this Routing.
        :rtype: bool
        """
        return self._fail_fast

    @fail_fast.setter
    def fail_fast(self, fail_fast):
        """Sets the fail_fast of this Routing.

        indicates whether matrix calculation should fail fast when points cannot be connected

        :param fail_fast: The fail_fast of this Routing.
        :type fail_fast: bool
        """

        self._fail_fast = fail_fast

    @property
    def network_data_provider(self):
        """Gets the network_data_provider of this Routing.

        specifies the data provider, read more about it [here](#section/Map-Data-and-Routing-Profiles).

        :return: The network_data_provider of this Routing.
        :rtype: str
        """
        return self._network_data_provider

    @network_data_provider.setter
    def network_data_provider(self, network_data_provider):
        """Sets the network_data_provider of this Routing.

        specifies the data provider, read more about it [here](#section/Map-Data-and-Routing-Profiles).

        :param network_data_provider: The network_data_provider of this Routing.
        :type network_data_provider: str
        """
        allowed_values = ["openstreetmap", "tomtom"]  # noqa: E501
        if network_data_provider not in allowed_values:
            raise ValueError(
                "Invalid value for `network_data_provider` ({0}), must be one of {1}"
                .format(network_data_provider, allowed_values)
            )

        self._network_data_provider = network_data_provider

    @property
    def return_snapped_waypoints(self):
        """Gets the return_snapped_waypoints of this Routing.

        Indicates whether a solution includes snapped waypoints. In contrary to the address coordinate a snapped waypoint is the access point to the (road) network.

        :return: The return_snapped_waypoints of this Routing.
        :rtype: bool
        """
        return self._return_snapped_waypoints

    @return_snapped_waypoints.setter
    def return_snapped_waypoints(self, return_snapped_waypoints):
        """Sets the return_snapped_waypoints of this Routing.

        Indicates whether a solution includes snapped waypoints. In contrary to the address coordinate a snapped waypoint is the access point to the (road) network.

        :param return_snapped_waypoints: The return_snapped_waypoints of this Routing.
        :type return_snapped_waypoints: bool
        """

        self._return_snapped_waypoints = return_snapped_waypoints

    @property
    def snap_preventions(self):
        """Gets the snap_preventions of this Routing.

        Prevents snapping locations to road links of specified road types, e.g. to motorway.

        :return: The snap_preventions of this Routing.
        :rtype: List[str]
        """
        return self._snap_preventions

    @snap_preventions.setter
    def snap_preventions(self, snap_preventions):
        """Sets the snap_preventions of this Routing.

        Prevents snapping locations to road links of specified road types, e.g. to motorway.

        :param snap_preventions: The snap_preventions of this Routing.
        :type snap_preventions: List[str]
        """
        allowed_values = ["motorway", "trunk", "bridge", "ford", "tunnel", "ferry"]  # noqa: E501
        if not set(snap_preventions).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `snap_preventions` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(snap_preventions) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._snap_preventions = snap_preventions
