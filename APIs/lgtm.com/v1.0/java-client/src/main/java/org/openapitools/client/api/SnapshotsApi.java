/*
 * LGTM API specification
 * The REST API for LGTM provides data so that you can customize how you integrate LGTM analysis into your workflow. It includes the following resources:   * `/` ([API root](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-API-root))&mdash;get version information or download the specification in OpenAPI format.   * `/projects` ([Projects](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Projects))&mdash;list projects, get a summary of the current status for a project, or add new projects.   * `/analyses` ([Analyses](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Analyses))&mdash;get a summary of results, download all the alerts, or trigger analysis for a specific commit.   * `/codereviews` ([Code reviews](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Code-reviews))&mdash;trigger code review for a patch, and view the results.   * `/operations` ([Operations](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Operations))&mdash;get information about long-running tasks, for example, analyses or code reviews that you've requested.   * `/snapshots` ([Snapshots](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Snapshots))&mdash;download and upload databases representing a snapshot of a codebase.   * `/queryjobs` ([Query jobs](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-Query-jobs))&mdash;submit queries to evaluate against existing projects, and download their results.   * `/system` ([System](https://lgtm.com/help/lgtm/api/api-v1#LGTM-API-specification-System))&mdash;get information on the health or usage of the system.  For an overview and getting started topics, see [API for LGTM](https://lgtm.com/help/lgtm/api/api-for-lgtm). 
 *
 * The version of the OpenAPI document: v1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import java.time.OffsetDateTime;
import org.openapitools.client.model.Operation;
import java.net.URI;
import org.openapitools.client.model.UploadSession;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SnapshotsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SnapshotsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SnapshotsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for abortUpload
     * @param sessionId The id of the upload session. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Aborted. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call abortUploadCall(String sessionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snapshots/uploads/{session-id}"
            .replace("{" + "session-id" + "}", localVarApiClient.escapeString(sessionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "access-token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call abortUploadValidateBeforeCall(String sessionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sessionId' is set
        if (sessionId == null) {
            throw new ApiException("Missing the required parameter 'sessionId' when calling abortUpload(Async)");
        }

        return abortUploadCall(sessionId, _callback);

    }

    /**
     * Abort database upload process
     * Aborts the specified upload session and deletes any uploaded parts. After the session is aborted it cannot be restarted. If any part uploads are in progress when the session is aborted, their data may not be deleted. To ensure that uploaded parts are deleted correctly, you should only abort an upload session after all part uploads have completed. 
     * @param sessionId The id of the upload session. (required)
     * @return Operation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Aborted. </td><td>  -  </td></tr>
     </table>
     */
    public Operation abortUpload(String sessionId) throws ApiException {
        ApiResponse<Operation> localVarResp = abortUploadWithHttpInfo(sessionId);
        return localVarResp.getData();
    }

    /**
     * Abort database upload process
     * Aborts the specified upload session and deletes any uploaded parts. After the session is aborted it cannot be restarted. If any part uploads are in progress when the session is aborted, their data may not be deleted. To ensure that uploaded parts are deleted correctly, you should only abort an upload session after all part uploads have completed. 
     * @param sessionId The id of the upload session. (required)
     * @return ApiResponse&lt;Operation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Aborted. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Operation> abortUploadWithHttpInfo(String sessionId) throws ApiException {
        okhttp3.Call localVarCall = abortUploadValidateBeforeCall(sessionId, null);
        Type localVarReturnType = new TypeToken<Operation>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Abort database upload process (asynchronously)
     * Aborts the specified upload session and deletes any uploaded parts. After the session is aborted it cannot be restarted. If any part uploads are in progress when the session is aborted, their data may not be deleted. To ensure that uploaded parts are deleted correctly, you should only abort an upload session after all part uploads have completed. 
     * @param sessionId The id of the upload session. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Aborted. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call abortUploadAsync(String sessionId, final ApiCallback<Operation> _callback) throws ApiException {

        okhttp3.Call localVarCall = abortUploadValidateBeforeCall(sessionId, _callback);
        Type localVarReturnType = new TypeToken<Operation>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for completeUpload
     * @param sessionId The id of the upload session. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Accepted. Analysis triggered. Tracking data returned. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call completeUploadCall(String sessionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snapshots/uploads/{session-id}"
            .replace("{" + "session-id" + "}", localVarApiClient.escapeString(sessionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "access-token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call completeUploadValidateBeforeCall(String sessionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sessionId' is set
        if (sessionId == null) {
            throw new ApiException("Missing the required parameter 'sessionId' when calling completeUpload(Async)");
        }

        return completeUploadCall(sessionId, _callback);

    }

    /**
     * Complete snapshot upload session
     * Completes the database upload by closing the upload session, upgrading the database if appropriate, and scheduling analysis of that snapshot of the codebase.  You can view the analysis progress and access the results using the &#x60;task-result-url&#x60;. 
     * @param sessionId The id of the upload session. (required)
     * @return Operation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Accepted. Analysis triggered. Tracking data returned. </td><td>  -  </td></tr>
     </table>
     */
    public Operation completeUpload(String sessionId) throws ApiException {
        ApiResponse<Operation> localVarResp = completeUploadWithHttpInfo(sessionId);
        return localVarResp.getData();
    }

    /**
     * Complete snapshot upload session
     * Completes the database upload by closing the upload session, upgrading the database if appropriate, and scheduling analysis of that snapshot of the codebase.  You can view the analysis progress and access the results using the &#x60;task-result-url&#x60;. 
     * @param sessionId The id of the upload session. (required)
     * @return ApiResponse&lt;Operation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Accepted. Analysis triggered. Tracking data returned. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Operation> completeUploadWithHttpInfo(String sessionId) throws ApiException {
        okhttp3.Call localVarCall = completeUploadValidateBeforeCall(sessionId, null);
        Type localVarReturnType = new TypeToken<Operation>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Complete snapshot upload session (asynchronously)
     * Completes the database upload by closing the upload session, upgrading the database if appropriate, and scheduling analysis of that snapshot of the codebase.  You can view the analysis progress and access the results using the &#x60;task-result-url&#x60;. 
     * @param sessionId The id of the upload session. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Accepted. Analysis triggered. Tracking data returned. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call completeUploadAsync(String sessionId, final ApiCallback<Operation> _callback) throws ApiException {

        okhttp3.Call localVarCall = completeUploadValidateBeforeCall(sessionId, _callback);
        Type localVarReturnType = new TypeToken<Operation>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSnapshot
     * @param projectId The numeric project identifier. (required)
     * @param language The language of the database to download. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 303 </td><td> Redirects to a URL for downloading the CodeQL database as indicated by the &#x60;Location:&#x60; header. </td><td>  * Location -  <br>  </td></tr>
     </table>
     */
    public okhttp3.Call getSnapshotCall(Long projectId, String language, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snapshots/{project-id}/{language}"
            .replace("{" + "project-id" + "}", localVarApiClient.escapeString(projectId.toString()))
            .replace("{" + "language" + "}", localVarApiClient.escapeString(language.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "access-token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSnapshotValidateBeforeCall(Long projectId, String language, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'projectId' is set
        if (projectId == null) {
            throw new ApiException("Missing the required parameter 'projectId' when calling getSnapshot(Async)");
        }

        // verify the required parameter 'language' is set
        if (language == null) {
            throw new ApiException("Missing the required parameter 'language' when calling getSnapshot(Async)");
        }

        return getSnapshotCall(projectId, language, _callback);

    }

    /**
     * Download a snapshot
     * Download a CodeQL database from LGTM, representing a snapshot of the codebase, to run queries in your IDE.  This endpoint works for projects that have been successfully analyzed for the language specified in the request.  A successful request redirects you to a URL for downloading a database that represents the code snapshot, as specified in the &#x60;Location:&#x60; header in the response. Therefore, your HTTP client should be configured to follow redirects. For example, if you are using &#x60;curl&#x60;, you can add the&#x60;-L&#x60; flag to the command.  The database is downloaded as a zip file that can be imported into an IDE equipped with a  CodeQL extension. The extension must be up to date to analyze databases downloaded from LGTM. For more information on running queries locally in your IDE, see [Runnning queries in your IDE](https://lgtm.com/help/lgtm/running-queries-ide).  
     * @param projectId The numeric project identifier. (required)
     * @param language The language of the database to download. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 303 </td><td> Redirects to a URL for downloading the CodeQL database as indicated by the &#x60;Location:&#x60; header. </td><td>  * Location -  <br>  </td></tr>
     </table>
     */
    public void getSnapshot(Long projectId, String language) throws ApiException {
        getSnapshotWithHttpInfo(projectId, language);
    }

    /**
     * Download a snapshot
     * Download a CodeQL database from LGTM, representing a snapshot of the codebase, to run queries in your IDE.  This endpoint works for projects that have been successfully analyzed for the language specified in the request.  A successful request redirects you to a URL for downloading a database that represents the code snapshot, as specified in the &#x60;Location:&#x60; header in the response. Therefore, your HTTP client should be configured to follow redirects. For example, if you are using &#x60;curl&#x60;, you can add the&#x60;-L&#x60; flag to the command.  The database is downloaded as a zip file that can be imported into an IDE equipped with a  CodeQL extension. The extension must be up to date to analyze databases downloaded from LGTM. For more information on running queries locally in your IDE, see [Runnning queries in your IDE](https://lgtm.com/help/lgtm/running-queries-ide).  
     * @param projectId The numeric project identifier. (required)
     * @param language The language of the database to download. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 303 </td><td> Redirects to a URL for downloading the CodeQL database as indicated by the &#x60;Location:&#x60; header. </td><td>  * Location -  <br>  </td></tr>
     </table>
     */
    public ApiResponse<Void> getSnapshotWithHttpInfo(Long projectId, String language) throws ApiException {
        okhttp3.Call localVarCall = getSnapshotValidateBeforeCall(projectId, language, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Download a snapshot (asynchronously)
     * Download a CodeQL database from LGTM, representing a snapshot of the codebase, to run queries in your IDE.  This endpoint works for projects that have been successfully analyzed for the language specified in the request.  A successful request redirects you to a URL for downloading a database that represents the code snapshot, as specified in the &#x60;Location:&#x60; header in the response. Therefore, your HTTP client should be configured to follow redirects. For example, if you are using &#x60;curl&#x60;, you can add the&#x60;-L&#x60; flag to the command.  The database is downloaded as a zip file that can be imported into an IDE equipped with a  CodeQL extension. The extension must be up to date to analyze databases downloaded from LGTM. For more information on running queries locally in your IDE, see [Runnning queries in your IDE](https://lgtm.com/help/lgtm/running-queries-ide).  
     * @param projectId The numeric project identifier. (required)
     * @param language The language of the database to download. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 303 </td><td> Redirects to a URL for downloading the CodeQL database as indicated by the &#x60;Location:&#x60; header. </td><td>  * Location -  <br>  </td></tr>
     </table>
     */
    public okhttp3.Call getSnapshotAsync(Long projectId, String language, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSnapshotValidateBeforeCall(projectId, language, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for initSnapshotUpload
     * @param projectId The numeric project identifier. (required)
     * @param language The language of the database to upload. (required)
     * @param commit The identifier of the analyzed commit. (required)
     * @param date The date and time of the analyzed commit (default the current time). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call initSnapshotUploadCall(Long projectId, String language, String commit, OffsetDateTime date, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snapshots/{project-id}/{language}"
            .replace("{" + "project-id" + "}", localVarApiClient.escapeString(projectId.toString()))
            .replace("{" + "language" + "}", localVarApiClient.escapeString(language.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (commit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("commit", commit));
        }

        if (date != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("date", date));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "access-token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call initSnapshotUploadValidateBeforeCall(Long projectId, String language, String commit, OffsetDateTime date, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'projectId' is set
        if (projectId == null) {
            throw new ApiException("Missing the required parameter 'projectId' when calling initSnapshotUpload(Async)");
        }

        // verify the required parameter 'language' is set
        if (language == null) {
            throw new ApiException("Missing the required parameter 'language' when calling initSnapshotUpload(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling initSnapshotUpload(Async)");
        }

        return initSnapshotUploadCall(projectId, language, commit, date, _callback);

    }

    /**
     * Start snapshot upload session
     * Start a session to upload an externally-built database (which represents a snapshot of a codebase) to a project on LGTM.   This endpoint works for projects that are already on LGTM, and the selected language of  the database must already be configured. The project must be configured with &#39;upload&#39; analysis mode. You can upload a \&quot;bundled\&quot; CodeQL database or a database exported by  the QL command-line tools (&#x60;odasa&#x60;).  If your database was generated using a version of the  command line that is older than LGTM,  LGTM will try to upgrade and analyze it when the upload is complete. You can include cached predicates in the upload, but they are ignored as the cache is  repopulated after the database has been upgraded and analyzed. However, if you want to include results with your database, make sure the database is  compatible before you start the upload session.  Incompatible databases with results won&#39;t be upgraded and therefore cannot be uploaded.  For further information on externally-built databases,  see [Preparing snapshots to upload to LGTM using the QL command-line tools](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).       When the upload session has been successfully started, upload the database to the  upload URL returned in the response. The database can be uploaded to the upload URL in parts using  the [&#x60;PUT /snapshots/uploads/{session-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIduploadPart) endpoint. After uploading all the parts you must call  the [&#x60;POST /snapshots/uploads/{session-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdcompleteUpload) endpoint to complete the upload session. 
     * @param projectId The numeric project identifier. (required)
     * @param language The language of the database to upload. (required)
     * @param commit The identifier of the analyzed commit. (required)
     * @param date The date and time of the analyzed commit (default the current time). (optional)
     * @return UploadSession
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
     </table>
     */
    public UploadSession initSnapshotUpload(Long projectId, String language, String commit, OffsetDateTime date) throws ApiException {
        ApiResponse<UploadSession> localVarResp = initSnapshotUploadWithHttpInfo(projectId, language, commit, date);
        return localVarResp.getData();
    }

    /**
     * Start snapshot upload session
     * Start a session to upload an externally-built database (which represents a snapshot of a codebase) to a project on LGTM.   This endpoint works for projects that are already on LGTM, and the selected language of  the database must already be configured. The project must be configured with &#39;upload&#39; analysis mode. You can upload a \&quot;bundled\&quot; CodeQL database or a database exported by  the QL command-line tools (&#x60;odasa&#x60;).  If your database was generated using a version of the  command line that is older than LGTM,  LGTM will try to upgrade and analyze it when the upload is complete. You can include cached predicates in the upload, but they are ignored as the cache is  repopulated after the database has been upgraded and analyzed. However, if you want to include results with your database, make sure the database is  compatible before you start the upload session.  Incompatible databases with results won&#39;t be upgraded and therefore cannot be uploaded.  For further information on externally-built databases,  see [Preparing snapshots to upload to LGTM using the QL command-line tools](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).       When the upload session has been successfully started, upload the database to the  upload URL returned in the response. The database can be uploaded to the upload URL in parts using  the [&#x60;PUT /snapshots/uploads/{session-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIduploadPart) endpoint. After uploading all the parts you must call  the [&#x60;POST /snapshots/uploads/{session-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdcompleteUpload) endpoint to complete the upload session. 
     * @param projectId The numeric project identifier. (required)
     * @param language The language of the database to upload. (required)
     * @param commit The identifier of the analyzed commit. (required)
     * @param date The date and time of the analyzed commit (default the current time). (optional)
     * @return ApiResponse&lt;UploadSession&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UploadSession> initSnapshotUploadWithHttpInfo(Long projectId, String language, String commit, OffsetDateTime date) throws ApiException {
        okhttp3.Call localVarCall = initSnapshotUploadValidateBeforeCall(projectId, language, commit, date, null);
        Type localVarReturnType = new TypeToken<UploadSession>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Start snapshot upload session (asynchronously)
     * Start a session to upload an externally-built database (which represents a snapshot of a codebase) to a project on LGTM.   This endpoint works for projects that are already on LGTM, and the selected language of  the database must already be configured. The project must be configured with &#39;upload&#39; analysis mode. You can upload a \&quot;bundled\&quot; CodeQL database or a database exported by  the QL command-line tools (&#x60;odasa&#x60;).  If your database was generated using a version of the  command line that is older than LGTM,  LGTM will try to upgrade and analyze it when the upload is complete. You can include cached predicates in the upload, but they are ignored as the cache is  repopulated after the database has been upgraded and analyzed. However, if you want to include results with your database, make sure the database is  compatible before you start the upload session.  Incompatible databases with results won&#39;t be upgraded and therefore cannot be uploaded.  For further information on externally-built databases,  see [Preparing snapshots to upload to LGTM using the QL command-line tools](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).       When the upload session has been successfully started, upload the database to the  upload URL returned in the response. The database can be uploaded to the upload URL in parts using  the [&#x60;PUT /snapshots/uploads/{session-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIduploadPart) endpoint. After uploading all the parts you must call  the [&#x60;POST /snapshots/uploads/{session-id}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdcompleteUpload) endpoint to complete the upload session. 
     * @param projectId The numeric project identifier. (required)
     * @param language The language of the database to upload. (required)
     * @param commit The identifier of the analyzed commit. (required)
     * @param date The date and time of the analyzed commit (default the current time). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Success. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call initSnapshotUploadAsync(Long projectId, String language, String commit, OffsetDateTime date, final ApiCallback<UploadSession> _callback) throws ApiException {

        okhttp3.Call localVarCall = initSnapshotUploadValidateBeforeCall(projectId, language, commit, date, _callback);
        Type localVarReturnType = new TypeToken<UploadSession>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for uploadPart
     * @param sessionId The id of the upload session. (required)
     * @param body The database or database part to upload. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Success. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call uploadPartCall(String sessionId, File body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/snapshots/uploads/{session-id}"
            .replace("{" + "session-id" + "}", localVarApiClient.escapeString(sessionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/octet-stream",
            "application/zip"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "access-token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call uploadPartValidateBeforeCall(String sessionId, File body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'sessionId' is set
        if (sessionId == null) {
            throw new ApiException("Missing the required parameter 'sessionId' when calling uploadPart(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling uploadPart(Async)");
        }

        return uploadPartCall(sessionId, body, _callback);

    }

    /**
     * Upload snapshot
     * Upload a database representing a snapshot of a codebase.  The database is sent in one or more parts. Each part is sent in the request body.  Use the [&#x60;POST /snapshots/{project-id}/{language}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdinitSnapshotUpload) endpoint  to start an upload session before uploading a database part. Database parts must have been generated and prepared for upload using the CodeQL CLI or the QL command-line tools. For further information on exporting externally-built databases,  see [Preparing snapshots to upload to LGTM](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).  Split large databases into multiple parts. Upload the parts by making a separate request for each part.  Don&#39;t upload the next part until you&#39;ve successfully uploaded the previous part.  If the upload fails you should retry it with the same data. 
     * @param sessionId The id of the upload session. (required)
     * @param body The database or database part to upload. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Success. </td><td>  -  </td></tr>
     </table>
     */
    public void uploadPart(String sessionId, File body) throws ApiException {
        uploadPartWithHttpInfo(sessionId, body);
    }

    /**
     * Upload snapshot
     * Upload a database representing a snapshot of a codebase.  The database is sent in one or more parts. Each part is sent in the request body.  Use the [&#x60;POST /snapshots/{project-id}/{language}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdinitSnapshotUpload) endpoint  to start an upload session before uploading a database part. Database parts must have been generated and prepared for upload using the CodeQL CLI or the QL command-line tools. For further information on exporting externally-built databases,  see [Preparing snapshots to upload to LGTM](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).  Split large databases into multiple parts. Upload the parts by making a separate request for each part.  Don&#39;t upload the next part until you&#39;ve successfully uploaded the previous part.  If the upload fails you should retry it with the same data. 
     * @param sessionId The id of the upload session. (required)
     * @param body The database or database part to upload. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Success. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> uploadPartWithHttpInfo(String sessionId, File body) throws ApiException {
        okhttp3.Call localVarCall = uploadPartValidateBeforeCall(sessionId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Upload snapshot (asynchronously)
     * Upload a database representing a snapshot of a codebase.  The database is sent in one or more parts. Each part is sent in the request body.  Use the [&#x60;POST /snapshots/{project-id}/{language}&#x60;](https://lgtm.com/help/lgtm/api/api-v1#opIdinitSnapshotUpload) endpoint  to start an upload session before uploading a database part. Database parts must have been generated and prepared for upload using the CodeQL CLI or the QL command-line tools. For further information on exporting externally-built databases,  see [Preparing snapshots to upload to LGTM](https://help.semmle.com/wiki/display/SD/Preparing+snapshots+to+upload+to+LGTM).  Split large databases into multiple parts. Upload the parts by making a separate request for each part.  Don&#39;t upload the next part until you&#39;ve successfully uploaded the previous part.  If the upload fails you should retry it with the same data. 
     * @param sessionId The id of the upload session. (required)
     * @param body The database or database part to upload. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Success. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call uploadPartAsync(String sessionId, File body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = uploadPartValidateBeforeCall(sessionId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
