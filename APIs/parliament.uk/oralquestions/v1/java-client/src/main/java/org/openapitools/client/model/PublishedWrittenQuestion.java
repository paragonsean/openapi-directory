/*
 * House of Commons Oral and Written Questions API
 * An API that allows querying all tabled oral and written questions, and motions for the House of Commons.
 *
 * The version of the OpenAPI document: v1
 * Contact: softwareengineering@parliament.uk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.MemberForDate;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * PublishedWrittenQuestion
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:25:28.456197-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PublishedWrittenQuestion {
  public static final String SERIALIZED_NAME_ANSWER = "Answer";
  @SerializedName(SERIALIZED_NAME_ANSWER)
  private String answer;

  public static final String SERIALIZED_NAME_ANSWERED_WHEN = "AnsweredWhen";
  @SerializedName(SERIALIZED_NAME_ANSWERED_WHEN)
  private OffsetDateTime answeredWhen;

  public static final String SERIALIZED_NAME_ANSWERING_BODY = "AnsweringBody";
  @SerializedName(SERIALIZED_NAME_ANSWERING_BODY)
  private String answeringBody;

  public static final String SERIALIZED_NAME_ANSWERING_BODY_ID = "AnsweringBodyId";
  @SerializedName(SERIALIZED_NAME_ANSWERING_BODY_ID)
  private Integer answeringBodyId;

  public static final String SERIALIZED_NAME_ANSWERING_MINISTER = "AnsweringMinister";
  @SerializedName(SERIALIZED_NAME_ANSWERING_MINISTER)
  private MemberForDate answeringMinister;

  public static final String SERIALIZED_NAME_ANSWERING_MINISTER_ID = "AnsweringMinisterId";
  @SerializedName(SERIALIZED_NAME_ANSWERING_MINISTER_ID)
  private Integer answeringMinisterId;

  public static final String SERIALIZED_NAME_ANSWERING_MINISTER_TITLE = "AnsweringMinisterTitle";
  @SerializedName(SERIALIZED_NAME_ANSWERING_MINISTER_TITLE)
  private String answeringMinisterTitle;

  public static final String SERIALIZED_NAME_ASKING_MEMBER = "AskingMember";
  @SerializedName(SERIALIZED_NAME_ASKING_MEMBER)
  private MemberForDate askingMember;

  public static final String SERIALIZED_NAME_ASKING_MEMBER_ID = "AskingMemberId";
  @SerializedName(SERIALIZED_NAME_ASKING_MEMBER_ID)
  private Integer askingMemberId;

  public static final String SERIALIZED_NAME_DUE_FOR_ANSWER = "DueForAnswer";
  @SerializedName(SERIALIZED_NAME_DUE_FOR_ANSWER)
  private OffsetDateTime dueForAnswer;

  public static final String SERIALIZED_NAME_ID = "Id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Integer id;

  public static final String SERIALIZED_NAME_QUESTION_TEXT = "QuestionText";
  @SerializedName(SERIALIZED_NAME_QUESTION_TEXT)
  private String questionText;

  /**
   * Gets or Sets questionType
   */
  @JsonAdapter(QuestionTypeEnum.Adapter.class)
  public enum QuestionTypeEnum {
    NAMED_DAY("NamedDay"),
    
    ORDINARY("Ordinary");

    private String value;

    QuestionTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static QuestionTypeEnum fromValue(String value) {
      for (QuestionTypeEnum b : QuestionTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<QuestionTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final QuestionTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public QuestionTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return QuestionTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      QuestionTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_QUESTION_TYPE = "QuestionType";
  @SerializedName(SERIALIZED_NAME_QUESTION_TYPE)
  private QuestionTypeEnum questionType;

  public static final String SERIALIZED_NAME_TABLED_WHEN = "TabledWhen";
  @SerializedName(SERIALIZED_NAME_TABLED_WHEN)
  private OffsetDateTime tabledWhen;

  public static final String SERIALIZED_NAME_U_I_N = "UIN";
  @SerializedName(SERIALIZED_NAME_U_I_N)
  private Integer UIN;

  public PublishedWrittenQuestion() {
  }

  public PublishedWrittenQuestion answer(String answer) {
    this.answer = answer;
    return this;
  }

  /**
   * Get answer
   * @return answer
   */
  @javax.annotation.Nullable
  public String getAnswer() {
    return answer;
  }

  public void setAnswer(String answer) {
    this.answer = answer;
  }


  public PublishedWrittenQuestion answeredWhen(OffsetDateTime answeredWhen) {
    this.answeredWhen = answeredWhen;
    return this;
  }

  /**
   * Get answeredWhen
   * @return answeredWhen
   */
  @javax.annotation.Nullable
  public OffsetDateTime getAnsweredWhen() {
    return answeredWhen;
  }

  public void setAnsweredWhen(OffsetDateTime answeredWhen) {
    this.answeredWhen = answeredWhen;
  }


  public PublishedWrittenQuestion answeringBody(String answeringBody) {
    this.answeringBody = answeringBody;
    return this;
  }

  /**
   * Get answeringBody
   * @return answeringBody
   */
  @javax.annotation.Nullable
  public String getAnsweringBody() {
    return answeringBody;
  }

  public void setAnsweringBody(String answeringBody) {
    this.answeringBody = answeringBody;
  }


  public PublishedWrittenQuestion answeringBodyId(Integer answeringBodyId) {
    this.answeringBodyId = answeringBodyId;
    return this;
  }

  /**
   * Get answeringBodyId
   * @return answeringBodyId
   */
  @javax.annotation.Nullable
  public Integer getAnsweringBodyId() {
    return answeringBodyId;
  }

  public void setAnsweringBodyId(Integer answeringBodyId) {
    this.answeringBodyId = answeringBodyId;
  }


  public PublishedWrittenQuestion answeringMinister(MemberForDate answeringMinister) {
    this.answeringMinister = answeringMinister;
    return this;
  }

  /**
   * Get answeringMinister
   * @return answeringMinister
   */
  @javax.annotation.Nullable
  public MemberForDate getAnsweringMinister() {
    return answeringMinister;
  }

  public void setAnsweringMinister(MemberForDate answeringMinister) {
    this.answeringMinister = answeringMinister;
  }


  public PublishedWrittenQuestion answeringMinisterId(Integer answeringMinisterId) {
    this.answeringMinisterId = answeringMinisterId;
    return this;
  }

  /**
   * Get answeringMinisterId
   * @return answeringMinisterId
   */
  @javax.annotation.Nullable
  public Integer getAnsweringMinisterId() {
    return answeringMinisterId;
  }

  public void setAnsweringMinisterId(Integer answeringMinisterId) {
    this.answeringMinisterId = answeringMinisterId;
  }


  public PublishedWrittenQuestion answeringMinisterTitle(String answeringMinisterTitle) {
    this.answeringMinisterTitle = answeringMinisterTitle;
    return this;
  }

  /**
   * Get answeringMinisterTitle
   * @return answeringMinisterTitle
   */
  @javax.annotation.Nullable
  public String getAnsweringMinisterTitle() {
    return answeringMinisterTitle;
  }

  public void setAnsweringMinisterTitle(String answeringMinisterTitle) {
    this.answeringMinisterTitle = answeringMinisterTitle;
  }


  public PublishedWrittenQuestion askingMember(MemberForDate askingMember) {
    this.askingMember = askingMember;
    return this;
  }

  /**
   * Get askingMember
   * @return askingMember
   */
  @javax.annotation.Nullable
  public MemberForDate getAskingMember() {
    return askingMember;
  }

  public void setAskingMember(MemberForDate askingMember) {
    this.askingMember = askingMember;
  }


  public PublishedWrittenQuestion askingMemberId(Integer askingMemberId) {
    this.askingMemberId = askingMemberId;
    return this;
  }

  /**
   * Get askingMemberId
   * @return askingMemberId
   */
  @javax.annotation.Nullable
  public Integer getAskingMemberId() {
    return askingMemberId;
  }

  public void setAskingMemberId(Integer askingMemberId) {
    this.askingMemberId = askingMemberId;
  }


  public PublishedWrittenQuestion dueForAnswer(OffsetDateTime dueForAnswer) {
    this.dueForAnswer = dueForAnswer;
    return this;
  }

  /**
   * Get dueForAnswer
   * @return dueForAnswer
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDueForAnswer() {
    return dueForAnswer;
  }

  public void setDueForAnswer(OffsetDateTime dueForAnswer) {
    this.dueForAnswer = dueForAnswer;
  }


  public PublishedWrittenQuestion id(Integer id) {
    this.id = id;
    return this;
  }

  /**
   * Get id
   * @return id
   */
  @javax.annotation.Nullable
  public Integer getId() {
    return id;
  }

  public void setId(Integer id) {
    this.id = id;
  }


  public PublishedWrittenQuestion questionText(String questionText) {
    this.questionText = questionText;
    return this;
  }

  /**
   * Get questionText
   * @return questionText
   */
  @javax.annotation.Nullable
  public String getQuestionText() {
    return questionText;
  }

  public void setQuestionText(String questionText) {
    this.questionText = questionText;
  }


  public PublishedWrittenQuestion questionType(QuestionTypeEnum questionType) {
    this.questionType = questionType;
    return this;
  }

  /**
   * Get questionType
   * @return questionType
   */
  @javax.annotation.Nullable
  public QuestionTypeEnum getQuestionType() {
    return questionType;
  }

  public void setQuestionType(QuestionTypeEnum questionType) {
    this.questionType = questionType;
  }


  public PublishedWrittenQuestion tabledWhen(OffsetDateTime tabledWhen) {
    this.tabledWhen = tabledWhen;
    return this;
  }

  /**
   * Get tabledWhen
   * @return tabledWhen
   */
  @javax.annotation.Nullable
  public OffsetDateTime getTabledWhen() {
    return tabledWhen;
  }

  public void setTabledWhen(OffsetDateTime tabledWhen) {
    this.tabledWhen = tabledWhen;
  }


  public PublishedWrittenQuestion UIN(Integer UIN) {
    this.UIN = UIN;
    return this;
  }

  /**
   * Get UIN
   * @return UIN
   */
  @javax.annotation.Nullable
  public Integer getUIN() {
    return UIN;
  }

  public void setUIN(Integer UIN) {
    this.UIN = UIN;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PublishedWrittenQuestion publishedWrittenQuestion = (PublishedWrittenQuestion) o;
    return Objects.equals(this.answer, publishedWrittenQuestion.answer) &&
        Objects.equals(this.answeredWhen, publishedWrittenQuestion.answeredWhen) &&
        Objects.equals(this.answeringBody, publishedWrittenQuestion.answeringBody) &&
        Objects.equals(this.answeringBodyId, publishedWrittenQuestion.answeringBodyId) &&
        Objects.equals(this.answeringMinister, publishedWrittenQuestion.answeringMinister) &&
        Objects.equals(this.answeringMinisterId, publishedWrittenQuestion.answeringMinisterId) &&
        Objects.equals(this.answeringMinisterTitle, publishedWrittenQuestion.answeringMinisterTitle) &&
        Objects.equals(this.askingMember, publishedWrittenQuestion.askingMember) &&
        Objects.equals(this.askingMemberId, publishedWrittenQuestion.askingMemberId) &&
        Objects.equals(this.dueForAnswer, publishedWrittenQuestion.dueForAnswer) &&
        Objects.equals(this.id, publishedWrittenQuestion.id) &&
        Objects.equals(this.questionText, publishedWrittenQuestion.questionText) &&
        Objects.equals(this.questionType, publishedWrittenQuestion.questionType) &&
        Objects.equals(this.tabledWhen, publishedWrittenQuestion.tabledWhen) &&
        Objects.equals(this.UIN, publishedWrittenQuestion.UIN);
  }

  @Override
  public int hashCode() {
    return Objects.hash(answer, answeredWhen, answeringBody, answeringBodyId, answeringMinister, answeringMinisterId, answeringMinisterTitle, askingMember, askingMemberId, dueForAnswer, id, questionText, questionType, tabledWhen, UIN);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PublishedWrittenQuestion {\n");
    sb.append("    answer: ").append(toIndentedString(answer)).append("\n");
    sb.append("    answeredWhen: ").append(toIndentedString(answeredWhen)).append("\n");
    sb.append("    answeringBody: ").append(toIndentedString(answeringBody)).append("\n");
    sb.append("    answeringBodyId: ").append(toIndentedString(answeringBodyId)).append("\n");
    sb.append("    answeringMinister: ").append(toIndentedString(answeringMinister)).append("\n");
    sb.append("    answeringMinisterId: ").append(toIndentedString(answeringMinisterId)).append("\n");
    sb.append("    answeringMinisterTitle: ").append(toIndentedString(answeringMinisterTitle)).append("\n");
    sb.append("    askingMember: ").append(toIndentedString(askingMember)).append("\n");
    sb.append("    askingMemberId: ").append(toIndentedString(askingMemberId)).append("\n");
    sb.append("    dueForAnswer: ").append(toIndentedString(dueForAnswer)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    questionText: ").append(toIndentedString(questionText)).append("\n");
    sb.append("    questionType: ").append(toIndentedString(questionType)).append("\n");
    sb.append("    tabledWhen: ").append(toIndentedString(tabledWhen)).append("\n");
    sb.append("    UIN: ").append(toIndentedString(UIN)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Answer");
    openapiFields.add("AnsweredWhen");
    openapiFields.add("AnsweringBody");
    openapiFields.add("AnsweringBodyId");
    openapiFields.add("AnsweringMinister");
    openapiFields.add("AnsweringMinisterId");
    openapiFields.add("AnsweringMinisterTitle");
    openapiFields.add("AskingMember");
    openapiFields.add("AskingMemberId");
    openapiFields.add("DueForAnswer");
    openapiFields.add("Id");
    openapiFields.add("QuestionText");
    openapiFields.add("QuestionType");
    openapiFields.add("TabledWhen");
    openapiFields.add("UIN");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PublishedWrittenQuestion
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PublishedWrittenQuestion.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PublishedWrittenQuestion is not found in the empty JSON string", PublishedWrittenQuestion.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PublishedWrittenQuestion.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PublishedWrittenQuestion` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("Answer") != null && !jsonObj.get("Answer").isJsonNull()) && !jsonObj.get("Answer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Answer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Answer").toString()));
      }
      if ((jsonObj.get("AnsweringBody") != null && !jsonObj.get("AnsweringBody").isJsonNull()) && !jsonObj.get("AnsweringBody").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `AnsweringBody` to be a primitive type in the JSON string but got `%s`", jsonObj.get("AnsweringBody").toString()));
      }
      // validate the optional field `AnsweringMinister`
      if (jsonObj.get("AnsweringMinister") != null && !jsonObj.get("AnsweringMinister").isJsonNull()) {
        MemberForDate.validateJsonElement(jsonObj.get("AnsweringMinister"));
      }
      if ((jsonObj.get("AnsweringMinisterTitle") != null && !jsonObj.get("AnsweringMinisterTitle").isJsonNull()) && !jsonObj.get("AnsweringMinisterTitle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `AnsweringMinisterTitle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("AnsweringMinisterTitle").toString()));
      }
      // validate the optional field `AskingMember`
      if (jsonObj.get("AskingMember") != null && !jsonObj.get("AskingMember").isJsonNull()) {
        MemberForDate.validateJsonElement(jsonObj.get("AskingMember"));
      }
      if ((jsonObj.get("QuestionText") != null && !jsonObj.get("QuestionText").isJsonNull()) && !jsonObj.get("QuestionText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `QuestionText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("QuestionText").toString()));
      }
      if ((jsonObj.get("QuestionType") != null && !jsonObj.get("QuestionType").isJsonNull()) && !jsonObj.get("QuestionType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `QuestionType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("QuestionType").toString()));
      }
      // validate the optional field `QuestionType`
      if (jsonObj.get("QuestionType") != null && !jsonObj.get("QuestionType").isJsonNull()) {
        QuestionTypeEnum.validateJsonElement(jsonObj.get("QuestionType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PublishedWrittenQuestion.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PublishedWrittenQuestion' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PublishedWrittenQuestion> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PublishedWrittenQuestion.class));

       return (TypeAdapter<T>) new TypeAdapter<PublishedWrittenQuestion>() {
           @Override
           public void write(JsonWriter out, PublishedWrittenQuestion value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PublishedWrittenQuestion read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PublishedWrittenQuestion given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PublishedWrittenQuestion
   * @throws IOException if the JSON string is invalid with respect to PublishedWrittenQuestion
   */
  public static PublishedWrittenQuestion fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PublishedWrittenQuestion.class);
  }

  /**
   * Convert an instance of PublishedWrittenQuestion to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

