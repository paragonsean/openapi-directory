/*
 * OpenCage Geocoder
 * Worldwide forward and reverse geocoding
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DefaultApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public DefaultApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DefaultApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for vversionFormatGet
     * @param version API version. (required)
     * @param format format of the response. One of &#39;json&#39;, &#39;xml&#39; or &#39;map&#39;. (required)
     * @param q string or lat,lng to be geocoded. (required)
     * @param key an application key. (required)
     * @param abbrv when true we attempt to abbreviate the formatted field of results. (optional)
     * @param addressOnly when true we include only address details in the formatted field of results. (optional)
     * @param addRequest if true the request is included in the response. (optional)
     * @param bounds four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat). (optional)
     * @param countrycode two letter code ISO 3166-1 Alpha 2 code to limit results to that country. (optional)
     * @param jsonp wraps the returned JSON with a function name. (optional)
     * @param language an IETF format language code (ex: &#39;es&#39; or &#39;pt-BR&#39;). (optional)
     * @param limit maximum number of results to return. Default is 10. Maximum is 100. (optional)
     * @param minConfidence integer from 1-10. Only results with at least this confidence are returned. (optional)
     * @param noAnnotations when true annotations are not added to results. (optional)
     * @param noDedupe when true results are not deduplicated. (optional)
     * @param noRecord when true query content is not logged. (optional)
     * @param pretty when true results are pretty printed. Useful for debugging. (optional)
     * @param proximity lat,lng to bias results. (optional)
     * @param roadinfo match nearest road, include roadinfo annotation (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unable to authenticate </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Valid request but quota exceeded </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Invalid API endpoint </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method not allowed </td><td>  -  </td></tr>
        <tr><td> 408 </td><td> Timeout; you can try again </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> Request too long </td><td>  -  </td></tr>
        <tr><td> 426 </td><td> Upgrade required </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call vversionFormatGetCall(Integer version, String format, String q, String key, Boolean abbrv, Boolean addressOnly, Boolean addRequest, String bounds, String countrycode, String jsonp, String language, Integer limit, Integer minConfidence, Boolean noAnnotations, Boolean noDedupe, Boolean noRecord, Boolean pretty, String proximity, Boolean roadinfo, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v{version}/{format}"
            .replace("{" + "version" + "}", localVarApiClient.escapeString(version.toString()))
            .replace("{" + "format" + "}", localVarApiClient.escapeString(format.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (key != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("key", key));
        }

        if (abbrv != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("abbrv", abbrv));
        }

        if (addressOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("address_only", addressOnly));
        }

        if (addRequest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("add_request", addRequest));
        }

        if (bounds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("bounds", bounds));
        }

        if (countrycode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("countrycode", countrycode));
        }

        if (jsonp != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jsonp", jsonp));
        }

        if (language != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("language", language));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (minConfidence != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min_confidence", minConfidence));
        }

        if (noAnnotations != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("no_annotations", noAnnotations));
        }

        if (noDedupe != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("no_dedupe", noDedupe));
        }

        if (noRecord != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("no_record", noRecord));
        }

        if (pretty != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pretty", pretty));
        }

        if (proximity != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("proximity", proximity));
        }

        if (roadinfo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("roadinfo", roadinfo));
        }

        final String[] localVarAccepts = {
            "application/json",
            "application/xml",
            "text/html"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call vversionFormatGetValidateBeforeCall(Integer version, String format, String q, String key, Boolean abbrv, Boolean addressOnly, Boolean addRequest, String bounds, String countrycode, String jsonp, String language, Integer limit, Integer minConfidence, Boolean noAnnotations, Boolean noDedupe, Boolean noRecord, Boolean pretty, String proximity, Boolean roadinfo, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'version' is set
        if (version == null) {
            throw new ApiException("Missing the required parameter 'version' when calling vversionFormatGet(Async)");
        }

        // verify the required parameter 'format' is set
        if (format == null) {
            throw new ApiException("Missing the required parameter 'format' when calling vversionFormatGet(Async)");
        }

        // verify the required parameter 'q' is set
        if (q == null) {
            throw new ApiException("Missing the required parameter 'q' when calling vversionFormatGet(Async)");
        }

        // verify the required parameter 'key' is set
        if (key == null) {
            throw new ApiException("Missing the required parameter 'key' when calling vversionFormatGet(Async)");
        }

        return vversionFormatGetCall(version, format, q, key, abbrv, addressOnly, addRequest, bounds, countrycode, jsonp, language, limit, minConfidence, noAnnotations, noDedupe, noRecord, pretty, proximity, roadinfo, _callback);

    }

    /**
     * 
     * geocode a query
     * @param version API version. (required)
     * @param format format of the response. One of &#39;json&#39;, &#39;xml&#39; or &#39;map&#39;. (required)
     * @param q string or lat,lng to be geocoded. (required)
     * @param key an application key. (required)
     * @param abbrv when true we attempt to abbreviate the formatted field of results. (optional)
     * @param addressOnly when true we include only address details in the formatted field of results. (optional)
     * @param addRequest if true the request is included in the response. (optional)
     * @param bounds four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat). (optional)
     * @param countrycode two letter code ISO 3166-1 Alpha 2 code to limit results to that country. (optional)
     * @param jsonp wraps the returned JSON with a function name. (optional)
     * @param language an IETF format language code (ex: &#39;es&#39; or &#39;pt-BR&#39;). (optional)
     * @param limit maximum number of results to return. Default is 10. Maximum is 100. (optional)
     * @param minConfidence integer from 1-10. Only results with at least this confidence are returned. (optional)
     * @param noAnnotations when true annotations are not added to results. (optional)
     * @param noDedupe when true results are not deduplicated. (optional)
     * @param noRecord when true query content is not logged. (optional)
     * @param pretty when true results are pretty printed. Useful for debugging. (optional)
     * @param proximity lat,lng to bias results. (optional)
     * @param roadinfo match nearest road, include roadinfo annotation (optional)
     * @return Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unable to authenticate </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Valid request but quota exceeded </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Invalid API endpoint </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method not allowed </td><td>  -  </td></tr>
        <tr><td> 408 </td><td> Timeout; you can try again </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> Request too long </td><td>  -  </td></tr>
        <tr><td> 426 </td><td> Upgrade required </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public Response vversionFormatGet(Integer version, String format, String q, String key, Boolean abbrv, Boolean addressOnly, Boolean addRequest, String bounds, String countrycode, String jsonp, String language, Integer limit, Integer minConfidence, Boolean noAnnotations, Boolean noDedupe, Boolean noRecord, Boolean pretty, String proximity, Boolean roadinfo) throws ApiException {
        ApiResponse<Response> localVarResp = vversionFormatGetWithHttpInfo(version, format, q, key, abbrv, addressOnly, addRequest, bounds, countrycode, jsonp, language, limit, minConfidence, noAnnotations, noDedupe, noRecord, pretty, proximity, roadinfo);
        return localVarResp.getData();
    }

    /**
     * 
     * geocode a query
     * @param version API version. (required)
     * @param format format of the response. One of &#39;json&#39;, &#39;xml&#39; or &#39;map&#39;. (required)
     * @param q string or lat,lng to be geocoded. (required)
     * @param key an application key. (required)
     * @param abbrv when true we attempt to abbreviate the formatted field of results. (optional)
     * @param addressOnly when true we include only address details in the formatted field of results. (optional)
     * @param addRequest if true the request is included in the response. (optional)
     * @param bounds four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat). (optional)
     * @param countrycode two letter code ISO 3166-1 Alpha 2 code to limit results to that country. (optional)
     * @param jsonp wraps the returned JSON with a function name. (optional)
     * @param language an IETF format language code (ex: &#39;es&#39; or &#39;pt-BR&#39;). (optional)
     * @param limit maximum number of results to return. Default is 10. Maximum is 100. (optional)
     * @param minConfidence integer from 1-10. Only results with at least this confidence are returned. (optional)
     * @param noAnnotations when true annotations are not added to results. (optional)
     * @param noDedupe when true results are not deduplicated. (optional)
     * @param noRecord when true query content is not logged. (optional)
     * @param pretty when true results are pretty printed. Useful for debugging. (optional)
     * @param proximity lat,lng to bias results. (optional)
     * @param roadinfo match nearest road, include roadinfo annotation (optional)
     * @return ApiResponse&lt;Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unable to authenticate </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Valid request but quota exceeded </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Invalid API endpoint </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method not allowed </td><td>  -  </td></tr>
        <tr><td> 408 </td><td> Timeout; you can try again </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> Request too long </td><td>  -  </td></tr>
        <tr><td> 426 </td><td> Upgrade required </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Response> vversionFormatGetWithHttpInfo(Integer version, String format, String q, String key, Boolean abbrv, Boolean addressOnly, Boolean addRequest, String bounds, String countrycode, String jsonp, String language, Integer limit, Integer minConfidence, Boolean noAnnotations, Boolean noDedupe, Boolean noRecord, Boolean pretty, String proximity, Boolean roadinfo) throws ApiException {
        okhttp3.Call localVarCall = vversionFormatGetValidateBeforeCall(version, format, q, key, abbrv, addressOnly, addRequest, bounds, countrycode, jsonp, language, limit, minConfidence, noAnnotations, noDedupe, noRecord, pretty, proximity, roadinfo, null);
        Type localVarReturnType = new TypeToken<Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * geocode a query
     * @param version API version. (required)
     * @param format format of the response. One of &#39;json&#39;, &#39;xml&#39; or &#39;map&#39;. (required)
     * @param q string or lat,lng to be geocoded. (required)
     * @param key an application key. (required)
     * @param abbrv when true we attempt to abbreviate the formatted field of results. (optional)
     * @param addressOnly when true we include only address details in the formatted field of results. (optional)
     * @param addRequest if true the request is included in the response. (optional)
     * @param bounds four coordinate points forming the south-west and north-east corners of a bounding box (min long, min lat, max long, max lat). (optional)
     * @param countrycode two letter code ISO 3166-1 Alpha 2 code to limit results to that country. (optional)
     * @param jsonp wraps the returned JSON with a function name. (optional)
     * @param language an IETF format language code (ex: &#39;es&#39; or &#39;pt-BR&#39;). (optional)
     * @param limit maximum number of results to return. Default is 10. Maximum is 100. (optional)
     * @param minConfidence integer from 1-10. Only results with at least this confidence are returned. (optional)
     * @param noAnnotations when true annotations are not added to results. (optional)
     * @param noDedupe when true results are not deduplicated. (optional)
     * @param noRecord when true query content is not logged. (optional)
     * @param pretty when true results are pretty printed. Useful for debugging. (optional)
     * @param proximity lat,lng to bias results. (optional)
     * @param roadinfo match nearest road, include roadinfo annotation (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unable to authenticate </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Valid request but quota exceeded </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Invalid API endpoint </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> Method not allowed </td><td>  -  </td></tr>
        <tr><td> 408 </td><td> Timeout; you can try again </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> Request too long </td><td>  -  </td></tr>
        <tr><td> 426 </td><td> Upgrade required </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call vversionFormatGetAsync(Integer version, String format, String q, String key, Boolean abbrv, Boolean addressOnly, Boolean addRequest, String bounds, String countrycode, String jsonp, String language, Integer limit, Integer minConfidence, Boolean noAnnotations, Boolean noDedupe, Boolean noRecord, Boolean pretty, String proximity, Boolean roadinfo, final ApiCallback<Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = vversionFormatGetValidateBeforeCall(version, format, q, key, abbrv, addressOnly, addRequest, bounds, countrycode, jsonp, language, limit, minConfidence, noAnnotations, noDedupe, noRecord, pretty, proximity, roadinfo, _callback);
        Type localVarReturnType = new TypeToken<Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
