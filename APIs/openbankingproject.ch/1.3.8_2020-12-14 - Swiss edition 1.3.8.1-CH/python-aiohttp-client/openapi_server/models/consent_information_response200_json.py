# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.account_access import AccountAccess
from openapi_server.models.consent_status import ConsentStatus
from openapi_server.models.links_get_consent import LinksGetConsent
from openapi_server import util


class ConsentInformationResponse200Json(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, links: LinksGetConsent=None, access: AccountAccess=None, consent_status: ConsentStatus=None, frequency_per_day: int=None, last_action_date: date=None, recurring_indicator: bool=None, valid_until: date=None):
        """ConsentInformationResponse200Json - a model defined in OpenAPI

        :param links: The links of this ConsentInformationResponse200Json.
        :param access: The access of this ConsentInformationResponse200Json.
        :param consent_status: The consent_status of this ConsentInformationResponse200Json.
        :param frequency_per_day: The frequency_per_day of this ConsentInformationResponse200Json.
        :param last_action_date: The last_action_date of this ConsentInformationResponse200Json.
        :param recurring_indicator: The recurring_indicator of this ConsentInformationResponse200Json.
        :param valid_until: The valid_until of this ConsentInformationResponse200Json.
        """
        self.openapi_types = {
            'links': LinksGetConsent,
            'access': AccountAccess,
            'consent_status': ConsentStatus,
            'frequency_per_day': int,
            'last_action_date': date,
            'recurring_indicator': bool,
            'valid_until': date
        }

        self.attribute_map = {
            'links': '_links',
            'access': 'access',
            'consent_status': 'consentStatus',
            'frequency_per_day': 'frequencyPerDay',
            'last_action_date': 'lastActionDate',
            'recurring_indicator': 'recurringIndicator',
            'valid_until': 'validUntil'
        }

        self._links = links
        self._access = access
        self._consent_status = consent_status
        self._frequency_per_day = frequency_per_day
        self._last_action_date = last_action_date
        self._recurring_indicator = recurring_indicator
        self._valid_until = valid_until

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ConsentInformationResponse200Json':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The consentInformationResponse-200_json of this ConsentInformationResponse200Json.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def links(self):
        """Gets the links of this ConsentInformationResponse200Json.


        :return: The links of this ConsentInformationResponse200Json.
        :rtype: LinksGetConsent
        """
        return self._links

    @links.setter
    def links(self, links):
        """Sets the links of this ConsentInformationResponse200Json.


        :param links: The links of this ConsentInformationResponse200Json.
        :type links: LinksGetConsent
        """

        self._links = links

    @property
    def access(self):
        """Gets the access of this ConsentInformationResponse200Json.


        :return: The access of this ConsentInformationResponse200Json.
        :rtype: AccountAccess
        """
        return self._access

    @access.setter
    def access(self, access):
        """Sets the access of this ConsentInformationResponse200Json.


        :param access: The access of this ConsentInformationResponse200Json.
        :type access: AccountAccess
        """
        if access is None:
            raise ValueError("Invalid value for `access`, must not be `None`")

        self._access = access

    @property
    def consent_status(self):
        """Gets the consent_status of this ConsentInformationResponse200Json.


        :return: The consent_status of this ConsentInformationResponse200Json.
        :rtype: ConsentStatus
        """
        return self._consent_status

    @consent_status.setter
    def consent_status(self, consent_status):
        """Sets the consent_status of this ConsentInformationResponse200Json.


        :param consent_status: The consent_status of this ConsentInformationResponse200Json.
        :type consent_status: ConsentStatus
        """
        if consent_status is None:
            raise ValueError("Invalid value for `consent_status`, must not be `None`")

        self._consent_status = consent_status

    @property
    def frequency_per_day(self):
        """Gets the frequency_per_day of this ConsentInformationResponse200Json.

        This field indicates the requested maximum frequency for an access without PSU involvement per day. For a one-off access, this attribute is set to \"1\".  The frequency needs to be greater equal to one.  If not otherwise agreed bilaterally between TPP and ASPSP, the frequency is less equal to 4. 

        :return: The frequency_per_day of this ConsentInformationResponse200Json.
        :rtype: int
        """
        return self._frequency_per_day

    @frequency_per_day.setter
    def frequency_per_day(self, frequency_per_day):
        """Sets the frequency_per_day of this ConsentInformationResponse200Json.

        This field indicates the requested maximum frequency for an access without PSU involvement per day. For a one-off access, this attribute is set to \"1\".  The frequency needs to be greater equal to one.  If not otherwise agreed bilaterally between TPP and ASPSP, the frequency is less equal to 4. 

        :param frequency_per_day: The frequency_per_day of this ConsentInformationResponse200Json.
        :type frequency_per_day: int
        """
        if frequency_per_day is None:
            raise ValueError("Invalid value for `frequency_per_day`, must not be `None`")
        if frequency_per_day is not None and frequency_per_day < 1:
            raise ValueError("Invalid value for `frequency_per_day`, must be a value greater than or equal to `1`")

        self._frequency_per_day = frequency_per_day

    @property
    def last_action_date(self):
        """Gets the last_action_date of this ConsentInformationResponse200Json.

        This date is containing the date of the last action on the consent object either through the XS2A interface or the PSU/ASPSP interface having an impact on the status. 

        :return: The last_action_date of this ConsentInformationResponse200Json.
        :rtype: date
        """
        return self._last_action_date

    @last_action_date.setter
    def last_action_date(self, last_action_date):
        """Sets the last_action_date of this ConsentInformationResponse200Json.

        This date is containing the date of the last action on the consent object either through the XS2A interface or the PSU/ASPSP interface having an impact on the status. 

        :param last_action_date: The last_action_date of this ConsentInformationResponse200Json.
        :type last_action_date: date
        """
        if last_action_date is None:
            raise ValueError("Invalid value for `last_action_date`, must not be `None`")

        self._last_action_date = last_action_date

    @property
    def recurring_indicator(self):
        """Gets the recurring_indicator of this ConsentInformationResponse200Json.

        \"true\", if the consent is for recurring access to the account data.  \"false\", if the consent is for one access to the account data. 

        :return: The recurring_indicator of this ConsentInformationResponse200Json.
        :rtype: bool
        """
        return self._recurring_indicator

    @recurring_indicator.setter
    def recurring_indicator(self, recurring_indicator):
        """Sets the recurring_indicator of this ConsentInformationResponse200Json.

        \"true\", if the consent is for recurring access to the account data.  \"false\", if the consent is for one access to the account data. 

        :param recurring_indicator: The recurring_indicator of this ConsentInformationResponse200Json.
        :type recurring_indicator: bool
        """
        if recurring_indicator is None:
            raise ValueError("Invalid value for `recurring_indicator`, must not be `None`")

        self._recurring_indicator = recurring_indicator

    @property
    def valid_until(self):
        """Gets the valid_until of this ConsentInformationResponse200Json.

        This parameter is defining a valid until date (including the mentioned date) for the requested consent.  The content is the local ASPSP date in ISO-Date format, e.g. 2017-10-30.  Future dates might get adjusted by ASPSP.   If a maximal available date is requested, a date in far future is to be used: \"9999-12-31\".   In both cases the consent object to be retrieved by the get consent request will contain the adjusted date. 

        :return: The valid_until of this ConsentInformationResponse200Json.
        :rtype: date
        """
        return self._valid_until

    @valid_until.setter
    def valid_until(self, valid_until):
        """Sets the valid_until of this ConsentInformationResponse200Json.

        This parameter is defining a valid until date (including the mentioned date) for the requested consent.  The content is the local ASPSP date in ISO-Date format, e.g. 2017-10-30.  Future dates might get adjusted by ASPSP.   If a maximal available date is requested, a date in far future is to be used: \"9999-12-31\".   In both cases the consent object to be retrieved by the get consent request will contain the adjusted date. 

        :param valid_until: The valid_until of this ConsentInformationResponse200Json.
        :type valid_until: date
        """
        if valid_until is None:
            raise ValueError("Invalid value for `valid_until`, must not be `None`")

        self._valid_until = valid_until
