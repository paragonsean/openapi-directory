# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.account_access import AccountAccess
from openapi_server import util


class Consents(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, access: AccountAccess=None, combined_service_indicator: bool=None, frequency_per_day: int=None, recurring_indicator: bool=None, valid_until: date=None):
        """Consents - a model defined in OpenAPI

        :param access: The access of this Consents.
        :param combined_service_indicator: The combined_service_indicator of this Consents.
        :param frequency_per_day: The frequency_per_day of this Consents.
        :param recurring_indicator: The recurring_indicator of this Consents.
        :param valid_until: The valid_until of this Consents.
        """
        self.openapi_types = {
            'access': AccountAccess,
            'combined_service_indicator': bool,
            'frequency_per_day': int,
            'recurring_indicator': bool,
            'valid_until': date
        }

        self.attribute_map = {
            'access': 'access',
            'combined_service_indicator': 'combinedServiceIndicator',
            'frequency_per_day': 'frequencyPerDay',
            'recurring_indicator': 'recurringIndicator',
            'valid_until': 'validUntil'
        }

        self._access = access
        self._combined_service_indicator = combined_service_indicator
        self._frequency_per_day = frequency_per_day
        self._recurring_indicator = recurring_indicator
        self._valid_until = valid_until

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Consents':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The consents of this Consents.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def access(self):
        """Gets the access of this Consents.


        :return: The access of this Consents.
        :rtype: AccountAccess
        """
        return self._access

    @access.setter
    def access(self, access):
        """Sets the access of this Consents.


        :param access: The access of this Consents.
        :type access: AccountAccess
        """
        if access is None:
            raise ValueError("Invalid value for `access`, must not be `None`")

        self._access = access

    @property
    def combined_service_indicator(self):
        """Gets the combined_service_indicator of this Consents.

        If \"true\" indicates that a payment initiation service will be addressed in the same \"session\". 

        :return: The combined_service_indicator of this Consents.
        :rtype: bool
        """
        return self._combined_service_indicator

    @combined_service_indicator.setter
    def combined_service_indicator(self, combined_service_indicator):
        """Sets the combined_service_indicator of this Consents.

        If \"true\" indicates that a payment initiation service will be addressed in the same \"session\". 

        :param combined_service_indicator: The combined_service_indicator of this Consents.
        :type combined_service_indicator: bool
        """
        if combined_service_indicator is None:
            raise ValueError("Invalid value for `combined_service_indicator`, must not be `None`")

        self._combined_service_indicator = combined_service_indicator

    @property
    def frequency_per_day(self):
        """Gets the frequency_per_day of this Consents.

        This field indicates the requested maximum frequency for an access without PSU involvement per day. For a one-off access, this attribute is set to \"1\".  The frequency needs to be greater equal to one.  If not otherwise agreed bilaterally between TPP and ASPSP, the frequency is less equal to 4. 

        :return: The frequency_per_day of this Consents.
        :rtype: int
        """
        return self._frequency_per_day

    @frequency_per_day.setter
    def frequency_per_day(self, frequency_per_day):
        """Sets the frequency_per_day of this Consents.

        This field indicates the requested maximum frequency for an access without PSU involvement per day. For a one-off access, this attribute is set to \"1\".  The frequency needs to be greater equal to one.  If not otherwise agreed bilaterally between TPP and ASPSP, the frequency is less equal to 4. 

        :param frequency_per_day: The frequency_per_day of this Consents.
        :type frequency_per_day: int
        """
        if frequency_per_day is None:
            raise ValueError("Invalid value for `frequency_per_day`, must not be `None`")
        if frequency_per_day is not None and frequency_per_day < 1:
            raise ValueError("Invalid value for `frequency_per_day`, must be a value greater than or equal to `1`")

        self._frequency_per_day = frequency_per_day

    @property
    def recurring_indicator(self):
        """Gets the recurring_indicator of this Consents.

        \"true\", if the consent is for recurring access to the account data.  \"false\", if the consent is for one access to the account data. 

        :return: The recurring_indicator of this Consents.
        :rtype: bool
        """
        return self._recurring_indicator

    @recurring_indicator.setter
    def recurring_indicator(self, recurring_indicator):
        """Sets the recurring_indicator of this Consents.

        \"true\", if the consent is for recurring access to the account data.  \"false\", if the consent is for one access to the account data. 

        :param recurring_indicator: The recurring_indicator of this Consents.
        :type recurring_indicator: bool
        """
        if recurring_indicator is None:
            raise ValueError("Invalid value for `recurring_indicator`, must not be `None`")

        self._recurring_indicator = recurring_indicator

    @property
    def valid_until(self):
        """Gets the valid_until of this Consents.

        This parameter is defining a valid until date (including the mentioned date) for the requested consent.  The content is the local ASPSP date in ISO-Date format, e.g. 2017-10-30.  Future dates might get adjusted by ASPSP.   If a maximal available date is requested, a date in far future is to be used: \"9999-12-31\".   In both cases the consent object to be retrieved by the get consent request will contain the adjusted date. 

        :return: The valid_until of this Consents.
        :rtype: date
        """
        return self._valid_until

    @valid_until.setter
    def valid_until(self, valid_until):
        """Sets the valid_until of this Consents.

        This parameter is defining a valid until date (including the mentioned date) for the requested consent.  The content is the local ASPSP date in ISO-Date format, e.g. 2017-10-30.  Future dates might get adjusted by ASPSP.   If a maximal available date is requested, a date in far future is to be used: \"9999-12-31\".   In both cases the consent object to be retrieved by the get consent request will contain the adjusted date. 

        :param valid_until: The valid_until of this Consents.
        :type valid_until: date
        """
        if valid_until is None:
            raise ValueError("Invalid value for `valid_until`, must not be `None`")

        self._valid_until = valid_until
