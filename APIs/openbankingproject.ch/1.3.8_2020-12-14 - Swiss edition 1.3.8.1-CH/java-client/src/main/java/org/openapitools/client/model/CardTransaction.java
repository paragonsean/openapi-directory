/*
 * Swiss NextGen Banking API-Framework
 * # Summary The **Swiss NextGen API** is based on the NextGenPSD2 *Framework Version 1.3.4* of the Berlin Group which offers a modern, open, harmonised and interoperable set of Application Programming Interfaces (APIs) as the safest and most efficient way to provide data securely. The NextGen Framework reduces XS2A complexity and costs, addresses the problem of multiple competing standards in Europe and, aligned with the goals of the Euro Retail Payments Board, enables European banking customers to benefit from innovative products and services ('Banking as a Service') by granting TPPs safe and secure (authenticated and authorised) access to their bank accounts and financial data.  The Swiss edtion refines the message formats specific to Switzerland and defines some matching examples.  The possible Approaches are:   * Redirect SCA Approach   * *(Not recommended by obp.ch community) OAuth SCA Approach*   * *(Not recommended by obp.ch community) Decoupled SCA Approach*   * *(Not recommended by obp.ch community) Embedded SCA Approach without SCA method*   * *(Not recommended by obp.ch community) Embedded SCA Approach with only one SCA method available*   * *(Not recommended by obp.ch community) Embedded SCA Approach with Selection of a SCA method*    Not every message defined in this API definition is necessary for all approaches.   Furthermore this API definition does not differ between methods which are mandatory, conditional, or optional   Therefore for a particular implementation of a compliant API it is only necessary to support   a certain subset of the methods defined in this API definition.    **Please have a look at the implementation guidelines if you are not sure   which message has to be used for the approach you are going to use.**  ## Some General Remarks Related to this version of the OpenAPI Specification: * **This API definition is based on the Implementation Guidelines of the [Berlin Group API](https://www.berlin-group.org/nextgenpsd2-downloads).**   It is not a replacement in any sense.   The main specification is (at the moment) always the Implementation Guidelines of the Berlin Group API. * **This API definition contains the REST-API for requests from the PISP to the ASPSP.** * **This API definition contains the messages for all different approaches defined in the Implementation Guidelines.** * According to the OpenAPI-Specification [https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md]      \"If in is \"header\" and the name field is \"Accept\", \"Content-Type\" or \"Authorization\", the parameter definition SHALL be ignored.\"    The element \"Accept\" will not be defined in this file at any place.    The elements \"Content-Type\" and \"Authorization\" are implicitly defined by the OpenApi tags \"content\" and \"security\".  * There are several predefined types which might occur in payment initiation messages,   but are not used in the standard JSON messages in the Implementation Guidelines.   Therefore they are not used in the corresponding messages in this file either.   We added them for the convenience of the user.   If there is a payment product, which needs these fields, one can easily use the predefined types.   But the ASPSP need not to accept them in general.  * **We omit the definition of all standard HTTP header elements (mandatory/optional/conditional)   except they are mentioned in the Implementation Guidelines.**   Therefore the implementer might add these in his own realisation of a comlient API in addition to the elements defined in this file.  ## General Remarks on Data Types  The Berlin Group definition of UTF-8 strings in context of the API have to support at least the following characters  a b c d e f g h i j k l m n o p q r s t u v w x y z  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  0 1 2 3 4 5 6 7 8 9  / - ? : ( ) . , ' +  Space 
 *
 * The version of the OpenAPI document: 1.3.8_2020-12-14 - Swiss edition 1.3.8.1-CH
 * Contact: info@obp.ch
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Address;
import org.openapitools.client.model.Amount;
import org.openapitools.client.model.ReportExchangeRate;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Card transaction information.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T10:00:56.314640-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CardTransaction {
  public static final String SERIALIZED_NAME_ACCEPTOR_TRANSACTION_DATE_TIME = "acceptorTransactionDateTime";
  @SerializedName(SERIALIZED_NAME_ACCEPTOR_TRANSACTION_DATE_TIME)
  private OffsetDateTime acceptorTransactionDateTime;

  public static final String SERIALIZED_NAME_BOOKING_DATE = "bookingDate";
  @SerializedName(SERIALIZED_NAME_BOOKING_DATE)
  private LocalDate bookingDate;

  public static final String SERIALIZED_NAME_CARD_ACCEPTOR_ADDRESS = "cardAcceptorAddress";
  @SerializedName(SERIALIZED_NAME_CARD_ACCEPTOR_ADDRESS)
  private Address cardAcceptorAddress;

  public static final String SERIALIZED_NAME_CARD_ACCEPTOR_ID = "cardAcceptorId";
  @SerializedName(SERIALIZED_NAME_CARD_ACCEPTOR_ID)
  private String cardAcceptorId;

  public static final String SERIALIZED_NAME_CARD_ACCEPTOR_PHONE = "cardAcceptorPhone";
  @SerializedName(SERIALIZED_NAME_CARD_ACCEPTOR_PHONE)
  private String cardAcceptorPhone;

  public static final String SERIALIZED_NAME_CARD_TRANSACTION_ID = "cardTransactionId";
  @SerializedName(SERIALIZED_NAME_CARD_TRANSACTION_ID)
  private String cardTransactionId;

  public static final String SERIALIZED_NAME_CURRENCY_EXCHANGE = "currencyExchange";
  @SerializedName(SERIALIZED_NAME_CURRENCY_EXCHANGE)
  private List<ReportExchangeRate> currencyExchange = new ArrayList<>();

  public static final String SERIALIZED_NAME_INVOICED = "invoiced";
  @SerializedName(SERIALIZED_NAME_INVOICED)
  private Boolean invoiced;

  public static final String SERIALIZED_NAME_MARKUP_FEE = "markupFee";
  @SerializedName(SERIALIZED_NAME_MARKUP_FEE)
  private Amount markupFee;

  public static final String SERIALIZED_NAME_MARKUP_FEE_PERCENTAGE = "markupFeePercentage";
  @SerializedName(SERIALIZED_NAME_MARKUP_FEE_PERCENTAGE)
  private String markupFeePercentage;

  public static final String SERIALIZED_NAME_MASKED_P_A_N = "maskedPAN";
  @SerializedName(SERIALIZED_NAME_MASKED_P_A_N)
  private String maskedPAN;

  public static final String SERIALIZED_NAME_MERCHANT_CATEGORY_CODE = "merchantCategoryCode";
  @SerializedName(SERIALIZED_NAME_MERCHANT_CATEGORY_CODE)
  private String merchantCategoryCode;

  public static final String SERIALIZED_NAME_ORIGINAL_AMOUNT = "originalAmount";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_AMOUNT)
  private Amount originalAmount;

  public static final String SERIALIZED_NAME_PROPRIETARY_BANK_TRANSACTION_CODE = "proprietaryBankTransactionCode";
  @SerializedName(SERIALIZED_NAME_PROPRIETARY_BANK_TRANSACTION_CODE)
  private String proprietaryBankTransactionCode;

  public static final String SERIALIZED_NAME_TERMINAL_ID = "terminalId";
  @SerializedName(SERIALIZED_NAME_TERMINAL_ID)
  private String terminalId;

  public static final String SERIALIZED_NAME_TRANSACTION_AMOUNT = "transactionAmount";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_AMOUNT)
  private Amount transactionAmount;

  public static final String SERIALIZED_NAME_TRANSACTION_DATE = "transactionDate";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_DATE)
  private LocalDate transactionDate;

  public static final String SERIALIZED_NAME_TRANSACTION_DETAILS = "transactionDetails";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_DETAILS)
  private String transactionDetails;

  public CardTransaction() {
  }

  public CardTransaction acceptorTransactionDateTime(OffsetDateTime acceptorTransactionDateTime) {
    this.acceptorTransactionDateTime = acceptorTransactionDateTime;
    return this;
  }

  /**
   * Timestamp of the actual card transaction within the acceptance system
   * @return acceptorTransactionDateTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getAcceptorTransactionDateTime() {
    return acceptorTransactionDateTime;
  }

  public void setAcceptorTransactionDateTime(OffsetDateTime acceptorTransactionDateTime) {
    this.acceptorTransactionDateTime = acceptorTransactionDateTime;
  }


  public CardTransaction bookingDate(LocalDate bookingDate) {
    this.bookingDate = bookingDate;
    return this;
  }

  /**
   * The date when an entry is posted to an account on the ASPSPs books. 
   * @return bookingDate
   */
  @javax.annotation.Nullable
  public LocalDate getBookingDate() {
    return bookingDate;
  }

  public void setBookingDate(LocalDate bookingDate) {
    this.bookingDate = bookingDate;
  }


  public CardTransaction cardAcceptorAddress(Address cardAcceptorAddress) {
    this.cardAcceptorAddress = cardAcceptorAddress;
    return this;
  }

  /**
   * Get cardAcceptorAddress
   * @return cardAcceptorAddress
   */
  @javax.annotation.Nullable
  public Address getCardAcceptorAddress() {
    return cardAcceptorAddress;
  }

  public void setCardAcceptorAddress(Address cardAcceptorAddress) {
    this.cardAcceptorAddress = cardAcceptorAddress;
  }


  public CardTransaction cardAcceptorId(String cardAcceptorId) {
    this.cardAcceptorId = cardAcceptorId;
    return this;
  }

  /**
   * Get cardAcceptorId
   * @return cardAcceptorId
   */
  @javax.annotation.Nullable
  public String getCardAcceptorId() {
    return cardAcceptorId;
  }

  public void setCardAcceptorId(String cardAcceptorId) {
    this.cardAcceptorId = cardAcceptorId;
  }


  public CardTransaction cardAcceptorPhone(String cardAcceptorPhone) {
    this.cardAcceptorPhone = cardAcceptorPhone;
    return this;
  }

  /**
   * Merchant phone number It consists of a \&quot;+\&quot; followed by the country code (from 1 to 3 characters) then a \&quot;-\&quot; and finally, any combination of numbers, \&quot;(\&quot;, \&quot;)\&quot;, \&quot;+\&quot; and \&quot;-\&quot; (up to 30 characters). pattern according to ISO20022 \\+[0-9]{1,3}-[0-9()+\\-]{1,30} 
   * @return cardAcceptorPhone
   */
  @javax.annotation.Nullable
  public String getCardAcceptorPhone() {
    return cardAcceptorPhone;
  }

  public void setCardAcceptorPhone(String cardAcceptorPhone) {
    this.cardAcceptorPhone = cardAcceptorPhone;
  }


  public CardTransaction cardTransactionId(String cardTransactionId) {
    this.cardTransactionId = cardTransactionId;
    return this;
  }

  /**
   * Unique end to end identity.
   * @return cardTransactionId
   */
  @javax.annotation.Nullable
  public String getCardTransactionId() {
    return cardTransactionId;
  }

  public void setCardTransactionId(String cardTransactionId) {
    this.cardTransactionId = cardTransactionId;
  }


  public CardTransaction currencyExchange(List<ReportExchangeRate> currencyExchange) {
    this.currencyExchange = currencyExchange;
    return this;
  }

  public CardTransaction addCurrencyExchangeItem(ReportExchangeRate currencyExchangeItem) {
    if (this.currencyExchange == null) {
      this.currencyExchange = new ArrayList<>();
    }
    this.currencyExchange.add(currencyExchangeItem);
    return this;
  }

  /**
   * Array of exchange rates.
   * @return currencyExchange
   */
  @javax.annotation.Nullable
  public List<ReportExchangeRate> getCurrencyExchange() {
    return currencyExchange;
  }

  public void setCurrencyExchange(List<ReportExchangeRate> currencyExchange) {
    this.currencyExchange = currencyExchange;
  }


  public CardTransaction invoiced(Boolean invoiced) {
    this.invoiced = invoiced;
    return this;
  }

  /**
   * Get invoiced
   * @return invoiced
   */
  @javax.annotation.Nullable
  public Boolean getInvoiced() {
    return invoiced;
  }

  public void setInvoiced(Boolean invoiced) {
    this.invoiced = invoiced;
  }


  public CardTransaction markupFee(Amount markupFee) {
    this.markupFee = markupFee;
    return this;
  }

  /**
   * Get markupFee
   * @return markupFee
   */
  @javax.annotation.Nullable
  public Amount getMarkupFee() {
    return markupFee;
  }

  public void setMarkupFee(Amount markupFee) {
    this.markupFee = markupFee;
  }


  public CardTransaction markupFeePercentage(String markupFeePercentage) {
    this.markupFeePercentage = markupFeePercentage;
    return this;
  }

  /**
   * Get markupFeePercentage
   * @return markupFeePercentage
   */
  @javax.annotation.Nullable
  public String getMarkupFeePercentage() {
    return markupFeePercentage;
  }

  public void setMarkupFeePercentage(String markupFeePercentage) {
    this.markupFeePercentage = markupFeePercentage;
  }


  public CardTransaction maskedPAN(String maskedPAN) {
    this.maskedPAN = maskedPAN;
    return this;
  }

  /**
   * Masked Primary Account Number. 
   * @return maskedPAN
   */
  @javax.annotation.Nullable
  public String getMaskedPAN() {
    return maskedPAN;
  }

  public void setMaskedPAN(String maskedPAN) {
    this.maskedPAN = maskedPAN;
  }


  public CardTransaction merchantCategoryCode(String merchantCategoryCode) {
    this.merchantCategoryCode = merchantCategoryCode;
    return this;
  }

  /**
   * Merchant category code.
   * @return merchantCategoryCode
   */
  @javax.annotation.Nullable
  public String getMerchantCategoryCode() {
    return merchantCategoryCode;
  }

  public void setMerchantCategoryCode(String merchantCategoryCode) {
    this.merchantCategoryCode = merchantCategoryCode;
  }


  public CardTransaction originalAmount(Amount originalAmount) {
    this.originalAmount = originalAmount;
    return this;
  }

  /**
   * Get originalAmount
   * @return originalAmount
   */
  @javax.annotation.Nullable
  public Amount getOriginalAmount() {
    return originalAmount;
  }

  public void setOriginalAmount(Amount originalAmount) {
    this.originalAmount = originalAmount;
  }


  public CardTransaction proprietaryBankTransactionCode(String proprietaryBankTransactionCode) {
    this.proprietaryBankTransactionCode = proprietaryBankTransactionCode;
    return this;
  }

  /**
   * Proprietary bank transaction code as used within a community or within an ASPSP e.g. for MT94x based transaction reports. 
   * @return proprietaryBankTransactionCode
   */
  @javax.annotation.Nullable
  public String getProprietaryBankTransactionCode() {
    return proprietaryBankTransactionCode;
  }

  public void setProprietaryBankTransactionCode(String proprietaryBankTransactionCode) {
    this.proprietaryBankTransactionCode = proprietaryBankTransactionCode;
  }


  public CardTransaction terminalId(String terminalId) {
    this.terminalId = terminalId;
    return this;
  }

  /**
   * Identification of the Terminal, where the card has been used.
   * @return terminalId
   */
  @javax.annotation.Nullable
  public String getTerminalId() {
    return terminalId;
  }

  public void setTerminalId(String terminalId) {
    this.terminalId = terminalId;
  }


  public CardTransaction transactionAmount(Amount transactionAmount) {
    this.transactionAmount = transactionAmount;
    return this;
  }

  /**
   * Get transactionAmount
   * @return transactionAmount
   */
  @javax.annotation.Nonnull
  public Amount getTransactionAmount() {
    return transactionAmount;
  }

  public void setTransactionAmount(Amount transactionAmount) {
    this.transactionAmount = transactionAmount;
  }


  public CardTransaction transactionDate(LocalDate transactionDate) {
    this.transactionDate = transactionDate;
    return this;
  }

  /**
   * Date of the actual card transaction.
   * @return transactionDate
   */
  @javax.annotation.Nullable
  public LocalDate getTransactionDate() {
    return transactionDate;
  }

  public void setTransactionDate(LocalDate transactionDate) {
    this.transactionDate = transactionDate;
  }


  public CardTransaction transactionDetails(String transactionDetails) {
    this.transactionDetails = transactionDetails;
    return this;
  }

  /**
   * Get transactionDetails
   * @return transactionDetails
   */
  @javax.annotation.Nullable
  public String getTransactionDetails() {
    return transactionDetails;
  }

  public void setTransactionDetails(String transactionDetails) {
    this.transactionDetails = transactionDetails;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CardTransaction cardTransaction = (CardTransaction) o;
    return Objects.equals(this.acceptorTransactionDateTime, cardTransaction.acceptorTransactionDateTime) &&
        Objects.equals(this.bookingDate, cardTransaction.bookingDate) &&
        Objects.equals(this.cardAcceptorAddress, cardTransaction.cardAcceptorAddress) &&
        Objects.equals(this.cardAcceptorId, cardTransaction.cardAcceptorId) &&
        Objects.equals(this.cardAcceptorPhone, cardTransaction.cardAcceptorPhone) &&
        Objects.equals(this.cardTransactionId, cardTransaction.cardTransactionId) &&
        Objects.equals(this.currencyExchange, cardTransaction.currencyExchange) &&
        Objects.equals(this.invoiced, cardTransaction.invoiced) &&
        Objects.equals(this.markupFee, cardTransaction.markupFee) &&
        Objects.equals(this.markupFeePercentage, cardTransaction.markupFeePercentage) &&
        Objects.equals(this.maskedPAN, cardTransaction.maskedPAN) &&
        Objects.equals(this.merchantCategoryCode, cardTransaction.merchantCategoryCode) &&
        Objects.equals(this.originalAmount, cardTransaction.originalAmount) &&
        Objects.equals(this.proprietaryBankTransactionCode, cardTransaction.proprietaryBankTransactionCode) &&
        Objects.equals(this.terminalId, cardTransaction.terminalId) &&
        Objects.equals(this.transactionAmount, cardTransaction.transactionAmount) &&
        Objects.equals(this.transactionDate, cardTransaction.transactionDate) &&
        Objects.equals(this.transactionDetails, cardTransaction.transactionDetails);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceptorTransactionDateTime, bookingDate, cardAcceptorAddress, cardAcceptorId, cardAcceptorPhone, cardTransactionId, currencyExchange, invoiced, markupFee, markupFeePercentage, maskedPAN, merchantCategoryCode, originalAmount, proprietaryBankTransactionCode, terminalId, transactionAmount, transactionDate, transactionDetails);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CardTransaction {\n");
    sb.append("    acceptorTransactionDateTime: ").append(toIndentedString(acceptorTransactionDateTime)).append("\n");
    sb.append("    bookingDate: ").append(toIndentedString(bookingDate)).append("\n");
    sb.append("    cardAcceptorAddress: ").append(toIndentedString(cardAcceptorAddress)).append("\n");
    sb.append("    cardAcceptorId: ").append(toIndentedString(cardAcceptorId)).append("\n");
    sb.append("    cardAcceptorPhone: ").append(toIndentedString(cardAcceptorPhone)).append("\n");
    sb.append("    cardTransactionId: ").append(toIndentedString(cardTransactionId)).append("\n");
    sb.append("    currencyExchange: ").append(toIndentedString(currencyExchange)).append("\n");
    sb.append("    invoiced: ").append(toIndentedString(invoiced)).append("\n");
    sb.append("    markupFee: ").append(toIndentedString(markupFee)).append("\n");
    sb.append("    markupFeePercentage: ").append(toIndentedString(markupFeePercentage)).append("\n");
    sb.append("    maskedPAN: ").append(toIndentedString(maskedPAN)).append("\n");
    sb.append("    merchantCategoryCode: ").append(toIndentedString(merchantCategoryCode)).append("\n");
    sb.append("    originalAmount: ").append(toIndentedString(originalAmount)).append("\n");
    sb.append("    proprietaryBankTransactionCode: ").append(toIndentedString(proprietaryBankTransactionCode)).append("\n");
    sb.append("    terminalId: ").append(toIndentedString(terminalId)).append("\n");
    sb.append("    transactionAmount: ").append(toIndentedString(transactionAmount)).append("\n");
    sb.append("    transactionDate: ").append(toIndentedString(transactionDate)).append("\n");
    sb.append("    transactionDetails: ").append(toIndentedString(transactionDetails)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acceptorTransactionDateTime");
    openapiFields.add("bookingDate");
    openapiFields.add("cardAcceptorAddress");
    openapiFields.add("cardAcceptorId");
    openapiFields.add("cardAcceptorPhone");
    openapiFields.add("cardTransactionId");
    openapiFields.add("currencyExchange");
    openapiFields.add("invoiced");
    openapiFields.add("markupFee");
    openapiFields.add("markupFeePercentage");
    openapiFields.add("maskedPAN");
    openapiFields.add("merchantCategoryCode");
    openapiFields.add("originalAmount");
    openapiFields.add("proprietaryBankTransactionCode");
    openapiFields.add("terminalId");
    openapiFields.add("transactionAmount");
    openapiFields.add("transactionDate");
    openapiFields.add("transactionDetails");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("transactionAmount");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CardTransaction
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CardTransaction.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CardTransaction is not found in the empty JSON string", CardTransaction.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CardTransaction.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CardTransaction` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CardTransaction.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `cardAcceptorAddress`
      if (jsonObj.get("cardAcceptorAddress") != null && !jsonObj.get("cardAcceptorAddress").isJsonNull()) {
        Address.validateJsonElement(jsonObj.get("cardAcceptorAddress"));
      }
      if ((jsonObj.get("cardAcceptorId") != null && !jsonObj.get("cardAcceptorId").isJsonNull()) && !jsonObj.get("cardAcceptorId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cardAcceptorId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cardAcceptorId").toString()));
      }
      if ((jsonObj.get("cardAcceptorPhone") != null && !jsonObj.get("cardAcceptorPhone").isJsonNull()) && !jsonObj.get("cardAcceptorPhone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cardAcceptorPhone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cardAcceptorPhone").toString()));
      }
      if ((jsonObj.get("cardTransactionId") != null && !jsonObj.get("cardTransactionId").isJsonNull()) && !jsonObj.get("cardTransactionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cardTransactionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cardTransactionId").toString()));
      }
      if (jsonObj.get("currencyExchange") != null && !jsonObj.get("currencyExchange").isJsonNull()) {
        JsonArray jsonArraycurrencyExchange = jsonObj.getAsJsonArray("currencyExchange");
        if (jsonArraycurrencyExchange != null) {
          // ensure the json data is an array
          if (!jsonObj.get("currencyExchange").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `currencyExchange` to be an array in the JSON string but got `%s`", jsonObj.get("currencyExchange").toString()));
          }

          // validate the optional field `currencyExchange` (array)
          for (int i = 0; i < jsonArraycurrencyExchange.size(); i++) {
            ReportExchangeRate.validateJsonElement(jsonArraycurrencyExchange.get(i));
          };
        }
      }
      // validate the optional field `markupFee`
      if (jsonObj.get("markupFee") != null && !jsonObj.get("markupFee").isJsonNull()) {
        Amount.validateJsonElement(jsonObj.get("markupFee"));
      }
      if ((jsonObj.get("markupFeePercentage") != null && !jsonObj.get("markupFeePercentage").isJsonNull()) && !jsonObj.get("markupFeePercentage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `markupFeePercentage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("markupFeePercentage").toString()));
      }
      if ((jsonObj.get("maskedPAN") != null && !jsonObj.get("maskedPAN").isJsonNull()) && !jsonObj.get("maskedPAN").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maskedPAN` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maskedPAN").toString()));
      }
      if ((jsonObj.get("merchantCategoryCode") != null && !jsonObj.get("merchantCategoryCode").isJsonNull()) && !jsonObj.get("merchantCategoryCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `merchantCategoryCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("merchantCategoryCode").toString()));
      }
      // validate the optional field `originalAmount`
      if (jsonObj.get("originalAmount") != null && !jsonObj.get("originalAmount").isJsonNull()) {
        Amount.validateJsonElement(jsonObj.get("originalAmount"));
      }
      if ((jsonObj.get("proprietaryBankTransactionCode") != null && !jsonObj.get("proprietaryBankTransactionCode").isJsonNull()) && !jsonObj.get("proprietaryBankTransactionCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `proprietaryBankTransactionCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("proprietaryBankTransactionCode").toString()));
      }
      if ((jsonObj.get("terminalId") != null && !jsonObj.get("terminalId").isJsonNull()) && !jsonObj.get("terminalId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `terminalId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("terminalId").toString()));
      }
      // validate the required field `transactionAmount`
      Amount.validateJsonElement(jsonObj.get("transactionAmount"));
      if ((jsonObj.get("transactionDetails") != null && !jsonObj.get("transactionDetails").isJsonNull()) && !jsonObj.get("transactionDetails").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionDetails` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionDetails").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CardTransaction.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CardTransaction' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CardTransaction> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CardTransaction.class));

       return (TypeAdapter<T>) new TypeAdapter<CardTransaction>() {
           @Override
           public void write(JsonWriter out, CardTransaction value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CardTransaction read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CardTransaction given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CardTransaction
   * @throws IOException if the JSON string is invalid with respect to CardTransaction
   */
  public static CardTransaction fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CardTransaction.class);
  }

  /**
   * Convert an instance of CardTransaction to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

