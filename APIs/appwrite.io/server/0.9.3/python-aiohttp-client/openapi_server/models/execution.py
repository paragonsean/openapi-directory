# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class Execution(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, id: str=None, date_created: int=None, exit_code: int=None, function_id: str=None, status: str=None, stderr: str=None, stdout: str=None, time: float=None, trigger: str=None):
        """Execution - a model defined in OpenAPI

        :param id: The id of this Execution.
        :param date_created: The date_created of this Execution.
        :param exit_code: The exit_code of this Execution.
        :param function_id: The function_id of this Execution.
        :param status: The status of this Execution.
        :param stderr: The stderr of this Execution.
        :param stdout: The stdout of this Execution.
        :param time: The time of this Execution.
        :param trigger: The trigger of this Execution.
        """
        self.openapi_types = {
            'id': str,
            'date_created': int,
            'exit_code': int,
            'function_id': str,
            'status': str,
            'stderr': str,
            'stdout': str,
            'time': float,
            'trigger': str
        }

        self.attribute_map = {
            'id': '$id',
            'date_created': 'dateCreated',
            'exit_code': 'exitCode',
            'function_id': 'functionId',
            'status': 'status',
            'stderr': 'stderr',
            'stdout': 'stdout',
            'time': 'time',
            'trigger': 'trigger'
        }

        self._id = id
        self._date_created = date_created
        self._exit_code = exit_code
        self._function_id = function_id
        self._status = status
        self._stderr = stderr
        self._stdout = stdout
        self._time = time
        self._trigger = trigger

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Execution':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The execution of this Execution.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def id(self):
        """Gets the id of this Execution.

        Execution ID.

        :return: The id of this Execution.
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this Execution.

        Execution ID.

        :param id: The id of this Execution.
        :type id: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")

        self._id = id

    @property
    def date_created(self):
        """Gets the date_created of this Execution.

        The execution creation date in Unix timestamp.

        :return: The date_created of this Execution.
        :rtype: int
        """
        return self._date_created

    @date_created.setter
    def date_created(self, date_created):
        """Sets the date_created of this Execution.

        The execution creation date in Unix timestamp.

        :param date_created: The date_created of this Execution.
        :type date_created: int
        """
        if date_created is None:
            raise ValueError("Invalid value for `date_created`, must not be `None`")

        self._date_created = date_created

    @property
    def exit_code(self):
        """Gets the exit_code of this Execution.

        The script exit code.

        :return: The exit_code of this Execution.
        :rtype: int
        """
        return self._exit_code

    @exit_code.setter
    def exit_code(self, exit_code):
        """Sets the exit_code of this Execution.

        The script exit code.

        :param exit_code: The exit_code of this Execution.
        :type exit_code: int
        """
        if exit_code is None:
            raise ValueError("Invalid value for `exit_code`, must not be `None`")

        self._exit_code = exit_code

    @property
    def function_id(self):
        """Gets the function_id of this Execution.

        Function ID.

        :return: The function_id of this Execution.
        :rtype: str
        """
        return self._function_id

    @function_id.setter
    def function_id(self, function_id):
        """Sets the function_id of this Execution.

        Function ID.

        :param function_id: The function_id of this Execution.
        :type function_id: str
        """
        if function_id is None:
            raise ValueError("Invalid value for `function_id`, must not be `None`")

        self._function_id = function_id

    @property
    def status(self):
        """Gets the status of this Execution.

        The status of the function execution. Possible values can be: `waiting`, `processing`, `completed`, or `failed`.

        :return: The status of this Execution.
        :rtype: str
        """
        return self._status

    @status.setter
    def status(self, status):
        """Sets the status of this Execution.

        The status of the function execution. Possible values can be: `waiting`, `processing`, `completed`, or `failed`.

        :param status: The status of this Execution.
        :type status: str
        """
        if status is None:
            raise ValueError("Invalid value for `status`, must not be `None`")

        self._status = status

    @property
    def stderr(self):
        """Gets the stderr of this Execution.

        The script stderr output string. Logs the last 4,000 characters of the execution stderr output

        :return: The stderr of this Execution.
        :rtype: str
        """
        return self._stderr

    @stderr.setter
    def stderr(self, stderr):
        """Sets the stderr of this Execution.

        The script stderr output string. Logs the last 4,000 characters of the execution stderr output

        :param stderr: The stderr of this Execution.
        :type stderr: str
        """
        if stderr is None:
            raise ValueError("Invalid value for `stderr`, must not be `None`")

        self._stderr = stderr

    @property
    def stdout(self):
        """Gets the stdout of this Execution.

        The script stdout output string. Logs the last 4,000 characters of the execution stdout output.

        :return: The stdout of this Execution.
        :rtype: str
        """
        return self._stdout

    @stdout.setter
    def stdout(self, stdout):
        """Sets the stdout of this Execution.

        The script stdout output string. Logs the last 4,000 characters of the execution stdout output.

        :param stdout: The stdout of this Execution.
        :type stdout: str
        """
        if stdout is None:
            raise ValueError("Invalid value for `stdout`, must not be `None`")

        self._stdout = stdout

    @property
    def time(self):
        """Gets the time of this Execution.

        The script execution time in seconds.

        :return: The time of this Execution.
        :rtype: float
        """
        return self._time

    @time.setter
    def time(self, time):
        """Sets the time of this Execution.

        The script execution time in seconds.

        :param time: The time of this Execution.
        :type time: float
        """
        if time is None:
            raise ValueError("Invalid value for `time`, must not be `None`")

        self._time = time

    @property
    def trigger(self):
        """Gets the trigger of this Execution.

        The trigger that caused the function to execute. Possible values can be: `http`, `schedule`, or `event`.

        :return: The trigger of this Execution.
        :rtype: str
        """
        return self._trigger

    @trigger.setter
    def trigger(self, trigger):
        """Sets the trigger of this Execution.

        The trigger that caused the function to execute. Possible values can be: `http`, `schedule`, or `event`.

        :param trigger: The trigger of this Execution.
        :type trigger: str
        """
        if trigger is None:
            raise ValueError("Invalid value for `trigger`, must not be `None`")

        self._trigger = trigger
