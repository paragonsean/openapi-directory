/*
 * Shotstack
 * Shotstack is a video, image and audio editing service that allows for the automated generation of videos, images and audio using JSON and a RESTful API.  You arrange and configure an edit and POST it to the API which will render your media and provide a file  location when complete.  For more details visit [shotstack.io](https://shotstack.io) or checkout our [getting started](https://shotstack.gitbook.io/docs/guides/getting-started) documentation. There are two main API's, one for editing and generating assets (Edit API) and one for managing hosted assets (Serve API).  The Edit API base URL is: <b>https://api.shotstack.io/{version}</b>  The Serve API base URL is: <b>https://api.shotstack.io/serve/{version}</b>
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Font;
import org.openapitools.client.model.Soundtrack;
import org.openapitools.client.model.Track;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A timeline represents the contents of a video edit over time, an audio edit over time, in seconds, or an image layout. A timeline consists of layers called tracks. Tracks are composed of titles, images, audio, html or video segments referred to as clips which are placed along the track at specific starting point and lasting for a specific amount of time.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:32:51.122157-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Timeline {
  public static final String SERIALIZED_NAME_BACKGROUND = "background";
  @SerializedName(SERIALIZED_NAME_BACKGROUND)
  private String background = "#000000";

  public static final String SERIALIZED_NAME_CACHE = "cache";
  @SerializedName(SERIALIZED_NAME_CACHE)
  private Boolean cache = true;

  public static final String SERIALIZED_NAME_FONTS = "fonts";
  @SerializedName(SERIALIZED_NAME_FONTS)
  private List<Font> fonts = new ArrayList<>();

  public static final String SERIALIZED_NAME_SOUNDTRACK = "soundtrack";
  @SerializedName(SERIALIZED_NAME_SOUNDTRACK)
  private Soundtrack soundtrack;

  public static final String SERIALIZED_NAME_TRACKS = "tracks";
  @SerializedName(SERIALIZED_NAME_TRACKS)
  private List<Track> tracks = new ArrayList<>();

  public Timeline() {
  }

  public Timeline background(String background) {
    this.background = background;
    return this;
  }

  /**
   * A hexadecimal value for the timeline background colour. Defaults to #000000 (black).
   * @return background
   */
  @javax.annotation.Nullable
  public String getBackground() {
    return background;
  }

  public void setBackground(String background) {
    this.background = background;
  }


  public Timeline cache(Boolean cache) {
    this.cache = cache;
    return this;
  }

  /**
   * Disable the caching of ingested source footage and assets. See  [caching](https://shotstack.gitbook.io/docs/guides/architecting-an-application/caching) for more details.
   * @return cache
   */
  @javax.annotation.Nullable
  public Boolean getCache() {
    return cache;
  }

  public void setCache(Boolean cache) {
    this.cache = cache;
  }


  public Timeline fonts(List<Font> fonts) {
    this.fonts = fonts;
    return this;
  }

  public Timeline addFontsItem(Font fontsItem) {
    if (this.fonts == null) {
      this.fonts = new ArrayList<>();
    }
    this.fonts.add(fontsItem);
    return this;
  }

  /**
   * An array of custom fonts to be downloaded for use by the HTML assets.
   * @return fonts
   */
  @javax.annotation.Nullable
  public List<Font> getFonts() {
    return fonts;
  }

  public void setFonts(List<Font> fonts) {
    this.fonts = fonts;
  }


  public Timeline soundtrack(Soundtrack soundtrack) {
    this.soundtrack = soundtrack;
    return this;
  }

  /**
   * Get soundtrack
   * @return soundtrack
   */
  @javax.annotation.Nullable
  public Soundtrack getSoundtrack() {
    return soundtrack;
  }

  public void setSoundtrack(Soundtrack soundtrack) {
    this.soundtrack = soundtrack;
  }


  public Timeline tracks(List<Track> tracks) {
    this.tracks = tracks;
    return this;
  }

  public Timeline addTracksItem(Track tracksItem) {
    if (this.tracks == null) {
      this.tracks = new ArrayList<>();
    }
    this.tracks.add(tracksItem);
    return this;
  }

  /**
   * A timeline consists of an array of tracks, each track containing clips. Tracks are layered on top of each other in the same order they are added to the array with the top most track layered over the top of those below it. Ensure that a track containing titles is the top most track so that it is displayed above videos and images.
   * @return tracks
   */
  @javax.annotation.Nonnull
  public List<Track> getTracks() {
    return tracks;
  }

  public void setTracks(List<Track> tracks) {
    this.tracks = tracks;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Timeline timeline = (Timeline) o;
    return Objects.equals(this.background, timeline.background) &&
        Objects.equals(this.cache, timeline.cache) &&
        Objects.equals(this.fonts, timeline.fonts) &&
        Objects.equals(this.soundtrack, timeline.soundtrack) &&
        Objects.equals(this.tracks, timeline.tracks);
  }

  @Override
  public int hashCode() {
    return Objects.hash(background, cache, fonts, soundtrack, tracks);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Timeline {\n");
    sb.append("    background: ").append(toIndentedString(background)).append("\n");
    sb.append("    cache: ").append(toIndentedString(cache)).append("\n");
    sb.append("    fonts: ").append(toIndentedString(fonts)).append("\n");
    sb.append("    soundtrack: ").append(toIndentedString(soundtrack)).append("\n");
    sb.append("    tracks: ").append(toIndentedString(tracks)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("background");
    openapiFields.add("cache");
    openapiFields.add("fonts");
    openapiFields.add("soundtrack");
    openapiFields.add("tracks");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("tracks");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Timeline
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Timeline.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Timeline is not found in the empty JSON string", Timeline.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Timeline.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Timeline` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Timeline.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("background") != null && !jsonObj.get("background").isJsonNull()) && !jsonObj.get("background").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `background` to be a primitive type in the JSON string but got `%s`", jsonObj.get("background").toString()));
      }
      if (jsonObj.get("fonts") != null && !jsonObj.get("fonts").isJsonNull()) {
        JsonArray jsonArrayfonts = jsonObj.getAsJsonArray("fonts");
        if (jsonArrayfonts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("fonts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `fonts` to be an array in the JSON string but got `%s`", jsonObj.get("fonts").toString()));
          }

          // validate the optional field `fonts` (array)
          for (int i = 0; i < jsonArrayfonts.size(); i++) {
            Font.validateJsonElement(jsonArrayfonts.get(i));
          };
        }
      }
      // validate the optional field `soundtrack`
      if (jsonObj.get("soundtrack") != null && !jsonObj.get("soundtrack").isJsonNull()) {
        Soundtrack.validateJsonElement(jsonObj.get("soundtrack"));
      }
      // ensure the json data is an array
      if (!jsonObj.get("tracks").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tracks` to be an array in the JSON string but got `%s`", jsonObj.get("tracks").toString()));
      }

      JsonArray jsonArraytracks = jsonObj.getAsJsonArray("tracks");
      // validate the required field `tracks` (array)
      for (int i = 0; i < jsonArraytracks.size(); i++) {
        Track.validateJsonElement(jsonArraytracks.get(i));
      };
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Timeline.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Timeline' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Timeline> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Timeline.class));

       return (TypeAdapter<T>) new TypeAdapter<Timeline>() {
           @Override
           public void write(JsonWriter out, Timeline value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Timeline read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Timeline given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Timeline
   * @throws IOException if the JSON string is invalid with respect to Timeline
   */
  public static Timeline fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Timeline.class);
  }

  /**
   * Convert an instance of Timeline to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

