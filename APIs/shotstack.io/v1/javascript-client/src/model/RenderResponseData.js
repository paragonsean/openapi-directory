/**
 * Shotstack
 * Shotstack is a video, image and audio editing service that allows for the automated generation of videos, images and audio using JSON and a RESTful API.  You arrange and configure an edit and POST it to the API which will render your media and provide a file  location when complete.  For more details visit [shotstack.io](https://shotstack.io) or checkout our [getting started](https://shotstack.gitbook.io/docs/guides/getting-started) documentation. There are two main API's, one for editing and generating assets (Edit API) and one for managing hosted assets (Serve API).  The Edit API base URL is: <b>https://api.shotstack.io/{version}</b>  The Serve API base URL is: <b>https://api.shotstack.io/serve/{version}</b>
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Edit from './Edit';

/**
 * The RenderResponseData model module.
 * @module model/RenderResponseData
 * @version v1
 */
class RenderResponseData {
    /**
     * Constructs a new <code>RenderResponseData</code>.
     * The response data returned with the [RenderResponse](#tocs_renderresponse) including status and URL.
     * @alias module:model/RenderResponseData
     * @param created {String} The time the render task was initially queued.
     * @param data {module:model/Edit} 
     * @param id {String} The id of the render task in UUID format.
     * @param owner {String} The owner id of the render task.
     * @param status {module:model/RenderResponseData.StatusEnum} The status of the render task. <ul>   <li>`queued` - render is queued waiting to be rendered</li>   <li>`fetching` - assets are being fetched</li>   <li>`rendering` - the asset is being rendered</li>   <li>`saving` - the final asset is being saved to storage</li>   <li>`done` - the asset is ready to be downloaded</li>   <li>`failed` - there was an error rendering the asset</li> </ul>
     * @param updated {String} The time the render status was last updated.
     */
    constructor(created, data, id, owner, status, updated) { 
        
        RenderResponseData.initialize(this, created, data, id, owner, status, updated);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, created, data, id, owner, status, updated) { 
        obj['created'] = created;
        obj['data'] = data;
        obj['id'] = id;
        obj['owner'] = owner;
        obj['status'] = status;
        obj['updated'] = updated;
    }

    /**
     * Constructs a <code>RenderResponseData</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/RenderResponseData} obj Optional instance to populate.
     * @return {module:model/RenderResponseData} The populated <code>RenderResponseData</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new RenderResponseData();

            if (data.hasOwnProperty('created')) {
                obj['created'] = ApiClient.convertToType(data['created'], 'String');
            }
            if (data.hasOwnProperty('data')) {
                obj['data'] = Edit.constructFromObject(data['data']);
            }
            if (data.hasOwnProperty('duration')) {
                obj['duration'] = ApiClient.convertToType(data['duration'], 'Number');
            }
            if (data.hasOwnProperty('error')) {
                obj['error'] = ApiClient.convertToType(data['error'], 'String');
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('owner')) {
                obj['owner'] = ApiClient.convertToType(data['owner'], 'String');
            }
            if (data.hasOwnProperty('plan')) {
                obj['plan'] = ApiClient.convertToType(data['plan'], 'String');
            }
            if (data.hasOwnProperty('poster')) {
                obj['poster'] = ApiClient.convertToType(data['poster'], 'String');
            }
            if (data.hasOwnProperty('renderTime')) {
                obj['renderTime'] = ApiClient.convertToType(data['renderTime'], 'Number');
            }
            if (data.hasOwnProperty('status')) {
                obj['status'] = ApiClient.convertToType(data['status'], 'String');
            }
            if (data.hasOwnProperty('thumbnail')) {
                obj['thumbnail'] = ApiClient.convertToType(data['thumbnail'], 'String');
            }
            if (data.hasOwnProperty('updated')) {
                obj['updated'] = ApiClient.convertToType(data['updated'], 'String');
            }
            if (data.hasOwnProperty('url')) {
                obj['url'] = ApiClient.convertToType(data['url'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>RenderResponseData</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>RenderResponseData</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of RenderResponseData.RequiredProperties) {
            if (!data.hasOwnProperty(property)) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['created'] && !(typeof data['created'] === 'string' || data['created'] instanceof String)) {
            throw new Error("Expected the field `created` to be a primitive type in the JSON string but got " + data['created']);
        }
        // validate the optional field `data`
        if (data['data']) { // data not null
          Edit.validateJSON(data['data']);
        }
        // ensure the json data is a string
        if (data['error'] && !(typeof data['error'] === 'string' || data['error'] instanceof String)) {
            throw new Error("Expected the field `error` to be a primitive type in the JSON string but got " + data['error']);
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // ensure the json data is a string
        if (data['owner'] && !(typeof data['owner'] === 'string' || data['owner'] instanceof String)) {
            throw new Error("Expected the field `owner` to be a primitive type in the JSON string but got " + data['owner']);
        }
        // ensure the json data is a string
        if (data['plan'] && !(typeof data['plan'] === 'string' || data['plan'] instanceof String)) {
            throw new Error("Expected the field `plan` to be a primitive type in the JSON string but got " + data['plan']);
        }
        // ensure the json data is a string
        if (data['poster'] && !(typeof data['poster'] === 'string' || data['poster'] instanceof String)) {
            throw new Error("Expected the field `poster` to be a primitive type in the JSON string but got " + data['poster']);
        }
        // ensure the json data is a string
        if (data['status'] && !(typeof data['status'] === 'string' || data['status'] instanceof String)) {
            throw new Error("Expected the field `status` to be a primitive type in the JSON string but got " + data['status']);
        }
        // ensure the json data is a string
        if (data['thumbnail'] && !(typeof data['thumbnail'] === 'string' || data['thumbnail'] instanceof String)) {
            throw new Error("Expected the field `thumbnail` to be a primitive type in the JSON string but got " + data['thumbnail']);
        }
        // ensure the json data is a string
        if (data['updated'] && !(typeof data['updated'] === 'string' || data['updated'] instanceof String)) {
            throw new Error("Expected the field `updated` to be a primitive type in the JSON string but got " + data['updated']);
        }
        // ensure the json data is a string
        if (data['url'] && !(typeof data['url'] === 'string' || data['url'] instanceof String)) {
            throw new Error("Expected the field `url` to be a primitive type in the JSON string but got " + data['url']);
        }

        return true;
    }


}

RenderResponseData.RequiredProperties = ["created", "data", "id", "owner", "status", "updated"];

/**
 * The time the render task was initially queued.
 * @member {String} created
 */
RenderResponseData.prototype['created'] = undefined;

/**
 * @member {module:model/Edit} data
 */
RenderResponseData.prototype['data'] = undefined;

/**
 * The output video or audio length in seconds.
 * @member {Number} duration
 */
RenderResponseData.prototype['duration'] = undefined;

/**
 * An error message, only displayed if an error occurred.
 * @member {String} error
 */
RenderResponseData.prototype['error'] = undefined;

/**
 * The id of the render task in UUID format.
 * @member {String} id
 */
RenderResponseData.prototype['id'] = undefined;

/**
 * The owner id of the render task.
 * @member {String} owner
 */
RenderResponseData.prototype['owner'] = undefined;

/**
 * The customer subscription plan.
 * @member {String} plan
 */
RenderResponseData.prototype['plan'] = undefined;

/**
 * The URL of the poster image if requested. This will only be available if status is done.
 * @member {String} poster
 */
RenderResponseData.prototype['poster'] = undefined;

/**
 * The time taken to render the asset in milliseconds.
 * @member {Number} renderTime
 */
RenderResponseData.prototype['renderTime'] = undefined;

/**
 * The status of the render task. <ul>   <li>`queued` - render is queued waiting to be rendered</li>   <li>`fetching` - assets are being fetched</li>   <li>`rendering` - the asset is being rendered</li>   <li>`saving` - the final asset is being saved to storage</li>   <li>`done` - the asset is ready to be downloaded</li>   <li>`failed` - there was an error rendering the asset</li> </ul>
 * @member {module:model/RenderResponseData.StatusEnum} status
 */
RenderResponseData.prototype['status'] = undefined;

/**
 * The URL of the thumbnail image if requested. This will only be available if status is done.
 * @member {String} thumbnail
 */
RenderResponseData.prototype['thumbnail'] = undefined;

/**
 * The time the render status was last updated.
 * @member {String} updated
 */
RenderResponseData.prototype['updated'] = undefined;

/**
 * The URL of the final asset. This will only be available if status is done. This is a temporary URL and will be deleted after 24 hours. By default all assets are copied to the Shotstack hosting and CDN destination.
 * @member {String} url
 */
RenderResponseData.prototype['url'] = undefined;





/**
 * Allowed values for the <code>status</code> property.
 * @enum {String}
 * @readonly
 */
RenderResponseData['StatusEnum'] = {

    /**
     * value: "queued"
     * @const
     */
    "queued": "queued",

    /**
     * value: "fetching"
     * @const
     */
    "fetching": "fetching",

    /**
     * value: "rendering"
     * @const
     */
    "rendering": "rendering",

    /**
     * value: "saving"
     * @const
     */
    "saving": "saving",

    /**
     * value: "done"
     * @const
     */
    "done": "done",

    /**
     * value: "failed"
     * @const
     */
    "failed": "failed"
};



export default RenderResponseData;

