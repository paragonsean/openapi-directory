/**
 * Data2CRM.API
 * <p>Make use of our in-depth documentation to get more information about the various functions of the service. Those willing to explore the mechanics of Data2CRM.API can test it in live regime using the short code samples.</p><p>Select CRM: <span id=\"docs-select-crm\" style=\"font-weight: bold\">Loading... please wait</span></p><p>Here are the API access keys:<br><b>X-API2CRM-USER-KEY</b>: <span id=\"docs-user-key\">e2a6379ab878ae7e58119d4ec842bf9c</span><br><b>X-API2CRM-APPLICATION-KEY</b>: <span id=\"docs-crm-key\">7ae5b17008fb414d84981191cf3b66a476ef8bef</span></p><p id=\"docs-crm-access\">The CRM access details are:<br><b>URL</b>: <a id=\"docs-crm-url\" href=\"https://login.salesforce.com/\" target=\"_blank\">https://login.salesforce.com/</a><br><b>E-mail / Username</b>: <span id=\"docs-crm-username\">developers.data2crm.api+1@magneticone.com</span><br><b>Password</b>: <span id=\"docs-crm-password\">data2crmapi123</span></p>
 *
 * The version of the OpenAPI document: 1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIEntityEntity.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIEntityEntity::OAIEntityEntity(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIEntityEntity::OAIEntityEntity() {
    this->initializeModel();
}

OAIEntityEntity::~OAIEntityEntity() {}

void OAIEntityEntity::initializeModel() {

    m_category_isSet = false;
    m_category_isValid = false;

    m_collection_isSet = false;
    m_collection_isValid = false;

    m_custom_field_isSet = false;
    m_custom_field_isValid = false;

    m_data_cache_isSet = false;
    m_data_cache_isValid = false;

    m_entity_isSet = false;
    m_entity_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_internal_type_isSet = false;
    m_internal_type_isValid = false;

    m_limit_isSet = false;
    m_limit_isValid = false;

    m_methods_isSet = false;
    m_methods_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_similar_to_isSet = false;
    m_similar_to_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;
}

void OAIEntityEntity::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIEntityEntity::fromJsonObject(QJsonObject json) {

    m_category_isValid = ::OpenAPI::fromJsonValue(m_category, json[QString("category")]);
    m_category_isSet = !json[QString("category")].isNull() && m_category_isValid;

    m_collection_isValid = ::OpenAPI::fromJsonValue(m_collection, json[QString("collection")]);
    m_collection_isSet = !json[QString("collection")].isNull() && m_collection_isValid;

    m_custom_field_isValid = ::OpenAPI::fromJsonValue(m_custom_field, json[QString("customField")]);
    m_custom_field_isSet = !json[QString("customField")].isNull() && m_custom_field_isValid;

    m_data_cache_isValid = ::OpenAPI::fromJsonValue(m_data_cache, json[QString("dataCache")]);
    m_data_cache_isSet = !json[QString("dataCache")].isNull() && m_data_cache_isValid;

    m_entity_isValid = ::OpenAPI::fromJsonValue(m_entity, json[QString("entity")]);
    m_entity_isSet = !json[QString("entity")].isNull() && m_entity_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_internal_type_isValid = ::OpenAPI::fromJsonValue(m_internal_type, json[QString("internalType")]);
    m_internal_type_isSet = !json[QString("internalType")].isNull() && m_internal_type_isValid;

    m_limit_isValid = ::OpenAPI::fromJsonValue(m_limit, json[QString("limit")]);
    m_limit_isSet = !json[QString("limit")].isNull() && m_limit_isValid;

    m_methods_isValid = ::OpenAPI::fromJsonValue(m_methods, json[QString("methods")]);
    m_methods_isSet = !json[QString("methods")].isNull() && m_methods_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_similar_to_isValid = ::OpenAPI::fromJsonValue(m_similar_to, json[QString("similarTo")]);
    m_similar_to_isSet = !json[QString("similarTo")].isNull() && m_similar_to_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;
}

QString OAIEntityEntity::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIEntityEntity::asJsonObject() const {
    QJsonObject obj;
    if (m_category_isSet) {
        obj.insert(QString("category"), ::OpenAPI::toJsonValue(m_category));
    }
    if (m_collection_isSet) {
        obj.insert(QString("collection"), ::OpenAPI::toJsonValue(m_collection));
    }
    if (m_custom_field_isSet) {
        obj.insert(QString("customField"), ::OpenAPI::toJsonValue(m_custom_field));
    }
    if (m_data_cache_isSet) {
        obj.insert(QString("dataCache"), ::OpenAPI::toJsonValue(m_data_cache));
    }
    if (m_entity_isSet) {
        obj.insert(QString("entity"), ::OpenAPI::toJsonValue(m_entity));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_internal_type_isSet) {
        obj.insert(QString("internalType"), ::OpenAPI::toJsonValue(m_internal_type));
    }
    if (m_limit_isSet) {
        obj.insert(QString("limit"), ::OpenAPI::toJsonValue(m_limit));
    }
    if (m_methods_isSet) {
        obj.insert(QString("methods"), ::OpenAPI::toJsonValue(m_methods));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_similar_to.size() > 0) {
        obj.insert(QString("similarTo"), ::OpenAPI::toJsonValue(m_similar_to));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    return obj;
}

QString OAIEntityEntity::getCategory() const {
    return m_category;
}
void OAIEntityEntity::setCategory(const QString &category) {
    m_category = category;
    m_category_isSet = true;
}

bool OAIEntityEntity::is_category_Set() const{
    return m_category_isSet;
}

bool OAIEntityEntity::is_category_Valid() const{
    return m_category_isValid;
}

QString OAIEntityEntity::getCollection() const {
    return m_collection;
}
void OAIEntityEntity::setCollection(const QString &collection) {
    m_collection = collection;
    m_collection_isSet = true;
}

bool OAIEntityEntity::is_collection_Set() const{
    return m_collection_isSet;
}

bool OAIEntityEntity::is_collection_Valid() const{
    return m_collection_isValid;
}

OAIObject OAIEntityEntity::getCustomField() const {
    return m_custom_field;
}
void OAIEntityEntity::setCustomField(const OAIObject &custom_field) {
    m_custom_field = custom_field;
    m_custom_field_isSet = true;
}

bool OAIEntityEntity::is_custom_field_Set() const{
    return m_custom_field_isSet;
}

bool OAIEntityEntity::is_custom_field_Valid() const{
    return m_custom_field_isValid;
}

OAIObject OAIEntityEntity::getDataCache() const {
    return m_data_cache;
}
void OAIEntityEntity::setDataCache(const OAIObject &data_cache) {
    m_data_cache = data_cache;
    m_data_cache_isSet = true;
}

bool OAIEntityEntity::is_data_cache_Set() const{
    return m_data_cache_isSet;
}

bool OAIEntityEntity::is_data_cache_Valid() const{
    return m_data_cache_isValid;
}

QString OAIEntityEntity::getEntity() const {
    return m_entity;
}
void OAIEntityEntity::setEntity(const QString &entity) {
    m_entity = entity;
    m_entity_isSet = true;
}

bool OAIEntityEntity::is_entity_Set() const{
    return m_entity_isSet;
}

bool OAIEntityEntity::is_entity_Valid() const{
    return m_entity_isValid;
}

QString OAIEntityEntity::getId() const {
    return m_id;
}
void OAIEntityEntity::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIEntityEntity::is_id_Set() const{
    return m_id_isSet;
}

bool OAIEntityEntity::is_id_Valid() const{
    return m_id_isValid;
}

QString OAIEntityEntity::getInternalType() const {
    return m_internal_type;
}
void OAIEntityEntity::setInternalType(const QString &internal_type) {
    m_internal_type = internal_type;
    m_internal_type_isSet = true;
}

bool OAIEntityEntity::is_internal_type_Set() const{
    return m_internal_type_isSet;
}

bool OAIEntityEntity::is_internal_type_Valid() const{
    return m_internal_type_isValid;
}

qint32 OAIEntityEntity::getLimit() const {
    return m_limit;
}
void OAIEntityEntity::setLimit(const qint32 &limit) {
    m_limit = limit;
    m_limit_isSet = true;
}

bool OAIEntityEntity::is_limit_Set() const{
    return m_limit_isSet;
}

bool OAIEntityEntity::is_limit_Valid() const{
    return m_limit_isValid;
}

OAIObject OAIEntityEntity::getMethods() const {
    return m_methods;
}
void OAIEntityEntity::setMethods(const OAIObject &methods) {
    m_methods = methods;
    m_methods_isSet = true;
}

bool OAIEntityEntity::is_methods_Set() const{
    return m_methods_isSet;
}

bool OAIEntityEntity::is_methods_Valid() const{
    return m_methods_isValid;
}

QString OAIEntityEntity::getName() const {
    return m_name;
}
void OAIEntityEntity::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIEntityEntity::is_name_Set() const{
    return m_name_isSet;
}

bool OAIEntityEntity::is_name_Valid() const{
    return m_name_isValid;
}

QList<QString> OAIEntityEntity::getSimilarTo() const {
    return m_similar_to;
}
void OAIEntityEntity::setSimilarTo(const QList<QString> &similar_to) {
    m_similar_to = similar_to;
    m_similar_to_isSet = true;
}

bool OAIEntityEntity::is_similar_to_Set() const{
    return m_similar_to_isSet;
}

bool OAIEntityEntity::is_similar_to_Valid() const{
    return m_similar_to_isValid;
}

QString OAIEntityEntity::getType() const {
    return m_type;
}
void OAIEntityEntity::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIEntityEntity::is_type_Set() const{
    return m_type_isSet;
}

bool OAIEntityEntity::is_type_Valid() const{
    return m_type_isValid;
}

bool OAIEntityEntity::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_category_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_collection_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_custom_field_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_cache_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_entity_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_internal_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_methods_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_similar_to.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIEntityEntity::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
