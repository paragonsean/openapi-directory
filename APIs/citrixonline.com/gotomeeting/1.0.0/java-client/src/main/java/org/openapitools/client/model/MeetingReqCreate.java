/*
 * GoToMeeting
 * <br>The GoToMeeting API provides seamless integration of GoToMeeting provisioning and meeting management into your existing infrastructure or third party applications.<br><br>For customers, the ability to add, suspend or delete an organizer in your GoToMeeting Corporate account from within your primary management systems simplifies and streamlines the entire process of account management. The ability to monitor meeting schedules, history and active meeting status allows managers to leverage GoToMeeting activities through your primary applications.<br><br>For third parties, the ability to create, update or delete a meeting from within your application makes real-time collaboration possible for your customers. The ability to update meeting schedules, view history and scheduled meetings, and view attendees from past meetings allows you to enhance your users' experience and the value of your applications.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: developer-support@citrixonline.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.MeetingType;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the information required to create a meeting.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:56:58.282128-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MeetingReqCreate {
  public static final String SERIALIZED_NAME_CONFERENCECALLINFO = "conferencecallinfo";
  @SerializedName(SERIALIZED_NAME_CONFERENCECALLINFO)
  private String conferencecallinfo;

  public static final String SERIALIZED_NAME_ENDTIME = "endtime";
  @SerializedName(SERIALIZED_NAME_ENDTIME)
  private OffsetDateTime endtime;

  public static final String SERIALIZED_NAME_MEETINGTYPE = "meetingtype";
  @SerializedName(SERIALIZED_NAME_MEETINGTYPE)
  private MeetingType meetingtype;

  public static final String SERIALIZED_NAME_PASSWORDREQUIRED = "passwordrequired";
  @SerializedName(SERIALIZED_NAME_PASSWORDREQUIRED)
  private Boolean passwordrequired;

  public static final String SERIALIZED_NAME_STARTTIME = "starttime";
  @SerializedName(SERIALIZED_NAME_STARTTIME)
  private OffsetDateTime starttime;

  public static final String SERIALIZED_NAME_SUBJECT = "subject";
  @SerializedName(SERIALIZED_NAME_SUBJECT)
  private String subject;

  public static final String SERIALIZED_NAME_TIMEZONEKEY = "timezonekey";
  @SerializedName(SERIALIZED_NAME_TIMEZONEKEY)
  private String timezonekey;

  public MeetingReqCreate() {
  }

  public MeetingReqCreate conferencecallinfo(String conferencecallinfo) {
    this.conferencecallinfo = conferencecallinfo;
    return this;
  }

  /**
   * A required string. Can be one of the following options: &lt;br&gt;PSTN (PSTN only), &lt;br&gt;Free (PSTN and VoIP), &lt;br&gt;Hybrid, (PSTN and VoIP), &lt;br&gt;Private (you provide numbers and access code), or &lt;br&gt;VoIP (VoIP only). &lt;br&gt;You may also enter plain text for numbers and access codes with a limit of 255 characters
   * @return conferencecallinfo
   */
  @javax.annotation.Nonnull
  public String getConferencecallinfo() {
    return conferencecallinfo;
  }

  public void setConferencecallinfo(String conferencecallinfo) {
    this.conferencecallinfo = conferencecallinfo;
  }


  public MeetingReqCreate endtime(OffsetDateTime endtime) {
    this.endtime = endtime;
    return this;
  }

  /**
   * The ending time of the meeting. Required ISO8601 UTC string, e.g. 2015-07-01T23:00:00Z
   * @return endtime
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getEndtime() {
    return endtime;
  }

  public void setEndtime(OffsetDateTime endtime) {
    this.endtime = endtime;
  }


  public MeetingReqCreate meetingtype(MeetingType meetingtype) {
    this.meetingtype = meetingtype;
    return this;
  }

  /**
   * Get meetingtype
   * @return meetingtype
   */
  @javax.annotation.Nonnull
  public MeetingType getMeetingtype() {
    return meetingtype;
  }

  public void setMeetingtype(MeetingType meetingtype) {
    this.meetingtype = meetingtype;
  }


  public MeetingReqCreate passwordrequired(Boolean passwordrequired) {
    this.passwordrequired = passwordrequired;
    return this;
  }

  /**
   * Indicates whether a password is required to join the meeting. Required parameter
   * @return passwordrequired
   */
  @javax.annotation.Nonnull
  public Boolean getPasswordrequired() {
    return passwordrequired;
  }

  public void setPasswordrequired(Boolean passwordrequired) {
    this.passwordrequired = passwordrequired;
  }


  public MeetingReqCreate starttime(OffsetDateTime starttime) {
    this.starttime = starttime;
    return this;
  }

  /**
   * The starting time of the meeting. Required ISO8601 UTC string, e.g. 2015-07-01T22:00:00Z
   * @return starttime
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getStarttime() {
    return starttime;
  }

  public void setStarttime(OffsetDateTime starttime) {
    this.starttime = starttime;
  }


  public MeetingReqCreate subject(String subject) {
    this.subject = subject;
    return this;
  }

  /**
   * The subject of the meeting. 100 characters maximum. The characters &#39;&amp;gt;&#39; and &#39;&amp;lt;&#39; have to be replaced with the corresponding html character code (&amp;amp;gt; for &amp;#39;&amp;gt;&amp;#39; and &amp;amp;lt; for &amp;#39;&amp;lt;&amp;#39;)
   * @return subject
   */
  @javax.annotation.Nonnull
  public String getSubject() {
    return subject;
  }

  public void setSubject(String subject) {
    this.subject = subject;
  }


  public MeetingReqCreate timezonekey(String timezonekey) {
    this.timezonekey = timezonekey;
    return this;
  }

  /**
   * DEPRECATED. Must be provided and set to empty string &#39;&#39;
   * @return timezonekey
   */
  @javax.annotation.Nonnull
  public String getTimezonekey() {
    return timezonekey;
  }

  public void setTimezonekey(String timezonekey) {
    this.timezonekey = timezonekey;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MeetingReqCreate meetingReqCreate = (MeetingReqCreate) o;
    return Objects.equals(this.conferencecallinfo, meetingReqCreate.conferencecallinfo) &&
        Objects.equals(this.endtime, meetingReqCreate.endtime) &&
        Objects.equals(this.meetingtype, meetingReqCreate.meetingtype) &&
        Objects.equals(this.passwordrequired, meetingReqCreate.passwordrequired) &&
        Objects.equals(this.starttime, meetingReqCreate.starttime) &&
        Objects.equals(this.subject, meetingReqCreate.subject) &&
        Objects.equals(this.timezonekey, meetingReqCreate.timezonekey);
  }

  @Override
  public int hashCode() {
    return Objects.hash(conferencecallinfo, endtime, meetingtype, passwordrequired, starttime, subject, timezonekey);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MeetingReqCreate {\n");
    sb.append("    conferencecallinfo: ").append(toIndentedString(conferencecallinfo)).append("\n");
    sb.append("    endtime: ").append(toIndentedString(endtime)).append("\n");
    sb.append("    meetingtype: ").append(toIndentedString(meetingtype)).append("\n");
    sb.append("    passwordrequired: ").append(toIndentedString(passwordrequired)).append("\n");
    sb.append("    starttime: ").append(toIndentedString(starttime)).append("\n");
    sb.append("    subject: ").append(toIndentedString(subject)).append("\n");
    sb.append("    timezonekey: ").append(toIndentedString(timezonekey)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("conferencecallinfo");
    openapiFields.add("endtime");
    openapiFields.add("meetingtype");
    openapiFields.add("passwordrequired");
    openapiFields.add("starttime");
    openapiFields.add("subject");
    openapiFields.add("timezonekey");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("conferencecallinfo");
    openapiRequiredFields.add("endtime");
    openapiRequiredFields.add("meetingtype");
    openapiRequiredFields.add("passwordrequired");
    openapiRequiredFields.add("starttime");
    openapiRequiredFields.add("subject");
    openapiRequiredFields.add("timezonekey");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MeetingReqCreate
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MeetingReqCreate.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MeetingReqCreate is not found in the empty JSON string", MeetingReqCreate.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MeetingReqCreate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MeetingReqCreate` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MeetingReqCreate.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("conferencecallinfo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `conferencecallinfo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("conferencecallinfo").toString()));
      }
      // validate the required field `meetingtype`
      MeetingType.validateJsonElement(jsonObj.get("meetingtype"));
      if (!jsonObj.get("subject").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subject` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subject").toString()));
      }
      if (!jsonObj.get("timezonekey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timezonekey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timezonekey").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MeetingReqCreate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MeetingReqCreate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MeetingReqCreate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MeetingReqCreate.class));

       return (TypeAdapter<T>) new TypeAdapter<MeetingReqCreate>() {
           @Override
           public void write(JsonWriter out, MeetingReqCreate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MeetingReqCreate read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MeetingReqCreate given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MeetingReqCreate
   * @throws IOException if the JSON string is invalid with respect to MeetingReqCreate
   */
  public static MeetingReqCreate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MeetingReqCreate.class);
  }

  /**
   * Convert an instance of MeetingReqCreate to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

