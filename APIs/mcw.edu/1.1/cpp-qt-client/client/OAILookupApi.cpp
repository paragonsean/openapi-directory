/**
 * Rat Genome Database REST API
 * The RGD REST API provides programmatic access to information and annotation stored in the Rat Genome Database
 *
 * The version of the OpenAPI document: 1.1
 * Contact: RGD.Data2@mcw.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAILookupApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAILookupApi::OAILookupApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAILookupApi::~OAILookupApi() {
}

void OAILookupApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("//rest.rgd.mcw.edu/rgdws"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("getEnsemblGeneMappingUsingGET", defaultConf);
    _serverIndices.insert("getEnsemblGeneMappingUsingGET", 0);
    _serverConfigs.insert("getEnsemblGeneMappingUsingPOST", defaultConf);
    _serverIndices.insert("getEnsemblGeneMappingUsingPOST", 0);
    _serverConfigs.insert("getEnsemblProteinMappingUsingGET", defaultConf);
    _serverIndices.insert("getEnsemblProteinMappingUsingGET", 0);
    _serverConfigs.insert("getEnsemblProteinMappingUsingPOST", defaultConf);
    _serverIndices.insert("getEnsemblProteinMappingUsingPOST", 0);
    _serverConfigs.insert("getEnsemblTranscriptMappingUsingGET", defaultConf);
    _serverIndices.insert("getEnsemblTranscriptMappingUsingGET", 0);
    _serverConfigs.insert("getEnsemblTranscriptMappingUsingPOST", defaultConf);
    _serverIndices.insert("getEnsemblTranscriptMappingUsingPOST", 0);
    _serverConfigs.insert("getGTEXMappingUsingGET", defaultConf);
    _serverIndices.insert("getGTEXMappingUsingGET", 0);
    _serverConfigs.insert("getGTEXMappingUsingPOST", defaultConf);
    _serverIndices.insert("getGTEXMappingUsingPOST", 0);
    _serverConfigs.insert("getGenBankNucleotideMappingUsingGET", defaultConf);
    _serverIndices.insert("getGenBankNucleotideMappingUsingGET", 0);
    _serverConfigs.insert("getGenBankNucleotideMappingUsingPOST", defaultConf);
    _serverIndices.insert("getGenBankNucleotideMappingUsingPOST", 0);
    _serverConfigs.insert("getGenBankProteinMappingUsingGET", defaultConf);
    _serverIndices.insert("getGenBankProteinMappingUsingGET", 0);
    _serverConfigs.insert("getGenBankProteinMappingUsingPOST", defaultConf);
    _serverIndices.insert("getGenBankProteinMappingUsingPOST", 0);
    _serverConfigs.insert("getGeneTypesUsingGET", defaultConf);
    _serverIndices.insert("getGeneTypesUsingGET", 0);
    _serverConfigs.insert("getHGNCMappingUsingGET", defaultConf);
    _serverIndices.insert("getHGNCMappingUsingGET", 0);
    _serverConfigs.insert("getHGNCMappingUsingPOST", defaultConf);
    _serverIndices.insert("getHGNCMappingUsingPOST", 0);
    _serverConfigs.insert("getMGIMappingUsingGET", defaultConf);
    _serverIndices.insert("getMGIMappingUsingGET", 0);
    _serverConfigs.insert("getMGIMappingUsingPOST", defaultConf);
    _serverIndices.insert("getMGIMappingUsingPOST", 0);
    _serverConfigs.insert("getMapsUsingGET", defaultConf);
    _serverIndices.insert("getMapsUsingGET", 0);
    _serverConfigs.insert("getMapsUsingGET1", defaultConf);
    _serverIndices.insert("getMapsUsingGET1", 0);
    _serverConfigs.insert("getNCBIGeneMappingUsingGET", defaultConf);
    _serverIndices.insert("getNCBIGeneMappingUsingGET", 0);
    _serverConfigs.insert("getNCBIGeneMappingUsingPOST", defaultConf);
    _serverIndices.insert("getNCBIGeneMappingUsingPOST", 0);
    _serverConfigs.insert("getSpeciesTypesUsingGET", defaultConf);
    _serverIndices.insert("getSpeciesTypesUsingGET", 0);
    _serverConfigs.insert("getUniProtMappingUsingGET", defaultConf);
    _serverIndices.insert("getUniProtMappingUsingGET", 0);
    _serverConfigs.insert("getUniProtMappingUsingPOST", defaultConf);
    _serverIndices.insert("getUniProtMappingUsingPOST", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAILookupApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAILookupApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAILookupApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAILookupApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAILookupApi::setUsername(const QString &username) {
    _username = username;
}

void OAILookupApi::setPassword(const QString &password) {
    _password = password;
}


void OAILookupApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAILookupApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAILookupApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAILookupApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAILookupApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAILookupApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAILookupApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAILookupApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAILookupApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAILookupApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAILookupApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAILookupApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAILookupApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAILookupApi::getEnsemblGeneMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getEnsemblGeneMappingUsingGET"][_serverIndices.value("getEnsemblGeneMappingUsingGET")].URL()+"/lookup/id/map/EnsemblGene/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getEnsemblGeneMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getEnsemblGeneMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getEnsemblGeneMappingUsingGETSignal(output);
        Q_EMIT getEnsemblGeneMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getEnsemblGeneMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getEnsemblGeneMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getEnsemblGeneMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getEnsemblGeneMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getEnsemblGeneMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getEnsemblGeneMappingUsingPOST"][_serverIndices.value("getEnsemblGeneMappingUsingPOST")].URL()+"/lookup/id/map/EnsemblGene");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getEnsemblGeneMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getEnsemblGeneMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getEnsemblGeneMappingUsingPOSTSignal(output);
        Q_EMIT getEnsemblGeneMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getEnsemblGeneMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getEnsemblGeneMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getEnsemblGeneMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getEnsemblGeneMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getEnsemblProteinMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getEnsemblProteinMappingUsingGET"][_serverIndices.value("getEnsemblProteinMappingUsingGET")].URL()+"/lookup/id/map/EnsemblProtein/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getEnsemblProteinMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getEnsemblProteinMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getEnsemblProteinMappingUsingGETSignal(output);
        Q_EMIT getEnsemblProteinMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getEnsemblProteinMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getEnsemblProteinMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getEnsemblProteinMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getEnsemblProteinMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getEnsemblProteinMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getEnsemblProteinMappingUsingPOST"][_serverIndices.value("getEnsemblProteinMappingUsingPOST")].URL()+"/lookup/id/map/EnsemblProtein");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getEnsemblProteinMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getEnsemblProteinMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getEnsemblProteinMappingUsingPOSTSignal(output);
        Q_EMIT getEnsemblProteinMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getEnsemblProteinMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getEnsemblProteinMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getEnsemblProteinMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getEnsemblProteinMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getEnsemblTranscriptMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getEnsemblTranscriptMappingUsingGET"][_serverIndices.value("getEnsemblTranscriptMappingUsingGET")].URL()+"/lookup/id/map/EnsemblTranscript/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getEnsemblTranscriptMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getEnsemblTranscriptMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getEnsemblTranscriptMappingUsingGETSignal(output);
        Q_EMIT getEnsemblTranscriptMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getEnsemblTranscriptMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getEnsemblTranscriptMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getEnsemblTranscriptMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getEnsemblTranscriptMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getEnsemblTranscriptMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getEnsemblTranscriptMappingUsingPOST"][_serverIndices.value("getEnsemblTranscriptMappingUsingPOST")].URL()+"/lookup/id/map/EnsemblTranscript");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getEnsemblTranscriptMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getEnsemblTranscriptMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getEnsemblTranscriptMappingUsingPOSTSignal(output);
        Q_EMIT getEnsemblTranscriptMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getEnsemblTranscriptMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getEnsemblTranscriptMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getEnsemblTranscriptMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getEnsemblTranscriptMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getGTEXMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getGTEXMappingUsingGET"][_serverIndices.value("getGTEXMappingUsingGET")].URL()+"/lookup/id/map/GTEx/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getGTEXMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getGTEXMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGTEXMappingUsingGETSignal(output);
        Q_EMIT getGTEXMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGTEXMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getGTEXMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGTEXMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getGTEXMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getGTEXMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getGTEXMappingUsingPOST"][_serverIndices.value("getGTEXMappingUsingPOST")].URL()+"/lookup/id/map/GTEx");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getGTEXMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getGTEXMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGTEXMappingUsingPOSTSignal(output);
        Q_EMIT getGTEXMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGTEXMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getGTEXMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGTEXMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getGTEXMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getGenBankNucleotideMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getGenBankNucleotideMappingUsingGET"][_serverIndices.value("getGenBankNucleotideMappingUsingGET")].URL()+"/lookup/id/map/GenBankNucleotide/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getGenBankNucleotideMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getGenBankNucleotideMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGenBankNucleotideMappingUsingGETSignal(output);
        Q_EMIT getGenBankNucleotideMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGenBankNucleotideMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getGenBankNucleotideMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGenBankNucleotideMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getGenBankNucleotideMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getGenBankNucleotideMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getGenBankNucleotideMappingUsingPOST"][_serverIndices.value("getGenBankNucleotideMappingUsingPOST")].URL()+"/lookup/id/map/GenBankNucleotide");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getGenBankNucleotideMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getGenBankNucleotideMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGenBankNucleotideMappingUsingPOSTSignal(output);
        Q_EMIT getGenBankNucleotideMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGenBankNucleotideMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getGenBankNucleotideMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGenBankNucleotideMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getGenBankNucleotideMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getGenBankProteinMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getGenBankProteinMappingUsingGET"][_serverIndices.value("getGenBankProteinMappingUsingGET")].URL()+"/lookup/id/map/GenBankProtein/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getGenBankProteinMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getGenBankProteinMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGenBankProteinMappingUsingGETSignal(output);
        Q_EMIT getGenBankProteinMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGenBankProteinMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getGenBankProteinMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGenBankProteinMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getGenBankProteinMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getGenBankProteinMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getGenBankProteinMappingUsingPOST"][_serverIndices.value("getGenBankProteinMappingUsingPOST")].URL()+"/lookup/id/map/GenBankProtein");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getGenBankProteinMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getGenBankProteinMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGenBankProteinMappingUsingPOSTSignal(output);
        Q_EMIT getGenBankProteinMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGenBankProteinMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getGenBankProteinMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGenBankProteinMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getGenBankProteinMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getGeneTypesUsingGET() {
    QString fullPath = QString(_serverConfigs["getGeneTypesUsingGET"][_serverIndices.value("getGeneTypesUsingGET")].URL()+"/lookup/geneTypes");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getGeneTypesUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getGeneTypesUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGeneTypesUsingGETSignal(output);
        Q_EMIT getGeneTypesUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGeneTypesUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getGeneTypesUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGeneTypesUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getGeneTypesUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getHGNCMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getHGNCMappingUsingGET"][_serverIndices.value("getHGNCMappingUsingGET")].URL()+"/lookup/id/map/HGNC/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getHGNCMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getHGNCMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getHGNCMappingUsingGETSignal(output);
        Q_EMIT getHGNCMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getHGNCMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getHGNCMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getHGNCMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getHGNCMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getHGNCMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getHGNCMappingUsingPOST"][_serverIndices.value("getHGNCMappingUsingPOST")].URL()+"/lookup/id/map/HGNC");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getHGNCMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getHGNCMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getHGNCMappingUsingPOSTSignal(output);
        Q_EMIT getHGNCMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getHGNCMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getHGNCMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getHGNCMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getHGNCMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getMGIMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getMGIMappingUsingGET"][_serverIndices.value("getMGIMappingUsingGET")].URL()+"/lookup/id/map/MGI/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getMGIMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getMGIMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMGIMappingUsingGETSignal(output);
        Q_EMIT getMGIMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMGIMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getMGIMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMGIMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getMGIMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getMGIMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getMGIMappingUsingPOST"][_serverIndices.value("getMGIMappingUsingPOST")].URL()+"/lookup/id/map/MGI");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getMGIMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getMGIMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMGIMappingUsingPOSTSignal(output);
        Q_EMIT getMGIMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMGIMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getMGIMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMGIMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getMGIMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getMapsUsingGET(const qint32 &species_type_key) {
    QString fullPath = QString(_serverConfigs["getMapsUsingGET"][_serverIndices.value("getMapsUsingGET")].URL()+"/lookup/maps/{speciesTypeKey}");
    
    
    {
        QString species_type_keyPathParam("{");
        species_type_keyPathParam.append("speciesTypeKey").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "speciesTypeKey", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"speciesTypeKey"+pathSuffix : pathPrefix;
        fullPath.replace(species_type_keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(species_type_key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getMapsUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getMapsUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIMap> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIMap val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMapsUsingGETSignal(output);
        Q_EMIT getMapsUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMapsUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getMapsUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMapsUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getMapsUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getMapsUsingGET1(const QString &acc_id) {
    QString fullPath = QString(_serverConfigs["getMapsUsingGET1"][_serverIndices.value("getMapsUsingGET1")].URL()+"/lookup/standardUnit/{accId}");
    
    
    {
        QString acc_idPathParam("{");
        acc_idPathParam.append("accId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "accId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"accId"+pathSuffix : pathPrefix;
        fullPath.replace(acc_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(acc_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getMapsUsingGET1Callback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getMapsUsingGET1Callback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMapsUsingGET1Signal(output);
        Q_EMIT getMapsUsingGET1SignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMapsUsingGET1SignalE(output, error_type, error_str);
        Q_EMIT getMapsUsingGET1SignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMapsUsingGET1SignalError(output, error_type, error_str);
        Q_EMIT getMapsUsingGET1SignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getNCBIGeneMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getNCBIGeneMappingUsingGET"][_serverIndices.value("getNCBIGeneMappingUsingGET")].URL()+"/lookup/id/map/NCBIGene/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getNCBIGeneMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getNCBIGeneMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getNCBIGeneMappingUsingGETSignal(output);
        Q_EMIT getNCBIGeneMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getNCBIGeneMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getNCBIGeneMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getNCBIGeneMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getNCBIGeneMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getNCBIGeneMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getNCBIGeneMappingUsingPOST"][_serverIndices.value("getNCBIGeneMappingUsingPOST")].URL()+"/lookup/id/map/NCBIGene");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getNCBIGeneMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getNCBIGeneMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getNCBIGeneMappingUsingPOSTSignal(output);
        Q_EMIT getNCBIGeneMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getNCBIGeneMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getNCBIGeneMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getNCBIGeneMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getNCBIGeneMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getSpeciesTypesUsingGET() {
    QString fullPath = QString(_serverConfigs["getSpeciesTypesUsingGET"][_serverIndices.value("getSpeciesTypesUsingGET")].URL()+"/lookup/speciesTypeKeys");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getSpeciesTypesUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getSpeciesTypesUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSpeciesTypesUsingGETSignal(output);
        Q_EMIT getSpeciesTypesUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSpeciesTypesUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getSpeciesTypesUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSpeciesTypesUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getSpeciesTypesUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getUniProtMappingUsingGET(const qint32 &rgd_id) {
    QString fullPath = QString(_serverConfigs["getUniProtMappingUsingGET"][_serverIndices.value("getUniProtMappingUsingGET")].URL()+"/lookup/id/map/UniProt/{rgdId}");
    
    
    {
        QString rgd_idPathParam("{");
        rgd_idPathParam.append("rgdId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rgdId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rgdId"+pathSuffix : pathPrefix;
        fullPath.replace(rgd_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(rgd_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getUniProtMappingUsingGETCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getUniProtMappingUsingGETCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getUniProtMappingUsingGETSignal(output);
        Q_EMIT getUniProtMappingUsingGETSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getUniProtMappingUsingGETSignalE(output, error_type, error_str);
        Q_EMIT getUniProtMappingUsingGETSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getUniProtMappingUsingGETSignalError(output, error_type, error_str);
        Q_EMIT getUniProtMappingUsingGETSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::getUniProtMappingUsingPOST(const ::OpenAPI::OptionalParam<OAIRGDIDListRequest> &oairgdid_list_request) {
    QString fullPath = QString(_serverConfigs["getUniProtMappingUsingPOST"][_serverIndices.value("getUniProtMappingUsingPOST")].URL()+"/lookup/id/map/UniProt");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oairgdid_list_request.hasValue()){

        
        QByteArray output = oairgdid_list_request.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAILookupApi::getUniProtMappingUsingPOSTCallback);
    connect(this, &OAILookupApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAILookupApi::getUniProtMappingUsingPOSTCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QMap<QString, QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject obj = doc.object();
    for (QString key : obj.keys()) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj[key]);
        output.insert(key, val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getUniProtMappingUsingPOSTSignal(output);
        Q_EMIT getUniProtMappingUsingPOSTSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getUniProtMappingUsingPOSTSignalE(output, error_type, error_str);
        Q_EMIT getUniProtMappingUsingPOSTSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getUniProtMappingUsingPOSTSignalError(output, error_type, error_str);
        Q_EMIT getUniProtMappingUsingPOSTSignalErrorFull(worker, error_type, error_str);
    }
}

void OAILookupApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
