/**
 * Rat Genome Database REST API
 * The RGD REST API provides programmatic access to information and annotation stored in the Rat Genome Database
 *
 * The version of the OpenAPI document: 1.1
 * Contact: RGD.Data2@mcw.edu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIStrain.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIStrain::OAIStrain(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIStrain::OAIStrain() {
    this->initializeModel();
}

OAIStrain::~OAIStrain() {}

void OAIStrain::initializeModel() {

    m_background_strain_rgd_id_isSet = false;
    m_background_strain_rgd_id_isValid = false;

    m_chr_altered_isSet = false;
    m_chr_altered_isValid = false;

    m_color_isSet = false;
    m_color_isValid = false;

    m_genetic_status_isSet = false;
    m_genetic_status_isValid = false;

    m_genetics_isSet = false;
    m_genetics_isValid = false;

    m_image_url_isSet = false;
    m_image_url_isValid = false;

    m_inbred_gen_isSet = false;
    m_inbred_gen_isValid = false;

    m_key_isSet = false;
    m_key_isValid = false;

    m_last_status_isSet = false;
    m_last_status_isValid = false;

    m_last_status_object_isSet = false;
    m_last_status_object_isValid = false;

    m_modification_method_isSet = false;
    m_modification_method_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_notes_isSet = false;
    m_notes_isValid = false;

    m_origin_isSet = false;
    m_origin_isValid = false;

    m_research_use_isSet = false;
    m_research_use_isValid = false;

    m_rgd_id_isSet = false;
    m_rgd_id_isValid = false;

    m_source_isSet = false;
    m_source_isValid = false;

    m_species_type_key_isSet = false;
    m_species_type_key_isValid = false;

    m_status_log_isSet = false;
    m_status_log_isValid = false;

    m_strain_isSet = false;
    m_strain_isValid = false;

    m_strain_type_name_isSet = false;
    m_strain_type_name_isValid = false;

    m_substrain_isSet = false;
    m_substrain_isValid = false;

    m_symbol_isSet = false;
    m_symbol_isValid = false;
}

void OAIStrain::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIStrain::fromJsonObject(QJsonObject json) {

    m_background_strain_rgd_id_isValid = ::OpenAPI::fromJsonValue(m_background_strain_rgd_id, json[QString("backgroundStrainRgdId")]);
    m_background_strain_rgd_id_isSet = !json[QString("backgroundStrainRgdId")].isNull() && m_background_strain_rgd_id_isValid;

    m_chr_altered_isValid = ::OpenAPI::fromJsonValue(m_chr_altered, json[QString("chrAltered")]);
    m_chr_altered_isSet = !json[QString("chrAltered")].isNull() && m_chr_altered_isValid;

    m_color_isValid = ::OpenAPI::fromJsonValue(m_color, json[QString("color")]);
    m_color_isSet = !json[QString("color")].isNull() && m_color_isValid;

    m_genetic_status_isValid = ::OpenAPI::fromJsonValue(m_genetic_status, json[QString("geneticStatus")]);
    m_genetic_status_isSet = !json[QString("geneticStatus")].isNull() && m_genetic_status_isValid;

    m_genetics_isValid = ::OpenAPI::fromJsonValue(m_genetics, json[QString("genetics")]);
    m_genetics_isSet = !json[QString("genetics")].isNull() && m_genetics_isValid;

    m_image_url_isValid = ::OpenAPI::fromJsonValue(m_image_url, json[QString("imageUrl")]);
    m_image_url_isSet = !json[QString("imageUrl")].isNull() && m_image_url_isValid;

    m_inbred_gen_isValid = ::OpenAPI::fromJsonValue(m_inbred_gen, json[QString("inbredGen")]);
    m_inbred_gen_isSet = !json[QString("inbredGen")].isNull() && m_inbred_gen_isValid;

    m_key_isValid = ::OpenAPI::fromJsonValue(m_key, json[QString("key")]);
    m_key_isSet = !json[QString("key")].isNull() && m_key_isValid;

    m_last_status_isValid = ::OpenAPI::fromJsonValue(m_last_status, json[QString("lastStatus")]);
    m_last_status_isSet = !json[QString("lastStatus")].isNull() && m_last_status_isValid;

    m_last_status_object_isValid = ::OpenAPI::fromJsonValue(m_last_status_object, json[QString("lastStatusObject")]);
    m_last_status_object_isSet = !json[QString("lastStatusObject")].isNull() && m_last_status_object_isValid;

    m_modification_method_isValid = ::OpenAPI::fromJsonValue(m_modification_method, json[QString("modificationMethod")]);
    m_modification_method_isSet = !json[QString("modificationMethod")].isNull() && m_modification_method_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_notes_isValid = ::OpenAPI::fromJsonValue(m_notes, json[QString("notes")]);
    m_notes_isSet = !json[QString("notes")].isNull() && m_notes_isValid;

    m_origin_isValid = ::OpenAPI::fromJsonValue(m_origin, json[QString("origin")]);
    m_origin_isSet = !json[QString("origin")].isNull() && m_origin_isValid;

    m_research_use_isValid = ::OpenAPI::fromJsonValue(m_research_use, json[QString("researchUse")]);
    m_research_use_isSet = !json[QString("researchUse")].isNull() && m_research_use_isValid;

    m_rgd_id_isValid = ::OpenAPI::fromJsonValue(m_rgd_id, json[QString("rgdId")]);
    m_rgd_id_isSet = !json[QString("rgdId")].isNull() && m_rgd_id_isValid;

    m_source_isValid = ::OpenAPI::fromJsonValue(m_source, json[QString("source")]);
    m_source_isSet = !json[QString("source")].isNull() && m_source_isValid;

    m_species_type_key_isValid = ::OpenAPI::fromJsonValue(m_species_type_key, json[QString("speciesTypeKey")]);
    m_species_type_key_isSet = !json[QString("speciesTypeKey")].isNull() && m_species_type_key_isValid;

    m_status_log_isValid = ::OpenAPI::fromJsonValue(m_status_log, json[QString("statusLog")]);
    m_status_log_isSet = !json[QString("statusLog")].isNull() && m_status_log_isValid;

    m_strain_isValid = ::OpenAPI::fromJsonValue(m_strain, json[QString("strain")]);
    m_strain_isSet = !json[QString("strain")].isNull() && m_strain_isValid;

    m_strain_type_name_isValid = ::OpenAPI::fromJsonValue(m_strain_type_name, json[QString("strainTypeName")]);
    m_strain_type_name_isSet = !json[QString("strainTypeName")].isNull() && m_strain_type_name_isValid;

    m_substrain_isValid = ::OpenAPI::fromJsonValue(m_substrain, json[QString("substrain")]);
    m_substrain_isSet = !json[QString("substrain")].isNull() && m_substrain_isValid;

    m_symbol_isValid = ::OpenAPI::fromJsonValue(m_symbol, json[QString("symbol")]);
    m_symbol_isSet = !json[QString("symbol")].isNull() && m_symbol_isValid;
}

QString OAIStrain::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIStrain::asJsonObject() const {
    QJsonObject obj;
    if (m_background_strain_rgd_id_isSet) {
        obj.insert(QString("backgroundStrainRgdId"), ::OpenAPI::toJsonValue(m_background_strain_rgd_id));
    }
    if (m_chr_altered_isSet) {
        obj.insert(QString("chrAltered"), ::OpenAPI::toJsonValue(m_chr_altered));
    }
    if (m_color_isSet) {
        obj.insert(QString("color"), ::OpenAPI::toJsonValue(m_color));
    }
    if (m_genetic_status_isSet) {
        obj.insert(QString("geneticStatus"), ::OpenAPI::toJsonValue(m_genetic_status));
    }
    if (m_genetics_isSet) {
        obj.insert(QString("genetics"), ::OpenAPI::toJsonValue(m_genetics));
    }
    if (m_image_url_isSet) {
        obj.insert(QString("imageUrl"), ::OpenAPI::toJsonValue(m_image_url));
    }
    if (m_inbred_gen_isSet) {
        obj.insert(QString("inbredGen"), ::OpenAPI::toJsonValue(m_inbred_gen));
    }
    if (m_key_isSet) {
        obj.insert(QString("key"), ::OpenAPI::toJsonValue(m_key));
    }
    if (m_last_status_isSet) {
        obj.insert(QString("lastStatus"), ::OpenAPI::toJsonValue(m_last_status));
    }
    if (m_last_status_object.isSet()) {
        obj.insert(QString("lastStatusObject"), ::OpenAPI::toJsonValue(m_last_status_object));
    }
    if (m_modification_method_isSet) {
        obj.insert(QString("modificationMethod"), ::OpenAPI::toJsonValue(m_modification_method));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_notes_isSet) {
        obj.insert(QString("notes"), ::OpenAPI::toJsonValue(m_notes));
    }
    if (m_origin_isSet) {
        obj.insert(QString("origin"), ::OpenAPI::toJsonValue(m_origin));
    }
    if (m_research_use_isSet) {
        obj.insert(QString("researchUse"), ::OpenAPI::toJsonValue(m_research_use));
    }
    if (m_rgd_id_isSet) {
        obj.insert(QString("rgdId"), ::OpenAPI::toJsonValue(m_rgd_id));
    }
    if (m_source_isSet) {
        obj.insert(QString("source"), ::OpenAPI::toJsonValue(m_source));
    }
    if (m_species_type_key_isSet) {
        obj.insert(QString("speciesTypeKey"), ::OpenAPI::toJsonValue(m_species_type_key));
    }
    if (m_status_log.size() > 0) {
        obj.insert(QString("statusLog"), ::OpenAPI::toJsonValue(m_status_log));
    }
    if (m_strain_isSet) {
        obj.insert(QString("strain"), ::OpenAPI::toJsonValue(m_strain));
    }
    if (m_strain_type_name_isSet) {
        obj.insert(QString("strainTypeName"), ::OpenAPI::toJsonValue(m_strain_type_name));
    }
    if (m_substrain_isSet) {
        obj.insert(QString("substrain"), ::OpenAPI::toJsonValue(m_substrain));
    }
    if (m_symbol_isSet) {
        obj.insert(QString("symbol"), ::OpenAPI::toJsonValue(m_symbol));
    }
    return obj;
}

qint32 OAIStrain::getBackgroundStrainRgdId() const {
    return m_background_strain_rgd_id;
}
void OAIStrain::setBackgroundStrainRgdId(const qint32 &background_strain_rgd_id) {
    m_background_strain_rgd_id = background_strain_rgd_id;
    m_background_strain_rgd_id_isSet = true;
}

bool OAIStrain::is_background_strain_rgd_id_Set() const{
    return m_background_strain_rgd_id_isSet;
}

bool OAIStrain::is_background_strain_rgd_id_Valid() const{
    return m_background_strain_rgd_id_isValid;
}

QString OAIStrain::getChrAltered() const {
    return m_chr_altered;
}
void OAIStrain::setChrAltered(const QString &chr_altered) {
    m_chr_altered = chr_altered;
    m_chr_altered_isSet = true;
}

bool OAIStrain::is_chr_altered_Set() const{
    return m_chr_altered_isSet;
}

bool OAIStrain::is_chr_altered_Valid() const{
    return m_chr_altered_isValid;
}

QString OAIStrain::getColor() const {
    return m_color;
}
void OAIStrain::setColor(const QString &color) {
    m_color = color;
    m_color_isSet = true;
}

bool OAIStrain::is_color_Set() const{
    return m_color_isSet;
}

bool OAIStrain::is_color_Valid() const{
    return m_color_isValid;
}

QString OAIStrain::getGeneticStatus() const {
    return m_genetic_status;
}
void OAIStrain::setGeneticStatus(const QString &genetic_status) {
    m_genetic_status = genetic_status;
    m_genetic_status_isSet = true;
}

bool OAIStrain::is_genetic_status_Set() const{
    return m_genetic_status_isSet;
}

bool OAIStrain::is_genetic_status_Valid() const{
    return m_genetic_status_isValid;
}

QString OAIStrain::getGenetics() const {
    return m_genetics;
}
void OAIStrain::setGenetics(const QString &genetics) {
    m_genetics = genetics;
    m_genetics_isSet = true;
}

bool OAIStrain::is_genetics_Set() const{
    return m_genetics_isSet;
}

bool OAIStrain::is_genetics_Valid() const{
    return m_genetics_isValid;
}

QString OAIStrain::getImageUrl() const {
    return m_image_url;
}
void OAIStrain::setImageUrl(const QString &image_url) {
    m_image_url = image_url;
    m_image_url_isSet = true;
}

bool OAIStrain::is_image_url_Set() const{
    return m_image_url_isSet;
}

bool OAIStrain::is_image_url_Valid() const{
    return m_image_url_isValid;
}

QString OAIStrain::getInbredGen() const {
    return m_inbred_gen;
}
void OAIStrain::setInbredGen(const QString &inbred_gen) {
    m_inbred_gen = inbred_gen;
    m_inbred_gen_isSet = true;
}

bool OAIStrain::is_inbred_gen_Set() const{
    return m_inbred_gen_isSet;
}

bool OAIStrain::is_inbred_gen_Valid() const{
    return m_inbred_gen_isValid;
}

qint32 OAIStrain::getKey() const {
    return m_key;
}
void OAIStrain::setKey(const qint32 &key) {
    m_key = key;
    m_key_isSet = true;
}

bool OAIStrain::is_key_Set() const{
    return m_key_isSet;
}

bool OAIStrain::is_key_Valid() const{
    return m_key_isValid;
}

QString OAIStrain::getLastStatus() const {
    return m_last_status;
}
void OAIStrain::setLastStatus(const QString &last_status) {
    m_last_status = last_status;
    m_last_status_isSet = true;
}

bool OAIStrain::is_last_status_Set() const{
    return m_last_status_isSet;
}

bool OAIStrain::is_last_status_Valid() const{
    return m_last_status_isValid;
}

OAIStatus OAIStrain::getLastStatusObject() const {
    return m_last_status_object;
}
void OAIStrain::setLastStatusObject(const OAIStatus &last_status_object) {
    m_last_status_object = last_status_object;
    m_last_status_object_isSet = true;
}

bool OAIStrain::is_last_status_object_Set() const{
    return m_last_status_object_isSet;
}

bool OAIStrain::is_last_status_object_Valid() const{
    return m_last_status_object_isValid;
}

QString OAIStrain::getModificationMethod() const {
    return m_modification_method;
}
void OAIStrain::setModificationMethod(const QString &modification_method) {
    m_modification_method = modification_method;
    m_modification_method_isSet = true;
}

bool OAIStrain::is_modification_method_Set() const{
    return m_modification_method_isSet;
}

bool OAIStrain::is_modification_method_Valid() const{
    return m_modification_method_isValid;
}

QString OAIStrain::getName() const {
    return m_name;
}
void OAIStrain::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIStrain::is_name_Set() const{
    return m_name_isSet;
}

bool OAIStrain::is_name_Valid() const{
    return m_name_isValid;
}

QString OAIStrain::getNotes() const {
    return m_notes;
}
void OAIStrain::setNotes(const QString &notes) {
    m_notes = notes;
    m_notes_isSet = true;
}

bool OAIStrain::is_notes_Set() const{
    return m_notes_isSet;
}

bool OAIStrain::is_notes_Valid() const{
    return m_notes_isValid;
}

QString OAIStrain::getOrigin() const {
    return m_origin;
}
void OAIStrain::setOrigin(const QString &origin) {
    m_origin = origin;
    m_origin_isSet = true;
}

bool OAIStrain::is_origin_Set() const{
    return m_origin_isSet;
}

bool OAIStrain::is_origin_Valid() const{
    return m_origin_isValid;
}

QString OAIStrain::getResearchUse() const {
    return m_research_use;
}
void OAIStrain::setResearchUse(const QString &research_use) {
    m_research_use = research_use;
    m_research_use_isSet = true;
}

bool OAIStrain::is_research_use_Set() const{
    return m_research_use_isSet;
}

bool OAIStrain::is_research_use_Valid() const{
    return m_research_use_isValid;
}

qint32 OAIStrain::getRgdId() const {
    return m_rgd_id;
}
void OAIStrain::setRgdId(const qint32 &rgd_id) {
    m_rgd_id = rgd_id;
    m_rgd_id_isSet = true;
}

bool OAIStrain::is_rgd_id_Set() const{
    return m_rgd_id_isSet;
}

bool OAIStrain::is_rgd_id_Valid() const{
    return m_rgd_id_isValid;
}

QString OAIStrain::getSource() const {
    return m_source;
}
void OAIStrain::setSource(const QString &source) {
    m_source = source;
    m_source_isSet = true;
}

bool OAIStrain::is_source_Set() const{
    return m_source_isSet;
}

bool OAIStrain::is_source_Valid() const{
    return m_source_isValid;
}

qint32 OAIStrain::getSpeciesTypeKey() const {
    return m_species_type_key;
}
void OAIStrain::setSpeciesTypeKey(const qint32 &species_type_key) {
    m_species_type_key = species_type_key;
    m_species_type_key_isSet = true;
}

bool OAIStrain::is_species_type_key_Set() const{
    return m_species_type_key_isSet;
}

bool OAIStrain::is_species_type_key_Valid() const{
    return m_species_type_key_isValid;
}

QList<OAIStatus> OAIStrain::getStatusLog() const {
    return m_status_log;
}
void OAIStrain::setStatusLog(const QList<OAIStatus> &status_log) {
    m_status_log = status_log;
    m_status_log_isSet = true;
}

bool OAIStrain::is_status_log_Set() const{
    return m_status_log_isSet;
}

bool OAIStrain::is_status_log_Valid() const{
    return m_status_log_isValid;
}

QString OAIStrain::getStrain() const {
    return m_strain;
}
void OAIStrain::setStrain(const QString &strain) {
    m_strain = strain;
    m_strain_isSet = true;
}

bool OAIStrain::is_strain_Set() const{
    return m_strain_isSet;
}

bool OAIStrain::is_strain_Valid() const{
    return m_strain_isValid;
}

QString OAIStrain::getStrainTypeName() const {
    return m_strain_type_name;
}
void OAIStrain::setStrainTypeName(const QString &strain_type_name) {
    m_strain_type_name = strain_type_name;
    m_strain_type_name_isSet = true;
}

bool OAIStrain::is_strain_type_name_Set() const{
    return m_strain_type_name_isSet;
}

bool OAIStrain::is_strain_type_name_Valid() const{
    return m_strain_type_name_isValid;
}

QString OAIStrain::getSubstrain() const {
    return m_substrain;
}
void OAIStrain::setSubstrain(const QString &substrain) {
    m_substrain = substrain;
    m_substrain_isSet = true;
}

bool OAIStrain::is_substrain_Set() const{
    return m_substrain_isSet;
}

bool OAIStrain::is_substrain_Valid() const{
    return m_substrain_isValid;
}

QString OAIStrain::getSymbol() const {
    return m_symbol;
}
void OAIStrain::setSymbol(const QString &symbol) {
    m_symbol = symbol;
    m_symbol_isSet = true;
}

bool OAIStrain::is_symbol_Set() const{
    return m_symbol_isSet;
}

bool OAIStrain::is_symbol_Valid() const{
    return m_symbol_isValid;
}

bool OAIStrain::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_background_strain_rgd_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_chr_altered_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_color_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_genetic_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_genetics_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_url_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_inbred_gen_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_status_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_last_status_object.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_modification_method_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_notes_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_origin_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_research_use_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rgd_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_source_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_species_type_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_status_log.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_strain_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_strain_type_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_substrain_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_symbol_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIStrain::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
