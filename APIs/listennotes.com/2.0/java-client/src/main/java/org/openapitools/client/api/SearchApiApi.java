/*
 * Listen API: Podcast Search, Directory, and Insights API
 * Simple & no-nonsense podcast search & directory API. Search all podcasts and episodes by people, places, or topics. 
 *
 * The version of the OpenAPI document: 2.0
 * Contact: hello@listennotes.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import java.time.OffsetDateTime;
import org.openapitools.client.model.RelatedSearchesResponse;
import org.openapitools.client.model.SearchResponse;
import org.openapitools.client.model.SpellCheckResponse;
import org.openapitools.client.model.TrendingSearchesResponse;
import org.openapitools.client.model.TypeaheadResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SearchApiApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SearchApiApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SearchApiApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getRelatedSearches
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic...  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRelatedSearchesCall(String xListenAPIKey, String q, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/related_searches";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (xListenAPIKey != null) {
            localVarHeaderParams.put("X-ListenAPI-Key", localVarApiClient.parameterToString(xListenAPIKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRelatedSearchesValidateBeforeCall(String xListenAPIKey, String q, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xListenAPIKey' is set
        if (xListenAPIKey == null) {
            throw new ApiException("Missing the required parameter 'xListenAPIKey' when calling getRelatedSearches(Async)");
        }

        // verify the required parameter 'q' is set
        if (q == null) {
            throw new ApiException("Missing the required parameter 'q' when calling getRelatedSearches(Async)");
        }

        return getRelatedSearchesCall(xListenAPIKey, q, _callback);

    }

    /**
     * Fetch related search terms
     * Suggest related search terms. The results are more comprehensive than from &#x60;GET /typeahead&#x60;. This endpoint is available only in the PRO/ENTERPRISE plan.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic...  (required)
     * @return RelatedSearchesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public RelatedSearchesResponse getRelatedSearches(String xListenAPIKey, String q) throws ApiException {
        ApiResponse<RelatedSearchesResponse> localVarResp = getRelatedSearchesWithHttpInfo(xListenAPIKey, q);
        return localVarResp.getData();
    }

    /**
     * Fetch related search terms
     * Suggest related search terms. The results are more comprehensive than from &#x60;GET /typeahead&#x60;. This endpoint is available only in the PRO/ENTERPRISE plan.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic...  (required)
     * @return ApiResponse&lt;RelatedSearchesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RelatedSearchesResponse> getRelatedSearchesWithHttpInfo(String xListenAPIKey, String q) throws ApiException {
        okhttp3.Call localVarCall = getRelatedSearchesValidateBeforeCall(xListenAPIKey, q, null);
        Type localVarReturnType = new TypeToken<RelatedSearchesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Fetch related search terms (asynchronously)
     * Suggest related search terms. The results are more comprehensive than from &#x60;GET /typeahead&#x60;. This endpoint is available only in the PRO/ENTERPRISE plan.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic...  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRelatedSearchesAsync(String xListenAPIKey, String q, final ApiCallback<RelatedSearchesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRelatedSearchesValidateBeforeCall(xListenAPIKey, q, _callback);
        Type localVarReturnType = new TypeToken<RelatedSearchesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getTrendingSearches
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTrendingSearchesCall(String xListenAPIKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/trending_searches";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xListenAPIKey != null) {
            localVarHeaderParams.put("X-ListenAPI-Key", localVarApiClient.parameterToString(xListenAPIKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTrendingSearchesValidateBeforeCall(String xListenAPIKey, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xListenAPIKey' is set
        if (xListenAPIKey == null) {
            throw new ApiException("Missing the required parameter 'xListenAPIKey' when calling getTrendingSearches(Async)");
        }

        return getTrendingSearchesCall(xListenAPIKey, _callback);

    }

    /**
     * Fetch trending search terms
     * Fetch up to 10 most recent trending search terms on the Listen Notes platform.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @return TrendingSearchesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public TrendingSearchesResponse getTrendingSearches(String xListenAPIKey) throws ApiException {
        ApiResponse<TrendingSearchesResponse> localVarResp = getTrendingSearchesWithHttpInfo(xListenAPIKey);
        return localVarResp.getData();
    }

    /**
     * Fetch trending search terms
     * Fetch up to 10 most recent trending search terms on the Listen Notes platform.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @return ApiResponse&lt;TrendingSearchesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TrendingSearchesResponse> getTrendingSearchesWithHttpInfo(String xListenAPIKey) throws ApiException {
        okhttp3.Call localVarCall = getTrendingSearchesValidateBeforeCall(xListenAPIKey, null);
        Type localVarReturnType = new TypeToken<TrendingSearchesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Fetch trending search terms (asynchronously)
     * Fetch up to 10 most recent trending search terms on the Listen Notes platform.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getTrendingSearchesAsync(String xListenAPIKey, final ApiCallback<TrendingSearchesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTrendingSearchesValidateBeforeCall(xListenAPIKey, _callback);
        Type localVarReturnType = new TypeToken<TrendingSearchesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for search
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., \&quot;game of thrones\&quot;. Otherwise, it&#39;s fuzzy search.  (required)
     * @param sortByDate Sort by date or not? If 0, then sort by relevance. If 1, then sort by date.  (optional, default to 0)
     * @param type What type of contents do you want to search for?   (optional, default to episode)
     * @param offset Offset for search results, for pagination. You&#39;ll use **next_offset** from response for this parameter.  (optional, default to 0)
     * @param lenMin Minimum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**. If **type** parameter is **episode**, it&#39;s for audio length of an episode. If **type** parameter is **podcast**, it&#39;s for average audio length of all episodes in a podcast.  (optional, default to 0)
     * @param lenMax Maximum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**. If **type** parameter is **episode**, it&#39;s for audio length of an episode. If **type** parameter is **podcast**, it&#39;s for average audio length of all episodes in a podcast.  (optional)
     * @param episodeCountMin Minimum number of episodes. Applicable only when type parameter is **podcast**.  (optional)
     * @param episodeCountMax Maximum number of episodes. Applicable only when type parameter is **podcast**.  (optional)
     * @param updateFreqMin Minimum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \&quot;weekly\&quot; podcasts, then you can set **update_freq_min**&#x3D;144 hours (or 6 days) and **update_freq_max**&#x3D;192 hours (or 8 days). Applicable only when type parameter is **podcast**.  (optional)
     * @param updateFreqMax Maximum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \&quot;weekly\&quot; podcasts, then you can set **update_freq_min**&#x3D;144 hours (or 6 days) and **update_freq_max**&#x3D;192 hours (or 8 days). Applicable only when type parameter is **podcast**.  (optional)
     * @param genreIds A comma-delimited string of a list of genre ids. If not specified, then all genres are included. You can find the id and the name of all genres from &#x60;GET /genres&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param publishedBefore Only show episodes/podcasts/curated lists published before this timestamp (in milliseconds). If **published_before** &amp; **published_after** are used at the same time, **published_before** should be bigger than **published_after**.  (optional)
     * @param publishedAfter Only show episodes/podcasts/curated lists published after this timestamp (in milliseconds). If **published_before** &amp; **published_after** are used at the same time, **published_before** should be bigger than **published_after**.  (optional, default to 0)
     * @param onlyIn A comma-delimited string to search only in specific fields. Allowed values are title, description, author, and audio. If not specified, then search every fields.  (optional, default to title,description,author,audio)
     * @param language Limit search results to a specific language. If not specified, it&#39;ll be any language. You can get a list of supported languages from &#x60;GET /languages&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param region Limit search results to a specific region (e.g., us, gb, in...). If not specified, it&#39;ll be any region. You can get the supported country codes from &#x60;GET /regions&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param ocid A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to limit search results from only a few specific podcasts. It works only when **type** is *episode*.  (optional)
     * @param ncid A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to exclude search results of a few specific podcasts. It works only when **type** is *episode*.  (optional)
     * @param safeMode Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*.  (optional, default to 0)
     * @param uniquePodcasts Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*.  (optional, default to 0)
     * @param pageSize The maximum number of search results per page. A valid value should be an integer between 1 and 10 (inclusive).  (optional, default to 10)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchCall(String xListenAPIKey, String q, Integer sortByDate, String type, Integer offset, Integer lenMin, Integer lenMax, Integer episodeCountMin, Integer episodeCountMax, Integer updateFreqMin, Integer updateFreqMax, String genreIds, Integer publishedBefore, Integer publishedAfter, String onlyIn, String language, String region, String ocid, String ncid, Integer safeMode, Integer uniquePodcasts, Integer pageSize, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (sortByDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort_by_date", sortByDate));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (lenMin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("len_min", lenMin));
        }

        if (lenMax != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("len_max", lenMax));
        }

        if (episodeCountMin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("episode_count_min", episodeCountMin));
        }

        if (episodeCountMax != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("episode_count_max", episodeCountMax));
        }

        if (updateFreqMin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("update_freq_min", updateFreqMin));
        }

        if (updateFreqMax != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("update_freq_max", updateFreqMax));
        }

        if (genreIds != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("genre_ids", genreIds));
        }

        if (publishedBefore != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("published_before", publishedBefore));
        }

        if (publishedAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("published_after", publishedAfter));
        }

        if (onlyIn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("only_in", onlyIn));
        }

        if (language != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("language", language));
        }

        if (region != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("region", region));
        }

        if (ocid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ocid", ocid));
        }

        if (ncid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ncid", ncid));
        }

        if (safeMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("safe_mode", safeMode));
        }

        if (uniquePodcasts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("unique_podcasts", uniquePodcasts));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page_size", pageSize));
        }

        if (xListenAPIKey != null) {
            localVarHeaderParams.put("X-ListenAPI-Key", localVarApiClient.parameterToString(xListenAPIKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchValidateBeforeCall(String xListenAPIKey, String q, Integer sortByDate, String type, Integer offset, Integer lenMin, Integer lenMax, Integer episodeCountMin, Integer episodeCountMax, Integer updateFreqMin, Integer updateFreqMax, String genreIds, Integer publishedBefore, Integer publishedAfter, String onlyIn, String language, String region, String ocid, String ncid, Integer safeMode, Integer uniquePodcasts, Integer pageSize, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xListenAPIKey' is set
        if (xListenAPIKey == null) {
            throw new ApiException("Missing the required parameter 'xListenAPIKey' when calling search(Async)");
        }

        // verify the required parameter 'q' is set
        if (q == null) {
            throw new ApiException("Missing the required parameter 'q' when calling search(Async)");
        }

        return searchCall(xListenAPIKey, q, sortByDate, type, offset, lenMin, lenMax, episodeCountMin, episodeCountMax, updateFreqMin, updateFreqMax, genreIds, publishedBefore, publishedAfter, onlyIn, language, region, ocid, ncid, safeMode, uniquePodcasts, pageSize, _callback);

    }

    /**
     * Full-text search
     * Full-text search on episodes, podcasts, or curated lists of podcasts. Use the &#x60;offset&#x60; parameter to paginate through search results. The FREE plan allows to see up to 30 search results (or &#x60;offset&#x60; &lt; 30) per query. The PRO plan allows to see up to 300 search results (or &#x60;offset&#x60; &lt; 300) per query. The ENTERPRISE plan allows to see up to 10,000 search results (or &#x60;offset&#x60; &lt; 10000) per query. 
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., \&quot;game of thrones\&quot;. Otherwise, it&#39;s fuzzy search.  (required)
     * @param sortByDate Sort by date or not? If 0, then sort by relevance. If 1, then sort by date.  (optional, default to 0)
     * @param type What type of contents do you want to search for?   (optional, default to episode)
     * @param offset Offset for search results, for pagination. You&#39;ll use **next_offset** from response for this parameter.  (optional, default to 0)
     * @param lenMin Minimum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**. If **type** parameter is **episode**, it&#39;s for audio length of an episode. If **type** parameter is **podcast**, it&#39;s for average audio length of all episodes in a podcast.  (optional, default to 0)
     * @param lenMax Maximum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**. If **type** parameter is **episode**, it&#39;s for audio length of an episode. If **type** parameter is **podcast**, it&#39;s for average audio length of all episodes in a podcast.  (optional)
     * @param episodeCountMin Minimum number of episodes. Applicable only when type parameter is **podcast**.  (optional)
     * @param episodeCountMax Maximum number of episodes. Applicable only when type parameter is **podcast**.  (optional)
     * @param updateFreqMin Minimum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \&quot;weekly\&quot; podcasts, then you can set **update_freq_min**&#x3D;144 hours (or 6 days) and **update_freq_max**&#x3D;192 hours (or 8 days). Applicable only when type parameter is **podcast**.  (optional)
     * @param updateFreqMax Maximum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \&quot;weekly\&quot; podcasts, then you can set **update_freq_min**&#x3D;144 hours (or 6 days) and **update_freq_max**&#x3D;192 hours (or 8 days). Applicable only when type parameter is **podcast**.  (optional)
     * @param genreIds A comma-delimited string of a list of genre ids. If not specified, then all genres are included. You can find the id and the name of all genres from &#x60;GET /genres&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param publishedBefore Only show episodes/podcasts/curated lists published before this timestamp (in milliseconds). If **published_before** &amp; **published_after** are used at the same time, **published_before** should be bigger than **published_after**.  (optional)
     * @param publishedAfter Only show episodes/podcasts/curated lists published after this timestamp (in milliseconds). If **published_before** &amp; **published_after** are used at the same time, **published_before** should be bigger than **published_after**.  (optional, default to 0)
     * @param onlyIn A comma-delimited string to search only in specific fields. Allowed values are title, description, author, and audio. If not specified, then search every fields.  (optional, default to title,description,author,audio)
     * @param language Limit search results to a specific language. If not specified, it&#39;ll be any language. You can get a list of supported languages from &#x60;GET /languages&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param region Limit search results to a specific region (e.g., us, gb, in...). If not specified, it&#39;ll be any region. You can get the supported country codes from &#x60;GET /regions&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param ocid A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to limit search results from only a few specific podcasts. It works only when **type** is *episode*.  (optional)
     * @param ncid A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to exclude search results of a few specific podcasts. It works only when **type** is *episode*.  (optional)
     * @param safeMode Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*.  (optional, default to 0)
     * @param uniquePodcasts Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*.  (optional, default to 0)
     * @param pageSize The maximum number of search results per page. A valid value should be an integer between 1 and 10 (inclusive).  (optional, default to 10)
     * @return SearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public SearchResponse search(String xListenAPIKey, String q, Integer sortByDate, String type, Integer offset, Integer lenMin, Integer lenMax, Integer episodeCountMin, Integer episodeCountMax, Integer updateFreqMin, Integer updateFreqMax, String genreIds, Integer publishedBefore, Integer publishedAfter, String onlyIn, String language, String region, String ocid, String ncid, Integer safeMode, Integer uniquePodcasts, Integer pageSize) throws ApiException {
        ApiResponse<SearchResponse> localVarResp = searchWithHttpInfo(xListenAPIKey, q, sortByDate, type, offset, lenMin, lenMax, episodeCountMin, episodeCountMax, updateFreqMin, updateFreqMax, genreIds, publishedBefore, publishedAfter, onlyIn, language, region, ocid, ncid, safeMode, uniquePodcasts, pageSize);
        return localVarResp.getData();
    }

    /**
     * Full-text search
     * Full-text search on episodes, podcasts, or curated lists of podcasts. Use the &#x60;offset&#x60; parameter to paginate through search results. The FREE plan allows to see up to 30 search results (or &#x60;offset&#x60; &lt; 30) per query. The PRO plan allows to see up to 300 search results (or &#x60;offset&#x60; &lt; 300) per query. The ENTERPRISE plan allows to see up to 10,000 search results (or &#x60;offset&#x60; &lt; 10000) per query. 
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., \&quot;game of thrones\&quot;. Otherwise, it&#39;s fuzzy search.  (required)
     * @param sortByDate Sort by date or not? If 0, then sort by relevance. If 1, then sort by date.  (optional, default to 0)
     * @param type What type of contents do you want to search for?   (optional, default to episode)
     * @param offset Offset for search results, for pagination. You&#39;ll use **next_offset** from response for this parameter.  (optional, default to 0)
     * @param lenMin Minimum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**. If **type** parameter is **episode**, it&#39;s for audio length of an episode. If **type** parameter is **podcast**, it&#39;s for average audio length of all episodes in a podcast.  (optional, default to 0)
     * @param lenMax Maximum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**. If **type** parameter is **episode**, it&#39;s for audio length of an episode. If **type** parameter is **podcast**, it&#39;s for average audio length of all episodes in a podcast.  (optional)
     * @param episodeCountMin Minimum number of episodes. Applicable only when type parameter is **podcast**.  (optional)
     * @param episodeCountMax Maximum number of episodes. Applicable only when type parameter is **podcast**.  (optional)
     * @param updateFreqMin Minimum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \&quot;weekly\&quot; podcasts, then you can set **update_freq_min**&#x3D;144 hours (or 6 days) and **update_freq_max**&#x3D;192 hours (or 8 days). Applicable only when type parameter is **podcast**.  (optional)
     * @param updateFreqMax Maximum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \&quot;weekly\&quot; podcasts, then you can set **update_freq_min**&#x3D;144 hours (or 6 days) and **update_freq_max**&#x3D;192 hours (or 8 days). Applicable only when type parameter is **podcast**.  (optional)
     * @param genreIds A comma-delimited string of a list of genre ids. If not specified, then all genres are included. You can find the id and the name of all genres from &#x60;GET /genres&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param publishedBefore Only show episodes/podcasts/curated lists published before this timestamp (in milliseconds). If **published_before** &amp; **published_after** are used at the same time, **published_before** should be bigger than **published_after**.  (optional)
     * @param publishedAfter Only show episodes/podcasts/curated lists published after this timestamp (in milliseconds). If **published_before** &amp; **published_after** are used at the same time, **published_before** should be bigger than **published_after**.  (optional, default to 0)
     * @param onlyIn A comma-delimited string to search only in specific fields. Allowed values are title, description, author, and audio. If not specified, then search every fields.  (optional, default to title,description,author,audio)
     * @param language Limit search results to a specific language. If not specified, it&#39;ll be any language. You can get a list of supported languages from &#x60;GET /languages&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param region Limit search results to a specific region (e.g., us, gb, in...). If not specified, it&#39;ll be any region. You can get the supported country codes from &#x60;GET /regions&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param ocid A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to limit search results from only a few specific podcasts. It works only when **type** is *episode*.  (optional)
     * @param ncid A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to exclude search results of a few specific podcasts. It works only when **type** is *episode*.  (optional)
     * @param safeMode Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*.  (optional, default to 0)
     * @param uniquePodcasts Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*.  (optional, default to 0)
     * @param pageSize The maximum number of search results per page. A valid value should be an integer between 1 and 10 (inclusive).  (optional, default to 10)
     * @return ApiResponse&lt;SearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SearchResponse> searchWithHttpInfo(String xListenAPIKey, String q, Integer sortByDate, String type, Integer offset, Integer lenMin, Integer lenMax, Integer episodeCountMin, Integer episodeCountMax, Integer updateFreqMin, Integer updateFreqMax, String genreIds, Integer publishedBefore, Integer publishedAfter, String onlyIn, String language, String region, String ocid, String ncid, Integer safeMode, Integer uniquePodcasts, Integer pageSize) throws ApiException {
        okhttp3.Call localVarCall = searchValidateBeforeCall(xListenAPIKey, q, sortByDate, type, offset, lenMin, lenMax, episodeCountMin, episodeCountMax, updateFreqMin, updateFreqMax, genreIds, publishedBefore, publishedAfter, onlyIn, language, region, ocid, ncid, safeMode, uniquePodcasts, pageSize, null);
        Type localVarReturnType = new TypeToken<SearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Full-text search (asynchronously)
     * Full-text search on episodes, podcasts, or curated lists of podcasts. Use the &#x60;offset&#x60; parameter to paginate through search results. The FREE plan allows to see up to 30 search results (or &#x60;offset&#x60; &lt; 30) per query. The PRO plan allows to see up to 300 search results (or &#x60;offset&#x60; &lt; 300) per query. The ENTERPRISE plan allows to see up to 10,000 search results (or &#x60;offset&#x60; &lt; 10000) per query. 
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., \&quot;game of thrones\&quot;. Otherwise, it&#39;s fuzzy search.  (required)
     * @param sortByDate Sort by date or not? If 0, then sort by relevance. If 1, then sort by date.  (optional, default to 0)
     * @param type What type of contents do you want to search for?   (optional, default to episode)
     * @param offset Offset for search results, for pagination. You&#39;ll use **next_offset** from response for this parameter.  (optional, default to 0)
     * @param lenMin Minimum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**. If **type** parameter is **episode**, it&#39;s for audio length of an episode. If **type** parameter is **podcast**, it&#39;s for average audio length of all episodes in a podcast.  (optional, default to 0)
     * @param lenMax Maximum audio length in minutes. Applicable only when **type** parameter is **episode** or **podcast**. If **type** parameter is **episode**, it&#39;s for audio length of an episode. If **type** parameter is **podcast**, it&#39;s for average audio length of all episodes in a podcast.  (optional)
     * @param episodeCountMin Minimum number of episodes. Applicable only when type parameter is **podcast**.  (optional)
     * @param episodeCountMax Maximum number of episodes. Applicable only when type parameter is **podcast**.  (optional)
     * @param updateFreqMin Minimum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \&quot;weekly\&quot; podcasts, then you can set **update_freq_min**&#x3D;144 hours (or 6 days) and **update_freq_max**&#x3D;192 hours (or 8 days). Applicable only when type parameter is **podcast**.  (optional)
     * @param updateFreqMax Maximum update frequency in hours (how frequently does a podcast release a new episode). For example, if you want to find \&quot;weekly\&quot; podcasts, then you can set **update_freq_min**&#x3D;144 hours (or 6 days) and **update_freq_max**&#x3D;192 hours (or 8 days). Applicable only when type parameter is **podcast**.  (optional)
     * @param genreIds A comma-delimited string of a list of genre ids. If not specified, then all genres are included. You can find the id and the name of all genres from &#x60;GET /genres&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param publishedBefore Only show episodes/podcasts/curated lists published before this timestamp (in milliseconds). If **published_before** &amp; **published_after** are used at the same time, **published_before** should be bigger than **published_after**.  (optional)
     * @param publishedAfter Only show episodes/podcasts/curated lists published after this timestamp (in milliseconds). If **published_before** &amp; **published_after** are used at the same time, **published_before** should be bigger than **published_after**.  (optional, default to 0)
     * @param onlyIn A comma-delimited string to search only in specific fields. Allowed values are title, description, author, and audio. If not specified, then search every fields.  (optional, default to title,description,author,audio)
     * @param language Limit search results to a specific language. If not specified, it&#39;ll be any language. You can get a list of supported languages from &#x60;GET /languages&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param region Limit search results to a specific region (e.g., us, gb, in...). If not specified, it&#39;ll be any region. You can get the supported country codes from &#x60;GET /regions&#x60;. It works only when **type** is *episode* or *podcast*.  (optional)
     * @param ocid A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to limit search results from only a few specific podcasts. It works only when **type** is *episode*.  (optional)
     * @param ncid A comma-delimited string of podcast ids (up to 5 podcasts) - you can get a podcast id from the **podcast_id** field in response. This parameter is to exclude search results of a few specific podcasts. It works only when **type** is *episode*.  (optional)
     * @param safeMode Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **type** is *episode* or *podcast*.  (optional, default to 0)
     * @param uniquePodcasts Whether or not to keep only one episode per podcast in search results. 1 is yes and 0 is no. It works only when **type** is *episode*.  (optional, default to 0)
     * @param pageSize The maximum number of search results per page. A valid value should be an integer between 1 and 10 (inclusive).  (optional, default to 10)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchAsync(String xListenAPIKey, String q, Integer sortByDate, String type, Integer offset, Integer lenMin, Integer lenMax, Integer episodeCountMin, Integer episodeCountMax, Integer updateFreqMin, Integer updateFreqMax, String genreIds, Integer publishedBefore, Integer publishedAfter, String onlyIn, String language, String region, String ocid, String ncid, Integer safeMode, Integer uniquePodcasts, Integer pageSize, final ApiCallback<SearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchValidateBeforeCall(xListenAPIKey, q, sortByDate, type, offset, lenMin, lenMax, episodeCountMin, episodeCountMax, updateFreqMin, updateFreqMax, genreIds, publishedBefore, publishedAfter, onlyIn, language, region, ocid, ncid, safeMode, uniquePodcasts, pageSize, _callback);
        Type localVarReturnType = new TypeToken<SearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for spellcheck
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic...  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call spellcheckCall(String xListenAPIKey, String q, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/spellcheck";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (xListenAPIKey != null) {
            localVarHeaderParams.put("X-ListenAPI-Key", localVarApiClient.parameterToString(xListenAPIKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call spellcheckValidateBeforeCall(String xListenAPIKey, String q, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xListenAPIKey' is set
        if (xListenAPIKey == null) {
            throw new ApiException("Missing the required parameter 'xListenAPIKey' when calling spellcheck(Async)");
        }

        // verify the required parameter 'q' is set
        if (q == null) {
            throw new ApiException("Missing the required parameter 'q' when calling spellcheck(Async)");
        }

        return spellcheckCall(xListenAPIKey, q, _callback);

    }

    /**
     * Spell check on a search term
     * Suggest a list of words that correct the spelling errors of a search term. This endpoint is available only in the PRO/ENTERPRISE plan.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic...  (required)
     * @return SpellCheckResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public SpellCheckResponse spellcheck(String xListenAPIKey, String q) throws ApiException {
        ApiResponse<SpellCheckResponse> localVarResp = spellcheckWithHttpInfo(xListenAPIKey, q);
        return localVarResp.getData();
    }

    /**
     * Spell check on a search term
     * Suggest a list of words that correct the spelling errors of a search term. This endpoint is available only in the PRO/ENTERPRISE plan.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic...  (required)
     * @return ApiResponse&lt;SpellCheckResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SpellCheckResponse> spellcheckWithHttpInfo(String xListenAPIKey, String q) throws ApiException {
        okhttp3.Call localVarCall = spellcheckValidateBeforeCall(xListenAPIKey, q, null);
        Type localVarReturnType = new TypeToken<SpellCheckResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Spell check on a search term (asynchronously)
     * Suggest a list of words that correct the spelling errors of a search term. This endpoint is available only in the PRO/ENTERPRISE plan.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic...  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call spellcheckAsync(String xListenAPIKey, String q, final ApiCallback<SpellCheckResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = spellcheckValidateBeforeCall(xListenAPIKey, q, _callback);
        Type localVarReturnType = new TypeToken<SpellCheckResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for typeahead
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., \&quot;game of thrones\&quot;. Otherwise, it&#39;s fuzzy search.  (required)
     * @param showPodcasts Autosuggest podcasts. This only searches podcast title and publisher and returns very limited info of 5 podcasts. 1 is yes, 0 is no. It&#39;s a bit slow to autosuggest podcasts, so we turn it off by default. If show_podcasts&#x3D;1, you can also pass iTunes id (e.g., 474722933) to the q parameter to fetch podcast meta data.  (optional, default to 0)
     * @param showGenres Whether or not to autosuggest genres. 1 is yes, 0 is no.  (optional, default to 0)
     * @param safeMode Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **show_podcasts** is *1*.  (optional, default to 0)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call typeaheadCall(String xListenAPIKey, String q, Integer showPodcasts, Integer showGenres, Integer safeMode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/typeahead";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (showPodcasts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("show_podcasts", showPodcasts));
        }

        if (showGenres != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("show_genres", showGenres));
        }

        if (safeMode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("safe_mode", safeMode));
        }

        if (xListenAPIKey != null) {
            localVarHeaderParams.put("X-ListenAPI-Key", localVarApiClient.parameterToString(xListenAPIKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call typeaheadValidateBeforeCall(String xListenAPIKey, String q, Integer showPodcasts, Integer showGenres, Integer safeMode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xListenAPIKey' is set
        if (xListenAPIKey == null) {
            throw new ApiException("Missing the required parameter 'xListenAPIKey' when calling typeahead(Async)");
        }

        // verify the required parameter 'q' is set
        if (q == null) {
            throw new ApiException("Missing the required parameter 'q' when calling typeahead(Async)");
        }

        return typeaheadCall(xListenAPIKey, q, showPodcasts, showGenres, safeMode, _callback);

    }

    /**
     * Typeahead search
     * Suggest search terms, podcast genres, and podcasts.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., \&quot;game of thrones\&quot;. Otherwise, it&#39;s fuzzy search.  (required)
     * @param showPodcasts Autosuggest podcasts. This only searches podcast title and publisher and returns very limited info of 5 podcasts. 1 is yes, 0 is no. It&#39;s a bit slow to autosuggest podcasts, so we turn it off by default. If show_podcasts&#x3D;1, you can also pass iTunes id (e.g., 474722933) to the q parameter to fetch podcast meta data.  (optional, default to 0)
     * @param showGenres Whether or not to autosuggest genres. 1 is yes, 0 is no.  (optional, default to 0)
     * @param safeMode Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **show_podcasts** is *1*.  (optional, default to 0)
     * @return TypeaheadResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public TypeaheadResponse typeahead(String xListenAPIKey, String q, Integer showPodcasts, Integer showGenres, Integer safeMode) throws ApiException {
        ApiResponse<TypeaheadResponse> localVarResp = typeaheadWithHttpInfo(xListenAPIKey, q, showPodcasts, showGenres, safeMode);
        return localVarResp.getData();
    }

    /**
     * Typeahead search
     * Suggest search terms, podcast genres, and podcasts.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., \&quot;game of thrones\&quot;. Otherwise, it&#39;s fuzzy search.  (required)
     * @param showPodcasts Autosuggest podcasts. This only searches podcast title and publisher and returns very limited info of 5 podcasts. 1 is yes, 0 is no. It&#39;s a bit slow to autosuggest podcasts, so we turn it off by default. If show_podcasts&#x3D;1, you can also pass iTunes id (e.g., 474722933) to the q parameter to fetch podcast meta data.  (optional, default to 0)
     * @param showGenres Whether or not to autosuggest genres. 1 is yes, 0 is no.  (optional, default to 0)
     * @param safeMode Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **show_podcasts** is *1*.  (optional, default to 0)
     * @return ApiResponse&lt;TypeaheadResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TypeaheadResponse> typeaheadWithHttpInfo(String xListenAPIKey, String q, Integer showPodcasts, Integer showGenres, Integer safeMode) throws ApiException {
        okhttp3.Call localVarCall = typeaheadValidateBeforeCall(xListenAPIKey, q, showPodcasts, showGenres, safeMode, null);
        Type localVarReturnType = new TypeToken<TypeaheadResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Typeahead search (asynchronously)
     * Suggest search terms, podcast genres, and podcasts.
     * @param xListenAPIKey Get API Key on listennotes.com/api (required)
     * @param q Search term, e.g., person, place, topic... You can use double quotes to do verbatim match, e.g., \&quot;game of thrones\&quot;. Otherwise, it&#39;s fuzzy search.  (required)
     * @param showPodcasts Autosuggest podcasts. This only searches podcast title and publisher and returns very limited info of 5 podcasts. 1 is yes, 0 is no. It&#39;s a bit slow to autosuggest podcasts, so we turn it off by default. If show_podcasts&#x3D;1, you can also pass iTunes id (e.g., 474722933) to the q parameter to fetch podcast meta data.  (optional, default to 0)
     * @param showGenres Whether or not to autosuggest genres. 1 is yes, 0 is no.  (optional, default to 0)
     * @param safeMode Whether or not to exclude podcasts/episodes with explicit language. 1 is yes and 0 is no. It works only when **show_podcasts** is *1*.  (optional, default to 0)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * X-ListenAPI-FreeQuota -  <br>  * X-ListenAPI-NextBillingDate -  <br>  * X-ListenAPI-Usage -  <br>  * X-listenAPI-Latency-Seconds -  <br>  </td></tr>
        <tr><td> 400 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 5XX </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call typeaheadAsync(String xListenAPIKey, String q, Integer showPodcasts, Integer showGenres, Integer safeMode, final ApiCallback<TypeaheadResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = typeaheadValidateBeforeCall(xListenAPIKey, q, showPodcasts, showGenres, safeMode, _callback);
        Type localVarReturnType = new TypeToken<TypeaheadResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
