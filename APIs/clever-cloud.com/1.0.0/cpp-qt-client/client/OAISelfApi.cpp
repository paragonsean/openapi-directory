/**
 * Clever-Cloud API
 * Public API for managing Clever-Cloud data and products
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAISelfApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAISelfApi::OAISelfApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAISelfApi::~OAISelfApi() {
}

void OAISelfApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api.clever-cloud.com/v2"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("deleteSelfAddonsAddonIdTagsTag", defaultConf);
    _serverIndices.insert("deleteSelfAddonsAddonIdTagsTag", 0);
    _serverConfigs.insert("deleteSelfAddonsAddonId", defaultConf);
    _serverIndices.insert("deleteSelfAddonsAddonId", 0);
    _serverConfigs.insert("deleteSelfApplicationsAppIdAddonsAddonId", defaultConf);
    _serverIndices.insert("deleteSelfApplicationsAppIdAddonsAddonId", 0);
    _serverConfigs.insert("deleteSelfApplicationsAppIdDependenciesDependencyId", defaultConf);
    _serverIndices.insert("deleteSelfApplicationsAppIdDependenciesDependencyId", 0);
    _serverConfigs.insert("deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstances", defaultConf);
    _serverIndices.insert("deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstances", 0);
    _serverConfigs.insert("deleteSelfApplicationsAppIdEnvEnvName", defaultConf);
    _serverIndices.insert("deleteSelfApplicationsAppIdEnvEnvName", 0);
    _serverConfigs.insert("deleteSelfApplicationsAppIdInstances", defaultConf);
    _serverIndices.insert("deleteSelfApplicationsAppIdInstances", 0);
    _serverConfigs.insert("deleteSelfApplicationsAppIdTagsTag", defaultConf);
    _serverIndices.insert("deleteSelfApplicationsAppIdTagsTag", 0);
    _serverConfigs.insert("deleteSelfApplicationsAppIdVhostsDomain", defaultConf);
    _serverIndices.insert("deleteSelfApplicationsAppIdVhostsDomain", 0);
    _serverConfigs.insert("deleteSelfApplicationsAppIdVhostsFavourite", defaultConf);
    _serverIndices.insert("deleteSelfApplicationsAppIdVhostsFavourite", 0);
    _serverConfigs.insert("deleteSelfApplicationsAppId", defaultConf);
    _serverIndices.insert("deleteSelfApplicationsAppId", 0);
    _serverConfigs.insert("deleteSelfConsumersKey", defaultConf);
    _serverIndices.insert("deleteSelfConsumersKey", 0);
    _serverConfigs.insert("deleteSelfEmailsEmail", defaultConf);
    _serverIndices.insert("deleteSelfEmailsEmail", 0);
    _serverConfigs.insert("deleteSelfKeysKey", defaultConf);
    _serverIndices.insert("deleteSelfKeysKey", 0);
    _serverConfigs.insert("deleteSelfPaymentsBillingsBid", defaultConf);
    _serverIndices.insert("deleteSelfPaymentsBillingsBid", 0);
    _serverConfigs.insert("deleteSelfPaymentsMethodsMId", defaultConf);
    _serverIndices.insert("deleteSelfPaymentsMethodsMId", 0);
    _serverConfigs.insert("deleteSelfPaymentsRecurring", defaultConf);
    _serverIndices.insert("deleteSelfPaymentsRecurring", 0);
    _serverConfigs.insert("deleteSelfTokensToken", defaultConf);
    _serverIndices.insert("deleteSelfTokensToken", 0);
    _serverConfigs.insert("deleteSelfTokens", defaultConf);
    _serverIndices.insert("deleteSelfTokens", 0);
    _serverConfigs.insert("deleteSelf", defaultConf);
    _serverIndices.insert("deleteSelf", 0);
    _serverConfigs.insert("getSelfAddonsAddonIdApplications", defaultConf);
    _serverIndices.insert("getSelfAddonsAddonIdApplications", 0);
    _serverConfigs.insert("getSelfAddonsAddonIdEnv", defaultConf);
    _serverIndices.insert("getSelfAddonsAddonIdEnv", 0);
    _serverConfigs.insert("getSelfAddonsAddonIdSso", defaultConf);
    _serverIndices.insert("getSelfAddonsAddonIdSso", 0);
    _serverConfigs.insert("getSelfAddonsAddonIdTags", defaultConf);
    _serverIndices.insert("getSelfAddonsAddonIdTags", 0);
    _serverConfigs.insert("getSelfAddonsAddonId", defaultConf);
    _serverIndices.insert("getSelfAddonsAddonId", 0);
    _serverConfigs.insert("getSelfAddons", defaultConf);
    _serverIndices.insert("getSelfAddons", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdAddonsEnv", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdAddonsEnv", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdAddons", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdAddons", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdDependenciesDependencyId", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdDependenciesDependencyId", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdDependencies", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdDependencies", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdDependents", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdDependents", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdDeployments", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdDeployments", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdEnv", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdEnv", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdInstances", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdInstances", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdTags", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdTags", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdVhostsFavourite", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdVhostsFavourite", 0);
    _serverConfigs.insert("getSelfApplicationsAppIdVhosts", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppIdVhosts", 0);
    _serverConfigs.insert("getSelfApplicationsAppId", defaultConf);
    _serverIndices.insert("getSelfApplicationsAppId", 0);
    _serverConfigs.insert("getSelfApplications", defaultConf);
    _serverIndices.insert("getSelfApplications", 0);
    _serverConfigs.insert("getSelfConfirmationEmail", defaultConf);
    _serverIndices.insert("getSelfConfirmationEmail", 0);
    _serverConfigs.insert("getSelfConsumersKeySecret", defaultConf);
    _serverIndices.insert("getSelfConsumersKeySecret", 0);
    _serverConfigs.insert("getSelfConsumersKey", defaultConf);
    _serverIndices.insert("getSelfConsumersKey", 0);
    _serverConfigs.insert("getSelfConsumers", defaultConf);
    _serverIndices.insert("getSelfConsumers", 0);
    _serverConfigs.insert("getSelfConsumptions", defaultConf);
    _serverIndices.insert("getSelfConsumptions", 0);
    _serverConfigs.insert("getSelfCredits", defaultConf);
    _serverIndices.insert("getSelfCredits", 0);
    _serverConfigs.insert("getSelfEmails", defaultConf);
    _serverIndices.insert("getSelfEmails", 0);
    _serverConfigs.insert("getSelfId", defaultConf);
    _serverIndices.insert("getSelfId", 0);
    _serverConfigs.insert("getSelfInstances", defaultConf);
    _serverIndices.insert("getSelfInstances", 0);
    _serverConfigs.insert("getSelfKeys", defaultConf);
    _serverIndices.insert("getSelfKeys", 0);
    _serverConfigs.insert("getSelfPaymentInfo", defaultConf);
    _serverIndices.insert("getSelfPaymentInfo", 0);
    _serverConfigs.insert("getSelfPaymentsBillingsBidPdf", defaultConf);
    _serverIndices.insert("getSelfPaymentsBillingsBidPdf", 0);
    _serverConfigs.insert("getSelfPaymentsBillingsBid", defaultConf);
    _serverIndices.insert("getSelfPaymentsBillingsBid", 0);
    _serverConfigs.insert("getSelfPaymentsBillings", defaultConf);
    _serverIndices.insert("getSelfPaymentsBillings", 0);
    _serverConfigs.insert("getSelfPaymentsFullpricePrice", defaultConf);
    _serverIndices.insert("getSelfPaymentsFullpricePrice", 0);
    _serverConfigs.insert("getSelfPaymentsMethods", defaultConf);
    _serverIndices.insert("getSelfPaymentsMethods", 0);
    _serverConfigs.insert("getSelfTokens", defaultConf);
    _serverIndices.insert("getSelfTokens", 0);
    _serverConfigs.insert("getSelfValidateEmail", defaultConf);
    _serverIndices.insert("getSelfValidateEmail", 0);
    _serverConfigs.insert("getSelf", defaultConf);
    _serverIndices.insert("getSelf", 0);
    _serverConfigs.insert("postSelfAddons", defaultConf);
    _serverIndices.insert("postSelfAddons", 0);
    _serverConfigs.insert("postSelfApplicationsAppIdAddons", defaultConf);
    _serverIndices.insert("postSelfApplicationsAppIdAddons", 0);
    _serverConfigs.insert("postSelfApplicationsAppIdInstances", defaultConf);
    _serverIndices.insert("postSelfApplicationsAppIdInstances", 0);
    _serverConfigs.insert("postSelfApplications", defaultConf);
    _serverIndices.insert("postSelfApplications", 0);
    _serverConfigs.insert("postSelfConsumers", defaultConf);
    _serverIndices.insert("postSelfConsumers", 0);
    _serverConfigs.insert("postSelfPaymentsBillings", defaultConf);
    _serverIndices.insert("postSelfPaymentsBillings", 0);
    _serverConfigs.insert("postSelfPaymentsMethods", defaultConf);
    _serverIndices.insert("postSelfPaymentsMethods", 0);
    _serverConfigs.insert("putSelfAddonsAddonIdPlan", defaultConf);
    _serverIndices.insert("putSelfAddonsAddonIdPlan", 0);
    _serverConfigs.insert("putSelfAddonsAddonIdTagsTag", defaultConf);
    _serverIndices.insert("putSelfAddonsAddonIdTagsTag", 0);
    _serverConfigs.insert("putSelfAddonsAddonId", defaultConf);
    _serverIndices.insert("putSelfAddonsAddonId", 0);
    _serverConfigs.insert("putSelfApplicationsAppIdEnvEnvName", defaultConf);
    _serverIndices.insert("putSelfApplicationsAppIdEnvEnvName", 0);
    _serverConfigs.insert("putSelfApplicationsAppIdEnv", defaultConf);
    _serverIndices.insert("putSelfApplicationsAppIdEnv", 0);
    _serverConfigs.insert("putSelfApplicationsAppIdTagsTag", defaultConf);
    _serverIndices.insert("putSelfApplicationsAppIdTagsTag", 0);
    _serverConfigs.insert("putSelfApplicationsAppIdVhostsDomain", defaultConf);
    _serverIndices.insert("putSelfApplicationsAppIdVhostsDomain", 0);
    _serverConfigs.insert("putSelfApplicationsAppIdVhostsFavourite", defaultConf);
    _serverIndices.insert("putSelfApplicationsAppIdVhostsFavourite", 0);
    _serverConfigs.insert("putSelfApplicationsAppId", defaultConf);
    _serverIndices.insert("putSelfApplicationsAppId", 0);
    _serverConfigs.insert("putSelfAvatar", defaultConf);
    _serverIndices.insert("putSelfAvatar", 0);
    _serverConfigs.insert("putSelfChangePassword", defaultConf);
    _serverIndices.insert("putSelfChangePassword", 0);
    _serverConfigs.insert("putSelfConsumersKey", defaultConf);
    _serverIndices.insert("putSelfConsumersKey", 0);
    _serverConfigs.insert("putSelfEmailsEmail", defaultConf);
    _serverIndices.insert("putSelfEmailsEmail", 0);
    _serverConfigs.insert("putSelfKeysKey", defaultConf);
    _serverIndices.insert("putSelfKeysKey", 0);
    _serverConfigs.insert("putSelfPaymentsBillingsBid", defaultConf);
    _serverIndices.insert("putSelfPaymentsBillingsBid", 0);
    _serverConfigs.insert("putSelf", defaultConf);
    _serverIndices.insert("putSelf", 0);
    _serverConfigs.insert("selfAddonsPreordersPost", defaultConf);
    _serverIndices.insert("selfAddonsPreordersPost", 0);
    _serverConfigs.insert("selfApplicationsAppIdBranchPut", defaultConf);
    _serverIndices.insert("selfApplicationsAppIdBranchPut", 0);
    _serverConfigs.insert("selfApplicationsAppIdBranchesGet", defaultConf);
    _serverIndices.insert("selfApplicationsAppIdBranchesGet", 0);
    _serverConfigs.insert("selfApplicationsAppIdBuildflavorPut", defaultConf);
    _serverIndices.insert("selfApplicationsAppIdBuildflavorPut", 0);
    _serverConfigs.insert("selfApplicationsAppIdDependenciesEnvGet", defaultConf);
    _serverIndices.insert("selfApplicationsAppIdDependenciesEnvGet", 0);
    _serverConfigs.insert("selfApplicationsAppIdDeploymentsDeploymentIdGet", defaultConf);
    _serverIndices.insert("selfApplicationsAppIdDeploymentsDeploymentIdGet", 0);
    _serverConfigs.insert("selfApplicationsAppIdExposedEnvGet", defaultConf);
    _serverIndices.insert("selfApplicationsAppIdExposedEnvGet", 0);
    _serverConfigs.insert("selfApplicationsAppIdExposedEnvPut", defaultConf);
    _serverIndices.insert("selfApplicationsAppIdExposedEnvPut", 0);
    _serverConfigs.insert("selfApplicationsAppIdInstancesInstanceIdGet", defaultConf);
    _serverIndices.insert("selfApplicationsAppIdInstancesInstanceIdGet", 0);
    _serverConfigs.insert("selfCliTokensGet", defaultConf);
    _serverIndices.insert("selfCliTokensGet", 0);
    _serverConfigs.insert("selfMfaKindBackupcodesGet", defaultConf);
    _serverIndices.insert("selfMfaKindBackupcodesGet", 0);
    _serverConfigs.insert("selfMfaKindConfirmationPost", defaultConf);
    _serverIndices.insert("selfMfaKindConfirmationPost", 0);
    _serverConfigs.insert("selfMfaKindDelete", defaultConf);
    _serverIndices.insert("selfMfaKindDelete", 0);
    _serverConfigs.insert("selfMfaKindPost", defaultConf);
    _serverIndices.insert("selfMfaKindPost", 0);
    _serverConfigs.insert("selfMfaKindPut", defaultConf);
    _serverIndices.insert("selfMfaKindPut", 0);
    _serverConfigs.insert("selfPaymentsMethodsDefaultGet", defaultConf);
    _serverIndices.insert("selfPaymentsMethodsDefaultGet", 0);
    _serverConfigs.insert("selfPaymentsMethodsDefaultPut", defaultConf);
    _serverIndices.insert("selfPaymentsMethodsDefaultPut", 0);
    _serverConfigs.insert("selfPaymentsMonthlyinvoiceGet", defaultConf);
    _serverIndices.insert("selfPaymentsMonthlyinvoiceGet", 0);
    _serverConfigs.insert("selfPaymentsMonthlyinvoiceMaxcreditPut", defaultConf);
    _serverIndices.insert("selfPaymentsMonthlyinvoiceMaxcreditPut", 0);
    _serverConfigs.insert("selfPaymentsRecurringGet", defaultConf);
    _serverIndices.insert("selfPaymentsRecurringGet", 0);
    _serverConfigs.insert("selfPaymentsTokensStripeGet", defaultConf);
    _serverIndices.insert("selfPaymentsTokensStripeGet", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAISelfApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAISelfApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAISelfApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAISelfApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAISelfApi::setUsername(const QString &username) {
    _username = username;
}

void OAISelfApi::setPassword(const QString &password) {
    _password = password;
}


void OAISelfApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAISelfApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAISelfApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAISelfApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAISelfApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAISelfApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAISelfApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAISelfApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAISelfApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAISelfApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAISelfApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAISelfApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAISelfApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAISelfApi::deleteSelfAddonsAddonIdTagsTag(const QString &tag, const QString &addon_id) {
    QString fullPath = QString(_serverConfigs["deleteSelfAddonsAddonIdTagsTag"][_serverIndices.value("deleteSelfAddonsAddonIdTagsTag")].URL()+"/self/addons/{addonId}/tags/{tag}");
    
    
    {
        QString tagPathParam("{");
        tagPathParam.append("tag").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "tag", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"tag"+pathSuffix : pathPrefix;
        fullPath.replace(tagPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(tag)));
    }
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfAddonsAddonIdTagsTagCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfAddonsAddonIdTagsTagCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfAddonsAddonIdTagsTagSignal();
        Q_EMIT deleteSelfAddonsAddonIdTagsTagSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfAddonsAddonIdTagsTagSignalE(error_type, error_str);
        Q_EMIT deleteSelfAddonsAddonIdTagsTagSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfAddonsAddonIdTagsTagSignalError(error_type, error_str);
        Q_EMIT deleteSelfAddonsAddonIdTagsTagSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfAddonsAddonId(const QString &addon_id) {
    QString fullPath = QString(_serverConfigs["deleteSelfAddonsAddonId"][_serverIndices.value("deleteSelfAddonsAddonId")].URL()+"/self/addons/{addonId}");
    
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfAddonsAddonIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfAddonsAddonIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfAddonsAddonIdSignal();
        Q_EMIT deleteSelfAddonsAddonIdSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfAddonsAddonIdSignalE(error_type, error_str);
        Q_EMIT deleteSelfAddonsAddonIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfAddonsAddonIdSignalError(error_type, error_str);
        Q_EMIT deleteSelfAddonsAddonIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfApplicationsAppIdAddonsAddonId(const QString &app_id, const QString &addon_id) {
    QString fullPath = QString(_serverConfigs["deleteSelfApplicationsAppIdAddonsAddonId"][_serverIndices.value("deleteSelfApplicationsAppIdAddonsAddonId")].URL()+"/self/applications/{appId}/addons/{addonId}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfApplicationsAppIdAddonsAddonIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfApplicationsAppIdAddonsAddonIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfApplicationsAppIdAddonsAddonIdSignal();
        Q_EMIT deleteSelfApplicationsAppIdAddonsAddonIdSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfApplicationsAppIdAddonsAddonIdSignalE(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdAddonsAddonIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfApplicationsAppIdAddonsAddonIdSignalError(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdAddonsAddonIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfApplicationsAppIdDependenciesDependencyId(const QString &dependency_id, const QString &app_id) {
    QString fullPath = QString(_serverConfigs["deleteSelfApplicationsAppIdDependenciesDependencyId"][_serverIndices.value("deleteSelfApplicationsAppIdDependenciesDependencyId")].URL()+"/self/applications/{appId}/dependencies/{dependencyId}");
    
    
    {
        QString dependency_idPathParam("{");
        dependency_idPathParam.append("dependencyId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "dependencyId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"dependencyId"+pathSuffix : pathPrefix;
        fullPath.replace(dependency_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dependency_id)));
    }
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfApplicationsAppIdDependenciesDependencyIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfApplicationsAppIdDependenciesDependencyIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfApplicationsAppIdDependenciesDependencyIdSignal();
        Q_EMIT deleteSelfApplicationsAppIdDependenciesDependencyIdSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfApplicationsAppIdDependenciesDependencyIdSignalE(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdDependenciesDependencyIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfApplicationsAppIdDependenciesDependencyIdSignalError(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdDependenciesDependencyIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstances(const QString &app_id, const QString &deployment_id) {
    QString fullPath = QString(_serverConfigs["deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstances"][_serverIndices.value("deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstances")].URL()+"/self/applications/{appId}/deployments/{deploymentId}/instances");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    
    {
        QString deployment_idPathParam("{");
        deployment_idPathParam.append("deploymentId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "deploymentId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"deploymentId"+pathSuffix : pathPrefix;
        fullPath.replace(deployment_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(deployment_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstancesCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstancesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstancesSignal();
        Q_EMIT deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstancesSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstancesSignalE(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstancesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstancesSignalError(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdDeploymentsDeploymentIdInstancesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfApplicationsAppIdEnvEnvName(const QString &app_id, const QString &env_name) {
    QString fullPath = QString(_serverConfigs["deleteSelfApplicationsAppIdEnvEnvName"][_serverIndices.value("deleteSelfApplicationsAppIdEnvEnvName")].URL()+"/self/applications/{appId}/env/{envName}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    
    {
        QString env_namePathParam("{");
        env_namePathParam.append("envName").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "envName", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"envName"+pathSuffix : pathPrefix;
        fullPath.replace(env_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(env_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfApplicationsAppIdEnvEnvNameCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfApplicationsAppIdEnvEnvNameCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfApplicationsAppIdEnvEnvNameSignal();
        Q_EMIT deleteSelfApplicationsAppIdEnvEnvNameSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfApplicationsAppIdEnvEnvNameSignalE(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdEnvEnvNameSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfApplicationsAppIdEnvEnvNameSignalError(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdEnvEnvNameSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfApplicationsAppIdInstances(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["deleteSelfApplicationsAppIdInstances"][_serverIndices.value("deleteSelfApplicationsAppIdInstances")].URL()+"/self/applications/{appId}/instances");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfApplicationsAppIdInstancesCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfApplicationsAppIdInstancesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfApplicationsAppIdInstancesSignal();
        Q_EMIT deleteSelfApplicationsAppIdInstancesSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfApplicationsAppIdInstancesSignalE(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdInstancesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfApplicationsAppIdInstancesSignalError(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdInstancesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfApplicationsAppIdTagsTag(const QString &app_id, const QString &tag) {
    QString fullPath = QString(_serverConfigs["deleteSelfApplicationsAppIdTagsTag"][_serverIndices.value("deleteSelfApplicationsAppIdTagsTag")].URL()+"/self/applications/{appId}/tags/{tag}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    
    {
        QString tagPathParam("{");
        tagPathParam.append("tag").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "tag", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"tag"+pathSuffix : pathPrefix;
        fullPath.replace(tagPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(tag)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfApplicationsAppIdTagsTagCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfApplicationsAppIdTagsTagCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfApplicationsAppIdTagsTagSignal();
        Q_EMIT deleteSelfApplicationsAppIdTagsTagSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfApplicationsAppIdTagsTagSignalE(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdTagsTagSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfApplicationsAppIdTagsTagSignalError(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdTagsTagSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfApplicationsAppIdVhostsDomain(const QString &app_id, const QString &domain) {
    QString fullPath = QString(_serverConfigs["deleteSelfApplicationsAppIdVhostsDomain"][_serverIndices.value("deleteSelfApplicationsAppIdVhostsDomain")].URL()+"/self/applications/{appId}/vhosts/{domain}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    
    {
        QString domainPathParam("{");
        domainPathParam.append("domain").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "domain", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"domain"+pathSuffix : pathPrefix;
        fullPath.replace(domainPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(domain)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfApplicationsAppIdVhostsDomainCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfApplicationsAppIdVhostsDomainCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfApplicationsAppIdVhostsDomainSignal();
        Q_EMIT deleteSelfApplicationsAppIdVhostsDomainSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfApplicationsAppIdVhostsDomainSignalE(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdVhostsDomainSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfApplicationsAppIdVhostsDomainSignalError(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdVhostsDomainSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfApplicationsAppIdVhostsFavourite(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["deleteSelfApplicationsAppIdVhostsFavourite"][_serverIndices.value("deleteSelfApplicationsAppIdVhostsFavourite")].URL()+"/self/applications/{appId}/vhosts/favourite");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfApplicationsAppIdVhostsFavouriteCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfApplicationsAppIdVhostsFavouriteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfApplicationsAppIdVhostsFavouriteSignal();
        Q_EMIT deleteSelfApplicationsAppIdVhostsFavouriteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfApplicationsAppIdVhostsFavouriteSignalE(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdVhostsFavouriteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfApplicationsAppIdVhostsFavouriteSignalError(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdVhostsFavouriteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfApplicationsAppId(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["deleteSelfApplicationsAppId"][_serverIndices.value("deleteSelfApplicationsAppId")].URL()+"/self/applications/{appId}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfApplicationsAppIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfApplicationsAppIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfApplicationsAppIdSignal();
        Q_EMIT deleteSelfApplicationsAppIdSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfApplicationsAppIdSignalE(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfApplicationsAppIdSignalError(error_type, error_str);
        Q_EMIT deleteSelfApplicationsAppIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfConsumersKey(const QString &key) {
    QString fullPath = QString(_serverConfigs["deleteSelfConsumersKey"][_serverIndices.value("deleteSelfConsumersKey")].URL()+"/self/consumers/{key}");
    
    
    {
        QString keyPathParam("{");
        keyPathParam.append("key").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "key", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"key"+pathSuffix : pathPrefix;
        fullPath.replace(keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfConsumersKeyCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfConsumersKeyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfConsumersKeySignal();
        Q_EMIT deleteSelfConsumersKeySignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfConsumersKeySignalE(error_type, error_str);
        Q_EMIT deleteSelfConsumersKeySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfConsumersKeySignalError(error_type, error_str);
        Q_EMIT deleteSelfConsumersKeySignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfEmailsEmail(const QString &email) {
    QString fullPath = QString(_serverConfigs["deleteSelfEmailsEmail"][_serverIndices.value("deleteSelfEmailsEmail")].URL()+"/self/emails/{email}");
    
    
    {
        QString emailPathParam("{");
        emailPathParam.append("email").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "email", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"email"+pathSuffix : pathPrefix;
        fullPath.replace(emailPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(email)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfEmailsEmailCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfEmailsEmailCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfEmailsEmailSignal();
        Q_EMIT deleteSelfEmailsEmailSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfEmailsEmailSignalE(error_type, error_str);
        Q_EMIT deleteSelfEmailsEmailSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfEmailsEmailSignalError(error_type, error_str);
        Q_EMIT deleteSelfEmailsEmailSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfKeysKey(const QString &key) {
    QString fullPath = QString(_serverConfigs["deleteSelfKeysKey"][_serverIndices.value("deleteSelfKeysKey")].URL()+"/self/keys/{key}");
    
    
    {
        QString keyPathParam("{");
        keyPathParam.append("key").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "key", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"key"+pathSuffix : pathPrefix;
        fullPath.replace(keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfKeysKeyCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfKeysKeyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfKeysKeySignal();
        Q_EMIT deleteSelfKeysKeySignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfKeysKeySignalE(error_type, error_str);
        Q_EMIT deleteSelfKeysKeySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfKeysKeySignalError(error_type, error_str);
        Q_EMIT deleteSelfKeysKeySignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfPaymentsBillingsBid(const QString &bid) {
    QString fullPath = QString(_serverConfigs["deleteSelfPaymentsBillingsBid"][_serverIndices.value("deleteSelfPaymentsBillingsBid")].URL()+"/self/payments/billings/{bid}");
    
    
    {
        QString bidPathParam("{");
        bidPathParam.append("bid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "bid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"bid"+pathSuffix : pathPrefix;
        fullPath.replace(bidPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(bid)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfPaymentsBillingsBidCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfPaymentsBillingsBidCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfPaymentsBillingsBidSignal();
        Q_EMIT deleteSelfPaymentsBillingsBidSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfPaymentsBillingsBidSignalE(error_type, error_str);
        Q_EMIT deleteSelfPaymentsBillingsBidSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfPaymentsBillingsBidSignalError(error_type, error_str);
        Q_EMIT deleteSelfPaymentsBillingsBidSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfPaymentsMethodsMId(const QString &m_id) {
    QString fullPath = QString(_serverConfigs["deleteSelfPaymentsMethodsMId"][_serverIndices.value("deleteSelfPaymentsMethodsMId")].URL()+"/self/payments/methods/{mId}");
    
    
    {
        QString m_idPathParam("{");
        m_idPathParam.append("mId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "mId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"mId"+pathSuffix : pathPrefix;
        fullPath.replace(m_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(m_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfPaymentsMethodsMIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfPaymentsMethodsMIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfPaymentsMethodsMIdSignal();
        Q_EMIT deleteSelfPaymentsMethodsMIdSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfPaymentsMethodsMIdSignalE(error_type, error_str);
        Q_EMIT deleteSelfPaymentsMethodsMIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfPaymentsMethodsMIdSignalError(error_type, error_str);
        Q_EMIT deleteSelfPaymentsMethodsMIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfPaymentsRecurring() {
    QString fullPath = QString(_serverConfigs["deleteSelfPaymentsRecurring"][_serverIndices.value("deleteSelfPaymentsRecurring")].URL()+"/self/payments/recurring");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfPaymentsRecurringCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfPaymentsRecurringCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfPaymentsRecurringSignal();
        Q_EMIT deleteSelfPaymentsRecurringSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfPaymentsRecurringSignalE(error_type, error_str);
        Q_EMIT deleteSelfPaymentsRecurringSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfPaymentsRecurringSignalError(error_type, error_str);
        Q_EMIT deleteSelfPaymentsRecurringSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfTokensToken(const QString &token) {
    QString fullPath = QString(_serverConfigs["deleteSelfTokensToken"][_serverIndices.value("deleteSelfTokensToken")].URL()+"/self/tokens/{token}");
    
    
    {
        QString tokenPathParam("{");
        tokenPathParam.append("token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"token"+pathSuffix : pathPrefix;
        fullPath.replace(tokenPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(token)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfTokensTokenCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfTokensTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfTokensTokenSignal();
        Q_EMIT deleteSelfTokensTokenSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfTokensTokenSignalE(error_type, error_str);
        Q_EMIT deleteSelfTokensTokenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfTokensTokenSignalError(error_type, error_str);
        Q_EMIT deleteSelfTokensTokenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelfTokens() {
    QString fullPath = QString(_serverConfigs["deleteSelfTokens"][_serverIndices.value("deleteSelfTokens")].URL()+"/self/tokens");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfTokensCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfTokensCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfTokensSignal();
        Q_EMIT deleteSelfTokensSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfTokensSignalE(error_type, error_str);
        Q_EMIT deleteSelfTokensSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfTokensSignalError(error_type, error_str);
        Q_EMIT deleteSelfTokensSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::deleteSelf() {
    QString fullPath = QString(_serverConfigs["deleteSelf"][_serverIndices.value("deleteSelf")].URL()+"/self");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::deleteSelfCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::deleteSelfCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteSelfSignal();
        Q_EMIT deleteSelfSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteSelfSignalE(error_type, error_str);
        Q_EMIT deleteSelfSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteSelfSignalError(error_type, error_str);
        Q_EMIT deleteSelfSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfAddonsAddonIdApplications(const QString &addon_id) {
    QString fullPath = QString(_serverConfigs["getSelfAddonsAddonIdApplications"][_serverIndices.value("getSelfAddonsAddonIdApplications")].URL()+"/self/addons/{addonId}/applications");
    
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfAddonsAddonIdApplicationsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfAddonsAddonIdApplicationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplication> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplication val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfAddonsAddonIdApplicationsSignal(output);
        Q_EMIT getSelfAddonsAddonIdApplicationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfAddonsAddonIdApplicationsSignalE(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdApplicationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfAddonsAddonIdApplicationsSignalError(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdApplicationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfAddonsAddonIdEnv(const QString &addon_id) {
    QString fullPath = QString(_serverConfigs["getSelfAddonsAddonIdEnv"][_serverIndices.value("getSelfAddonsAddonIdEnv")].URL()+"/self/addons/{addonId}/env");
    
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfAddonsAddonIdEnvCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfAddonsAddonIdEnvCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIListEnv> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIListEnv val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfAddonsAddonIdEnvSignal(output);
        Q_EMIT getSelfAddonsAddonIdEnvSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfAddonsAddonIdEnvSignalE(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdEnvSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfAddonsAddonIdEnvSignalError(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdEnvSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfAddonsAddonIdSso(const QString &addon_id) {
    QString fullPath = QString(_serverConfigs["getSelfAddonsAddonIdSso"][_serverIndices.value("getSelfAddonsAddonIdSso")].URL()+"/self/addons/{addonId}/sso");
    
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfAddonsAddonIdSsoCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfAddonsAddonIdSsoCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISso output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfAddonsAddonIdSsoSignal(output);
        Q_EMIT getSelfAddonsAddonIdSsoSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfAddonsAddonIdSsoSignalE(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdSsoSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfAddonsAddonIdSsoSignalError(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdSsoSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfAddonsAddonIdTags(const QString &addon_id) {
    QString fullPath = QString(_serverConfigs["getSelfAddonsAddonIdTags"][_serverIndices.value("getSelfAddonsAddonIdTags")].URL()+"/self/addons/{addonId}/tags");
    
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfAddonsAddonIdTagsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfAddonsAddonIdTagsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfAddonsAddonIdTagsSignal(output);
        Q_EMIT getSelfAddonsAddonIdTagsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfAddonsAddonIdTagsSignalE(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdTagsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfAddonsAddonIdTagsSignalError(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdTagsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfAddonsAddonId(const QString &addon_id) {
    QString fullPath = QString(_serverConfigs["getSelfAddonsAddonId"][_serverIndices.value("getSelfAddonsAddonId")].URL()+"/self/addons/{addonId}");
    
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfAddonsAddonIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfAddonsAddonIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAddon output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfAddonsAddonIdSignal(output);
        Q_EMIT getSelfAddonsAddonIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfAddonsAddonIdSignalE(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfAddonsAddonIdSignalError(output, error_type, error_str);
        Q_EMIT getSelfAddonsAddonIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfAddons() {
    QString fullPath = QString(_serverConfigs["getSelfAddons"][_serverIndices.value("getSelfAddons")].URL()+"/self/addons");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfAddonsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfAddonsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIAddon> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIAddon val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfAddonsSignal(output);
        Q_EMIT getSelfAddonsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfAddonsSignalE(output, error_type, error_str);
        Q_EMIT getSelfAddonsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfAddonsSignalError(output, error_type, error_str);
        Q_EMIT getSelfAddonsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdAddonsEnv(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdAddonsEnv"][_serverIndices.value("getSelfApplicationsAppIdAddonsEnv")].URL()+"/self/applications/{appId}/addons/env");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdAddonsEnvCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdAddonsEnvCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIEnv> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIEnv val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdAddonsEnvSignal(output);
        Q_EMIT getSelfApplicationsAppIdAddonsEnvSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdAddonsEnvSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdAddonsEnvSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdAddonsEnvSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdAddonsEnvSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdAddons(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdAddons"][_serverIndices.value("getSelfApplicationsAppIdAddons")].URL()+"/self/applications/{appId}/addons");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdAddonsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdAddonsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIAddon> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIAddon val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdAddonsSignal(output);
        Q_EMIT getSelfApplicationsAppIdAddonsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdAddonsSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdAddonsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdAddonsSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdAddonsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdDependenciesDependencyId(const QString &dependency_id, const QString &app_id, const OAIWannabeApplication &oai_wannabe_application) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdDependenciesDependencyId"][_serverIndices.value("getSelfApplicationsAppIdDependenciesDependencyId")].URL()+"/self/applications/{appId}/dependencies/{dependencyId}");
    
    
    {
        QString dependency_idPathParam("{");
        dependency_idPathParam.append("dependencyId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "dependencyId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"dependencyId"+pathSuffix : pathPrefix;
        fullPath.replace(dependency_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(dependency_id)));
    }
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_wannabe_application.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdDependenciesDependencyIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdDependenciesDependencyIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdDependenciesDependencyIdSignal();
        Q_EMIT getSelfApplicationsAppIdDependenciesDependencyIdSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdDependenciesDependencyIdSignalE(error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdDependenciesDependencyIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdDependenciesDependencyIdSignalError(error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdDependenciesDependencyIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdDependencies(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdDependencies"][_serverIndices.value("getSelfApplicationsAppIdDependencies")].URL()+"/self/applications/{appId}/dependencies");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdDependenciesCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdDependenciesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplication> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplication val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdDependenciesSignal(output);
        Q_EMIT getSelfApplicationsAppIdDependenciesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdDependenciesSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdDependenciesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdDependenciesSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdDependenciesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdDependents(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdDependents"][_serverIndices.value("getSelfApplicationsAppIdDependents")].URL()+"/self/applications/{appId}/dependents");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdDependentsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdDependentsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplication> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplication val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdDependentsSignal(output);
        Q_EMIT getSelfApplicationsAppIdDependentsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdDependentsSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdDependentsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdDependentsSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdDependentsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdDeployments(const QString &app_id, const ::OpenAPI::OptionalParam<QString> &limit, const ::OpenAPI::OptionalParam<QString> &offset, const ::OpenAPI::OptionalParam<QString> &action) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdDeployments"][_serverIndices.value("getSelfApplicationsAppIdDeployments")].URL()+"/self/applications/{appId}/deployments");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(limit.stringValue()));
    }
    if (offset.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(offset.stringValue()));
    }
    if (action.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "action", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("action")).append(querySuffix).append(QUrl::toPercentEncoding(action.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdDeploymentsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdDeploymentsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIDeployment> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIDeployment val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdDeploymentsSignal(output);
        Q_EMIT getSelfApplicationsAppIdDeploymentsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdDeploymentsSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdDeploymentsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdDeploymentsSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdDeploymentsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdEnv(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdEnv"][_serverIndices.value("getSelfApplicationsAppIdEnv")].URL()+"/self/applications/{appId}/env");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdEnvCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdEnvCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIListEnv> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIListEnv val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdEnvSignal(output);
        Q_EMIT getSelfApplicationsAppIdEnvSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdEnvSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdEnvSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdEnvSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdEnvSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdInstances(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdInstances"][_serverIndices.value("getSelfApplicationsAppIdInstances")].URL()+"/self/applications/{appId}/instances");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdInstancesCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdInstancesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIInstance> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIInstance val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdInstancesSignal(output);
        Q_EMIT getSelfApplicationsAppIdInstancesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdInstancesSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdInstancesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdInstancesSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdInstancesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdTags(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdTags"][_serverIndices.value("getSelfApplicationsAppIdTags")].URL()+"/self/applications/{appId}/tags");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdTagsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdTagsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdTagsSignal(output);
        Q_EMIT getSelfApplicationsAppIdTagsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdTagsSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdTagsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdTagsSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdTagsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdVhostsFavourite(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdVhostsFavourite"][_serverIndices.value("getSelfApplicationsAppIdVhostsFavourite")].URL()+"/self/applications/{appId}/vhosts/favourite");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdVhostsFavouriteCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdVhostsFavouriteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIVhost output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdVhostsFavouriteSignal(output);
        Q_EMIT getSelfApplicationsAppIdVhostsFavouriteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdVhostsFavouriteSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdVhostsFavouriteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdVhostsFavouriteSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdVhostsFavouriteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppIdVhosts(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppIdVhosts"][_serverIndices.value("getSelfApplicationsAppIdVhosts")].URL()+"/self/applications/{appId}/vhosts");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdVhostsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdVhostsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIVhost> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIVhost val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdVhostsSignal(output);
        Q_EMIT getSelfApplicationsAppIdVhostsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdVhostsSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdVhostsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdVhostsSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdVhostsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplicationsAppId(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["getSelfApplicationsAppId"][_serverIndices.value("getSelfApplicationsAppId")].URL()+"/self/applications/{appId}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsAppIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsAppIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplication output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsAppIdSignal(output);
        Q_EMIT getSelfApplicationsAppIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsAppIdSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsAppIdSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsAppIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfApplications() {
    QString fullPath = QString(_serverConfigs["getSelfApplications"][_serverIndices.value("getSelfApplications")].URL()+"/self/applications");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfApplicationsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfApplicationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplication> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplication val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfApplicationsSignal(output);
        Q_EMIT getSelfApplicationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfApplicationsSignalE(output, error_type, error_str);
        Q_EMIT getSelfApplicationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfApplicationsSignalError(output, error_type, error_str);
        Q_EMIT getSelfApplicationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfConfirmationEmail() {
    QString fullPath = QString(_serverConfigs["getSelfConfirmationEmail"][_serverIndices.value("getSelfConfirmationEmail")].URL()+"/self/confirmation_email");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfConfirmationEmailCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfConfirmationEmailCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfConfirmationEmailSignal();
        Q_EMIT getSelfConfirmationEmailSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfConfirmationEmailSignalE(error_type, error_str);
        Q_EMIT getSelfConfirmationEmailSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfConfirmationEmailSignalError(error_type, error_str);
        Q_EMIT getSelfConfirmationEmailSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfConsumersKeySecret(const QString &key) {
    QString fullPath = QString(_serverConfigs["getSelfConsumersKeySecret"][_serverIndices.value("getSelfConsumersKeySecret")].URL()+"/self/consumers/{key}/secret");
    
    
    {
        QString keyPathParam("{");
        keyPathParam.append("key").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "key", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"key"+pathSuffix : pathPrefix;
        fullPath.replace(keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfConsumersKeySecretCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfConsumersKeySecretCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISecret output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfConsumersKeySecretSignal(output);
        Q_EMIT getSelfConsumersKeySecretSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfConsumersKeySecretSignalE(output, error_type, error_str);
        Q_EMIT getSelfConsumersKeySecretSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfConsumersKeySecretSignalError(output, error_type, error_str);
        Q_EMIT getSelfConsumersKeySecretSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfConsumersKey(const QString &key) {
    QString fullPath = QString(_serverConfigs["getSelfConsumersKey"][_serverIndices.value("getSelfConsumersKey")].URL()+"/self/consumers/{key}");
    
    
    {
        QString keyPathParam("{");
        keyPathParam.append("key").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "key", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"key"+pathSuffix : pathPrefix;
        fullPath.replace(keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfConsumersKeyCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfConsumersKeyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIConsumer output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfConsumersKeySignal(output);
        Q_EMIT getSelfConsumersKeySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfConsumersKeySignalE(output, error_type, error_str);
        Q_EMIT getSelfConsumersKeySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfConsumersKeySignalError(output, error_type, error_str);
        Q_EMIT getSelfConsumersKeySignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfConsumers() {
    QString fullPath = QString(_serverConfigs["getSelfConsumers"][_serverIndices.value("getSelfConsumers")].URL()+"/self/consumers");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfConsumersCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfConsumersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIConsumer> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIConsumer val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfConsumersSignal(output);
        Q_EMIT getSelfConsumersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfConsumersSignalE(output, error_type, error_str);
        Q_EMIT getSelfConsumersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfConsumersSignalError(output, error_type, error_str);
        Q_EMIT getSelfConsumersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfConsumptions(const ::OpenAPI::OptionalParam<QString> &app_id, const ::OpenAPI::OptionalParam<QString> &from, const ::OpenAPI::OptionalParam<QString> &to) {
    QString fullPath = QString(_serverConfigs["getSelfConsumptions"][_serverIndices.value("getSelfConsumptions")].URL()+"/self/consumptions");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (app_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "appId", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("appId")).append(querySuffix).append(QUrl::toPercentEncoding(app_id.stringValue()));
    }
    if (from.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "from", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("from")).append(querySuffix).append(QUrl::toPercentEncoding(from.stringValue()));
    }
    if (to.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "to", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("to")).append(querySuffix).append(QUrl::toPercentEncoding(to.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfConsumptionsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfConsumptionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIConso output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfConsumptionsSignal(output);
        Q_EMIT getSelfConsumptionsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfConsumptionsSignalE(output, error_type, error_str);
        Q_EMIT getSelfConsumptionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfConsumptionsSignalError(output, error_type, error_str);
        Q_EMIT getSelfConsumptionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfCredits() {
    QString fullPath = QString(_serverConfigs["getSelfCredits"][_serverIndices.value("getSelfCredits")].URL()+"/self/credits");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfCreditsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfCreditsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICredits output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfCreditsSignal(output);
        Q_EMIT getSelfCreditsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfCreditsSignalE(output, error_type, error_str);
        Q_EMIT getSelfCreditsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfCreditsSignalError(output, error_type, error_str);
        Q_EMIT getSelfCreditsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfEmails() {
    QString fullPath = QString(_serverConfigs["getSelfEmails"][_serverIndices.value("getSelfEmails")].URL()+"/self/emails");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfEmailsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfEmailsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        QString val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfEmailsSignal(output);
        Q_EMIT getSelfEmailsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfEmailsSignalE(output, error_type, error_str);
        Q_EMIT getSelfEmailsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfEmailsSignalError(output, error_type, error_str);
        Q_EMIT getSelfEmailsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfId() {
    QString fullPath = QString(_serverConfigs["getSelfId"][_serverIndices.value("getSelfId")].URL()+"/self/id");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::OpenAPI::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfIdSignal(output);
        Q_EMIT getSelfIdSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfIdSignalE(output, error_type, error_str);
        Q_EMIT getSelfIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfIdSignalError(output, error_type, error_str);
        Q_EMIT getSelfIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfInstances() {
    QString fullPath = QString(_serverConfigs["getSelfInstances"][_serverIndices.value("getSelfInstances")].URL()+"/self/instances");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfInstancesCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfInstancesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIInstance> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIInstance val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfInstancesSignal(output);
        Q_EMIT getSelfInstancesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfInstancesSignalE(output, error_type, error_str);
        Q_EMIT getSelfInstancesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfInstancesSignalError(output, error_type, error_str);
        Q_EMIT getSelfInstancesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfKeys() {
    QString fullPath = QString(_serverConfigs["getSelfKeys"][_serverIndices.value("getSelfKeys")].URL()+"/self/keys");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfKeysCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfKeysCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIKey> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIKey val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfKeysSignal(output);
        Q_EMIT getSelfKeysSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfKeysSignalE(output, error_type, error_str);
        Q_EMIT getSelfKeysSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfKeysSignalError(output, error_type, error_str);
        Q_EMIT getSelfKeysSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfPaymentInfo() {
    QString fullPath = QString(_serverConfigs["getSelfPaymentInfo"][_serverIndices.value("getSelfPaymentInfo")].URL()+"/self/payment-info");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfPaymentInfoCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfPaymentInfoCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfPaymentInfoSignal();
        Q_EMIT getSelfPaymentInfoSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfPaymentInfoSignalE(error_type, error_str);
        Q_EMIT getSelfPaymentInfoSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfPaymentInfoSignalError(error_type, error_str);
        Q_EMIT getSelfPaymentInfoSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfPaymentsBillingsBidPdf(const QString &bid, const ::OpenAPI::OptionalParam<QString> &token) {
    QString fullPath = QString(_serverConfigs["getSelfPaymentsBillingsBidPdf"][_serverIndices.value("getSelfPaymentsBillingsBidPdf")].URL()+"/self/payments/billings/{bid}.pdf");
    
    
    {
        QString bidPathParam("{");
        bidPathParam.append("bid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "bid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"bid"+pathSuffix : pathPrefix;
        fullPath.replace(bidPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(bid)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (token.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "token", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("token")).append(querySuffix).append(QUrl::toPercentEncoding(token.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfPaymentsBillingsBidPdfCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfPaymentsBillingsBidPdfCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfPaymentsBillingsBidPdfSignal();
        Q_EMIT getSelfPaymentsBillingsBidPdfSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfPaymentsBillingsBidPdfSignalE(error_type, error_str);
        Q_EMIT getSelfPaymentsBillingsBidPdfSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfPaymentsBillingsBidPdfSignalError(error_type, error_str);
        Q_EMIT getSelfPaymentsBillingsBidPdfSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfPaymentsBillingsBid(const QString &bid) {
    QString fullPath = QString(_serverConfigs["getSelfPaymentsBillingsBid"][_serverIndices.value("getSelfPaymentsBillingsBid")].URL()+"/self/payments/billings/{bid}");
    
    
    {
        QString bidPathParam("{");
        bidPathParam.append("bid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "bid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"bid"+pathSuffix : pathPrefix;
        fullPath.replace(bidPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(bid)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfPaymentsBillingsBidCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfPaymentsBillingsBidCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfPaymentsBillingsBidSignal();
        Q_EMIT getSelfPaymentsBillingsBidSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfPaymentsBillingsBidSignalE(error_type, error_str);
        Q_EMIT getSelfPaymentsBillingsBidSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfPaymentsBillingsBidSignalError(error_type, error_str);
        Q_EMIT getSelfPaymentsBillingsBidSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfPaymentsBillings() {
    QString fullPath = QString(_serverConfigs["getSelfPaymentsBillings"][_serverIndices.value("getSelfPaymentsBillings")].URL()+"/self/payments/billings");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfPaymentsBillingsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfPaymentsBillingsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfPaymentsBillingsSignal();
        Q_EMIT getSelfPaymentsBillingsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfPaymentsBillingsSignalE(error_type, error_str);
        Q_EMIT getSelfPaymentsBillingsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfPaymentsBillingsSignalError(error_type, error_str);
        Q_EMIT getSelfPaymentsBillingsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfPaymentsFullpricePrice(const QString &price) {
    QString fullPath = QString(_serverConfigs["getSelfPaymentsFullpricePrice"][_serverIndices.value("getSelfPaymentsFullpricePrice")].URL()+"/self/payments/fullprice/{price}");
    
    
    {
        QString pricePathParam("{");
        pricePathParam.append("price").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "price", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"price"+pathSuffix : pathPrefix;
        fullPath.replace(pricePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(price)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfPaymentsFullpricePriceCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfPaymentsFullpricePriceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfPaymentsFullpricePriceSignal();
        Q_EMIT getSelfPaymentsFullpricePriceSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfPaymentsFullpricePriceSignalE(error_type, error_str);
        Q_EMIT getSelfPaymentsFullpricePriceSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfPaymentsFullpricePriceSignalError(error_type, error_str);
        Q_EMIT getSelfPaymentsFullpricePriceSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfPaymentsMethods() {
    QString fullPath = QString(_serverConfigs["getSelfPaymentsMethods"][_serverIndices.value("getSelfPaymentsMethods")].URL()+"/self/payments/methods");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfPaymentsMethodsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfPaymentsMethodsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfPaymentsMethodsSignal();
        Q_EMIT getSelfPaymentsMethodsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfPaymentsMethodsSignalE(error_type, error_str);
        Q_EMIT getSelfPaymentsMethodsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfPaymentsMethodsSignalError(error_type, error_str);
        Q_EMIT getSelfPaymentsMethodsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfTokens() {
    QString fullPath = QString(_serverConfigs["getSelfTokens"][_serverIndices.value("getSelfTokens")].URL()+"/self/tokens");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfTokensCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfTokensCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIToken> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIToken val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfTokensSignal(output);
        Q_EMIT getSelfTokensSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfTokensSignalE(output, error_type, error_str);
        Q_EMIT getSelfTokensSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfTokensSignalError(output, error_type, error_str);
        Q_EMIT getSelfTokensSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelfValidateEmail(const ::OpenAPI::OptionalParam<QString> &validation_key) {
    QString fullPath = QString(_serverConfigs["getSelfValidateEmail"][_serverIndices.value("getSelfValidateEmail")].URL()+"/self/validate_email");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (validation_key.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "validationKey", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("validationKey")).append(querySuffix).append(QUrl::toPercentEncoding(validation_key.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfValidateEmailCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfValidateEmailCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfValidateEmailSignal();
        Q_EMIT getSelfValidateEmailSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfValidateEmailSignalE(error_type, error_str);
        Q_EMIT getSelfValidateEmailSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfValidateEmailSignalError(error_type, error_str);
        Q_EMIT getSelfValidateEmailSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::getSelf() {
    QString fullPath = QString(_serverConfigs["getSelf"][_serverIndices.value("getSelf")].URL()+"/self");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::getSelfCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::getSelfCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUser output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfSignal(output);
        Q_EMIT getSelfSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfSignalE(output, error_type, error_str);
        Q_EMIT getSelfSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfSignalError(output, error_type, error_str);
        Q_EMIT getSelfSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::postSelfAddons(const OAIWannabeAddon &oai_wannabe_addon) {
    QString fullPath = QString(_serverConfigs["postSelfAddons"][_serverIndices.value("postSelfAddons")].URL()+"/self/addons");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wannabe_addon.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::postSelfAddonsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::postSelfAddonsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postSelfAddonsSignal();
        Q_EMIT postSelfAddonsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postSelfAddonsSignalE(error_type, error_str);
        Q_EMIT postSelfAddonsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postSelfAddonsSignalError(error_type, error_str);
        Q_EMIT postSelfAddonsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::postSelfApplicationsAppIdAddons(const QString &app_id, const OAIBody &oai_body) {
    QString fullPath = QString(_serverConfigs["postSelfApplicationsAppIdAddons"][_serverIndices.value("postSelfApplicationsAppIdAddons")].URL()+"/self/applications/{appId}/addons");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_body.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::postSelfApplicationsAppIdAddonsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::postSelfApplicationsAppIdAddonsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postSelfApplicationsAppIdAddonsSignal();
        Q_EMIT postSelfApplicationsAppIdAddonsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postSelfApplicationsAppIdAddonsSignalE(error_type, error_str);
        Q_EMIT postSelfApplicationsAppIdAddonsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postSelfApplicationsAppIdAddonsSignalError(error_type, error_str);
        Q_EMIT postSelfApplicationsAppIdAddonsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::postSelfApplicationsAppIdInstances(const QString &app_id, const ::OpenAPI::OptionalParam<QString> &commit) {
    QString fullPath = QString(_serverConfigs["postSelfApplicationsAppIdInstances"][_serverIndices.value("postSelfApplicationsAppIdInstances")].URL()+"/self/applications/{appId}/instances");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (commit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "commit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("commit")).append(querySuffix).append(QUrl::toPercentEncoding(commit.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::postSelfApplicationsAppIdInstancesCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::postSelfApplicationsAppIdInstancesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postSelfApplicationsAppIdInstancesSignal();
        Q_EMIT postSelfApplicationsAppIdInstancesSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postSelfApplicationsAppIdInstancesSignalE(error_type, error_str);
        Q_EMIT postSelfApplicationsAppIdInstancesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postSelfApplicationsAppIdInstancesSignalError(error_type, error_str);
        Q_EMIT postSelfApplicationsAppIdInstancesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::postSelfApplications(const OAIWannabeApplication &oai_wannabe_application) {
    QString fullPath = QString(_serverConfigs["postSelfApplications"][_serverIndices.value("postSelfApplications")].URL()+"/self/applications");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wannabe_application.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::postSelfApplicationsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::postSelfApplicationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postSelfApplicationsSignal();
        Q_EMIT postSelfApplicationsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postSelfApplicationsSignalE(error_type, error_str);
        Q_EMIT postSelfApplicationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postSelfApplicationsSignalError(error_type, error_str);
        Q_EMIT postSelfApplicationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::postSelfConsumers(const OAIWannabeConsumer &oai_wannabe_consumer) {
    QString fullPath = QString(_serverConfigs["postSelfConsumers"][_serverIndices.value("postSelfConsumers")].URL()+"/self/consumers");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wannabe_consumer.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::postSelfConsumersCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::postSelfConsumersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postSelfConsumersSignal();
        Q_EMIT postSelfConsumersSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postSelfConsumersSignalE(error_type, error_str);
        Q_EMIT postSelfConsumersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postSelfConsumersSignalError(error_type, error_str);
        Q_EMIT postSelfConsumersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::postSelfPaymentsBillings() {
    QString fullPath = QString(_serverConfigs["postSelfPaymentsBillings"][_serverIndices.value("postSelfPaymentsBillings")].URL()+"/self/payments/billings");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::postSelfPaymentsBillingsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::postSelfPaymentsBillingsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postSelfPaymentsBillingsSignal();
        Q_EMIT postSelfPaymentsBillingsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postSelfPaymentsBillingsSignalE(error_type, error_str);
        Q_EMIT postSelfPaymentsBillingsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postSelfPaymentsBillingsSignalError(error_type, error_str);
        Q_EMIT postSelfPaymentsBillingsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::postSelfPaymentsMethods() {
    QString fullPath = QString(_serverConfigs["postSelfPaymentsMethods"][_serverIndices.value("postSelfPaymentsMethods")].URL()+"/self/payments/methods");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::postSelfPaymentsMethodsCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::postSelfPaymentsMethodsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT postSelfPaymentsMethodsSignal();
        Q_EMIT postSelfPaymentsMethodsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT postSelfPaymentsMethodsSignalE(error_type, error_str);
        Q_EMIT postSelfPaymentsMethodsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT postSelfPaymentsMethodsSignalError(error_type, error_str);
        Q_EMIT postSelfPaymentsMethodsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfAddonsAddonIdPlan(const QString &addon_id, const OAIWannabePlan &oai_wannabe_plan) {
    QString fullPath = QString(_serverConfigs["putSelfAddonsAddonIdPlan"][_serverIndices.value("putSelfAddonsAddonIdPlan")].URL()+"/self/addons/{addonId}/plan");
    
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_wannabe_plan.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfAddonsAddonIdPlanCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfAddonsAddonIdPlanCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfAddonsAddonIdPlanSignal();
        Q_EMIT putSelfAddonsAddonIdPlanSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfAddonsAddonIdPlanSignalE(error_type, error_str);
        Q_EMIT putSelfAddonsAddonIdPlanSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfAddonsAddonIdPlanSignalError(error_type, error_str);
        Q_EMIT putSelfAddonsAddonIdPlanSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfAddonsAddonIdTagsTag(const QString &tag, const QString &addon_id, const OAIBody &oai_body) {
    QString fullPath = QString(_serverConfigs["putSelfAddonsAddonIdTagsTag"][_serverIndices.value("putSelfAddonsAddonIdTagsTag")].URL()+"/self/addons/{addonId}/tags/{tag}");
    
    
    {
        QString tagPathParam("{");
        tagPathParam.append("tag").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "tag", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"tag"+pathSuffix : pathPrefix;
        fullPath.replace(tagPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(tag)));
    }
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfAddonsAddonIdTagsTagCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfAddonsAddonIdTagsTagCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfAddonsAddonIdTagsTagSignal();
        Q_EMIT putSelfAddonsAddonIdTagsTagSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfAddonsAddonIdTagsTagSignalE(error_type, error_str);
        Q_EMIT putSelfAddonsAddonIdTagsTagSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfAddonsAddonIdTagsTagSignalError(error_type, error_str);
        Q_EMIT putSelfAddonsAddonIdTagsTagSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfAddonsAddonId(const QString &addon_id, const OAIWannabeAddon &oai_wannabe_addon) {
    QString fullPath = QString(_serverConfigs["putSelfAddonsAddonId"][_serverIndices.value("putSelfAddonsAddonId")].URL()+"/self/addons/{addonId}");
    
    
    {
        QString addon_idPathParam("{");
        addon_idPathParam.append("addonId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "addonId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"addonId"+pathSuffix : pathPrefix;
        fullPath.replace(addon_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(addon_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_wannabe_addon.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfAddonsAddonIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfAddonsAddonIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfAddonsAddonIdSignal();
        Q_EMIT putSelfAddonsAddonIdSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfAddonsAddonIdSignalE(error_type, error_str);
        Q_EMIT putSelfAddonsAddonIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfAddonsAddonIdSignalError(error_type, error_str);
        Q_EMIT putSelfAddonsAddonIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfApplicationsAppIdEnvEnvName(const QString &app_id, const QString &env_name, const OAIWannabeEnv &oai_wannabe_env) {
    QString fullPath = QString(_serverConfigs["putSelfApplicationsAppIdEnvEnvName"][_serverIndices.value("putSelfApplicationsAppIdEnvEnvName")].URL()+"/self/applications/{appId}/env/{envName}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    
    {
        QString env_namePathParam("{");
        env_namePathParam.append("envName").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "envName", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"envName"+pathSuffix : pathPrefix;
        fullPath.replace(env_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(env_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_wannabe_env.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfApplicationsAppIdEnvEnvNameCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfApplicationsAppIdEnvEnvNameCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfApplicationsAppIdEnvEnvNameSignal();
        Q_EMIT putSelfApplicationsAppIdEnvEnvNameSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfApplicationsAppIdEnvEnvNameSignalE(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdEnvEnvNameSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfApplicationsAppIdEnvEnvNameSignalError(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdEnvEnvNameSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfApplicationsAppIdEnv(const QString &app_id, const OAIWannabeEnv &oai_wannabe_env) {
    QString fullPath = QString(_serverConfigs["putSelfApplicationsAppIdEnv"][_serverIndices.value("putSelfApplicationsAppIdEnv")].URL()+"/self/applications/{appId}/env");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_wannabe_env.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfApplicationsAppIdEnvCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfApplicationsAppIdEnvCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfApplicationsAppIdEnvSignal();
        Q_EMIT putSelfApplicationsAppIdEnvSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfApplicationsAppIdEnvSignalE(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdEnvSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfApplicationsAppIdEnvSignalError(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdEnvSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfApplicationsAppIdTagsTag(const QString &app_id, const QString &tag, const OAIBody &oai_body) {
    QString fullPath = QString(_serverConfigs["putSelfApplicationsAppIdTagsTag"][_serverIndices.value("putSelfApplicationsAppIdTagsTag")].URL()+"/self/applications/{appId}/tags/{tag}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    
    {
        QString tagPathParam("{");
        tagPathParam.append("tag").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "tag", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"tag"+pathSuffix : pathPrefix;
        fullPath.replace(tagPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(tag)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfApplicationsAppIdTagsTagCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfApplicationsAppIdTagsTagCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfApplicationsAppIdTagsTagSignal();
        Q_EMIT putSelfApplicationsAppIdTagsTagSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfApplicationsAppIdTagsTagSignalE(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdTagsTagSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfApplicationsAppIdTagsTagSignalError(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdTagsTagSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfApplicationsAppIdVhostsDomain(const QString &app_id, const QString &domain, const OAIVhost &oai_vhost) {
    QString fullPath = QString(_serverConfigs["putSelfApplicationsAppIdVhostsDomain"][_serverIndices.value("putSelfApplicationsAppIdVhostsDomain")].URL()+"/self/applications/{appId}/vhosts/{domain}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    
    {
        QString domainPathParam("{");
        domainPathParam.append("domain").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "domain", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"domain"+pathSuffix : pathPrefix;
        fullPath.replace(domainPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(domain)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_vhost.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfApplicationsAppIdVhostsDomainCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfApplicationsAppIdVhostsDomainCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfApplicationsAppIdVhostsDomainSignal();
        Q_EMIT putSelfApplicationsAppIdVhostsDomainSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfApplicationsAppIdVhostsDomainSignalE(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdVhostsDomainSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfApplicationsAppIdVhostsDomainSignalError(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdVhostsDomainSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfApplicationsAppIdVhostsFavourite(const QString &app_id, const OAIVhost &oai_vhost) {
    QString fullPath = QString(_serverConfigs["putSelfApplicationsAppIdVhostsFavourite"][_serverIndices.value("putSelfApplicationsAppIdVhostsFavourite")].URL()+"/self/applications/{appId}/vhosts/favourite");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_vhost.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfApplicationsAppIdVhostsFavouriteCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfApplicationsAppIdVhostsFavouriteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfApplicationsAppIdVhostsFavouriteSignal();
        Q_EMIT putSelfApplicationsAppIdVhostsFavouriteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfApplicationsAppIdVhostsFavouriteSignalE(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdVhostsFavouriteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfApplicationsAppIdVhostsFavouriteSignalError(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdVhostsFavouriteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfApplicationsAppId(const QString &app_id, const OAIWannabeApplication &oai_wannabe_application) {
    QString fullPath = QString(_serverConfigs["putSelfApplicationsAppId"][_serverIndices.value("putSelfApplicationsAppId")].URL()+"/self/applications/{appId}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_wannabe_application.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfApplicationsAppIdCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfApplicationsAppIdCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfApplicationsAppIdSignal();
        Q_EMIT putSelfApplicationsAppIdSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfApplicationsAppIdSignalE(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfApplicationsAppIdSignalError(error_type, error_str);
        Q_EMIT putSelfApplicationsAppIdSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfAvatar(const OAIAvatar &oai_avatar) {
    QString fullPath = QString(_serverConfigs["putSelfAvatar"][_serverIndices.value("putSelfAvatar")].URL()+"/self/avatar");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_avatar.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfAvatarCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfAvatarCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfAvatarSignal();
        Q_EMIT putSelfAvatarSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfAvatarSignalE(error_type, error_str);
        Q_EMIT putSelfAvatarSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfAvatarSignalError(error_type, error_str);
        Q_EMIT putSelfAvatarSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfChangePassword() {
    QString fullPath = QString(_serverConfigs["putSelfChangePassword"][_serverIndices.value("putSelfChangePassword")].URL()+"/self/change_password");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfChangePasswordCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfChangePasswordCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIChange_Password output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfChangePasswordSignal(output);
        Q_EMIT putSelfChangePasswordSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfChangePasswordSignalE(output, error_type, error_str);
        Q_EMIT putSelfChangePasswordSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfChangePasswordSignalError(output, error_type, error_str);
        Q_EMIT putSelfChangePasswordSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfConsumersKey(const QString &key, const OAIWannabeConsumer &oai_wannabe_consumer) {
    QString fullPath = QString(_serverConfigs["putSelfConsumersKey"][_serverIndices.value("putSelfConsumersKey")].URL()+"/self/consumers/{key}");
    
    
    {
        QString keyPathParam("{");
        keyPathParam.append("key").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "key", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"key"+pathSuffix : pathPrefix;
        fullPath.replace(keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_wannabe_consumer.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfConsumersKeyCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfConsumersKeyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfConsumersKeySignal();
        Q_EMIT putSelfConsumersKeySignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfConsumersKeySignalE(error_type, error_str);
        Q_EMIT putSelfConsumersKeySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfConsumersKeySignalError(error_type, error_str);
        Q_EMIT putSelfConsumersKeySignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfEmailsEmail(const QString &email, const OAIBody &oai_body) {
    QString fullPath = QString(_serverConfigs["putSelfEmailsEmail"][_serverIndices.value("putSelfEmailsEmail")].URL()+"/self/emails/{email}");
    
    
    {
        QString emailPathParam("{");
        emailPathParam.append("email").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "email", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"email"+pathSuffix : pathPrefix;
        fullPath.replace(emailPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(email)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfEmailsEmailCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfEmailsEmailCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfEmailsEmailSignal();
        Q_EMIT putSelfEmailsEmailSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfEmailsEmailSignalE(error_type, error_str);
        Q_EMIT putSelfEmailsEmailSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfEmailsEmailSignalError(error_type, error_str);
        Q_EMIT putSelfEmailsEmailSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfKeysKey(const QString &key, const OAIBody &oai_body) {
    QString fullPath = QString(_serverConfigs["putSelfKeysKey"][_serverIndices.value("putSelfKeysKey")].URL()+"/self/keys/{key}");
    
    
    {
        QString keyPathParam("{");
        keyPathParam.append("key").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "key", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"key"+pathSuffix : pathPrefix;
        fullPath.replace(keyPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(key)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_body.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfKeysKeyCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfKeysKeyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfKeysKeySignal();
        Q_EMIT putSelfKeysKeySignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfKeysKeySignalE(error_type, error_str);
        Q_EMIT putSelfKeysKeySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfKeysKeySignalError(error_type, error_str);
        Q_EMIT putSelfKeysKeySignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelfPaymentsBillingsBid(const QString &bid) {
    QString fullPath = QString(_serverConfigs["putSelfPaymentsBillingsBid"][_serverIndices.value("putSelfPaymentsBillingsBid")].URL()+"/self/payments/billings/{bid}");
    
    
    {
        QString bidPathParam("{");
        bidPathParam.append("bid").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "bid", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"bid"+pathSuffix : pathPrefix;
        fullPath.replace(bidPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(bid)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfPaymentsBillingsBidCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfPaymentsBillingsBidCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfPaymentsBillingsBidSignal();
        Q_EMIT putSelfPaymentsBillingsBidSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfPaymentsBillingsBidSignalE(error_type, error_str);
        Q_EMIT putSelfPaymentsBillingsBidSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfPaymentsBillingsBidSignalError(error_type, error_str);
        Q_EMIT putSelfPaymentsBillingsBidSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::putSelf(const OAIWannabeUser &oai_wannabe_user) {
    QString fullPath = QString(_serverConfigs["putSelf"][_serverIndices.value("putSelf")].URL()+"/self");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_wannabe_user.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::putSelfCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::putSelfCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putSelfSignal();
        Q_EMIT putSelfSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putSelfSignalE(error_type, error_str);
        Q_EMIT putSelfSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putSelfSignalError(error_type, error_str);
        Q_EMIT putSelfSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfAddonsPreordersPost(const OAIWannabeAddon &oai_wannabe_addon) {
    QString fullPath = QString(_serverConfigs["selfAddonsPreordersPost"][_serverIndices.value("selfAddonsPreordersPost")].URL()+"/self/addons/preorders");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_wannabe_addon.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfAddonsPreordersPostCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfAddonsPreordersPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfAddonsPreordersPostSignal();
        Q_EMIT selfAddonsPreordersPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfAddonsPreordersPostSignalE(error_type, error_str);
        Q_EMIT selfAddonsPreordersPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfAddonsPreordersPostSignalError(error_type, error_str);
        Q_EMIT selfAddonsPreordersPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfApplicationsAppIdBranchPut(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["selfApplicationsAppIdBranchPut"][_serverIndices.value("selfApplicationsAppIdBranchPut")].URL()+"/self/applications/{appId}/branch");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfApplicationsAppIdBranchPutCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfApplicationsAppIdBranchPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfApplicationsAppIdBranchPutSignal();
        Q_EMIT selfApplicationsAppIdBranchPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfApplicationsAppIdBranchPutSignalE(error_type, error_str);
        Q_EMIT selfApplicationsAppIdBranchPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfApplicationsAppIdBranchPutSignalError(error_type, error_str);
        Q_EMIT selfApplicationsAppIdBranchPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfApplicationsAppIdBranchesGet(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["selfApplicationsAppIdBranchesGet"][_serverIndices.value("selfApplicationsAppIdBranchesGet")].URL()+"/self/applications/{appId}/branches");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfApplicationsAppIdBranchesGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfApplicationsAppIdBranchesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfApplicationsAppIdBranchesGetSignal();
        Q_EMIT selfApplicationsAppIdBranchesGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfApplicationsAppIdBranchesGetSignalE(error_type, error_str);
        Q_EMIT selfApplicationsAppIdBranchesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfApplicationsAppIdBranchesGetSignalError(error_type, error_str);
        Q_EMIT selfApplicationsAppIdBranchesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfApplicationsAppIdBuildflavorPut(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["selfApplicationsAppIdBuildflavorPut"][_serverIndices.value("selfApplicationsAppIdBuildflavorPut")].URL()+"/self/applications/{appId}/buildflavor");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfApplicationsAppIdBuildflavorPutCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfApplicationsAppIdBuildflavorPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfApplicationsAppIdBuildflavorPutSignal();
        Q_EMIT selfApplicationsAppIdBuildflavorPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfApplicationsAppIdBuildflavorPutSignalE(error_type, error_str);
        Q_EMIT selfApplicationsAppIdBuildflavorPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfApplicationsAppIdBuildflavorPutSignalError(error_type, error_str);
        Q_EMIT selfApplicationsAppIdBuildflavorPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfApplicationsAppIdDependenciesEnvGet(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["selfApplicationsAppIdDependenciesEnvGet"][_serverIndices.value("selfApplicationsAppIdDependenciesEnvGet")].URL()+"/self/applications/{appId}/dependencies/env");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfApplicationsAppIdDependenciesEnvGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfApplicationsAppIdDependenciesEnvGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILinkedAppEnv> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAILinkedAppEnv val;
        ::OpenAPI::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfApplicationsAppIdDependenciesEnvGetSignal(output);
        Q_EMIT selfApplicationsAppIdDependenciesEnvGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfApplicationsAppIdDependenciesEnvGetSignalE(output, error_type, error_str);
        Q_EMIT selfApplicationsAppIdDependenciesEnvGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfApplicationsAppIdDependenciesEnvGetSignalError(output, error_type, error_str);
        Q_EMIT selfApplicationsAppIdDependenciesEnvGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfApplicationsAppIdDeploymentsDeploymentIdGet(const QString &app_id, const QString &deployment_id) {
    QString fullPath = QString(_serverConfigs["selfApplicationsAppIdDeploymentsDeploymentIdGet"][_serverIndices.value("selfApplicationsAppIdDeploymentsDeploymentIdGet")].URL()+"/self/applications/{appId}/deployments/{deploymentId}");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    
    {
        QString deployment_idPathParam("{");
        deployment_idPathParam.append("deploymentId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "deploymentId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"deploymentId"+pathSuffix : pathPrefix;
        fullPath.replace(deployment_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(deployment_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfApplicationsAppIdDeploymentsDeploymentIdGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfApplicationsAppIdDeploymentsDeploymentIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfApplicationsAppIdDeploymentsDeploymentIdGetSignal();
        Q_EMIT selfApplicationsAppIdDeploymentsDeploymentIdGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfApplicationsAppIdDeploymentsDeploymentIdGetSignalE(error_type, error_str);
        Q_EMIT selfApplicationsAppIdDeploymentsDeploymentIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfApplicationsAppIdDeploymentsDeploymentIdGetSignalError(error_type, error_str);
        Q_EMIT selfApplicationsAppIdDeploymentsDeploymentIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfApplicationsAppIdExposedEnvGet(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["selfApplicationsAppIdExposedEnvGet"][_serverIndices.value("selfApplicationsAppIdExposedEnvGet")].URL()+"/self/applications/{appId}/exposed_env");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfApplicationsAppIdExposedEnvGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfApplicationsAppIdExposedEnvGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfApplicationsAppIdExposedEnvGetSignal();
        Q_EMIT selfApplicationsAppIdExposedEnvGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfApplicationsAppIdExposedEnvGetSignalE(error_type, error_str);
        Q_EMIT selfApplicationsAppIdExposedEnvGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfApplicationsAppIdExposedEnvGetSignalError(error_type, error_str);
        Q_EMIT selfApplicationsAppIdExposedEnvGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfApplicationsAppIdExposedEnvPut(const QString &app_id) {
    QString fullPath = QString(_serverConfigs["selfApplicationsAppIdExposedEnvPut"][_serverIndices.value("selfApplicationsAppIdExposedEnvPut")].URL()+"/self/applications/{appId}/exposed_env");
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfApplicationsAppIdExposedEnvPutCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfApplicationsAppIdExposedEnvPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfApplicationsAppIdExposedEnvPutSignal();
        Q_EMIT selfApplicationsAppIdExposedEnvPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfApplicationsAppIdExposedEnvPutSignalE(error_type, error_str);
        Q_EMIT selfApplicationsAppIdExposedEnvPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfApplicationsAppIdExposedEnvPutSignalError(error_type, error_str);
        Q_EMIT selfApplicationsAppIdExposedEnvPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfApplicationsAppIdInstancesInstanceIdGet(const QString &instance_id, const QString &app_id) {
    QString fullPath = QString(_serverConfigs["selfApplicationsAppIdInstancesInstanceIdGet"][_serverIndices.value("selfApplicationsAppIdInstancesInstanceIdGet")].URL()+"/self/applications/{appId}/instances/{instanceId}");
    
    
    {
        QString instance_idPathParam("{");
        instance_idPathParam.append("instanceId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "instanceId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"instanceId"+pathSuffix : pathPrefix;
        fullPath.replace(instance_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(instance_id)));
    }
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("appId").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "appId", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"appId"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfApplicationsAppIdInstancesInstanceIdGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfApplicationsAppIdInstancesInstanceIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfApplicationsAppIdInstancesInstanceIdGetSignal();
        Q_EMIT selfApplicationsAppIdInstancesInstanceIdGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfApplicationsAppIdInstancesInstanceIdGetSignalE(error_type, error_str);
        Q_EMIT selfApplicationsAppIdInstancesInstanceIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfApplicationsAppIdInstancesInstanceIdGetSignalError(error_type, error_str);
        Q_EMIT selfApplicationsAppIdInstancesInstanceIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfCliTokensGet(const ::OpenAPI::OptionalParam<QString> &cli_token) {
    QString fullPath = QString(_serverConfigs["selfCliTokensGet"][_serverIndices.value("selfCliTokensGet")].URL()+"/self/cli_tokens");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (cli_token.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "cli_token", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("cli_token")).append(querySuffix).append(QUrl::toPercentEncoding(cli_token.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfCliTokensGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfCliTokensGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfCliTokensGetSignal();
        Q_EMIT selfCliTokensGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfCliTokensGetSignalE(error_type, error_str);
        Q_EMIT selfCliTokensGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfCliTokensGetSignalError(error_type, error_str);
        Q_EMIT selfCliTokensGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfMfaKindBackupcodesGet(const QString &kind) {
    QString fullPath = QString(_serverConfigs["selfMfaKindBackupcodesGet"][_serverIndices.value("selfMfaKindBackupcodesGet")].URL()+"/self/mfa/{kind}/backupcodes");
    
    
    {
        QString kindPathParam("{");
        kindPathParam.append("kind").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "kind", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"kind"+pathSuffix : pathPrefix;
        fullPath.replace(kindPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(kind)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfMfaKindBackupcodesGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfMfaKindBackupcodesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfMfaKindBackupcodesGetSignal();
        Q_EMIT selfMfaKindBackupcodesGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfMfaKindBackupcodesGetSignalE(error_type, error_str);
        Q_EMIT selfMfaKindBackupcodesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfMfaKindBackupcodesGetSignalError(error_type, error_str);
        Q_EMIT selfMfaKindBackupcodesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfMfaKindConfirmationPost(const QString &kind) {
    QString fullPath = QString(_serverConfigs["selfMfaKindConfirmationPost"][_serverIndices.value("selfMfaKindConfirmationPost")].URL()+"/self/mfa/{kind}/confirmation");
    
    
    {
        QString kindPathParam("{");
        kindPathParam.append("kind").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "kind", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"kind"+pathSuffix : pathPrefix;
        fullPath.replace(kindPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(kind)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfMfaKindConfirmationPostCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfMfaKindConfirmationPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfMfaKindConfirmationPostSignal();
        Q_EMIT selfMfaKindConfirmationPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfMfaKindConfirmationPostSignalE(error_type, error_str);
        Q_EMIT selfMfaKindConfirmationPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfMfaKindConfirmationPostSignalError(error_type, error_str);
        Q_EMIT selfMfaKindConfirmationPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfMfaKindDelete(const QString &kind) {
    QString fullPath = QString(_serverConfigs["selfMfaKindDelete"][_serverIndices.value("selfMfaKindDelete")].URL()+"/self/mfa/{kind}");
    
    
    {
        QString kindPathParam("{");
        kindPathParam.append("kind").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "kind", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"kind"+pathSuffix : pathPrefix;
        fullPath.replace(kindPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(kind)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfMfaKindDeleteCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfMfaKindDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfMfaKindDeleteSignal();
        Q_EMIT selfMfaKindDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfMfaKindDeleteSignalE(error_type, error_str);
        Q_EMIT selfMfaKindDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfMfaKindDeleteSignalError(error_type, error_str);
        Q_EMIT selfMfaKindDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfMfaKindPost(const QString &kind) {
    QString fullPath = QString(_serverConfigs["selfMfaKindPost"][_serverIndices.value("selfMfaKindPost")].URL()+"/self/mfa/{kind}");
    
    
    {
        QString kindPathParam("{");
        kindPathParam.append("kind").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "kind", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"kind"+pathSuffix : pathPrefix;
        fullPath.replace(kindPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(kind)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfMfaKindPostCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfMfaKindPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfMfaKindPostSignal();
        Q_EMIT selfMfaKindPostSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfMfaKindPostSignalE(error_type, error_str);
        Q_EMIT selfMfaKindPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfMfaKindPostSignalError(error_type, error_str);
        Q_EMIT selfMfaKindPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfMfaKindPut(const QString &kind) {
    QString fullPath = QString(_serverConfigs["selfMfaKindPut"][_serverIndices.value("selfMfaKindPut")].URL()+"/self/mfa/{kind}");
    
    
    {
        QString kindPathParam("{");
        kindPathParam.append("kind").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "kind", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"kind"+pathSuffix : pathPrefix;
        fullPath.replace(kindPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(kind)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfMfaKindPutCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfMfaKindPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfMfaKindPutSignal();
        Q_EMIT selfMfaKindPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfMfaKindPutSignalE(error_type, error_str);
        Q_EMIT selfMfaKindPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfMfaKindPutSignalError(error_type, error_str);
        Q_EMIT selfMfaKindPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfPaymentsMethodsDefaultGet() {
    QString fullPath = QString(_serverConfigs["selfPaymentsMethodsDefaultGet"][_serverIndices.value("selfPaymentsMethodsDefaultGet")].URL()+"/self/payments/methods/default");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfPaymentsMethodsDefaultGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfPaymentsMethodsDefaultGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfPaymentsMethodsDefaultGetSignal();
        Q_EMIT selfPaymentsMethodsDefaultGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfPaymentsMethodsDefaultGetSignalE(error_type, error_str);
        Q_EMIT selfPaymentsMethodsDefaultGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfPaymentsMethodsDefaultGetSignalError(error_type, error_str);
        Q_EMIT selfPaymentsMethodsDefaultGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfPaymentsMethodsDefaultPut() {
    QString fullPath = QString(_serverConfigs["selfPaymentsMethodsDefaultPut"][_serverIndices.value("selfPaymentsMethodsDefaultPut")].URL()+"/self/payments/methods/default");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfPaymentsMethodsDefaultPutCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfPaymentsMethodsDefaultPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfPaymentsMethodsDefaultPutSignal();
        Q_EMIT selfPaymentsMethodsDefaultPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfPaymentsMethodsDefaultPutSignalE(error_type, error_str);
        Q_EMIT selfPaymentsMethodsDefaultPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfPaymentsMethodsDefaultPutSignalError(error_type, error_str);
        Q_EMIT selfPaymentsMethodsDefaultPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfPaymentsMonthlyinvoiceGet() {
    QString fullPath = QString(_serverConfigs["selfPaymentsMonthlyinvoiceGet"][_serverIndices.value("selfPaymentsMonthlyinvoiceGet")].URL()+"/self/payments/monthlyinvoice");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfPaymentsMonthlyinvoiceGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfPaymentsMonthlyinvoiceGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfPaymentsMonthlyinvoiceGetSignal();
        Q_EMIT selfPaymentsMonthlyinvoiceGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfPaymentsMonthlyinvoiceGetSignalE(error_type, error_str);
        Q_EMIT selfPaymentsMonthlyinvoiceGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfPaymentsMonthlyinvoiceGetSignalError(error_type, error_str);
        Q_EMIT selfPaymentsMonthlyinvoiceGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfPaymentsMonthlyinvoiceMaxcreditPut() {
    QString fullPath = QString(_serverConfigs["selfPaymentsMonthlyinvoiceMaxcreditPut"][_serverIndices.value("selfPaymentsMonthlyinvoiceMaxcreditPut")].URL()+"/self/payments/monthlyinvoice/maxcredit");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfPaymentsMonthlyinvoiceMaxcreditPutCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfPaymentsMonthlyinvoiceMaxcreditPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfPaymentsMonthlyinvoiceMaxcreditPutSignal();
        Q_EMIT selfPaymentsMonthlyinvoiceMaxcreditPutSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfPaymentsMonthlyinvoiceMaxcreditPutSignalE(error_type, error_str);
        Q_EMIT selfPaymentsMonthlyinvoiceMaxcreditPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfPaymentsMonthlyinvoiceMaxcreditPutSignalError(error_type, error_str);
        Q_EMIT selfPaymentsMonthlyinvoiceMaxcreditPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfPaymentsRecurringGet() {
    QString fullPath = QString(_serverConfigs["selfPaymentsRecurringGet"][_serverIndices.value("selfPaymentsRecurringGet")].URL()+"/self/payments/recurring");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfPaymentsRecurringGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfPaymentsRecurringGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfPaymentsRecurringGetSignal();
        Q_EMIT selfPaymentsRecurringGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfPaymentsRecurringGetSignalE(error_type, error_str);
        Q_EMIT selfPaymentsRecurringGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfPaymentsRecurringGetSignalError(error_type, error_str);
        Q_EMIT selfPaymentsRecurringGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::selfPaymentsTokensStripeGet() {
    QString fullPath = QString(_serverConfigs["selfPaymentsTokensStripeGet"][_serverIndices.value("selfPaymentsTokensStripeGet")].URL()+"/self/payments/tokens/stripe");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISelfApi::selfPaymentsTokensStripeGetCallback);
    connect(this, &OAISelfApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISelfApi::selfPaymentsTokensStripeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT selfPaymentsTokensStripeGetSignal();
        Q_EMIT selfPaymentsTokensStripeGetSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT selfPaymentsTokensStripeGetSignalE(error_type, error_str);
        Q_EMIT selfPaymentsTokensStripeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT selfPaymentsTokensStripeGetSignalError(error_type, error_str);
        Q_EMIT selfPaymentsTokensStripeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISelfApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
