# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.self_link import SelfLink
from openapi_server import util


class SubscriptionReactivation(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, links: List[SelfLink]=None, cancellation_id: str=None, created_time: datetime=None, description: str=None, effective_time: datetime=None, id: str=None, renewal_time: datetime=None, subscription_id: str=None):
        """SubscriptionReactivation - a model defined in OpenAPI

        :param links: The links of this SubscriptionReactivation.
        :param cancellation_id: The cancellation_id of this SubscriptionReactivation.
        :param created_time: The created_time of this SubscriptionReactivation.
        :param description: The description of this SubscriptionReactivation.
        :param effective_time: The effective_time of this SubscriptionReactivation.
        :param id: The id of this SubscriptionReactivation.
        :param renewal_time: The renewal_time of this SubscriptionReactivation.
        :param subscription_id: The subscription_id of this SubscriptionReactivation.
        """
        self.openapi_types = {
            'links': List[SelfLink],
            'cancellation_id': str,
            'created_time': datetime,
            'description': str,
            'effective_time': datetime,
            'id': str,
            'renewal_time': datetime,
            'subscription_id': str
        }

        self.attribute_map = {
            'links': '_links',
            'cancellation_id': 'cancellationId',
            'created_time': 'createdTime',
            'description': 'description',
            'effective_time': 'effectiveTime',
            'id': 'id',
            'renewal_time': 'renewalTime',
            'subscription_id': 'subscriptionId'
        }

        self._links = links
        self._cancellation_id = cancellation_id
        self._created_time = created_time
        self._description = description
        self._effective_time = effective_time
        self._id = id
        self._renewal_time = renewal_time
        self._subscription_id = subscription_id

    @classmethod
    def from_dict(cls, dikt: dict) -> 'SubscriptionReactivation':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The SubscriptionReactivation of this SubscriptionReactivation.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def links(self):
        """Gets the links of this SubscriptionReactivation.

        The links related to resource.

        :return: The links of this SubscriptionReactivation.
        :rtype: List[SelfLink]
        """
        return self._links

    @links.setter
    def links(self, links):
        """Sets the links of this SubscriptionReactivation.

        The links related to resource.

        :param links: The links of this SubscriptionReactivation.
        :type links: List[SelfLink]
        """
        if links is not None and len(links) < 1:
            raise ValueError("Invalid value for `links`, number of items must be greater than or equal to `1`")

        self._links = links

    @property
    def cancellation_id(self):
        """Gets the cancellation_id of this SubscriptionReactivation.

        Identifier of the related cancellation.

        :return: The cancellation_id of this SubscriptionReactivation.
        :rtype: str
        """
        return self._cancellation_id

    @cancellation_id.setter
    def cancellation_id(self, cancellation_id):
        """Sets the cancellation_id of this SubscriptionReactivation.

        Identifier of the related cancellation.

        :param cancellation_id: The cancellation_id of this SubscriptionReactivation.
        :type cancellation_id: str
        """
        if cancellation_id is not None and len(cancellation_id) > 50:
            raise ValueError("Invalid value for `cancellation_id`, length must be less than or equal to `50`")

        self._cancellation_id = cancellation_id

    @property
    def created_time(self):
        """Gets the created_time of this SubscriptionReactivation.

        The time of resource creation (when it is posted).

        :return: The created_time of this SubscriptionReactivation.
        :rtype: datetime
        """
        return self._created_time

    @created_time.setter
    def created_time(self, created_time):
        """Sets the created_time of this SubscriptionReactivation.

        The time of resource creation (when it is posted).

        :param created_time: The created_time of this SubscriptionReactivation.
        :type created_time: datetime
        """

        self._created_time = created_time

    @property
    def description(self):
        """Gets the description of this SubscriptionReactivation.

        Reactivation reason description in free form.

        :return: The description of this SubscriptionReactivation.
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this SubscriptionReactivation.

        Reactivation reason description in free form.

        :param description: The description of this SubscriptionReactivation.
        :type description: str
        """
        if description is not None and len(description) > 255:
            raise ValueError("Invalid value for `description`, length must be less than or equal to `255`")

        self._description = description

    @property
    def effective_time(self):
        """Gets the effective_time of this SubscriptionReactivation.

        The date from which the service period would start, unless the subscription is canceled but still active. In case the susbcription is still active, the subscription will continue the current service period. If omitted, it will default to the current time. 

        :return: The effective_time of this SubscriptionReactivation.
        :rtype: datetime
        """
        return self._effective_time

    @effective_time.setter
    def effective_time(self, effective_time):
        """Sets the effective_time of this SubscriptionReactivation.

        The date from which the service period would start, unless the subscription is canceled but still active. In case the susbcription is still active, the subscription will continue the current service period. If omitted, it will default to the current time. 

        :param effective_time: The effective_time of this SubscriptionReactivation.
        :type effective_time: datetime
        """

        self._effective_time = effective_time

    @property
    def id(self):
        """Gets the id of this SubscriptionReactivation.

        Reactivation identifier.

        :return: The id of this SubscriptionReactivation.
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this SubscriptionReactivation.

        Reactivation identifier.

        :param id: The id of this SubscriptionReactivation.
        :type id: str
        """
        if id is not None and len(id) > 50:
            raise ValueError("Invalid value for `id`, length must be less than or equal to `50`")

        self._id = id

    @property
    def renewal_time(self):
        """Gets the renewal_time of this SubscriptionReactivation.

        The time of the next subscription renewal. If omitted then it is computed from the effective time. If the subscription is canceled but active it is ignored, so the next renewal will happen as scheduled. 

        :return: The renewal_time of this SubscriptionReactivation.
        :rtype: datetime
        """
        return self._renewal_time

    @renewal_time.setter
    def renewal_time(self, renewal_time):
        """Sets the renewal_time of this SubscriptionReactivation.

        The time of the next subscription renewal. If omitted then it is computed from the effective time. If the subscription is canceled but active it is ignored, so the next renewal will happen as scheduled. 

        :param renewal_time: The renewal_time of this SubscriptionReactivation.
        :type renewal_time: datetime
        """

        self._renewal_time = renewal_time

    @property
    def subscription_id(self):
        """Gets the subscription_id of this SubscriptionReactivation.

        Identifier of the reactivated subscription.

        :return: The subscription_id of this SubscriptionReactivation.
        :rtype: str
        """
        return self._subscription_id

    @subscription_id.setter
    def subscription_id(self, subscription_id):
        """Sets the subscription_id of this SubscriptionReactivation.

        Identifier of the reactivated subscription.

        :param subscription_id: The subscription_id of this SubscriptionReactivation.
        :type subscription_id: str
        """
        if subscription_id is None:
            raise ValueError("Invalid value for `subscription_id`, must not be `None`")
        if subscription_id is not None and len(subscription_id) > 50:
            raise ValueError("Invalid value for `subscription_id`, length must be less than or equal to `50`")

        self._subscription_id = subscription_id
