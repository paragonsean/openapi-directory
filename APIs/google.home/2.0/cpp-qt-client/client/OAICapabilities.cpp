/**
 * Google Home
 * # Google Home Local API This is an unofficial documentation of the local API used by the Home app to communicate with GH devices. [GitHub Repo](https://github.com/rithvikvibhu/GHLocalApi)  [![GitHub stars](https://img.shields.io/github/stars/rithvikvibhu/GHLocalApi)](https://github.com/rithvikvibhu/GHLocalApi/stargazers) [![GitHub license](https://img.shields.io/github/license/rithvikvibhu/GHLocalApi)](https://github.com/rithvikvibhu/GHLocalApi/blob/master/LICENSE.md)  ## Getting Started  Requests must be made over HTTPS, port 8443, so the base URL for these endpoints is: `https://<google-home-ip>:8443/setup/`  Get the IP of Google Home from the Google Home app (Device Settings -> End of the list) or from your router.  GET requests are simple, in the browser kind.   POST requests need to set the header (when there's a body): `content-type: application/json`  ## Authentication  Since June 2019, most requests (with exceptions like `/setup/eureka_info`) need a local authorization token.  There are 3 kinds of tokens involved here:  ### Local Authorization Token This token must be sent in all requests in the header `cast-local-authorization-token`. It is short-lived (~1 day) and may change unexpectedly (with a sync, change in homegraph, etc.) ##### Get this token - With access to an android device, [get this token directly by either method](https://gist.github.com/rithvikvibhu/1a0f4937af957ef6a78453e3be482c1f). - Without a device, or to integrate it with a script, use an access token to get the homegraph and extract the token. To get an access token, read the next section. Check the example section for more info.  ### Access Token This is a standard google oauth2 access token. It is in the form `ya29.***`. This gives access to the Google Home Foyer API. These expire in an hour. Use this to get the homegraph (and then the local authorization token above). ##### Get this token To get this access token, either a Google account username/password or a Google Master Token is needed. More info in the gist. Use the script [from this gist](https://gist.github.com/rithvikvibhu/952f83ea656c6782fbd0f1645059055d).  ### Master Token This is in the form `aas_et/_***` and can be used to request access tokens. ##### Get this token The same [script in the gist](https://gist.github.com/rithvikvibhu/952f83ea656c6782fbd0f1645059055d) that gets the access token can also get the master token. Needs Google account creds.  ## Example  Here's the whole flow from just a pair of username/password to using the local API.  Prerequisites: - [grpcurl](https://github.com/fullstorydev/grpcurl) - [Proto files](https://drive.google.com/drive/folders/1RvnN3y-G23pd2SWHmfV_7sef8QU5GNF4?usp=sharing) (preserve folder structure)  ### 1. Get an access token with the script - Download get_tokens.py - Fill in username and password ```sh python3 get_tokens.py # Note down the access token printed. ```  ### 2. Use the access token and get home graph - This prints the json and uses jq to parse and filter out the fields deviceName and localAuthToken - This will give a list of all devices and their local auth tokens ```sh ./grpcurl -H 'authorization: Bearer ya29.a0Af****' \\  -import-path /path/to/protos \\  -proto /path/to/protos/google/internal/home/foyer/v1.proto \\  googlehomefoyer-pa.googleapis.com:443 \\  google.internal.home.foyer.v1.StructuresService/GetHomeGraph | jq '.home.devices[] | {deviceName, localAuthToken}' # Note down the local auth token for the device you want. ```  ### 3. Make the call to the local device using the local auth token ```sh curl -H \"cast-local-authorization-token: LOCAL_AUTH_TOKEN\" --verbose --insecure https://192.168.0.18:8443/setup/bluetooth/status ```
 *
 * The version of the OpenAPI document: 2.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICapabilities.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICapabilities::OAICapabilities(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICapabilities::OAICapabilities() {
    this->initializeModel();
}

OAICapabilities::~OAICapabilities() {}

void OAICapabilities::initializeModel() {

    m_aogh_supported_isSet = false;
    m_aogh_supported_isValid = false;

    m_assistant_supported_isSet = false;
    m_assistant_supported_isValid = false;

    m_audio_hdr_supported_isSet = false;
    m_audio_hdr_supported_isValid = false;

    m_audio_surround_mode_supported_isSet = false;
    m_audio_surround_mode_supported_isValid = false;

    m_ble_supported_isSet = false;
    m_ble_supported_isValid = false;

    m_bluetooth_audio_sink_supported_isSet = false;
    m_bluetooth_audio_sink_supported_isValid = false;

    m_bluetooth_audio_source_supported_isSet = false;
    m_bluetooth_audio_source_supported_isValid = false;

    m_bluetooth_supported_isSet = false;
    m_bluetooth_supported_isValid = false;

    m_cloudcast_supported_isSet = false;
    m_cloudcast_supported_isValid = false;

    m_content_filters_supported_isSet = false;
    m_content_filters_supported_isValid = false;

    m_display_supported_isSet = false;
    m_display_supported_isValid = false;

    m_fdr_supported_isSet = false;
    m_fdr_supported_isValid = false;

    m_hdmi_prefer_50hz_supported_isSet = false;
    m_hdmi_prefer_50hz_supported_isValid = false;

    m_hdmi_prefer_high_fps_supported_isSet = false;
    m_hdmi_prefer_high_fps_supported_isValid = false;

    m_hotspot_supported_isSet = false;
    m_hotspot_supported_isValid = false;

    m_https_setup_supported_isSet = false;
    m_https_setup_supported_isValid = false;

    m_input_management_supported_isSet = false;
    m_input_management_supported_isValid = false;

    m_keep_hotspot_until_connected_supported_isSet = false;
    m_keep_hotspot_until_connected_supported_isValid = false;

    m_multi_user_supported_isSet = false;
    m_multi_user_supported_isValid = false;

    m_multichannel_group_supported_isSet = false;
    m_multichannel_group_supported_isValid = false;

    m_multizone_supported_isSet = false;
    m_multizone_supported_isValid = false;

    m_night_mode_supported_isSet = false;
    m_night_mode_supported_isValid = false;

    m_night_mode_supported_v2_isSet = false;
    m_night_mode_supported_v2_isValid = false;

    m_opencast_supported_isSet = false;
    m_opencast_supported_isValid = false;

    m_preview_channel_supported_isSet = false;
    m_preview_channel_supported_isValid = false;

    m_reboot_supported_isSet = false;
    m_reboot_supported_isValid = false;

    m_remote_ducking_supported_isSet = false;
    m_remote_ducking_supported_isValid = false;

    m_separate_tts_volume_supported_isSet = false;
    m_separate_tts_volume_supported_isValid = false;

    m_setup_supported_isSet = false;
    m_setup_supported_isValid = false;

    m_sleep_mode_supported_isSet = false;
    m_sleep_mode_supported_isValid = false;

    m_stats_supported_isSet = false;
    m_stats_supported_isValid = false;

    m_system_sound_effects_supported_isSet = false;
    m_system_sound_effects_supported_isValid = false;

    m_user_eq_supported_isSet = false;
    m_user_eq_supported_isValid = false;

    m_wifi_auto_save_supported_isSet = false;
    m_wifi_auto_save_supported_isValid = false;

    m_wifi_regulatory_domain_locked_isSet = false;
    m_wifi_regulatory_domain_locked_isValid = false;

    m_wifi_supported_isSet = false;
    m_wifi_supported_isValid = false;
}

void OAICapabilities::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICapabilities::fromJsonObject(QJsonObject json) {

    m_aogh_supported_isValid = ::OpenAPI::fromJsonValue(m_aogh_supported, json[QString("aogh_supported")]);
    m_aogh_supported_isSet = !json[QString("aogh_supported")].isNull() && m_aogh_supported_isValid;

    m_assistant_supported_isValid = ::OpenAPI::fromJsonValue(m_assistant_supported, json[QString("assistant_supported")]);
    m_assistant_supported_isSet = !json[QString("assistant_supported")].isNull() && m_assistant_supported_isValid;

    m_audio_hdr_supported_isValid = ::OpenAPI::fromJsonValue(m_audio_hdr_supported, json[QString("audio_hdr_supported")]);
    m_audio_hdr_supported_isSet = !json[QString("audio_hdr_supported")].isNull() && m_audio_hdr_supported_isValid;

    m_audio_surround_mode_supported_isValid = ::OpenAPI::fromJsonValue(m_audio_surround_mode_supported, json[QString("audio_surround_mode_supported")]);
    m_audio_surround_mode_supported_isSet = !json[QString("audio_surround_mode_supported")].isNull() && m_audio_surround_mode_supported_isValid;

    m_ble_supported_isValid = ::OpenAPI::fromJsonValue(m_ble_supported, json[QString("ble_supported")]);
    m_ble_supported_isSet = !json[QString("ble_supported")].isNull() && m_ble_supported_isValid;

    m_bluetooth_audio_sink_supported_isValid = ::OpenAPI::fromJsonValue(m_bluetooth_audio_sink_supported, json[QString("bluetooth_audio_sink_supported")]);
    m_bluetooth_audio_sink_supported_isSet = !json[QString("bluetooth_audio_sink_supported")].isNull() && m_bluetooth_audio_sink_supported_isValid;

    m_bluetooth_audio_source_supported_isValid = ::OpenAPI::fromJsonValue(m_bluetooth_audio_source_supported, json[QString("bluetooth_audio_source_supported")]);
    m_bluetooth_audio_source_supported_isSet = !json[QString("bluetooth_audio_source_supported")].isNull() && m_bluetooth_audio_source_supported_isValid;

    m_bluetooth_supported_isValid = ::OpenAPI::fromJsonValue(m_bluetooth_supported, json[QString("bluetooth_supported")]);
    m_bluetooth_supported_isSet = !json[QString("bluetooth_supported")].isNull() && m_bluetooth_supported_isValid;

    m_cloudcast_supported_isValid = ::OpenAPI::fromJsonValue(m_cloudcast_supported, json[QString("cloudcast_supported")]);
    m_cloudcast_supported_isSet = !json[QString("cloudcast_supported")].isNull() && m_cloudcast_supported_isValid;

    m_content_filters_supported_isValid = ::OpenAPI::fromJsonValue(m_content_filters_supported, json[QString("content_filters_supported")]);
    m_content_filters_supported_isSet = !json[QString("content_filters_supported")].isNull() && m_content_filters_supported_isValid;

    m_display_supported_isValid = ::OpenAPI::fromJsonValue(m_display_supported, json[QString("display_supported")]);
    m_display_supported_isSet = !json[QString("display_supported")].isNull() && m_display_supported_isValid;

    m_fdr_supported_isValid = ::OpenAPI::fromJsonValue(m_fdr_supported, json[QString("fdr_supported")]);
    m_fdr_supported_isSet = !json[QString("fdr_supported")].isNull() && m_fdr_supported_isValid;

    m_hdmi_prefer_50hz_supported_isValid = ::OpenAPI::fromJsonValue(m_hdmi_prefer_50hz_supported, json[QString("hdmi_prefer_50hz_supported")]);
    m_hdmi_prefer_50hz_supported_isSet = !json[QString("hdmi_prefer_50hz_supported")].isNull() && m_hdmi_prefer_50hz_supported_isValid;

    m_hdmi_prefer_high_fps_supported_isValid = ::OpenAPI::fromJsonValue(m_hdmi_prefer_high_fps_supported, json[QString("hdmi_prefer_high_fps_supported")]);
    m_hdmi_prefer_high_fps_supported_isSet = !json[QString("hdmi_prefer_high_fps_supported")].isNull() && m_hdmi_prefer_high_fps_supported_isValid;

    m_hotspot_supported_isValid = ::OpenAPI::fromJsonValue(m_hotspot_supported, json[QString("hotspot_supported")]);
    m_hotspot_supported_isSet = !json[QString("hotspot_supported")].isNull() && m_hotspot_supported_isValid;

    m_https_setup_supported_isValid = ::OpenAPI::fromJsonValue(m_https_setup_supported, json[QString("https_setup_supported")]);
    m_https_setup_supported_isSet = !json[QString("https_setup_supported")].isNull() && m_https_setup_supported_isValid;

    m_input_management_supported_isValid = ::OpenAPI::fromJsonValue(m_input_management_supported, json[QString("input_management_supported")]);
    m_input_management_supported_isSet = !json[QString("input_management_supported")].isNull() && m_input_management_supported_isValid;

    m_keep_hotspot_until_connected_supported_isValid = ::OpenAPI::fromJsonValue(m_keep_hotspot_until_connected_supported, json[QString("keep_hotspot_until_connected_supported")]);
    m_keep_hotspot_until_connected_supported_isSet = !json[QString("keep_hotspot_until_connected_supported")].isNull() && m_keep_hotspot_until_connected_supported_isValid;

    m_multi_user_supported_isValid = ::OpenAPI::fromJsonValue(m_multi_user_supported, json[QString("multi_user_supported")]);
    m_multi_user_supported_isSet = !json[QString("multi_user_supported")].isNull() && m_multi_user_supported_isValid;

    m_multichannel_group_supported_isValid = ::OpenAPI::fromJsonValue(m_multichannel_group_supported, json[QString("multichannel_group_supported")]);
    m_multichannel_group_supported_isSet = !json[QString("multichannel_group_supported")].isNull() && m_multichannel_group_supported_isValid;

    m_multizone_supported_isValid = ::OpenAPI::fromJsonValue(m_multizone_supported, json[QString("multizone_supported")]);
    m_multizone_supported_isSet = !json[QString("multizone_supported")].isNull() && m_multizone_supported_isValid;

    m_night_mode_supported_isValid = ::OpenAPI::fromJsonValue(m_night_mode_supported, json[QString("night_mode_supported")]);
    m_night_mode_supported_isSet = !json[QString("night_mode_supported")].isNull() && m_night_mode_supported_isValid;

    m_night_mode_supported_v2_isValid = ::OpenAPI::fromJsonValue(m_night_mode_supported_v2, json[QString("night_mode_supported_v2")]);
    m_night_mode_supported_v2_isSet = !json[QString("night_mode_supported_v2")].isNull() && m_night_mode_supported_v2_isValid;

    m_opencast_supported_isValid = ::OpenAPI::fromJsonValue(m_opencast_supported, json[QString("opencast_supported")]);
    m_opencast_supported_isSet = !json[QString("opencast_supported")].isNull() && m_opencast_supported_isValid;

    m_preview_channel_supported_isValid = ::OpenAPI::fromJsonValue(m_preview_channel_supported, json[QString("preview_channel_supported")]);
    m_preview_channel_supported_isSet = !json[QString("preview_channel_supported")].isNull() && m_preview_channel_supported_isValid;

    m_reboot_supported_isValid = ::OpenAPI::fromJsonValue(m_reboot_supported, json[QString("reboot_supported")]);
    m_reboot_supported_isSet = !json[QString("reboot_supported")].isNull() && m_reboot_supported_isValid;

    m_remote_ducking_supported_isValid = ::OpenAPI::fromJsonValue(m_remote_ducking_supported, json[QString("remote_ducking_supported")]);
    m_remote_ducking_supported_isSet = !json[QString("remote_ducking_supported")].isNull() && m_remote_ducking_supported_isValid;

    m_separate_tts_volume_supported_isValid = ::OpenAPI::fromJsonValue(m_separate_tts_volume_supported, json[QString("separate_tts_volume_supported")]);
    m_separate_tts_volume_supported_isSet = !json[QString("separate_tts_volume_supported")].isNull() && m_separate_tts_volume_supported_isValid;

    m_setup_supported_isValid = ::OpenAPI::fromJsonValue(m_setup_supported, json[QString("setup_supported")]);
    m_setup_supported_isSet = !json[QString("setup_supported")].isNull() && m_setup_supported_isValid;

    m_sleep_mode_supported_isValid = ::OpenAPI::fromJsonValue(m_sleep_mode_supported, json[QString("sleep_mode_supported")]);
    m_sleep_mode_supported_isSet = !json[QString("sleep_mode_supported")].isNull() && m_sleep_mode_supported_isValid;

    m_stats_supported_isValid = ::OpenAPI::fromJsonValue(m_stats_supported, json[QString("stats_supported")]);
    m_stats_supported_isSet = !json[QString("stats_supported")].isNull() && m_stats_supported_isValid;

    m_system_sound_effects_supported_isValid = ::OpenAPI::fromJsonValue(m_system_sound_effects_supported, json[QString("system_sound_effects_supported")]);
    m_system_sound_effects_supported_isSet = !json[QString("system_sound_effects_supported")].isNull() && m_system_sound_effects_supported_isValid;

    m_user_eq_supported_isValid = ::OpenAPI::fromJsonValue(m_user_eq_supported, json[QString("user_eq_supported")]);
    m_user_eq_supported_isSet = !json[QString("user_eq_supported")].isNull() && m_user_eq_supported_isValid;

    m_wifi_auto_save_supported_isValid = ::OpenAPI::fromJsonValue(m_wifi_auto_save_supported, json[QString("wifi_auto_save_supported")]);
    m_wifi_auto_save_supported_isSet = !json[QString("wifi_auto_save_supported")].isNull() && m_wifi_auto_save_supported_isValid;

    m_wifi_regulatory_domain_locked_isValid = ::OpenAPI::fromJsonValue(m_wifi_regulatory_domain_locked, json[QString("wifi_regulatory_domain_locked")]);
    m_wifi_regulatory_domain_locked_isSet = !json[QString("wifi_regulatory_domain_locked")].isNull() && m_wifi_regulatory_domain_locked_isValid;

    m_wifi_supported_isValid = ::OpenAPI::fromJsonValue(m_wifi_supported, json[QString("wifi_supported")]);
    m_wifi_supported_isSet = !json[QString("wifi_supported")].isNull() && m_wifi_supported_isValid;
}

QString OAICapabilities::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICapabilities::asJsonObject() const {
    QJsonObject obj;
    if (m_aogh_supported_isSet) {
        obj.insert(QString("aogh_supported"), ::OpenAPI::toJsonValue(m_aogh_supported));
    }
    if (m_assistant_supported_isSet) {
        obj.insert(QString("assistant_supported"), ::OpenAPI::toJsonValue(m_assistant_supported));
    }
    if (m_audio_hdr_supported_isSet) {
        obj.insert(QString("audio_hdr_supported"), ::OpenAPI::toJsonValue(m_audio_hdr_supported));
    }
    if (m_audio_surround_mode_supported_isSet) {
        obj.insert(QString("audio_surround_mode_supported"), ::OpenAPI::toJsonValue(m_audio_surround_mode_supported));
    }
    if (m_ble_supported_isSet) {
        obj.insert(QString("ble_supported"), ::OpenAPI::toJsonValue(m_ble_supported));
    }
    if (m_bluetooth_audio_sink_supported_isSet) {
        obj.insert(QString("bluetooth_audio_sink_supported"), ::OpenAPI::toJsonValue(m_bluetooth_audio_sink_supported));
    }
    if (m_bluetooth_audio_source_supported_isSet) {
        obj.insert(QString("bluetooth_audio_source_supported"), ::OpenAPI::toJsonValue(m_bluetooth_audio_source_supported));
    }
    if (m_bluetooth_supported_isSet) {
        obj.insert(QString("bluetooth_supported"), ::OpenAPI::toJsonValue(m_bluetooth_supported));
    }
    if (m_cloudcast_supported_isSet) {
        obj.insert(QString("cloudcast_supported"), ::OpenAPI::toJsonValue(m_cloudcast_supported));
    }
    if (m_content_filters_supported_isSet) {
        obj.insert(QString("content_filters_supported"), ::OpenAPI::toJsonValue(m_content_filters_supported));
    }
    if (m_display_supported_isSet) {
        obj.insert(QString("display_supported"), ::OpenAPI::toJsonValue(m_display_supported));
    }
    if (m_fdr_supported_isSet) {
        obj.insert(QString("fdr_supported"), ::OpenAPI::toJsonValue(m_fdr_supported));
    }
    if (m_hdmi_prefer_50hz_supported_isSet) {
        obj.insert(QString("hdmi_prefer_50hz_supported"), ::OpenAPI::toJsonValue(m_hdmi_prefer_50hz_supported));
    }
    if (m_hdmi_prefer_high_fps_supported_isSet) {
        obj.insert(QString("hdmi_prefer_high_fps_supported"), ::OpenAPI::toJsonValue(m_hdmi_prefer_high_fps_supported));
    }
    if (m_hotspot_supported_isSet) {
        obj.insert(QString("hotspot_supported"), ::OpenAPI::toJsonValue(m_hotspot_supported));
    }
    if (m_https_setup_supported_isSet) {
        obj.insert(QString("https_setup_supported"), ::OpenAPI::toJsonValue(m_https_setup_supported));
    }
    if (m_input_management_supported_isSet) {
        obj.insert(QString("input_management_supported"), ::OpenAPI::toJsonValue(m_input_management_supported));
    }
    if (m_keep_hotspot_until_connected_supported_isSet) {
        obj.insert(QString("keep_hotspot_until_connected_supported"), ::OpenAPI::toJsonValue(m_keep_hotspot_until_connected_supported));
    }
    if (m_multi_user_supported_isSet) {
        obj.insert(QString("multi_user_supported"), ::OpenAPI::toJsonValue(m_multi_user_supported));
    }
    if (m_multichannel_group_supported_isSet) {
        obj.insert(QString("multichannel_group_supported"), ::OpenAPI::toJsonValue(m_multichannel_group_supported));
    }
    if (m_multizone_supported_isSet) {
        obj.insert(QString("multizone_supported"), ::OpenAPI::toJsonValue(m_multizone_supported));
    }
    if (m_night_mode_supported_isSet) {
        obj.insert(QString("night_mode_supported"), ::OpenAPI::toJsonValue(m_night_mode_supported));
    }
    if (m_night_mode_supported_v2_isSet) {
        obj.insert(QString("night_mode_supported_v2"), ::OpenAPI::toJsonValue(m_night_mode_supported_v2));
    }
    if (m_opencast_supported_isSet) {
        obj.insert(QString("opencast_supported"), ::OpenAPI::toJsonValue(m_opencast_supported));
    }
    if (m_preview_channel_supported_isSet) {
        obj.insert(QString("preview_channel_supported"), ::OpenAPI::toJsonValue(m_preview_channel_supported));
    }
    if (m_reboot_supported_isSet) {
        obj.insert(QString("reboot_supported"), ::OpenAPI::toJsonValue(m_reboot_supported));
    }
    if (m_remote_ducking_supported_isSet) {
        obj.insert(QString("remote_ducking_supported"), ::OpenAPI::toJsonValue(m_remote_ducking_supported));
    }
    if (m_separate_tts_volume_supported_isSet) {
        obj.insert(QString("separate_tts_volume_supported"), ::OpenAPI::toJsonValue(m_separate_tts_volume_supported));
    }
    if (m_setup_supported_isSet) {
        obj.insert(QString("setup_supported"), ::OpenAPI::toJsonValue(m_setup_supported));
    }
    if (m_sleep_mode_supported_isSet) {
        obj.insert(QString("sleep_mode_supported"), ::OpenAPI::toJsonValue(m_sleep_mode_supported));
    }
    if (m_stats_supported_isSet) {
        obj.insert(QString("stats_supported"), ::OpenAPI::toJsonValue(m_stats_supported));
    }
    if (m_system_sound_effects_supported_isSet) {
        obj.insert(QString("system_sound_effects_supported"), ::OpenAPI::toJsonValue(m_system_sound_effects_supported));
    }
    if (m_user_eq_supported_isSet) {
        obj.insert(QString("user_eq_supported"), ::OpenAPI::toJsonValue(m_user_eq_supported));
    }
    if (m_wifi_auto_save_supported_isSet) {
        obj.insert(QString("wifi_auto_save_supported"), ::OpenAPI::toJsonValue(m_wifi_auto_save_supported));
    }
    if (m_wifi_regulatory_domain_locked_isSet) {
        obj.insert(QString("wifi_regulatory_domain_locked"), ::OpenAPI::toJsonValue(m_wifi_regulatory_domain_locked));
    }
    if (m_wifi_supported_isSet) {
        obj.insert(QString("wifi_supported"), ::OpenAPI::toJsonValue(m_wifi_supported));
    }
    return obj;
}

bool OAICapabilities::isAoghSupported() const {
    return m_aogh_supported;
}
void OAICapabilities::setAoghSupported(const bool &aogh_supported) {
    m_aogh_supported = aogh_supported;
    m_aogh_supported_isSet = true;
}

bool OAICapabilities::is_aogh_supported_Set() const{
    return m_aogh_supported_isSet;
}

bool OAICapabilities::is_aogh_supported_Valid() const{
    return m_aogh_supported_isValid;
}

bool OAICapabilities::isAssistantSupported() const {
    return m_assistant_supported;
}
void OAICapabilities::setAssistantSupported(const bool &assistant_supported) {
    m_assistant_supported = assistant_supported;
    m_assistant_supported_isSet = true;
}

bool OAICapabilities::is_assistant_supported_Set() const{
    return m_assistant_supported_isSet;
}

bool OAICapabilities::is_assistant_supported_Valid() const{
    return m_assistant_supported_isValid;
}

bool OAICapabilities::isAudioHdrSupported() const {
    return m_audio_hdr_supported;
}
void OAICapabilities::setAudioHdrSupported(const bool &audio_hdr_supported) {
    m_audio_hdr_supported = audio_hdr_supported;
    m_audio_hdr_supported_isSet = true;
}

bool OAICapabilities::is_audio_hdr_supported_Set() const{
    return m_audio_hdr_supported_isSet;
}

bool OAICapabilities::is_audio_hdr_supported_Valid() const{
    return m_audio_hdr_supported_isValid;
}

bool OAICapabilities::isAudioSurroundModeSupported() const {
    return m_audio_surround_mode_supported;
}
void OAICapabilities::setAudioSurroundModeSupported(const bool &audio_surround_mode_supported) {
    m_audio_surround_mode_supported = audio_surround_mode_supported;
    m_audio_surround_mode_supported_isSet = true;
}

bool OAICapabilities::is_audio_surround_mode_supported_Set() const{
    return m_audio_surround_mode_supported_isSet;
}

bool OAICapabilities::is_audio_surround_mode_supported_Valid() const{
    return m_audio_surround_mode_supported_isValid;
}

bool OAICapabilities::isBleSupported() const {
    return m_ble_supported;
}
void OAICapabilities::setBleSupported(const bool &ble_supported) {
    m_ble_supported = ble_supported;
    m_ble_supported_isSet = true;
}

bool OAICapabilities::is_ble_supported_Set() const{
    return m_ble_supported_isSet;
}

bool OAICapabilities::is_ble_supported_Valid() const{
    return m_ble_supported_isValid;
}

bool OAICapabilities::isBluetoothAudioSinkSupported() const {
    return m_bluetooth_audio_sink_supported;
}
void OAICapabilities::setBluetoothAudioSinkSupported(const bool &bluetooth_audio_sink_supported) {
    m_bluetooth_audio_sink_supported = bluetooth_audio_sink_supported;
    m_bluetooth_audio_sink_supported_isSet = true;
}

bool OAICapabilities::is_bluetooth_audio_sink_supported_Set() const{
    return m_bluetooth_audio_sink_supported_isSet;
}

bool OAICapabilities::is_bluetooth_audio_sink_supported_Valid() const{
    return m_bluetooth_audio_sink_supported_isValid;
}

bool OAICapabilities::isBluetoothAudioSourceSupported() const {
    return m_bluetooth_audio_source_supported;
}
void OAICapabilities::setBluetoothAudioSourceSupported(const bool &bluetooth_audio_source_supported) {
    m_bluetooth_audio_source_supported = bluetooth_audio_source_supported;
    m_bluetooth_audio_source_supported_isSet = true;
}

bool OAICapabilities::is_bluetooth_audio_source_supported_Set() const{
    return m_bluetooth_audio_source_supported_isSet;
}

bool OAICapabilities::is_bluetooth_audio_source_supported_Valid() const{
    return m_bluetooth_audio_source_supported_isValid;
}

bool OAICapabilities::isBluetoothSupported() const {
    return m_bluetooth_supported;
}
void OAICapabilities::setBluetoothSupported(const bool &bluetooth_supported) {
    m_bluetooth_supported = bluetooth_supported;
    m_bluetooth_supported_isSet = true;
}

bool OAICapabilities::is_bluetooth_supported_Set() const{
    return m_bluetooth_supported_isSet;
}

bool OAICapabilities::is_bluetooth_supported_Valid() const{
    return m_bluetooth_supported_isValid;
}

bool OAICapabilities::isCloudcastSupported() const {
    return m_cloudcast_supported;
}
void OAICapabilities::setCloudcastSupported(const bool &cloudcast_supported) {
    m_cloudcast_supported = cloudcast_supported;
    m_cloudcast_supported_isSet = true;
}

bool OAICapabilities::is_cloudcast_supported_Set() const{
    return m_cloudcast_supported_isSet;
}

bool OAICapabilities::is_cloudcast_supported_Valid() const{
    return m_cloudcast_supported_isValid;
}

bool OAICapabilities::isContentFiltersSupported() const {
    return m_content_filters_supported;
}
void OAICapabilities::setContentFiltersSupported(const bool &content_filters_supported) {
    m_content_filters_supported = content_filters_supported;
    m_content_filters_supported_isSet = true;
}

bool OAICapabilities::is_content_filters_supported_Set() const{
    return m_content_filters_supported_isSet;
}

bool OAICapabilities::is_content_filters_supported_Valid() const{
    return m_content_filters_supported_isValid;
}

bool OAICapabilities::isDisplaySupported() const {
    return m_display_supported;
}
void OAICapabilities::setDisplaySupported(const bool &display_supported) {
    m_display_supported = display_supported;
    m_display_supported_isSet = true;
}

bool OAICapabilities::is_display_supported_Set() const{
    return m_display_supported_isSet;
}

bool OAICapabilities::is_display_supported_Valid() const{
    return m_display_supported_isValid;
}

bool OAICapabilities::isFdrSupported() const {
    return m_fdr_supported;
}
void OAICapabilities::setFdrSupported(const bool &fdr_supported) {
    m_fdr_supported = fdr_supported;
    m_fdr_supported_isSet = true;
}

bool OAICapabilities::is_fdr_supported_Set() const{
    return m_fdr_supported_isSet;
}

bool OAICapabilities::is_fdr_supported_Valid() const{
    return m_fdr_supported_isValid;
}

bool OAICapabilities::isHdmiPrefer50hzSupported() const {
    return m_hdmi_prefer_50hz_supported;
}
void OAICapabilities::setHdmiPrefer50hzSupported(const bool &hdmi_prefer_50hz_supported) {
    m_hdmi_prefer_50hz_supported = hdmi_prefer_50hz_supported;
    m_hdmi_prefer_50hz_supported_isSet = true;
}

bool OAICapabilities::is_hdmi_prefer_50hz_supported_Set() const{
    return m_hdmi_prefer_50hz_supported_isSet;
}

bool OAICapabilities::is_hdmi_prefer_50hz_supported_Valid() const{
    return m_hdmi_prefer_50hz_supported_isValid;
}

bool OAICapabilities::isHdmiPreferHighFpsSupported() const {
    return m_hdmi_prefer_high_fps_supported;
}
void OAICapabilities::setHdmiPreferHighFpsSupported(const bool &hdmi_prefer_high_fps_supported) {
    m_hdmi_prefer_high_fps_supported = hdmi_prefer_high_fps_supported;
    m_hdmi_prefer_high_fps_supported_isSet = true;
}

bool OAICapabilities::is_hdmi_prefer_high_fps_supported_Set() const{
    return m_hdmi_prefer_high_fps_supported_isSet;
}

bool OAICapabilities::is_hdmi_prefer_high_fps_supported_Valid() const{
    return m_hdmi_prefer_high_fps_supported_isValid;
}

bool OAICapabilities::isHotspotSupported() const {
    return m_hotspot_supported;
}
void OAICapabilities::setHotspotSupported(const bool &hotspot_supported) {
    m_hotspot_supported = hotspot_supported;
    m_hotspot_supported_isSet = true;
}

bool OAICapabilities::is_hotspot_supported_Set() const{
    return m_hotspot_supported_isSet;
}

bool OAICapabilities::is_hotspot_supported_Valid() const{
    return m_hotspot_supported_isValid;
}

bool OAICapabilities::isHttpsSetupSupported() const {
    return m_https_setup_supported;
}
void OAICapabilities::setHttpsSetupSupported(const bool &https_setup_supported) {
    m_https_setup_supported = https_setup_supported;
    m_https_setup_supported_isSet = true;
}

bool OAICapabilities::is_https_setup_supported_Set() const{
    return m_https_setup_supported_isSet;
}

bool OAICapabilities::is_https_setup_supported_Valid() const{
    return m_https_setup_supported_isValid;
}

bool OAICapabilities::isInputManagementSupported() const {
    return m_input_management_supported;
}
void OAICapabilities::setInputManagementSupported(const bool &input_management_supported) {
    m_input_management_supported = input_management_supported;
    m_input_management_supported_isSet = true;
}

bool OAICapabilities::is_input_management_supported_Set() const{
    return m_input_management_supported_isSet;
}

bool OAICapabilities::is_input_management_supported_Valid() const{
    return m_input_management_supported_isValid;
}

bool OAICapabilities::isKeepHotspotUntilConnectedSupported() const {
    return m_keep_hotspot_until_connected_supported;
}
void OAICapabilities::setKeepHotspotUntilConnectedSupported(const bool &keep_hotspot_until_connected_supported) {
    m_keep_hotspot_until_connected_supported = keep_hotspot_until_connected_supported;
    m_keep_hotspot_until_connected_supported_isSet = true;
}

bool OAICapabilities::is_keep_hotspot_until_connected_supported_Set() const{
    return m_keep_hotspot_until_connected_supported_isSet;
}

bool OAICapabilities::is_keep_hotspot_until_connected_supported_Valid() const{
    return m_keep_hotspot_until_connected_supported_isValid;
}

bool OAICapabilities::isMultiUserSupported() const {
    return m_multi_user_supported;
}
void OAICapabilities::setMultiUserSupported(const bool &multi_user_supported) {
    m_multi_user_supported = multi_user_supported;
    m_multi_user_supported_isSet = true;
}

bool OAICapabilities::is_multi_user_supported_Set() const{
    return m_multi_user_supported_isSet;
}

bool OAICapabilities::is_multi_user_supported_Valid() const{
    return m_multi_user_supported_isValid;
}

bool OAICapabilities::isMultichannelGroupSupported() const {
    return m_multichannel_group_supported;
}
void OAICapabilities::setMultichannelGroupSupported(const bool &multichannel_group_supported) {
    m_multichannel_group_supported = multichannel_group_supported;
    m_multichannel_group_supported_isSet = true;
}

bool OAICapabilities::is_multichannel_group_supported_Set() const{
    return m_multichannel_group_supported_isSet;
}

bool OAICapabilities::is_multichannel_group_supported_Valid() const{
    return m_multichannel_group_supported_isValid;
}

bool OAICapabilities::isMultizoneSupported() const {
    return m_multizone_supported;
}
void OAICapabilities::setMultizoneSupported(const bool &multizone_supported) {
    m_multizone_supported = multizone_supported;
    m_multizone_supported_isSet = true;
}

bool OAICapabilities::is_multizone_supported_Set() const{
    return m_multizone_supported_isSet;
}

bool OAICapabilities::is_multizone_supported_Valid() const{
    return m_multizone_supported_isValid;
}

bool OAICapabilities::isNightModeSupported() const {
    return m_night_mode_supported;
}
void OAICapabilities::setNightModeSupported(const bool &night_mode_supported) {
    m_night_mode_supported = night_mode_supported;
    m_night_mode_supported_isSet = true;
}

bool OAICapabilities::is_night_mode_supported_Set() const{
    return m_night_mode_supported_isSet;
}

bool OAICapabilities::is_night_mode_supported_Valid() const{
    return m_night_mode_supported_isValid;
}

bool OAICapabilities::isNightModeSupportedV2() const {
    return m_night_mode_supported_v2;
}
void OAICapabilities::setNightModeSupportedV2(const bool &night_mode_supported_v2) {
    m_night_mode_supported_v2 = night_mode_supported_v2;
    m_night_mode_supported_v2_isSet = true;
}

bool OAICapabilities::is_night_mode_supported_v2_Set() const{
    return m_night_mode_supported_v2_isSet;
}

bool OAICapabilities::is_night_mode_supported_v2_Valid() const{
    return m_night_mode_supported_v2_isValid;
}

bool OAICapabilities::isOpencastSupported() const {
    return m_opencast_supported;
}
void OAICapabilities::setOpencastSupported(const bool &opencast_supported) {
    m_opencast_supported = opencast_supported;
    m_opencast_supported_isSet = true;
}

bool OAICapabilities::is_opencast_supported_Set() const{
    return m_opencast_supported_isSet;
}

bool OAICapabilities::is_opencast_supported_Valid() const{
    return m_opencast_supported_isValid;
}

bool OAICapabilities::isPreviewChannelSupported() const {
    return m_preview_channel_supported;
}
void OAICapabilities::setPreviewChannelSupported(const bool &preview_channel_supported) {
    m_preview_channel_supported = preview_channel_supported;
    m_preview_channel_supported_isSet = true;
}

bool OAICapabilities::is_preview_channel_supported_Set() const{
    return m_preview_channel_supported_isSet;
}

bool OAICapabilities::is_preview_channel_supported_Valid() const{
    return m_preview_channel_supported_isValid;
}

bool OAICapabilities::isRebootSupported() const {
    return m_reboot_supported;
}
void OAICapabilities::setRebootSupported(const bool &reboot_supported) {
    m_reboot_supported = reboot_supported;
    m_reboot_supported_isSet = true;
}

bool OAICapabilities::is_reboot_supported_Set() const{
    return m_reboot_supported_isSet;
}

bool OAICapabilities::is_reboot_supported_Valid() const{
    return m_reboot_supported_isValid;
}

bool OAICapabilities::isRemoteDuckingSupported() const {
    return m_remote_ducking_supported;
}
void OAICapabilities::setRemoteDuckingSupported(const bool &remote_ducking_supported) {
    m_remote_ducking_supported = remote_ducking_supported;
    m_remote_ducking_supported_isSet = true;
}

bool OAICapabilities::is_remote_ducking_supported_Set() const{
    return m_remote_ducking_supported_isSet;
}

bool OAICapabilities::is_remote_ducking_supported_Valid() const{
    return m_remote_ducking_supported_isValid;
}

bool OAICapabilities::isSeparateTtsVolumeSupported() const {
    return m_separate_tts_volume_supported;
}
void OAICapabilities::setSeparateTtsVolumeSupported(const bool &separate_tts_volume_supported) {
    m_separate_tts_volume_supported = separate_tts_volume_supported;
    m_separate_tts_volume_supported_isSet = true;
}

bool OAICapabilities::is_separate_tts_volume_supported_Set() const{
    return m_separate_tts_volume_supported_isSet;
}

bool OAICapabilities::is_separate_tts_volume_supported_Valid() const{
    return m_separate_tts_volume_supported_isValid;
}

bool OAICapabilities::isSetupSupported() const {
    return m_setup_supported;
}
void OAICapabilities::setSetupSupported(const bool &setup_supported) {
    m_setup_supported = setup_supported;
    m_setup_supported_isSet = true;
}

bool OAICapabilities::is_setup_supported_Set() const{
    return m_setup_supported_isSet;
}

bool OAICapabilities::is_setup_supported_Valid() const{
    return m_setup_supported_isValid;
}

bool OAICapabilities::isSleepModeSupported() const {
    return m_sleep_mode_supported;
}
void OAICapabilities::setSleepModeSupported(const bool &sleep_mode_supported) {
    m_sleep_mode_supported = sleep_mode_supported;
    m_sleep_mode_supported_isSet = true;
}

bool OAICapabilities::is_sleep_mode_supported_Set() const{
    return m_sleep_mode_supported_isSet;
}

bool OAICapabilities::is_sleep_mode_supported_Valid() const{
    return m_sleep_mode_supported_isValid;
}

bool OAICapabilities::isStatsSupported() const {
    return m_stats_supported;
}
void OAICapabilities::setStatsSupported(const bool &stats_supported) {
    m_stats_supported = stats_supported;
    m_stats_supported_isSet = true;
}

bool OAICapabilities::is_stats_supported_Set() const{
    return m_stats_supported_isSet;
}

bool OAICapabilities::is_stats_supported_Valid() const{
    return m_stats_supported_isValid;
}

bool OAICapabilities::isSystemSoundEffectsSupported() const {
    return m_system_sound_effects_supported;
}
void OAICapabilities::setSystemSoundEffectsSupported(const bool &system_sound_effects_supported) {
    m_system_sound_effects_supported = system_sound_effects_supported;
    m_system_sound_effects_supported_isSet = true;
}

bool OAICapabilities::is_system_sound_effects_supported_Set() const{
    return m_system_sound_effects_supported_isSet;
}

bool OAICapabilities::is_system_sound_effects_supported_Valid() const{
    return m_system_sound_effects_supported_isValid;
}

bool OAICapabilities::isUserEqSupported() const {
    return m_user_eq_supported;
}
void OAICapabilities::setUserEqSupported(const bool &user_eq_supported) {
    m_user_eq_supported = user_eq_supported;
    m_user_eq_supported_isSet = true;
}

bool OAICapabilities::is_user_eq_supported_Set() const{
    return m_user_eq_supported_isSet;
}

bool OAICapabilities::is_user_eq_supported_Valid() const{
    return m_user_eq_supported_isValid;
}

bool OAICapabilities::isWifiAutoSaveSupported() const {
    return m_wifi_auto_save_supported;
}
void OAICapabilities::setWifiAutoSaveSupported(const bool &wifi_auto_save_supported) {
    m_wifi_auto_save_supported = wifi_auto_save_supported;
    m_wifi_auto_save_supported_isSet = true;
}

bool OAICapabilities::is_wifi_auto_save_supported_Set() const{
    return m_wifi_auto_save_supported_isSet;
}

bool OAICapabilities::is_wifi_auto_save_supported_Valid() const{
    return m_wifi_auto_save_supported_isValid;
}

bool OAICapabilities::isWifiRegulatoryDomainLocked() const {
    return m_wifi_regulatory_domain_locked;
}
void OAICapabilities::setWifiRegulatoryDomainLocked(const bool &wifi_regulatory_domain_locked) {
    m_wifi_regulatory_domain_locked = wifi_regulatory_domain_locked;
    m_wifi_regulatory_domain_locked_isSet = true;
}

bool OAICapabilities::is_wifi_regulatory_domain_locked_Set() const{
    return m_wifi_regulatory_domain_locked_isSet;
}

bool OAICapabilities::is_wifi_regulatory_domain_locked_Valid() const{
    return m_wifi_regulatory_domain_locked_isValid;
}

bool OAICapabilities::isWifiSupported() const {
    return m_wifi_supported;
}
void OAICapabilities::setWifiSupported(const bool &wifi_supported) {
    m_wifi_supported = wifi_supported;
    m_wifi_supported_isSet = true;
}

bool OAICapabilities::is_wifi_supported_Set() const{
    return m_wifi_supported_isSet;
}

bool OAICapabilities::is_wifi_supported_Valid() const{
    return m_wifi_supported_isValid;
}

bool OAICapabilities::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_aogh_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_assistant_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_audio_hdr_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_audio_surround_mode_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ble_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_bluetooth_audio_sink_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_bluetooth_audio_source_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_bluetooth_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cloudcast_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_filters_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_fdr_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hdmi_prefer_50hz_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hdmi_prefer_high_fps_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_hotspot_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_https_setup_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_input_management_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_keep_hotspot_until_connected_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_multi_user_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_multichannel_group_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_multizone_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_night_mode_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_night_mode_supported_v2_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_opencast_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_preview_channel_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_reboot_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_remote_ducking_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_separate_tts_volume_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_setup_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sleep_mode_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stats_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_system_sound_effects_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_user_eq_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_wifi_auto_save_supported_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_wifi_regulatory_domain_locked_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_wifi_supported_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICapabilities::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_aogh_supported_isValid && m_assistant_supported_isValid && m_audio_hdr_supported_isValid && m_audio_surround_mode_supported_isValid && m_ble_supported_isValid && m_bluetooth_audio_sink_supported_isValid && m_bluetooth_audio_source_supported_isValid && m_bluetooth_supported_isValid && m_cloudcast_supported_isValid && m_content_filters_supported_isValid && m_display_supported_isValid && m_fdr_supported_isValid && m_hdmi_prefer_50hz_supported_isValid && m_hdmi_prefer_high_fps_supported_isValid && m_hotspot_supported_isValid && m_https_setup_supported_isValid && m_input_management_supported_isValid && m_keep_hotspot_until_connected_supported_isValid && m_multi_user_supported_isValid && m_multichannel_group_supported_isValid && m_multizone_supported_isValid && m_night_mode_supported_isValid && m_night_mode_supported_v2_isValid && m_opencast_supported_isValid && m_preview_channel_supported_isValid && m_reboot_supported_isValid && m_remote_ducking_supported_isValid && m_separate_tts_volume_supported_isValid && m_setup_supported_isValid && m_sleep_mode_supported_isValid && m_stats_supported_isValid && m_system_sound_effects_supported_isValid && m_user_eq_supported_isValid && m_wifi_auto_save_supported_isValid && m_wifi_regulatory_domain_locked_isValid && m_wifi_supported_isValid && true;
}

} // namespace OpenAPI
