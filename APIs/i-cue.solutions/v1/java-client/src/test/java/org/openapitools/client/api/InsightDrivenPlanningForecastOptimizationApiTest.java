/*
 * Growth Services
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.AiPlanningLevelRequest;
import java.io.File;
import org.openapitools.client.model.ForecastBottomUpResponse;
import org.openapitools.client.model.ForecastResponse;
import org.openapitools.client.model.FullDetailsForecastResponse;
import org.openapitools.client.model.HistoryAndForecastResponse;
import org.openapitools.client.model.JobResponse;
import org.openapitools.client.model.OptimalParameterResponse;
import org.openapitools.client.model.OutliersRequest;
import org.openapitools.client.model.PlanningLevelReRunRequest;
import org.openapitools.client.model.PlanningLevelRequest;
import org.openapitools.client.model.TimeSeriesOutliersResponse;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for InsightDrivenPlanningForecastOptimizationApi
 */
@Disabled
public class InsightDrivenPlanningForecastOptimizationApiTest {

    private final InsightDrivenPlanningForecastOptimizationApi api = new InsightDrivenPlanningForecastOptimizationApi();

    /**
     * History and forecast utilizing advanced machine learning models
     *
     * History and forecast utilizing advanced machine learning models. Please be mindful of enhanced execution times (~1-2s per timeseries).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastAIHistoryAndForecastPostTest() throws ApiException {
        String token = null;
        AiPlanningLevelRequest aiPlanningLevelRequest = null;
        JobResponse response = api.forecastAIHistoryAndForecastPost(token, aiPlanningLevelRequest);
        // TODO: test validations
    }

    /**
     * Forecast utilizing advanced machine learning models
     *
     * Forecast AI is utilizing advanced machine learning models. Please be mindful of enhanced execution times (~1-2s per timeseries).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastAIPostTest() throws ApiException {
        String token = null;
        AiPlanningLevelRequest aiPlanningLevelRequest = null;
        JobResponse response = api.forecastAIPost(token, aiPlanningLevelRequest);
        // TODO: test validations
    }

    /**
     * Forecast from file
     *
     * Forecast from file allows for quick analysis via Microsoft Excel and CSV file format. Please check documentation link for help.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastFileToForecastPostTest() throws ApiException {
        File _file = null;
        String method = null;
        String token = null;
        Boolean discardData = null;
        String errorType = null;
        Integer holdOutPeriod = null;
        Integer noFcst = null;
        Boolean outlierDetection = null;
        Integer periodicity = null;
        JobResponse response = api.forecastFileToForecastPost(_file, method, token, discardData, errorType, holdOutPeriod, noFcst, outlierDetection, periodicity);
        // TODO: test validations
    }

    /**
     * Bottom up forecasting
     *
     * Calculate forecast by timeseries and sum results up to establish forecast for top level timeseries.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastForecastBottomUpPostTest() throws ApiException {
        String token = null;
        PlanningLevelRequest planningLevelRequest = null;
        ForecastBottomUpResponse response = api.forecastForecastBottomUpPost(token, planningLevelRequest);
        // TODO: test validations
    }

    /**
     * Top down forecasting
     *
     * Calculate forecast based on sum of of lower level timeseries and distribute forecast down based on ratios. Great feature for planning levels with dynamic timeseries.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastForecastTopDownPostTest() throws ApiException {
        String token = null;
        PlanningLevelRequest planningLevelRequest = null;
        api.forecastForecastTopDownPost(token, planningLevelRequest);
        // TODO: test validations
    }

    /**
     * Full forecast result details, including error, trend seasonality and outlier
     *
     * Response provides full forecast result details, including error, trend seasonality and outlier. Great for advanced analysis.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastFullDetailPostTest() throws ApiException {
        String token = null;
        PlanningLevelRequest planningLevelRequest = null;
        FullDetailsForecastResponse response = api.forecastFullDetailPost(token, planningLevelRequest);
        // TODO: test validations
    }

    /**
     * History and forecast for fast timeseries view
     *
     * Reponse provides history and forecast per timeseries. Great for visualizing results.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastHistoryAndForecastPostTest() throws ApiException {
        String token = null;
        PlanningLevelRequest planningLevelRequest = null;
        HistoryAndForecastResponse response = api.forecastHistoryAndForecastPost(token, planningLevelRequest);
        // TODO: test validations
    }

    /**
     * Get optimal parameter per method
     *
     * Use the optimal parameter sets created by iCUE to set the method parameters of your internal planning system.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastOptimalParameterPostTest() throws ApiException {
        String token = null;
        PlanningLevelRequest planningLevelRequest = null;
        OptimalParameterResponse response = api.forecastOptimalParameterPost(token, planningLevelRequest);
        // TODO: test validations
    }

    /**
     * Forecasts only, for faster results
     *
     * To support maximum operation and integration speed, this endpoint only returns the calculated forecast.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastPostTest() throws ApiException {
        String token = null;
        PlanningLevelRequest planningLevelRequest = null;
        ForecastResponse response = api.forecastPost(token, planningLevelRequest);
        // TODO: test validations
    }

    /**
     * Rerun previously uploaded planning level
     *
     * Rerun previously uploaded planning level.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastRerunPostTest() throws ApiException {
        String token = null;
        PlanningLevelReRunRequest planningLevelReRunRequest = null;
        ForecastResponse response = api.forecastRerunPost(token, planningLevelReRunRequest);
        // TODO: test validations
    }

    /**
     * Forecast result
     *
     * Get result for forecast job
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastResultJobIdGetTest() throws ApiException {
        Integer jobId = null;
        String token = null;
        api.forecastResultJobIdGet(jobId, token);
        // TODO: test validations
    }

    /**
     * Forecast status
     *
     * Get status for forecast job
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void forecastStatusJobIdGetTest() throws ApiException {
        Integer jobId = null;
        String token = null;
        api.forecastStatusJobIdGet(jobId, token);
        // TODO: test validations
    }

    /**
     * Get outlier
     *
     * Identify outliers (single and repetitive spikes, seasonality, masked outliers, trend and level jumps, amongst other topics) and use for cleansing of the history stream prior to forecast claculation. Depending on math model used, this approach often improves results dramatically, as it removes disturbances.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void outlierPostTest() throws ApiException {
        String token = null;
        OutliersRequest outliersRequest = null;
        List<TimeSeriesOutliersResponse> response = api.outlierPost(token, outliersRequest);
        // TODO: test validations
    }

}
