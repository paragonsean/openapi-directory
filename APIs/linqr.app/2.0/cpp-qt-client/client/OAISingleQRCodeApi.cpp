/**
 * LinQR
 * This is LinQR QR Code API documentation. This API allows you to generate custom, visually attractive QR Codes. The cloud infrastructure guarantees high availability and autoscalability of the service. You can generate hundreds of thousands of images this way and use them however you like.  We realize that your API use case may require custom solutions, and perhaps we lack functionality that is very important to you. In that case feel free to write an email to our support and tell us about it. We have repeatedly added new functions of our service directly after the requests of our users.  **General remarks:**  - maximum request size is fixed at 32MB.  - request timeout is fixed at 180 seconds.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@linqr.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAISingleQRCodeApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAISingleQRCodeApi::OAISingleQRCodeApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAISingleQRCodeApi::~OAISingleQRCodeApi() {
}

void OAISingleQRCodeApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://run.byvalue.org"),
    "Byvalue proxy",
    QMap<QString, OAIServerVariable>()));
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://qrcode3.p.rapidapi.com"),
    "RapidAPI proxy",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("dispatcherQrcodeContactPost", defaultConf);
    _serverIndices.insert("dispatcherQrcodeContactPost", 0);
    _serverConfigs.insert("dispatcherQrcodeCryptoPost", defaultConf);
    _serverIndices.insert("dispatcherQrcodeCryptoPost", 0);
    _serverConfigs.insert("dispatcherQrcodeEmailPost", defaultConf);
    _serverIndices.insert("dispatcherQrcodeEmailPost", 0);
    _serverConfigs.insert("dispatcherQrcodeGeoPost", defaultConf);
    _serverIndices.insert("dispatcherQrcodeGeoPost", 0);
    _serverConfigs.insert("dispatcherQrcodePhonePost", defaultConf);
    _serverIndices.insert("dispatcherQrcodePhonePost", 0);
    _serverConfigs.insert("dispatcherQrcodePost", defaultConf);
    _serverIndices.insert("dispatcherQrcodePost", 0);
    _serverConfigs.insert("dispatcherQrcodeSmsPost", defaultConf);
    _serverIndices.insert("dispatcherQrcodeSmsPost", 0);
    _serverConfigs.insert("dispatcherQrcodeTextPost", defaultConf);
    _serverIndices.insert("dispatcherQrcodeTextPost", 0);
    _serverConfigs.insert("dispatcherQrcodeWifiPost", defaultConf);
    _serverIndices.insert("dispatcherQrcodeWifiPost", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAISingleQRCodeApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAISingleQRCodeApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAISingleQRCodeApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAISingleQRCodeApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAISingleQRCodeApi::setUsername(const QString &username) {
    _username = username;
}

void OAISingleQRCodeApi::setPassword(const QString &password) {
    _password = password;
}


void OAISingleQRCodeApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAISingleQRCodeApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAISingleQRCodeApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAISingleQRCodeApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAISingleQRCodeApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAISingleQRCodeApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAISingleQRCodeApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAISingleQRCodeApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAISingleQRCodeApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAISingleQRCodeApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAISingleQRCodeApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAISingleQRCodeApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAISingleQRCodeApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAISingleQRCodeApi::dispatcherQrcodeContactPost(const ::OpenAPI::OptionalParam<OAIContactQRCode> &oai_contact_qr_code) {
    QString fullPath = QString(_serverConfigs["dispatcherQrcodeContactPost"][_serverIndices.value("dispatcherQrcodeContactPost")].URL()+"/qrcode/contact");
    
    if (_apiKeys.contains("Byvalue")) {
        addHeaders("Byvalue",_apiKeys.find("Byvalue").value());
    }
    
    if (_apiKeys.contains("RapidAPI")) {
        addHeaders("RapidAPI",_apiKeys.find("RapidAPI").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_contact_qr_code.hasValue()){

        
        QByteArray output = oai_contact_qr_code.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISingleQRCodeApi::dispatcherQrcodeContactPostCallback);
    connect(this, &OAISingleQRCodeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISingleQRCodeApi::dispatcherQrcodeContactPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dispatcherQrcodeContactPostSignal(output);
        Q_EMIT dispatcherQrcodeContactPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dispatcherQrcodeContactPostSignalE(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeContactPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dispatcherQrcodeContactPostSignalError(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeContactPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISingleQRCodeApi::dispatcherQrcodeCryptoPost(const ::OpenAPI::OptionalParam<OAICryptoPaymentQRCode> &oai_crypto_payment_qr_code) {
    QString fullPath = QString(_serverConfigs["dispatcherQrcodeCryptoPost"][_serverIndices.value("dispatcherQrcodeCryptoPost")].URL()+"/qrcode/crypto");
    
    if (_apiKeys.contains("Byvalue")) {
        addHeaders("Byvalue",_apiKeys.find("Byvalue").value());
    }
    
    if (_apiKeys.contains("RapidAPI")) {
        addHeaders("RapidAPI",_apiKeys.find("RapidAPI").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_crypto_payment_qr_code.hasValue()){

        
        QByteArray output = oai_crypto_payment_qr_code.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISingleQRCodeApi::dispatcherQrcodeCryptoPostCallback);
    connect(this, &OAISingleQRCodeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISingleQRCodeApi::dispatcherQrcodeCryptoPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dispatcherQrcodeCryptoPostSignal(output);
        Q_EMIT dispatcherQrcodeCryptoPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dispatcherQrcodeCryptoPostSignalE(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeCryptoPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dispatcherQrcodeCryptoPostSignalError(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeCryptoPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISingleQRCodeApi::dispatcherQrcodeEmailPost(const ::OpenAPI::OptionalParam<OAIEmailQRCode> &oai_email_qr_code) {
    QString fullPath = QString(_serverConfigs["dispatcherQrcodeEmailPost"][_serverIndices.value("dispatcherQrcodeEmailPost")].URL()+"/qrcode/email");
    
    if (_apiKeys.contains("Byvalue")) {
        addHeaders("Byvalue",_apiKeys.find("Byvalue").value());
    }
    
    if (_apiKeys.contains("RapidAPI")) {
        addHeaders("RapidAPI",_apiKeys.find("RapidAPI").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_email_qr_code.hasValue()){

        
        QByteArray output = oai_email_qr_code.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISingleQRCodeApi::dispatcherQrcodeEmailPostCallback);
    connect(this, &OAISingleQRCodeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISingleQRCodeApi::dispatcherQrcodeEmailPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dispatcherQrcodeEmailPostSignal(output);
        Q_EMIT dispatcherQrcodeEmailPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dispatcherQrcodeEmailPostSignalE(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeEmailPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dispatcherQrcodeEmailPostSignalError(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeEmailPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISingleQRCodeApi::dispatcherQrcodeGeoPost(const ::OpenAPI::OptionalParam<OAIGeolocationQRCode> &oai_geolocation_qr_code) {
    QString fullPath = QString(_serverConfigs["dispatcherQrcodeGeoPost"][_serverIndices.value("dispatcherQrcodeGeoPost")].URL()+"/qrcode/geo");
    
    if (_apiKeys.contains("Byvalue")) {
        addHeaders("Byvalue",_apiKeys.find("Byvalue").value());
    }
    
    if (_apiKeys.contains("RapidAPI")) {
        addHeaders("RapidAPI",_apiKeys.find("RapidAPI").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_geolocation_qr_code.hasValue()){

        
        QByteArray output = oai_geolocation_qr_code.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISingleQRCodeApi::dispatcherQrcodeGeoPostCallback);
    connect(this, &OAISingleQRCodeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISingleQRCodeApi::dispatcherQrcodeGeoPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dispatcherQrcodeGeoPostSignal(output);
        Q_EMIT dispatcherQrcodeGeoPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dispatcherQrcodeGeoPostSignalE(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeGeoPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dispatcherQrcodeGeoPostSignalError(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeGeoPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISingleQRCodeApi::dispatcherQrcodePhonePost(const ::OpenAPI::OptionalParam<OAIPhoneQRCode> &oai_phone_qr_code) {
    QString fullPath = QString(_serverConfigs["dispatcherQrcodePhonePost"][_serverIndices.value("dispatcherQrcodePhonePost")].URL()+"/qrcode/phone");
    
    if (_apiKeys.contains("Byvalue")) {
        addHeaders("Byvalue",_apiKeys.find("Byvalue").value());
    }
    
    if (_apiKeys.contains("RapidAPI")) {
        addHeaders("RapidAPI",_apiKeys.find("RapidAPI").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_phone_qr_code.hasValue()){

        
        QByteArray output = oai_phone_qr_code.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISingleQRCodeApi::dispatcherQrcodePhonePostCallback);
    connect(this, &OAISingleQRCodeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISingleQRCodeApi::dispatcherQrcodePhonePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dispatcherQrcodePhonePostSignal(output);
        Q_EMIT dispatcherQrcodePhonePostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dispatcherQrcodePhonePostSignalE(output, error_type, error_str);
        Q_EMIT dispatcherQrcodePhonePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dispatcherQrcodePhonePostSignalError(output, error_type, error_str);
        Q_EMIT dispatcherQrcodePhonePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISingleQRCodeApi::dispatcherQrcodePost(const ::OpenAPI::OptionalParam<OAIAutoQRCode> &oai_auto_qr_code) {
    QString fullPath = QString(_serverConfigs["dispatcherQrcodePost"][_serverIndices.value("dispatcherQrcodePost")].URL()+"/qrcode");
    
    if (_apiKeys.contains("Byvalue")) {
        addHeaders("Byvalue",_apiKeys.find("Byvalue").value());
    }
    
    if (_apiKeys.contains("RapidAPI")) {
        addHeaders("RapidAPI",_apiKeys.find("RapidAPI").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_auto_qr_code.hasValue()){

        
        QByteArray output = oai_auto_qr_code.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISingleQRCodeApi::dispatcherQrcodePostCallback);
    connect(this, &OAISingleQRCodeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISingleQRCodeApi::dispatcherQrcodePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dispatcherQrcodePostSignal(output);
        Q_EMIT dispatcherQrcodePostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dispatcherQrcodePostSignalE(output, error_type, error_str);
        Q_EMIT dispatcherQrcodePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dispatcherQrcodePostSignalError(output, error_type, error_str);
        Q_EMIT dispatcherQrcodePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISingleQRCodeApi::dispatcherQrcodeSmsPost(const ::OpenAPI::OptionalParam<OAISMSQRCode> &oaismsqr_code) {
    QString fullPath = QString(_serverConfigs["dispatcherQrcodeSmsPost"][_serverIndices.value("dispatcherQrcodeSmsPost")].URL()+"/qrcode/sms");
    
    if (_apiKeys.contains("Byvalue")) {
        addHeaders("Byvalue",_apiKeys.find("Byvalue").value());
    }
    
    if (_apiKeys.contains("RapidAPI")) {
        addHeaders("RapidAPI",_apiKeys.find("RapidAPI").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oaismsqr_code.hasValue()){

        
        QByteArray output = oaismsqr_code.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISingleQRCodeApi::dispatcherQrcodeSmsPostCallback);
    connect(this, &OAISingleQRCodeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISingleQRCodeApi::dispatcherQrcodeSmsPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dispatcherQrcodeSmsPostSignal(output);
        Q_EMIT dispatcherQrcodeSmsPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dispatcherQrcodeSmsPostSignalE(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeSmsPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dispatcherQrcodeSmsPostSignalError(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeSmsPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISingleQRCodeApi::dispatcherQrcodeTextPost(const ::OpenAPI::OptionalParam<OAITextQRCode> &oai_text_qr_code) {
    QString fullPath = QString(_serverConfigs["dispatcherQrcodeTextPost"][_serverIndices.value("dispatcherQrcodeTextPost")].URL()+"/qrcode/text");
    
    if (_apiKeys.contains("Byvalue")) {
        addHeaders("Byvalue",_apiKeys.find("Byvalue").value());
    }
    
    if (_apiKeys.contains("RapidAPI")) {
        addHeaders("RapidAPI",_apiKeys.find("RapidAPI").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_text_qr_code.hasValue()){

        
        QByteArray output = oai_text_qr_code.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISingleQRCodeApi::dispatcherQrcodeTextPostCallback);
    connect(this, &OAISingleQRCodeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISingleQRCodeApi::dispatcherQrcodeTextPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dispatcherQrcodeTextPostSignal(output);
        Q_EMIT dispatcherQrcodeTextPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dispatcherQrcodeTextPostSignalE(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeTextPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dispatcherQrcodeTextPostSignalError(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeTextPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISingleQRCodeApi::dispatcherQrcodeWifiPost(const ::OpenAPI::OptionalParam<OAIWiFiQRCode> &oaiwi_fi_qr_code) {
    QString fullPath = QString(_serverConfigs["dispatcherQrcodeWifiPost"][_serverIndices.value("dispatcherQrcodeWifiPost")].URL()+"/qrcode/wifi");
    
    if (_apiKeys.contains("Byvalue")) {
        addHeaders("Byvalue",_apiKeys.find("Byvalue").value());
    }
    
    if (_apiKeys.contains("RapidAPI")) {
        addHeaders("RapidAPI",_apiKeys.find("RapidAPI").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oaiwi_fi_qr_code.hasValue()){

        
        QByteArray output = oaiwi_fi_qr_code.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAISingleQRCodeApi::dispatcherQrcodeWifiPostCallback);
    connect(this, &OAISingleQRCodeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAISingleQRCodeApi::dispatcherQrcodeWifiPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIHttpFileElement output = worker->getHttpFileElement();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT dispatcherQrcodeWifiPostSignal(output);
        Q_EMIT dispatcherQrcodeWifiPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT dispatcherQrcodeWifiPostSignalE(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeWifiPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT dispatcherQrcodeWifiPostSignalError(output, error_type, error_str);
        Q_EMIT dispatcherQrcodeWifiPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAISingleQRCodeApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
