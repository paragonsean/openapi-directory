/**
 * Gateway REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.9
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIVersionDefinition_extended_paths.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIVersionDefinition_extended_paths::OAIVersionDefinition_extended_paths(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIVersionDefinition_extended_paths::OAIVersionDefinition_extended_paths() {
    this->initializeModel();
}

OAIVersionDefinition_extended_paths::~OAIVersionDefinition_extended_paths() {}

void OAIVersionDefinition_extended_paths::initializeModel() {

    m_black_list_isSet = false;
    m_black_list_isValid = false;

    m_cache_isSet = false;
    m_cache_isValid = false;

    m_circuit_breakers_isSet = false;
    m_circuit_breakers_isValid = false;

    m_hard_timeouts_isSet = false;
    m_hard_timeouts_isValid = false;

    m_ignored_isSet = false;
    m_ignored_isValid = false;

    m_size_limits_isSet = false;
    m_size_limits_isValid = false;

    m_transform_isSet = false;
    m_transform_isValid = false;

    m_transform_headers_isSet = false;
    m_transform_headers_isValid = false;

    m_transform_response_isSet = false;
    m_transform_response_isValid = false;

    m_transform_response_headers_isSet = false;
    m_transform_response_headers_isValid = false;

    m_url_rewrites_isSet = false;
    m_url_rewrites_isValid = false;

    m_r_virtual_isSet = false;
    m_r_virtual_isValid = false;

    m_white_list_isSet = false;
    m_white_list_isValid = false;
}

void OAIVersionDefinition_extended_paths::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIVersionDefinition_extended_paths::fromJsonObject(QJsonObject json) {

    m_black_list_isValid = ::OpenAPI::fromJsonValue(m_black_list, json[QString("black_list")]);
    m_black_list_isSet = !json[QString("black_list")].isNull() && m_black_list_isValid;

    m_cache_isValid = ::OpenAPI::fromJsonValue(m_cache, json[QString("cache")]);
    m_cache_isSet = !json[QString("cache")].isNull() && m_cache_isValid;

    m_circuit_breakers_isValid = ::OpenAPI::fromJsonValue(m_circuit_breakers, json[QString("circuit_breakers")]);
    m_circuit_breakers_isSet = !json[QString("circuit_breakers")].isNull() && m_circuit_breakers_isValid;

    m_hard_timeouts_isValid = ::OpenAPI::fromJsonValue(m_hard_timeouts, json[QString("hard_timeouts")]);
    m_hard_timeouts_isSet = !json[QString("hard_timeouts")].isNull() && m_hard_timeouts_isValid;

    m_ignored_isValid = ::OpenAPI::fromJsonValue(m_ignored, json[QString("ignored")]);
    m_ignored_isSet = !json[QString("ignored")].isNull() && m_ignored_isValid;

    m_size_limits_isValid = ::OpenAPI::fromJsonValue(m_size_limits, json[QString("size_limits")]);
    m_size_limits_isSet = !json[QString("size_limits")].isNull() && m_size_limits_isValid;

    m_transform_isValid = ::OpenAPI::fromJsonValue(m_transform, json[QString("transform")]);
    m_transform_isSet = !json[QString("transform")].isNull() && m_transform_isValid;

    m_transform_headers_isValid = ::OpenAPI::fromJsonValue(m_transform_headers, json[QString("transform_headers")]);
    m_transform_headers_isSet = !json[QString("transform_headers")].isNull() && m_transform_headers_isValid;

    m_transform_response_isValid = ::OpenAPI::fromJsonValue(m_transform_response, json[QString("transform_response")]);
    m_transform_response_isSet = !json[QString("transform_response")].isNull() && m_transform_response_isValid;

    m_transform_response_headers_isValid = ::OpenAPI::fromJsonValue(m_transform_response_headers, json[QString("transform_response_headers")]);
    m_transform_response_headers_isSet = !json[QString("transform_response_headers")].isNull() && m_transform_response_headers_isValid;

    m_url_rewrites_isValid = ::OpenAPI::fromJsonValue(m_url_rewrites, json[QString("url_rewrites")]);
    m_url_rewrites_isSet = !json[QString("url_rewrites")].isNull() && m_url_rewrites_isValid;

    m_r_virtual_isValid = ::OpenAPI::fromJsonValue(m_r_virtual, json[QString("virtual")]);
    m_r_virtual_isSet = !json[QString("virtual")].isNull() && m_r_virtual_isValid;

    m_white_list_isValid = ::OpenAPI::fromJsonValue(m_white_list, json[QString("white_list")]);
    m_white_list_isSet = !json[QString("white_list")].isNull() && m_white_list_isValid;
}

QString OAIVersionDefinition_extended_paths::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIVersionDefinition_extended_paths::asJsonObject() const {
    QJsonObject obj;
    if (m_black_list.size() > 0) {
        obj.insert(QString("black_list"), ::OpenAPI::toJsonValue(m_black_list));
    }
    if (m_cache.size() > 0) {
        obj.insert(QString("cache"), ::OpenAPI::toJsonValue(m_cache));
    }
    if (m_circuit_breakers.size() > 0) {
        obj.insert(QString("circuit_breakers"), ::OpenAPI::toJsonValue(m_circuit_breakers));
    }
    if (m_hard_timeouts.size() > 0) {
        obj.insert(QString("hard_timeouts"), ::OpenAPI::toJsonValue(m_hard_timeouts));
    }
    if (m_ignored.size() > 0) {
        obj.insert(QString("ignored"), ::OpenAPI::toJsonValue(m_ignored));
    }
    if (m_size_limits.size() > 0) {
        obj.insert(QString("size_limits"), ::OpenAPI::toJsonValue(m_size_limits));
    }
    if (m_transform.size() > 0) {
        obj.insert(QString("transform"), ::OpenAPI::toJsonValue(m_transform));
    }
    if (m_transform_headers.size() > 0) {
        obj.insert(QString("transform_headers"), ::OpenAPI::toJsonValue(m_transform_headers));
    }
    if (m_transform_response.size() > 0) {
        obj.insert(QString("transform_response"), ::OpenAPI::toJsonValue(m_transform_response));
    }
    if (m_transform_response_headers.size() > 0) {
        obj.insert(QString("transform_response_headers"), ::OpenAPI::toJsonValue(m_transform_response_headers));
    }
    if (m_url_rewrites.size() > 0) {
        obj.insert(QString("url_rewrites"), ::OpenAPI::toJsonValue(m_url_rewrites));
    }
    if (m_r_virtual.size() > 0) {
        obj.insert(QString("virtual"), ::OpenAPI::toJsonValue(m_r_virtual));
    }
    if (m_white_list.size() > 0) {
        obj.insert(QString("white_list"), ::OpenAPI::toJsonValue(m_white_list));
    }
    return obj;
}

QList<OAIEndPointMeta> OAIVersionDefinition_extended_paths::getBlackList() const {
    return m_black_list;
}
void OAIVersionDefinition_extended_paths::setBlackList(const QList<OAIEndPointMeta> &black_list) {
    m_black_list = black_list;
    m_black_list_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_black_list_Set() const{
    return m_black_list_isSet;
}

bool OAIVersionDefinition_extended_paths::is_black_list_Valid() const{
    return m_black_list_isValid;
}

QList<QString> OAIVersionDefinition_extended_paths::getCache() const {
    return m_cache;
}
void OAIVersionDefinition_extended_paths::setCache(const QList<QString> &cache) {
    m_cache = cache;
    m_cache_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_cache_Set() const{
    return m_cache_isSet;
}

bool OAIVersionDefinition_extended_paths::is_cache_Valid() const{
    return m_cache_isValid;
}

QList<OAIVersionDefinition_extended_paths_circuit_breakers_inner> OAIVersionDefinition_extended_paths::getCircuitBreakers() const {
    return m_circuit_breakers;
}
void OAIVersionDefinition_extended_paths::setCircuitBreakers(const QList<OAIVersionDefinition_extended_paths_circuit_breakers_inner> &circuit_breakers) {
    m_circuit_breakers = circuit_breakers;
    m_circuit_breakers_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_circuit_breakers_Set() const{
    return m_circuit_breakers_isSet;
}

bool OAIVersionDefinition_extended_paths::is_circuit_breakers_Valid() const{
    return m_circuit_breakers_isValid;
}

QList<OAIVersionDefinition_extended_paths_hard_timeouts_inner> OAIVersionDefinition_extended_paths::getHardTimeouts() const {
    return m_hard_timeouts;
}
void OAIVersionDefinition_extended_paths::setHardTimeouts(const QList<OAIVersionDefinition_extended_paths_hard_timeouts_inner> &hard_timeouts) {
    m_hard_timeouts = hard_timeouts;
    m_hard_timeouts_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_hard_timeouts_Set() const{
    return m_hard_timeouts_isSet;
}

bool OAIVersionDefinition_extended_paths::is_hard_timeouts_Valid() const{
    return m_hard_timeouts_isValid;
}

QList<OAIEndPointMeta> OAIVersionDefinition_extended_paths::getIgnored() const {
    return m_ignored;
}
void OAIVersionDefinition_extended_paths::setIgnored(const QList<OAIEndPointMeta> &ignored) {
    m_ignored = ignored;
    m_ignored_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_ignored_Set() const{
    return m_ignored_isSet;
}

bool OAIVersionDefinition_extended_paths::is_ignored_Valid() const{
    return m_ignored_isValid;
}

QList<OAIVersionDefinition_extended_paths_size_limits_inner> OAIVersionDefinition_extended_paths::getSizeLimits() const {
    return m_size_limits;
}
void OAIVersionDefinition_extended_paths::setSizeLimits(const QList<OAIVersionDefinition_extended_paths_size_limits_inner> &size_limits) {
    m_size_limits = size_limits;
    m_size_limits_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_size_limits_Set() const{
    return m_size_limits_isSet;
}

bool OAIVersionDefinition_extended_paths::is_size_limits_Valid() const{
    return m_size_limits_isValid;
}

QList<OAITemplateMeta> OAIVersionDefinition_extended_paths::getTransform() const {
    return m_transform;
}
void OAIVersionDefinition_extended_paths::setTransform(const QList<OAITemplateMeta> &transform) {
    m_transform = transform;
    m_transform_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_transform_Set() const{
    return m_transform_isSet;
}

bool OAIVersionDefinition_extended_paths::is_transform_Valid() const{
    return m_transform_isValid;
}

QList<OAIHeaderInjectionMeta> OAIVersionDefinition_extended_paths::getTransformHeaders() const {
    return m_transform_headers;
}
void OAIVersionDefinition_extended_paths::setTransformHeaders(const QList<OAIHeaderInjectionMeta> &transform_headers) {
    m_transform_headers = transform_headers;
    m_transform_headers_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_transform_headers_Set() const{
    return m_transform_headers_isSet;
}

bool OAIVersionDefinition_extended_paths::is_transform_headers_Valid() const{
    return m_transform_headers_isValid;
}

QList<OAITemplateMeta> OAIVersionDefinition_extended_paths::getTransformResponse() const {
    return m_transform_response;
}
void OAIVersionDefinition_extended_paths::setTransformResponse(const QList<OAITemplateMeta> &transform_response) {
    m_transform_response = transform_response;
    m_transform_response_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_transform_response_Set() const{
    return m_transform_response_isSet;
}

bool OAIVersionDefinition_extended_paths::is_transform_response_Valid() const{
    return m_transform_response_isValid;
}

QList<OAIHeaderInjectionMeta> OAIVersionDefinition_extended_paths::getTransformResponseHeaders() const {
    return m_transform_response_headers;
}
void OAIVersionDefinition_extended_paths::setTransformResponseHeaders(const QList<OAIHeaderInjectionMeta> &transform_response_headers) {
    m_transform_response_headers = transform_response_headers;
    m_transform_response_headers_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_transform_response_headers_Set() const{
    return m_transform_response_headers_isSet;
}

bool OAIVersionDefinition_extended_paths::is_transform_response_headers_Valid() const{
    return m_transform_response_headers_isValid;
}

QList<OAIVersionDefinition_extended_paths_url_rewrites_inner> OAIVersionDefinition_extended_paths::getUrlRewrites() const {
    return m_url_rewrites;
}
void OAIVersionDefinition_extended_paths::setUrlRewrites(const QList<OAIVersionDefinition_extended_paths_url_rewrites_inner> &url_rewrites) {
    m_url_rewrites = url_rewrites;
    m_url_rewrites_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_url_rewrites_Set() const{
    return m_url_rewrites_isSet;
}

bool OAIVersionDefinition_extended_paths::is_url_rewrites_Valid() const{
    return m_url_rewrites_isValid;
}

QList<OAIVersionDefinition_extended_paths_virtual_inner> OAIVersionDefinition_extended_paths::getRVirtual() const {
    return m_r_virtual;
}
void OAIVersionDefinition_extended_paths::setRVirtual(const QList<OAIVersionDefinition_extended_paths_virtual_inner> &r_virtual) {
    m_r_virtual = r_virtual;
    m_r_virtual_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_r_virtual_Set() const{
    return m_r_virtual_isSet;
}

bool OAIVersionDefinition_extended_paths::is_r_virtual_Valid() const{
    return m_r_virtual_isValid;
}

QList<OAIEndPointMeta> OAIVersionDefinition_extended_paths::getWhiteList() const {
    return m_white_list;
}
void OAIVersionDefinition_extended_paths::setWhiteList(const QList<OAIEndPointMeta> &white_list) {
    m_white_list = white_list;
    m_white_list_isSet = true;
}

bool OAIVersionDefinition_extended_paths::is_white_list_Set() const{
    return m_white_list_isSet;
}

bool OAIVersionDefinition_extended_paths::is_white_list_Valid() const{
    return m_white_list_isValid;
}

bool OAIVersionDefinition_extended_paths::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_black_list.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_cache.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_circuit_breakers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_hard_timeouts.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_ignored.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_size_limits.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_transform.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_transform_headers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_transform_response.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_transform_response_headers.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_url_rewrites.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_virtual.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_white_list.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIVersionDefinition_extended_paths::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
