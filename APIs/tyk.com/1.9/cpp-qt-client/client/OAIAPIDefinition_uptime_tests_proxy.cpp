/**
 * Gateway REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.9
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAPIDefinition_uptime_tests_proxy.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAPIDefinition_uptime_tests_proxy::OAIAPIDefinition_uptime_tests_proxy(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAPIDefinition_uptime_tests_proxy::OAIAPIDefinition_uptime_tests_proxy() {
    this->initializeModel();
}

OAIAPIDefinition_uptime_tests_proxy::~OAIAPIDefinition_uptime_tests_proxy() {}

void OAIAPIDefinition_uptime_tests_proxy::initializeModel() {

    m_check_host_against_uptime_tests_isSet = false;
    m_check_host_against_uptime_tests_isValid = false;

    m_enable_load_balancing_isSet = false;
    m_enable_load_balancing_isValid = false;

    m_listen_path_isSet = false;
    m_listen_path_isValid = false;

    m_preserve_host_header_isSet = false;
    m_preserve_host_header_isValid = false;

    m_service_discovery_isSet = false;
    m_service_discovery_isValid = false;

    m_strip_listen_path_isSet = false;
    m_strip_listen_path_isValid = false;

    m_target_list_isSet = false;
    m_target_list_isValid = false;

    m_target_url_isSet = false;
    m_target_url_isValid = false;
}

void OAIAPIDefinition_uptime_tests_proxy::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAPIDefinition_uptime_tests_proxy::fromJsonObject(QJsonObject json) {

    m_check_host_against_uptime_tests_isValid = ::OpenAPI::fromJsonValue(m_check_host_against_uptime_tests, json[QString("check_host_against_uptime_tests")]);
    m_check_host_against_uptime_tests_isSet = !json[QString("check_host_against_uptime_tests")].isNull() && m_check_host_against_uptime_tests_isValid;

    m_enable_load_balancing_isValid = ::OpenAPI::fromJsonValue(m_enable_load_balancing, json[QString("enable_load_balancing")]);
    m_enable_load_balancing_isSet = !json[QString("enable_load_balancing")].isNull() && m_enable_load_balancing_isValid;

    m_listen_path_isValid = ::OpenAPI::fromJsonValue(m_listen_path, json[QString("listen_path")]);
    m_listen_path_isSet = !json[QString("listen_path")].isNull() && m_listen_path_isValid;

    m_preserve_host_header_isValid = ::OpenAPI::fromJsonValue(m_preserve_host_header, json[QString("preserve_host_header")]);
    m_preserve_host_header_isSet = !json[QString("preserve_host_header")].isNull() && m_preserve_host_header_isValid;

    m_service_discovery_isValid = ::OpenAPI::fromJsonValue(m_service_discovery, json[QString("service_discovery")]);
    m_service_discovery_isSet = !json[QString("service_discovery")].isNull() && m_service_discovery_isValid;

    m_strip_listen_path_isValid = ::OpenAPI::fromJsonValue(m_strip_listen_path, json[QString("strip_listen_path")]);
    m_strip_listen_path_isSet = !json[QString("strip_listen_path")].isNull() && m_strip_listen_path_isValid;

    m_target_list_isValid = ::OpenAPI::fromJsonValue(m_target_list, json[QString("target_list")]);
    m_target_list_isSet = !json[QString("target_list")].isNull() && m_target_list_isValid;

    m_target_url_isValid = ::OpenAPI::fromJsonValue(m_target_url, json[QString("target_url")]);
    m_target_url_isSet = !json[QString("target_url")].isNull() && m_target_url_isValid;
}

QString OAIAPIDefinition_uptime_tests_proxy::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAPIDefinition_uptime_tests_proxy::asJsonObject() const {
    QJsonObject obj;
    if (m_check_host_against_uptime_tests_isSet) {
        obj.insert(QString("check_host_against_uptime_tests"), ::OpenAPI::toJsonValue(m_check_host_against_uptime_tests));
    }
    if (m_enable_load_balancing_isSet) {
        obj.insert(QString("enable_load_balancing"), ::OpenAPI::toJsonValue(m_enable_load_balancing));
    }
    if (m_listen_path_isSet) {
        obj.insert(QString("listen_path"), ::OpenAPI::toJsonValue(m_listen_path));
    }
    if (m_preserve_host_header_isSet) {
        obj.insert(QString("preserve_host_header"), ::OpenAPI::toJsonValue(m_preserve_host_header));
    }
    if (m_service_discovery.isSet()) {
        obj.insert(QString("service_discovery"), ::OpenAPI::toJsonValue(m_service_discovery));
    }
    if (m_strip_listen_path_isSet) {
        obj.insert(QString("strip_listen_path"), ::OpenAPI::toJsonValue(m_strip_listen_path));
    }
    if (m_target_list.size() > 0) {
        obj.insert(QString("target_list"), ::OpenAPI::toJsonValue(m_target_list));
    }
    if (m_target_url_isSet) {
        obj.insert(QString("target_url"), ::OpenAPI::toJsonValue(m_target_url));
    }
    return obj;
}

bool OAIAPIDefinition_uptime_tests_proxy::isCheckHostAgainstUptimeTests() const {
    return m_check_host_against_uptime_tests;
}
void OAIAPIDefinition_uptime_tests_proxy::setCheckHostAgainstUptimeTests(const bool &check_host_against_uptime_tests) {
    m_check_host_against_uptime_tests = check_host_against_uptime_tests;
    m_check_host_against_uptime_tests_isSet = true;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_check_host_against_uptime_tests_Set() const{
    return m_check_host_against_uptime_tests_isSet;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_check_host_against_uptime_tests_Valid() const{
    return m_check_host_against_uptime_tests_isValid;
}

bool OAIAPIDefinition_uptime_tests_proxy::isEnableLoadBalancing() const {
    return m_enable_load_balancing;
}
void OAIAPIDefinition_uptime_tests_proxy::setEnableLoadBalancing(const bool &enable_load_balancing) {
    m_enable_load_balancing = enable_load_balancing;
    m_enable_load_balancing_isSet = true;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_enable_load_balancing_Set() const{
    return m_enable_load_balancing_isSet;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_enable_load_balancing_Valid() const{
    return m_enable_load_balancing_isValid;
}

QString OAIAPIDefinition_uptime_tests_proxy::getListenPath() const {
    return m_listen_path;
}
void OAIAPIDefinition_uptime_tests_proxy::setListenPath(const QString &listen_path) {
    m_listen_path = listen_path;
    m_listen_path_isSet = true;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_listen_path_Set() const{
    return m_listen_path_isSet;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_listen_path_Valid() const{
    return m_listen_path_isValid;
}

bool OAIAPIDefinition_uptime_tests_proxy::isPreserveHostHeader() const {
    return m_preserve_host_header;
}
void OAIAPIDefinition_uptime_tests_proxy::setPreserveHostHeader(const bool &preserve_host_header) {
    m_preserve_host_header = preserve_host_header;
    m_preserve_host_header_isSet = true;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_preserve_host_header_Set() const{
    return m_preserve_host_header_isSet;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_preserve_host_header_Valid() const{
    return m_preserve_host_header_isValid;
}

OAIServiceDiscoverConfiguration OAIAPIDefinition_uptime_tests_proxy::getServiceDiscovery() const {
    return m_service_discovery;
}
void OAIAPIDefinition_uptime_tests_proxy::setServiceDiscovery(const OAIServiceDiscoverConfiguration &service_discovery) {
    m_service_discovery = service_discovery;
    m_service_discovery_isSet = true;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_service_discovery_Set() const{
    return m_service_discovery_isSet;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_service_discovery_Valid() const{
    return m_service_discovery_isValid;
}

bool OAIAPIDefinition_uptime_tests_proxy::isStripListenPath() const {
    return m_strip_listen_path;
}
void OAIAPIDefinition_uptime_tests_proxy::setStripListenPath(const bool &strip_listen_path) {
    m_strip_listen_path = strip_listen_path;
    m_strip_listen_path_isSet = true;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_strip_listen_path_Set() const{
    return m_strip_listen_path_isSet;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_strip_listen_path_Valid() const{
    return m_strip_listen_path_isValid;
}

QList<QString> OAIAPIDefinition_uptime_tests_proxy::getTargetList() const {
    return m_target_list;
}
void OAIAPIDefinition_uptime_tests_proxy::setTargetList(const QList<QString> &target_list) {
    m_target_list = target_list;
    m_target_list_isSet = true;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_target_list_Set() const{
    return m_target_list_isSet;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_target_list_Valid() const{
    return m_target_list_isValid;
}

QString OAIAPIDefinition_uptime_tests_proxy::getTargetUrl() const {
    return m_target_url;
}
void OAIAPIDefinition_uptime_tests_proxy::setTargetUrl(const QString &target_url) {
    m_target_url = target_url;
    m_target_url_isSet = true;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_target_url_Set() const{
    return m_target_url_isSet;
}

bool OAIAPIDefinition_uptime_tests_proxy::is_target_url_Valid() const{
    return m_target_url_isValid;
}

bool OAIAPIDefinition_uptime_tests_proxy::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_check_host_against_uptime_tests_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_load_balancing_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_listen_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_preserve_host_header_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_discovery.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_strip_listen_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_target_list.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_target_url_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAPIDefinition_uptime_tests_proxy::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
