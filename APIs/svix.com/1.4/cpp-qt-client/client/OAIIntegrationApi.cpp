/**
 * Svix API
 * Welcome to the Svix API documentation!  Useful links: [Homepage](https://www.svix.com) | [Support email](mailto:support+docs@svix.com) | [Blog](https://www.svix.com/blog/) | [Slack Community](https://www.svix.com/slack/)  # Introduction  This is the reference documentation and schemas for the [Svix webhook service](https://www.svix.com) API. For tutorials and other documentation please refer to [the documentation](https://docs.svix.com).  ## Main concepts  In Svix you have four important entities you will be interacting with:  - `messages`: these are the webhooks being sent. They can have contents and a few other properties. - `application`: this is where `messages` are sent to. Usually you want to create one application for each user on your platform. - `endpoint`: endpoints are the URLs messages will be sent to. Each application can have multiple `endpoints` and each message sent to that application will be sent to all of them (unless they are not subscribed to the sent event type). - `event-type`: event types are identifiers denoting the type of the message being sent. Event types are primarily used to decide which events are sent to which endpoint.   ## Authentication  Get your authentication token (`AUTH_TOKEN`) from the [Svix dashboard](https://dashboard.svix.com) and use it as part of the `Authorization` header as such: `Authorization: Bearer ${AUTH_TOKEN}`.  <SecurityDefinitions />   ## Code samples  The code samples assume you already have the respective libraries installed and you know how to use them. For the latest information on how to do that, please refer to [the documentation](https://docs.svix.com/).   ## Idempotency  Svix supports [idempotency](https://en.wikipedia.org/wiki/Idempotence) for safely retrying requests without accidentally performing the same operation twice. This is useful when an API call is disrupted in transit and you do not receive a response.  To perform an idempotent request, pass the idempotency key in the `Idempotency-Key` header to the request. The idempotency key should be a unique value generated by the client. You can create the key in however way you like, though we suggest using UUID v4, or any other string with enough entropy to avoid collisions.  Svix's idempotency works by saving the resulting status code and body of the first request made for any given idempotency key for any successful request. Subsequent requests with the same key return the same result.  Please note that idempotency is only supported for `POST` requests.   ## Cross-Origin Resource Sharing  This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with [W3C spec](https://www.w3.org/TR/cors/). And that allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site. 
 *
 * The version of the OpenAPI document: 1.4
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIIntegrationApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIIntegrationApi::OAIIntegrationApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIIntegrationApi::~OAIIntegrationApi() {
}

void OAIIntegrationApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("createIntegrationApiV1AppAppIdIntegrationPost", defaultConf);
    _serverIndices.insert("createIntegrationApiV1AppAppIdIntegrationPost", 0);
    _serverConfigs.insert("deleteIntegrationApiV1AppAppIdIntegrationIntegIdDelete", defaultConf);
    _serverIndices.insert("deleteIntegrationApiV1AppAppIdIntegrationIntegIdDelete", 0);
    _serverConfigs.insert("getIntegrationApiV1AppAppIdIntegrationIntegIdGet", defaultConf);
    _serverIndices.insert("getIntegrationApiV1AppAppIdIntegrationIntegIdGet", 0);
    _serverConfigs.insert("getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGet", defaultConf);
    _serverIndices.insert("getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGet", 0);
    _serverConfigs.insert("listIntegrationsApiV1AppAppIdIntegrationGet", defaultConf);
    _serverIndices.insert("listIntegrationsApiV1AppAppIdIntegrationGet", 0);
    _serverConfigs.insert("rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePost", defaultConf);
    _serverIndices.insert("rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePost", 0);
    _serverConfigs.insert("updateIntegrationApiV1AppAppIdIntegrationIntegIdPut", defaultConf);
    _serverIndices.insert("updateIntegrationApiV1AppAppIdIntegrationIntegIdPut", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIIntegrationApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIIntegrationApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIIntegrationApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIIntegrationApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIIntegrationApi::setUsername(const QString &username) {
    _username = username;
}

void OAIIntegrationApi::setPassword(const QString &password) {
    _password = password;
}


void OAIIntegrationApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIIntegrationApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIIntegrationApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIIntegrationApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIIntegrationApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIIntegrationApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIIntegrationApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIIntegrationApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIIntegrationApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIIntegrationApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIIntegrationApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIIntegrationApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIIntegrationApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIIntegrationApi::createIntegrationApiV1AppAppIdIntegrationPost(const QString &app_id, const OAIIntegrationIn &oai_integration_in, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["createIntegrationApiV1AppAppIdIntegrationPost"][_serverIndices.value("createIntegrationApiV1AppAppIdIntegrationPost")].URL()+"/api/v1/app/{app_id}/integration/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("app_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "app_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"app_id"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_integration_in.asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIntegrationApi::createIntegrationApiV1AppAppIdIntegrationPostCallback);
    connect(this, &OAIIntegrationApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIIntegrationApi::createIntegrationApiV1AppAppIdIntegrationPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIntegrationOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createIntegrationApiV1AppAppIdIntegrationPostSignal(output);
        Q_EMIT createIntegrationApiV1AppAppIdIntegrationPostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createIntegrationApiV1AppAppIdIntegrationPostSignalE(output, error_type, error_str);
        Q_EMIT createIntegrationApiV1AppAppIdIntegrationPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createIntegrationApiV1AppAppIdIntegrationPostSignalError(output, error_type, error_str);
        Q_EMIT createIntegrationApiV1AppAppIdIntegrationPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIntegrationApi::deleteIntegrationApiV1AppAppIdIntegrationIntegIdDelete(const QString &integ_id, const QString &app_id, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["deleteIntegrationApiV1AppAppIdIntegrationIntegIdDelete"][_serverIndices.value("deleteIntegrationApiV1AppAppIdIntegrationIntegIdDelete")].URL()+"/api/v1/app/{app_id}/integration/{integ_id}/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString integ_idPathParam("{");
        integ_idPathParam.append("integ_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "integ_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"integ_id"+pathSuffix : pathPrefix;
        fullPath.replace(integ_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(integ_id)));
    }
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("app_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "app_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"app_id"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIntegrationApi::deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteCallback);
    connect(this, &OAIIntegrationApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIIntegrationApi::deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteSignal();
        Q_EMIT deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteSignalE(error_type, error_str);
        Q_EMIT deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteSignalError(error_type, error_str);
        Q_EMIT deleteIntegrationApiV1AppAppIdIntegrationIntegIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIntegrationApi::getIntegrationApiV1AppAppIdIntegrationIntegIdGet(const QString &integ_id, const QString &app_id, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["getIntegrationApiV1AppAppIdIntegrationIntegIdGet"][_serverIndices.value("getIntegrationApiV1AppAppIdIntegrationIntegIdGet")].URL()+"/api/v1/app/{app_id}/integration/{integ_id}/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString integ_idPathParam("{");
        integ_idPathParam.append("integ_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "integ_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"integ_id"+pathSuffix : pathPrefix;
        fullPath.replace(integ_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(integ_id)));
    }
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("app_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "app_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"app_id"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIntegrationApi::getIntegrationApiV1AppAppIdIntegrationIntegIdGetCallback);
    connect(this, &OAIIntegrationApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIIntegrationApi::getIntegrationApiV1AppAppIdIntegrationIntegIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIntegrationOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getIntegrationApiV1AppAppIdIntegrationIntegIdGetSignal(output);
        Q_EMIT getIntegrationApiV1AppAppIdIntegrationIntegIdGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getIntegrationApiV1AppAppIdIntegrationIntegIdGetSignalE(output, error_type, error_str);
        Q_EMIT getIntegrationApiV1AppAppIdIntegrationIntegIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getIntegrationApiV1AppAppIdIntegrationIntegIdGetSignalError(output, error_type, error_str);
        Q_EMIT getIntegrationApiV1AppAppIdIntegrationIntegIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIntegrationApi::getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGet(const QString &integ_id, const QString &app_id, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGet"][_serverIndices.value("getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGet")].URL()+"/api/v1/app/{app_id}/integration/{integ_id}/key/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString integ_idPathParam("{");
        integ_idPathParam.append("integ_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "integ_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"integ_id"+pathSuffix : pathPrefix;
        fullPath.replace(integ_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(integ_id)));
    }
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("app_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "app_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"app_id"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIntegrationApi::getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetCallback);
    connect(this, &OAIIntegrationApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIIntegrationApi::getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIntegrationKeyOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetSignal(output);
        Q_EMIT getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetSignalE(output, error_type, error_str);
        Q_EMIT getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetSignalError(output, error_type, error_str);
        Q_EMIT getIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIntegrationApi::listIntegrationsApiV1AppAppIdIntegrationGet(const QString &app_id, const ::OpenAPI::OptionalParam<QString> &iterator, const ::OpenAPI::OptionalParam<qint32> &limit, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["listIntegrationsApiV1AppAppIdIntegrationGet"][_serverIndices.value("listIntegrationsApiV1AppAppIdIntegrationGet")].URL()+"/api/v1/app/{app_id}/integration/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("app_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "app_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"app_id"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (iterator.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "iterator", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("iterator")).append(querySuffix).append(QUrl::toPercentEncoding(iterator.stringValue()));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(limit.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIntegrationApi::listIntegrationsApiV1AppAppIdIntegrationGetCallback);
    connect(this, &OAIIntegrationApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIIntegrationApi::listIntegrationsApiV1AppAppIdIntegrationGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIListResponse_IntegrationOut_ output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listIntegrationsApiV1AppAppIdIntegrationGetSignal(output);
        Q_EMIT listIntegrationsApiV1AppAppIdIntegrationGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listIntegrationsApiV1AppAppIdIntegrationGetSignalE(output, error_type, error_str);
        Q_EMIT listIntegrationsApiV1AppAppIdIntegrationGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listIntegrationsApiV1AppAppIdIntegrationGetSignalError(output, error_type, error_str);
        Q_EMIT listIntegrationsApiV1AppAppIdIntegrationGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIntegrationApi::rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePost(const QString &integ_id, const QString &app_id, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePost"][_serverIndices.value("rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePost")].URL()+"/api/v1/app/{app_id}/integration/{integ_id}/key/rotate/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString integ_idPathParam("{");
        integ_idPathParam.append("integ_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "integ_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"integ_id"+pathSuffix : pathPrefix;
        fullPath.replace(integ_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(integ_id)));
    }
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("app_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "app_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"app_id"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIntegrationApi::rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostCallback);
    connect(this, &OAIIntegrationApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIIntegrationApi::rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIntegrationKeyOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostSignal(output);
        Q_EMIT rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostSignalE(output, error_type, error_str);
        Q_EMIT rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostSignalError(output, error_type, error_str);
        Q_EMIT rotateIntegrationKeyApiV1AppAppIdIntegrationIntegIdKeyRotatePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIntegrationApi::updateIntegrationApiV1AppAppIdIntegrationIntegIdPut(const QString &integ_id, const QString &app_id, const OAIIntegrationUpdate &oai_integration_update, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["updateIntegrationApiV1AppAppIdIntegrationIntegIdPut"][_serverIndices.value("updateIntegrationApiV1AppAppIdIntegrationIntegIdPut")].URL()+"/api/v1/app/{app_id}/integration/{integ_id}/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString integ_idPathParam("{");
        integ_idPathParam.append("integ_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "integ_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"integ_id"+pathSuffix : pathPrefix;
        fullPath.replace(integ_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(integ_id)));
    }
    
    {
        QString app_idPathParam("{");
        app_idPathParam.append("app_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "app_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"app_id"+pathSuffix : pathPrefix;
        fullPath.replace(app_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(app_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_integration_update.asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIntegrationApi::updateIntegrationApiV1AppAppIdIntegrationIntegIdPutCallback);
    connect(this, &OAIIntegrationApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIIntegrationApi::updateIntegrationApiV1AppAppIdIntegrationIntegIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIntegrationOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateIntegrationApiV1AppAppIdIntegrationIntegIdPutSignal(output);
        Q_EMIT updateIntegrationApiV1AppAppIdIntegrationIntegIdPutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateIntegrationApiV1AppAppIdIntegrationIntegIdPutSignalE(output, error_type, error_str);
        Q_EMIT updateIntegrationApiV1AppAppIdIntegrationIntegIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateIntegrationApiV1AppAppIdIntegrationIntegIdPutSignalError(output, error_type, error_str);
        Q_EMIT updateIntegrationApiV1AppAppIdIntegrationIntegIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIntegrationApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
