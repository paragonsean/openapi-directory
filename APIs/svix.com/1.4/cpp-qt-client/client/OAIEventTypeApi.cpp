/**
 * Svix API
 * Welcome to the Svix API documentation!  Useful links: [Homepage](https://www.svix.com) | [Support email](mailto:support+docs@svix.com) | [Blog](https://www.svix.com/blog/) | [Slack Community](https://www.svix.com/slack/)  # Introduction  This is the reference documentation and schemas for the [Svix webhook service](https://www.svix.com) API. For tutorials and other documentation please refer to [the documentation](https://docs.svix.com).  ## Main concepts  In Svix you have four important entities you will be interacting with:  - `messages`: these are the webhooks being sent. They can have contents and a few other properties. - `application`: this is where `messages` are sent to. Usually you want to create one application for each user on your platform. - `endpoint`: endpoints are the URLs messages will be sent to. Each application can have multiple `endpoints` and each message sent to that application will be sent to all of them (unless they are not subscribed to the sent event type). - `event-type`: event types are identifiers denoting the type of the message being sent. Event types are primarily used to decide which events are sent to which endpoint.   ## Authentication  Get your authentication token (`AUTH_TOKEN`) from the [Svix dashboard](https://dashboard.svix.com) and use it as part of the `Authorization` header as such: `Authorization: Bearer ${AUTH_TOKEN}`.  <SecurityDefinitions />   ## Code samples  The code samples assume you already have the respective libraries installed and you know how to use them. For the latest information on how to do that, please refer to [the documentation](https://docs.svix.com/).   ## Idempotency  Svix supports [idempotency](https://en.wikipedia.org/wiki/Idempotence) for safely retrying requests without accidentally performing the same operation twice. This is useful when an API call is disrupted in transit and you do not receive a response.  To perform an idempotent request, pass the idempotency key in the `Idempotency-Key` header to the request. The idempotency key should be a unique value generated by the client. You can create the key in however way you like, though we suggest using UUID v4, or any other string with enough entropy to avoid collisions.  Svix's idempotency works by saving the resulting status code and body of the first request made for any given idempotency key for any successful request. Subsequent requests with the same key return the same result.  Please note that idempotency is only supported for `POST` requests.   ## Cross-Origin Resource Sharing  This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with [W3C spec](https://www.w3.org/TR/cors/). And that allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site. 
 *
 * The version of the OpenAPI document: 1.4
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIEventTypeApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIEventTypeApi::OAIEventTypeApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIEventTypeApi::~OAIEventTypeApi() {
}

void OAIEventTypeApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("/"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("createEventTypeApiV1EventTypePost", defaultConf);
    _serverIndices.insert("createEventTypeApiV1EventTypePost", 0);
    _serverConfigs.insert("deleteEventTypeApiV1EventTypeEventTypeNameDelete", defaultConf);
    _serverIndices.insert("deleteEventTypeApiV1EventTypeEventTypeNameDelete", 0);
    _serverConfigs.insert("getEventTypeApiV1EventTypeEventTypeNameGet", defaultConf);
    _serverIndices.insert("getEventTypeApiV1EventTypeEventTypeNameGet", 0);
    _serverConfigs.insert("listEventTypesApiV1EventTypeGet", defaultConf);
    _serverIndices.insert("listEventTypesApiV1EventTypeGet", 0);
    _serverConfigs.insert("updateEventTypeApiV1EventTypeEventTypeNamePut", defaultConf);
    _serverIndices.insert("updateEventTypeApiV1EventTypeEventTypeNamePut", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIEventTypeApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIEventTypeApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIEventTypeApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIEventTypeApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIEventTypeApi::setUsername(const QString &username) {
    _username = username;
}

void OAIEventTypeApi::setPassword(const QString &password) {
    _password = password;
}


void OAIEventTypeApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIEventTypeApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIEventTypeApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIEventTypeApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIEventTypeApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIEventTypeApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIEventTypeApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIEventTypeApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIEventTypeApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIEventTypeApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIEventTypeApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIEventTypeApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIEventTypeApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIEventTypeApi::createEventTypeApiV1EventTypePost(const OAIEventTypeIn &oai_event_type_in, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["createEventTypeApiV1EventTypePost"][_serverIndices.value("createEventTypeApiV1EventTypePost")].URL()+"/api/v1/event-type/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_event_type_in.asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIEventTypeApi::createEventTypeApiV1EventTypePostCallback);
    connect(this, &OAIEventTypeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIEventTypeApi::createEventTypeApiV1EventTypePostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEventTypeOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createEventTypeApiV1EventTypePostSignal(output);
        Q_EMIT createEventTypeApiV1EventTypePostSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createEventTypeApiV1EventTypePostSignalE(output, error_type, error_str);
        Q_EMIT createEventTypeApiV1EventTypePostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createEventTypeApiV1EventTypePostSignalError(output, error_type, error_str);
        Q_EMIT createEventTypeApiV1EventTypePostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIEventTypeApi::deleteEventTypeApiV1EventTypeEventTypeNameDelete(const QString &event_type_name, const ::OpenAPI::OptionalParam<bool> &expunge, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["deleteEventTypeApiV1EventTypeEventTypeNameDelete"][_serverIndices.value("deleteEventTypeApiV1EventTypeEventTypeNameDelete")].URL()+"/api/v1/event-type/{event_type_name}/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString event_type_namePathParam("{");
        event_type_namePathParam.append("event_type_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "event_type_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"event_type_name"+pathSuffix : pathPrefix;
        fullPath.replace(event_type_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(event_type_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (expunge.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "expunge", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("expunge")).append(querySuffix).append(QUrl::toPercentEncoding(expunge.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIEventTypeApi::deleteEventTypeApiV1EventTypeEventTypeNameDeleteCallback);
    connect(this, &OAIEventTypeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIEventTypeApi::deleteEventTypeApiV1EventTypeEventTypeNameDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteEventTypeApiV1EventTypeEventTypeNameDeleteSignal();
        Q_EMIT deleteEventTypeApiV1EventTypeEventTypeNameDeleteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteEventTypeApiV1EventTypeEventTypeNameDeleteSignalE(error_type, error_str);
        Q_EMIT deleteEventTypeApiV1EventTypeEventTypeNameDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteEventTypeApiV1EventTypeEventTypeNameDeleteSignalError(error_type, error_str);
        Q_EMIT deleteEventTypeApiV1EventTypeEventTypeNameDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIEventTypeApi::getEventTypeApiV1EventTypeEventTypeNameGet(const QString &event_type_name, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["getEventTypeApiV1EventTypeEventTypeNameGet"][_serverIndices.value("getEventTypeApiV1EventTypeEventTypeNameGet")].URL()+"/api/v1/event-type/{event_type_name}/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString event_type_namePathParam("{");
        event_type_namePathParam.append("event_type_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "event_type_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"event_type_name"+pathSuffix : pathPrefix;
        fullPath.replace(event_type_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(event_type_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIEventTypeApi::getEventTypeApiV1EventTypeEventTypeNameGetCallback);
    connect(this, &OAIEventTypeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIEventTypeApi::getEventTypeApiV1EventTypeEventTypeNameGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEventTypeOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getEventTypeApiV1EventTypeEventTypeNameGetSignal(output);
        Q_EMIT getEventTypeApiV1EventTypeEventTypeNameGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getEventTypeApiV1EventTypeEventTypeNameGetSignalE(output, error_type, error_str);
        Q_EMIT getEventTypeApiV1EventTypeEventTypeNameGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getEventTypeApiV1EventTypeEventTypeNameGetSignalError(output, error_type, error_str);
        Q_EMIT getEventTypeApiV1EventTypeEventTypeNameGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIEventTypeApi::listEventTypesApiV1EventTypeGet(const ::OpenAPI::OptionalParam<QString> &iterator, const ::OpenAPI::OptionalParam<qint32> &limit, const ::OpenAPI::OptionalParam<bool> &with_content, const ::OpenAPI::OptionalParam<bool> &include_archived, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["listEventTypesApiV1EventTypeGet"][_serverIndices.value("listEventTypesApiV1EventTypeGet")].URL()+"/api/v1/event-type/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (iterator.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "iterator", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("iterator")).append(querySuffix).append(QUrl::toPercentEncoding(iterator.stringValue()));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(limit.stringValue()));
    }
    if (with_content.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_content", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_content")).append(querySuffix).append(QUrl::toPercentEncoding(with_content.stringValue()));
    }
    if (include_archived.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "include_archived", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("include_archived")).append(querySuffix).append(QUrl::toPercentEncoding(include_archived.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIEventTypeApi::listEventTypesApiV1EventTypeGetCallback);
    connect(this, &OAIEventTypeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIEventTypeApi::listEventTypesApiV1EventTypeGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIListResponse_EventTypeOut_ output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listEventTypesApiV1EventTypeGetSignal(output);
        Q_EMIT listEventTypesApiV1EventTypeGetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listEventTypesApiV1EventTypeGetSignalE(output, error_type, error_str);
        Q_EMIT listEventTypesApiV1EventTypeGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listEventTypesApiV1EventTypeGetSignalError(output, error_type, error_str);
        Q_EMIT listEventTypesApiV1EventTypeGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIEventTypeApi::updateEventTypeApiV1EventTypeEventTypeNamePut(const QString &event_type_name, const OAIEventTypeUpdate &oai_event_type_update, const ::OpenAPI::OptionalParam<QString> &idempotency_key) {
    QString fullPath = QString(_serverConfigs["updateEventTypeApiV1EventTypeEventTypeNamePut"][_serverIndices.value("updateEventTypeApiV1EventTypeEventTypeNamePut")].URL()+"/api/v1/event-type/{event_type_name}/");
    
    if (!_bearerToken.isEmpty())
        addHeaders("Authorization", "Bearer " + _bearerToken);
    
    
    {
        QString event_type_namePathParam("{");
        event_type_namePathParam.append("event_type_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "event_type_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"event_type_name"+pathSuffix : pathPrefix;
        fullPath.replace(event_type_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(event_type_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_event_type_update.asJson().toUtf8();
        input.request_body.append(output);
    }
    if (idempotency_key.hasValue())
    {
        if (!::OpenAPI::toStringValue(idempotency_key.value()).isEmpty()) {
            input.headers.insert("idempotency-key", ::OpenAPI::toStringValue(idempotency_key.value()));
        }
        }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIEventTypeApi::updateEventTypeApiV1EventTypeEventTypeNamePutCallback);
    connect(this, &OAIEventTypeApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIEventTypeApi::updateEventTypeApiV1EventTypeEventTypeNamePutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEventTypeOut output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateEventTypeApiV1EventTypeEventTypeNamePutSignal(output);
        Q_EMIT updateEventTypeApiV1EventTypeEventTypeNamePutSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateEventTypeApiV1EventTypeEventTypeNamePutSignalE(output, error_type, error_str);
        Q_EMIT updateEventTypeApiV1EventTypeEventTypeNamePutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateEventTypeApiV1EventTypeEventTypeNamePutSignalError(output, error_type, error_str);
        Q_EMIT updateEventTypeApiV1EventTypeEventTypeNamePutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIEventTypeApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
