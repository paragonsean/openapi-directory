/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The DomainVerificationDetailAllOfCertificateAuthorityAuthorization model module.
 * @module model/DomainVerificationDetailAllOfCertificateAuthorityAuthorization
 * @version 1.0.0
 */
class DomainVerificationDetailAllOfCertificateAuthorityAuthorization {
    /**
     * Constructs a new <code>DomainVerificationDetailAllOfCertificateAuthorityAuthorization</code>.
     * Contains information about the last Certificate Authority Authorization (CAA) Lookup details for the specified domain.  In order for a domain to be eligible to be included in the certificate, the entire domain hierarchy must be scanned for DNS CAA records, as outlined by RFC 6844.  The absence of any CAA records found in the domain hierarchy indicates that the domain may be included in the certificate. Alternatively, if CAA records are found when scanning the domain hierarchy, the domain may be included in the certificate as long as &#x60;godaddy.com&#x60; or &#x60;starfieldtech.com&#x60; is found in the DNS record value. However, if CAA records are found, yet &#x60;godaddy.com&#x60; or &#x60;starfieldtech.com&#x60; is not found in any CAA record&#39;s value, then we must drop the domain from the certificate request.  In the case where there are repeated DNS errors when scanning the domain hierarchy for CAA records, thus ending in an unsuccessful scan, then the domain can still be included in the certificate provided the primary domain is not setup with DNSSEC. Conversely, if DNSSEC is found to be setup on the primary domain when scanning following repeated CAA failures, the domain must be dropped from the certificate request. Finally, if DNS errors persist to the point where a successful DNSSEC query could not be obtained, then the domain must be dropped from the certificate request. 
     * @alias module:model/DomainVerificationDetailAllOfCertificateAuthorityAuthorization
     */
    constructor() { 
        
        DomainVerificationDetailAllOfCertificateAuthorityAuthorization.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>DomainVerificationDetailAllOfCertificateAuthorityAuthorization</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/DomainVerificationDetailAllOfCertificateAuthorityAuthorization} obj Optional instance to populate.
     * @return {module:model/DomainVerificationDetailAllOfCertificateAuthorityAuthorization} The populated <code>DomainVerificationDetailAllOfCertificateAuthorityAuthorization</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new DomainVerificationDetailAllOfCertificateAuthorityAuthorization();

            if (data.hasOwnProperty('completedAt')) {
                obj['completedAt'] = ApiClient.convertToType(data['completedAt'], 'String');
            }
            if (data.hasOwnProperty('queryPaths')) {
                obj['queryPaths'] = ApiClient.convertToType(data['queryPaths'], ['String']);
            }
            if (data.hasOwnProperty('recommendations')) {
                obj['recommendations'] = ApiClient.convertToType(data['recommendations'], ['String']);
            }
            if (data.hasOwnProperty('status')) {
                obj['status'] = ApiClient.convertToType(data['status'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>DomainVerificationDetailAllOfCertificateAuthorityAuthorization</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>DomainVerificationDetailAllOfCertificateAuthorityAuthorization</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['completedAt'] && !(typeof data['completedAt'] === 'string' || data['completedAt'] instanceof String)) {
            throw new Error("Expected the field `completedAt` to be a primitive type in the JSON string but got " + data['completedAt']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['queryPaths'])) {
            throw new Error("Expected the field `queryPaths` to be an array in the JSON data but got " + data['queryPaths']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['recommendations'])) {
            throw new Error("Expected the field `recommendations` to be an array in the JSON data but got " + data['recommendations']);
        }
        // ensure the json data is a string
        if (data['status'] && !(typeof data['status'] === 'string' || data['status'] instanceof String)) {
            throw new Error("Expected the field `status` to be a primitive type in the JSON string but got " + data['status']);
        }

        return true;
    }


}



/**
 * The date the certificate request completed processing.
 * @member {String} completedAt
 */
DomainVerificationDetailAllOfCertificateAuthorityAuthorization.prototype['completedAt'] = undefined;

/**
 * Details all the individual DNS paths that were scanned for CAA records for this domain, as detailed by RFC 6844. This element not only contains the parts determined from parsing the domain, but also any CNAME or DNAME targets specified by any of those individual parts.
 * @member {Array.<String>} queryPaths
 */
DomainVerificationDetailAllOfCertificateAuthorityAuthorization.prototype['queryPaths'] = undefined;

/**
 * Returns a list of fix recommendations if the query was unsuccessful, or if the domain was dropped from the certificate request, so that a subsequent certificate request with the specified domain will successfully pass its CAA scan.
 * @member {Array.<module:model/DomainVerificationDetailAllOfCertificateAuthorityAuthorization.RecommendationsEnum>} recommendations
 */
DomainVerificationDetailAllOfCertificateAuthorityAuthorization.prototype['recommendations'] = undefined;

/**
 * Returns the status of the CAA Lookup for the specified domain: * `PENDING` - The CAA lookup has not yet been attempted for the specified domain. * `REMOVED_DNS_ERROR` - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNS errors then prevented the system from determining if DNSSEC was enabled for the specified domain, and it had to be removed from the certificate request. * `REMOVED_DNSSEC_ENABLED` - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNSSEC was determined to be enabled for the specified domain, and it had to be removed from the certificate request. * `REMOVED_NOT_FOUND_CA` - CAA records were found during the CAA lookup for the speicified domain, but `godaddy.com` or `starfieldtech.com` was not listed as a value, thereby not allowing us to issue a certificate with this domain. The specified domain was removed from the certificate request. * `REMOVED_UNKNOWN_CRITICAL_TAG` - A CAA record was found during the CAA lookup with its Critical bit set, as outlined by RFC 6844, yet the Tag of the CAA record was not understood (as outlined by RFC 6844). The specified domain was removed from the certificate request. * `SUCCESS_CAA` - The CAA lookup was successful for the specified domain, and the domain can remain in the certificate request. * `SUCCESS_DNSSEC` - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. The system detemined that DNSSEC was not enabled for the specified domain, so the domain is allowed to remain in the certificate request. 
 * @member {module:model/DomainVerificationDetailAllOfCertificateAuthorityAuthorization.StatusEnum} status
 */
DomainVerificationDetailAllOfCertificateAuthorityAuthorization.prototype['status'] = undefined;





/**
 * Allowed values for the <code>recommendations</code> property.
 * @enum {String}
 * @readonly
 */
DomainVerificationDetailAllOfCertificateAuthorityAuthorization['RecommendationsEnum'] = {

    /**
     * value: "ADD_CA_TO_CAA"
     * @const
     */
    "ADD_CA_TO_CAA": "ADD_CA_TO_CAA",

    /**
     * value: "CREATE_TARGET_DOMAIN_CAA"
     * @const
     */
    "CREATE_TARGET_DOMAIN_CAA": "CREATE_TARGET_DOMAIN_CAA",

    /**
     * value: "DISABLE_DNSSEC"
     * @const
     */
    "DISABLE_DNSSEC": "DISABLE_DNSSEC",

    /**
     * value: "FIX_CRITICAL_TAG"
     * @const
     */
    "FIX_CRITICAL_TAG": "FIX_CRITICAL_TAG",

    /**
     * value: "VALIDATE_SOA"
     * @const
     */
    "VALIDATE_SOA": "VALIDATE_SOA"
};


/**
 * Allowed values for the <code>status</code> property.
 * @enum {String}
 * @readonly
 */
DomainVerificationDetailAllOfCertificateAuthorityAuthorization['StatusEnum'] = {

    /**
     * value: "PENDING"
     * @const
     */
    "PENDING": "PENDING",

    /**
     * value: "REMOVED_DNS_ERROR"
     * @const
     */
    "REMOVED_DNS_ERROR": "REMOVED_DNS_ERROR",

    /**
     * value: "REMOVED_DNSSEC_ENABLED"
     * @const
     */
    "REMOVED_DNSSEC_ENABLED": "REMOVED_DNSSEC_ENABLED",

    /**
     * value: "REMOVED_NOT_FOUND_CA"
     * @const
     */
    "REMOVED_NOT_FOUND_CA": "REMOVED_NOT_FOUND_CA",

    /**
     * value: "REMOVED_UNKNOWN_CRITICAL_TAG"
     * @const
     */
    "REMOVED_UNKNOWN_CRITICAL_TAG": "REMOVED_UNKNOWN_CRITICAL_TAG",

    /**
     * value: "SUCCESS_CAA"
     * @const
     */
    "SUCCESS_CAA": "SUCCESS_CAA",

    /**
     * value: "SUCCESS_DNSSEC"
     * @const
     */
    "SUCCESS_DNSSEC": "SUCCESS_DNSSEC"
};



export default DomainVerificationDetailAllOfCertificateAuthorityAuthorization;

