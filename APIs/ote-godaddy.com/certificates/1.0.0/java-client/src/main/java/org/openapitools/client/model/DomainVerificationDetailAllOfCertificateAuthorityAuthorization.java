/*
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains information about the last Certificate Authority Authorization (CAA) Lookup details for the specified domain.  In order for a domain to be eligible to be included in the certificate, the entire domain hierarchy must be scanned for DNS CAA records, as outlined by RFC 6844.  The absence of any CAA records found in the domain hierarchy indicates that the domain may be included in the certificate. Alternatively, if CAA records are found when scanning the domain hierarchy, the domain may be included in the certificate as long as &#x60;godaddy.com&#x60; or &#x60;starfieldtech.com&#x60; is found in the DNS record value. However, if CAA records are found, yet &#x60;godaddy.com&#x60; or &#x60;starfieldtech.com&#x60; is not found in any CAA record&#39;s value, then we must drop the domain from the certificate request.  In the case where there are repeated DNS errors when scanning the domain hierarchy for CAA records, thus ending in an unsuccessful scan, then the domain can still be included in the certificate provided the primary domain is not setup with DNSSEC. Conversely, if DNSSEC is found to be setup on the primary domain when scanning following repeated CAA failures, the domain must be dropped from the certificate request. Finally, if DNS errors persist to the point where a successful DNSSEC query could not be obtained, then the domain must be dropped from the certificate request. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:00:19.304783-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DomainVerificationDetailAllOfCertificateAuthorityAuthorization {
  public static final String SERIALIZED_NAME_COMPLETED_AT = "completedAt";
  @SerializedName(SERIALIZED_NAME_COMPLETED_AT)
  private String completedAt;

  public static final String SERIALIZED_NAME_QUERY_PATHS = "queryPaths";
  @SerializedName(SERIALIZED_NAME_QUERY_PATHS)
  private List<String> queryPaths = new ArrayList<>();

  /**
   * * &#x60;ADD_CA_TO_CAA&#x60; - The system found a CAA record in the domain hierarchy, but it did not find our CA in the record&#39;s values. Add &#x60;godaddy.com&#x60; or &#x60;starfieldtech.com&#x60; to the CAA record&#39;s values. * &#x60;CREATE_TARGET_DOMAIN_CAA&#x60; - Create a CAA record on the specified domain with &#x60;godaddy.com&#x60; or &#x60;starfieldtech.com&#x60; as the value. If the system finds a CAA record in the specified domain, it will stop scanning the domain hierarchy, thereby preventing potentially problematic parent domain paths from being scanned. * &#x60;DISABLE_DNSSEC&#x60; - Disable DNSSEC on the domain if CAA lookups fail and a DNSSEC scan is being used as the method for determining if the specified domain can remain in the certificate request. * &#x60;FIX_CRITICAL_TAG&#x60; - When setting the critical flag in a CAA record, you must ensure you&#39;re using a well-known tag, per RFC 6844. * &#x60;VALIDATE_SOA&#x60; - Make sure all queryPaths for the specified domain have an SOA record pointing to a valid publicly-accessible nameserver and respond in a timely fashion. 
   */
  @JsonAdapter(RecommendationsEnum.Adapter.class)
  public enum RecommendationsEnum {
    ADD_CA_TO_CAA("ADD_CA_TO_CAA"),
    
    CREATE_TARGET_DOMAIN_CAA("CREATE_TARGET_DOMAIN_CAA"),
    
    DISABLE_DNSSEC("DISABLE_DNSSEC"),
    
    FIX_CRITICAL_TAG("FIX_CRITICAL_TAG"),
    
    VALIDATE_SOA("VALIDATE_SOA");

    private String value;

    RecommendationsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RecommendationsEnum fromValue(String value) {
      for (RecommendationsEnum b : RecommendationsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RecommendationsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RecommendationsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RecommendationsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RecommendationsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RecommendationsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RECOMMENDATIONS = "recommendations";
  @SerializedName(SERIALIZED_NAME_RECOMMENDATIONS)
  private List<RecommendationsEnum> recommendations = new ArrayList<>();

  /**
   * Returns the status of the CAA Lookup for the specified domain: * &#x60;PENDING&#x60; - The CAA lookup has not yet been attempted for the specified domain. * &#x60;REMOVED_DNS_ERROR&#x60; - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNS errors then prevented the system from determining if DNSSEC was enabled for the specified domain, and it had to be removed from the certificate request. * &#x60;REMOVED_DNSSEC_ENABLED&#x60; - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNSSEC was determined to be enabled for the specified domain, and it had to be removed from the certificate request. * &#x60;REMOVED_NOT_FOUND_CA&#x60; - CAA records were found during the CAA lookup for the speicified domain, but &#x60;godaddy.com&#x60; or &#x60;starfieldtech.com&#x60; was not listed as a value, thereby not allowing us to issue a certificate with this domain. The specified domain was removed from the certificate request. * &#x60;REMOVED_UNKNOWN_CRITICAL_TAG&#x60; - A CAA record was found during the CAA lookup with its Critical bit set, as outlined by RFC 6844, yet the Tag of the CAA record was not understood (as outlined by RFC 6844). The specified domain was removed from the certificate request. * &#x60;SUCCESS_CAA&#x60; - The CAA lookup was successful for the specified domain, and the domain can remain in the certificate request. * &#x60;SUCCESS_DNSSEC&#x60; - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. The system detemined that DNSSEC was not enabled for the specified domain, so the domain is allowed to remain in the certificate request. 
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    PENDING("PENDING"),
    
    REMOVED_DNS_ERROR("REMOVED_DNS_ERROR"),
    
    REMOVED_DNSSEC_ENABLED("REMOVED_DNSSEC_ENABLED"),
    
    REMOVED_NOT_FOUND_CA("REMOVED_NOT_FOUND_CA"),
    
    REMOVED_UNKNOWN_CRITICAL_TAG("REMOVED_UNKNOWN_CRITICAL_TAG"),
    
    SUCCESS_CAA("SUCCESS_CAA"),
    
    SUCCESS_DNSSEC("SUCCESS_DNSSEC");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public DomainVerificationDetailAllOfCertificateAuthorityAuthorization() {
  }

  public DomainVerificationDetailAllOfCertificateAuthorityAuthorization completedAt(String completedAt) {
    this.completedAt = completedAt;
    return this;
  }

  /**
   * The date the certificate request completed processing.
   * @return completedAt
   */
  @javax.annotation.Nullable
  public String getCompletedAt() {
    return completedAt;
  }

  public void setCompletedAt(String completedAt) {
    this.completedAt = completedAt;
  }


  public DomainVerificationDetailAllOfCertificateAuthorityAuthorization queryPaths(List<String> queryPaths) {
    this.queryPaths = queryPaths;
    return this;
  }

  public DomainVerificationDetailAllOfCertificateAuthorityAuthorization addQueryPathsItem(String queryPathsItem) {
    if (this.queryPaths == null) {
      this.queryPaths = new ArrayList<>();
    }
    this.queryPaths.add(queryPathsItem);
    return this;
  }

  /**
   * Details all the individual DNS paths that were scanned for CAA records for this domain, as detailed by RFC 6844. This element not only contains the parts determined from parsing the domain, but also any CNAME or DNAME targets specified by any of those individual parts.
   * @return queryPaths
   */
  @javax.annotation.Nullable
  public List<String> getQueryPaths() {
    return queryPaths;
  }

  public void setQueryPaths(List<String> queryPaths) {
    this.queryPaths = queryPaths;
  }


  public DomainVerificationDetailAllOfCertificateAuthorityAuthorization recommendations(List<RecommendationsEnum> recommendations) {
    this.recommendations = recommendations;
    return this;
  }

  public DomainVerificationDetailAllOfCertificateAuthorityAuthorization addRecommendationsItem(RecommendationsEnum recommendationsItem) {
    if (this.recommendations == null) {
      this.recommendations = new ArrayList<>();
    }
    this.recommendations.add(recommendationsItem);
    return this;
  }

  /**
   * Returns a list of fix recommendations if the query was unsuccessful, or if the domain was dropped from the certificate request, so that a subsequent certificate request with the specified domain will successfully pass its CAA scan.
   * @return recommendations
   */
  @javax.annotation.Nullable
  public List<RecommendationsEnum> getRecommendations() {
    return recommendations;
  }

  public void setRecommendations(List<RecommendationsEnum> recommendations) {
    this.recommendations = recommendations;
  }


  public DomainVerificationDetailAllOfCertificateAuthorityAuthorization status(StatusEnum status) {
    this.status = status;
    return this;
  }

  /**
   * Returns the status of the CAA Lookup for the specified domain: * &#x60;PENDING&#x60; - The CAA lookup has not yet been attempted for the specified domain. * &#x60;REMOVED_DNS_ERROR&#x60; - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNS errors then prevented the system from determining if DNSSEC was enabled for the specified domain, and it had to be removed from the certificate request. * &#x60;REMOVED_DNSSEC_ENABLED&#x60; - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNSSEC was determined to be enabled for the specified domain, and it had to be removed from the certificate request. * &#x60;REMOVED_NOT_FOUND_CA&#x60; - CAA records were found during the CAA lookup for the speicified domain, but &#x60;godaddy.com&#x60; or &#x60;starfieldtech.com&#x60; was not listed as a value, thereby not allowing us to issue a certificate with this domain. The specified domain was removed from the certificate request. * &#x60;REMOVED_UNKNOWN_CRITICAL_TAG&#x60; - A CAA record was found during the CAA lookup with its Critical bit set, as outlined by RFC 6844, yet the Tag of the CAA record was not understood (as outlined by RFC 6844). The specified domain was removed from the certificate request. * &#x60;SUCCESS_CAA&#x60; - The CAA lookup was successful for the specified domain, and the domain can remain in the certificate request. * &#x60;SUCCESS_DNSSEC&#x60; - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. The system detemined that DNSSEC was not enabled for the specified domain, so the domain is allowed to remain in the certificate request. 
   * @return status
   */
  @javax.annotation.Nullable
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DomainVerificationDetailAllOfCertificateAuthorityAuthorization domainVerificationDetailAllOfCertificateAuthorityAuthorization = (DomainVerificationDetailAllOfCertificateAuthorityAuthorization) o;
    return Objects.equals(this.completedAt, domainVerificationDetailAllOfCertificateAuthorityAuthorization.completedAt) &&
        Objects.equals(this.queryPaths, domainVerificationDetailAllOfCertificateAuthorityAuthorization.queryPaths) &&
        Objects.equals(this.recommendations, domainVerificationDetailAllOfCertificateAuthorityAuthorization.recommendations) &&
        Objects.equals(this.status, domainVerificationDetailAllOfCertificateAuthorityAuthorization.status);
  }

  @Override
  public int hashCode() {
    return Objects.hash(completedAt, queryPaths, recommendations, status);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DomainVerificationDetailAllOfCertificateAuthorityAuthorization {\n");
    sb.append("    completedAt: ").append(toIndentedString(completedAt)).append("\n");
    sb.append("    queryPaths: ").append(toIndentedString(queryPaths)).append("\n");
    sb.append("    recommendations: ").append(toIndentedString(recommendations)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("completedAt");
    openapiFields.add("queryPaths");
    openapiFields.add("recommendations");
    openapiFields.add("status");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DomainVerificationDetailAllOfCertificateAuthorityAuthorization
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DomainVerificationDetailAllOfCertificateAuthorityAuthorization.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DomainVerificationDetailAllOfCertificateAuthorityAuthorization is not found in the empty JSON string", DomainVerificationDetailAllOfCertificateAuthorityAuthorization.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DomainVerificationDetailAllOfCertificateAuthorityAuthorization.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DomainVerificationDetailAllOfCertificateAuthorityAuthorization` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("completedAt") != null && !jsonObj.get("completedAt").isJsonNull()) && !jsonObj.get("completedAt").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `completedAt` to be a primitive type in the JSON string but got `%s`", jsonObj.get("completedAt").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("queryPaths") != null && !jsonObj.get("queryPaths").isJsonNull() && !jsonObj.get("queryPaths").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `queryPaths` to be an array in the JSON string but got `%s`", jsonObj.get("queryPaths").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("recommendations") != null && !jsonObj.get("recommendations").isJsonNull() && !jsonObj.get("recommendations").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `recommendations` to be an array in the JSON string but got `%s`", jsonObj.get("recommendations").toString()));
      }
      if ((jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) && !jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the optional field `status`
      if (jsonObj.get("status") != null && !jsonObj.get("status").isJsonNull()) {
        StatusEnum.validateJsonElement(jsonObj.get("status"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DomainVerificationDetailAllOfCertificateAuthorityAuthorization.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DomainVerificationDetailAllOfCertificateAuthorityAuthorization' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DomainVerificationDetailAllOfCertificateAuthorityAuthorization> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DomainVerificationDetailAllOfCertificateAuthorityAuthorization.class));

       return (TypeAdapter<T>) new TypeAdapter<DomainVerificationDetailAllOfCertificateAuthorityAuthorization>() {
           @Override
           public void write(JsonWriter out, DomainVerificationDetailAllOfCertificateAuthorityAuthorization value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DomainVerificationDetailAllOfCertificateAuthorityAuthorization read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DomainVerificationDetailAllOfCertificateAuthorityAuthorization given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DomainVerificationDetailAllOfCertificateAuthorityAuthorization
   * @throws IOException if the JSON string is invalid with respect to DomainVerificationDetailAllOfCertificateAuthorityAuthorization
   */
  public static DomainVerificationDetailAllOfCertificateAuthorityAuthorization fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DomainVerificationDetailAllOfCertificateAuthorityAuthorization.class);
  }

  /**
   * Convert an instance of DomainVerificationDetailAllOfCertificateAuthorityAuthorization to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

