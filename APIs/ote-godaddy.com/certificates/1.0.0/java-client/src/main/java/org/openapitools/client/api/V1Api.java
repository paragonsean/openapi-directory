/*
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.Certificate;
import org.openapitools.client.model.CertificateAction;
import org.openapitools.client.model.CertificateBundle;
import org.openapitools.client.model.CertificateCallback;
import org.openapitools.client.model.CertificateCreate;
import org.openapitools.client.model.CertificateEmailHistory;
import org.openapitools.client.model.CertificateIdentifier;
import org.openapitools.client.model.CertificateReissue;
import org.openapitools.client.model.CertificateRenew;
import org.openapitools.client.model.CertificateRevoke;
import org.openapitools.client.model.CertificateSiteSeal;
import org.openapitools.client.model.Error;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class V1Api {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public V1Api() {
        this(Configuration.getDefaultApiClient());
    }

    public V1Api(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for certificateActionRetrieve
     * @param certificateId Certificate id to register for callback (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Action retrieval successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateActionRetrieveCall(String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/actions"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateActionRetrieveValidateBeforeCall(String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateActionRetrieve(Async)");
        }

        return certificateActionRetrieveCall(certificateId, _callback);

    }

    /**
     * Retrieve all certificate actions
     * This method is used to retrieve all stateful actions relating to a certificate lifecycle.
     * @param certificateId Certificate id to register for callback (required)
     * @return List&lt;CertificateAction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Action retrieval successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public List<CertificateAction> certificateActionRetrieve(String certificateId) throws ApiException {
        ApiResponse<List<CertificateAction>> localVarResp = certificateActionRetrieveWithHttpInfo(certificateId);
        return localVarResp.getData();
    }

    /**
     * Retrieve all certificate actions
     * This method is used to retrieve all stateful actions relating to a certificate lifecycle.
     * @param certificateId Certificate id to register for callback (required)
     * @return ApiResponse&lt;List&lt;CertificateAction&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Action retrieval successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<CertificateAction>> certificateActionRetrieveWithHttpInfo(String certificateId) throws ApiException {
        okhttp3.Call localVarCall = certificateActionRetrieveValidateBeforeCall(certificateId, null);
        Type localVarReturnType = new TypeToken<List<CertificateAction>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve all certificate actions (asynchronously)
     * This method is used to retrieve all stateful actions relating to a certificate lifecycle.
     * @param certificateId Certificate id to register for callback (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Action retrieval successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateActionRetrieveAsync(String certificateId, final ApiCallback<List<CertificateAction>> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateActionRetrieveValidateBeforeCall(certificateId, _callback);
        Type localVarReturnType = new TypeToken<List<CertificateAction>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateAlternateEmailAddress
     * @param certificateId Certificate id to resend emails (required)
     * @param emailAddress Specific email address to resend email (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Alternate email address added and emails re-sent </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow alternate email address </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateAlternateEmailAddressCall(String certificateId, String emailAddress, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/email/resend/{emailAddress}"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()))
            .replace("{" + "emailAddress" + "}", localVarApiClient.escapeString(emailAddress.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateAlternateEmailAddressValidateBeforeCall(String certificateId, String emailAddress, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateAlternateEmailAddress(Async)");
        }

        // verify the required parameter 'emailAddress' is set
        if (emailAddress == null) {
            throw new ApiException("Missing the required parameter 'emailAddress' when calling certificateAlternateEmailAddress(Async)");
        }

        return certificateAlternateEmailAddressCall(certificateId, emailAddress, _callback);

    }

    /**
     * Add alternate email address
     * This method adds an alternate email address to a certificate order and re-sends all existing request emails to that address.
     * @param certificateId Certificate id to resend emails (required)
     * @param emailAddress Specific email address to resend email (required)
     * @return CertificateEmailHistory
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Alternate email address added and emails re-sent </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow alternate email address </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public CertificateEmailHistory certificateAlternateEmailAddress(String certificateId, String emailAddress) throws ApiException {
        ApiResponse<CertificateEmailHistory> localVarResp = certificateAlternateEmailAddressWithHttpInfo(certificateId, emailAddress);
        return localVarResp.getData();
    }

    /**
     * Add alternate email address
     * This method adds an alternate email address to a certificate order and re-sends all existing request emails to that address.
     * @param certificateId Certificate id to resend emails (required)
     * @param emailAddress Specific email address to resend email (required)
     * @return ApiResponse&lt;CertificateEmailHistory&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Alternate email address added and emails re-sent </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow alternate email address </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CertificateEmailHistory> certificateAlternateEmailAddressWithHttpInfo(String certificateId, String emailAddress) throws ApiException {
        okhttp3.Call localVarCall = certificateAlternateEmailAddressValidateBeforeCall(certificateId, emailAddress, null);
        Type localVarReturnType = new TypeToken<CertificateEmailHistory>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Add alternate email address (asynchronously)
     * This method adds an alternate email address to a certificate order and re-sends all existing request emails to that address.
     * @param certificateId Certificate id to resend emails (required)
     * @param emailAddress Specific email address to resend email (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Alternate email address added and emails re-sent </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow alternate email address </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateAlternateEmailAddressAsync(String certificateId, String emailAddress, final ApiCallback<CertificateEmailHistory> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateAlternateEmailAddressValidateBeforeCall(certificateId, emailAddress, _callback);
        Type localVarReturnType = new TypeToken<CertificateEmailHistory>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateCallbackDelete
     * @param certificateId Certificate id to unregister callback (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Callback removed </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCallbackDeleteCall(String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/callback"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateCallbackDeleteValidateBeforeCall(String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateCallbackDelete(Async)");
        }

        return certificateCallbackDeleteCall(certificateId, _callback);

    }

    /**
     * Unregister system callback
     * Unregister the callback for a particular certificate.
     * @param certificateId Certificate id to unregister callback (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Callback removed </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateCallbackDelete(String certificateId) throws ApiException {
        certificateCallbackDeleteWithHttpInfo(certificateId);
    }

    /**
     * Unregister system callback
     * Unregister the callback for a particular certificate.
     * @param certificateId Certificate id to unregister callback (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Callback removed </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateCallbackDeleteWithHttpInfo(String certificateId) throws ApiException {
        okhttp3.Call localVarCall = certificateCallbackDeleteValidateBeforeCall(certificateId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Unregister system callback (asynchronously)
     * Unregister the callback for a particular certificate.
     * @param certificateId Certificate id to unregister callback (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Callback removed </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCallbackDeleteAsync(String certificateId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateCallbackDeleteValidateBeforeCall(certificateId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateCallbackGet
     * @param certificateId Certificate id to register for stateful action callback (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Callback registered </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCallbackGetCall(String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/callback"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateCallbackGetValidateBeforeCall(String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateCallbackGet(Async)");
        }

        return certificateCallbackGetCall(certificateId, _callback);

    }

    /**
     * Retrieve system stateful action callback url
     * This method is used to retrieve the registered callback url for a certificate.
     * @param certificateId Certificate id to register for stateful action callback (required)
     * @return CertificateCallback
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Callback registered </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public CertificateCallback certificateCallbackGet(String certificateId) throws ApiException {
        ApiResponse<CertificateCallback> localVarResp = certificateCallbackGetWithHttpInfo(certificateId);
        return localVarResp.getData();
    }

    /**
     * Retrieve system stateful action callback url
     * This method is used to retrieve the registered callback url for a certificate.
     * @param certificateId Certificate id to register for stateful action callback (required)
     * @return ApiResponse&lt;CertificateCallback&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Callback registered </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CertificateCallback> certificateCallbackGetWithHttpInfo(String certificateId) throws ApiException {
        okhttp3.Call localVarCall = certificateCallbackGetValidateBeforeCall(certificateId, null);
        Type localVarReturnType = new TypeToken<CertificateCallback>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve system stateful action callback url (asynchronously)
     * This method is used to retrieve the registered callback url for a certificate.
     * @param certificateId Certificate id to register for stateful action callback (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Callback registered </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCallbackGetAsync(String certificateId, final ApiCallback<CertificateCallback> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateCallbackGetValidateBeforeCall(certificateId, _callback);
        Type localVarReturnType = new TypeToken<CertificateCallback>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateCallbackReplace
     * @param certificateId Certificate id to register/replace for callback (required)
     * @param callbackUrl Callback url registered/replaced to receive stateful actions (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Callback replaced/registered </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Callback url is missing &lt;br&gt; Callback url is malformed </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCallbackReplaceCall(String certificateId, String callbackUrl, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/callback"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (callbackUrl != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callbackUrl", callbackUrl));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateCallbackReplaceValidateBeforeCall(String certificateId, String callbackUrl, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateCallbackReplace(Async)");
        }

        // verify the required parameter 'callbackUrl' is set
        if (callbackUrl == null) {
            throw new ApiException("Missing the required parameter 'callbackUrl' when calling certificateCallbackReplace(Async)");
        }

        return certificateCallbackReplaceCall(certificateId, callbackUrl, _callback);

    }

    /**
     * Register of certificate action callback
     * This method is used to register/replace url for callbacks for stateful actions relating to a certificate lifecycle. The callback url is a Webhook style pattern and will receive POST http requests with json body defined in the CertificateAction model definition for each certificate action.  Only one callback URL is allowed to be registered for each certificateId, so it will replace a previous registration.
     * @param certificateId Certificate id to register/replace for callback (required)
     * @param callbackUrl Callback url registered/replaced to receive stateful actions (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Callback replaced/registered </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Callback url is missing &lt;br&gt; Callback url is malformed </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateCallbackReplace(String certificateId, String callbackUrl) throws ApiException {
        certificateCallbackReplaceWithHttpInfo(certificateId, callbackUrl);
    }

    /**
     * Register of certificate action callback
     * This method is used to register/replace url for callbacks for stateful actions relating to a certificate lifecycle. The callback url is a Webhook style pattern and will receive POST http requests with json body defined in the CertificateAction model definition for each certificate action.  Only one callback URL is allowed to be registered for each certificateId, so it will replace a previous registration.
     * @param certificateId Certificate id to register/replace for callback (required)
     * @param callbackUrl Callback url registered/replaced to receive stateful actions (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Callback replaced/registered </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Callback url is missing &lt;br&gt; Callback url is malformed </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateCallbackReplaceWithHttpInfo(String certificateId, String callbackUrl) throws ApiException {
        okhttp3.Call localVarCall = certificateCallbackReplaceValidateBeforeCall(certificateId, callbackUrl, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Register of certificate action callback (asynchronously)
     * This method is used to register/replace url for callbacks for stateful actions relating to a certificate lifecycle. The callback url is a Webhook style pattern and will receive POST http requests with json body defined in the CertificateAction model definition for each certificate action.  Only one callback URL is allowed to be registered for each certificateId, so it will replace a previous registration.
     * @param certificateId Certificate id to register/replace for callback (required)
     * @param callbackUrl Callback url registered/replaced to receive stateful actions (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Callback replaced/registered </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Callback url is missing &lt;br&gt; Callback url is malformed </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCallbackReplaceAsync(String certificateId, String callbackUrl, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateCallbackReplaceValidateBeforeCall(certificateId, callbackUrl, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateCancel
     * @param certificateId Certificate id to cancel (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Certificate order has been canceled </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow cancel </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCancelCall(String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/cancel"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateCancelValidateBeforeCall(String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateCancel(Async)");
        }

        return certificateCancelCall(certificateId, _callback);

    }

    /**
     * Cancel a pending certificate
     * Use the cancel call to cancel a pending certificate order.
     * @param certificateId Certificate id to cancel (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Certificate order has been canceled </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow cancel </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateCancel(String certificateId) throws ApiException {
        certificateCancelWithHttpInfo(certificateId);
    }

    /**
     * Cancel a pending certificate
     * Use the cancel call to cancel a pending certificate order.
     * @param certificateId Certificate id to cancel (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Certificate order has been canceled </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow cancel </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateCancelWithHttpInfo(String certificateId) throws ApiException {
        okhttp3.Call localVarCall = certificateCancelValidateBeforeCall(certificateId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Cancel a pending certificate (asynchronously)
     * Use the cancel call to cancel a pending certificate order.
     * @param certificateId Certificate id to cancel (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Certificate order has been canceled </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow cancel </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCancelAsync(String certificateId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateCancelValidateBeforeCall(certificateId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateCreate
     * @param certificateCreate The certificate order information (required)
     * @param xMarketId Setting locale for communications such as emails and error messages (optional, default to Default locale for shopper account)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Request was successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;email&#x60; is not empty&lt;br&gt;&#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCreateCall(CertificateCreate certificateCreate, String xMarketId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = certificateCreate;

        // create path and map variables
        String localVarPath = "/v1/certificates";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xMarketId != null) {
            localVarHeaderParams.put("X-Market-Id", localVarApiClient.parameterToString(xMarketId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateCreateValidateBeforeCall(CertificateCreate certificateCreate, String xMarketId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateCreate' is set
        if (certificateCreate == null) {
            throw new ApiException("Missing the required parameter 'certificateCreate' when calling certificateCreate(Async)");
        }

        return certificateCreateCall(certificateCreate, xMarketId, _callback);

    }

    /**
     * Create a pending order for certificate
     * &lt;p&gt;Creating a certificate order can be a long running asynchronous operation in the PKI workflow. The PKI API supports 2 options for getting the completion stateful actions for this asynchronous operations: 1) by polling operations -- see /v1/certificates/{certificateId}/actions 2) via WebHook style callback -- see &#39;/v1/certificates/{certificateId}/callback&#39;.&lt;/p&gt;
     * @param certificateCreate The certificate order information (required)
     * @param xMarketId Setting locale for communications such as emails and error messages (optional, default to Default locale for shopper account)
     * @return CertificateIdentifier
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Request was successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;email&#x60; is not empty&lt;br&gt;&#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public CertificateIdentifier certificateCreate(CertificateCreate certificateCreate, String xMarketId) throws ApiException {
        ApiResponse<CertificateIdentifier> localVarResp = certificateCreateWithHttpInfo(certificateCreate, xMarketId);
        return localVarResp.getData();
    }

    /**
     * Create a pending order for certificate
     * &lt;p&gt;Creating a certificate order can be a long running asynchronous operation in the PKI workflow. The PKI API supports 2 options for getting the completion stateful actions for this asynchronous operations: 1) by polling operations -- see /v1/certificates/{certificateId}/actions 2) via WebHook style callback -- see &#39;/v1/certificates/{certificateId}/callback&#39;.&lt;/p&gt;
     * @param certificateCreate The certificate order information (required)
     * @param xMarketId Setting locale for communications such as emails and error messages (optional, default to Default locale for shopper account)
     * @return ApiResponse&lt;CertificateIdentifier&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Request was successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;email&#x60; is not empty&lt;br&gt;&#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CertificateIdentifier> certificateCreateWithHttpInfo(CertificateCreate certificateCreate, String xMarketId) throws ApiException {
        okhttp3.Call localVarCall = certificateCreateValidateBeforeCall(certificateCreate, xMarketId, null);
        Type localVarReturnType = new TypeToken<CertificateIdentifier>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a pending order for certificate (asynchronously)
     * &lt;p&gt;Creating a certificate order can be a long running asynchronous operation in the PKI workflow. The PKI API supports 2 options for getting the completion stateful actions for this asynchronous operations: 1) by polling operations -- see /v1/certificates/{certificateId}/actions 2) via WebHook style callback -- see &#39;/v1/certificates/{certificateId}/callback&#39;.&lt;/p&gt;
     * @param certificateCreate The certificate order information (required)
     * @param xMarketId Setting locale for communications such as emails and error messages (optional, default to Default locale for shopper account)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Request was successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;email&#x60; is not empty&lt;br&gt;&#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCreateAsync(CertificateCreate certificateCreate, String xMarketId, final ApiCallback<CertificateIdentifier> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateCreateValidateBeforeCall(certificateCreate, xMarketId, _callback);
        Type localVarReturnType = new TypeToken<CertificateIdentifier>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateDownload
     * @param certificateId Certificate id to download (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow download </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDownloadCall(String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/download"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateDownloadValidateBeforeCall(String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateDownload(Async)");
        }

        return certificateDownloadCall(certificateId, _callback);

    }

    /**
     * Download certificate
     * 
     * @param certificateId Certificate id to download (required)
     * @return CertificateBundle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow download </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public CertificateBundle certificateDownload(String certificateId) throws ApiException {
        ApiResponse<CertificateBundle> localVarResp = certificateDownloadWithHttpInfo(certificateId);
        return localVarResp.getData();
    }

    /**
     * Download certificate
     * 
     * @param certificateId Certificate id to download (required)
     * @return ApiResponse&lt;CertificateBundle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow download </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CertificateBundle> certificateDownloadWithHttpInfo(String certificateId) throws ApiException {
        okhttp3.Call localVarCall = certificateDownloadValidateBeforeCall(certificateId, null);
        Type localVarReturnType = new TypeToken<CertificateBundle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Download certificate (asynchronously)
     * 
     * @param certificateId Certificate id to download (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow download </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDownloadAsync(String certificateId, final ApiCallback<CertificateBundle> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateDownloadValidateBeforeCall(certificateId, _callback);
        Type localVarReturnType = new TypeToken<CertificateBundle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateDownloadEntitlement
     * @param entitlementId Entitlement id to download (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Entitlement id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow download </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Entitlement id not provided </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDownloadEntitlementCall(String entitlementId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/certificates/download";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (entitlementId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("entitlementId", entitlementId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateDownloadEntitlementValidateBeforeCall(String entitlementId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'entitlementId' is set
        if (entitlementId == null) {
            throw new ApiException("Missing the required parameter 'entitlementId' when calling certificateDownloadEntitlement(Async)");
        }

        return certificateDownloadEntitlementCall(entitlementId, _callback);

    }

    /**
     * Download certificate by entitlement
     * 
     * @param entitlementId Entitlement id to download (required)
     * @return CertificateBundle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Entitlement id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow download </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Entitlement id not provided </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public CertificateBundle certificateDownloadEntitlement(String entitlementId) throws ApiException {
        ApiResponse<CertificateBundle> localVarResp = certificateDownloadEntitlementWithHttpInfo(entitlementId);
        return localVarResp.getData();
    }

    /**
     * Download certificate by entitlement
     * 
     * @param entitlementId Entitlement id to download (required)
     * @return ApiResponse&lt;CertificateBundle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Entitlement id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow download </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Entitlement id not provided </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CertificateBundle> certificateDownloadEntitlementWithHttpInfo(String entitlementId) throws ApiException {
        okhttp3.Call localVarCall = certificateDownloadEntitlementValidateBeforeCall(entitlementId, null);
        Type localVarReturnType = new TypeToken<CertificateBundle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Download certificate by entitlement (asynchronously)
     * 
     * @param entitlementId Entitlement id to download (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Entitlement id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow download </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Entitlement id not provided </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDownloadEntitlementAsync(String entitlementId, final ApiCallback<CertificateBundle> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateDownloadEntitlementValidateBeforeCall(entitlementId, _callback);
        Type localVarReturnType = new TypeToken<CertificateBundle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateEmailHistory
     * @param certificateId Certificate id to retrieve email history (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Email history retrieval successful </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email history not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateEmailHistoryCall(String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/email/history"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateEmailHistoryValidateBeforeCall(String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateEmailHistory(Async)");
        }

        return certificateEmailHistoryCall(certificateId, _callback);

    }

    /**
     * Retrieve email history
     * This method can be used to retrieve all emails sent for a certificate.
     * @param certificateId Certificate id to retrieve email history (required)
     * @return CertificateEmailHistory
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Email history retrieval successful </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email history not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public CertificateEmailHistory certificateEmailHistory(String certificateId) throws ApiException {
        ApiResponse<CertificateEmailHistory> localVarResp = certificateEmailHistoryWithHttpInfo(certificateId);
        return localVarResp.getData();
    }

    /**
     * Retrieve email history
     * This method can be used to retrieve all emails sent for a certificate.
     * @param certificateId Certificate id to retrieve email history (required)
     * @return ApiResponse&lt;CertificateEmailHistory&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Email history retrieval successful </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email history not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CertificateEmailHistory> certificateEmailHistoryWithHttpInfo(String certificateId) throws ApiException {
        okhttp3.Call localVarCall = certificateEmailHistoryValidateBeforeCall(certificateId, null);
        Type localVarReturnType = new TypeToken<CertificateEmailHistory>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve email history (asynchronously)
     * This method can be used to retrieve all emails sent for a certificate.
     * @param certificateId Certificate id to retrieve email history (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Email history retrieval successful </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email history not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateEmailHistoryAsync(String certificateId, final ApiCallback<CertificateEmailHistory> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateEmailHistoryValidateBeforeCall(certificateId, _callback);
        Type localVarReturnType = new TypeToken<CertificateEmailHistory>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateGet
     * @param certificateId Certificate id to lookup (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetCall(String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateGetValidateBeforeCall(String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateGet(Async)");
        }

        return certificateGetCall(certificateId, _callback);

    }

    /**
     * Retrieve certificate details
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate.
     * @param certificateId Certificate id to lookup (required)
     * @return Certificate
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public Certificate certificateGet(String certificateId) throws ApiException {
        ApiResponse<Certificate> localVarResp = certificateGetWithHttpInfo(certificateId);
        return localVarResp.getData();
    }

    /**
     * Retrieve certificate details
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate.
     * @param certificateId Certificate id to lookup (required)
     * @return ApiResponse&lt;Certificate&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Certificate> certificateGetWithHttpInfo(String certificateId) throws ApiException {
        okhttp3.Call localVarCall = certificateGetValidateBeforeCall(certificateId, null);
        Type localVarReturnType = new TypeToken<Certificate>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve certificate details (asynchronously)
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate.
     * @param certificateId Certificate id to lookup (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetAsync(String certificateId, final ApiCallback<Certificate> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateGetValidateBeforeCall(certificateId, _callback);
        Type localVarReturnType = new TypeToken<Certificate>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateGetEntitlement
     * @param entitlementId Entitlement id to lookup (required)
     * @param latest Fetch only the most recent certificate (optional, default to true)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Entitlement id not provided </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetEntitlementCall(String entitlementId, Boolean latest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/certificates";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (entitlementId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("entitlementId", entitlementId));
        }

        if (latest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latest", latest));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateGetEntitlementValidateBeforeCall(String entitlementId, Boolean latest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'entitlementId' is set
        if (entitlementId == null) {
            throw new ApiException("Missing the required parameter 'entitlementId' when calling certificateGetEntitlement(Async)");
        }

        return certificateGetEntitlementCall(entitlementId, latest, _callback);

    }

    /**
     * Search for certificate details by entitlement
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificates associated to an entitlement.
     * @param entitlementId Entitlement id to lookup (required)
     * @param latest Fetch only the most recent certificate (optional, default to true)
     * @return List&lt;Certificate&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Entitlement id not provided </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public List<Certificate> certificateGetEntitlement(String entitlementId, Boolean latest) throws ApiException {
        ApiResponse<List<Certificate>> localVarResp = certificateGetEntitlementWithHttpInfo(entitlementId, latest);
        return localVarResp.getData();
    }

    /**
     * Search for certificate details by entitlement
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificates associated to an entitlement.
     * @param entitlementId Entitlement id to lookup (required)
     * @param latest Fetch only the most recent certificate (optional, default to true)
     * @return ApiResponse&lt;List&lt;Certificate&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Entitlement id not provided </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Certificate>> certificateGetEntitlementWithHttpInfo(String entitlementId, Boolean latest) throws ApiException {
        okhttp3.Call localVarCall = certificateGetEntitlementValidateBeforeCall(entitlementId, latest, null);
        Type localVarReturnType = new TypeToken<List<Certificate>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Search for certificate details by entitlement (asynchronously)
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificates associated to an entitlement.
     * @param entitlementId Entitlement id to lookup (required)
     * @param latest Fetch only the most recent certificate (optional, default to true)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Entitlement id not provided </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetEntitlementAsync(String entitlementId, Boolean latest, final ApiCallback<List<Certificate>> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateGetEntitlementValidateBeforeCall(entitlementId, latest, _callback);
        Type localVarReturnType = new TypeToken<List<Certificate>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateReissue
     * @param certificateId Certificate id to reissue (required)
     * @param certificateReissue The reissue request info (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Reissue request created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow reissue </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;csr&#x60; is invalid&lt;br&gt;Delay revocation exceeds maximum </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateReissueCall(String certificateId, CertificateReissue certificateReissue, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = certificateReissue;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/reissue"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateReissueValidateBeforeCall(String certificateId, CertificateReissue certificateReissue, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateReissue(Async)");
        }

        // verify the required parameter 'certificateReissue' is set
        if (certificateReissue == null) {
            throw new ApiException("Missing the required parameter 'certificateReissue' when calling certificateReissue(Async)");
        }

        return certificateReissueCall(certificateId, certificateReissue, _callback);

    }

    /**
     * Reissue active certificate
     * &lt;p&gt;Rekeying is the process by which the private and public key is changed for a certificate. It is a simplified reissue,where only the CSR is changed. Reissuing is the process by which domain names are added or removed from a certificate.Once a request is validated and approved, the certificate will be reissued with the new common name and sans specified. Unlimited reissues are available during the lifetime of the certificate.New names added to a certificate that do not share the base domain of the common name may take additional time to validate. If this API call is made before a previous pending reissue has been validated and issued, the previous reissue request is automatically rejected and replaced with the current request.&lt;/p&gt;
     * @param certificateId Certificate id to reissue (required)
     * @param certificateReissue The reissue request info (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Reissue request created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow reissue </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;csr&#x60; is invalid&lt;br&gt;Delay revocation exceeds maximum </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateReissue(String certificateId, CertificateReissue certificateReissue) throws ApiException {
        certificateReissueWithHttpInfo(certificateId, certificateReissue);
    }

    /**
     * Reissue active certificate
     * &lt;p&gt;Rekeying is the process by which the private and public key is changed for a certificate. It is a simplified reissue,where only the CSR is changed. Reissuing is the process by which domain names are added or removed from a certificate.Once a request is validated and approved, the certificate will be reissued with the new common name and sans specified. Unlimited reissues are available during the lifetime of the certificate.New names added to a certificate that do not share the base domain of the common name may take additional time to validate. If this API call is made before a previous pending reissue has been validated and issued, the previous reissue request is automatically rejected and replaced with the current request.&lt;/p&gt;
     * @param certificateId Certificate id to reissue (required)
     * @param certificateReissue The reissue request info (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Reissue request created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow reissue </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;csr&#x60; is invalid&lt;br&gt;Delay revocation exceeds maximum </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateReissueWithHttpInfo(String certificateId, CertificateReissue certificateReissue) throws ApiException {
        okhttp3.Call localVarCall = certificateReissueValidateBeforeCall(certificateId, certificateReissue, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Reissue active certificate (asynchronously)
     * &lt;p&gt;Rekeying is the process by which the private and public key is changed for a certificate. It is a simplified reissue,where only the CSR is changed. Reissuing is the process by which domain names are added or removed from a certificate.Once a request is validated and approved, the certificate will be reissued with the new common name and sans specified. Unlimited reissues are available during the lifetime of the certificate.New names added to a certificate that do not share the base domain of the common name may take additional time to validate. If this API call is made before a previous pending reissue has been validated and issued, the previous reissue request is automatically rejected and replaced with the current request.&lt;/p&gt;
     * @param certificateId Certificate id to reissue (required)
     * @param certificateReissue The reissue request info (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Reissue request created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow reissue </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;csr&#x60; is invalid&lt;br&gt;Delay revocation exceeds maximum </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateReissueAsync(String certificateId, CertificateReissue certificateReissue, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateReissueValidateBeforeCall(certificateId, certificateReissue, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateRenew
     * @param certificateId Certificate id to renew (required)
     * @param certificateRenew The renew request info (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Renew request created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRenewCall(String certificateId, CertificateRenew certificateRenew, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = certificateRenew;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/renew"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateRenewValidateBeforeCall(String certificateId, CertificateRenew certificateRenew, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateRenew(Async)");
        }

        // verify the required parameter 'certificateRenew' is set
        if (certificateRenew == null) {
            throw new ApiException("Missing the required parameter 'certificateRenew' when calling certificateRenew(Async)");
        }

        return certificateRenewCall(certificateId, certificateRenew, _callback);

    }

    /**
     * Renew active certificate
     * Renewal is the process by which the validity of a certificate is extended. Renewal is only available 60 days prior to expiration of the previous certificate and 30 days after the expiration of the previous certificate. The renewal supports modifying a set of the original certificate order information. Once a request is validated and approved, the certificate will be issued with extended validity. Since subject alternative names can be removed during a renewal, we require that you provide the subject alternative names you expect in the renewed certificate. New names added to a certificate that do not share the base domain of the common name may take additional time to validate. &lt;/p&gt;
     * @param certificateId Certificate id to renew (required)
     * @param certificateRenew The renew request info (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Renew request created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateRenew(String certificateId, CertificateRenew certificateRenew) throws ApiException {
        certificateRenewWithHttpInfo(certificateId, certificateRenew);
    }

    /**
     * Renew active certificate
     * Renewal is the process by which the validity of a certificate is extended. Renewal is only available 60 days prior to expiration of the previous certificate and 30 days after the expiration of the previous certificate. The renewal supports modifying a set of the original certificate order information. Once a request is validated and approved, the certificate will be issued with extended validity. Since subject alternative names can be removed during a renewal, we require that you provide the subject alternative names you expect in the renewed certificate. New names added to a certificate that do not share the base domain of the common name may take additional time to validate. &lt;/p&gt;
     * @param certificateId Certificate id to renew (required)
     * @param certificateRenew The renew request info (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Renew request created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateRenewWithHttpInfo(String certificateId, CertificateRenew certificateRenew) throws ApiException {
        okhttp3.Call localVarCall = certificateRenewValidateBeforeCall(certificateId, certificateRenew, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Renew active certificate (asynchronously)
     * Renewal is the process by which the validity of a certificate is extended. Renewal is only available 60 days prior to expiration of the previous certificate and 30 days after the expiration of the previous certificate. The renewal supports modifying a set of the original certificate order information. Once a request is validated and approved, the certificate will be issued with extended validity. Since subject alternative names can be removed during a renewal, we require that you provide the subject alternative names you expect in the renewed certificate. New names added to a certificate that do not share the base domain of the common name may take additional time to validate. &lt;/p&gt;
     * @param certificateId Certificate id to renew (required)
     * @param certificateRenew The renew request info (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Renew request created </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRenewAsync(String certificateId, CertificateRenew certificateRenew, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateRenewValidateBeforeCall(certificateId, certificateRenew, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateResendEmail
     * @param certificateId Certificate id to resend email (required)
     * @param emailId Email id for email to resend (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Email sent successfully </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email Id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateResendEmailCall(String certificateId, String emailId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/email/{emailId}/resend"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()))
            .replace("{" + "emailId" + "}", localVarApiClient.escapeString(emailId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateResendEmailValidateBeforeCall(String certificateId, String emailId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateResendEmail(Async)");
        }

        // verify the required parameter 'emailId' is set
        if (emailId == null) {
            throw new ApiException("Missing the required parameter 'emailId' when calling certificateResendEmail(Async)");
        }

        return certificateResendEmailCall(certificateId, emailId, _callback);

    }

    /**
     * Resend an email
     * This method can be used to resend emails by providing the certificate id and the email id
     * @param certificateId Certificate id to resend email (required)
     * @param emailId Email id for email to resend (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Email sent successfully </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email Id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateResendEmail(String certificateId, String emailId) throws ApiException {
        certificateResendEmailWithHttpInfo(certificateId, emailId);
    }

    /**
     * Resend an email
     * This method can be used to resend emails by providing the certificate id and the email id
     * @param certificateId Certificate id to resend email (required)
     * @param emailId Email id for email to resend (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Email sent successfully </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email Id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateResendEmailWithHttpInfo(String certificateId, String emailId) throws ApiException {
        okhttp3.Call localVarCall = certificateResendEmailValidateBeforeCall(certificateId, emailId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Resend an email (asynchronously)
     * This method can be used to resend emails by providing the certificate id and the email id
     * @param certificateId Certificate id to resend email (required)
     * @param emailId Email id for email to resend (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Email sent successfully </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email Id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateResendEmailAsync(String certificateId, String emailId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateResendEmailValidateBeforeCall(certificateId, emailId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateResendEmailAddress
     * @param certificateId Certificate id to resend emails (required)
     * @param emailId Email id for email to resend (required)
     * @param emailAddress Specific email address to resend email (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Email sent successfully </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email Id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateResendEmailAddressCall(String certificateId, String emailId, String emailAddress, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/email/{emailId}/resend/{emailAddress}"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()))
            .replace("{" + "emailId" + "}", localVarApiClient.escapeString(emailId.toString()))
            .replace("{" + "emailAddress" + "}", localVarApiClient.escapeString(emailAddress.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateResendEmailAddressValidateBeforeCall(String certificateId, String emailId, String emailAddress, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateResendEmailAddress(Async)");
        }

        // verify the required parameter 'emailId' is set
        if (emailId == null) {
            throw new ApiException("Missing the required parameter 'emailId' when calling certificateResendEmailAddress(Async)");
        }

        // verify the required parameter 'emailAddress' is set
        if (emailAddress == null) {
            throw new ApiException("Missing the required parameter 'emailAddress' when calling certificateResendEmailAddress(Async)");
        }

        return certificateResendEmailAddressCall(certificateId, emailId, emailAddress, _callback);

    }

    /**
     * Resend email to email address
     * This method can be used to resend emails by providing the certificate id, the email id, and the recipient email address
     * @param certificateId Certificate id to resend emails (required)
     * @param emailId Email id for email to resend (required)
     * @param emailAddress Specific email address to resend email (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Email sent successfully </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email Id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateResendEmailAddress(String certificateId, String emailId, String emailAddress) throws ApiException {
        certificateResendEmailAddressWithHttpInfo(certificateId, emailId, emailAddress);
    }

    /**
     * Resend email to email address
     * This method can be used to resend emails by providing the certificate id, the email id, and the recipient email address
     * @param certificateId Certificate id to resend emails (required)
     * @param emailId Email id for email to resend (required)
     * @param emailAddress Specific email address to resend email (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Email sent successfully </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email Id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateResendEmailAddressWithHttpInfo(String certificateId, String emailId, String emailAddress) throws ApiException {
        okhttp3.Call localVarCall = certificateResendEmailAddressValidateBeforeCall(certificateId, emailId, emailAddress, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Resend email to email address (asynchronously)
     * This method can be used to resend emails by providing the certificate id, the email id, and the recipient email address
     * @param certificateId Certificate id to resend emails (required)
     * @param emailId Email id for email to resend (required)
     * @param emailAddress Specific email address to resend email (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Email sent successfully </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Email Id not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateResendEmailAddressAsync(String certificateId, String emailId, String emailAddress, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateResendEmailAddressValidateBeforeCall(certificateId, emailId, emailAddress, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateRevoke
     * @param certificateId Certificate id to revoke (required)
     * @param certificateRevoke The certificate revocation request (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Certificate Revoked </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow revoke </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRevokeCall(String certificateId, CertificateRevoke certificateRevoke, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = certificateRevoke;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/revoke"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateRevokeValidateBeforeCall(String certificateId, CertificateRevoke certificateRevoke, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateRevoke(Async)");
        }

        // verify the required parameter 'certificateRevoke' is set
        if (certificateRevoke == null) {
            throw new ApiException("Missing the required parameter 'certificateRevoke' when calling certificateRevoke(Async)");
        }

        return certificateRevokeCall(certificateId, certificateRevoke, _callback);

    }

    /**
     * Revoke active certificate
     * Use revoke call to revoke an active certificate, if the certificate has not been issued a 404 response will be returned.
     * @param certificateId Certificate id to revoke (required)
     * @param certificateRevoke The certificate revocation request (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Certificate Revoked </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow revoke </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateRevoke(String certificateId, CertificateRevoke certificateRevoke) throws ApiException {
        certificateRevokeWithHttpInfo(certificateId, certificateRevoke);
    }

    /**
     * Revoke active certificate
     * Use revoke call to revoke an active certificate, if the certificate has not been issued a 404 response will be returned.
     * @param certificateId Certificate id to revoke (required)
     * @param certificateRevoke The certificate revocation request (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Certificate Revoked </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow revoke </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateRevokeWithHttpInfo(String certificateId, CertificateRevoke certificateRevoke) throws ApiException {
        okhttp3.Call localVarCall = certificateRevokeValidateBeforeCall(certificateId, certificateRevoke, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Revoke active certificate (asynchronously)
     * Use revoke call to revoke an active certificate, if the certificate has not been issued a 404 response will be returned.
     * @param certificateId Certificate id to revoke (required)
     * @param certificateRevoke The certificate revocation request (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Certificate Revoked </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow revoke </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRevokeAsync(String certificateId, CertificateRevoke certificateRevoke, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateRevokeValidateBeforeCall(certificateId, certificateRevoke, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateSitesealGet
     * @param certificateId Certificate id (required)
     * @param theme This value represents the visual theme of the seal. If seal doesn&#39;t exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present. (optional, default to LIGHT)
     * @param locale Determine locale for text displayed in seal image and verification page. If seal doesn&#39;t exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present. (optional, default to en)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Site seal retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow seal </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#39;locale&#39; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateSitesealGetCall(String certificateId, String theme, String locale, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/siteSeal"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (theme != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("theme", theme));
        }

        if (locale != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("locale", locale));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateSitesealGetValidateBeforeCall(String certificateId, String theme, String locale, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateSitesealGet(Async)");
        }

        return certificateSitesealGetCall(certificateId, theme, locale, _callback);

    }

    /**
     * Get Site seal
     * &lt;p&gt;This method is used to obtain the site seal information for an issued certificate. A site seal is a graphic that the certificate purchaser can embed on their web site to show their visitors information about their SSL certificate. If a web site visitor clicks on the site seal image, a pop-up page is displayed that contains detailed information about the SSL certificate. The site seal token is used to link the site seal graphic image to the appropriate certificate details pop-up page display when a user clicks on the site seal. The site seal images are expected to be static images and hosted on the reseller&#39;s website, to minimize delays for customer page load times.&lt;/p&gt;
     * @param certificateId Certificate id (required)
     * @param theme This value represents the visual theme of the seal. If seal doesn&#39;t exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present. (optional, default to LIGHT)
     * @param locale Determine locale for text displayed in seal image and verification page. If seal doesn&#39;t exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present. (optional, default to en)
     * @return CertificateSiteSeal
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Site seal retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow seal </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#39;locale&#39; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public CertificateSiteSeal certificateSitesealGet(String certificateId, String theme, String locale) throws ApiException {
        ApiResponse<CertificateSiteSeal> localVarResp = certificateSitesealGetWithHttpInfo(certificateId, theme, locale);
        return localVarResp.getData();
    }

    /**
     * Get Site seal
     * &lt;p&gt;This method is used to obtain the site seal information for an issued certificate. A site seal is a graphic that the certificate purchaser can embed on their web site to show their visitors information about their SSL certificate. If a web site visitor clicks on the site seal image, a pop-up page is displayed that contains detailed information about the SSL certificate. The site seal token is used to link the site seal graphic image to the appropriate certificate details pop-up page display when a user clicks on the site seal. The site seal images are expected to be static images and hosted on the reseller&#39;s website, to minimize delays for customer page load times.&lt;/p&gt;
     * @param certificateId Certificate id (required)
     * @param theme This value represents the visual theme of the seal. If seal doesn&#39;t exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present. (optional, default to LIGHT)
     * @param locale Determine locale for text displayed in seal image and verification page. If seal doesn&#39;t exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present. (optional, default to en)
     * @return ApiResponse&lt;CertificateSiteSeal&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Site seal retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow seal </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#39;locale&#39; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CertificateSiteSeal> certificateSitesealGetWithHttpInfo(String certificateId, String theme, String locale) throws ApiException {
        okhttp3.Call localVarCall = certificateSitesealGetValidateBeforeCall(certificateId, theme, locale, null);
        Type localVarReturnType = new TypeToken<CertificateSiteSeal>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Site seal (asynchronously)
     * &lt;p&gt;This method is used to obtain the site seal information for an issued certificate. A site seal is a graphic that the certificate purchaser can embed on their web site to show their visitors information about their SSL certificate. If a web site visitor clicks on the site seal image, a pop-up page is displayed that contains detailed information about the SSL certificate. The site seal token is used to link the site seal graphic image to the appropriate certificate details pop-up page display when a user clicks on the site seal. The site seal images are expected to be static images and hosted on the reseller&#39;s website, to minimize delays for customer page load times.&lt;/p&gt;
     * @param certificateId Certificate id (required)
     * @param theme This value represents the visual theme of the seal. If seal doesn&#39;t exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present. (optional, default to LIGHT)
     * @param locale Determine locale for text displayed in seal image and verification page. If seal doesn&#39;t exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present. (optional, default to en)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Site seal retrieved </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow seal </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#39;locale&#39; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateSitesealGetAsync(String certificateId, String theme, String locale, final ApiCallback<CertificateSiteSeal> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateSitesealGetValidateBeforeCall(certificateId, theme, locale, _callback);
        Type localVarReturnType = new TypeToken<CertificateSiteSeal>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateValidate
     * @param certificateCreate The certificate order info (required)
     * @param xMarketId Setting locale for communications such as emails and error messages (optional, default to Default locale for shopper account)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Request validated successfully </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;email&#x60; is not empty &lt;br&gt; &#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateValidateCall(CertificateCreate certificateCreate, String xMarketId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = certificateCreate;

        // create path and map variables
        String localVarPath = "/v1/certificates/validate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xMarketId != null) {
            localVarHeaderParams.put("X-Market-Id", localVarApiClient.parameterToString(xMarketId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateValidateValidateBeforeCall(CertificateCreate certificateCreate, String xMarketId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateCreate' is set
        if (certificateCreate == null) {
            throw new ApiException("Missing the required parameter 'certificateCreate' when calling certificateValidate(Async)");
        }

        return certificateValidateCall(certificateCreate, xMarketId, _callback);

    }

    /**
     * Validate a pending order for certificate
     * 
     * @param certificateCreate The certificate order info (required)
     * @param xMarketId Setting locale for communications such as emails and error messages (optional, default to Default locale for shopper account)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Request validated successfully </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;email&#x60; is not empty &lt;br&gt; &#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateValidate(CertificateCreate certificateCreate, String xMarketId) throws ApiException {
        certificateValidateWithHttpInfo(certificateCreate, xMarketId);
    }

    /**
     * Validate a pending order for certificate
     * 
     * @param certificateCreate The certificate order info (required)
     * @param xMarketId Setting locale for communications such as emails and error messages (optional, default to Default locale for shopper account)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Request validated successfully </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;email&#x60; is not empty &lt;br&gt; &#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateValidateWithHttpInfo(CertificateCreate certificateCreate, String xMarketId) throws ApiException {
        okhttp3.Call localVarCall = certificateValidateValidateBeforeCall(certificateCreate, xMarketId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Validate a pending order for certificate (asynchronously)
     * 
     * @param certificateCreate The certificate order info (required)
     * @param xMarketId Setting locale for communications such as emails and error messages (optional, default to Default locale for shopper account)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Request validated successfully </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Certificate state does not allow renew </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> &#x60;email&#x60; is not empty &lt;br&gt; &#x60;csr&#x60; is invalid </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateValidateAsync(CertificateCreate certificateCreate, String xMarketId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateValidateValidateBeforeCall(certificateCreate, xMarketId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateVerifydomaincontrol
     * @param certificateId Certificate id to lookup (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Domain control was successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Domain control was not successful &lt;br&gt; Certificate state does not allow domain control </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateVerifydomaincontrolCall(String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/certificates/{certificateId}/verifyDomainControl"
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateVerifydomaincontrolValidateBeforeCall(String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateVerifydomaincontrol(Async)");
        }

        return certificateVerifydomaincontrolCall(certificateId, _callback);

    }

    /**
     * Check Domain Control
     * Domain control is a means for verifying the domain included in the certificate order. This resource is useful for resellers that control the domains for their customers, and can expedite the verification process. See https://www.godaddy.com/help/verifying-your-domain-ownership-for-ssl-certificate-requests-html-or-dns-7452
     * @param certificateId Certificate id to lookup (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Domain control was successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Domain control was not successful &lt;br&gt; Certificate state does not allow domain control </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public void certificateVerifydomaincontrol(String certificateId) throws ApiException {
        certificateVerifydomaincontrolWithHttpInfo(certificateId);
    }

    /**
     * Check Domain Control
     * Domain control is a means for verifying the domain included in the certificate order. This resource is useful for resellers that control the domains for their customers, and can expedite the verification process. See https://www.godaddy.com/help/verifying-your-domain-ownership-for-ssl-certificate-requests-html-or-dns-7452
     * @param certificateId Certificate id to lookup (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Domain control was successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Domain control was not successful &lt;br&gt; Certificate state does not allow domain control </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateVerifydomaincontrolWithHttpInfo(String certificateId) throws ApiException {
        okhttp3.Call localVarCall = certificateVerifydomaincontrolValidateBeforeCall(certificateId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Check Domain Control (asynchronously)
     * Domain control is a means for verifying the domain included in the certificate order. This resource is useful for resellers that control the domains for their customers, and can expedite the verification process. See https://www.godaddy.com/help/verifying-your-domain-ownership-for-ssl-certificate-requests-html-or-dns-7452
     * @param certificateId Certificate id to lookup (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Domain control was successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request was malformed </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Certificate id not found </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Domain control was not successful &lt;br&gt; Certificate state does not allow domain control </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateVerifydomaincontrolAsync(String certificateId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateVerifydomaincontrolValidateBeforeCall(certificateId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
