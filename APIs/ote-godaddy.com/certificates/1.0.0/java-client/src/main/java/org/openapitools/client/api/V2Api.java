/*
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.CertificateDetailV2;
import org.openapitools.client.model.CertificateSummariesV2;
import org.openapitools.client.model.DomainVerificationDetail;
import org.openapitools.client.model.DomainVerificationSummary;
import org.openapitools.client.model.Error;
import org.openapitools.client.model.ErrorLimit;
import org.openapitools.client.model.ExternalAccountBinding;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class V2Api {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public V2Api() {
        this(Configuration.getDefaultApiClient());
    }

    public V2Api(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getAcmeExternalAccountBinding
     * @param customerId An identifier for a customer (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Acme key identifier and HMAC key for the external account binding. Directory URI is also provided for making ACME requests. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAcmeExternalAccountBindingCall(String customerId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/customers/{customerId}/certificates/acme/externalAccountBinding"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAcmeExternalAccountBindingValidateBeforeCall(String customerId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling getAcmeExternalAccountBinding(Async)");
        }

        return getAcmeExternalAccountBindingCall(customerId, _callback);

    }

    /**
     * Retrieves the external account binding for the specified customer
     * Use this endpoint to retrieve a key identifier and Hash-based Message Authentication Code (HMAC) key for Automated Certificate Management Environment (ACME) External Account Binding (EAB). These credentials can be used with an ACME client that supports EAB (ex. CertBot) to automate the issuance request and deployment of DV SSL certificates
     * @param customerId An identifier for a customer (required)
     * @return ExternalAccountBinding
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Acme key identifier and HMAC key for the external account binding. Directory URI is also provided for making ACME requests. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ExternalAccountBinding getAcmeExternalAccountBinding(String customerId) throws ApiException {
        ApiResponse<ExternalAccountBinding> localVarResp = getAcmeExternalAccountBindingWithHttpInfo(customerId);
        return localVarResp.getData();
    }

    /**
     * Retrieves the external account binding for the specified customer
     * Use this endpoint to retrieve a key identifier and Hash-based Message Authentication Code (HMAC) key for Automated Certificate Management Environment (ACME) External Account Binding (EAB). These credentials can be used with an ACME client that supports EAB (ex. CertBot) to automate the issuance request and deployment of DV SSL certificates
     * @param customerId An identifier for a customer (required)
     * @return ApiResponse&lt;ExternalAccountBinding&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Acme key identifier and HMAC key for the external account binding. Directory URI is also provided for making ACME requests. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ExternalAccountBinding> getAcmeExternalAccountBindingWithHttpInfo(String customerId) throws ApiException {
        okhttp3.Call localVarCall = getAcmeExternalAccountBindingValidateBeforeCall(customerId, null);
        Type localVarReturnType = new TypeToken<ExternalAccountBinding>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieves the external account binding for the specified customer (asynchronously)
     * Use this endpoint to retrieve a key identifier and Hash-based Message Authentication Code (HMAC) key for Automated Certificate Management Environment (ACME) External Account Binding (EAB). These credentials can be used with an ACME client that supports EAB (ex. CertBot) to automate the issuance request and deployment of DV SSL certificates
     * @param customerId An identifier for a customer (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Acme key identifier and HMAC key for the external account binding. Directory URI is also provided for making ACME requests. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAcmeExternalAccountBindingAsync(String customerId, final ApiCallback<ExternalAccountBinding> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAcmeExternalAccountBindingValidateBeforeCall(customerId, _callback);
        Type localVarReturnType = new TypeToken<ExternalAccountBinding>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCertificateDetailByCertIdentifier
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCertificateDetailByCertIdentifierCall(String customerId, String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/customers/{customerId}/certificates/{certificateId}"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()))
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCertificateDetailByCertIdentifierValidateBeforeCall(String customerId, String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling getCertificateDetailByCertIdentifier(Async)");
        }

        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling getCertificateDetailByCertIdentifier(Async)");
        }

        return getCertificateDetailByCertIdentifierCall(customerId, certificateId, _callback);

    }

    /**
     * Retrieve individual certificate details
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate. &lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**. **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @return CertificateDetailV2
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public CertificateDetailV2 getCertificateDetailByCertIdentifier(String customerId, String certificateId) throws ApiException {
        ApiResponse<CertificateDetailV2> localVarResp = getCertificateDetailByCertIdentifierWithHttpInfo(customerId, certificateId);
        return localVarResp.getData();
    }

    /**
     * Retrieve individual certificate details
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate. &lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**. **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @return ApiResponse&lt;CertificateDetailV2&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CertificateDetailV2> getCertificateDetailByCertIdentifierWithHttpInfo(String customerId, String certificateId) throws ApiException {
        okhttp3.Call localVarCall = getCertificateDetailByCertIdentifierValidateBeforeCall(customerId, certificateId, null);
        Type localVarReturnType = new TypeToken<CertificateDetailV2>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve individual certificate details (asynchronously)
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate. &lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**. **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Certificate details retrieved </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCertificateDetailByCertIdentifierAsync(String customerId, String certificateId, final ApiCallback<CertificateDetailV2> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCertificateDetailByCertIdentifierValidateBeforeCall(customerId, certificateId, _callback);
        Type localVarReturnType = new TypeToken<CertificateDetailV2>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCustomerCertificatesByCustomerId
     * @param customerId An identifier for a customer (required)
     * @param offset Number of results to skip for pagination (optional)
     * @param limit Maximum number of items to return (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Customer certificate information retrieved. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCustomerCertificatesByCustomerIdCall(String customerId, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/customers/{customerId}/certificates"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {
            "application/json",
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCustomerCertificatesByCustomerIdValidateBeforeCall(String customerId, Integer offset, Integer limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling getCustomerCertificatesByCustomerId(Async)");
        }

        return getCustomerCertificatesByCustomerIdCall(customerId, offset, limit, _callback);

    }

    /**
     * Retrieve customer&#39;s certificates
     * This method can be used to retrieve a list of certificates for a specified customer. &lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;
     * @param customerId An identifier for a customer (required)
     * @param offset Number of results to skip for pagination (optional)
     * @param limit Maximum number of items to return (optional)
     * @return CertificateSummariesV2
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Customer certificate information retrieved. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public CertificateSummariesV2 getCustomerCertificatesByCustomerId(String customerId, Integer offset, Integer limit) throws ApiException {
        ApiResponse<CertificateSummariesV2> localVarResp = getCustomerCertificatesByCustomerIdWithHttpInfo(customerId, offset, limit);
        return localVarResp.getData();
    }

    /**
     * Retrieve customer&#39;s certificates
     * This method can be used to retrieve a list of certificates for a specified customer. &lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;
     * @param customerId An identifier for a customer (required)
     * @param offset Number of results to skip for pagination (optional)
     * @param limit Maximum number of items to return (optional)
     * @return ApiResponse&lt;CertificateSummariesV2&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Customer certificate information retrieved. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CertificateSummariesV2> getCustomerCertificatesByCustomerIdWithHttpInfo(String customerId, Integer offset, Integer limit) throws ApiException {
        okhttp3.Call localVarCall = getCustomerCertificatesByCustomerIdValidateBeforeCall(customerId, offset, limit, null);
        Type localVarReturnType = new TypeToken<CertificateSummariesV2>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve customer&#39;s certificates (asynchronously)
     * This method can be used to retrieve a list of certificates for a specified customer. &lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;
     * @param customerId An identifier for a customer (required)
     * @param offset Number of results to skip for pagination (optional)
     * @param limit Maximum number of items to return (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Customer certificate information retrieved. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCustomerCertificatesByCustomerIdAsync(String customerId, Integer offset, Integer limit, final ApiCallback<CertificateSummariesV2> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCustomerCertificatesByCustomerIdValidateBeforeCall(customerId, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<CertificateSummariesV2>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getDomainDetailsByDomain
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @param domain A valid domain name in the certificate request (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDomainDetailsByDomainCall(String customerId, String certificateId, String domain, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/customers/{customerId}/certificates/{certificateId}/domainVerifications/{domain}"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()))
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()))
            .replace("{" + "domain" + "}", localVarApiClient.escapeString(domain.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDomainDetailsByDomainValidateBeforeCall(String customerId, String certificateId, String domain, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling getDomainDetailsByDomain(Async)");
        }

        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling getDomainDetailsByDomain(Async)");
        }

        // verify the required parameter 'domain' is set
        if (domain == null) {
            throw new ApiException("Missing the required parameter 'domain' when calling getDomainDetailsByDomain(Async)");
        }

        return getDomainDetailsByDomainCall(customerId, certificateId, domain, _callback);

    }

    /**
     * Retrieve detailed information for supplied domain
     * Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details. &lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @param domain A valid domain name in the certificate request (required)
     * @return DomainVerificationDetail
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public DomainVerificationDetail getDomainDetailsByDomain(String customerId, String certificateId, String domain) throws ApiException {
        ApiResponse<DomainVerificationDetail> localVarResp = getDomainDetailsByDomainWithHttpInfo(customerId, certificateId, domain);
        return localVarResp.getData();
    }

    /**
     * Retrieve detailed information for supplied domain
     * Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details. &lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @param domain A valid domain name in the certificate request (required)
     * @return ApiResponse&lt;DomainVerificationDetail&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DomainVerificationDetail> getDomainDetailsByDomainWithHttpInfo(String customerId, String certificateId, String domain) throws ApiException {
        okhttp3.Call localVarCall = getDomainDetailsByDomainValidateBeforeCall(customerId, certificateId, domain, null);
        Type localVarReturnType = new TypeToken<DomainVerificationDetail>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve detailed information for supplied domain (asynchronously)
     * Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details. &lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @param domain A valid domain name in the certificate request (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDomainDetailsByDomainAsync(String customerId, String certificateId, String domain, final ApiCallback<DomainVerificationDetail> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDomainDetailsByDomainValidateBeforeCall(customerId, certificateId, domain, _callback);
        Type localVarReturnType = new TypeToken<DomainVerificationDetail>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getDomainInformationByCertificateId
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Domain verification status list for specified certificateId. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDomainInformationByCertificateIdCall(String customerId, String certificateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/customers/{customerId}/certificates/{certificateId}/domainVerifications"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()))
            .replace("{" + "certificateId" + "}", localVarApiClient.escapeString(certificateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDomainInformationByCertificateIdValidateBeforeCall(String customerId, String certificateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling getDomainInformationByCertificateId(Async)");
        }

        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling getDomainInformationByCertificateId(Async)");
        }

        return getDomainInformationByCertificateIdCall(customerId, certificateId, _callback);

    }

    /**
     * Retrieve domain verification status
     * This method can be used to retrieve the domain verification status for a certificate request.&lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;\&quot;
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @return List&lt;DomainVerificationSummary&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Domain verification status list for specified certificateId. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public List<DomainVerificationSummary> getDomainInformationByCertificateId(String customerId, String certificateId) throws ApiException {
        ApiResponse<List<DomainVerificationSummary>> localVarResp = getDomainInformationByCertificateIdWithHttpInfo(customerId, certificateId);
        return localVarResp.getData();
    }

    /**
     * Retrieve domain verification status
     * This method can be used to retrieve the domain verification status for a certificate request.&lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;\&quot;
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @return ApiResponse&lt;List&lt;DomainVerificationSummary&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Domain verification status list for specified certificateId. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DomainVerificationSummary>> getDomainInformationByCertificateIdWithHttpInfo(String customerId, String certificateId) throws ApiException {
        okhttp3.Call localVarCall = getDomainInformationByCertificateIdValidateBeforeCall(customerId, certificateId, null);
        Type localVarReturnType = new TypeToken<List<DomainVerificationSummary>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve domain verification status (asynchronously)
     * This method can be used to retrieve the domain verification status for a certificate request.&lt;ul&gt;&lt;li&gt;**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)&lt;/li&gt;&lt;/ul&gt;\&quot;
     * @param customerId An identifier for a customer (required)
     * @param certificateId Certificate id to lookup (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Domain verification status list for specified certificateId. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Authentication info not sent or is invalid </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Authenticated user is not allowed access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Resource not found </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Application-specific request error </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> Too many requests received within interval </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDomainInformationByCertificateIdAsync(String customerId, String certificateId, final ApiCallback<List<DomainVerificationSummary>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDomainInformationByCertificateIdValidateBeforeCall(customerId, certificateId, _callback);
        Type localVarReturnType = new TypeToken<List<DomainVerificationSummary>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
