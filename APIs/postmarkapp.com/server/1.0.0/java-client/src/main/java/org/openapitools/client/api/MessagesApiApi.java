/*
 * Postmark API
 * Postmark makes sending and receiving email incredibly easy. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.InboundMessageFullDetailsResponse;
import org.openapitools.client.model.InboundSearchResponse;
import java.time.LocalDate;
import org.openapitools.client.model.MessageClickSearchResponse;
import org.openapitools.client.model.MessageOpenSearchResponse;
import org.openapitools.client.model.OutboundMessageDetailsResponse;
import org.openapitools.client.model.OutboundMessageDumpResponse;
import org.openapitools.client.model.OutboundSearchResponse;
import org.openapitools.client.model.StandardPostmarkResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MessagesApiApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MessagesApiApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MessagesApiApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for bypassRulesForInboundMessage
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message which should bypass inbound rules. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call bypassRulesForInboundMessageCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/inbound/{messageid}/bypass"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call bypassRulesForInboundMessageValidateBeforeCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling bypassRulesForInboundMessage(Async)");
        }

        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling bypassRulesForInboundMessage(Async)");
        }

        return bypassRulesForInboundMessageCall(xPostmarkServerToken, messageid, _callback);

    }

    /**
     * Bypass rules for a blocked inbound message
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message which should bypass inbound rules. (required)
     * @return StandardPostmarkResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public StandardPostmarkResponse bypassRulesForInboundMessage(String xPostmarkServerToken, String messageid) throws ApiException {
        ApiResponse<StandardPostmarkResponse> localVarResp = bypassRulesForInboundMessageWithHttpInfo(xPostmarkServerToken, messageid);
        return localVarResp.getData();
    }

    /**
     * Bypass rules for a blocked inbound message
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message which should bypass inbound rules. (required)
     * @return ApiResponse&lt;StandardPostmarkResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<StandardPostmarkResponse> bypassRulesForInboundMessageWithHttpInfo(String xPostmarkServerToken, String messageid) throws ApiException {
        okhttp3.Call localVarCall = bypassRulesForInboundMessageValidateBeforeCall(xPostmarkServerToken, messageid, null);
        Type localVarReturnType = new TypeToken<StandardPostmarkResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Bypass rules for a blocked inbound message (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message which should bypass inbound rules. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call bypassRulesForInboundMessageAsync(String xPostmarkServerToken, String messageid, final ApiCallback<StandardPostmarkResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = bypassRulesForInboundMessageValidateBeforeCall(xPostmarkServerToken, messageid, _callback);
        Type localVarReturnType = new TypeToken<StandardPostmarkResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getClicksForSingleOutboundMessage
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the Outbound Message for which click statistics should be retrieved. (required)
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getClicksForSingleOutboundMessageCall(String xPostmarkServerToken, String messageid, Integer count, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/clicks/{messageid}"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getClicksForSingleOutboundMessageValidateBeforeCall(String xPostmarkServerToken, String messageid, Integer count, Integer offset, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling getClicksForSingleOutboundMessage(Async)");
        }

        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getClicksForSingleOutboundMessage(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling getClicksForSingleOutboundMessage(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling getClicksForSingleOutboundMessage(Async)");
        }

        return getClicksForSingleOutboundMessageCall(xPostmarkServerToken, messageid, count, offset, _callback);

    }

    /**
     * Retrieve Message Clicks
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the Outbound Message for which click statistics should be retrieved. (required)
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @return MessageClickSearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public MessageClickSearchResponse getClicksForSingleOutboundMessage(String xPostmarkServerToken, String messageid, Integer count, Integer offset) throws ApiException {
        ApiResponse<MessageClickSearchResponse> localVarResp = getClicksForSingleOutboundMessageWithHttpInfo(xPostmarkServerToken, messageid, count, offset);
        return localVarResp.getData();
    }

    /**
     * Retrieve Message Clicks
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the Outbound Message for which click statistics should be retrieved. (required)
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @return ApiResponse&lt;MessageClickSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MessageClickSearchResponse> getClicksForSingleOutboundMessageWithHttpInfo(String xPostmarkServerToken, String messageid, Integer count, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = getClicksForSingleOutboundMessageValidateBeforeCall(xPostmarkServerToken, messageid, count, offset, null);
        Type localVarReturnType = new TypeToken<MessageClickSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve Message Clicks (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the Outbound Message for which click statistics should be retrieved. (required)
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getClicksForSingleOutboundMessageAsync(String xPostmarkServerToken, String messageid, Integer count, Integer offset, final ApiCallback<MessageClickSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getClicksForSingleOutboundMessageValidateBeforeCall(xPostmarkServerToken, messageid, count, offset, _callback);
        Type localVarReturnType = new TypeToken<MessageClickSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getInboundMessageDetails
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to details will be retrieved. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getInboundMessageDetailsCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/inbound/{messageid}/details"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getInboundMessageDetailsValidateBeforeCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling getInboundMessageDetails(Async)");
        }

        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getInboundMessageDetails(Async)");
        }

        return getInboundMessageDetailsCall(xPostmarkServerToken, messageid, _callback);

    }

    /**
     * Inbound message details
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to details will be retrieved. (required)
     * @return InboundMessageFullDetailsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public InboundMessageFullDetailsResponse getInboundMessageDetails(String xPostmarkServerToken, String messageid) throws ApiException {
        ApiResponse<InboundMessageFullDetailsResponse> localVarResp = getInboundMessageDetailsWithHttpInfo(xPostmarkServerToken, messageid);
        return localVarResp.getData();
    }

    /**
     * Inbound message details
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to details will be retrieved. (required)
     * @return ApiResponse&lt;InboundMessageFullDetailsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<InboundMessageFullDetailsResponse> getInboundMessageDetailsWithHttpInfo(String xPostmarkServerToken, String messageid) throws ApiException {
        okhttp3.Call localVarCall = getInboundMessageDetailsValidateBeforeCall(xPostmarkServerToken, messageid, null);
        Type localVarReturnType = new TypeToken<InboundMessageFullDetailsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Inbound message details (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to details will be retrieved. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getInboundMessageDetailsAsync(String xPostmarkServerToken, String messageid, final ApiCallback<InboundMessageFullDetailsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getInboundMessageDetailsValidateBeforeCall(xPostmarkServerToken, messageid, _callback);
        Type localVarReturnType = new TypeToken<InboundMessageFullDetailsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getOpensForSingleOutboundMessage
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the Outbound Message for which open statistics should be retrieved. (required)
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getOpensForSingleOutboundMessageCall(String xPostmarkServerToken, String messageid, Integer count, Integer offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/opens/{messageid}"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOpensForSingleOutboundMessageValidateBeforeCall(String xPostmarkServerToken, String messageid, Integer count, Integer offset, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling getOpensForSingleOutboundMessage(Async)");
        }

        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getOpensForSingleOutboundMessage(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling getOpensForSingleOutboundMessage(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling getOpensForSingleOutboundMessage(Async)");
        }

        return getOpensForSingleOutboundMessageCall(xPostmarkServerToken, messageid, count, offset, _callback);

    }

    /**
     * Retrieve Message Opens
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the Outbound Message for which open statistics should be retrieved. (required)
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @return MessageOpenSearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public MessageOpenSearchResponse getOpensForSingleOutboundMessage(String xPostmarkServerToken, String messageid, Integer count, Integer offset) throws ApiException {
        ApiResponse<MessageOpenSearchResponse> localVarResp = getOpensForSingleOutboundMessageWithHttpInfo(xPostmarkServerToken, messageid, count, offset);
        return localVarResp.getData();
    }

    /**
     * Retrieve Message Opens
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the Outbound Message for which open statistics should be retrieved. (required)
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @return ApiResponse&lt;MessageOpenSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MessageOpenSearchResponse> getOpensForSingleOutboundMessageWithHttpInfo(String xPostmarkServerToken, String messageid, Integer count, Integer offset) throws ApiException {
        okhttp3.Call localVarCall = getOpensForSingleOutboundMessageValidateBeforeCall(xPostmarkServerToken, messageid, count, offset, null);
        Type localVarReturnType = new TypeToken<MessageOpenSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve Message Opens (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the Outbound Message for which open statistics should be retrieved. (required)
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getOpensForSingleOutboundMessageAsync(String xPostmarkServerToken, String messageid, Integer count, Integer offset, final ApiCallback<MessageOpenSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getOpensForSingleOutboundMessageValidateBeforeCall(xPostmarkServerToken, messageid, count, offset, _callback);
        Type localVarReturnType = new TypeToken<MessageOpenSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getOutboundMessageDetails
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to retrieve details. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getOutboundMessageDetailsCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/{messageid}/details"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOutboundMessageDetailsValidateBeforeCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling getOutboundMessageDetails(Async)");
        }

        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getOutboundMessageDetails(Async)");
        }

        return getOutboundMessageDetailsCall(xPostmarkServerToken, messageid, _callback);

    }

    /**
     * Outbound message details
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to retrieve details. (required)
     * @return OutboundMessageDetailsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public OutboundMessageDetailsResponse getOutboundMessageDetails(String xPostmarkServerToken, String messageid) throws ApiException {
        ApiResponse<OutboundMessageDetailsResponse> localVarResp = getOutboundMessageDetailsWithHttpInfo(xPostmarkServerToken, messageid);
        return localVarResp.getData();
    }

    /**
     * Outbound message details
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to retrieve details. (required)
     * @return ApiResponse&lt;OutboundMessageDetailsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<OutboundMessageDetailsResponse> getOutboundMessageDetailsWithHttpInfo(String xPostmarkServerToken, String messageid) throws ApiException {
        okhttp3.Call localVarCall = getOutboundMessageDetailsValidateBeforeCall(xPostmarkServerToken, messageid, null);
        Type localVarReturnType = new TypeToken<OutboundMessageDetailsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Outbound message details (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to retrieve details. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getOutboundMessageDetailsAsync(String xPostmarkServerToken, String messageid, final ApiCallback<OutboundMessageDetailsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getOutboundMessageDetailsValidateBeforeCall(xPostmarkServerToken, messageid, _callback);
        Type localVarReturnType = new TypeToken<OutboundMessageDetailsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getOutboundMessageDump
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to retrieve a dump. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getOutboundMessageDumpCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/{messageid}/dump"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOutboundMessageDumpValidateBeforeCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling getOutboundMessageDump(Async)");
        }

        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling getOutboundMessageDump(Async)");
        }

        return getOutboundMessageDumpCall(xPostmarkServerToken, messageid, _callback);

    }

    /**
     * Outbound message dump
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to retrieve a dump. (required)
     * @return OutboundMessageDumpResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public OutboundMessageDumpResponse getOutboundMessageDump(String xPostmarkServerToken, String messageid) throws ApiException {
        ApiResponse<OutboundMessageDumpResponse> localVarResp = getOutboundMessageDumpWithHttpInfo(xPostmarkServerToken, messageid);
        return localVarResp.getData();
    }

    /**
     * Outbound message dump
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to retrieve a dump. (required)
     * @return ApiResponse&lt;OutboundMessageDumpResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<OutboundMessageDumpResponse> getOutboundMessageDumpWithHttpInfo(String xPostmarkServerToken, String messageid) throws ApiException {
        okhttp3.Call localVarCall = getOutboundMessageDumpValidateBeforeCall(xPostmarkServerToken, messageid, null);
        Type localVarReturnType = new TypeToken<OutboundMessageDumpResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Outbound message dump (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the message for which to retrieve a dump. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getOutboundMessageDumpAsync(String xPostmarkServerToken, String messageid, final ApiCallback<OutboundMessageDumpResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getOutboundMessageDumpValidateBeforeCall(xPostmarkServerToken, messageid, _callback);
        Type localVarReturnType = new TypeToken<OutboundMessageDumpResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for retryInboundMessageProcessing
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the inbound message on which we should retry processing. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call retryInboundMessageProcessingCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/inbound/{messageid}/retry"
            .replace("{" + "messageid" + "}", localVarApiClient.escapeString(messageid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call retryInboundMessageProcessingValidateBeforeCall(String xPostmarkServerToken, String messageid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling retryInboundMessageProcessing(Async)");
        }

        // verify the required parameter 'messageid' is set
        if (messageid == null) {
            throw new ApiException("Missing the required parameter 'messageid' when calling retryInboundMessageProcessing(Async)");
        }

        return retryInboundMessageProcessingCall(xPostmarkServerToken, messageid, _callback);

    }

    /**
     * Retry a failed inbound message for processing
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the inbound message on which we should retry processing. (required)
     * @return StandardPostmarkResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public StandardPostmarkResponse retryInboundMessageProcessing(String xPostmarkServerToken, String messageid) throws ApiException {
        ApiResponse<StandardPostmarkResponse> localVarResp = retryInboundMessageProcessingWithHttpInfo(xPostmarkServerToken, messageid);
        return localVarResp.getData();
    }

    /**
     * Retry a failed inbound message for processing
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the inbound message on which we should retry processing. (required)
     * @return ApiResponse&lt;StandardPostmarkResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<StandardPostmarkResponse> retryInboundMessageProcessingWithHttpInfo(String xPostmarkServerToken, String messageid) throws ApiException {
        okhttp3.Call localVarCall = retryInboundMessageProcessingValidateBeforeCall(xPostmarkServerToken, messageid, null);
        Type localVarReturnType = new TypeToken<StandardPostmarkResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retry a failed inbound message for processing (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param messageid The ID of the inbound message on which we should retry processing. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call retryInboundMessageProcessingAsync(String xPostmarkServerToken, String messageid, final ApiCallback<StandardPostmarkResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = retryInboundMessageProcessingValidateBeforeCall(xPostmarkServerToken, messageid, _callback);
        Type localVarReturnType = new TypeToken<StandardPostmarkResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchClicksForOutboundMessages
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by To, Cc, Bcc (optional)
     * @param tag Filter by tag (optional)
     * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
     * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
     * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
     * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
     * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
     * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
     * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
     * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
     * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchClicksForOutboundMessagesCall(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/clicks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (recipient != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipient", recipient));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (clientName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_name", clientName));
        }

        if (clientCompany != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_company", clientCompany));
        }

        if (clientFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_family", clientFamily));
        }

        if (osName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_name", osName));
        }

        if (osFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_family", osFamily));
        }

        if (osCompany != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_company", osCompany));
        }

        if (platform != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("platform", platform));
        }

        if (country != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country", country));
        }

        if (region != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("region", region));
        }

        if (city != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("city", city));
        }

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchClicksForOutboundMessagesValidateBeforeCall(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling searchClicksForOutboundMessages(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling searchClicksForOutboundMessages(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling searchClicksForOutboundMessages(Async)");
        }

        return searchClicksForOutboundMessagesCall(xPostmarkServerToken, count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);

    }

    /**
     * Clicks for a all messages
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by To, Cc, Bcc (optional)
     * @param tag Filter by tag (optional)
     * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
     * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
     * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
     * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
     * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
     * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
     * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
     * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
     * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @return MessageClickSearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public MessageClickSearchResponse searchClicksForOutboundMessages(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city) throws ApiException {
        ApiResponse<MessageClickSearchResponse> localVarResp = searchClicksForOutboundMessagesWithHttpInfo(xPostmarkServerToken, count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city);
        return localVarResp.getData();
    }

    /**
     * Clicks for a all messages
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by To, Cc, Bcc (optional)
     * @param tag Filter by tag (optional)
     * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
     * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
     * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
     * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
     * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
     * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
     * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
     * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
     * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @return ApiResponse&lt;MessageClickSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MessageClickSearchResponse> searchClicksForOutboundMessagesWithHttpInfo(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city) throws ApiException {
        okhttp3.Call localVarCall = searchClicksForOutboundMessagesValidateBeforeCall(xPostmarkServerToken, count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, null);
        Type localVarReturnType = new TypeToken<MessageClickSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Clicks for a all messages (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of message clicks to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by To, Cc, Bcc (optional)
     * @param tag Filter by tag (optional)
     * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
     * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
     * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
     * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
     * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
     * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
     * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
     * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
     * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchClicksForOutboundMessagesAsync(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback<MessageClickSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchClicksForOutboundMessagesValidateBeforeCall(xPostmarkServerToken, count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);
        Type localVarReturnType = new TypeToken<MessageClickSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchInboundMessages
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by the user who was receiving the email (optional)
     * @param fromemail Filter by the sender email address (optional)
     * @param subject Filter by email subject (optional)
     * @param mailboxhash Filter by mailboxhash (optional)
     * @param tag Filter by tag (optional)
     * @param status Filter by status (&#x60;blocked&#x60;, &#x60;processed&#x60;, &#x60;queued&#x60;, &#x60;failed&#x60;, &#x60;scheduled&#x60;) (optional)
     * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchInboundMessagesCall(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String subject, String mailboxhash, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/inbound";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (recipient != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipient", recipient));
        }

        if (fromemail != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromemail", fromemail));
        }

        if (subject != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("subject", subject));
        }

        if (mailboxhash != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("mailboxhash", mailboxhash));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchInboundMessagesValidateBeforeCall(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String subject, String mailboxhash, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling searchInboundMessages(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling searchInboundMessages(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling searchInboundMessages(Async)");
        }

        return searchInboundMessagesCall(xPostmarkServerToken, count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate, _callback);

    }

    /**
     * Inbound message search
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by the user who was receiving the email (optional)
     * @param fromemail Filter by the sender email address (optional)
     * @param subject Filter by email subject (optional)
     * @param mailboxhash Filter by mailboxhash (optional)
     * @param tag Filter by tag (optional)
     * @param status Filter by status (&#x60;blocked&#x60;, &#x60;processed&#x60;, &#x60;queued&#x60;, &#x60;failed&#x60;, &#x60;scheduled&#x60;) (optional)
     * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @return InboundSearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public InboundSearchResponse searchInboundMessages(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String subject, String mailboxhash, String tag, String status, LocalDate todate, LocalDate fromdate) throws ApiException {
        ApiResponse<InboundSearchResponse> localVarResp = searchInboundMessagesWithHttpInfo(xPostmarkServerToken, count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate);
        return localVarResp.getData();
    }

    /**
     * Inbound message search
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by the user who was receiving the email (optional)
     * @param fromemail Filter by the sender email address (optional)
     * @param subject Filter by email subject (optional)
     * @param mailboxhash Filter by mailboxhash (optional)
     * @param tag Filter by tag (optional)
     * @param status Filter by status (&#x60;blocked&#x60;, &#x60;processed&#x60;, &#x60;queued&#x60;, &#x60;failed&#x60;, &#x60;scheduled&#x60;) (optional)
     * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @return ApiResponse&lt;InboundSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<InboundSearchResponse> searchInboundMessagesWithHttpInfo(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String subject, String mailboxhash, String tag, String status, LocalDate todate, LocalDate fromdate) throws ApiException {
        okhttp3.Call localVarCall = searchInboundMessagesValidateBeforeCall(xPostmarkServerToken, count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate, null);
        Type localVarReturnType = new TypeToken<InboundSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Inbound message search (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by the user who was receiving the email (optional)
     * @param fromemail Filter by the sender email address (optional)
     * @param subject Filter by email subject (optional)
     * @param mailboxhash Filter by mailboxhash (optional)
     * @param tag Filter by tag (optional)
     * @param status Filter by status (&#x60;blocked&#x60;, &#x60;processed&#x60;, &#x60;queued&#x60;, &#x60;failed&#x60;, &#x60;scheduled&#x60;) (optional)
     * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchInboundMessagesAsync(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String subject, String mailboxhash, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback<InboundSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchInboundMessagesValidateBeforeCall(xPostmarkServerToken, count, offset, recipient, fromemail, subject, mailboxhash, tag, status, todate, fromdate, _callback);
        Type localVarReturnType = new TypeToken<InboundSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchOpensForOutboundMessages
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by To, Cc, Bcc (optional)
     * @param tag Filter by tag (optional)
     * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
     * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
     * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
     * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
     * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
     * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
     * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
     * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
     * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchOpensForOutboundMessagesCall(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound/opens";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (recipient != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipient", recipient));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (clientName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_name", clientName));
        }

        if (clientCompany != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_company", clientCompany));
        }

        if (clientFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_family", clientFamily));
        }

        if (osName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_name", osName));
        }

        if (osFamily != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_family", osFamily));
        }

        if (osCompany != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("os_company", osCompany));
        }

        if (platform != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("platform", platform));
        }

        if (country != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country", country));
        }

        if (region != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("region", region));
        }

        if (city != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("city", city));
        }

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchOpensForOutboundMessagesValidateBeforeCall(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling searchOpensForOutboundMessages(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling searchOpensForOutboundMessages(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling searchOpensForOutboundMessages(Async)");
        }

        return searchOpensForOutboundMessagesCall(xPostmarkServerToken, count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);

    }

    /**
     * Opens for all messages
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by To, Cc, Bcc (optional)
     * @param tag Filter by tag (optional)
     * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
     * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
     * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
     * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
     * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
     * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
     * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
     * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
     * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @return MessageOpenSearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public MessageOpenSearchResponse searchOpensForOutboundMessages(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city) throws ApiException {
        ApiResponse<MessageOpenSearchResponse> localVarResp = searchOpensForOutboundMessagesWithHttpInfo(xPostmarkServerToken, count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city);
        return localVarResp.getData();
    }

    /**
     * Opens for all messages
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by To, Cc, Bcc (optional)
     * @param tag Filter by tag (optional)
     * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
     * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
     * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
     * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
     * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
     * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
     * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
     * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
     * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @return ApiResponse&lt;MessageOpenSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MessageOpenSearchResponse> searchOpensForOutboundMessagesWithHttpInfo(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city) throws ApiException {
        okhttp3.Call localVarCall = searchOpensForOutboundMessagesValidateBeforeCall(xPostmarkServerToken, count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, null);
        Type localVarReturnType = new TypeToken<MessageOpenSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Opens for all messages (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of message opens to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by To, Cc, Bcc (optional)
     * @param tag Filter by tag (optional)
     * @param clientName Filter by client name, i.e. Outlook, Gmail (optional)
     * @param clientCompany Filter by company, i.e. Microsoft, Apple, Google (optional)
     * @param clientFamily Filter by client family, i.e. OS X, Chrome (optional)
     * @param osName Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7 (optional)
     * @param osFamily Filter by kind of OS used without specific version, i.e. OS X, Windows (optional)
     * @param osCompany Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation (optional)
     * @param platform Filter by platform, i.e. webmail, desktop, mobile (optional)
     * @param country Filter by country messages were opened in, i.e. Denmark, Russia (optional)
     * @param region Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param city Filter by full name of region messages were opened in, i.e. Moscow, New York (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchOpensForOutboundMessagesAsync(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String tag, String clientName, String clientCompany, String clientFamily, String osName, String osFamily, String osCompany, String platform, String country, String region, String city, final ApiCallback<MessageOpenSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchOpensForOutboundMessagesValidateBeforeCall(xPostmarkServerToken, count, offset, recipient, tag, clientName, clientCompany, clientFamily, osName, osFamily, osCompany, platform, country, region, city, _callback);
        Type localVarReturnType = new TypeToken<MessageOpenSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchOutboundMessages
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by the user who was receiving the email (optional)
     * @param fromemail Filter by the sender email address (optional)
     * @param tag Filter by tag (optional)
     * @param status Filter by status (&#x60;queued&#x60; or &#x60;sent&#x60;) (optional)
     * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchOutboundMessagesCall(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/outbound";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (count != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("count", count));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (recipient != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recipient", recipient));
        }

        if (fromemail != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromemail", fromemail));
        }

        if (tag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tag", tag));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (xPostmarkServerToken != null) {
            localVarHeaderParams.put("X-Postmark-Server-Token", localVarApiClient.parameterToString(xPostmarkServerToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchOutboundMessagesValidateBeforeCall(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPostmarkServerToken' is set
        if (xPostmarkServerToken == null) {
            throw new ApiException("Missing the required parameter 'xPostmarkServerToken' when calling searchOutboundMessages(Async)");
        }

        // verify the required parameter 'count' is set
        if (count == null) {
            throw new ApiException("Missing the required parameter 'count' when calling searchOutboundMessages(Async)");
        }

        // verify the required parameter 'offset' is set
        if (offset == null) {
            throw new ApiException("Missing the required parameter 'offset' when calling searchOutboundMessages(Async)");
        }

        return searchOutboundMessagesCall(xPostmarkServerToken, count, offset, recipient, fromemail, tag, status, todate, fromdate, _callback);

    }

    /**
     * Outbound message search
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by the user who was receiving the email (optional)
     * @param fromemail Filter by the sender email address (optional)
     * @param tag Filter by tag (optional)
     * @param status Filter by status (&#x60;queued&#x60; or &#x60;sent&#x60;) (optional)
     * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @return OutboundSearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public OutboundSearchResponse searchOutboundMessages(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String tag, String status, LocalDate todate, LocalDate fromdate) throws ApiException {
        ApiResponse<OutboundSearchResponse> localVarResp = searchOutboundMessagesWithHttpInfo(xPostmarkServerToken, count, offset, recipient, fromemail, tag, status, todate, fromdate);
        return localVarResp.getData();
    }

    /**
     * Outbound message search
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by the user who was receiving the email (optional)
     * @param fromemail Filter by the sender email address (optional)
     * @param tag Filter by tag (optional)
     * @param status Filter by status (&#x60;queued&#x60; or &#x60;sent&#x60;) (optional)
     * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @return ApiResponse&lt;OutboundSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<OutboundSearchResponse> searchOutboundMessagesWithHttpInfo(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String tag, String status, LocalDate todate, LocalDate fromdate) throws ApiException {
        okhttp3.Call localVarCall = searchOutboundMessagesValidateBeforeCall(xPostmarkServerToken, count, offset, recipient, fromemail, tag, status, todate, fromdate, null);
        Type localVarReturnType = new TypeToken<OutboundSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Outbound message search (asynchronously)
     * 
     * @param xPostmarkServerToken The token associated with the Server on which this request will operate. (required)
     * @param count Number of messages to return per request. Max 500. (required)
     * @param offset Number of messages to skip (required)
     * @param recipient Filter by the user who was receiving the email (optional)
     * @param fromemail Filter by the sender email address (optional)
     * @param tag Filter by tag (optional)
     * @param status Filter by status (&#x60;queued&#x60; or &#x60;sent&#x60;) (optional)
     * @param todate Filter messages up to the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param fromdate Filter messages starting from the date specified. e.g. &#x60;2014-02-01&#x60; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> An error was generated due to incorrect use of the API. See the Message associated with this response for more information. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Indicates an internal server error occurred. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call searchOutboundMessagesAsync(String xPostmarkServerToken, Integer count, Integer offset, String recipient, String fromemail, String tag, String status, LocalDate todate, LocalDate fromdate, final ApiCallback<OutboundSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchOutboundMessagesValidateBeforeCall(xPostmarkServerToken, count, offset, recipient, fromemail, tag, status, todate, fromdate, _callback);
        Type localVarReturnType = new TypeToken<OutboundSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
