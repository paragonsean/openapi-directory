/*
 * Turbine Labs API
 * The Turbine Labs API provides CRUD operations for core object types, and is mostly RESTy. The easiest way to interact with the API is with [tbnctl](https://docs.turbinelabs.io/advanced/tbnctl.html). If you want to make direct HTTP calls, however, you can obtain an access token using tbnctl, and then pass it in the Authorization header, prefixed by `Token `: ```console curl -H \"Authorization: Token <access token>\" https://api.turbinelabs.io/v1.0/cluster ``` 
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A form of passive health checking that dynamically determines whether instances in a cluster are performing unlike others and preemptively removes them from a load balancing set. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:56:51.953320-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class OutlierDetection {
  public static final String SERIALIZED_NAME_BASE_EJECTION_TIME_MSEC = "base_ejection_time_msec";
  @SerializedName(SERIALIZED_NAME_BASE_EJECTION_TIME_MSEC)
  private Integer baseEjectionTimeMsec;

  public static final String SERIALIZED_NAME_CONSECUTIVE5XX = "consecutive_5xx";
  @SerializedName(SERIALIZED_NAME_CONSECUTIVE5XX)
  private Integer consecutive5xx;

  public static final String SERIALIZED_NAME_CONSECUTIVE_GATEWAY_FAILURE = "consecutive_gateway_failure";
  @SerializedName(SERIALIZED_NAME_CONSECUTIVE_GATEWAY_FAILURE)
  private Integer consecutiveGatewayFailure;

  public static final String SERIALIZED_NAME_ENFORCING_CONSECUTIVE5XX = "enforcing_consecutive_5xx";
  @SerializedName(SERIALIZED_NAME_ENFORCING_CONSECUTIVE5XX)
  private Integer enforcingConsecutive5xx;

  public static final String SERIALIZED_NAME_ENFORCING_CONSECUTIVE_GATEWAY_FAILURE = "enforcing_consecutive_gateway_failure";
  @SerializedName(SERIALIZED_NAME_ENFORCING_CONSECUTIVE_GATEWAY_FAILURE)
  private Integer enforcingConsecutiveGatewayFailure;

  public static final String SERIALIZED_NAME_ENFORCING_SUCCESS_RATE = "enforcing_success_rate";
  @SerializedName(SERIALIZED_NAME_ENFORCING_SUCCESS_RATE)
  private Integer enforcingSuccessRate;

  public static final String SERIALIZED_NAME_INTERVAL_MSEC = "interval_msec";
  @SerializedName(SERIALIZED_NAME_INTERVAL_MSEC)
  private Integer intervalMsec;

  public static final String SERIALIZED_NAME_MAX_EJECTION_PERCENT = "max_ejection_percent";
  @SerializedName(SERIALIZED_NAME_MAX_EJECTION_PERCENT)
  private Integer maxEjectionPercent;

  public static final String SERIALIZED_NAME_SUCCESS_RATE_MINIMUM_HOSTS = "success_rate_minimum_hosts";
  @SerializedName(SERIALIZED_NAME_SUCCESS_RATE_MINIMUM_HOSTS)
  private Integer successRateMinimumHosts;

  public static final String SERIALIZED_NAME_SUCCESS_RATE_REQUEST_VOLUME = "success_rate_request_volume";
  @SerializedName(SERIALIZED_NAME_SUCCESS_RATE_REQUEST_VOLUME)
  private Integer successRateRequestVolume;

  public static final String SERIALIZED_NAME_SUCCESS_RATE_STDEV_FACTOR = "success_rate_stdev_factor";
  @SerializedName(SERIALIZED_NAME_SUCCESS_RATE_STDEV_FACTOR)
  private Integer successRateStdevFactor;

  public OutlierDetection() {
  }

  public OutlierDetection baseEjectionTimeMsec(Integer baseEjectionTimeMsec) {
    this.baseEjectionTimeMsec = baseEjectionTimeMsec;
    return this;
  }

  /**
   * The base time that a host is ejected for. The real time is equal to the base time multiplied by the number of times the host has been ejected. Defaults to 30s. Setting this to 0 means that no host will be ejected for longer than &#x60;interval_msec&#x60;. 
   * @return baseEjectionTimeMsec
   */
  @javax.annotation.Nullable
  public Integer getBaseEjectionTimeMsec() {
    return baseEjectionTimeMsec;
  }

  public void setBaseEjectionTimeMsec(Integer baseEjectionTimeMsec) {
    this.baseEjectionTimeMsec = baseEjectionTimeMsec;
  }


  public OutlierDetection consecutive5xx(Integer consecutive5xx) {
    this.consecutive5xx = consecutive5xx;
    return this;
  }

  /**
   * The number of consecutive 5xx responses before a consecutive 5xx ejection occurs. Defaults to 5. Setting this to 0 effectively turns off the consecutive 5xx detector. 
   * @return consecutive5xx
   */
  @javax.annotation.Nullable
  public Integer getConsecutive5xx() {
    return consecutive5xx;
  }

  public void setConsecutive5xx(Integer consecutive5xx) {
    this.consecutive5xx = consecutive5xx;
  }


  public OutlierDetection consecutiveGatewayFailure(Integer consecutiveGatewayFailure) {
    this.consecutiveGatewayFailure = consecutiveGatewayFailure;
    return this;
  }

  /**
   * The number of consecutive gateway failures (502, 503, 504 status or connection errors that are mapped to one of those status codes) before a consecutive gateway failure ejection occurs. Defaults to 5. Setting this to 0 effectively turns off the consecutive gateway failure detector. 
   * @return consecutiveGatewayFailure
   */
  @javax.annotation.Nullable
  public Integer getConsecutiveGatewayFailure() {
    return consecutiveGatewayFailure;
  }

  public void setConsecutiveGatewayFailure(Integer consecutiveGatewayFailure) {
    this.consecutiveGatewayFailure = consecutiveGatewayFailure;
  }


  public OutlierDetection enforcingConsecutive5xx(Integer enforcingConsecutive5xx) {
    this.enforcingConsecutive5xx = enforcingConsecutive5xx;
    return this;
  }

  /**
   * The % chance that a host will be actually ejected when an outlier status is detected through consecutive 5xx. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100. 
   * @return enforcingConsecutive5xx
   */
  @javax.annotation.Nullable
  public Integer getEnforcingConsecutive5xx() {
    return enforcingConsecutive5xx;
  }

  public void setEnforcingConsecutive5xx(Integer enforcingConsecutive5xx) {
    this.enforcingConsecutive5xx = enforcingConsecutive5xx;
  }


  public OutlierDetection enforcingConsecutiveGatewayFailure(Integer enforcingConsecutiveGatewayFailure) {
    this.enforcingConsecutiveGatewayFailure = enforcingConsecutiveGatewayFailure;
    return this;
  }

  /**
   * The % chance that a host will be actually ejected when an outlier status is detected through consecutive gateway failures. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 0. 
   * @return enforcingConsecutiveGatewayFailure
   */
  @javax.annotation.Nullable
  public Integer getEnforcingConsecutiveGatewayFailure() {
    return enforcingConsecutiveGatewayFailure;
  }

  public void setEnforcingConsecutiveGatewayFailure(Integer enforcingConsecutiveGatewayFailure) {
    this.enforcingConsecutiveGatewayFailure = enforcingConsecutiveGatewayFailure;
  }


  public OutlierDetection enforcingSuccessRate(Integer enforcingSuccessRate) {
    this.enforcingSuccessRate = enforcingSuccessRate;
    return this;
  }

  /**
   * The % chance that a host will be actually ejected when an outlier status is detected through success rate statistics. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100. 
   * @return enforcingSuccessRate
   */
  @javax.annotation.Nullable
  public Integer getEnforcingSuccessRate() {
    return enforcingSuccessRate;
  }

  public void setEnforcingSuccessRate(Integer enforcingSuccessRate) {
    this.enforcingSuccessRate = enforcingSuccessRate;
  }


  public OutlierDetection intervalMsec(Integer intervalMsec) {
    this.intervalMsec = intervalMsec;
    return this;
  }

  /**
   * The time interval between ejection analysis sweeps. This can result in both new ejections due to success rate outlier detection as well as hosts being returned to service. Defaults to 10s and must be greater than 0. 
   * @return intervalMsec
   */
  @javax.annotation.Nullable
  public Integer getIntervalMsec() {
    return intervalMsec;
  }

  public void setIntervalMsec(Integer intervalMsec) {
    this.intervalMsec = intervalMsec;
  }


  public OutlierDetection maxEjectionPercent(Integer maxEjectionPercent) {
    this.maxEjectionPercent = maxEjectionPercent;
    return this;
  }

  /**
   * The maximum % of an upstream cluster that can be ejected due to outlier detection. Defaults to 10% but will always eject at least one host. 
   * @return maxEjectionPercent
   */
  @javax.annotation.Nullable
  public Integer getMaxEjectionPercent() {
    return maxEjectionPercent;
  }

  public void setMaxEjectionPercent(Integer maxEjectionPercent) {
    this.maxEjectionPercent = maxEjectionPercent;
  }


  public OutlierDetection successRateMinimumHosts(Integer successRateMinimumHosts) {
    this.successRateMinimumHosts = successRateMinimumHosts;
    return this;
  }

  /**
   * The number of hosts in a cluster that must have enough request volume to detect success rate outliers. If the number of hosts is less than this setting, outlier detection via success rate statistics is not performed for any host in the cluster. Defaults to 5. Setting this to 0 effectively triggers the success rate detector regardless of the number of valid hosts during an interval (as determined by &#x60;success_rate_request_volume&#x60;). 
   * @return successRateMinimumHosts
   */
  @javax.annotation.Nullable
  public Integer getSuccessRateMinimumHosts() {
    return successRateMinimumHosts;
  }

  public void setSuccessRateMinimumHosts(Integer successRateMinimumHosts) {
    this.successRateMinimumHosts = successRateMinimumHosts;
  }


  public OutlierDetection successRateRequestVolume(Integer successRateRequestVolume) {
    this.successRateRequestVolume = successRateRequestVolume;
    return this;
  }

  /**
   * The minimum number of total requests that must be collected in one interval (as defined by interval_msec) to include this host in success rate based outlier detection. If the volume is lower than this setting, outlier detection via success rate statistics is not performed for that host. Defaults to 100. Must be greater than 0. 
   * @return successRateRequestVolume
   */
  @javax.annotation.Nullable
  public Integer getSuccessRateRequestVolume() {
    return successRateRequestVolume;
  }

  public void setSuccessRateRequestVolume(Integer successRateRequestVolume) {
    this.successRateRequestVolume = successRateRequestVolume;
  }


  public OutlierDetection successRateStdevFactor(Integer successRateStdevFactor) {
    this.successRateStdevFactor = successRateStdevFactor;
    return this;
  }

  /**
   * This factor is used to determine the ejection threshold for success rate outlier ejection. The ejection threshold is the difference between the mean success rate, and the product of this factor and the standard deviation of the mean success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided by a thousand to get a double. That is, if the desired factor is 1.9, the runtime value should be 1900. Defaults to 1900. Setting this to 0 effectively turns off the success rate detector. 
   * @return successRateStdevFactor
   */
  @javax.annotation.Nullable
  public Integer getSuccessRateStdevFactor() {
    return successRateStdevFactor;
  }

  public void setSuccessRateStdevFactor(Integer successRateStdevFactor) {
    this.successRateStdevFactor = successRateStdevFactor;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OutlierDetection outlierDetection = (OutlierDetection) o;
    return Objects.equals(this.baseEjectionTimeMsec, outlierDetection.baseEjectionTimeMsec) &&
        Objects.equals(this.consecutive5xx, outlierDetection.consecutive5xx) &&
        Objects.equals(this.consecutiveGatewayFailure, outlierDetection.consecutiveGatewayFailure) &&
        Objects.equals(this.enforcingConsecutive5xx, outlierDetection.enforcingConsecutive5xx) &&
        Objects.equals(this.enforcingConsecutiveGatewayFailure, outlierDetection.enforcingConsecutiveGatewayFailure) &&
        Objects.equals(this.enforcingSuccessRate, outlierDetection.enforcingSuccessRate) &&
        Objects.equals(this.intervalMsec, outlierDetection.intervalMsec) &&
        Objects.equals(this.maxEjectionPercent, outlierDetection.maxEjectionPercent) &&
        Objects.equals(this.successRateMinimumHosts, outlierDetection.successRateMinimumHosts) &&
        Objects.equals(this.successRateRequestVolume, outlierDetection.successRateRequestVolume) &&
        Objects.equals(this.successRateStdevFactor, outlierDetection.successRateStdevFactor);
  }

  @Override
  public int hashCode() {
    return Objects.hash(baseEjectionTimeMsec, consecutive5xx, consecutiveGatewayFailure, enforcingConsecutive5xx, enforcingConsecutiveGatewayFailure, enforcingSuccessRate, intervalMsec, maxEjectionPercent, successRateMinimumHosts, successRateRequestVolume, successRateStdevFactor);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OutlierDetection {\n");
    sb.append("    baseEjectionTimeMsec: ").append(toIndentedString(baseEjectionTimeMsec)).append("\n");
    sb.append("    consecutive5xx: ").append(toIndentedString(consecutive5xx)).append("\n");
    sb.append("    consecutiveGatewayFailure: ").append(toIndentedString(consecutiveGatewayFailure)).append("\n");
    sb.append("    enforcingConsecutive5xx: ").append(toIndentedString(enforcingConsecutive5xx)).append("\n");
    sb.append("    enforcingConsecutiveGatewayFailure: ").append(toIndentedString(enforcingConsecutiveGatewayFailure)).append("\n");
    sb.append("    enforcingSuccessRate: ").append(toIndentedString(enforcingSuccessRate)).append("\n");
    sb.append("    intervalMsec: ").append(toIndentedString(intervalMsec)).append("\n");
    sb.append("    maxEjectionPercent: ").append(toIndentedString(maxEjectionPercent)).append("\n");
    sb.append("    successRateMinimumHosts: ").append(toIndentedString(successRateMinimumHosts)).append("\n");
    sb.append("    successRateRequestVolume: ").append(toIndentedString(successRateRequestVolume)).append("\n");
    sb.append("    successRateStdevFactor: ").append(toIndentedString(successRateStdevFactor)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("base_ejection_time_msec");
    openapiFields.add("consecutive_5xx");
    openapiFields.add("consecutive_gateway_failure");
    openapiFields.add("enforcing_consecutive_5xx");
    openapiFields.add("enforcing_consecutive_gateway_failure");
    openapiFields.add("enforcing_success_rate");
    openapiFields.add("interval_msec");
    openapiFields.add("max_ejection_percent");
    openapiFields.add("success_rate_minimum_hosts");
    openapiFields.add("success_rate_request_volume");
    openapiFields.add("success_rate_stdev_factor");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to OutlierDetection
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!OutlierDetection.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in OutlierDetection is not found in the empty JSON string", OutlierDetection.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!OutlierDetection.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `OutlierDetection` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!OutlierDetection.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'OutlierDetection' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<OutlierDetection> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(OutlierDetection.class));

       return (TypeAdapter<T>) new TypeAdapter<OutlierDetection>() {
           @Override
           public void write(JsonWriter out, OutlierDetection value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public OutlierDetection read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of OutlierDetection given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of OutlierDetection
   * @throws IOException if the JSON string is invalid with respect to OutlierDetection
   */
  public static OutlierDetection fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OutlierDetection.class);
  }

  /**
   * Convert an instance of OutlierDetection to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

