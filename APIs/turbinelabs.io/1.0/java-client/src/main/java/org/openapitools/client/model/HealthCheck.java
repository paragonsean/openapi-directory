/*
 * Turbine Labs API
 * The Turbine Labs API provides CRUD operations for core object types, and is mostly RESTy. The easiest way to interact with the API is with [tbnctl](https://docs.turbinelabs.io/advanced/tbnctl.html). If you want to make direct HTTP calls, however, you can obtain an access token using tbnctl, and then pass it in the Authorization header, prefixed by `Token `: ```console curl -H \"Authorization: Token <access token>\" https://api.turbinelabs.io/v1.0/cluster ``` 
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.HealthCheckHealthChecker;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configures active health checking for every instance in a cluster. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T09:56:51.953320-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class HealthCheck {
  public static final String SERIALIZED_NAME_HEALTH_CHECKER = "health_checker";
  @SerializedName(SERIALIZED_NAME_HEALTH_CHECKER)
  private HealthCheckHealthChecker healthChecker;

  public static final String SERIALIZED_NAME_HEALTHY_EDGE_INTERVAL_MSEC = "healthy_edge_interval_msec";
  @SerializedName(SERIALIZED_NAME_HEALTHY_EDGE_INTERVAL_MSEC)
  private Integer healthyEdgeIntervalMsec;

  public static final String SERIALIZED_NAME_HEALTHY_THRESHOLD = "healthy_threshold";
  @SerializedName(SERIALIZED_NAME_HEALTHY_THRESHOLD)
  private Integer healthyThreshold;

  public static final String SERIALIZED_NAME_INTERVAL_JITTER_MSEC = "interval_jitter_msec";
  @SerializedName(SERIALIZED_NAME_INTERVAL_JITTER_MSEC)
  private Integer intervalJitterMsec;

  public static final String SERIALIZED_NAME_INTERVAL_MSEC = "interval_msec";
  @SerializedName(SERIALIZED_NAME_INTERVAL_MSEC)
  private Integer intervalMsec;

  public static final String SERIALIZED_NAME_NO_TRAFFIC_INTERVAL_MSEC = "no_traffic_interval_msec";
  @SerializedName(SERIALIZED_NAME_NO_TRAFFIC_INTERVAL_MSEC)
  private Integer noTrafficIntervalMsec;

  public static final String SERIALIZED_NAME_REUSE_CONNECTION = "reuse_connection";
  @SerializedName(SERIALIZED_NAME_REUSE_CONNECTION)
  private Boolean reuseConnection;

  public static final String SERIALIZED_NAME_TIMEOUT_MSEC = "timeout_msec";
  @SerializedName(SERIALIZED_NAME_TIMEOUT_MSEC)
  private Integer timeoutMsec;

  public static final String SERIALIZED_NAME_UNHEALTHY_EDGE_INTERVAL_MSEC = "unhealthy_edge_interval_msec";
  @SerializedName(SERIALIZED_NAME_UNHEALTHY_EDGE_INTERVAL_MSEC)
  private Integer unhealthyEdgeIntervalMsec;

  public static final String SERIALIZED_NAME_UNHEALTHY_INTERVAL_MSEC = "unhealthy_interval_msec";
  @SerializedName(SERIALIZED_NAME_UNHEALTHY_INTERVAL_MSEC)
  private Integer unhealthyIntervalMsec;

  public static final String SERIALIZED_NAME_UNHEALTHY_THRESHOLD = "unhealthy_threshold";
  @SerializedName(SERIALIZED_NAME_UNHEALTHY_THRESHOLD)
  private Integer unhealthyThreshold;

  public HealthCheck() {
  }

  public HealthCheck healthChecker(HealthCheckHealthChecker healthChecker) {
    this.healthChecker = healthChecker;
    return this;
  }

  /**
   * Get healthChecker
   * @return healthChecker
   */
  @javax.annotation.Nonnull
  public HealthCheckHealthChecker getHealthChecker() {
    return healthChecker;
  }

  public void setHealthChecker(HealthCheckHealthChecker healthChecker) {
    this.healthChecker = healthChecker;
  }


  public HealthCheck healthyEdgeIntervalMsec(Integer healthyEdgeIntervalMsec) {
    this.healthyEdgeIntervalMsec = healthyEdgeIntervalMsec;
    return this;
  }

  /**
   * Interval used for the first health check right after a host is marked as healthy. For subsequent health checks, the proxy will shift back to using the standard health check interval(\\&#39;interval_msec\\&#39;) that is defined. Defaults to the same value as \\&#39;interval_msec\\&#39; if not specified. 
   * @return healthyEdgeIntervalMsec
   */
  @javax.annotation.Nullable
  public Integer getHealthyEdgeIntervalMsec() {
    return healthyEdgeIntervalMsec;
  }

  public void setHealthyEdgeIntervalMsec(Integer healthyEdgeIntervalMsec) {
    this.healthyEdgeIntervalMsec = healthyEdgeIntervalMsec;
  }


  public HealthCheck healthyThreshold(Integer healthyThreshold) {
    this.healthyThreshold = healthyThreshold;
    return this;
  }

  /**
   * The number of healthy health checks required before a host is marked healthy. Note that during startup, only a single successful health check is required to mark a host healthy. 
   * @return healthyThreshold
   */
  @javax.annotation.Nonnull
  public Integer getHealthyThreshold() {
    return healthyThreshold;
  }

  public void setHealthyThreshold(Integer healthyThreshold) {
    this.healthyThreshold = healthyThreshold;
  }


  public HealthCheck intervalJitterMsec(Integer intervalJitterMsec) {
    this.intervalJitterMsec = intervalJitterMsec;
    return this;
  }

  /**
   * An optional jitter amount that is added to each interval value calculated by the proxy. If not specified, defaults to 0. 
   * @return intervalJitterMsec
   */
  @javax.annotation.Nullable
  public Integer getIntervalJitterMsec() {
    return intervalJitterMsec;
  }

  public void setIntervalJitterMsec(Integer intervalJitterMsec) {
    this.intervalJitterMsec = intervalJitterMsec;
  }


  public HealthCheck intervalMsec(Integer intervalMsec) {
    this.intervalMsec = intervalMsec;
    return this;
  }

  /**
   * The interval between health checks. The first round of health checks will occur during startup before any traffic is routed to a cluster. This means that the \\&#39;no_traffic_interval_msec\\&#39; value will be used as the first interval of health checks. 
   * @return intervalMsec
   */
  @javax.annotation.Nonnull
  public Integer getIntervalMsec() {
    return intervalMsec;
  }

  public void setIntervalMsec(Integer intervalMsec) {
    this.intervalMsec = intervalMsec;
  }


  public HealthCheck noTrafficIntervalMsec(Integer noTrafficIntervalMsec) {
    this.noTrafficIntervalMsec = noTrafficIntervalMsec;
    return this;
  }

  /**
   * Interval used when a cluster has never had traffic routed to it. It allows cluster information to be kept up to date, without sending a potentially large amount of active health checking traffic for no reason. Once a cluster has been used for traffic routing, The proxy will shift back to using the standard health check interval that is defined. Note that this interval takes precedence over any other. Defaults to 60s. 
   * @return noTrafficIntervalMsec
   */
  @javax.annotation.Nullable
  public Integer getNoTrafficIntervalMsec() {
    return noTrafficIntervalMsec;
  }

  public void setNoTrafficIntervalMsec(Integer noTrafficIntervalMsec) {
    this.noTrafficIntervalMsec = noTrafficIntervalMsec;
  }


  public HealthCheck reuseConnection(Boolean reuseConnection) {
    this.reuseConnection = reuseConnection;
    return this;
  }

  /**
   * Whether or not to reuse health check connections between health checks. Default is true. 
   * @return reuseConnection
   */
  @javax.annotation.Nullable
  public Boolean getReuseConnection() {
    return reuseConnection;
  }

  public void setReuseConnection(Boolean reuseConnection) {
    this.reuseConnection = reuseConnection;
  }


  public HealthCheck timeoutMsec(Integer timeoutMsec) {
    this.timeoutMsec = timeoutMsec;
    return this;
  }

  /**
   * The time to wait for a health check response. If the timeout is reached without a response, the health check attempt will be considered a failure. This is a required field and must be greater than 0. 
   * @return timeoutMsec
   */
  @javax.annotation.Nonnull
  public Integer getTimeoutMsec() {
    return timeoutMsec;
  }

  public void setTimeoutMsec(Integer timeoutMsec) {
    this.timeoutMsec = timeoutMsec;
  }


  public HealthCheck unhealthyEdgeIntervalMsec(Integer unhealthyEdgeIntervalMsec) {
    this.unhealthyEdgeIntervalMsec = unhealthyEdgeIntervalMsec;
    return this;
  }

  /**
   * Interval used for the first health check right after a host is marked as unhealthy. For subsequent health checks, the proxy will shift back to using either \\&#39;unhealthy_interval_msec\\&#39; if present or the standard health check interval, \\&#39;interval_msec\\&#39;. 
   * @return unhealthyEdgeIntervalMsec
   */
  @javax.annotation.Nullable
  public Integer getUnhealthyEdgeIntervalMsec() {
    return unhealthyEdgeIntervalMsec;
  }

  public void setUnhealthyEdgeIntervalMsec(Integer unhealthyEdgeIntervalMsec) {
    this.unhealthyEdgeIntervalMsec = unhealthyEdgeIntervalMsec;
  }


  public HealthCheck unhealthyIntervalMsec(Integer unhealthyIntervalMsec) {
    this.unhealthyIntervalMsec = unhealthyIntervalMsec;
    return this;
  }

  /**
   * Interval used for hosts that are marked as unhealthy. As soon as the host is marked as healthy, The proxy will shift back to using the standard health check interval that is defined. This defaults to the same value as \\&#39;interval_msec\\&#39; if not specified. 
   * @return unhealthyIntervalMsec
   */
  @javax.annotation.Nullable
  public Integer getUnhealthyIntervalMsec() {
    return unhealthyIntervalMsec;
  }

  public void setUnhealthyIntervalMsec(Integer unhealthyIntervalMsec) {
    this.unhealthyIntervalMsec = unhealthyIntervalMsec;
  }


  public HealthCheck unhealthyThreshold(Integer unhealthyThreshold) {
    this.unhealthyThreshold = unhealthyThreshold;
    return this;
  }

  /**
   * The number of unhealthy health checks required before a host is marked unhealthy. Note that for *http* health checking, if a host responds with 503, this threshold is ignored and the host is considered unhealthy immediately. 
   * @return unhealthyThreshold
   */
  @javax.annotation.Nonnull
  public Integer getUnhealthyThreshold() {
    return unhealthyThreshold;
  }

  public void setUnhealthyThreshold(Integer unhealthyThreshold) {
    this.unhealthyThreshold = unhealthyThreshold;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HealthCheck healthCheck = (HealthCheck) o;
    return Objects.equals(this.healthChecker, healthCheck.healthChecker) &&
        Objects.equals(this.healthyEdgeIntervalMsec, healthCheck.healthyEdgeIntervalMsec) &&
        Objects.equals(this.healthyThreshold, healthCheck.healthyThreshold) &&
        Objects.equals(this.intervalJitterMsec, healthCheck.intervalJitterMsec) &&
        Objects.equals(this.intervalMsec, healthCheck.intervalMsec) &&
        Objects.equals(this.noTrafficIntervalMsec, healthCheck.noTrafficIntervalMsec) &&
        Objects.equals(this.reuseConnection, healthCheck.reuseConnection) &&
        Objects.equals(this.timeoutMsec, healthCheck.timeoutMsec) &&
        Objects.equals(this.unhealthyEdgeIntervalMsec, healthCheck.unhealthyEdgeIntervalMsec) &&
        Objects.equals(this.unhealthyIntervalMsec, healthCheck.unhealthyIntervalMsec) &&
        Objects.equals(this.unhealthyThreshold, healthCheck.unhealthyThreshold);
  }

  @Override
  public int hashCode() {
    return Objects.hash(healthChecker, healthyEdgeIntervalMsec, healthyThreshold, intervalJitterMsec, intervalMsec, noTrafficIntervalMsec, reuseConnection, timeoutMsec, unhealthyEdgeIntervalMsec, unhealthyIntervalMsec, unhealthyThreshold);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HealthCheck {\n");
    sb.append("    healthChecker: ").append(toIndentedString(healthChecker)).append("\n");
    sb.append("    healthyEdgeIntervalMsec: ").append(toIndentedString(healthyEdgeIntervalMsec)).append("\n");
    sb.append("    healthyThreshold: ").append(toIndentedString(healthyThreshold)).append("\n");
    sb.append("    intervalJitterMsec: ").append(toIndentedString(intervalJitterMsec)).append("\n");
    sb.append("    intervalMsec: ").append(toIndentedString(intervalMsec)).append("\n");
    sb.append("    noTrafficIntervalMsec: ").append(toIndentedString(noTrafficIntervalMsec)).append("\n");
    sb.append("    reuseConnection: ").append(toIndentedString(reuseConnection)).append("\n");
    sb.append("    timeoutMsec: ").append(toIndentedString(timeoutMsec)).append("\n");
    sb.append("    unhealthyEdgeIntervalMsec: ").append(toIndentedString(unhealthyEdgeIntervalMsec)).append("\n");
    sb.append("    unhealthyIntervalMsec: ").append(toIndentedString(unhealthyIntervalMsec)).append("\n");
    sb.append("    unhealthyThreshold: ").append(toIndentedString(unhealthyThreshold)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("health_checker");
    openapiFields.add("healthy_edge_interval_msec");
    openapiFields.add("healthy_threshold");
    openapiFields.add("interval_jitter_msec");
    openapiFields.add("interval_msec");
    openapiFields.add("no_traffic_interval_msec");
    openapiFields.add("reuse_connection");
    openapiFields.add("timeout_msec");
    openapiFields.add("unhealthy_edge_interval_msec");
    openapiFields.add("unhealthy_interval_msec");
    openapiFields.add("unhealthy_threshold");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("health_checker");
    openapiRequiredFields.add("healthy_threshold");
    openapiRequiredFields.add("interval_msec");
    openapiRequiredFields.add("timeout_msec");
    openapiRequiredFields.add("unhealthy_threshold");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to HealthCheck
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!HealthCheck.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in HealthCheck is not found in the empty JSON string", HealthCheck.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!HealthCheck.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `HealthCheck` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : HealthCheck.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `health_checker`
      HealthCheckHealthChecker.validateJsonElement(jsonObj.get("health_checker"));
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!HealthCheck.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'HealthCheck' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<HealthCheck> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(HealthCheck.class));

       return (TypeAdapter<T>) new TypeAdapter<HealthCheck>() {
           @Override
           public void write(JsonWriter out, HealthCheck value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public HealthCheck read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of HealthCheck given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of HealthCheck
   * @throws IOException if the JSON string is invalid with respect to HealthCheck
   */
  public static HealthCheck fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, HealthCheck.class);
  }

  /**
   * Convert an instance of HealthCheck to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

