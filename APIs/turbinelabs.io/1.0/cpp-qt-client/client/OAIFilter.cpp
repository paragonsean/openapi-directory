/**
 * Turbine Labs API
 * The Turbine Labs API provides CRUD operations for core object types, and is mostly RESTy. The easiest way to interact with the API is with [tbnctl](https://docs.turbinelabs.io/advanced/tbnctl.html). If you want to make direct HTTP calls, however, you can obtain an access token using tbnctl, and then pass it in the Authorization header, prefixed by `Token `: ```console curl -H \"Authorization: Token <access token>\" https://api.turbinelabs.io/v1.0/cluster ``` 
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIFilter.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIFilter::OAIFilter(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIFilter::OAIFilter() {
    this->initializeModel();
}

OAIFilter::~OAIFilter() {}

void OAIFilter::initializeModel() {

    m_absolute_match_only_isSet = false;
    m_absolute_match_only_isValid = false;

    m_actor_key_isSet = false;
    m_actor_key_isValid = false;

    m_attribute_path_isSet = false;
    m_attribute_path_isValid = false;

    m_attribute_value_isSet = false;
    m_attribute_value_isValid = false;

    m_change_txn_isSet = false;
    m_change_txn_isValid = false;

    m_change_type_isSet = false;
    m_change_type_isValid = false;

    m_exclude_empty_values_isSet = false;
    m_exclude_empty_values_isValid = false;

    m_negative_match_isSet = false;
    m_negative_match_isValid = false;

    m_object_key_isSet = false;
    m_object_key_isValid = false;

    m_object_type_isSet = false;
    m_object_type_isValid = false;

    m_org_key_isSet = false;
    m_org_key_isValid = false;

    m_time_range_isSet = false;
    m_time_range_isValid = false;

    m_zone_key_isSet = false;
    m_zone_key_isValid = false;
}

void OAIFilter::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIFilter::fromJsonObject(QJsonObject json) {

    m_absolute_match_only_isValid = ::OpenAPI::fromJsonValue(m_absolute_match_only, json[QString("absolute_match_only")]);
    m_absolute_match_only_isSet = !json[QString("absolute_match_only")].isNull() && m_absolute_match_only_isValid;

    m_actor_key_isValid = ::OpenAPI::fromJsonValue(m_actor_key, json[QString("actor_key")]);
    m_actor_key_isSet = !json[QString("actor_key")].isNull() && m_actor_key_isValid;

    m_attribute_path_isValid = ::OpenAPI::fromJsonValue(m_attribute_path, json[QString("attribute_path")]);
    m_attribute_path_isSet = !json[QString("attribute_path")].isNull() && m_attribute_path_isValid;

    m_attribute_value_isValid = ::OpenAPI::fromJsonValue(m_attribute_value, json[QString("attribute_value")]);
    m_attribute_value_isSet = !json[QString("attribute_value")].isNull() && m_attribute_value_isValid;

    m_change_txn_isValid = ::OpenAPI::fromJsonValue(m_change_txn, json[QString("change_txn")]);
    m_change_txn_isSet = !json[QString("change_txn")].isNull() && m_change_txn_isValid;

    m_change_type_isValid = ::OpenAPI::fromJsonValue(m_change_type, json[QString("change_type")]);
    m_change_type_isSet = !json[QString("change_type")].isNull() && m_change_type_isValid;

    m_exclude_empty_values_isValid = ::OpenAPI::fromJsonValue(m_exclude_empty_values, json[QString("exclude_empty_values")]);
    m_exclude_empty_values_isSet = !json[QString("exclude_empty_values")].isNull() && m_exclude_empty_values_isValid;

    m_negative_match_isValid = ::OpenAPI::fromJsonValue(m_negative_match, json[QString("negative_match")]);
    m_negative_match_isSet = !json[QString("negative_match")].isNull() && m_negative_match_isValid;

    m_object_key_isValid = ::OpenAPI::fromJsonValue(m_object_key, json[QString("object_key")]);
    m_object_key_isSet = !json[QString("object_key")].isNull() && m_object_key_isValid;

    m_object_type_isValid = ::OpenAPI::fromJsonValue(m_object_type, json[QString("object_type")]);
    m_object_type_isSet = !json[QString("object_type")].isNull() && m_object_type_isValid;

    m_org_key_isValid = ::OpenAPI::fromJsonValue(m_org_key, json[QString("org_key")]);
    m_org_key_isSet = !json[QString("org_key")].isNull() && m_org_key_isValid;

    m_time_range_isValid = ::OpenAPI::fromJsonValue(m_time_range, json[QString("time_range")]);
    m_time_range_isSet = !json[QString("time_range")].isNull() && m_time_range_isValid;

    m_zone_key_isValid = ::OpenAPI::fromJsonValue(m_zone_key, json[QString("zone_key")]);
    m_zone_key_isSet = !json[QString("zone_key")].isNull() && m_zone_key_isValid;
}

QString OAIFilter::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIFilter::asJsonObject() const {
    QJsonObject obj;
    if (m_absolute_match_only_isSet) {
        obj.insert(QString("absolute_match_only"), ::OpenAPI::toJsonValue(m_absolute_match_only));
    }
    if (m_actor_key_isSet) {
        obj.insert(QString("actor_key"), ::OpenAPI::toJsonValue(m_actor_key));
    }
    if (m_attribute_path_isSet) {
        obj.insert(QString("attribute_path"), ::OpenAPI::toJsonValue(m_attribute_path));
    }
    if (m_attribute_value_isSet) {
        obj.insert(QString("attribute_value"), ::OpenAPI::toJsonValue(m_attribute_value));
    }
    if (m_change_txn_isSet) {
        obj.insert(QString("change_txn"), ::OpenAPI::toJsonValue(m_change_txn));
    }
    if (m_change_type_isSet) {
        obj.insert(QString("change_type"), ::OpenAPI::toJsonValue(m_change_type));
    }
    if (m_exclude_empty_values_isSet) {
        obj.insert(QString("exclude_empty_values"), ::OpenAPI::toJsonValue(m_exclude_empty_values));
    }
    if (m_negative_match_isSet) {
        obj.insert(QString("negative_match"), ::OpenAPI::toJsonValue(m_negative_match));
    }
    if (m_object_key_isSet) {
        obj.insert(QString("object_key"), ::OpenAPI::toJsonValue(m_object_key));
    }
    if (m_object_type_isSet) {
        obj.insert(QString("object_type"), ::OpenAPI::toJsonValue(m_object_type));
    }
    if (m_org_key_isSet) {
        obj.insert(QString("org_key"), ::OpenAPI::toJsonValue(m_org_key));
    }
    if (m_time_range.isSet()) {
        obj.insert(QString("time_range"), ::OpenAPI::toJsonValue(m_time_range));
    }
    if (m_zone_key_isSet) {
        obj.insert(QString("zone_key"), ::OpenAPI::toJsonValue(m_zone_key));
    }
    return obj;
}

bool OAIFilter::isAbsoluteMatchOnly() const {
    return m_absolute_match_only;
}
void OAIFilter::setAbsoluteMatchOnly(const bool &absolute_match_only) {
    m_absolute_match_only = absolute_match_only;
    m_absolute_match_only_isSet = true;
}

bool OAIFilter::is_absolute_match_only_Set() const{
    return m_absolute_match_only_isSet;
}

bool OAIFilter::is_absolute_match_only_Valid() const{
    return m_absolute_match_only_isValid;
}

QString OAIFilter::getActorKey() const {
    return m_actor_key;
}
void OAIFilter::setActorKey(const QString &actor_key) {
    m_actor_key = actor_key;
    m_actor_key_isSet = true;
}

bool OAIFilter::is_actor_key_Set() const{
    return m_actor_key_isSet;
}

bool OAIFilter::is_actor_key_Valid() const{
    return m_actor_key_isValid;
}

QString OAIFilter::getAttributePath() const {
    return m_attribute_path;
}
void OAIFilter::setAttributePath(const QString &attribute_path) {
    m_attribute_path = attribute_path;
    m_attribute_path_isSet = true;
}

bool OAIFilter::is_attribute_path_Set() const{
    return m_attribute_path_isSet;
}

bool OAIFilter::is_attribute_path_Valid() const{
    return m_attribute_path_isValid;
}

QString OAIFilter::getAttributeValue() const {
    return m_attribute_value;
}
void OAIFilter::setAttributeValue(const QString &attribute_value) {
    m_attribute_value = attribute_value;
    m_attribute_value_isSet = true;
}

bool OAIFilter::is_attribute_value_Set() const{
    return m_attribute_value_isSet;
}

bool OAIFilter::is_attribute_value_Valid() const{
    return m_attribute_value_isValid;
}

QString OAIFilter::getChangeTxn() const {
    return m_change_txn;
}
void OAIFilter::setChangeTxn(const QString &change_txn) {
    m_change_txn = change_txn;
    m_change_txn_isSet = true;
}

bool OAIFilter::is_change_txn_Set() const{
    return m_change_txn_isSet;
}

bool OAIFilter::is_change_txn_Valid() const{
    return m_change_txn_isValid;
}

QString OAIFilter::getChangeType() const {
    return m_change_type;
}
void OAIFilter::setChangeType(const QString &change_type) {
    m_change_type = change_type;
    m_change_type_isSet = true;
}

bool OAIFilter::is_change_type_Set() const{
    return m_change_type_isSet;
}

bool OAIFilter::is_change_type_Valid() const{
    return m_change_type_isValid;
}

bool OAIFilter::isExcludeEmptyValues() const {
    return m_exclude_empty_values;
}
void OAIFilter::setExcludeEmptyValues(const bool &exclude_empty_values) {
    m_exclude_empty_values = exclude_empty_values;
    m_exclude_empty_values_isSet = true;
}

bool OAIFilter::is_exclude_empty_values_Set() const{
    return m_exclude_empty_values_isSet;
}

bool OAIFilter::is_exclude_empty_values_Valid() const{
    return m_exclude_empty_values_isValid;
}

bool OAIFilter::isNegativeMatch() const {
    return m_negative_match;
}
void OAIFilter::setNegativeMatch(const bool &negative_match) {
    m_negative_match = negative_match;
    m_negative_match_isSet = true;
}

bool OAIFilter::is_negative_match_Set() const{
    return m_negative_match_isSet;
}

bool OAIFilter::is_negative_match_Valid() const{
    return m_negative_match_isValid;
}

QString OAIFilter::getObjectKey() const {
    return m_object_key;
}
void OAIFilter::setObjectKey(const QString &object_key) {
    m_object_key = object_key;
    m_object_key_isSet = true;
}

bool OAIFilter::is_object_key_Set() const{
    return m_object_key_isSet;
}

bool OAIFilter::is_object_key_Valid() const{
    return m_object_key_isValid;
}

QString OAIFilter::getObjectType() const {
    return m_object_type;
}
void OAIFilter::setObjectType(const QString &object_type) {
    m_object_type = object_type;
    m_object_type_isSet = true;
}

bool OAIFilter::is_object_type_Set() const{
    return m_object_type_isSet;
}

bool OAIFilter::is_object_type_Valid() const{
    return m_object_type_isValid;
}

QString OAIFilter::getOrgKey() const {
    return m_org_key;
}
void OAIFilter::setOrgKey(const QString &org_key) {
    m_org_key = org_key;
    m_org_key_isSet = true;
}

bool OAIFilter::is_org_key_Set() const{
    return m_org_key_isSet;
}

bool OAIFilter::is_org_key_Valid() const{
    return m_org_key_isValid;
}

OAITimeRange OAIFilter::getTimeRange() const {
    return m_time_range;
}
void OAIFilter::setTimeRange(const OAITimeRange &time_range) {
    m_time_range = time_range;
    m_time_range_isSet = true;
}

bool OAIFilter::is_time_range_Set() const{
    return m_time_range_isSet;
}

bool OAIFilter::is_time_range_Valid() const{
    return m_time_range_isValid;
}

QString OAIFilter::getZoneKey() const {
    return m_zone_key;
}
void OAIFilter::setZoneKey(const QString &zone_key) {
    m_zone_key = zone_key;
    m_zone_key_isSet = true;
}

bool OAIFilter::is_zone_key_Set() const{
    return m_zone_key_isSet;
}

bool OAIFilter::is_zone_key_Valid() const{
    return m_zone_key_isValid;
}

bool OAIFilter::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_absolute_match_only_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_actor_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_attribute_path_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_attribute_value_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_change_txn_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_change_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_exclude_empty_values_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_negative_match_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_object_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_object_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_org_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_range.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_zone_key_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIFilter::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
