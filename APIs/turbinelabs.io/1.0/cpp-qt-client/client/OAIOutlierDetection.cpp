/**
 * Turbine Labs API
 * The Turbine Labs API provides CRUD operations for core object types, and is mostly RESTy. The easiest way to interact with the API is with [tbnctl](https://docs.turbinelabs.io/advanced/tbnctl.html). If you want to make direct HTTP calls, however, you can obtain an access token using tbnctl, and then pass it in the Authorization header, prefixed by `Token `: ```console curl -H \"Authorization: Token <access token>\" https://api.turbinelabs.io/v1.0/cluster ``` 
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIOutlierDetection.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIOutlierDetection::OAIOutlierDetection(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIOutlierDetection::OAIOutlierDetection() {
    this->initializeModel();
}

OAIOutlierDetection::~OAIOutlierDetection() {}

void OAIOutlierDetection::initializeModel() {

    m_base_ejection_time_msec_isSet = false;
    m_base_ejection_time_msec_isValid = false;

    m_consecutive_5xx_isSet = false;
    m_consecutive_5xx_isValid = false;

    m_consecutive_gateway_failure_isSet = false;
    m_consecutive_gateway_failure_isValid = false;

    m_enforcing_consecutive_5xx_isSet = false;
    m_enforcing_consecutive_5xx_isValid = false;

    m_enforcing_consecutive_gateway_failure_isSet = false;
    m_enforcing_consecutive_gateway_failure_isValid = false;

    m_enforcing_success_rate_isSet = false;
    m_enforcing_success_rate_isValid = false;

    m_interval_msec_isSet = false;
    m_interval_msec_isValid = false;

    m_max_ejection_percent_isSet = false;
    m_max_ejection_percent_isValid = false;

    m_success_rate_minimum_hosts_isSet = false;
    m_success_rate_minimum_hosts_isValid = false;

    m_success_rate_request_volume_isSet = false;
    m_success_rate_request_volume_isValid = false;

    m_success_rate_stdev_factor_isSet = false;
    m_success_rate_stdev_factor_isValid = false;
}

void OAIOutlierDetection::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIOutlierDetection::fromJsonObject(QJsonObject json) {

    m_base_ejection_time_msec_isValid = ::OpenAPI::fromJsonValue(m_base_ejection_time_msec, json[QString("base_ejection_time_msec")]);
    m_base_ejection_time_msec_isSet = !json[QString("base_ejection_time_msec")].isNull() && m_base_ejection_time_msec_isValid;

    m_consecutive_5xx_isValid = ::OpenAPI::fromJsonValue(m_consecutive_5xx, json[QString("consecutive_5xx")]);
    m_consecutive_5xx_isSet = !json[QString("consecutive_5xx")].isNull() && m_consecutive_5xx_isValid;

    m_consecutive_gateway_failure_isValid = ::OpenAPI::fromJsonValue(m_consecutive_gateway_failure, json[QString("consecutive_gateway_failure")]);
    m_consecutive_gateway_failure_isSet = !json[QString("consecutive_gateway_failure")].isNull() && m_consecutive_gateway_failure_isValid;

    m_enforcing_consecutive_5xx_isValid = ::OpenAPI::fromJsonValue(m_enforcing_consecutive_5xx, json[QString("enforcing_consecutive_5xx")]);
    m_enforcing_consecutive_5xx_isSet = !json[QString("enforcing_consecutive_5xx")].isNull() && m_enforcing_consecutive_5xx_isValid;

    m_enforcing_consecutive_gateway_failure_isValid = ::OpenAPI::fromJsonValue(m_enforcing_consecutive_gateway_failure, json[QString("enforcing_consecutive_gateway_failure")]);
    m_enforcing_consecutive_gateway_failure_isSet = !json[QString("enforcing_consecutive_gateway_failure")].isNull() && m_enforcing_consecutive_gateway_failure_isValid;

    m_enforcing_success_rate_isValid = ::OpenAPI::fromJsonValue(m_enforcing_success_rate, json[QString("enforcing_success_rate")]);
    m_enforcing_success_rate_isSet = !json[QString("enforcing_success_rate")].isNull() && m_enforcing_success_rate_isValid;

    m_interval_msec_isValid = ::OpenAPI::fromJsonValue(m_interval_msec, json[QString("interval_msec")]);
    m_interval_msec_isSet = !json[QString("interval_msec")].isNull() && m_interval_msec_isValid;

    m_max_ejection_percent_isValid = ::OpenAPI::fromJsonValue(m_max_ejection_percent, json[QString("max_ejection_percent")]);
    m_max_ejection_percent_isSet = !json[QString("max_ejection_percent")].isNull() && m_max_ejection_percent_isValid;

    m_success_rate_minimum_hosts_isValid = ::OpenAPI::fromJsonValue(m_success_rate_minimum_hosts, json[QString("success_rate_minimum_hosts")]);
    m_success_rate_minimum_hosts_isSet = !json[QString("success_rate_minimum_hosts")].isNull() && m_success_rate_minimum_hosts_isValid;

    m_success_rate_request_volume_isValid = ::OpenAPI::fromJsonValue(m_success_rate_request_volume, json[QString("success_rate_request_volume")]);
    m_success_rate_request_volume_isSet = !json[QString("success_rate_request_volume")].isNull() && m_success_rate_request_volume_isValid;

    m_success_rate_stdev_factor_isValid = ::OpenAPI::fromJsonValue(m_success_rate_stdev_factor, json[QString("success_rate_stdev_factor")]);
    m_success_rate_stdev_factor_isSet = !json[QString("success_rate_stdev_factor")].isNull() && m_success_rate_stdev_factor_isValid;
}

QString OAIOutlierDetection::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIOutlierDetection::asJsonObject() const {
    QJsonObject obj;
    if (m_base_ejection_time_msec_isSet) {
        obj.insert(QString("base_ejection_time_msec"), ::OpenAPI::toJsonValue(m_base_ejection_time_msec));
    }
    if (m_consecutive_5xx_isSet) {
        obj.insert(QString("consecutive_5xx"), ::OpenAPI::toJsonValue(m_consecutive_5xx));
    }
    if (m_consecutive_gateway_failure_isSet) {
        obj.insert(QString("consecutive_gateway_failure"), ::OpenAPI::toJsonValue(m_consecutive_gateway_failure));
    }
    if (m_enforcing_consecutive_5xx_isSet) {
        obj.insert(QString("enforcing_consecutive_5xx"), ::OpenAPI::toJsonValue(m_enforcing_consecutive_5xx));
    }
    if (m_enforcing_consecutive_gateway_failure_isSet) {
        obj.insert(QString("enforcing_consecutive_gateway_failure"), ::OpenAPI::toJsonValue(m_enforcing_consecutive_gateway_failure));
    }
    if (m_enforcing_success_rate_isSet) {
        obj.insert(QString("enforcing_success_rate"), ::OpenAPI::toJsonValue(m_enforcing_success_rate));
    }
    if (m_interval_msec_isSet) {
        obj.insert(QString("interval_msec"), ::OpenAPI::toJsonValue(m_interval_msec));
    }
    if (m_max_ejection_percent_isSet) {
        obj.insert(QString("max_ejection_percent"), ::OpenAPI::toJsonValue(m_max_ejection_percent));
    }
    if (m_success_rate_minimum_hosts_isSet) {
        obj.insert(QString("success_rate_minimum_hosts"), ::OpenAPI::toJsonValue(m_success_rate_minimum_hosts));
    }
    if (m_success_rate_request_volume_isSet) {
        obj.insert(QString("success_rate_request_volume"), ::OpenAPI::toJsonValue(m_success_rate_request_volume));
    }
    if (m_success_rate_stdev_factor_isSet) {
        obj.insert(QString("success_rate_stdev_factor"), ::OpenAPI::toJsonValue(m_success_rate_stdev_factor));
    }
    return obj;
}

qint32 OAIOutlierDetection::getBaseEjectionTimeMsec() const {
    return m_base_ejection_time_msec;
}
void OAIOutlierDetection::setBaseEjectionTimeMsec(const qint32 &base_ejection_time_msec) {
    m_base_ejection_time_msec = base_ejection_time_msec;
    m_base_ejection_time_msec_isSet = true;
}

bool OAIOutlierDetection::is_base_ejection_time_msec_Set() const{
    return m_base_ejection_time_msec_isSet;
}

bool OAIOutlierDetection::is_base_ejection_time_msec_Valid() const{
    return m_base_ejection_time_msec_isValid;
}

qint32 OAIOutlierDetection::getConsecutive5xx() const {
    return m_consecutive_5xx;
}
void OAIOutlierDetection::setConsecutive5xx(const qint32 &consecutive_5xx) {
    m_consecutive_5xx = consecutive_5xx;
    m_consecutive_5xx_isSet = true;
}

bool OAIOutlierDetection::is_consecutive_5xx_Set() const{
    return m_consecutive_5xx_isSet;
}

bool OAIOutlierDetection::is_consecutive_5xx_Valid() const{
    return m_consecutive_5xx_isValid;
}

qint32 OAIOutlierDetection::getConsecutiveGatewayFailure() const {
    return m_consecutive_gateway_failure;
}
void OAIOutlierDetection::setConsecutiveGatewayFailure(const qint32 &consecutive_gateway_failure) {
    m_consecutive_gateway_failure = consecutive_gateway_failure;
    m_consecutive_gateway_failure_isSet = true;
}

bool OAIOutlierDetection::is_consecutive_gateway_failure_Set() const{
    return m_consecutive_gateway_failure_isSet;
}

bool OAIOutlierDetection::is_consecutive_gateway_failure_Valid() const{
    return m_consecutive_gateway_failure_isValid;
}

qint32 OAIOutlierDetection::getEnforcingConsecutive5xx() const {
    return m_enforcing_consecutive_5xx;
}
void OAIOutlierDetection::setEnforcingConsecutive5xx(const qint32 &enforcing_consecutive_5xx) {
    m_enforcing_consecutive_5xx = enforcing_consecutive_5xx;
    m_enforcing_consecutive_5xx_isSet = true;
}

bool OAIOutlierDetection::is_enforcing_consecutive_5xx_Set() const{
    return m_enforcing_consecutive_5xx_isSet;
}

bool OAIOutlierDetection::is_enforcing_consecutive_5xx_Valid() const{
    return m_enforcing_consecutive_5xx_isValid;
}

qint32 OAIOutlierDetection::getEnforcingConsecutiveGatewayFailure() const {
    return m_enforcing_consecutive_gateway_failure;
}
void OAIOutlierDetection::setEnforcingConsecutiveGatewayFailure(const qint32 &enforcing_consecutive_gateway_failure) {
    m_enforcing_consecutive_gateway_failure = enforcing_consecutive_gateway_failure;
    m_enforcing_consecutive_gateway_failure_isSet = true;
}

bool OAIOutlierDetection::is_enforcing_consecutive_gateway_failure_Set() const{
    return m_enforcing_consecutive_gateway_failure_isSet;
}

bool OAIOutlierDetection::is_enforcing_consecutive_gateway_failure_Valid() const{
    return m_enforcing_consecutive_gateway_failure_isValid;
}

qint32 OAIOutlierDetection::getEnforcingSuccessRate() const {
    return m_enforcing_success_rate;
}
void OAIOutlierDetection::setEnforcingSuccessRate(const qint32 &enforcing_success_rate) {
    m_enforcing_success_rate = enforcing_success_rate;
    m_enforcing_success_rate_isSet = true;
}

bool OAIOutlierDetection::is_enforcing_success_rate_Set() const{
    return m_enforcing_success_rate_isSet;
}

bool OAIOutlierDetection::is_enforcing_success_rate_Valid() const{
    return m_enforcing_success_rate_isValid;
}

qint32 OAIOutlierDetection::getIntervalMsec() const {
    return m_interval_msec;
}
void OAIOutlierDetection::setIntervalMsec(const qint32 &interval_msec) {
    m_interval_msec = interval_msec;
    m_interval_msec_isSet = true;
}

bool OAIOutlierDetection::is_interval_msec_Set() const{
    return m_interval_msec_isSet;
}

bool OAIOutlierDetection::is_interval_msec_Valid() const{
    return m_interval_msec_isValid;
}

qint32 OAIOutlierDetection::getMaxEjectionPercent() const {
    return m_max_ejection_percent;
}
void OAIOutlierDetection::setMaxEjectionPercent(const qint32 &max_ejection_percent) {
    m_max_ejection_percent = max_ejection_percent;
    m_max_ejection_percent_isSet = true;
}

bool OAIOutlierDetection::is_max_ejection_percent_Set() const{
    return m_max_ejection_percent_isSet;
}

bool OAIOutlierDetection::is_max_ejection_percent_Valid() const{
    return m_max_ejection_percent_isValid;
}

qint32 OAIOutlierDetection::getSuccessRateMinimumHosts() const {
    return m_success_rate_minimum_hosts;
}
void OAIOutlierDetection::setSuccessRateMinimumHosts(const qint32 &success_rate_minimum_hosts) {
    m_success_rate_minimum_hosts = success_rate_minimum_hosts;
    m_success_rate_minimum_hosts_isSet = true;
}

bool OAIOutlierDetection::is_success_rate_minimum_hosts_Set() const{
    return m_success_rate_minimum_hosts_isSet;
}

bool OAIOutlierDetection::is_success_rate_minimum_hosts_Valid() const{
    return m_success_rate_minimum_hosts_isValid;
}

qint32 OAIOutlierDetection::getSuccessRateRequestVolume() const {
    return m_success_rate_request_volume;
}
void OAIOutlierDetection::setSuccessRateRequestVolume(const qint32 &success_rate_request_volume) {
    m_success_rate_request_volume = success_rate_request_volume;
    m_success_rate_request_volume_isSet = true;
}

bool OAIOutlierDetection::is_success_rate_request_volume_Set() const{
    return m_success_rate_request_volume_isSet;
}

bool OAIOutlierDetection::is_success_rate_request_volume_Valid() const{
    return m_success_rate_request_volume_isValid;
}

qint32 OAIOutlierDetection::getSuccessRateStdevFactor() const {
    return m_success_rate_stdev_factor;
}
void OAIOutlierDetection::setSuccessRateStdevFactor(const qint32 &success_rate_stdev_factor) {
    m_success_rate_stdev_factor = success_rate_stdev_factor;
    m_success_rate_stdev_factor_isSet = true;
}

bool OAIOutlierDetection::is_success_rate_stdev_factor_Set() const{
    return m_success_rate_stdev_factor_isSet;
}

bool OAIOutlierDetection::is_success_rate_stdev_factor_Valid() const{
    return m_success_rate_stdev_factor_isValid;
}

bool OAIOutlierDetection::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_base_ejection_time_msec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_consecutive_5xx_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_consecutive_gateway_failure_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enforcing_consecutive_5xx_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enforcing_consecutive_gateway_failure_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enforcing_success_rate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interval_msec_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_ejection_percent_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_success_rate_minimum_hosts_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_success_rate_request_volume_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_success_rate_stdev_factor_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIOutlierDetection::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
