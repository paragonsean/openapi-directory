/**
 * Turbine Labs API
 * The Turbine Labs API provides CRUD operations for core object types, and is mostly RESTy. The easiest way to interact with the API is with [tbnctl](https://docs.turbinelabs.io/advanced/tbnctl.html). If you want to make direct HTTP calls, however, you can obtain an access token using tbnctl, and then pass it in the Authorization header, prefixed by `Token `: ```console curl -H \"Authorization: Token <access token>\" https://api.turbinelabs.io/v1.0/cluster ``` 
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * OAIOutlierDetection.h
 *
 * A form of passive health checking that dynamically determines whether instances in a cluster are performing unlike others and preemptively removes them from a load balancing set. 
 */

#ifndef OAIOutlierDetection_H
#define OAIOutlierDetection_H

#include <QJsonObject>


#include "OAIEnum.h"
#include "OAIObject.h"

namespace OpenAPI {

class OAIOutlierDetection : public OAIObject {
public:
    OAIOutlierDetection();
    OAIOutlierDetection(QString json);
    ~OAIOutlierDetection() override;

    QString asJson() const override;
    QJsonObject asJsonObject() const override;
    void fromJsonObject(QJsonObject json) override;
    void fromJson(QString jsonString) override;

    qint32 getBaseEjectionTimeMsec() const;
    void setBaseEjectionTimeMsec(const qint32 &base_ejection_time_msec);
    bool is_base_ejection_time_msec_Set() const;
    bool is_base_ejection_time_msec_Valid() const;

    qint32 getConsecutive5xx() const;
    void setConsecutive5xx(const qint32 &consecutive_5xx);
    bool is_consecutive_5xx_Set() const;
    bool is_consecutive_5xx_Valid() const;

    qint32 getConsecutiveGatewayFailure() const;
    void setConsecutiveGatewayFailure(const qint32 &consecutive_gateway_failure);
    bool is_consecutive_gateway_failure_Set() const;
    bool is_consecutive_gateway_failure_Valid() const;

    qint32 getEnforcingConsecutive5xx() const;
    void setEnforcingConsecutive5xx(const qint32 &enforcing_consecutive_5xx);
    bool is_enforcing_consecutive_5xx_Set() const;
    bool is_enforcing_consecutive_5xx_Valid() const;

    qint32 getEnforcingConsecutiveGatewayFailure() const;
    void setEnforcingConsecutiveGatewayFailure(const qint32 &enforcing_consecutive_gateway_failure);
    bool is_enforcing_consecutive_gateway_failure_Set() const;
    bool is_enforcing_consecutive_gateway_failure_Valid() const;

    qint32 getEnforcingSuccessRate() const;
    void setEnforcingSuccessRate(const qint32 &enforcing_success_rate);
    bool is_enforcing_success_rate_Set() const;
    bool is_enforcing_success_rate_Valid() const;

    qint32 getIntervalMsec() const;
    void setIntervalMsec(const qint32 &interval_msec);
    bool is_interval_msec_Set() const;
    bool is_interval_msec_Valid() const;

    qint32 getMaxEjectionPercent() const;
    void setMaxEjectionPercent(const qint32 &max_ejection_percent);
    bool is_max_ejection_percent_Set() const;
    bool is_max_ejection_percent_Valid() const;

    qint32 getSuccessRateMinimumHosts() const;
    void setSuccessRateMinimumHosts(const qint32 &success_rate_minimum_hosts);
    bool is_success_rate_minimum_hosts_Set() const;
    bool is_success_rate_minimum_hosts_Valid() const;

    qint32 getSuccessRateRequestVolume() const;
    void setSuccessRateRequestVolume(const qint32 &success_rate_request_volume);
    bool is_success_rate_request_volume_Set() const;
    bool is_success_rate_request_volume_Valid() const;

    qint32 getSuccessRateStdevFactor() const;
    void setSuccessRateStdevFactor(const qint32 &success_rate_stdev_factor);
    bool is_success_rate_stdev_factor_Set() const;
    bool is_success_rate_stdev_factor_Valid() const;

    virtual bool isSet() const override;
    virtual bool isValid() const override;

private:
    void initializeModel();

    qint32 m_base_ejection_time_msec;
    bool m_base_ejection_time_msec_isSet;
    bool m_base_ejection_time_msec_isValid;

    qint32 m_consecutive_5xx;
    bool m_consecutive_5xx_isSet;
    bool m_consecutive_5xx_isValid;

    qint32 m_consecutive_gateway_failure;
    bool m_consecutive_gateway_failure_isSet;
    bool m_consecutive_gateway_failure_isValid;

    qint32 m_enforcing_consecutive_5xx;
    bool m_enforcing_consecutive_5xx_isSet;
    bool m_enforcing_consecutive_5xx_isValid;

    qint32 m_enforcing_consecutive_gateway_failure;
    bool m_enforcing_consecutive_gateway_failure_isSet;
    bool m_enforcing_consecutive_gateway_failure_isValid;

    qint32 m_enforcing_success_rate;
    bool m_enforcing_success_rate_isSet;
    bool m_enforcing_success_rate_isValid;

    qint32 m_interval_msec;
    bool m_interval_msec_isSet;
    bool m_interval_msec_isValid;

    qint32 m_max_ejection_percent;
    bool m_max_ejection_percent_isSet;
    bool m_max_ejection_percent_isValid;

    qint32 m_success_rate_minimum_hosts;
    bool m_success_rate_minimum_hosts_isSet;
    bool m_success_rate_minimum_hosts_isValid;

    qint32 m_success_rate_request_volume;
    bool m_success_rate_request_volume_isSet;
    bool m_success_rate_request_volume_isValid;

    qint32 m_success_rate_stdev_factor;
    bool m_success_rate_stdev_factor_isSet;
    bool m_success_rate_stdev_factor_isValid;
};

} // namespace OpenAPI

Q_DECLARE_METATYPE(OpenAPI::OAIOutlierDetection)

#endif // OAIOutlierDetection_H
