/**
 * Turbine Labs API
 * The Turbine Labs API provides CRUD operations for core object types, and is mostly RESTy. The easiest way to interact with the API is with [tbnctl](https://docs.turbinelabs.io/advanced/tbnctl.html). If you want to make direct HTTP calls, however, you can obtain an access token using tbnctl, and then pass it in the Authorization header, prefixed by `Token `: ```console curl -H \"Authorization: Token <access token>\" https://api.turbinelabs.io/v1.0/cluster ``` 
 *
 * The version of the OpenAPI document: 1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRule.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRule::OAIRule(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRule::OAIRule() {
    this->initializeModel();
}

OAIRule::~OAIRule() {}

void OAIRule::initializeModel() {

    m_cohort_seed_isSet = false;
    m_cohort_seed_isValid = false;

    m_constraints_isSet = false;
    m_constraints_isValid = false;

    m_matches_isSet = false;
    m_matches_isValid = false;

    m_methods_isSet = false;
    m_methods_isValid = false;

    m_rule_key_isSet = false;
    m_rule_key_isValid = false;
}

void OAIRule::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRule::fromJsonObject(QJsonObject json) {

    m_cohort_seed_isValid = ::OpenAPI::fromJsonValue(m_cohort_seed, json[QString("cohort_seed")]);
    m_cohort_seed_isSet = !json[QString("cohort_seed")].isNull() && m_cohort_seed_isValid;

    m_constraints_isValid = ::OpenAPI::fromJsonValue(m_constraints, json[QString("constraints")]);
    m_constraints_isSet = !json[QString("constraints")].isNull() && m_constraints_isValid;

    m_matches_isValid = ::OpenAPI::fromJsonValue(m_matches, json[QString("matches")]);
    m_matches_isSet = !json[QString("matches")].isNull() && m_matches_isValid;

    m_methods_isValid = ::OpenAPI::fromJsonValue(m_methods, json[QString("methods")]);
    m_methods_isSet = !json[QString("methods")].isNull() && m_methods_isValid;

    m_rule_key_isValid = ::OpenAPI::fromJsonValue(m_rule_key, json[QString("rule_key")]);
    m_rule_key_isSet = !json[QString("rule_key")].isNull() && m_rule_key_isValid;
}

QString OAIRule::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRule::asJsonObject() const {
    QJsonObject obj;
    if (m_cohort_seed.isSet()) {
        obj.insert(QString("cohort_seed"), ::OpenAPI::toJsonValue(m_cohort_seed));
    }
    if (m_constraints.isSet()) {
        obj.insert(QString("constraints"), ::OpenAPI::toJsonValue(m_constraints));
    }
    if (m_matches.size() > 0) {
        obj.insert(QString("matches"), ::OpenAPI::toJsonValue(m_matches));
    }
    if (m_methods.size() > 0) {
        obj.insert(QString("methods"), ::OpenAPI::toJsonValue(m_methods));
    }
    if (m_rule_key_isSet) {
        obj.insert(QString("rule_key"), ::OpenAPI::toJsonValue(m_rule_key));
    }
    return obj;
}

OAICohortSeed OAIRule::getCohortSeed() const {
    return m_cohort_seed;
}
void OAIRule::setCohortSeed(const OAICohortSeed &cohort_seed) {
    m_cohort_seed = cohort_seed;
    m_cohort_seed_isSet = true;
}

bool OAIRule::is_cohort_seed_Set() const{
    return m_cohort_seed_isSet;
}

bool OAIRule::is_cohort_seed_Valid() const{
    return m_cohort_seed_isValid;
}

OAIAllConstraints OAIRule::getConstraints() const {
    return m_constraints;
}
void OAIRule::setConstraints(const OAIAllConstraints &constraints) {
    m_constraints = constraints;
    m_constraints_isSet = true;
}

bool OAIRule::is_constraints_Set() const{
    return m_constraints_isSet;
}

bool OAIRule::is_constraints_Valid() const{
    return m_constraints_isValid;
}

QList<OAIMatch> OAIRule::getMatches() const {
    return m_matches;
}
void OAIRule::setMatches(const QList<OAIMatch> &matches) {
    m_matches = matches;
    m_matches_isSet = true;
}

bool OAIRule::is_matches_Set() const{
    return m_matches_isSet;
}

bool OAIRule::is_matches_Valid() const{
    return m_matches_isValid;
}

QList<QString> OAIRule::getMethods() const {
    return m_methods;
}
void OAIRule::setMethods(const QList<QString> &methods) {
    m_methods = methods;
    m_methods_isSet = true;
}

bool OAIRule::is_methods_Set() const{
    return m_methods_isSet;
}

bool OAIRule::is_methods_Valid() const{
    return m_methods_isValid;
}

QString OAIRule::getRuleKey() const {
    return m_rule_key;
}
void OAIRule::setRuleKey(const QString &rule_key) {
    m_rule_key = rule_key;
    m_rule_key_isSet = true;
}

bool OAIRule::is_rule_key_Set() const{
    return m_rule_key_isSet;
}

bool OAIRule::is_rule_key_Valid() const{
    return m_rule_key_isValid;
}

bool OAIRule::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cohort_seed.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_constraints.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_matches.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_methods.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_rule_key_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRule::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
