/*
 * Xero OAuth 2 Identity Service API
 * These endpoints are related to managing authentication tokens and identity for Xero API
 *
 * The version of the OpenAPI document: 2.9.4
 * Contact: api@xero.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Connection
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:53:24.388603-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Connection {
  public static final String SERIALIZED_NAME_AUTH_EVENT_ID = "authEventId";
  @SerializedName(SERIALIZED_NAME_AUTH_EVENT_ID)
  private UUID authEventId;

  public static final String SERIALIZED_NAME_CREATED_DATE_UTC = "createdDateUtc";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE_UTC)
  private OffsetDateTime createdDateUtc;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private UUID id;

  public static final String SERIALIZED_NAME_TENANT_ID = "tenantId";
  @SerializedName(SERIALIZED_NAME_TENANT_ID)
  private UUID tenantId;

  public static final String SERIALIZED_NAME_TENANT_NAME = "tenantName";
  @SerializedName(SERIALIZED_NAME_TENANT_NAME)
  private String tenantName;

  public static final String SERIALIZED_NAME_TENANT_TYPE = "tenantType";
  @SerializedName(SERIALIZED_NAME_TENANT_TYPE)
  private String tenantType;

  public static final String SERIALIZED_NAME_UPDATED_DATE_UTC = "updatedDateUtc";
  @SerializedName(SERIALIZED_NAME_UPDATED_DATE_UTC)
  private OffsetDateTime updatedDateUtc;

  public Connection() {
  }

  public Connection authEventId(UUID authEventId) {
    this.authEventId = authEventId;
    return this;
  }

  /**
   * Identifier shared across connections authorised at the same time
   * @return authEventId
   */
  @javax.annotation.Nullable
  public UUID getAuthEventId() {
    return authEventId;
  }

  public void setAuthEventId(UUID authEventId) {
    this.authEventId = authEventId;
  }


  public Connection createdDateUtc(OffsetDateTime createdDateUtc) {
    this.createdDateUtc = createdDateUtc;
    return this;
  }

  /**
   * The date when the user connected this tenant to your app
   * @return createdDateUtc
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedDateUtc() {
    return createdDateUtc;
  }

  public void setCreatedDateUtc(OffsetDateTime createdDateUtc) {
    this.createdDateUtc = createdDateUtc;
  }


  public Connection id(UUID id) {
    this.id = id;
    return this;
  }

  /**
   * Xero identifier
   * @return id
   */
  @javax.annotation.Nullable
  public UUID getId() {
    return id;
  }

  public void setId(UUID id) {
    this.id = id;
  }


  public Connection tenantId(UUID tenantId) {
    this.tenantId = tenantId;
    return this;
  }

  /**
   * Xero identifier of organisation
   * @return tenantId
   */
  @javax.annotation.Nullable
  public UUID getTenantId() {
    return tenantId;
  }

  public void setTenantId(UUID tenantId) {
    this.tenantId = tenantId;
  }


  public Connection tenantName(String tenantName) {
    this.tenantName = tenantName;
    return this;
  }

  /**
   * Xero tenant name
   * @return tenantName
   */
  @javax.annotation.Nullable
  public String getTenantName() {
    return tenantName;
  }

  public void setTenantName(String tenantName) {
    this.tenantName = tenantName;
  }


  public Connection tenantType(String tenantType) {
    this.tenantType = tenantType;
    return this;
  }

  /**
   * Xero tenant type (i.e. ORGANISATION, PRACTICE)
   * @return tenantType
   */
  @javax.annotation.Nullable
  public String getTenantType() {
    return tenantType;
  }

  public void setTenantType(String tenantType) {
    this.tenantType = tenantType;
  }


  public Connection updatedDateUtc(OffsetDateTime updatedDateUtc) {
    this.updatedDateUtc = updatedDateUtc;
    return this;
  }

  /**
   * The date when the user most recently connected this tenant to your app. May differ to the created date if the user has disconnected and subsequently reconnected this tenant to your app.
   * @return updatedDateUtc
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedDateUtc() {
    return updatedDateUtc;
  }

  public void setUpdatedDateUtc(OffsetDateTime updatedDateUtc) {
    this.updatedDateUtc = updatedDateUtc;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Connection connection = (Connection) o;
    return Objects.equals(this.authEventId, connection.authEventId) &&
        Objects.equals(this.createdDateUtc, connection.createdDateUtc) &&
        Objects.equals(this.id, connection.id) &&
        Objects.equals(this.tenantId, connection.tenantId) &&
        Objects.equals(this.tenantName, connection.tenantName) &&
        Objects.equals(this.tenantType, connection.tenantType) &&
        Objects.equals(this.updatedDateUtc, connection.updatedDateUtc);
  }

  @Override
  public int hashCode() {
    return Objects.hash(authEventId, createdDateUtc, id, tenantId, tenantName, tenantType, updatedDateUtc);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Connection {\n");
    sb.append("    authEventId: ").append(toIndentedString(authEventId)).append("\n");
    sb.append("    createdDateUtc: ").append(toIndentedString(createdDateUtc)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    tenantId: ").append(toIndentedString(tenantId)).append("\n");
    sb.append("    tenantName: ").append(toIndentedString(tenantName)).append("\n");
    sb.append("    tenantType: ").append(toIndentedString(tenantType)).append("\n");
    sb.append("    updatedDateUtc: ").append(toIndentedString(updatedDateUtc)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("authEventId");
    openapiFields.add("createdDateUtc");
    openapiFields.add("id");
    openapiFields.add("tenantId");
    openapiFields.add("tenantName");
    openapiFields.add("tenantType");
    openapiFields.add("updatedDateUtc");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Connection
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Connection.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Connection is not found in the empty JSON string", Connection.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Connection.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Connection` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("authEventId") != null && !jsonObj.get("authEventId").isJsonNull()) && !jsonObj.get("authEventId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authEventId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authEventId").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("tenantId") != null && !jsonObj.get("tenantId").isJsonNull()) && !jsonObj.get("tenantId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tenantId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tenantId").toString()));
      }
      if ((jsonObj.get("tenantName") != null && !jsonObj.get("tenantName").isJsonNull()) && !jsonObj.get("tenantName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tenantName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tenantName").toString()));
      }
      if ((jsonObj.get("tenantType") != null && !jsonObj.get("tenantType").isJsonNull()) && !jsonObj.get("tenantType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tenantType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tenantType").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Connection.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Connection' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Connection> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Connection.class));

       return (TypeAdapter<T>) new TypeAdapter<Connection>() {
           @Override
           public void write(JsonWriter out, Connection value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Connection read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Connection given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Connection
   * @throws IOException if the JSON string is invalid with respect to Connection
   */
  public static Connection fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Connection.class);
  }

  /**
   * Convert an instance of Connection to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

