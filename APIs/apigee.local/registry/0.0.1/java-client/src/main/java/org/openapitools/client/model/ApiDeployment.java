/*
 * Registry API
 * The Registry service allows teams to manage descriptions of APIs.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An ApiDeployment describes a service running at particular address that provides a particular version of an API. ApiDeployments have revisions which correspond to different configurations of a single deployment in time. Revision identifiers should be updated whenever the served API spec or endpoint address changes.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:30:10.251904-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ApiDeployment {
  public static final String SERIALIZED_NAME_ACCESS_GUIDANCE = "accessGuidance";
  @SerializedName(SERIALIZED_NAME_ACCESS_GUIDANCE)
  private String accessGuidance;

  public static final String SERIALIZED_NAME_ANNOTATIONS = "annotations";
  @SerializedName(SERIALIZED_NAME_ANNOTATIONS)
  private Map<String, String> annotations = new HashMap<>();

  public static final String SERIALIZED_NAME_API_SPEC_REVISION = "apiSpecRevision";
  @SerializedName(SERIALIZED_NAME_API_SPEC_REVISION)
  private String apiSpecRevision;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private OffsetDateTime createTime;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_ENDPOINT_URI = "endpointUri";
  @SerializedName(SERIALIZED_NAME_ENDPOINT_URI)
  private String endpointUri;

  public static final String SERIALIZED_NAME_EXTERNAL_CHANNEL_URI = "externalChannelUri";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_CHANNEL_URI)
  private String externalChannelUri;

  public static final String SERIALIZED_NAME_INTENDED_AUDIENCE = "intendedAudience";
  @SerializedName(SERIALIZED_NAME_INTENDED_AUDIENCE)
  private String intendedAudience;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_REVISION_CREATE_TIME = "revisionCreateTime";
  @SerializedName(SERIALIZED_NAME_REVISION_CREATE_TIME)
  private OffsetDateTime revisionCreateTime;

  public static final String SERIALIZED_NAME_REVISION_ID = "revisionId";
  @SerializedName(SERIALIZED_NAME_REVISION_ID)
  private String revisionId;

  public static final String SERIALIZED_NAME_REVISION_UPDATE_TIME = "revisionUpdateTime";
  @SerializedName(SERIALIZED_NAME_REVISION_UPDATE_TIME)
  private OffsetDateTime revisionUpdateTime;

  public ApiDeployment() {
  }

  public ApiDeployment(
     OffsetDateTime createTime, 
     OffsetDateTime revisionCreateTime, 
     String revisionId, 
     OffsetDateTime revisionUpdateTime
  ) {
    this();
    this.createTime = createTime;
    this.revisionCreateTime = revisionCreateTime;
    this.revisionId = revisionId;
    this.revisionUpdateTime = revisionUpdateTime;
  }

  public ApiDeployment accessGuidance(String accessGuidance) {
    this.accessGuidance = accessGuidance;
    return this;
  }

  /**
   * Text briefly describing how to access the endpoint. Changes to this value will not affect the revision.
   * @return accessGuidance
   */
  @javax.annotation.Nullable
  public String getAccessGuidance() {
    return accessGuidance;
  }

  public void setAccessGuidance(String accessGuidance) {
    this.accessGuidance = accessGuidance;
  }


  public ApiDeployment annotations(Map<String, String> annotations) {
    this.annotations = annotations;
    return this;
  }

  public ApiDeployment putAnnotationsItem(String key, String annotationsItem) {
    if (this.annotations == null) {
      this.annotations = new HashMap<>();
    }
    this.annotations.put(key, annotationsItem);
    return this;
  }

  /**
   * Annotations attach non-identifying metadata to resources. Annotation keys and values are less restricted than those of labels, but should be generally used for small values of broad interest. Larger, topic- specific metadata should be stored in Artifacts.
   * @return annotations
   */
  @javax.annotation.Nullable
  public Map<String, String> getAnnotations() {
    return annotations;
  }

  public void setAnnotations(Map<String, String> annotations) {
    this.annotations = annotations;
  }


  public ApiDeployment apiSpecRevision(String apiSpecRevision) {
    this.apiSpecRevision = apiSpecRevision;
    return this;
  }

  /**
   * The full resource name (including revision id) of the spec of the API being served by the deployment. Changes to this value will update the revision. Format: apis/{api}/deployments/{deployment}
   * @return apiSpecRevision
   */
  @javax.annotation.Nullable
  public String getApiSpecRevision() {
    return apiSpecRevision;
  }

  public void setApiSpecRevision(String apiSpecRevision) {
    this.apiSpecRevision = apiSpecRevision;
  }


  /**
   * Output only. Creation timestamp; when the deployment resource was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreateTime() {
    return createTime;
  }



  public ApiDeployment description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A detailed description.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public ApiDeployment displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Human-meaningful name.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public ApiDeployment endpointUri(String endpointUri) {
    this.endpointUri = endpointUri;
    return this;
  }

  /**
   * The address where the deployment is serving. Changes to this value will update the revision.
   * @return endpointUri
   */
  @javax.annotation.Nullable
  public String getEndpointUri() {
    return endpointUri;
  }

  public void setEndpointUri(String endpointUri) {
    this.endpointUri = endpointUri;
  }


  public ApiDeployment externalChannelUri(String externalChannelUri) {
    this.externalChannelUri = externalChannelUri;
    return this;
  }

  /**
   * The address of the external channel of the API (e.g. the Developer Portal). Changes to this value will not affect the revision.
   * @return externalChannelUri
   */
  @javax.annotation.Nullable
  public String getExternalChannelUri() {
    return externalChannelUri;
  }

  public void setExternalChannelUri(String externalChannelUri) {
    this.externalChannelUri = externalChannelUri;
  }


  public ApiDeployment intendedAudience(String intendedAudience) {
    this.intendedAudience = intendedAudience;
    return this;
  }

  /**
   * Text briefly identifying the intended audience of the API. Changes to this value will not affect the revision.
   * @return intendedAudience
   */
  @javax.annotation.Nullable
  public String getIntendedAudience() {
    return intendedAudience;
  }

  public void setIntendedAudience(String intendedAudience) {
    this.intendedAudience = intendedAudience;
  }


  public ApiDeployment labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public ApiDeployment putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels attach identifying metadata to resources. Identifying metadata can be used to filter list operations. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one resource (System labels are excluded). See https://goo.gl/xmQnxf for more information and examples of labels. System reserved label keys are prefixed with \&quot;registry.googleapis.com/\&quot; and cannot be changed.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public ApiDeployment name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Resource name.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  /**
   * Output only. Revision creation timestamp; when the represented revision was created.
   * @return revisionCreateTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getRevisionCreateTime() {
    return revisionCreateTime;
  }



  /**
   * Output only. Immutable. The revision ID of the deployment. A new revision is committed whenever the deployment contents are changed. The format is an 8-character hexadecimal string.
   * @return revisionId
   */
  @javax.annotation.Nullable
  public String getRevisionId() {
    return revisionId;
  }



  /**
   * Output only. Last update timestamp: when the represented revision was last modified.
   * @return revisionUpdateTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getRevisionUpdateTime() {
    return revisionUpdateTime;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApiDeployment apiDeployment = (ApiDeployment) o;
    return Objects.equals(this.accessGuidance, apiDeployment.accessGuidance) &&
        Objects.equals(this.annotations, apiDeployment.annotations) &&
        Objects.equals(this.apiSpecRevision, apiDeployment.apiSpecRevision) &&
        Objects.equals(this.createTime, apiDeployment.createTime) &&
        Objects.equals(this.description, apiDeployment.description) &&
        Objects.equals(this.displayName, apiDeployment.displayName) &&
        Objects.equals(this.endpointUri, apiDeployment.endpointUri) &&
        Objects.equals(this.externalChannelUri, apiDeployment.externalChannelUri) &&
        Objects.equals(this.intendedAudience, apiDeployment.intendedAudience) &&
        Objects.equals(this.labels, apiDeployment.labels) &&
        Objects.equals(this.name, apiDeployment.name) &&
        Objects.equals(this.revisionCreateTime, apiDeployment.revisionCreateTime) &&
        Objects.equals(this.revisionId, apiDeployment.revisionId) &&
        Objects.equals(this.revisionUpdateTime, apiDeployment.revisionUpdateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessGuidance, annotations, apiSpecRevision, createTime, description, displayName, endpointUri, externalChannelUri, intendedAudience, labels, name, revisionCreateTime, revisionId, revisionUpdateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApiDeployment {\n");
    sb.append("    accessGuidance: ").append(toIndentedString(accessGuidance)).append("\n");
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    apiSpecRevision: ").append(toIndentedString(apiSpecRevision)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    endpointUri: ").append(toIndentedString(endpointUri)).append("\n");
    sb.append("    externalChannelUri: ").append(toIndentedString(externalChannelUri)).append("\n");
    sb.append("    intendedAudience: ").append(toIndentedString(intendedAudience)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    revisionCreateTime: ").append(toIndentedString(revisionCreateTime)).append("\n");
    sb.append("    revisionId: ").append(toIndentedString(revisionId)).append("\n");
    sb.append("    revisionUpdateTime: ").append(toIndentedString(revisionUpdateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accessGuidance");
    openapiFields.add("annotations");
    openapiFields.add("apiSpecRevision");
    openapiFields.add("createTime");
    openapiFields.add("description");
    openapiFields.add("displayName");
    openapiFields.add("endpointUri");
    openapiFields.add("externalChannelUri");
    openapiFields.add("intendedAudience");
    openapiFields.add("labels");
    openapiFields.add("name");
    openapiFields.add("revisionCreateTime");
    openapiFields.add("revisionId");
    openapiFields.add("revisionUpdateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ApiDeployment
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ApiDeployment.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApiDeployment is not found in the empty JSON string", ApiDeployment.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ApiDeployment.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ApiDeployment` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("accessGuidance") != null && !jsonObj.get("accessGuidance").isJsonNull()) && !jsonObj.get("accessGuidance").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accessGuidance` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accessGuidance").toString()));
      }
      if ((jsonObj.get("apiSpecRevision") != null && !jsonObj.get("apiSpecRevision").isJsonNull()) && !jsonObj.get("apiSpecRevision").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `apiSpecRevision` to be a primitive type in the JSON string but got `%s`", jsonObj.get("apiSpecRevision").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("endpointUri") != null && !jsonObj.get("endpointUri").isJsonNull()) && !jsonObj.get("endpointUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endpointUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endpointUri").toString()));
      }
      if ((jsonObj.get("externalChannelUri") != null && !jsonObj.get("externalChannelUri").isJsonNull()) && !jsonObj.get("externalChannelUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `externalChannelUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("externalChannelUri").toString()));
      }
      if ((jsonObj.get("intendedAudience") != null && !jsonObj.get("intendedAudience").isJsonNull()) && !jsonObj.get("intendedAudience").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `intendedAudience` to be a primitive type in the JSON string but got `%s`", jsonObj.get("intendedAudience").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("revisionId") != null && !jsonObj.get("revisionId").isJsonNull()) && !jsonObj.get("revisionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revisionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revisionId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApiDeployment.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApiDeployment' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApiDeployment> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApiDeployment.class));

       return (TypeAdapter<T>) new TypeAdapter<ApiDeployment>() {
           @Override
           public void write(JsonWriter out, ApiDeployment value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ApiDeployment read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ApiDeployment given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ApiDeployment
   * @throws IOException if the JSON string is invalid with respect to ApiDeployment
   */
  public static ApiDeployment fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApiDeployment.class);
  }

  /**
   * Convert an instance of ApiDeployment to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

