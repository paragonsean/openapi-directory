# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.ixp_specific_feature_flag import IXPSpecificFeatureFlag
from openapi_server.models.route_server_network_feature import RouteServerNetworkFeature
from openapi_server import util


class NetworkFeature(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, address_families: List[str]=None, asn: int=None, available_bgp_session_types: List[str]=None, flags: List[IXPSpecificFeatureFlag]=None, fqdn: str=None, id: str=None, ip_v4: str=None, ip_v6: str=None, looking_glass_url: str=None, name: str=None, network_service: str=None, nfc_required_contact_roles: List[str]=None, required: bool=None, session_mode: str=None, type: str=None):
        """NetworkFeature - a model defined in OpenAPI

        :param address_families: The address_families of this NetworkFeature.
        :param asn: The asn of this NetworkFeature.
        :param available_bgp_session_types: The available_bgp_session_types of this NetworkFeature.
        :param flags: The flags of this NetworkFeature.
        :param fqdn: The fqdn of this NetworkFeature.
        :param id: The id of this NetworkFeature.
        :param ip_v4: The ip_v4 of this NetworkFeature.
        :param ip_v6: The ip_v6 of this NetworkFeature.
        :param looking_glass_url: The looking_glass_url of this NetworkFeature.
        :param name: The name of this NetworkFeature.
        :param network_service: The network_service of this NetworkFeature.
        :param nfc_required_contact_roles: The nfc_required_contact_roles of this NetworkFeature.
        :param required: The required of this NetworkFeature.
        :param session_mode: The session_mode of this NetworkFeature.
        :param type: The type of this NetworkFeature.
        """
        self.openapi_types = {
            'address_families': List[str],
            'asn': int,
            'available_bgp_session_types': List[str],
            'flags': List[IXPSpecificFeatureFlag],
            'fqdn': str,
            'id': str,
            'ip_v4': str,
            'ip_v6': str,
            'looking_glass_url': str,
            'name': str,
            'network_service': str,
            'nfc_required_contact_roles': List[str],
            'required': bool,
            'session_mode': str,
            'type': str
        }

        self.attribute_map = {
            'address_families': 'address_families',
            'asn': 'asn',
            'available_bgp_session_types': 'available_bgp_session_types',
            'flags': 'flags',
            'fqdn': 'fqdn',
            'id': 'id',
            'ip_v4': 'ip_v4',
            'ip_v6': 'ip_v6',
            'looking_glass_url': 'looking_glass_url',
            'name': 'name',
            'network_service': 'network_service',
            'nfc_required_contact_roles': 'nfc_required_contact_roles',
            'required': 'required',
            'session_mode': 'session_mode',
            'type': 'type'
        }

        self._address_families = address_families
        self._asn = asn
        self._available_bgp_session_types = available_bgp_session_types
        self._flags = flags
        self._fqdn = fqdn
        self._id = id
        self._ip_v4 = ip_v4
        self._ip_v6 = ip_v6
        self._looking_glass_url = looking_glass_url
        self._name = name
        self._network_service = network_service
        self._nfc_required_contact_roles = nfc_required_contact_roles
        self._required = required
        self._session_mode = session_mode
        self._type = type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'NetworkFeature':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The NetworkFeature of this NetworkFeature.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def address_families(self):
        """Gets the address_families of this NetworkFeature.

        When creating a route server feature config, remember to specify which address family or families to use:  If the route server network feature only supports `af_inet`, then the `as_set_v4` in the network feature config is required.  If only `af_inet6` is supported, then the `as_set_v6` is required.  If both `af_inet` and `af_inet6` are supported, either `as_set_v4` or `as_set_v6` is required, but both can be provided in the network service config. 

        :return: The address_families of this NetworkFeature.
        :rtype: List[str]
        """
        return self._address_families

    @address_families.setter
    def address_families(self, address_families):
        """Sets the address_families of this NetworkFeature.

        When creating a route server feature config, remember to specify which address family or families to use:  If the route server network feature only supports `af_inet`, then the `as_set_v4` in the network feature config is required.  If only `af_inet6` is supported, then the `as_set_v6` is required.  If both `af_inet` and `af_inet6` are supported, either `as_set_v4` or `as_set_v6` is required, but both can be provided in the network service config. 

        :param address_families: The address_families of this NetworkFeature.
        :type address_families: List[str]
        """
        allowed_values = ["af_inet", "af_inet6"]  # noqa: E501
        if not set(address_families).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `address_families` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(address_families) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._address_families = address_families

    @property
    def asn(self):
        """Gets the asn of this NetworkFeature.


        :return: The asn of this NetworkFeature.
        :rtype: int
        """
        return self._asn

    @asn.setter
    def asn(self, asn):
        """Sets the asn of this NetworkFeature.


        :param asn: The asn of this NetworkFeature.
        :type asn: int
        """
        if asn is None:
            raise ValueError("Invalid value for `asn`, must not be `None`")
        if asn is not None and asn < 0:
            raise ValueError("Invalid value for `asn`, must be a value greater than or equal to `0`")

        self._asn = asn

    @property
    def available_bgp_session_types(self):
        """Gets the available_bgp_session_types of this NetworkFeature.

        The route server provides the following session modes. 

        :return: The available_bgp_session_types of this NetworkFeature.
        :rtype: List[str]
        """
        return self._available_bgp_session_types

    @available_bgp_session_types.setter
    def available_bgp_session_types(self, available_bgp_session_types):
        """Sets the available_bgp_session_types of this NetworkFeature.

        The route server provides the following session modes. 

        :param available_bgp_session_types: The available_bgp_session_types of this NetworkFeature.
        :type available_bgp_session_types: List[str]
        """
        allowed_values = ["active", "passive"]  # noqa: E501
        if not set(available_bgp_session_types).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `available_bgp_session_types` [{0}], must be a subset of [{1}]"
                .format(", ".join(map(str, set(available_bgp_session_types) - set(allowed_values))),
                        ", ".join(map(str, allowed_values)))
            )

        self._available_bgp_session_types = available_bgp_session_types

    @property
    def flags(self):
        """Gets the flags of this NetworkFeature.

        A list of IXP specific feature flags. This can be used to see if e.g. RPKI hard filtering is available.

        :return: The flags of this NetworkFeature.
        :rtype: List[IXPSpecificFeatureFlag]
        """
        return self._flags

    @flags.setter
    def flags(self, flags):
        """Sets the flags of this NetworkFeature.

        A list of IXP specific feature flags. This can be used to see if e.g. RPKI hard filtering is available.

        :param flags: The flags of this NetworkFeature.
        :type flags: List[IXPSpecificFeatureFlag]
        """
        if flags is None:
            raise ValueError("Invalid value for `flags`, must not be `None`")

        self._flags = flags

    @property
    def fqdn(self):
        """Gets the fqdn of this NetworkFeature.

        The FQDN of the route server. 

        :return: The fqdn of this NetworkFeature.
        :rtype: str
        """
        return self._fqdn

    @fqdn.setter
    def fqdn(self, fqdn):
        """Sets the fqdn of this NetworkFeature.

        The FQDN of the route server. 

        :param fqdn: The fqdn of this NetworkFeature.
        :type fqdn: str
        """
        if fqdn is None:
            raise ValueError("Invalid value for `fqdn`, must not be `None`")
        if fqdn is not None and len(fqdn) > 80:
            raise ValueError("Invalid value for `fqdn`, length must be less than or equal to `80`")

        self._fqdn = fqdn

    @property
    def id(self):
        """Gets the id of this NetworkFeature.


        :return: The id of this NetworkFeature.
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this NetworkFeature.


        :param id: The id of this NetworkFeature.
        :type id: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")

        self._id = id

    @property
    def ip_v4(self):
        """Gets the ip_v4 of this NetworkFeature.

        IPv4 address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) notation. 

        :return: The ip_v4 of this NetworkFeature.
        :rtype: str
        """
        return self._ip_v4

    @ip_v4.setter
    def ip_v4(self, ip_v4):
        """Sets the ip_v4 of this NetworkFeature.

        IPv4 address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) notation. 

        :param ip_v4: The ip_v4 of this NetworkFeature.
        :type ip_v4: str
        """
        if ip_v4 is None:
            raise ValueError("Invalid value for `ip_v4`, must not be `None`")

        self._ip_v4 = ip_v4

    @property
    def ip_v6(self):
        """Gets the ip_v6 of this NetworkFeature.

        IPv6 address in hexadecimal colon separated notation. 

        :return: The ip_v6 of this NetworkFeature.
        :rtype: str
        """
        return self._ip_v6

    @ip_v6.setter
    def ip_v6(self, ip_v6):
        """Sets the ip_v6 of this NetworkFeature.

        IPv6 address in hexadecimal colon separated notation. 

        :param ip_v6: The ip_v6 of this NetworkFeature.
        :type ip_v6: str
        """
        if ip_v6 is None:
            raise ValueError("Invalid value for `ip_v6`, must not be `None`")

        self._ip_v6 = ip_v6

    @property
    def looking_glass_url(self):
        """Gets the looking_glass_url of this NetworkFeature.

        The url of the looking glass. 

        :return: The looking_glass_url of this NetworkFeature.
        :rtype: str
        """
        return self._looking_glass_url

    @looking_glass_url.setter
    def looking_glass_url(self, looking_glass_url):
        """Sets the looking_glass_url of this NetworkFeature.

        The url of the looking glass. 

        :param looking_glass_url: The looking_glass_url of this NetworkFeature.
        :type looking_glass_url: str
        """

        self._looking_glass_url = looking_glass_url

    @property
    def name(self):
        """Gets the name of this NetworkFeature.


        :return: The name of this NetworkFeature.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this NetworkFeature.


        :param name: The name of this NetworkFeature.
        :type name: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        if name is not None and len(name) > 80:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `80`")

        self._name = name

    @property
    def network_service(self):
        """Gets the network_service of this NetworkFeature.


        :return: The network_service of this NetworkFeature.
        :rtype: str
        """
        return self._network_service

    @network_service.setter
    def network_service(self, network_service):
        """Sets the network_service of this NetworkFeature.


        :param network_service: The network_service of this NetworkFeature.
        :type network_service: str
        """
        if network_service is None:
            raise ValueError("Invalid value for `network_service`, must not be `None`")

        self._network_service = network_service

    @property
    def nfc_required_contact_roles(self):
        """Gets the nfc_required_contact_roles of this NetworkFeature.

        The configuration will require at least one of each of the specified roles assigned to contacts.  The role assignments is associated with the network feature config through the `role_assignments` list property.

        :return: The nfc_required_contact_roles of this NetworkFeature.
        :rtype: List[str]
        """
        return self._nfc_required_contact_roles

    @nfc_required_contact_roles.setter
    def nfc_required_contact_roles(self, nfc_required_contact_roles):
        """Sets the nfc_required_contact_roles of this NetworkFeature.

        The configuration will require at least one of each of the specified roles assigned to contacts.  The role assignments is associated with the network feature config through the `role_assignments` list property.

        :param nfc_required_contact_roles: The nfc_required_contact_roles of this NetworkFeature.
        :type nfc_required_contact_roles: List[str]
        """

        self._nfc_required_contact_roles = nfc_required_contact_roles

    @property
    def required(self):
        """Gets the required of this NetworkFeature.


        :return: The required of this NetworkFeature.
        :rtype: bool
        """
        return self._required

    @required.setter
    def required(self, required):
        """Sets the required of this NetworkFeature.


        :param required: The required of this NetworkFeature.
        :type required: bool
        """
        if required is None:
            raise ValueError("Invalid value for `required`, must not be `None`")

        self._required = required

    @property
    def session_mode(self):
        """Gets the session_mode of this NetworkFeature.

        When creating a route server feature config, remember to specify the same session_mode as the route server. 

        :return: The session_mode of this NetworkFeature.
        :rtype: str
        """
        return self._session_mode

    @session_mode.setter
    def session_mode(self, session_mode):
        """Sets the session_mode of this NetworkFeature.

        When creating a route server feature config, remember to specify the same session_mode as the route server. 

        :param session_mode: The session_mode of this NetworkFeature.
        :type session_mode: str
        """
        allowed_values = ["public", "collector"]  # noqa: E501
        if session_mode not in allowed_values:
            raise ValueError(
                "Invalid value for `session_mode` ({0}), must be one of {1}"
                .format(session_mode, allowed_values)
            )

        self._session_mode = session_mode

    @property
    def type(self):
        """Gets the type of this NetworkFeature.


        :return: The type of this NetworkFeature.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this NetworkFeature.


        :param type: The type of this NetworkFeature.
        :type type: str
        """
        if type is None:
            raise ValueError("Invalid value for `type`, must not be `None`")

        self._type = type
