/**
 * paccurate.io
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import BoxType from './BoxType';
import BoxTypeSet from './BoxTypeSet';
import ItemSet from './ItemSet';
import Point from './Point';
import Rule from './Rule';

/**
 * The Pack model module.
 * @module model/Pack
 * @version 0.1.1
 */
class Pack {
    /**
     * Constructs a new <code>Pack</code>.
     * @alias module:model/Pack
     */
    constructor() { 
        
        Pack.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
        obj['cohortPacking'] = false;
        obj['corners'] = true;
        obj['includeImages'] = true;
        obj['includeScripts'] = true;
        obj['interlock'] = false;
        obj['layFlat'] = false;
        obj['placementStyle'] = 'default';
        obj['random'] = false;
        obj['seed'] = true;
        obj['sequenceHeatMap'] = false;
        obj['sequenceSort'] = false;
    }

    /**
     * Constructs a <code>Pack</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Pack} obj Optional instance to populate.
     * @return {module:model/Pack} The populated <code>Pack</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Pack();

            if (data.hasOwnProperty('allowableOverhang')) {
                obj['allowableOverhang'] = ApiClient.convertToType(data['allowableOverhang'], 'Number');
            }
            if (data.hasOwnProperty('boxTypeSets')) {
                obj['boxTypeSets'] = ApiClient.convertToType(data['boxTypeSets'], [BoxTypeSet]);
            }
            if (data.hasOwnProperty('boxTypes')) {
                obj['boxTypes'] = ApiClient.convertToType(data['boxTypes'], [BoxType]);
            }
            if (data.hasOwnProperty('cohortMax')) {
                obj['cohortMax'] = ApiClient.convertToType(data['cohortMax'], 'Number');
            }
            if (data.hasOwnProperty('cohortPacking')) {
                obj['cohortPacking'] = ApiClient.convertToType(data['cohortPacking'], 'Boolean');
            }
            if (data.hasOwnProperty('coordOrder')) {
                obj['coordOrder'] = ApiClient.convertToType(data['coordOrder'], ['Number']);
            }
            if (data.hasOwnProperty('corners')) {
                obj['corners'] = ApiClient.convertToType(data['corners'], 'Boolean');
            }
            if (data.hasOwnProperty('eye')) {
                obj['eye'] = ApiClient.convertToType(data['eye'], Point);
            }
            if (data.hasOwnProperty('imgSize')) {
                obj['imgSize'] = ApiClient.convertToType(data['imgSize'], 'Number');
            }
            if (data.hasOwnProperty('includeImages')) {
                obj['includeImages'] = ApiClient.convertToType(data['includeImages'], 'Boolean');
            }
            if (data.hasOwnProperty('includeScripts')) {
                obj['includeScripts'] = ApiClient.convertToType(data['includeScripts'], 'Boolean');
            }
            if (data.hasOwnProperty('interlock')) {
                obj['interlock'] = ApiClient.convertToType(data['interlock'], 'Boolean');
            }
            if (data.hasOwnProperty('itemSets')) {
                obj['itemSets'] = ApiClient.convertToType(data['itemSets'], [ItemSet]);
            }
            if (data.hasOwnProperty('key')) {
                obj['key'] = ApiClient.convertToType(data['key'], 'String');
            }
            if (data.hasOwnProperty('layFlat')) {
                obj['layFlat'] = ApiClient.convertToType(data['layFlat'], 'Boolean');
            }
            if (data.hasOwnProperty('maxSequenceDistance')) {
                obj['maxSequenceDistance'] = ApiClient.convertToType(data['maxSequenceDistance'], 'Number');
            }
            if (data.hasOwnProperty('n')) {
                obj['n'] = ApiClient.convertToType(data['n'], 'Number');
            }
            if (data.hasOwnProperty('packOrigin')) {
                obj['packOrigin'] = ApiClient.convertToType(data['packOrigin'], Point);
            }
            if (data.hasOwnProperty('placementStyle')) {
                obj['placementStyle'] = ApiClient.convertToType(data['placementStyle'], 'String');
            }
            if (data.hasOwnProperty('random')) {
                obj['random'] = ApiClient.convertToType(data['random'], 'Boolean');
            }
            if (data.hasOwnProperty('randomMaxDimension')) {
                obj['randomMaxDimension'] = ApiClient.convertToType(data['randomMaxDimension'], 'Number');
            }
            if (data.hasOwnProperty('randomMaxWeight')) {
                obj['randomMaxWeight'] = ApiClient.convertToType(data['randomMaxWeight'], 'Number');
            }
            if (data.hasOwnProperty('rules')) {
                obj['rules'] = ApiClient.convertToType(data['rules'], [Rule]);
            }
            if (data.hasOwnProperty('seed')) {
                obj['seed'] = ApiClient.convertToType(data['seed'], 'Boolean');
            }
            if (data.hasOwnProperty('sequenceHeatMap')) {
                obj['sequenceHeatMap'] = ApiClient.convertToType(data['sequenceHeatMap'], 'Boolean');
            }
            if (data.hasOwnProperty('sequenceSort')) {
                obj['sequenceSort'] = ApiClient.convertToType(data['sequenceSort'], 'Boolean');
            }
            if (data.hasOwnProperty('template')) {
                obj['template'] = ApiClient.convertToType(data['template'], 'String');
            }
            if (data.hasOwnProperty('usableSpace')) {
                obj['usableSpace'] = ApiClient.convertToType(data['usableSpace'], 'Number');
            }
            if (data.hasOwnProperty('zone')) {
                obj['zone'] = ApiClient.convertToType(data['zone'], 'Number');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Pack</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Pack</code>.
     */
    static validateJSON(data) {
        // ensure the json data is an array
        if (!Array.isArray(data['boxTypeSets'])) {
            throw new Error("Expected the field `boxTypeSets` to be an array in the JSON data but got " + data['boxTypeSets']);
        }
        if (data['boxTypes']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['boxTypes'])) {
                throw new Error("Expected the field `boxTypes` to be an array in the JSON data but got " + data['boxTypes']);
            }
            // validate the optional field `boxTypes` (array)
            for (const item of data['boxTypes']) {
                BoxType.validateJSON(item);
            };
        }
        // ensure the json data is an array
        if (!Array.isArray(data['coordOrder'])) {
            throw new Error("Expected the field `coordOrder` to be an array in the JSON data but got " + data['coordOrder']);
        }
        // validate the optional field `eye`
        if (data['eye']) { // data not null
          Point.validateJSON(data['eye']);
        }
        if (data['itemSets']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['itemSets'])) {
                throw new Error("Expected the field `itemSets` to be an array in the JSON data but got " + data['itemSets']);
            }
            // validate the optional field `itemSets` (array)
            for (const item of data['itemSets']) {
                ItemSet.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['key'] && !(typeof data['key'] === 'string' || data['key'] instanceof String)) {
            throw new Error("Expected the field `key` to be a primitive type in the JSON string but got " + data['key']);
        }
        // validate the optional field `packOrigin`
        if (data['packOrigin']) { // data not null
          Point.validateJSON(data['packOrigin']);
        }
        // ensure the json data is a string
        if (data['placementStyle'] && !(typeof data['placementStyle'] === 'string' || data['placementStyle'] instanceof String)) {
            throw new Error("Expected the field `placementStyle` to be a primitive type in the JSON string but got " + data['placementStyle']);
        }
        if (data['rules']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['rules'])) {
                throw new Error("Expected the field `rules` to be an array in the JSON data but got " + data['rules']);
            }
            // validate the optional field `rules` (array)
            for (const item of data['rules']) {
                Rule.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['template'] && !(typeof data['template'] === 'string' || data['template'] instanceof String)) {
            throw new Error("Expected the field `template` to be a primitive type in the JSON string but got " + data['template']);
        }

        return true;
    }


}



/**
 * The amount an item can overhang lower items that it is placed upon. The units are whatever units the box and item dimensions are given in. By convention, inches.
 * @member {Number} allowableOverhang
 */
Pack.prototype['allowableOverhang'] = undefined;

/**
 * predefined box types to be used, separated by commas. Will be overridden by boxTypes. Acceptable values are <ul><li>\"fedex\"--FedEx OneRate</li><li>\"usps\"--USPS Priority Flat Rate</li><li>\"pallet\"--full-, half-, and quarter-sized 48\"x40\" pallets.
 * @member {Array.<module:model/BoxTypeSet>} boxTypeSets
 */
Pack.prototype['boxTypeSets'] = undefined;

/**
 * box type definitions for packing, will override boxTypeSets defined.
 * @member {Array.<module:model/BoxType>} boxTypes
 */
Pack.prototype['boxTypes'] = undefined;

/**
 * the maximum number of contiguous cohorts for a given item type within a single container. E.g., if you pack 40 chairs in a single container, a cohortMax of 2 could yield one (all 40 chairs in a single block if space is availabe) or two (say, 25 chairs in one corner and 15 in the other) contiguous cohorts.
 * @member {Number} cohortMax
 */
Pack.prototype['cohortMax'] = undefined;

/**
 * if selected, will ensure that all like items will be packed together, in no more than [cohortMax] different groups within a single container.
 * @member {Boolean} cohortPacking
 * @default false
 */
Pack.prototype['cohortPacking'] = false;

/**
 * If placementStyle is set to \"default\", coordOrder sets the placement priority of axes ascendingly. \"0,1,2\" would search for placement points along the Z(length,\"2\"), then Y(width,\"1\"), and finally X(height\"0\"). Keep in mind that in the default rendering the \"up\" direction is X and the other axes follow the right-hand rule. This is useful for different packing methods. E.g., Utilizing \"2,0,1\" would pack a shipping container first in the Y(width) direction, then in the X(height) direction, and finally in the Z(length) direction, replication a floor-to-ceiling, front-to-back loading method.
 * @member {Array.<Number>} coordOrder
 */
Pack.prototype['coordOrder'] = undefined;

/**
 * only pack items at valid corner points of other items (optimal)
 * @member {Boolean} corners
 * @default true
 */
Pack.prototype['corners'] = true;

/**
 * The x,y,z coordinates of the virtual eye looking at the package for visualization purposes. Default is isometric, \"1,1,1\". To generate a side view, one could use \"0.001,1.0,0.001\".
 * @member {module:model/Point} eye
 */
Pack.prototype['eye'] = undefined;

/**
 * width of rendered SVGs in pixels.
 * @member {Number} imgSize
 */
Pack.prototype['imgSize'] = undefined;

/**
 * include inline images, default is always on
 * @member {Boolean} includeImages
 * @default true
 */
Pack.prototype['includeImages'] = true;

/**
 * include inline javascripts and styles for base template
 * @member {Boolean} includeScripts
 * @default true
 */
Pack.prototype['includeScripts'] = true;

/**
 * alternates layFlat orientation by layer, so as to create an interlocked placement pattern and improve item stability.
 * @member {Boolean} interlock
 * @default false
 */
Pack.prototype['interlock'] = false;

/**
 * item set definitions if not creating random items.
 * @member {Array.<module:model/ItemSet>} itemSets
 */
Pack.prototype['itemSets'] = undefined;

/**
 * issued API key.
 * @member {String} key
 */
Pack.prototype['key'] = undefined;

/**
 * aligns all items laying flat. If possible, it may create a \"brick-laying\" pattern to increase stability.
 * @member {Boolean} layFlat
 * @default false
 */
Pack.prototype['layFlat'] = false;

/**
 * This is the maximum distance allowable between two sequence values of items packed in a common box. E.g., \"Distance\" for an item sequence composed of aisle/bin combinations of \"0401\" and \"1228\" has a sequence distance of \\|1228 - 401\\| = 827
 * @member {Number} maxSequenceDistance
 */
Pack.prototype['maxSequenceDistance'] = undefined;

/**
 * number of random items to generate and the quantity of each if \"random\" is set to true. a value of 5 would create 5 different items with a quantity of 5 each, making the total item quantity equal to n&sup2;
 * @member {Number} n
 */
Pack.prototype['n'] = undefined;

/**
 * the x,y,z coordinates of an optional packing origin. A packing origin is used to create more balanced packing for situations where load needs to be considered. E.g., for a 40\"x48\" pallet, a packOrigin representing the middle of the pallet, \"0,20,24\", would cause placement to minimize the distance of the packed items from the center of the pallet.
 * @member {module:model/Point} packOrigin
 */
Pack.prototype['packOrigin'] = undefined;

/**
 * How to place items. 'default' will defer to coordOrder, 'corner' minimizes distance to rear, bottom corner, 'wedge' minimizes distance to middle of bottom, back edge, 'mound' minimizes distance to center of carton bottom.
 * @member {module:model/Pack.PlacementStyleEnum} placementStyle
 * @default 'default'
 */
Pack.prototype['placementStyle'] = 'default';

/**
 * create random items
 * @member {Boolean} random
 * @default false
 */
Pack.prototype['random'] = false;

/**
 * maximum item dimension along a single axis for randomly generated items.
 * @member {Number} randomMaxDimension
 */
Pack.prototype['randomMaxDimension'] = undefined;

/**
 * maximum item weight for randomly generated items.
 * @member {Number} randomMaxWeight
 */
Pack.prototype['randomMaxWeight'] = undefined;

/**
 * Array of packing rules.
 * @member {Array.<module:model/Rule>} rules
 */
Pack.prototype['rules'] = undefined;

/**
 * if random is selected, seed the random number generator to deterministically generate random items to pack.
 * @member {Boolean} seed
 * @default true
 */
Pack.prototype['seed'] = true;

/**
 * Colorize items solely by their sequence value, light when sequence is high, dark when it is low. Useful for indicating item bin location, weight, or other sequence property that may not be apparent from the default visualization.
 * @member {Boolean} sequenceHeatMap
 * @default false
 */
Pack.prototype['sequenceHeatMap'] = false;

/**
 * Whether or not the items should be initially sorted by their sequence value instead of their volume. This is not always useful, as the default \"biggest-first\" volume sort is very effective for items, and constraining by maxSequenceDistance is applied regardless of this field. That said, for doing custom pre-sorts such as weight-based instead of volume based, this value should be set to true.
 * @member {Boolean} sequenceSort
 * @default false
 */
Pack.prototype['sequenceSort'] = false;

/**
 * template name for markup generation.
 * @member {module:model/Pack.TemplateEnum} template
 */
Pack.prototype['template'] = undefined;

/**
 * estimate of percentage space in boxes that is usable, i.e., not packing material.
 * @member {Number} usableSpace
 */
Pack.prototype['usableSpace'] = undefined;

/**
 * <b>[experimental]</b> the shipping zone in order to use basic zone-based price optimization.
 * @member {Number} zone
 */
Pack.prototype['zone'] = undefined;





/**
 * Allowed values for the <code>placementStyle</code> property.
 * @enum {String}
 * @readonly
 */
Pack['PlacementStyleEnum'] = {

    /**
     * value: "default"
     * @const
     */
    "default": "default",

    /**
     * value: "corner"
     * @const
     */
    "corner": "corner",

    /**
     * value: "wedge"
     * @const
     */
    "wedge": "wedge",

    /**
     * value: "mound"
     * @const
     */
    "mound": "mound",

    /**
     * value: "orb"
     * @const
     */
    "orb": "orb"
};


/**
 * Allowed values for the <code>template</code> property.
 * @enum {String}
 * @readonly
 */
Pack['TemplateEnum'] = {

    /**
     * value: "demo.tmpl"
     * @const
     */
    "demo.tmpl": "demo.tmpl",

    /**
     * value: "shipapp.tmpl"
     * @const
     */
    "shipapp.tmpl": "shipapp.tmpl",

    /**
     * value: "boat.tmpl"
     * @const
     */
    "boat.tmpl": "boat.tmpl"
};



export default Pack;

