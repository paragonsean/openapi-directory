/**
 * paccurate.io
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The RateTable model module.
 * @module model/RateTable
 * @version 0.1.1
 */
class RateTable {
    /**
     * Constructs a new <code>RateTable</code>.
     * @alias module:model/RateTable
     */
    constructor() { 
        
        RateTable.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>RateTable</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/RateTable} obj Optional instance to populate.
     * @return {module:model/RateTable} The populated <code>RateTable</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new RateTable();

            if (data.hasOwnProperty('basePrice')) {
                obj['basePrice'] = ApiClient.convertToType(data['basePrice'], 'Number');
            }
            if (data.hasOwnProperty('carrier')) {
                obj['carrier'] = ApiClient.convertToType(data['carrier'], 'String');
            }
            if (data.hasOwnProperty('dimFactor')) {
                obj['dimFactor'] = ApiClient.convertToType(data['dimFactor'], 'Number');
            }
            if (data.hasOwnProperty('priceIncreaseRate')) {
                obj['priceIncreaseRate'] = ApiClient.convertToType(data['priceIncreaseRate'], 'Number');
            }
            if (data.hasOwnProperty('rates')) {
                obj['rates'] = ApiClient.convertToType(data['rates'], ['Number']);
            }
            if (data.hasOwnProperty('service')) {
                obj['service'] = ApiClient.convertToType(data['service'], 'String');
            }
            if (data.hasOwnProperty('weights')) {
                obj['weights'] = ApiClient.convertToType(data['weights'], ['Number']);
            }
            if (data.hasOwnProperty('zone')) {
                obj['zone'] = ApiClient.convertToType(data['zone'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>RateTable</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>RateTable</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['carrier'] && !(typeof data['carrier'] === 'string' || data['carrier'] instanceof String)) {
            throw new Error("Expected the field `carrier` to be a primitive type in the JSON string but got " + data['carrier']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['rates'])) {
            throw new Error("Expected the field `rates` to be an array in the JSON data but got " + data['rates']);
        }
        // ensure the json data is a string
        if (data['service'] && !(typeof data['service'] === 'string' || data['service'] instanceof String)) {
            throw new Error("Expected the field `service` to be a primitive type in the JSON string but got " + data['service']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['weights'])) {
            throw new Error("Expected the field `weights` to be an array in the JSON data but got " + data['weights']);
        }
        // ensure the json data is a string
        if (data['zone'] && !(typeof data['zone'] === 'string' || data['zone'] instanceof String)) {
            throw new Error("Expected the field `zone` to be a primitive type in the JSON string but got " + data['zone']);
        }

        return true;
    }


}



/**
 * The basePrice can be found by estimating the lowest weight-based rate available for a given service, in the example above, solving for basePrice for a $10, 1lb package with the already-solved priceIncreaseRate yields <pre>$10 = $5/lb * 1lb + basePrice<br/>$10 = $5 + basePrice<br/>basePrice = $5</pre>
 * @member {Number} basePrice
 */
RateTable.prototype['basePrice'] = undefined;

/**
 * carrier name for rate table to use
 * @member {String} carrier
 */
RateTable.prototype['carrier'] = undefined;

/**
 * This is the Dimensional Weight divisor. It is given in units of volume per unit weight, e.g., the standard of \"139\" represents 139 cubic inches per pound, and is used to convert the total volume of a carton into a functional minimum weight to be used when rating the carton. E.g., a carton with dimensions 10\" x 10\" x 13.9\" would yield a volume of 1390 cubic inches. This yields <pre>cartonEffectiveMinimumWeight = 1390in&sup3; / 139in&sup3;/lb<br/>cartonEffectiveMinimumWeight = 10lbs</pre>
 * @member {Number} dimFactor
 */
RateTable.prototype['dimFactor'] = undefined;

/**
 * Instead of providing the full rate table, you can list a carton \"basePrice\" and a carton \"priceIncreaseRate\". These two values will be used in a simple linear model to guess carton price, i.e., <pre>cartonPrice = priceIncreaseRate * cartonWeight + basePrice</pre> Oftentimes, this will be enough to get accurate carton selections without needing to send complete customer-based rates. It's worth considering, as the prices are only estimates to be used in carton selection, with final rating of cartons happening outside of paccurate. This is the predicted rate of increase for a weight-based pricing model. The simplest way to find a servicable value is to take <pre>priceIncreaseRate = (maximumPrice - minimumPrice)/(maximumWeight - minimumWeight)</pre> In the example above, this would yield <pre>priceIncreaseRate = ($20-$10)/(3lbs-1lb)<br/>priceIncreaseRate = $10/2lbs<br/>priceIncreaseRate = $5/lb</pre>
 * @member {Number} priceIncreaseRate
 */
RateTable.prototype['priceIncreaseRate'] = undefined;

/**
 * list of prices to use for the weight that corresponds to its index, e.g., [10, 15, 20] would be $10 for 1lb, $15 for 2lbs, $20 for 3lbs.
 * @member {Array.<Number>} rates
 */
RateTable.prototype['rates'] = undefined;

/**
 * service name for rate table to use
 * @member {String} service
 */
RateTable.prototype['service'] = undefined;

/**
 * list of weights to use for the rate that corresponds to its index, e.g., [1, 2, 3] would mean 1lb for the minimum rate ($10), 2lbs for the second rate ($15), and 3lbs for the highest rate ($20). Note that if the highest value from this list is less than the weightMax of the carton, all carton weights exceeding the maximum from this list up to the carton weightMax will not pro-rate but will be estimated at the maximum value in the rate table.
 * @member {Array.<Number>} weights
 */
RateTable.prototype['weights'] = undefined;

/**
 * zone of rate table to use
 * @member {String} zone
 */
RateTable.prototype['zone'] = undefined;






export default RateTable;

