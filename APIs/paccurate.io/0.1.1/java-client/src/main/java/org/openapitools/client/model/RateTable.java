/*
 * paccurate.io
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * RateTable
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:43:44.933917-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RateTable {
  public static final String SERIALIZED_NAME_BASE_PRICE = "basePrice";
  @SerializedName(SERIALIZED_NAME_BASE_PRICE)
  private BigDecimal basePrice;

  public static final String SERIALIZED_NAME_CARRIER = "carrier";
  @SerializedName(SERIALIZED_NAME_CARRIER)
  private String carrier;

  public static final String SERIALIZED_NAME_DIM_FACTOR = "dimFactor";
  @SerializedName(SERIALIZED_NAME_DIM_FACTOR)
  private BigDecimal dimFactor;

  public static final String SERIALIZED_NAME_PRICE_INCREASE_RATE = "priceIncreaseRate";
  @SerializedName(SERIALIZED_NAME_PRICE_INCREASE_RATE)
  private BigDecimal priceIncreaseRate;

  public static final String SERIALIZED_NAME_RATES = "rates";
  @SerializedName(SERIALIZED_NAME_RATES)
  private List<BigDecimal> rates = new ArrayList<>();

  public static final String SERIALIZED_NAME_SERVICE = "service";
  @SerializedName(SERIALIZED_NAME_SERVICE)
  private String service;

  public static final String SERIALIZED_NAME_WEIGHTS = "weights";
  @SerializedName(SERIALIZED_NAME_WEIGHTS)
  private List<BigDecimal> weights = new ArrayList<>();

  public static final String SERIALIZED_NAME_ZONE = "zone";
  @SerializedName(SERIALIZED_NAME_ZONE)
  private String zone;

  public RateTable() {
  }

  public RateTable basePrice(BigDecimal basePrice) {
    this.basePrice = basePrice;
    return this;
  }

  /**
   * The basePrice can be found by estimating the lowest weight-based rate available for a given service, in the example above, solving for basePrice for a $10, 1lb package with the already-solved priceIncreaseRate yields &lt;pre&gt;$10 &#x3D; $5/lb * 1lb + basePrice&lt;br/&gt;$10 &#x3D; $5 + basePrice&lt;br/&gt;basePrice &#x3D; $5&lt;/pre&gt;
   * @return basePrice
   */
  @javax.annotation.Nullable
  public BigDecimal getBasePrice() {
    return basePrice;
  }

  public void setBasePrice(BigDecimal basePrice) {
    this.basePrice = basePrice;
  }


  public RateTable carrier(String carrier) {
    this.carrier = carrier;
    return this;
  }

  /**
   * carrier name for rate table to use
   * @return carrier
   */
  @javax.annotation.Nullable
  public String getCarrier() {
    return carrier;
  }

  public void setCarrier(String carrier) {
    this.carrier = carrier;
  }


  public RateTable dimFactor(BigDecimal dimFactor) {
    this.dimFactor = dimFactor;
    return this;
  }

  /**
   * This is the Dimensional Weight divisor. It is given in units of volume per unit weight, e.g., the standard of \&quot;139\&quot; represents 139 cubic inches per pound, and is used to convert the total volume of a carton into a functional minimum weight to be used when rating the carton. E.g., a carton with dimensions 10\&quot; x 10\&quot; x 13.9\&quot; would yield a volume of 1390 cubic inches. This yields &lt;pre&gt;cartonEffectiveMinimumWeight &#x3D; 1390in&amp;sup3; / 139in&amp;sup3;/lb&lt;br/&gt;cartonEffectiveMinimumWeight &#x3D; 10lbs&lt;/pre&gt;
   * @return dimFactor
   */
  @javax.annotation.Nullable
  public BigDecimal getDimFactor() {
    return dimFactor;
  }

  public void setDimFactor(BigDecimal dimFactor) {
    this.dimFactor = dimFactor;
  }


  public RateTable priceIncreaseRate(BigDecimal priceIncreaseRate) {
    this.priceIncreaseRate = priceIncreaseRate;
    return this;
  }

  /**
   * Instead of providing the full rate table, you can list a carton \&quot;basePrice\&quot; and a carton \&quot;priceIncreaseRate\&quot;. These two values will be used in a simple linear model to guess carton price, i.e., &lt;pre&gt;cartonPrice &#x3D; priceIncreaseRate * cartonWeight + basePrice&lt;/pre&gt; Oftentimes, this will be enough to get accurate carton selections without needing to send complete customer-based rates. It&#39;s worth considering, as the prices are only estimates to be used in carton selection, with final rating of cartons happening outside of paccurate. This is the predicted rate of increase for a weight-based pricing model. The simplest way to find a servicable value is to take &lt;pre&gt;priceIncreaseRate &#x3D; (maximumPrice - minimumPrice)/(maximumWeight - minimumWeight)&lt;/pre&gt; In the example above, this would yield &lt;pre&gt;priceIncreaseRate &#x3D; ($20-$10)/(3lbs-1lb)&lt;br/&gt;priceIncreaseRate &#x3D; $10/2lbs&lt;br/&gt;priceIncreaseRate &#x3D; $5/lb&lt;/pre&gt;
   * @return priceIncreaseRate
   */
  @javax.annotation.Nullable
  public BigDecimal getPriceIncreaseRate() {
    return priceIncreaseRate;
  }

  public void setPriceIncreaseRate(BigDecimal priceIncreaseRate) {
    this.priceIncreaseRate = priceIncreaseRate;
  }


  public RateTable rates(List<BigDecimal> rates) {
    this.rates = rates;
    return this;
  }

  public RateTable addRatesItem(BigDecimal ratesItem) {
    if (this.rates == null) {
      this.rates = new ArrayList<>();
    }
    this.rates.add(ratesItem);
    return this;
  }

  /**
   * list of prices to use for the weight that corresponds to its index, e.g., [10, 15, 20] would be $10 for 1lb, $15 for 2lbs, $20 for 3lbs.
   * @return rates
   */
  @javax.annotation.Nullable
  public List<BigDecimal> getRates() {
    return rates;
  }

  public void setRates(List<BigDecimal> rates) {
    this.rates = rates;
  }


  public RateTable service(String service) {
    this.service = service;
    return this;
  }

  /**
   * service name for rate table to use
   * @return service
   */
  @javax.annotation.Nullable
  public String getService() {
    return service;
  }

  public void setService(String service) {
    this.service = service;
  }


  public RateTable weights(List<BigDecimal> weights) {
    this.weights = weights;
    return this;
  }

  public RateTable addWeightsItem(BigDecimal weightsItem) {
    if (this.weights == null) {
      this.weights = new ArrayList<>();
    }
    this.weights.add(weightsItem);
    return this;
  }

  /**
   * list of weights to use for the rate that corresponds to its index, e.g., [1, 2, 3] would mean 1lb for the minimum rate ($10), 2lbs for the second rate ($15), and 3lbs for the highest rate ($20). Note that if the highest value from this list is less than the weightMax of the carton, all carton weights exceeding the maximum from this list up to the carton weightMax will not pro-rate but will be estimated at the maximum value in the rate table.
   * @return weights
   */
  @javax.annotation.Nullable
  public List<BigDecimal> getWeights() {
    return weights;
  }

  public void setWeights(List<BigDecimal> weights) {
    this.weights = weights;
  }


  public RateTable zone(String zone) {
    this.zone = zone;
    return this;
  }

  /**
   * zone of rate table to use
   * @return zone
   */
  @javax.annotation.Nullable
  public String getZone() {
    return zone;
  }

  public void setZone(String zone) {
    this.zone = zone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RateTable rateTable = (RateTable) o;
    return Objects.equals(this.basePrice, rateTable.basePrice) &&
        Objects.equals(this.carrier, rateTable.carrier) &&
        Objects.equals(this.dimFactor, rateTable.dimFactor) &&
        Objects.equals(this.priceIncreaseRate, rateTable.priceIncreaseRate) &&
        Objects.equals(this.rates, rateTable.rates) &&
        Objects.equals(this.service, rateTable.service) &&
        Objects.equals(this.weights, rateTable.weights) &&
        Objects.equals(this.zone, rateTable.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(basePrice, carrier, dimFactor, priceIncreaseRate, rates, service, weights, zone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RateTable {\n");
    sb.append("    basePrice: ").append(toIndentedString(basePrice)).append("\n");
    sb.append("    carrier: ").append(toIndentedString(carrier)).append("\n");
    sb.append("    dimFactor: ").append(toIndentedString(dimFactor)).append("\n");
    sb.append("    priceIncreaseRate: ").append(toIndentedString(priceIncreaseRate)).append("\n");
    sb.append("    rates: ").append(toIndentedString(rates)).append("\n");
    sb.append("    service: ").append(toIndentedString(service)).append("\n");
    sb.append("    weights: ").append(toIndentedString(weights)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("basePrice");
    openapiFields.add("carrier");
    openapiFields.add("dimFactor");
    openapiFields.add("priceIncreaseRate");
    openapiFields.add("rates");
    openapiFields.add("service");
    openapiFields.add("weights");
    openapiFields.add("zone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RateTable
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RateTable.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RateTable is not found in the empty JSON string", RateTable.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RateTable.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RateTable` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("carrier") != null && !jsonObj.get("carrier").isJsonNull()) && !jsonObj.get("carrier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `carrier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("carrier").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("rates") != null && !jsonObj.get("rates").isJsonNull() && !jsonObj.get("rates").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `rates` to be an array in the JSON string but got `%s`", jsonObj.get("rates").toString()));
      }
      if ((jsonObj.get("service") != null && !jsonObj.get("service").isJsonNull()) && !jsonObj.get("service").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `service` to be a primitive type in the JSON string but got `%s`", jsonObj.get("service").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("weights") != null && !jsonObj.get("weights").isJsonNull() && !jsonObj.get("weights").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `weights` to be an array in the JSON string but got `%s`", jsonObj.get("weights").toString()));
      }
      if ((jsonObj.get("zone") != null && !jsonObj.get("zone").isJsonNull()) && !jsonObj.get("zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RateTable.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RateTable' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RateTable> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RateTable.class));

       return (TypeAdapter<T>) new TypeAdapter<RateTable>() {
           @Override
           public void write(JsonWriter out, RateTable value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RateTable read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RateTable given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RateTable
   * @throws IOException if the JSON string is invalid with respect to RateTable
   */
  public static RateTable fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RateTable.class);
  }

  /**
   * Convert an instance of RateTable to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

