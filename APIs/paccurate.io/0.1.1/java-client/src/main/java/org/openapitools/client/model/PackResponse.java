/*
 * paccurate.io
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Box;
import org.openapitools.client.model.Item;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * PackResponse
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:43:44.933917-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PackResponse {
  public static final String SERIALIZED_NAME_BOXES = "boxes";
  @SerializedName(SERIALIZED_NAME_BOXES)
  private List<Box> boxes = new ArrayList<>();

  public static final String SERIALIZED_NAME_BUILT = "built";
  @SerializedName(SERIALIZED_NAME_BUILT)
  private String built;

  public static final String SERIALIZED_NAME_LEFTOVERS = "leftovers";
  @SerializedName(SERIALIZED_NAME_LEFTOVERS)
  private List<Item> leftovers = new ArrayList<>();

  public static final String SERIALIZED_NAME_LEN_BOXES = "lenBoxes";
  @SerializedName(SERIALIZED_NAME_LEN_BOXES)
  private Integer lenBoxes;

  public static final String SERIALIZED_NAME_LEN_ITEMS = "lenItems";
  @SerializedName(SERIALIZED_NAME_LEN_ITEMS)
  private Integer lenItems;

  public static final String SERIALIZED_NAME_LEN_LEFTOVERS = "lenLeftovers";
  @SerializedName(SERIALIZED_NAME_LEN_LEFTOVERS)
  private Integer lenLeftovers;

  public static final String SERIALIZED_NAME_PACK_TIME = "packTime";
  @SerializedName(SERIALIZED_NAME_PACK_TIME)
  private BigDecimal packTime;

  public static final String SERIALIZED_NAME_RENDER_TIME = "renderTime";
  @SerializedName(SERIALIZED_NAME_RENDER_TIME)
  private BigDecimal renderTime;

  public static final String SERIALIZED_NAME_SCRIPTS = "scripts";
  @SerializedName(SERIALIZED_NAME_SCRIPTS)
  private String scripts;

  public static final String SERIALIZED_NAME_STYLES = "styles";
  @SerializedName(SERIALIZED_NAME_STYLES)
  private String styles;

  public static final String SERIALIZED_NAME_SVGS = "svgs";
  @SerializedName(SERIALIZED_NAME_SVGS)
  private String svgs;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public static final String SERIALIZED_NAME_TOTAL_COST = "totalCost";
  @SerializedName(SERIALIZED_NAME_TOTAL_COST)
  private Integer totalCost;

  public static final String SERIALIZED_NAME_TOTAL_TIME = "totalTime";
  @SerializedName(SERIALIZED_NAME_TOTAL_TIME)
  private BigDecimal totalTime;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public PackResponse() {
  }

  public PackResponse boxes(List<Box> boxes) {
    this.boxes = boxes;
    return this;
  }

  public PackResponse addBoxesItem(Box boxesItem) {
    if (this.boxes == null) {
      this.boxes = new ArrayList<>();
    }
    this.boxes.add(boxesItem);
    return this;
  }

  /**
   * List of boxes, packed, with their contained items.
   * @return boxes
   */
  @javax.annotation.Nullable
  public List<Box> getBoxes() {
    return boxes;
  }

  public void setBoxes(List<Box> boxes) {
    this.boxes = boxes;
  }


  public PackResponse built(String built) {
    this.built = built;
    return this;
  }

  /**
   * build timestamp of engine.
   * @return built
   */
  @javax.annotation.Nullable
  public String getBuilt() {
    return built;
  }

  public void setBuilt(String built) {
    this.built = built;
  }


  public PackResponse leftovers(List<Item> leftovers) {
    this.leftovers = leftovers;
    return this;
  }

  public PackResponse addLeftoversItem(Item leftoversItem) {
    if (this.leftovers == null) {
      this.leftovers = new ArrayList<>();
    }
    this.leftovers.add(leftoversItem);
    return this;
  }

  /**
   * items left over that could not be packed into any available boxes.
   * @return leftovers
   */
  @javax.annotation.Nullable
  public List<Item> getLeftovers() {
    return leftovers;
  }

  public void setLeftovers(List<Item> leftovers) {
    this.leftovers = leftovers;
  }


  public PackResponse lenBoxes(Integer lenBoxes) {
    this.lenBoxes = lenBoxes;
    return this;
  }

  /**
   * cardinality of all packed boxes
   * @return lenBoxes
   */
  @javax.annotation.Nullable
  public Integer getLenBoxes() {
    return lenBoxes;
  }

  public void setLenBoxes(Integer lenBoxes) {
    this.lenBoxes = lenBoxes;
  }


  public PackResponse lenItems(Integer lenItems) {
    this.lenItems = lenItems;
    return this;
  }

  /**
   * cardinality of all items
   * @return lenItems
   */
  @javax.annotation.Nullable
  public Integer getLenItems() {
    return lenItems;
  }

  public void setLenItems(Integer lenItems) {
    this.lenItems = lenItems;
  }


  public PackResponse lenLeftovers(Integer lenLeftovers) {
    this.lenLeftovers = lenLeftovers;
    return this;
  }

  /**
   * cardinality of items unabled to be packed
   * @return lenLeftovers
   */
  @javax.annotation.Nullable
  public Integer getLenLeftovers() {
    return lenLeftovers;
  }

  public void setLenLeftovers(Integer lenLeftovers) {
    this.lenLeftovers = lenLeftovers;
  }


  public PackResponse packTime(BigDecimal packTime) {
    this.packTime = packTime;
    return this;
  }

  /**
   * seconds spent in packing
   * @return packTime
   */
  @javax.annotation.Nullable
  public BigDecimal getPackTime() {
    return packTime;
  }

  public void setPackTime(BigDecimal packTime) {
    this.packTime = packTime;
  }


  public PackResponse renderTime(BigDecimal renderTime) {
    this.renderTime = renderTime;
    return this;
  }

  /**
   * seconds spent in rendering and placement instruction creation of packing solution
   * @return renderTime
   */
  @javax.annotation.Nullable
  public BigDecimal getRenderTime() {
    return renderTime;
  }

  public void setRenderTime(BigDecimal renderTime) {
    this.renderTime = renderTime;
  }


  public PackResponse scripts(String scripts) {
    this.scripts = scripts;
    return this;
  }

  /**
   * additional javascripts for any image loading.
   * @return scripts
   */
  @javax.annotation.Nullable
  public String getScripts() {
    return scripts;
  }

  public void setScripts(String scripts) {
    this.scripts = scripts;
  }


  public PackResponse styles(String styles) {
    this.styles = styles;
    return this;
  }

  /**
   * additional styles for pack images
   * @return styles
   */
  @javax.annotation.Nullable
  public String getStyles() {
    return styles;
  }

  public void setStyles(String styles) {
    this.styles = styles;
  }


  public PackResponse svgs(String svgs) {
    this.svgs = svgs;
    return this;
  }

  /**
   * all box SVG images
   * @return svgs
   */
  @javax.annotation.Nullable
  public String getSvgs() {
    return svgs;
  }

  public void setSvgs(String svgs) {
    this.svgs = svgs;
  }


  public PackResponse title(String title) {
    this.title = title;
    return this;
  }

  /**
   * title of packing result, when applicable.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }


  public PackResponse totalCost(Integer totalCost) {
    this.totalCost = totalCost;
    return this;
  }

  /**
   * total estimated cost of all packed boxes, when applicable, in cents.
   * @return totalCost
   */
  @javax.annotation.Nullable
  public Integer getTotalCost() {
    return totalCost;
  }

  public void setTotalCost(Integer totalCost) {
    this.totalCost = totalCost;
  }


  public PackResponse totalTime(BigDecimal totalTime) {
    this.totalTime = totalTime;
    return this;
  }

  /**
   * seconds spent generating response, total.
   * @return totalTime
   */
  @javax.annotation.Nullable
  public BigDecimal getTotalTime() {
    return totalTime;
  }

  public void setTotalTime(BigDecimal totalTime) {
    this.totalTime = totalTime;
  }


  public PackResponse version(String version) {
    this.version = version;
    return this;
  }

  /**
   * version of engine
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PackResponse packResponse = (PackResponse) o;
    return Objects.equals(this.boxes, packResponse.boxes) &&
        Objects.equals(this.built, packResponse.built) &&
        Objects.equals(this.leftovers, packResponse.leftovers) &&
        Objects.equals(this.lenBoxes, packResponse.lenBoxes) &&
        Objects.equals(this.lenItems, packResponse.lenItems) &&
        Objects.equals(this.lenLeftovers, packResponse.lenLeftovers) &&
        Objects.equals(this.packTime, packResponse.packTime) &&
        Objects.equals(this.renderTime, packResponse.renderTime) &&
        Objects.equals(this.scripts, packResponse.scripts) &&
        Objects.equals(this.styles, packResponse.styles) &&
        Objects.equals(this.svgs, packResponse.svgs) &&
        Objects.equals(this.title, packResponse.title) &&
        Objects.equals(this.totalCost, packResponse.totalCost) &&
        Objects.equals(this.totalTime, packResponse.totalTime) &&
        Objects.equals(this.version, packResponse.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(boxes, built, leftovers, lenBoxes, lenItems, lenLeftovers, packTime, renderTime, scripts, styles, svgs, title, totalCost, totalTime, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PackResponse {\n");
    sb.append("    boxes: ").append(toIndentedString(boxes)).append("\n");
    sb.append("    built: ").append(toIndentedString(built)).append("\n");
    sb.append("    leftovers: ").append(toIndentedString(leftovers)).append("\n");
    sb.append("    lenBoxes: ").append(toIndentedString(lenBoxes)).append("\n");
    sb.append("    lenItems: ").append(toIndentedString(lenItems)).append("\n");
    sb.append("    lenLeftovers: ").append(toIndentedString(lenLeftovers)).append("\n");
    sb.append("    packTime: ").append(toIndentedString(packTime)).append("\n");
    sb.append("    renderTime: ").append(toIndentedString(renderTime)).append("\n");
    sb.append("    scripts: ").append(toIndentedString(scripts)).append("\n");
    sb.append("    styles: ").append(toIndentedString(styles)).append("\n");
    sb.append("    svgs: ").append(toIndentedString(svgs)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    totalCost: ").append(toIndentedString(totalCost)).append("\n");
    sb.append("    totalTime: ").append(toIndentedString(totalTime)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("boxes");
    openapiFields.add("built");
    openapiFields.add("leftovers");
    openapiFields.add("lenBoxes");
    openapiFields.add("lenItems");
    openapiFields.add("lenLeftovers");
    openapiFields.add("packTime");
    openapiFields.add("renderTime");
    openapiFields.add("scripts");
    openapiFields.add("styles");
    openapiFields.add("svgs");
    openapiFields.add("title");
    openapiFields.add("totalCost");
    openapiFields.add("totalTime");
    openapiFields.add("version");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PackResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PackResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PackResponse is not found in the empty JSON string", PackResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PackResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PackResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("boxes") != null && !jsonObj.get("boxes").isJsonNull()) {
        JsonArray jsonArrayboxes = jsonObj.getAsJsonArray("boxes");
        if (jsonArrayboxes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("boxes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `boxes` to be an array in the JSON string but got `%s`", jsonObj.get("boxes").toString()));
          }

          // validate the optional field `boxes` (array)
          for (int i = 0; i < jsonArrayboxes.size(); i++) {
            Box.validateJsonElement(jsonArrayboxes.get(i));
          };
        }
      }
      if ((jsonObj.get("built") != null && !jsonObj.get("built").isJsonNull()) && !jsonObj.get("built").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `built` to be a primitive type in the JSON string but got `%s`", jsonObj.get("built").toString()));
      }
      if (jsonObj.get("leftovers") != null && !jsonObj.get("leftovers").isJsonNull()) {
        JsonArray jsonArrayleftovers = jsonObj.getAsJsonArray("leftovers");
        if (jsonArrayleftovers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("leftovers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `leftovers` to be an array in the JSON string but got `%s`", jsonObj.get("leftovers").toString()));
          }

          // validate the optional field `leftovers` (array)
          for (int i = 0; i < jsonArrayleftovers.size(); i++) {
            Item.validateJsonElement(jsonArrayleftovers.get(i));
          };
        }
      }
      if ((jsonObj.get("scripts") != null && !jsonObj.get("scripts").isJsonNull()) && !jsonObj.get("scripts").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scripts` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scripts").toString()));
      }
      if ((jsonObj.get("styles") != null && !jsonObj.get("styles").isJsonNull()) && !jsonObj.get("styles").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `styles` to be a primitive type in the JSON string but got `%s`", jsonObj.get("styles").toString()));
      }
      if ((jsonObj.get("svgs") != null && !jsonObj.get("svgs").isJsonNull()) && !jsonObj.get("svgs").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `svgs` to be a primitive type in the JSON string but got `%s`", jsonObj.get("svgs").toString()));
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PackResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PackResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PackResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PackResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<PackResponse>() {
           @Override
           public void write(JsonWriter out, PackResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PackResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PackResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PackResponse
   * @throws IOException if the JSON string is invalid with respect to PackResponse
   */
  public static PackResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PackResponse.class);
  }

  /**
   * Convert an instance of PackResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

