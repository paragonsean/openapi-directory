/*
 * paccurate.io
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BoxType;
import org.openapitools.client.model.BoxTypeSet;
import org.openapitools.client.model.ItemSet;
import org.openapitools.client.model.Point;
import org.openapitools.client.model.Rule;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Pack
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:43:44.933917-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Pack {
  public static final String SERIALIZED_NAME_ALLOWABLE_OVERHANG = "allowableOverhang";
  @SerializedName(SERIALIZED_NAME_ALLOWABLE_OVERHANG)
  private BigDecimal allowableOverhang;

  public static final String SERIALIZED_NAME_BOX_TYPE_SETS = "boxTypeSets";
  @SerializedName(SERIALIZED_NAME_BOX_TYPE_SETS)
  private List<BoxTypeSet> boxTypeSets = new ArrayList<>();

  public static final String SERIALIZED_NAME_BOX_TYPES = "boxTypes";
  @SerializedName(SERIALIZED_NAME_BOX_TYPES)
  private List<BoxType> boxTypes = new ArrayList<>();

  public static final String SERIALIZED_NAME_COHORT_MAX = "cohortMax";
  @SerializedName(SERIALIZED_NAME_COHORT_MAX)
  private Integer cohortMax;

  public static final String SERIALIZED_NAME_COHORT_PACKING = "cohortPacking";
  @SerializedName(SERIALIZED_NAME_COHORT_PACKING)
  private Boolean cohortPacking = false;

  public static final String SERIALIZED_NAME_COORD_ORDER = "coordOrder";
  @SerializedName(SERIALIZED_NAME_COORD_ORDER)
  private List<Integer> coordOrder = new ArrayList<>();

  public static final String SERIALIZED_NAME_CORNERS = "corners";
  @SerializedName(SERIALIZED_NAME_CORNERS)
  private Boolean corners = true;

  public static final String SERIALIZED_NAME_EYE = "eye";
  @SerializedName(SERIALIZED_NAME_EYE)
  private Point eye;

  public static final String SERIALIZED_NAME_IMG_SIZE = "imgSize";
  @SerializedName(SERIALIZED_NAME_IMG_SIZE)
  private Integer imgSize;

  public static final String SERIALIZED_NAME_INCLUDE_IMAGES = "includeImages";
  @SerializedName(SERIALIZED_NAME_INCLUDE_IMAGES)
  private Boolean includeImages = true;

  public static final String SERIALIZED_NAME_INCLUDE_SCRIPTS = "includeScripts";
  @SerializedName(SERIALIZED_NAME_INCLUDE_SCRIPTS)
  private Boolean includeScripts = true;

  public static final String SERIALIZED_NAME_INTERLOCK = "interlock";
  @SerializedName(SERIALIZED_NAME_INTERLOCK)
  private Boolean interlock = false;

  public static final String SERIALIZED_NAME_ITEM_SETS = "itemSets";
  @SerializedName(SERIALIZED_NAME_ITEM_SETS)
  private List<ItemSet> itemSets = new ArrayList<>();

  public static final String SERIALIZED_NAME_KEY = "key";
  @SerializedName(SERIALIZED_NAME_KEY)
  private String key;

  public static final String SERIALIZED_NAME_LAY_FLAT = "layFlat";
  @SerializedName(SERIALIZED_NAME_LAY_FLAT)
  private Boolean layFlat = false;

  public static final String SERIALIZED_NAME_MAX_SEQUENCE_DISTANCE = "maxSequenceDistance";
  @SerializedName(SERIALIZED_NAME_MAX_SEQUENCE_DISTANCE)
  private Integer maxSequenceDistance;

  public static final String SERIALIZED_NAME_N = "n";
  @SerializedName(SERIALIZED_NAME_N)
  private Integer n;

  public static final String SERIALIZED_NAME_PACK_ORIGIN = "packOrigin";
  @SerializedName(SERIALIZED_NAME_PACK_ORIGIN)
  private Point packOrigin;

  /**
   * How to place items. &#39;default&#39; will defer to coordOrder, &#39;corner&#39; minimizes distance to rear, bottom corner, &#39;wedge&#39; minimizes distance to middle of bottom, back edge, &#39;mound&#39; minimizes distance to center of carton bottom.
   */
  @JsonAdapter(PlacementStyleEnum.Adapter.class)
  public enum PlacementStyleEnum {
    DEFAULT("default"),
    
    CORNER("corner"),
    
    WEDGE("wedge"),
    
    MOUND("mound"),
    
    ORB("orb");

    private String value;

    PlacementStyleEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PlacementStyleEnum fromValue(String value) {
      for (PlacementStyleEnum b : PlacementStyleEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PlacementStyleEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PlacementStyleEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PlacementStyleEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PlacementStyleEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PlacementStyleEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PLACEMENT_STYLE = "placementStyle";
  @SerializedName(SERIALIZED_NAME_PLACEMENT_STYLE)
  private PlacementStyleEnum placementStyle = PlacementStyleEnum.DEFAULT;

  public static final String SERIALIZED_NAME_RANDOM = "random";
  @SerializedName(SERIALIZED_NAME_RANDOM)
  private Boolean random = false;

  public static final String SERIALIZED_NAME_RANDOM_MAX_DIMENSION = "randomMaxDimension";
  @SerializedName(SERIALIZED_NAME_RANDOM_MAX_DIMENSION)
  private Integer randomMaxDimension;

  public static final String SERIALIZED_NAME_RANDOM_MAX_WEIGHT = "randomMaxWeight";
  @SerializedName(SERIALIZED_NAME_RANDOM_MAX_WEIGHT)
  private Integer randomMaxWeight;

  public static final String SERIALIZED_NAME_RULES = "rules";
  @SerializedName(SERIALIZED_NAME_RULES)
  private List<Rule> rules = new ArrayList<>();

  public static final String SERIALIZED_NAME_SEED = "seed";
  @SerializedName(SERIALIZED_NAME_SEED)
  private Boolean seed = true;

  public static final String SERIALIZED_NAME_SEQUENCE_HEAT_MAP = "sequenceHeatMap";
  @SerializedName(SERIALIZED_NAME_SEQUENCE_HEAT_MAP)
  private Boolean sequenceHeatMap = false;

  public static final String SERIALIZED_NAME_SEQUENCE_SORT = "sequenceSort";
  @SerializedName(SERIALIZED_NAME_SEQUENCE_SORT)
  private Boolean sequenceSort = false;

  /**
   * template name for markup generation.
   */
  @JsonAdapter(TemplateEnum.Adapter.class)
  public enum TemplateEnum {
    DEMO_TMPL("demo.tmpl"),
    
    SHIPAPP_TMPL("shipapp.tmpl"),
    
    BOAT_TMPL("boat.tmpl");

    private String value;

    TemplateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TemplateEnum fromValue(String value) {
      for (TemplateEnum b : TemplateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TemplateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TemplateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TemplateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TemplateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TemplateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TEMPLATE = "template";
  @SerializedName(SERIALIZED_NAME_TEMPLATE)
  private TemplateEnum template;

  public static final String SERIALIZED_NAME_USABLE_SPACE = "usableSpace";
  @SerializedName(SERIALIZED_NAME_USABLE_SPACE)
  private BigDecimal usableSpace;

  public static final String SERIALIZED_NAME_ZONE = "zone";
  @SerializedName(SERIALIZED_NAME_ZONE)
  private Integer zone;

  public Pack() {
  }

  public Pack allowableOverhang(BigDecimal allowableOverhang) {
    this.allowableOverhang = allowableOverhang;
    return this;
  }

  /**
   * The amount an item can overhang lower items that it is placed upon. The units are whatever units the box and item dimensions are given in. By convention, inches.
   * @return allowableOverhang
   */
  @javax.annotation.Nullable
  public BigDecimal getAllowableOverhang() {
    return allowableOverhang;
  }

  public void setAllowableOverhang(BigDecimal allowableOverhang) {
    this.allowableOverhang = allowableOverhang;
  }


  public Pack boxTypeSets(List<BoxTypeSet> boxTypeSets) {
    this.boxTypeSets = boxTypeSets;
    return this;
  }

  public Pack addBoxTypeSetsItem(BoxTypeSet boxTypeSetsItem) {
    if (this.boxTypeSets == null) {
      this.boxTypeSets = new ArrayList<>();
    }
    this.boxTypeSets.add(boxTypeSetsItem);
    return this;
  }

  /**
   * predefined box types to be used, separated by commas. Will be overridden by boxTypes. Acceptable values are &lt;ul&gt;&lt;li&gt;\&quot;fedex\&quot;--FedEx OneRate&lt;/li&gt;&lt;li&gt;\&quot;usps\&quot;--USPS Priority Flat Rate&lt;/li&gt;&lt;li&gt;\&quot;pallet\&quot;--full-, half-, and quarter-sized 48\&quot;x40\&quot; pallets.
   * @return boxTypeSets
   */
  @javax.annotation.Nullable
  public List<BoxTypeSet> getBoxTypeSets() {
    return boxTypeSets;
  }

  public void setBoxTypeSets(List<BoxTypeSet> boxTypeSets) {
    this.boxTypeSets = boxTypeSets;
  }


  public Pack boxTypes(List<BoxType> boxTypes) {
    this.boxTypes = boxTypes;
    return this;
  }

  public Pack addBoxTypesItem(BoxType boxTypesItem) {
    if (this.boxTypes == null) {
      this.boxTypes = new ArrayList<>();
    }
    this.boxTypes.add(boxTypesItem);
    return this;
  }

  /**
   * box type definitions for packing, will override boxTypeSets defined.
   * @return boxTypes
   */
  @javax.annotation.Nullable
  public List<BoxType> getBoxTypes() {
    return boxTypes;
  }

  public void setBoxTypes(List<BoxType> boxTypes) {
    this.boxTypes = boxTypes;
  }


  public Pack cohortMax(Integer cohortMax) {
    this.cohortMax = cohortMax;
    return this;
  }

  /**
   * the maximum number of contiguous cohorts for a given item type within a single container. E.g., if you pack 40 chairs in a single container, a cohortMax of 2 could yield one (all 40 chairs in a single block if space is availabe) or two (say, 25 chairs in one corner and 15 in the other) contiguous cohorts.
   * @return cohortMax
   */
  @javax.annotation.Nullable
  public Integer getCohortMax() {
    return cohortMax;
  }

  public void setCohortMax(Integer cohortMax) {
    this.cohortMax = cohortMax;
  }


  public Pack cohortPacking(Boolean cohortPacking) {
    this.cohortPacking = cohortPacking;
    return this;
  }

  /**
   * if selected, will ensure that all like items will be packed together, in no more than [cohortMax] different groups within a single container.
   * @return cohortPacking
   */
  @javax.annotation.Nullable
  public Boolean getCohortPacking() {
    return cohortPacking;
  }

  public void setCohortPacking(Boolean cohortPacking) {
    this.cohortPacking = cohortPacking;
  }


  public Pack coordOrder(List<Integer> coordOrder) {
    this.coordOrder = coordOrder;
    return this;
  }

  public Pack addCoordOrderItem(Integer coordOrderItem) {
    if (this.coordOrder == null) {
      this.coordOrder = new ArrayList<>();
    }
    this.coordOrder.add(coordOrderItem);
    return this;
  }

  /**
   * If placementStyle is set to \&quot;default\&quot;, coordOrder sets the placement priority of axes ascendingly. \&quot;0,1,2\&quot; would search for placement points along the Z(length,\&quot;2\&quot;), then Y(width,\&quot;1\&quot;), and finally X(height\&quot;0\&quot;). Keep in mind that in the default rendering the \&quot;up\&quot; direction is X and the other axes follow the right-hand rule. This is useful for different packing methods. E.g., Utilizing \&quot;2,0,1\&quot; would pack a shipping container first in the Y(width) direction, then in the X(height) direction, and finally in the Z(length) direction, replication a floor-to-ceiling, front-to-back loading method.
   * @return coordOrder
   */
  @javax.annotation.Nullable
  public List<Integer> getCoordOrder() {
    return coordOrder;
  }

  public void setCoordOrder(List<Integer> coordOrder) {
    this.coordOrder = coordOrder;
  }


  public Pack corners(Boolean corners) {
    this.corners = corners;
    return this;
  }

  /**
   * only pack items at valid corner points of other items (optimal)
   * @return corners
   */
  @javax.annotation.Nullable
  public Boolean getCorners() {
    return corners;
  }

  public void setCorners(Boolean corners) {
    this.corners = corners;
  }


  public Pack eye(Point eye) {
    this.eye = eye;
    return this;
  }

  /**
   * The x,y,z coordinates of the virtual eye looking at the package for visualization purposes. Default is isometric, \&quot;1,1,1\&quot;. To generate a side view, one could use \&quot;0.001,1.0,0.001\&quot;.
   * @return eye
   */
  @javax.annotation.Nullable
  public Point getEye() {
    return eye;
  }

  public void setEye(Point eye) {
    this.eye = eye;
  }


  public Pack imgSize(Integer imgSize) {
    this.imgSize = imgSize;
    return this;
  }

  /**
   * width of rendered SVGs in pixels.
   * @return imgSize
   */
  @javax.annotation.Nullable
  public Integer getImgSize() {
    return imgSize;
  }

  public void setImgSize(Integer imgSize) {
    this.imgSize = imgSize;
  }


  public Pack includeImages(Boolean includeImages) {
    this.includeImages = includeImages;
    return this;
  }

  /**
   * include inline images, default is always on
   * @return includeImages
   */
  @javax.annotation.Nullable
  public Boolean getIncludeImages() {
    return includeImages;
  }

  public void setIncludeImages(Boolean includeImages) {
    this.includeImages = includeImages;
  }


  public Pack includeScripts(Boolean includeScripts) {
    this.includeScripts = includeScripts;
    return this;
  }

  /**
   * include inline javascripts and styles for base template
   * @return includeScripts
   */
  @javax.annotation.Nullable
  public Boolean getIncludeScripts() {
    return includeScripts;
  }

  public void setIncludeScripts(Boolean includeScripts) {
    this.includeScripts = includeScripts;
  }


  public Pack interlock(Boolean interlock) {
    this.interlock = interlock;
    return this;
  }

  /**
   * alternates layFlat orientation by layer, so as to create an interlocked placement pattern and improve item stability.
   * @return interlock
   */
  @javax.annotation.Nullable
  public Boolean getInterlock() {
    return interlock;
  }

  public void setInterlock(Boolean interlock) {
    this.interlock = interlock;
  }


  public Pack itemSets(List<ItemSet> itemSets) {
    this.itemSets = itemSets;
    return this;
  }

  public Pack addItemSetsItem(ItemSet itemSetsItem) {
    if (this.itemSets == null) {
      this.itemSets = new ArrayList<>();
    }
    this.itemSets.add(itemSetsItem);
    return this;
  }

  /**
   * item set definitions if not creating random items.
   * @return itemSets
   */
  @javax.annotation.Nullable
  public List<ItemSet> getItemSets() {
    return itemSets;
  }

  public void setItemSets(List<ItemSet> itemSets) {
    this.itemSets = itemSets;
  }


  public Pack key(String key) {
    this.key = key;
    return this;
  }

  /**
   * issued API key.
   * @return key
   */
  @javax.annotation.Nullable
  public String getKey() {
    return key;
  }

  public void setKey(String key) {
    this.key = key;
  }


  public Pack layFlat(Boolean layFlat) {
    this.layFlat = layFlat;
    return this;
  }

  /**
   * aligns all items laying flat. If possible, it may create a \&quot;brick-laying\&quot; pattern to increase stability.
   * @return layFlat
   */
  @javax.annotation.Nullable
  public Boolean getLayFlat() {
    return layFlat;
  }

  public void setLayFlat(Boolean layFlat) {
    this.layFlat = layFlat;
  }


  public Pack maxSequenceDistance(Integer maxSequenceDistance) {
    this.maxSequenceDistance = maxSequenceDistance;
    return this;
  }

  /**
   * This is the maximum distance allowable between two sequence values of items packed in a common box. E.g., \&quot;Distance\&quot; for an item sequence composed of aisle/bin combinations of \&quot;0401\&quot; and \&quot;1228\&quot; has a sequence distance of \\|1228 - 401\\| &#x3D; 827
   * @return maxSequenceDistance
   */
  @javax.annotation.Nullable
  public Integer getMaxSequenceDistance() {
    return maxSequenceDistance;
  }

  public void setMaxSequenceDistance(Integer maxSequenceDistance) {
    this.maxSequenceDistance = maxSequenceDistance;
  }


  public Pack n(Integer n) {
    this.n = n;
    return this;
  }

  /**
   * number of random items to generate and the quantity of each if \&quot;random\&quot; is set to true. a value of 5 would create 5 different items with a quantity of 5 each, making the total item quantity equal to n&amp;sup2;
   * @return n
   */
  @javax.annotation.Nullable
  public Integer getN() {
    return n;
  }

  public void setN(Integer n) {
    this.n = n;
  }


  public Pack packOrigin(Point packOrigin) {
    this.packOrigin = packOrigin;
    return this;
  }

  /**
   * the x,y,z coordinates of an optional packing origin. A packing origin is used to create more balanced packing for situations where load needs to be considered. E.g., for a 40\&quot;x48\&quot; pallet, a packOrigin representing the middle of the pallet, \&quot;0,20,24\&quot;, would cause placement to minimize the distance of the packed items from the center of the pallet.
   * @return packOrigin
   */
  @javax.annotation.Nullable
  public Point getPackOrigin() {
    return packOrigin;
  }

  public void setPackOrigin(Point packOrigin) {
    this.packOrigin = packOrigin;
  }


  public Pack placementStyle(PlacementStyleEnum placementStyle) {
    this.placementStyle = placementStyle;
    return this;
  }

  /**
   * How to place items. &#39;default&#39; will defer to coordOrder, &#39;corner&#39; minimizes distance to rear, bottom corner, &#39;wedge&#39; minimizes distance to middle of bottom, back edge, &#39;mound&#39; minimizes distance to center of carton bottom.
   * @return placementStyle
   */
  @javax.annotation.Nullable
  public PlacementStyleEnum getPlacementStyle() {
    return placementStyle;
  }

  public void setPlacementStyle(PlacementStyleEnum placementStyle) {
    this.placementStyle = placementStyle;
  }


  public Pack random(Boolean random) {
    this.random = random;
    return this;
  }

  /**
   * create random items
   * @return random
   */
  @javax.annotation.Nullable
  public Boolean getRandom() {
    return random;
  }

  public void setRandom(Boolean random) {
    this.random = random;
  }


  public Pack randomMaxDimension(Integer randomMaxDimension) {
    this.randomMaxDimension = randomMaxDimension;
    return this;
  }

  /**
   * maximum item dimension along a single axis for randomly generated items.
   * @return randomMaxDimension
   */
  @javax.annotation.Nullable
  public Integer getRandomMaxDimension() {
    return randomMaxDimension;
  }

  public void setRandomMaxDimension(Integer randomMaxDimension) {
    this.randomMaxDimension = randomMaxDimension;
  }


  public Pack randomMaxWeight(Integer randomMaxWeight) {
    this.randomMaxWeight = randomMaxWeight;
    return this;
  }

  /**
   * maximum item weight for randomly generated items.
   * @return randomMaxWeight
   */
  @javax.annotation.Nullable
  public Integer getRandomMaxWeight() {
    return randomMaxWeight;
  }

  public void setRandomMaxWeight(Integer randomMaxWeight) {
    this.randomMaxWeight = randomMaxWeight;
  }


  public Pack rules(List<Rule> rules) {
    this.rules = rules;
    return this;
  }

  public Pack addRulesItem(Rule rulesItem) {
    if (this.rules == null) {
      this.rules = new ArrayList<>();
    }
    this.rules.add(rulesItem);
    return this;
  }

  /**
   * Array of packing rules.
   * @return rules
   */
  @javax.annotation.Nullable
  public List<Rule> getRules() {
    return rules;
  }

  public void setRules(List<Rule> rules) {
    this.rules = rules;
  }


  public Pack seed(Boolean seed) {
    this.seed = seed;
    return this;
  }

  /**
   * if random is selected, seed the random number generator to deterministically generate random items to pack.
   * @return seed
   */
  @javax.annotation.Nullable
  public Boolean getSeed() {
    return seed;
  }

  public void setSeed(Boolean seed) {
    this.seed = seed;
  }


  public Pack sequenceHeatMap(Boolean sequenceHeatMap) {
    this.sequenceHeatMap = sequenceHeatMap;
    return this;
  }

  /**
   * Colorize items solely by their sequence value, light when sequence is high, dark when it is low. Useful for indicating item bin location, weight, or other sequence property that may not be apparent from the default visualization.
   * @return sequenceHeatMap
   */
  @javax.annotation.Nullable
  public Boolean getSequenceHeatMap() {
    return sequenceHeatMap;
  }

  public void setSequenceHeatMap(Boolean sequenceHeatMap) {
    this.sequenceHeatMap = sequenceHeatMap;
  }


  public Pack sequenceSort(Boolean sequenceSort) {
    this.sequenceSort = sequenceSort;
    return this;
  }

  /**
   * Whether or not the items should be initially sorted by their sequence value instead of their volume. This is not always useful, as the default \&quot;biggest-first\&quot; volume sort is very effective for items, and constraining by maxSequenceDistance is applied regardless of this field. That said, for doing custom pre-sorts such as weight-based instead of volume based, this value should be set to true.
   * @return sequenceSort
   */
  @javax.annotation.Nullable
  public Boolean getSequenceSort() {
    return sequenceSort;
  }

  public void setSequenceSort(Boolean sequenceSort) {
    this.sequenceSort = sequenceSort;
  }


  public Pack template(TemplateEnum template) {
    this.template = template;
    return this;
  }

  /**
   * template name for markup generation.
   * @return template
   */
  @javax.annotation.Nullable
  public TemplateEnum getTemplate() {
    return template;
  }

  public void setTemplate(TemplateEnum template) {
    this.template = template;
  }


  public Pack usableSpace(BigDecimal usableSpace) {
    this.usableSpace = usableSpace;
    return this;
  }

  /**
   * estimate of percentage space in boxes that is usable, i.e., not packing material.
   * minimum: 0
   * maximum: 1
   * @return usableSpace
   */
  @javax.annotation.Nullable
  public BigDecimal getUsableSpace() {
    return usableSpace;
  }

  public void setUsableSpace(BigDecimal usableSpace) {
    this.usableSpace = usableSpace;
  }


  public Pack zone(Integer zone) {
    this.zone = zone;
    return this;
  }

  /**
   * &lt;b&gt;[experimental]&lt;/b&gt; the shipping zone in order to use basic zone-based price optimization.
   * minimum: 1
   * @return zone
   */
  @javax.annotation.Nullable
  public Integer getZone() {
    return zone;
  }

  public void setZone(Integer zone) {
    this.zone = zone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Pack pack = (Pack) o;
    return Objects.equals(this.allowableOverhang, pack.allowableOverhang) &&
        Objects.equals(this.boxTypeSets, pack.boxTypeSets) &&
        Objects.equals(this.boxTypes, pack.boxTypes) &&
        Objects.equals(this.cohortMax, pack.cohortMax) &&
        Objects.equals(this.cohortPacking, pack.cohortPacking) &&
        Objects.equals(this.coordOrder, pack.coordOrder) &&
        Objects.equals(this.corners, pack.corners) &&
        Objects.equals(this.eye, pack.eye) &&
        Objects.equals(this.imgSize, pack.imgSize) &&
        Objects.equals(this.includeImages, pack.includeImages) &&
        Objects.equals(this.includeScripts, pack.includeScripts) &&
        Objects.equals(this.interlock, pack.interlock) &&
        Objects.equals(this.itemSets, pack.itemSets) &&
        Objects.equals(this.key, pack.key) &&
        Objects.equals(this.layFlat, pack.layFlat) &&
        Objects.equals(this.maxSequenceDistance, pack.maxSequenceDistance) &&
        Objects.equals(this.n, pack.n) &&
        Objects.equals(this.packOrigin, pack.packOrigin) &&
        Objects.equals(this.placementStyle, pack.placementStyle) &&
        Objects.equals(this.random, pack.random) &&
        Objects.equals(this.randomMaxDimension, pack.randomMaxDimension) &&
        Objects.equals(this.randomMaxWeight, pack.randomMaxWeight) &&
        Objects.equals(this.rules, pack.rules) &&
        Objects.equals(this.seed, pack.seed) &&
        Objects.equals(this.sequenceHeatMap, pack.sequenceHeatMap) &&
        Objects.equals(this.sequenceSort, pack.sequenceSort) &&
        Objects.equals(this.template, pack.template) &&
        Objects.equals(this.usableSpace, pack.usableSpace) &&
        Objects.equals(this.zone, pack.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowableOverhang, boxTypeSets, boxTypes, cohortMax, cohortPacking, coordOrder, corners, eye, imgSize, includeImages, includeScripts, interlock, itemSets, key, layFlat, maxSequenceDistance, n, packOrigin, placementStyle, random, randomMaxDimension, randomMaxWeight, rules, seed, sequenceHeatMap, sequenceSort, template, usableSpace, zone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Pack {\n");
    sb.append("    allowableOverhang: ").append(toIndentedString(allowableOverhang)).append("\n");
    sb.append("    boxTypeSets: ").append(toIndentedString(boxTypeSets)).append("\n");
    sb.append("    boxTypes: ").append(toIndentedString(boxTypes)).append("\n");
    sb.append("    cohortMax: ").append(toIndentedString(cohortMax)).append("\n");
    sb.append("    cohortPacking: ").append(toIndentedString(cohortPacking)).append("\n");
    sb.append("    coordOrder: ").append(toIndentedString(coordOrder)).append("\n");
    sb.append("    corners: ").append(toIndentedString(corners)).append("\n");
    sb.append("    eye: ").append(toIndentedString(eye)).append("\n");
    sb.append("    imgSize: ").append(toIndentedString(imgSize)).append("\n");
    sb.append("    includeImages: ").append(toIndentedString(includeImages)).append("\n");
    sb.append("    includeScripts: ").append(toIndentedString(includeScripts)).append("\n");
    sb.append("    interlock: ").append(toIndentedString(interlock)).append("\n");
    sb.append("    itemSets: ").append(toIndentedString(itemSets)).append("\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    layFlat: ").append(toIndentedString(layFlat)).append("\n");
    sb.append("    maxSequenceDistance: ").append(toIndentedString(maxSequenceDistance)).append("\n");
    sb.append("    n: ").append(toIndentedString(n)).append("\n");
    sb.append("    packOrigin: ").append(toIndentedString(packOrigin)).append("\n");
    sb.append("    placementStyle: ").append(toIndentedString(placementStyle)).append("\n");
    sb.append("    random: ").append(toIndentedString(random)).append("\n");
    sb.append("    randomMaxDimension: ").append(toIndentedString(randomMaxDimension)).append("\n");
    sb.append("    randomMaxWeight: ").append(toIndentedString(randomMaxWeight)).append("\n");
    sb.append("    rules: ").append(toIndentedString(rules)).append("\n");
    sb.append("    seed: ").append(toIndentedString(seed)).append("\n");
    sb.append("    sequenceHeatMap: ").append(toIndentedString(sequenceHeatMap)).append("\n");
    sb.append("    sequenceSort: ").append(toIndentedString(sequenceSort)).append("\n");
    sb.append("    template: ").append(toIndentedString(template)).append("\n");
    sb.append("    usableSpace: ").append(toIndentedString(usableSpace)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowableOverhang");
    openapiFields.add("boxTypeSets");
    openapiFields.add("boxTypes");
    openapiFields.add("cohortMax");
    openapiFields.add("cohortPacking");
    openapiFields.add("coordOrder");
    openapiFields.add("corners");
    openapiFields.add("eye");
    openapiFields.add("imgSize");
    openapiFields.add("includeImages");
    openapiFields.add("includeScripts");
    openapiFields.add("interlock");
    openapiFields.add("itemSets");
    openapiFields.add("key");
    openapiFields.add("layFlat");
    openapiFields.add("maxSequenceDistance");
    openapiFields.add("n");
    openapiFields.add("packOrigin");
    openapiFields.add("placementStyle");
    openapiFields.add("random");
    openapiFields.add("randomMaxDimension");
    openapiFields.add("randomMaxWeight");
    openapiFields.add("rules");
    openapiFields.add("seed");
    openapiFields.add("sequenceHeatMap");
    openapiFields.add("sequenceSort");
    openapiFields.add("template");
    openapiFields.add("usableSpace");
    openapiFields.add("zone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Pack
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Pack.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Pack is not found in the empty JSON string", Pack.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Pack.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Pack` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("boxTypeSets") != null && !jsonObj.get("boxTypeSets").isJsonNull() && !jsonObj.get("boxTypeSets").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `boxTypeSets` to be an array in the JSON string but got `%s`", jsonObj.get("boxTypeSets").toString()));
      }
      if (jsonObj.get("boxTypes") != null && !jsonObj.get("boxTypes").isJsonNull()) {
        JsonArray jsonArrayboxTypes = jsonObj.getAsJsonArray("boxTypes");
        if (jsonArrayboxTypes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("boxTypes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `boxTypes` to be an array in the JSON string but got `%s`", jsonObj.get("boxTypes").toString()));
          }

          // validate the optional field `boxTypes` (array)
          for (int i = 0; i < jsonArrayboxTypes.size(); i++) {
            BoxType.validateJsonElement(jsonArrayboxTypes.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("coordOrder") != null && !jsonObj.get("coordOrder").isJsonNull() && !jsonObj.get("coordOrder").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `coordOrder` to be an array in the JSON string but got `%s`", jsonObj.get("coordOrder").toString()));
      }
      // validate the optional field `eye`
      if (jsonObj.get("eye") != null && !jsonObj.get("eye").isJsonNull()) {
        Point.validateJsonElement(jsonObj.get("eye"));
      }
      if (jsonObj.get("itemSets") != null && !jsonObj.get("itemSets").isJsonNull()) {
        JsonArray jsonArrayitemSets = jsonObj.getAsJsonArray("itemSets");
        if (jsonArrayitemSets != null) {
          // ensure the json data is an array
          if (!jsonObj.get("itemSets").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `itemSets` to be an array in the JSON string but got `%s`", jsonObj.get("itemSets").toString()));
          }

          // validate the optional field `itemSets` (array)
          for (int i = 0; i < jsonArrayitemSets.size(); i++) {
            ItemSet.validateJsonElement(jsonArrayitemSets.get(i));
          };
        }
      }
      if ((jsonObj.get("key") != null && !jsonObj.get("key").isJsonNull()) && !jsonObj.get("key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key").toString()));
      }
      // validate the optional field `packOrigin`
      if (jsonObj.get("packOrigin") != null && !jsonObj.get("packOrigin").isJsonNull()) {
        Point.validateJsonElement(jsonObj.get("packOrigin"));
      }
      if ((jsonObj.get("placementStyle") != null && !jsonObj.get("placementStyle").isJsonNull()) && !jsonObj.get("placementStyle").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `placementStyle` to be a primitive type in the JSON string but got `%s`", jsonObj.get("placementStyle").toString()));
      }
      // validate the optional field `placementStyle`
      if (jsonObj.get("placementStyle") != null && !jsonObj.get("placementStyle").isJsonNull()) {
        PlacementStyleEnum.validateJsonElement(jsonObj.get("placementStyle"));
      }
      if (jsonObj.get("rules") != null && !jsonObj.get("rules").isJsonNull()) {
        JsonArray jsonArrayrules = jsonObj.getAsJsonArray("rules");
        if (jsonArrayrules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("rules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `rules` to be an array in the JSON string but got `%s`", jsonObj.get("rules").toString()));
          }

          // validate the optional field `rules` (array)
          for (int i = 0; i < jsonArrayrules.size(); i++) {
            Rule.validateJsonElement(jsonArrayrules.get(i));
          };
        }
      }
      if ((jsonObj.get("template") != null && !jsonObj.get("template").isJsonNull()) && !jsonObj.get("template").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `template` to be a primitive type in the JSON string but got `%s`", jsonObj.get("template").toString()));
      }
      // validate the optional field `template`
      if (jsonObj.get("template") != null && !jsonObj.get("template").isJsonNull()) {
        TemplateEnum.validateJsonElement(jsonObj.get("template"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Pack.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Pack' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Pack> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Pack.class));

       return (TypeAdapter<T>) new TypeAdapter<Pack>() {
           @Override
           public void write(JsonWriter out, Pack value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Pack read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Pack given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Pack
   * @throws IOException if the JSON string is invalid with respect to Pack
   */
  public static Pack fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Pack.class);
  }

  /**
   * Convert an instance of Pack to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

