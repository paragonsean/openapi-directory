# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.box_type import BoxType
from openapi_server.models.box_type_set import BoxTypeSet
from openapi_server.models.item_set import ItemSet
from openapi_server.models.point import Point
from openapi_server.models.rule import Rule
from openapi_server import util


class Pack(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, allowable_overhang: float=None, box_type_sets: List[BoxTypeSet]=None, box_types: List[BoxType]=None, cohort_max: int=None, cohort_packing: bool=False, coord_order: List[int]=None, corners: bool=True, eye: Point=None, img_size: int=None, include_images: bool=True, include_scripts: bool=True, interlock: bool=False, item_sets: List[ItemSet]=None, key: str=None, lay_flat: bool=False, max_sequence_distance: int=None, n: int=None, pack_origin: Point=None, placement_style: str='default', random: bool=False, random_max_dimension: int=None, random_max_weight: int=None, rules: List[Rule]=None, seed: bool=True, sequence_heat_map: bool=False, sequence_sort: bool=False, template: str=None, usable_space: float=None, zone: int=None):
        """Pack - a model defined in OpenAPI

        :param allowable_overhang: The allowable_overhang of this Pack.
        :param box_type_sets: The box_type_sets of this Pack.
        :param box_types: The box_types of this Pack.
        :param cohort_max: The cohort_max of this Pack.
        :param cohort_packing: The cohort_packing of this Pack.
        :param coord_order: The coord_order of this Pack.
        :param corners: The corners of this Pack.
        :param eye: The eye of this Pack.
        :param img_size: The img_size of this Pack.
        :param include_images: The include_images of this Pack.
        :param include_scripts: The include_scripts of this Pack.
        :param interlock: The interlock of this Pack.
        :param item_sets: The item_sets of this Pack.
        :param key: The key of this Pack.
        :param lay_flat: The lay_flat of this Pack.
        :param max_sequence_distance: The max_sequence_distance of this Pack.
        :param n: The n of this Pack.
        :param pack_origin: The pack_origin of this Pack.
        :param placement_style: The placement_style of this Pack.
        :param random: The random of this Pack.
        :param random_max_dimension: The random_max_dimension of this Pack.
        :param random_max_weight: The random_max_weight of this Pack.
        :param rules: The rules of this Pack.
        :param seed: The seed of this Pack.
        :param sequence_heat_map: The sequence_heat_map of this Pack.
        :param sequence_sort: The sequence_sort of this Pack.
        :param template: The template of this Pack.
        :param usable_space: The usable_space of this Pack.
        :param zone: The zone of this Pack.
        """
        self.openapi_types = {
            'allowable_overhang': float,
            'box_type_sets': List[BoxTypeSet],
            'box_types': List[BoxType],
            'cohort_max': int,
            'cohort_packing': bool,
            'coord_order': List[int],
            'corners': bool,
            'eye': Point,
            'img_size': int,
            'include_images': bool,
            'include_scripts': bool,
            'interlock': bool,
            'item_sets': List[ItemSet],
            'key': str,
            'lay_flat': bool,
            'max_sequence_distance': int,
            'n': int,
            'pack_origin': Point,
            'placement_style': str,
            'random': bool,
            'random_max_dimension': int,
            'random_max_weight': int,
            'rules': List[Rule],
            'seed': bool,
            'sequence_heat_map': bool,
            'sequence_sort': bool,
            'template': str,
            'usable_space': float,
            'zone': int
        }

        self.attribute_map = {
            'allowable_overhang': 'allowableOverhang',
            'box_type_sets': 'boxTypeSets',
            'box_types': 'boxTypes',
            'cohort_max': 'cohortMax',
            'cohort_packing': 'cohortPacking',
            'coord_order': 'coordOrder',
            'corners': 'corners',
            'eye': 'eye',
            'img_size': 'imgSize',
            'include_images': 'includeImages',
            'include_scripts': 'includeScripts',
            'interlock': 'interlock',
            'item_sets': 'itemSets',
            'key': 'key',
            'lay_flat': 'layFlat',
            'max_sequence_distance': 'maxSequenceDistance',
            'n': 'n',
            'pack_origin': 'packOrigin',
            'placement_style': 'placementStyle',
            'random': 'random',
            'random_max_dimension': 'randomMaxDimension',
            'random_max_weight': 'randomMaxWeight',
            'rules': 'rules',
            'seed': 'seed',
            'sequence_heat_map': 'sequenceHeatMap',
            'sequence_sort': 'sequenceSort',
            'template': 'template',
            'usable_space': 'usableSpace',
            'zone': 'zone'
        }

        self._allowable_overhang = allowable_overhang
        self._box_type_sets = box_type_sets
        self._box_types = box_types
        self._cohort_max = cohort_max
        self._cohort_packing = cohort_packing
        self._coord_order = coord_order
        self._corners = corners
        self._eye = eye
        self._img_size = img_size
        self._include_images = include_images
        self._include_scripts = include_scripts
        self._interlock = interlock
        self._item_sets = item_sets
        self._key = key
        self._lay_flat = lay_flat
        self._max_sequence_distance = max_sequence_distance
        self._n = n
        self._pack_origin = pack_origin
        self._placement_style = placement_style
        self._random = random
        self._random_max_dimension = random_max_dimension
        self._random_max_weight = random_max_weight
        self._rules = rules
        self._seed = seed
        self._sequence_heat_map = sequence_heat_map
        self._sequence_sort = sequence_sort
        self._template = template
        self._usable_space = usable_space
        self._zone = zone

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Pack':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Pack of this Pack.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def allowable_overhang(self):
        """Gets the allowable_overhang of this Pack.

        The amount an item can overhang lower items that it is placed upon. The units are whatever units the box and item dimensions are given in. By convention, inches.

        :return: The allowable_overhang of this Pack.
        :rtype: float
        """
        return self._allowable_overhang

    @allowable_overhang.setter
    def allowable_overhang(self, allowable_overhang):
        """Sets the allowable_overhang of this Pack.

        The amount an item can overhang lower items that it is placed upon. The units are whatever units the box and item dimensions are given in. By convention, inches.

        :param allowable_overhang: The allowable_overhang of this Pack.
        :type allowable_overhang: float
        """

        self._allowable_overhang = allowable_overhang

    @property
    def box_type_sets(self):
        """Gets the box_type_sets of this Pack.

        predefined box types to be used, separated by commas. Will be overridden by boxTypes. Acceptable values are <ul><li>\"fedex\"--FedEx OneRate</li><li>\"usps\"--USPS Priority Flat Rate</li><li>\"pallet\"--full-, half-, and quarter-sized 48\"x40\" pallets.

        :return: The box_type_sets of this Pack.
        :rtype: List[BoxTypeSet]
        """
        return self._box_type_sets

    @box_type_sets.setter
    def box_type_sets(self, box_type_sets):
        """Sets the box_type_sets of this Pack.

        predefined box types to be used, separated by commas. Will be overridden by boxTypes. Acceptable values are <ul><li>\"fedex\"--FedEx OneRate</li><li>\"usps\"--USPS Priority Flat Rate</li><li>\"pallet\"--full-, half-, and quarter-sized 48\"x40\" pallets.

        :param box_type_sets: The box_type_sets of this Pack.
        :type box_type_sets: List[BoxTypeSet]
        """

        self._box_type_sets = box_type_sets

    @property
    def box_types(self):
        """Gets the box_types of this Pack.

        box type definitions for packing, will override boxTypeSets defined.

        :return: The box_types of this Pack.
        :rtype: List[BoxType]
        """
        return self._box_types

    @box_types.setter
    def box_types(self, box_types):
        """Sets the box_types of this Pack.

        box type definitions for packing, will override boxTypeSets defined.

        :param box_types: The box_types of this Pack.
        :type box_types: List[BoxType]
        """

        self._box_types = box_types

    @property
    def cohort_max(self):
        """Gets the cohort_max of this Pack.

        the maximum number of contiguous cohorts for a given item type within a single container. E.g., if you pack 40 chairs in a single container, a cohortMax of 2 could yield one (all 40 chairs in a single block if space is availabe) or two (say, 25 chairs in one corner and 15 in the other) contiguous cohorts.

        :return: The cohort_max of this Pack.
        :rtype: int
        """
        return self._cohort_max

    @cohort_max.setter
    def cohort_max(self, cohort_max):
        """Sets the cohort_max of this Pack.

        the maximum number of contiguous cohorts for a given item type within a single container. E.g., if you pack 40 chairs in a single container, a cohortMax of 2 could yield one (all 40 chairs in a single block if space is availabe) or two (say, 25 chairs in one corner and 15 in the other) contiguous cohorts.

        :param cohort_max: The cohort_max of this Pack.
        :type cohort_max: int
        """

        self._cohort_max = cohort_max

    @property
    def cohort_packing(self):
        """Gets the cohort_packing of this Pack.

        if selected, will ensure that all like items will be packed together, in no more than [cohortMax] different groups within a single container.

        :return: The cohort_packing of this Pack.
        :rtype: bool
        """
        return self._cohort_packing

    @cohort_packing.setter
    def cohort_packing(self, cohort_packing):
        """Sets the cohort_packing of this Pack.

        if selected, will ensure that all like items will be packed together, in no more than [cohortMax] different groups within a single container.

        :param cohort_packing: The cohort_packing of this Pack.
        :type cohort_packing: bool
        """

        self._cohort_packing = cohort_packing

    @property
    def coord_order(self):
        """Gets the coord_order of this Pack.

        If placementStyle is set to \"default\", coordOrder sets the placement priority of axes ascendingly. \"0,1,2\" would search for placement points along the Z(length,\"2\"), then Y(width,\"1\"), and finally X(height\"0\"). Keep in mind that in the default rendering the \"up\" direction is X and the other axes follow the right-hand rule. This is useful for different packing methods. E.g., Utilizing \"2,0,1\" would pack a shipping container first in the Y(width) direction, then in the X(height) direction, and finally in the Z(length) direction, replication a floor-to-ceiling, front-to-back loading method.

        :return: The coord_order of this Pack.
        :rtype: List[int]
        """
        return self._coord_order

    @coord_order.setter
    def coord_order(self, coord_order):
        """Sets the coord_order of this Pack.

        If placementStyle is set to \"default\", coordOrder sets the placement priority of axes ascendingly. \"0,1,2\" would search for placement points along the Z(length,\"2\"), then Y(width,\"1\"), and finally X(height\"0\"). Keep in mind that in the default rendering the \"up\" direction is X and the other axes follow the right-hand rule. This is useful for different packing methods. E.g., Utilizing \"2,0,1\" would pack a shipping container first in the Y(width) direction, then in the X(height) direction, and finally in the Z(length) direction, replication a floor-to-ceiling, front-to-back loading method.

        :param coord_order: The coord_order of this Pack.
        :type coord_order: List[int]
        """

        self._coord_order = coord_order

    @property
    def corners(self):
        """Gets the corners of this Pack.

        only pack items at valid corner points of other items (optimal)

        :return: The corners of this Pack.
        :rtype: bool
        """
        return self._corners

    @corners.setter
    def corners(self, corners):
        """Sets the corners of this Pack.

        only pack items at valid corner points of other items (optimal)

        :param corners: The corners of this Pack.
        :type corners: bool
        """

        self._corners = corners

    @property
    def eye(self):
        """Gets the eye of this Pack.

        The x,y,z coordinates of the virtual eye looking at the package for visualization purposes. Default is isometric, \"1,1,1\". To generate a side view, one could use \"0.001,1.0,0.001\".

        :return: The eye of this Pack.
        :rtype: Point
        """
        return self._eye

    @eye.setter
    def eye(self, eye):
        """Sets the eye of this Pack.

        The x,y,z coordinates of the virtual eye looking at the package for visualization purposes. Default is isometric, \"1,1,1\". To generate a side view, one could use \"0.001,1.0,0.001\".

        :param eye: The eye of this Pack.
        :type eye: Point
        """

        self._eye = eye

    @property
    def img_size(self):
        """Gets the img_size of this Pack.

        width of rendered SVGs in pixels.

        :return: The img_size of this Pack.
        :rtype: int
        """
        return self._img_size

    @img_size.setter
    def img_size(self, img_size):
        """Sets the img_size of this Pack.

        width of rendered SVGs in pixels.

        :param img_size: The img_size of this Pack.
        :type img_size: int
        """

        self._img_size = img_size

    @property
    def include_images(self):
        """Gets the include_images of this Pack.

        include inline images, default is always on

        :return: The include_images of this Pack.
        :rtype: bool
        """
        return self._include_images

    @include_images.setter
    def include_images(self, include_images):
        """Sets the include_images of this Pack.

        include inline images, default is always on

        :param include_images: The include_images of this Pack.
        :type include_images: bool
        """

        self._include_images = include_images

    @property
    def include_scripts(self):
        """Gets the include_scripts of this Pack.

        include inline javascripts and styles for base template

        :return: The include_scripts of this Pack.
        :rtype: bool
        """
        return self._include_scripts

    @include_scripts.setter
    def include_scripts(self, include_scripts):
        """Sets the include_scripts of this Pack.

        include inline javascripts and styles for base template

        :param include_scripts: The include_scripts of this Pack.
        :type include_scripts: bool
        """

        self._include_scripts = include_scripts

    @property
    def interlock(self):
        """Gets the interlock of this Pack.

        alternates layFlat orientation by layer, so as to create an interlocked placement pattern and improve item stability.

        :return: The interlock of this Pack.
        :rtype: bool
        """
        return self._interlock

    @interlock.setter
    def interlock(self, interlock):
        """Sets the interlock of this Pack.

        alternates layFlat orientation by layer, so as to create an interlocked placement pattern and improve item stability.

        :param interlock: The interlock of this Pack.
        :type interlock: bool
        """

        self._interlock = interlock

    @property
    def item_sets(self):
        """Gets the item_sets of this Pack.

        item set definitions if not creating random items.

        :return: The item_sets of this Pack.
        :rtype: List[ItemSet]
        """
        return self._item_sets

    @item_sets.setter
    def item_sets(self, item_sets):
        """Sets the item_sets of this Pack.

        item set definitions if not creating random items.

        :param item_sets: The item_sets of this Pack.
        :type item_sets: List[ItemSet]
        """

        self._item_sets = item_sets

    @property
    def key(self):
        """Gets the key of this Pack.

        issued API key.

        :return: The key of this Pack.
        :rtype: str
        """
        return self._key

    @key.setter
    def key(self, key):
        """Sets the key of this Pack.

        issued API key.

        :param key: The key of this Pack.
        :type key: str
        """

        self._key = key

    @property
    def lay_flat(self):
        """Gets the lay_flat of this Pack.

        aligns all items laying flat. If possible, it may create a \"brick-laying\" pattern to increase stability.

        :return: The lay_flat of this Pack.
        :rtype: bool
        """
        return self._lay_flat

    @lay_flat.setter
    def lay_flat(self, lay_flat):
        """Sets the lay_flat of this Pack.

        aligns all items laying flat. If possible, it may create a \"brick-laying\" pattern to increase stability.

        :param lay_flat: The lay_flat of this Pack.
        :type lay_flat: bool
        """

        self._lay_flat = lay_flat

    @property
    def max_sequence_distance(self):
        """Gets the max_sequence_distance of this Pack.

        This is the maximum distance allowable between two sequence values of items packed in a common box. E.g., \"Distance\" for an item sequence composed of aisle/bin combinations of \"0401\" and \"1228\" has a sequence distance of \\|1228 - 401\\| = 827

        :return: The max_sequence_distance of this Pack.
        :rtype: int
        """
        return self._max_sequence_distance

    @max_sequence_distance.setter
    def max_sequence_distance(self, max_sequence_distance):
        """Sets the max_sequence_distance of this Pack.

        This is the maximum distance allowable between two sequence values of items packed in a common box. E.g., \"Distance\" for an item sequence composed of aisle/bin combinations of \"0401\" and \"1228\" has a sequence distance of \\|1228 - 401\\| = 827

        :param max_sequence_distance: The max_sequence_distance of this Pack.
        :type max_sequence_distance: int
        """

        self._max_sequence_distance = max_sequence_distance

    @property
    def n(self):
        """Gets the n of this Pack.

        number of random items to generate and the quantity of each if \"random\" is set to true. a value of 5 would create 5 different items with a quantity of 5 each, making the total item quantity equal to n&sup2;

        :return: The n of this Pack.
        :rtype: int
        """
        return self._n

    @n.setter
    def n(self, n):
        """Sets the n of this Pack.

        number of random items to generate and the quantity of each if \"random\" is set to true. a value of 5 would create 5 different items with a quantity of 5 each, making the total item quantity equal to n&sup2;

        :param n: The n of this Pack.
        :type n: int
        """

        self._n = n

    @property
    def pack_origin(self):
        """Gets the pack_origin of this Pack.

        the x,y,z coordinates of an optional packing origin. A packing origin is used to create more balanced packing for situations where load needs to be considered. E.g., for a 40\"x48\" pallet, a packOrigin representing the middle of the pallet, \"0,20,24\", would cause placement to minimize the distance of the packed items from the center of the pallet.

        :return: The pack_origin of this Pack.
        :rtype: Point
        """
        return self._pack_origin

    @pack_origin.setter
    def pack_origin(self, pack_origin):
        """Sets the pack_origin of this Pack.

        the x,y,z coordinates of an optional packing origin. A packing origin is used to create more balanced packing for situations where load needs to be considered. E.g., for a 40\"x48\" pallet, a packOrigin representing the middle of the pallet, \"0,20,24\", would cause placement to minimize the distance of the packed items from the center of the pallet.

        :param pack_origin: The pack_origin of this Pack.
        :type pack_origin: Point
        """

        self._pack_origin = pack_origin

    @property
    def placement_style(self):
        """Gets the placement_style of this Pack.

        How to place items. 'default' will defer to coordOrder, 'corner' minimizes distance to rear, bottom corner, 'wedge' minimizes distance to middle of bottom, back edge, 'mound' minimizes distance to center of carton bottom.

        :return: The placement_style of this Pack.
        :rtype: str
        """
        return self._placement_style

    @placement_style.setter
    def placement_style(self, placement_style):
        """Sets the placement_style of this Pack.

        How to place items. 'default' will defer to coordOrder, 'corner' minimizes distance to rear, bottom corner, 'wedge' minimizes distance to middle of bottom, back edge, 'mound' minimizes distance to center of carton bottom.

        :param placement_style: The placement_style of this Pack.
        :type placement_style: str
        """
        allowed_values = ["default", "corner", "wedge", "mound", "orb"]  # noqa: E501
        if placement_style not in allowed_values:
            raise ValueError(
                "Invalid value for `placement_style` ({0}), must be one of {1}"
                .format(placement_style, allowed_values)
            )

        self._placement_style = placement_style

    @property
    def random(self):
        """Gets the random of this Pack.

        create random items

        :return: The random of this Pack.
        :rtype: bool
        """
        return self._random

    @random.setter
    def random(self, random):
        """Sets the random of this Pack.

        create random items

        :param random: The random of this Pack.
        :type random: bool
        """

        self._random = random

    @property
    def random_max_dimension(self):
        """Gets the random_max_dimension of this Pack.

        maximum item dimension along a single axis for randomly generated items.

        :return: The random_max_dimension of this Pack.
        :rtype: int
        """
        return self._random_max_dimension

    @random_max_dimension.setter
    def random_max_dimension(self, random_max_dimension):
        """Sets the random_max_dimension of this Pack.

        maximum item dimension along a single axis for randomly generated items.

        :param random_max_dimension: The random_max_dimension of this Pack.
        :type random_max_dimension: int
        """

        self._random_max_dimension = random_max_dimension

    @property
    def random_max_weight(self):
        """Gets the random_max_weight of this Pack.

        maximum item weight for randomly generated items.

        :return: The random_max_weight of this Pack.
        :rtype: int
        """
        return self._random_max_weight

    @random_max_weight.setter
    def random_max_weight(self, random_max_weight):
        """Sets the random_max_weight of this Pack.

        maximum item weight for randomly generated items.

        :param random_max_weight: The random_max_weight of this Pack.
        :type random_max_weight: int
        """

        self._random_max_weight = random_max_weight

    @property
    def rules(self):
        """Gets the rules of this Pack.

        Array of packing rules.

        :return: The rules of this Pack.
        :rtype: List[Rule]
        """
        return self._rules

    @rules.setter
    def rules(self, rules):
        """Sets the rules of this Pack.

        Array of packing rules.

        :param rules: The rules of this Pack.
        :type rules: List[Rule]
        """

        self._rules = rules

    @property
    def seed(self):
        """Gets the seed of this Pack.

        if random is selected, seed the random number generator to deterministically generate random items to pack.

        :return: The seed of this Pack.
        :rtype: bool
        """
        return self._seed

    @seed.setter
    def seed(self, seed):
        """Sets the seed of this Pack.

        if random is selected, seed the random number generator to deterministically generate random items to pack.

        :param seed: The seed of this Pack.
        :type seed: bool
        """

        self._seed = seed

    @property
    def sequence_heat_map(self):
        """Gets the sequence_heat_map of this Pack.

        Colorize items solely by their sequence value, light when sequence is high, dark when it is low. Useful for indicating item bin location, weight, or other sequence property that may not be apparent from the default visualization.

        :return: The sequence_heat_map of this Pack.
        :rtype: bool
        """
        return self._sequence_heat_map

    @sequence_heat_map.setter
    def sequence_heat_map(self, sequence_heat_map):
        """Sets the sequence_heat_map of this Pack.

        Colorize items solely by their sequence value, light when sequence is high, dark when it is low. Useful for indicating item bin location, weight, or other sequence property that may not be apparent from the default visualization.

        :param sequence_heat_map: The sequence_heat_map of this Pack.
        :type sequence_heat_map: bool
        """

        self._sequence_heat_map = sequence_heat_map

    @property
    def sequence_sort(self):
        """Gets the sequence_sort of this Pack.

        Whether or not the items should be initially sorted by their sequence value instead of their volume. This is not always useful, as the default \"biggest-first\" volume sort is very effective for items, and constraining by maxSequenceDistance is applied regardless of this field. That said, for doing custom pre-sorts such as weight-based instead of volume based, this value should be set to true.

        :return: The sequence_sort of this Pack.
        :rtype: bool
        """
        return self._sequence_sort

    @sequence_sort.setter
    def sequence_sort(self, sequence_sort):
        """Sets the sequence_sort of this Pack.

        Whether or not the items should be initially sorted by their sequence value instead of their volume. This is not always useful, as the default \"biggest-first\" volume sort is very effective for items, and constraining by maxSequenceDistance is applied regardless of this field. That said, for doing custom pre-sorts such as weight-based instead of volume based, this value should be set to true.

        :param sequence_sort: The sequence_sort of this Pack.
        :type sequence_sort: bool
        """

        self._sequence_sort = sequence_sort

    @property
    def template(self):
        """Gets the template of this Pack.

        template name for markup generation.

        :return: The template of this Pack.
        :rtype: str
        """
        return self._template

    @template.setter
    def template(self, template):
        """Sets the template of this Pack.

        template name for markup generation.

        :param template: The template of this Pack.
        :type template: str
        """
        allowed_values = ["demo.tmpl", "shipapp.tmpl", "boat.tmpl"]  # noqa: E501
        if template not in allowed_values:
            raise ValueError(
                "Invalid value for `template` ({0}), must be one of {1}"
                .format(template, allowed_values)
            )

        self._template = template

    @property
    def usable_space(self):
        """Gets the usable_space of this Pack.

        estimate of percentage space in boxes that is usable, i.e., not packing material.

        :return: The usable_space of this Pack.
        :rtype: float
        """
        return self._usable_space

    @usable_space.setter
    def usable_space(self, usable_space):
        """Sets the usable_space of this Pack.

        estimate of percentage space in boxes that is usable, i.e., not packing material.

        :param usable_space: The usable_space of this Pack.
        :type usable_space: float
        """
        if usable_space is not None and usable_space > 1:
            raise ValueError("Invalid value for `usable_space`, must be a value less than or equal to `1`")
        if usable_space is not None and usable_space < 0:
            raise ValueError("Invalid value for `usable_space`, must be a value greater than or equal to `0`")

        self._usable_space = usable_space

    @property
    def zone(self):
        """Gets the zone of this Pack.

        <b>[experimental]</b> the shipping zone in order to use basic zone-based price optimization.

        :return: The zone of this Pack.
        :rtype: int
        """
        return self._zone

    @zone.setter
    def zone(self, zone):
        """Sets the zone of this Pack.

        <b>[experimental]</b> the shipping zone in order to use basic zone-based price optimization.

        :param zone: The zone of this Pack.
        :type zone: int
        """
        if zone is not None and zone < 1:
            raise ValueError("Invalid value for `zone`, must be a value greater than or equal to `1`")

        self._zone = zone
