# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class RateTable(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, base_price: float=None, carrier: str=None, dim_factor: float=None, price_increase_rate: float=None, rates: List[float]=None, service: str=None, weights: List[float]=None, zone: str=None):
        """RateTable - a model defined in OpenAPI

        :param base_price: The base_price of this RateTable.
        :param carrier: The carrier of this RateTable.
        :param dim_factor: The dim_factor of this RateTable.
        :param price_increase_rate: The price_increase_rate of this RateTable.
        :param rates: The rates of this RateTable.
        :param service: The service of this RateTable.
        :param weights: The weights of this RateTable.
        :param zone: The zone of this RateTable.
        """
        self.openapi_types = {
            'base_price': float,
            'carrier': str,
            'dim_factor': float,
            'price_increase_rate': float,
            'rates': List[float],
            'service': str,
            'weights': List[float],
            'zone': str
        }

        self.attribute_map = {
            'base_price': 'basePrice',
            'carrier': 'carrier',
            'dim_factor': 'dimFactor',
            'price_increase_rate': 'priceIncreaseRate',
            'rates': 'rates',
            'service': 'service',
            'weights': 'weights',
            'zone': 'zone'
        }

        self._base_price = base_price
        self._carrier = carrier
        self._dim_factor = dim_factor
        self._price_increase_rate = price_increase_rate
        self._rates = rates
        self._service = service
        self._weights = weights
        self._zone = zone

    @classmethod
    def from_dict(cls, dikt: dict) -> 'RateTable':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The RateTable of this RateTable.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def base_price(self):
        """Gets the base_price of this RateTable.

        The basePrice can be found by estimating the lowest weight-based rate available for a given service, in the example above, solving for basePrice for a $10, 1lb package with the already-solved priceIncreaseRate yields <pre>$10 = $5/lb * 1lb + basePrice<br/>$10 = $5 + basePrice<br/>basePrice = $5</pre>

        :return: The base_price of this RateTable.
        :rtype: float
        """
        return self._base_price

    @base_price.setter
    def base_price(self, base_price):
        """Sets the base_price of this RateTable.

        The basePrice can be found by estimating the lowest weight-based rate available for a given service, in the example above, solving for basePrice for a $10, 1lb package with the already-solved priceIncreaseRate yields <pre>$10 = $5/lb * 1lb + basePrice<br/>$10 = $5 + basePrice<br/>basePrice = $5</pre>

        :param base_price: The base_price of this RateTable.
        :type base_price: float
        """

        self._base_price = base_price

    @property
    def carrier(self):
        """Gets the carrier of this RateTable.

        carrier name for rate table to use

        :return: The carrier of this RateTable.
        :rtype: str
        """
        return self._carrier

    @carrier.setter
    def carrier(self, carrier):
        """Sets the carrier of this RateTable.

        carrier name for rate table to use

        :param carrier: The carrier of this RateTable.
        :type carrier: str
        """

        self._carrier = carrier

    @property
    def dim_factor(self):
        """Gets the dim_factor of this RateTable.

        This is the Dimensional Weight divisor. It is given in units of volume per unit weight, e.g., the standard of \"139\" represents 139 cubic inches per pound, and is used to convert the total volume of a carton into a functional minimum weight to be used when rating the carton. E.g., a carton with dimensions 10\" x 10\" x 13.9\" would yield a volume of 1390 cubic inches. This yields <pre>cartonEffectiveMinimumWeight = 1390in&sup3; / 139in&sup3;/lb<br/>cartonEffectiveMinimumWeight = 10lbs</pre>

        :return: The dim_factor of this RateTable.
        :rtype: float
        """
        return self._dim_factor

    @dim_factor.setter
    def dim_factor(self, dim_factor):
        """Sets the dim_factor of this RateTable.

        This is the Dimensional Weight divisor. It is given in units of volume per unit weight, e.g., the standard of \"139\" represents 139 cubic inches per pound, and is used to convert the total volume of a carton into a functional minimum weight to be used when rating the carton. E.g., a carton with dimensions 10\" x 10\" x 13.9\" would yield a volume of 1390 cubic inches. This yields <pre>cartonEffectiveMinimumWeight = 1390in&sup3; / 139in&sup3;/lb<br/>cartonEffectiveMinimumWeight = 10lbs</pre>

        :param dim_factor: The dim_factor of this RateTable.
        :type dim_factor: float
        """

        self._dim_factor = dim_factor

    @property
    def price_increase_rate(self):
        """Gets the price_increase_rate of this RateTable.

        Instead of providing the full rate table, you can list a carton \"basePrice\" and a carton \"priceIncreaseRate\". These two values will be used in a simple linear model to guess carton price, i.e., <pre>cartonPrice = priceIncreaseRate * cartonWeight + basePrice</pre> Oftentimes, this will be enough to get accurate carton selections without needing to send complete customer-based rates. It's worth considering, as the prices are only estimates to be used in carton selection, with final rating of cartons happening outside of paccurate. This is the predicted rate of increase for a weight-based pricing model. The simplest way to find a servicable value is to take <pre>priceIncreaseRate = (maximumPrice - minimumPrice)/(maximumWeight - minimumWeight)</pre> In the example above, this would yield <pre>priceIncreaseRate = ($20-$10)/(3lbs-1lb)<br/>priceIncreaseRate = $10/2lbs<br/>priceIncreaseRate = $5/lb</pre>

        :return: The price_increase_rate of this RateTable.
        :rtype: float
        """
        return self._price_increase_rate

    @price_increase_rate.setter
    def price_increase_rate(self, price_increase_rate):
        """Sets the price_increase_rate of this RateTable.

        Instead of providing the full rate table, you can list a carton \"basePrice\" and a carton \"priceIncreaseRate\". These two values will be used in a simple linear model to guess carton price, i.e., <pre>cartonPrice = priceIncreaseRate * cartonWeight + basePrice</pre> Oftentimes, this will be enough to get accurate carton selections without needing to send complete customer-based rates. It's worth considering, as the prices are only estimates to be used in carton selection, with final rating of cartons happening outside of paccurate. This is the predicted rate of increase for a weight-based pricing model. The simplest way to find a servicable value is to take <pre>priceIncreaseRate = (maximumPrice - minimumPrice)/(maximumWeight - minimumWeight)</pre> In the example above, this would yield <pre>priceIncreaseRate = ($20-$10)/(3lbs-1lb)<br/>priceIncreaseRate = $10/2lbs<br/>priceIncreaseRate = $5/lb</pre>

        :param price_increase_rate: The price_increase_rate of this RateTable.
        :type price_increase_rate: float
        """

        self._price_increase_rate = price_increase_rate

    @property
    def rates(self):
        """Gets the rates of this RateTable.

        list of prices to use for the weight that corresponds to its index, e.g., [10, 15, 20] would be $10 for 1lb, $15 for 2lbs, $20 for 3lbs.

        :return: The rates of this RateTable.
        :rtype: List[float]
        """
        return self._rates

    @rates.setter
    def rates(self, rates):
        """Sets the rates of this RateTable.

        list of prices to use for the weight that corresponds to its index, e.g., [10, 15, 20] would be $10 for 1lb, $15 for 2lbs, $20 for 3lbs.

        :param rates: The rates of this RateTable.
        :type rates: List[float]
        """

        self._rates = rates

    @property
    def service(self):
        """Gets the service of this RateTable.

        service name for rate table to use

        :return: The service of this RateTable.
        :rtype: str
        """
        return self._service

    @service.setter
    def service(self, service):
        """Sets the service of this RateTable.

        service name for rate table to use

        :param service: The service of this RateTable.
        :type service: str
        """

        self._service = service

    @property
    def weights(self):
        """Gets the weights of this RateTable.

        list of weights to use for the rate that corresponds to its index, e.g., [1, 2, 3] would mean 1lb for the minimum rate ($10), 2lbs for the second rate ($15), and 3lbs for the highest rate ($20). Note that if the highest value from this list is less than the weightMax of the carton, all carton weights exceeding the maximum from this list up to the carton weightMax will not pro-rate but will be estimated at the maximum value in the rate table.

        :return: The weights of this RateTable.
        :rtype: List[float]
        """
        return self._weights

    @weights.setter
    def weights(self, weights):
        """Sets the weights of this RateTable.

        list of weights to use for the rate that corresponds to its index, e.g., [1, 2, 3] would mean 1lb for the minimum rate ($10), 2lbs for the second rate ($15), and 3lbs for the highest rate ($20). Note that if the highest value from this list is less than the weightMax of the carton, all carton weights exceeding the maximum from this list up to the carton weightMax will not pro-rate but will be estimated at the maximum value in the rate table.

        :param weights: The weights of this RateTable.
        :type weights: List[float]
        """

        self._weights = weights

    @property
    def zone(self):
        """Gets the zone of this RateTable.

        zone of rate table to use

        :return: The zone of this RateTable.
        :rtype: str
        """
        return self._zone

    @zone.setter
    def zone(self, zone):
        """Sets the zone of this RateTable.

        zone of rate table to use

        :param zone: The zone of this RateTable.
        :type zone: str
        """

        self._zone = zone
