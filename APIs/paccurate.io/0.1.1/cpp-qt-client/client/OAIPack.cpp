/**
 * paccurate.io
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPack.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPack::OAIPack(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPack::OAIPack() {
    this->initializeModel();
}

OAIPack::~OAIPack() {}

void OAIPack::initializeModel() {

    m_allowable_overhang_isSet = false;
    m_allowable_overhang_isValid = false;

    m_box_type_sets_isSet = false;
    m_box_type_sets_isValid = false;

    m_box_types_isSet = false;
    m_box_types_isValid = false;

    m_cohort_max_isSet = false;
    m_cohort_max_isValid = false;

    m_cohort_packing_isSet = false;
    m_cohort_packing_isValid = false;

    m_coord_order_isSet = false;
    m_coord_order_isValid = false;

    m_corners_isSet = false;
    m_corners_isValid = false;

    m_eye_isSet = false;
    m_eye_isValid = false;

    m_img_size_isSet = false;
    m_img_size_isValid = false;

    m_include_images_isSet = false;
    m_include_images_isValid = false;

    m_include_scripts_isSet = false;
    m_include_scripts_isValid = false;

    m_interlock_isSet = false;
    m_interlock_isValid = false;

    m_item_sets_isSet = false;
    m_item_sets_isValid = false;

    m_key_isSet = false;
    m_key_isValid = false;

    m_lay_flat_isSet = false;
    m_lay_flat_isValid = false;

    m_max_sequence_distance_isSet = false;
    m_max_sequence_distance_isValid = false;

    m_n_isSet = false;
    m_n_isValid = false;

    m_pack_origin_isSet = false;
    m_pack_origin_isValid = false;

    m_placement_style_isSet = false;
    m_placement_style_isValid = false;

    m_random_isSet = false;
    m_random_isValid = false;

    m_random_max_dimension_isSet = false;
    m_random_max_dimension_isValid = false;

    m_random_max_weight_isSet = false;
    m_random_max_weight_isValid = false;

    m_rules_isSet = false;
    m_rules_isValid = false;

    m_seed_isSet = false;
    m_seed_isValid = false;

    m_sequence_heat_map_isSet = false;
    m_sequence_heat_map_isValid = false;

    m_sequence_sort_isSet = false;
    m_sequence_sort_isValid = false;

    m_r_template_isSet = false;
    m_r_template_isValid = false;

    m_usable_space_isSet = false;
    m_usable_space_isValid = false;

    m_zone_isSet = false;
    m_zone_isValid = false;
}

void OAIPack::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPack::fromJsonObject(QJsonObject json) {

    m_allowable_overhang_isValid = ::OpenAPI::fromJsonValue(m_allowable_overhang, json[QString("allowableOverhang")]);
    m_allowable_overhang_isSet = !json[QString("allowableOverhang")].isNull() && m_allowable_overhang_isValid;

    m_box_type_sets_isValid = ::OpenAPI::fromJsonValue(m_box_type_sets, json[QString("boxTypeSets")]);
    m_box_type_sets_isSet = !json[QString("boxTypeSets")].isNull() && m_box_type_sets_isValid;

    m_box_types_isValid = ::OpenAPI::fromJsonValue(m_box_types, json[QString("boxTypes")]);
    m_box_types_isSet = !json[QString("boxTypes")].isNull() && m_box_types_isValid;

    m_cohort_max_isValid = ::OpenAPI::fromJsonValue(m_cohort_max, json[QString("cohortMax")]);
    m_cohort_max_isSet = !json[QString("cohortMax")].isNull() && m_cohort_max_isValid;

    m_cohort_packing_isValid = ::OpenAPI::fromJsonValue(m_cohort_packing, json[QString("cohortPacking")]);
    m_cohort_packing_isSet = !json[QString("cohortPacking")].isNull() && m_cohort_packing_isValid;

    m_coord_order_isValid = ::OpenAPI::fromJsonValue(m_coord_order, json[QString("coordOrder")]);
    m_coord_order_isSet = !json[QString("coordOrder")].isNull() && m_coord_order_isValid;

    m_corners_isValid = ::OpenAPI::fromJsonValue(m_corners, json[QString("corners")]);
    m_corners_isSet = !json[QString("corners")].isNull() && m_corners_isValid;

    m_eye_isValid = ::OpenAPI::fromJsonValue(m_eye, json[QString("eye")]);
    m_eye_isSet = !json[QString("eye")].isNull() && m_eye_isValid;

    m_img_size_isValid = ::OpenAPI::fromJsonValue(m_img_size, json[QString("imgSize")]);
    m_img_size_isSet = !json[QString("imgSize")].isNull() && m_img_size_isValid;

    m_include_images_isValid = ::OpenAPI::fromJsonValue(m_include_images, json[QString("includeImages")]);
    m_include_images_isSet = !json[QString("includeImages")].isNull() && m_include_images_isValid;

    m_include_scripts_isValid = ::OpenAPI::fromJsonValue(m_include_scripts, json[QString("includeScripts")]);
    m_include_scripts_isSet = !json[QString("includeScripts")].isNull() && m_include_scripts_isValid;

    m_interlock_isValid = ::OpenAPI::fromJsonValue(m_interlock, json[QString("interlock")]);
    m_interlock_isSet = !json[QString("interlock")].isNull() && m_interlock_isValid;

    m_item_sets_isValid = ::OpenAPI::fromJsonValue(m_item_sets, json[QString("itemSets")]);
    m_item_sets_isSet = !json[QString("itemSets")].isNull() && m_item_sets_isValid;

    m_key_isValid = ::OpenAPI::fromJsonValue(m_key, json[QString("key")]);
    m_key_isSet = !json[QString("key")].isNull() && m_key_isValid;

    m_lay_flat_isValid = ::OpenAPI::fromJsonValue(m_lay_flat, json[QString("layFlat")]);
    m_lay_flat_isSet = !json[QString("layFlat")].isNull() && m_lay_flat_isValid;

    m_max_sequence_distance_isValid = ::OpenAPI::fromJsonValue(m_max_sequence_distance, json[QString("maxSequenceDistance")]);
    m_max_sequence_distance_isSet = !json[QString("maxSequenceDistance")].isNull() && m_max_sequence_distance_isValid;

    m_n_isValid = ::OpenAPI::fromJsonValue(m_n, json[QString("n")]);
    m_n_isSet = !json[QString("n")].isNull() && m_n_isValid;

    m_pack_origin_isValid = ::OpenAPI::fromJsonValue(m_pack_origin, json[QString("packOrigin")]);
    m_pack_origin_isSet = !json[QString("packOrigin")].isNull() && m_pack_origin_isValid;

    m_placement_style_isValid = ::OpenAPI::fromJsonValue(m_placement_style, json[QString("placementStyle")]);
    m_placement_style_isSet = !json[QString("placementStyle")].isNull() && m_placement_style_isValid;

    m_random_isValid = ::OpenAPI::fromJsonValue(m_random, json[QString("random")]);
    m_random_isSet = !json[QString("random")].isNull() && m_random_isValid;

    m_random_max_dimension_isValid = ::OpenAPI::fromJsonValue(m_random_max_dimension, json[QString("randomMaxDimension")]);
    m_random_max_dimension_isSet = !json[QString("randomMaxDimension")].isNull() && m_random_max_dimension_isValid;

    m_random_max_weight_isValid = ::OpenAPI::fromJsonValue(m_random_max_weight, json[QString("randomMaxWeight")]);
    m_random_max_weight_isSet = !json[QString("randomMaxWeight")].isNull() && m_random_max_weight_isValid;

    m_rules_isValid = ::OpenAPI::fromJsonValue(m_rules, json[QString("rules")]);
    m_rules_isSet = !json[QString("rules")].isNull() && m_rules_isValid;

    m_seed_isValid = ::OpenAPI::fromJsonValue(m_seed, json[QString("seed")]);
    m_seed_isSet = !json[QString("seed")].isNull() && m_seed_isValid;

    m_sequence_heat_map_isValid = ::OpenAPI::fromJsonValue(m_sequence_heat_map, json[QString("sequenceHeatMap")]);
    m_sequence_heat_map_isSet = !json[QString("sequenceHeatMap")].isNull() && m_sequence_heat_map_isValid;

    m_sequence_sort_isValid = ::OpenAPI::fromJsonValue(m_sequence_sort, json[QString("sequenceSort")]);
    m_sequence_sort_isSet = !json[QString("sequenceSort")].isNull() && m_sequence_sort_isValid;

    m_r_template_isValid = ::OpenAPI::fromJsonValue(m_r_template, json[QString("template")]);
    m_r_template_isSet = !json[QString("template")].isNull() && m_r_template_isValid;

    m_usable_space_isValid = ::OpenAPI::fromJsonValue(m_usable_space, json[QString("usableSpace")]);
    m_usable_space_isSet = !json[QString("usableSpace")].isNull() && m_usable_space_isValid;

    m_zone_isValid = ::OpenAPI::fromJsonValue(m_zone, json[QString("zone")]);
    m_zone_isSet = !json[QString("zone")].isNull() && m_zone_isValid;
}

QString OAIPack::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPack::asJsonObject() const {
    QJsonObject obj;
    if (m_allowable_overhang_isSet) {
        obj.insert(QString("allowableOverhang"), ::OpenAPI::toJsonValue(m_allowable_overhang));
    }
    if (m_box_type_sets.size() > 0) {
        obj.insert(QString("boxTypeSets"), ::OpenAPI::toJsonValue(m_box_type_sets));
    }
    if (m_box_types.size() > 0) {
        obj.insert(QString("boxTypes"), ::OpenAPI::toJsonValue(m_box_types));
    }
    if (m_cohort_max_isSet) {
        obj.insert(QString("cohortMax"), ::OpenAPI::toJsonValue(m_cohort_max));
    }
    if (m_cohort_packing_isSet) {
        obj.insert(QString("cohortPacking"), ::OpenAPI::toJsonValue(m_cohort_packing));
    }
    if (m_coord_order.size() > 0) {
        obj.insert(QString("coordOrder"), ::OpenAPI::toJsonValue(m_coord_order));
    }
    if (m_corners_isSet) {
        obj.insert(QString("corners"), ::OpenAPI::toJsonValue(m_corners));
    }
    if (m_eye.isSet()) {
        obj.insert(QString("eye"), ::OpenAPI::toJsonValue(m_eye));
    }
    if (m_img_size_isSet) {
        obj.insert(QString("imgSize"), ::OpenAPI::toJsonValue(m_img_size));
    }
    if (m_include_images_isSet) {
        obj.insert(QString("includeImages"), ::OpenAPI::toJsonValue(m_include_images));
    }
    if (m_include_scripts_isSet) {
        obj.insert(QString("includeScripts"), ::OpenAPI::toJsonValue(m_include_scripts));
    }
    if (m_interlock_isSet) {
        obj.insert(QString("interlock"), ::OpenAPI::toJsonValue(m_interlock));
    }
    if (m_item_sets.size() > 0) {
        obj.insert(QString("itemSets"), ::OpenAPI::toJsonValue(m_item_sets));
    }
    if (m_key_isSet) {
        obj.insert(QString("key"), ::OpenAPI::toJsonValue(m_key));
    }
    if (m_lay_flat_isSet) {
        obj.insert(QString("layFlat"), ::OpenAPI::toJsonValue(m_lay_flat));
    }
    if (m_max_sequence_distance_isSet) {
        obj.insert(QString("maxSequenceDistance"), ::OpenAPI::toJsonValue(m_max_sequence_distance));
    }
    if (m_n_isSet) {
        obj.insert(QString("n"), ::OpenAPI::toJsonValue(m_n));
    }
    if (m_pack_origin.isSet()) {
        obj.insert(QString("packOrigin"), ::OpenAPI::toJsonValue(m_pack_origin));
    }
    if (m_placement_style_isSet) {
        obj.insert(QString("placementStyle"), ::OpenAPI::toJsonValue(m_placement_style));
    }
    if (m_random_isSet) {
        obj.insert(QString("random"), ::OpenAPI::toJsonValue(m_random));
    }
    if (m_random_max_dimension_isSet) {
        obj.insert(QString("randomMaxDimension"), ::OpenAPI::toJsonValue(m_random_max_dimension));
    }
    if (m_random_max_weight_isSet) {
        obj.insert(QString("randomMaxWeight"), ::OpenAPI::toJsonValue(m_random_max_weight));
    }
    if (m_rules.size() > 0) {
        obj.insert(QString("rules"), ::OpenAPI::toJsonValue(m_rules));
    }
    if (m_seed_isSet) {
        obj.insert(QString("seed"), ::OpenAPI::toJsonValue(m_seed));
    }
    if (m_sequence_heat_map_isSet) {
        obj.insert(QString("sequenceHeatMap"), ::OpenAPI::toJsonValue(m_sequence_heat_map));
    }
    if (m_sequence_sort_isSet) {
        obj.insert(QString("sequenceSort"), ::OpenAPI::toJsonValue(m_sequence_sort));
    }
    if (m_r_template_isSet) {
        obj.insert(QString("template"), ::OpenAPI::toJsonValue(m_r_template));
    }
    if (m_usable_space_isSet) {
        obj.insert(QString("usableSpace"), ::OpenAPI::toJsonValue(m_usable_space));
    }
    if (m_zone_isSet) {
        obj.insert(QString("zone"), ::OpenAPI::toJsonValue(m_zone));
    }
    return obj;
}

double OAIPack::getAllowableOverhang() const {
    return m_allowable_overhang;
}
void OAIPack::setAllowableOverhang(const double &allowable_overhang) {
    m_allowable_overhang = allowable_overhang;
    m_allowable_overhang_isSet = true;
}

bool OAIPack::is_allowable_overhang_Set() const{
    return m_allowable_overhang_isSet;
}

bool OAIPack::is_allowable_overhang_Valid() const{
    return m_allowable_overhang_isValid;
}

QList<OAIBoxTypeSet> OAIPack::getBoxTypeSets() const {
    return m_box_type_sets;
}
void OAIPack::setBoxTypeSets(const QList<OAIBoxTypeSet> &box_type_sets) {
    m_box_type_sets = box_type_sets;
    m_box_type_sets_isSet = true;
}

bool OAIPack::is_box_type_sets_Set() const{
    return m_box_type_sets_isSet;
}

bool OAIPack::is_box_type_sets_Valid() const{
    return m_box_type_sets_isValid;
}

QList<OAIBoxType> OAIPack::getBoxTypes() const {
    return m_box_types;
}
void OAIPack::setBoxTypes(const QList<OAIBoxType> &box_types) {
    m_box_types = box_types;
    m_box_types_isSet = true;
}

bool OAIPack::is_box_types_Set() const{
    return m_box_types_isSet;
}

bool OAIPack::is_box_types_Valid() const{
    return m_box_types_isValid;
}

qint32 OAIPack::getCohortMax() const {
    return m_cohort_max;
}
void OAIPack::setCohortMax(const qint32 &cohort_max) {
    m_cohort_max = cohort_max;
    m_cohort_max_isSet = true;
}

bool OAIPack::is_cohort_max_Set() const{
    return m_cohort_max_isSet;
}

bool OAIPack::is_cohort_max_Valid() const{
    return m_cohort_max_isValid;
}

bool OAIPack::isCohortPacking() const {
    return m_cohort_packing;
}
void OAIPack::setCohortPacking(const bool &cohort_packing) {
    m_cohort_packing = cohort_packing;
    m_cohort_packing_isSet = true;
}

bool OAIPack::is_cohort_packing_Set() const{
    return m_cohort_packing_isSet;
}

bool OAIPack::is_cohort_packing_Valid() const{
    return m_cohort_packing_isValid;
}

QList<qint32> OAIPack::getCoordOrder() const {
    return m_coord_order;
}
void OAIPack::setCoordOrder(const QList<qint32> &coord_order) {
    m_coord_order = coord_order;
    m_coord_order_isSet = true;
}

bool OAIPack::is_coord_order_Set() const{
    return m_coord_order_isSet;
}

bool OAIPack::is_coord_order_Valid() const{
    return m_coord_order_isValid;
}

bool OAIPack::isCorners() const {
    return m_corners;
}
void OAIPack::setCorners(const bool &corners) {
    m_corners = corners;
    m_corners_isSet = true;
}

bool OAIPack::is_corners_Set() const{
    return m_corners_isSet;
}

bool OAIPack::is_corners_Valid() const{
    return m_corners_isValid;
}

OAIPoint OAIPack::getEye() const {
    return m_eye;
}
void OAIPack::setEye(const OAIPoint &eye) {
    m_eye = eye;
    m_eye_isSet = true;
}

bool OAIPack::is_eye_Set() const{
    return m_eye_isSet;
}

bool OAIPack::is_eye_Valid() const{
    return m_eye_isValid;
}

qint32 OAIPack::getImgSize() const {
    return m_img_size;
}
void OAIPack::setImgSize(const qint32 &img_size) {
    m_img_size = img_size;
    m_img_size_isSet = true;
}

bool OAIPack::is_img_size_Set() const{
    return m_img_size_isSet;
}

bool OAIPack::is_img_size_Valid() const{
    return m_img_size_isValid;
}

bool OAIPack::isIncludeImages() const {
    return m_include_images;
}
void OAIPack::setIncludeImages(const bool &include_images) {
    m_include_images = include_images;
    m_include_images_isSet = true;
}

bool OAIPack::is_include_images_Set() const{
    return m_include_images_isSet;
}

bool OAIPack::is_include_images_Valid() const{
    return m_include_images_isValid;
}

bool OAIPack::isIncludeScripts() const {
    return m_include_scripts;
}
void OAIPack::setIncludeScripts(const bool &include_scripts) {
    m_include_scripts = include_scripts;
    m_include_scripts_isSet = true;
}

bool OAIPack::is_include_scripts_Set() const{
    return m_include_scripts_isSet;
}

bool OAIPack::is_include_scripts_Valid() const{
    return m_include_scripts_isValid;
}

bool OAIPack::isInterlock() const {
    return m_interlock;
}
void OAIPack::setInterlock(const bool &interlock) {
    m_interlock = interlock;
    m_interlock_isSet = true;
}

bool OAIPack::is_interlock_Set() const{
    return m_interlock_isSet;
}

bool OAIPack::is_interlock_Valid() const{
    return m_interlock_isValid;
}

QList<OAIItemSet> OAIPack::getItemSets() const {
    return m_item_sets;
}
void OAIPack::setItemSets(const QList<OAIItemSet> &item_sets) {
    m_item_sets = item_sets;
    m_item_sets_isSet = true;
}

bool OAIPack::is_item_sets_Set() const{
    return m_item_sets_isSet;
}

bool OAIPack::is_item_sets_Valid() const{
    return m_item_sets_isValid;
}

QString OAIPack::getKey() const {
    return m_key;
}
void OAIPack::setKey(const QString &key) {
    m_key = key;
    m_key_isSet = true;
}

bool OAIPack::is_key_Set() const{
    return m_key_isSet;
}

bool OAIPack::is_key_Valid() const{
    return m_key_isValid;
}

bool OAIPack::isLayFlat() const {
    return m_lay_flat;
}
void OAIPack::setLayFlat(const bool &lay_flat) {
    m_lay_flat = lay_flat;
    m_lay_flat_isSet = true;
}

bool OAIPack::is_lay_flat_Set() const{
    return m_lay_flat_isSet;
}

bool OAIPack::is_lay_flat_Valid() const{
    return m_lay_flat_isValid;
}

qint32 OAIPack::getMaxSequenceDistance() const {
    return m_max_sequence_distance;
}
void OAIPack::setMaxSequenceDistance(const qint32 &max_sequence_distance) {
    m_max_sequence_distance = max_sequence_distance;
    m_max_sequence_distance_isSet = true;
}

bool OAIPack::is_max_sequence_distance_Set() const{
    return m_max_sequence_distance_isSet;
}

bool OAIPack::is_max_sequence_distance_Valid() const{
    return m_max_sequence_distance_isValid;
}

qint32 OAIPack::getN() const {
    return m_n;
}
void OAIPack::setN(const qint32 &n) {
    m_n = n;
    m_n_isSet = true;
}

bool OAIPack::is_n_Set() const{
    return m_n_isSet;
}

bool OAIPack::is_n_Valid() const{
    return m_n_isValid;
}

OAIPoint OAIPack::getPackOrigin() const {
    return m_pack_origin;
}
void OAIPack::setPackOrigin(const OAIPoint &pack_origin) {
    m_pack_origin = pack_origin;
    m_pack_origin_isSet = true;
}

bool OAIPack::is_pack_origin_Set() const{
    return m_pack_origin_isSet;
}

bool OAIPack::is_pack_origin_Valid() const{
    return m_pack_origin_isValid;
}

QString OAIPack::getPlacementStyle() const {
    return m_placement_style;
}
void OAIPack::setPlacementStyle(const QString &placement_style) {
    m_placement_style = placement_style;
    m_placement_style_isSet = true;
}

bool OAIPack::is_placement_style_Set() const{
    return m_placement_style_isSet;
}

bool OAIPack::is_placement_style_Valid() const{
    return m_placement_style_isValid;
}

bool OAIPack::isRandom() const {
    return m_random;
}
void OAIPack::setRandom(const bool &random) {
    m_random = random;
    m_random_isSet = true;
}

bool OAIPack::is_random_Set() const{
    return m_random_isSet;
}

bool OAIPack::is_random_Valid() const{
    return m_random_isValid;
}

qint32 OAIPack::getRandomMaxDimension() const {
    return m_random_max_dimension;
}
void OAIPack::setRandomMaxDimension(const qint32 &random_max_dimension) {
    m_random_max_dimension = random_max_dimension;
    m_random_max_dimension_isSet = true;
}

bool OAIPack::is_random_max_dimension_Set() const{
    return m_random_max_dimension_isSet;
}

bool OAIPack::is_random_max_dimension_Valid() const{
    return m_random_max_dimension_isValid;
}

qint32 OAIPack::getRandomMaxWeight() const {
    return m_random_max_weight;
}
void OAIPack::setRandomMaxWeight(const qint32 &random_max_weight) {
    m_random_max_weight = random_max_weight;
    m_random_max_weight_isSet = true;
}

bool OAIPack::is_random_max_weight_Set() const{
    return m_random_max_weight_isSet;
}

bool OAIPack::is_random_max_weight_Valid() const{
    return m_random_max_weight_isValid;
}

QList<OAIRule> OAIPack::getRules() const {
    return m_rules;
}
void OAIPack::setRules(const QList<OAIRule> &rules) {
    m_rules = rules;
    m_rules_isSet = true;
}

bool OAIPack::is_rules_Set() const{
    return m_rules_isSet;
}

bool OAIPack::is_rules_Valid() const{
    return m_rules_isValid;
}

bool OAIPack::isSeed() const {
    return m_seed;
}
void OAIPack::setSeed(const bool &seed) {
    m_seed = seed;
    m_seed_isSet = true;
}

bool OAIPack::is_seed_Set() const{
    return m_seed_isSet;
}

bool OAIPack::is_seed_Valid() const{
    return m_seed_isValid;
}

bool OAIPack::isSequenceHeatMap() const {
    return m_sequence_heat_map;
}
void OAIPack::setSequenceHeatMap(const bool &sequence_heat_map) {
    m_sequence_heat_map = sequence_heat_map;
    m_sequence_heat_map_isSet = true;
}

bool OAIPack::is_sequence_heat_map_Set() const{
    return m_sequence_heat_map_isSet;
}

bool OAIPack::is_sequence_heat_map_Valid() const{
    return m_sequence_heat_map_isValid;
}

bool OAIPack::isSequenceSort() const {
    return m_sequence_sort;
}
void OAIPack::setSequenceSort(const bool &sequence_sort) {
    m_sequence_sort = sequence_sort;
    m_sequence_sort_isSet = true;
}

bool OAIPack::is_sequence_sort_Set() const{
    return m_sequence_sort_isSet;
}

bool OAIPack::is_sequence_sort_Valid() const{
    return m_sequence_sort_isValid;
}

QString OAIPack::getRTemplate() const {
    return m_r_template;
}
void OAIPack::setRTemplate(const QString &r_template) {
    m_r_template = r_template;
    m_r_template_isSet = true;
}

bool OAIPack::is_r_template_Set() const{
    return m_r_template_isSet;
}

bool OAIPack::is_r_template_Valid() const{
    return m_r_template_isValid;
}

double OAIPack::getUsableSpace() const {
    return m_usable_space;
}
void OAIPack::setUsableSpace(const double &usable_space) {
    m_usable_space = usable_space;
    m_usable_space_isSet = true;
}

bool OAIPack::is_usable_space_Set() const{
    return m_usable_space_isSet;
}

bool OAIPack::is_usable_space_Valid() const{
    return m_usable_space_isValid;
}

qint32 OAIPack::getZone() const {
    return m_zone;
}
void OAIPack::setZone(const qint32 &zone) {
    m_zone = zone;
    m_zone_isSet = true;
}

bool OAIPack::is_zone_Set() const{
    return m_zone_isSet;
}

bool OAIPack::is_zone_Valid() const{
    return m_zone_isValid;
}

bool OAIPack::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_allowable_overhang_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_box_type_sets.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_box_types.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_cohort_max_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_cohort_packing_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_coord_order.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_corners_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_eye.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_img_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_include_images_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_include_scripts_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_interlock_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_item_sets.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_key_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lay_flat_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_sequence_distance_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_n_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pack_origin.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_placement_style_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_random_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_random_max_dimension_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_random_max_weight_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_rules.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_seed_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sequence_heat_map_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_sequence_sort_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_template_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_usable_space_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_zone_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPack::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
