/**
 * Storm Glass Marine Weather
 * Global marine weather data from multiple sources in one single API with hourly resolution. Get your API key by visiting the Storm Glass web site.
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: support@stormglass.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIForecast_hours_inner.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIForecast_hours_inner::OAIForecast_hours_inner(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIForecast_hours_inner::OAIForecast_hours_inner() {
    this->initializeModel();
}

OAIForecast_hours_inner::~OAIForecast_hours_inner() {}

void OAIForecast_hours_inner::initializeModel() {

    m_air_temperature_isSet = false;
    m_air_temperature_isValid = false;

    m_swell_direction_isSet = false;
    m_swell_direction_isValid = false;

    m_swell_height_isSet = false;
    m_swell_height_isValid = false;

    m_swell_period_isSet = false;
    m_swell_period_isValid = false;

    m_time_isSet = false;
    m_time_isValid = false;

    m_water_temperature_isSet = false;
    m_water_temperature_isValid = false;

    m_wave_direction_isSet = false;
    m_wave_direction_isValid = false;

    m_wave_height_isSet = false;
    m_wave_height_isValid = false;

    m_wave_period_isSet = false;
    m_wave_period_isValid = false;

    m_wind_direction_isSet = false;
    m_wind_direction_isValid = false;

    m_wind_speed_isSet = false;
    m_wind_speed_isValid = false;
}

void OAIForecast_hours_inner::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIForecast_hours_inner::fromJsonObject(QJsonObject json) {

    m_air_temperature_isValid = ::OpenAPI::fromJsonValue(m_air_temperature, json[QString("airTemperature")]);
    m_air_temperature_isSet = !json[QString("airTemperature")].isNull() && m_air_temperature_isValid;

    m_swell_direction_isValid = ::OpenAPI::fromJsonValue(m_swell_direction, json[QString("swellDirection")]);
    m_swell_direction_isSet = !json[QString("swellDirection")].isNull() && m_swell_direction_isValid;

    m_swell_height_isValid = ::OpenAPI::fromJsonValue(m_swell_height, json[QString("swellHeight")]);
    m_swell_height_isSet = !json[QString("swellHeight")].isNull() && m_swell_height_isValid;

    m_swell_period_isValid = ::OpenAPI::fromJsonValue(m_swell_period, json[QString("swellPeriod")]);
    m_swell_period_isSet = !json[QString("swellPeriod")].isNull() && m_swell_period_isValid;

    m_time_isValid = ::OpenAPI::fromJsonValue(m_time, json[QString("time")]);
    m_time_isSet = !json[QString("time")].isNull() && m_time_isValid;

    m_water_temperature_isValid = ::OpenAPI::fromJsonValue(m_water_temperature, json[QString("waterTemperature")]);
    m_water_temperature_isSet = !json[QString("waterTemperature")].isNull() && m_water_temperature_isValid;

    m_wave_direction_isValid = ::OpenAPI::fromJsonValue(m_wave_direction, json[QString("waveDirection")]);
    m_wave_direction_isSet = !json[QString("waveDirection")].isNull() && m_wave_direction_isValid;

    m_wave_height_isValid = ::OpenAPI::fromJsonValue(m_wave_height, json[QString("waveHeight")]);
    m_wave_height_isSet = !json[QString("waveHeight")].isNull() && m_wave_height_isValid;

    m_wave_period_isValid = ::OpenAPI::fromJsonValue(m_wave_period, json[QString("wavePeriod")]);
    m_wave_period_isSet = !json[QString("wavePeriod")].isNull() && m_wave_period_isValid;

    m_wind_direction_isValid = ::OpenAPI::fromJsonValue(m_wind_direction, json[QString("windDirection")]);
    m_wind_direction_isSet = !json[QString("windDirection")].isNull() && m_wind_direction_isValid;

    m_wind_speed_isValid = ::OpenAPI::fromJsonValue(m_wind_speed, json[QString("windSpeed")]);
    m_wind_speed_isSet = !json[QString("windSpeed")].isNull() && m_wind_speed_isValid;
}

QString OAIForecast_hours_inner::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIForecast_hours_inner::asJsonObject() const {
    QJsonObject obj;
    if (m_air_temperature.size() > 0) {
        obj.insert(QString("airTemperature"), ::OpenAPI::toJsonValue(m_air_temperature));
    }
    if (m_swell_direction.size() > 0) {
        obj.insert(QString("swellDirection"), ::OpenAPI::toJsonValue(m_swell_direction));
    }
    if (m_swell_height.size() > 0) {
        obj.insert(QString("swellHeight"), ::OpenAPI::toJsonValue(m_swell_height));
    }
    if (m_swell_period.size() > 0) {
        obj.insert(QString("swellPeriod"), ::OpenAPI::toJsonValue(m_swell_period));
    }
    if (m_time_isSet) {
        obj.insert(QString("time"), ::OpenAPI::toJsonValue(m_time));
    }
    if (m_water_temperature.size() > 0) {
        obj.insert(QString("waterTemperature"), ::OpenAPI::toJsonValue(m_water_temperature));
    }
    if (m_wave_direction.size() > 0) {
        obj.insert(QString("waveDirection"), ::OpenAPI::toJsonValue(m_wave_direction));
    }
    if (m_wave_height.size() > 0) {
        obj.insert(QString("waveHeight"), ::OpenAPI::toJsonValue(m_wave_height));
    }
    if (m_wave_period.size() > 0) {
        obj.insert(QString("wavePeriod"), ::OpenAPI::toJsonValue(m_wave_period));
    }
    if (m_wind_direction.size() > 0) {
        obj.insert(QString("windDirection"), ::OpenAPI::toJsonValue(m_wind_direction));
    }
    if (m_wind_speed.size() > 0) {
        obj.insert(QString("windSpeed"), ::OpenAPI::toJsonValue(m_wind_speed));
    }
    return obj;
}

QList<OAIForecast_hours_inner_airTemperature_inner> OAIForecast_hours_inner::getAirTemperature() const {
    return m_air_temperature;
}
void OAIForecast_hours_inner::setAirTemperature(const QList<OAIForecast_hours_inner_airTemperature_inner> &air_temperature) {
    m_air_temperature = air_temperature;
    m_air_temperature_isSet = true;
}

bool OAIForecast_hours_inner::is_air_temperature_Set() const{
    return m_air_temperature_isSet;
}

bool OAIForecast_hours_inner::is_air_temperature_Valid() const{
    return m_air_temperature_isValid;
}

QList<OAIForecast_hours_inner_swellDirection_inner> OAIForecast_hours_inner::getSwellDirection() const {
    return m_swell_direction;
}
void OAIForecast_hours_inner::setSwellDirection(const QList<OAIForecast_hours_inner_swellDirection_inner> &swell_direction) {
    m_swell_direction = swell_direction;
    m_swell_direction_isSet = true;
}

bool OAIForecast_hours_inner::is_swell_direction_Set() const{
    return m_swell_direction_isSet;
}

bool OAIForecast_hours_inner::is_swell_direction_Valid() const{
    return m_swell_direction_isValid;
}

QList<OAIForecast_hours_inner_swellHeight_inner> OAIForecast_hours_inner::getSwellHeight() const {
    return m_swell_height;
}
void OAIForecast_hours_inner::setSwellHeight(const QList<OAIForecast_hours_inner_swellHeight_inner> &swell_height) {
    m_swell_height = swell_height;
    m_swell_height_isSet = true;
}

bool OAIForecast_hours_inner::is_swell_height_Set() const{
    return m_swell_height_isSet;
}

bool OAIForecast_hours_inner::is_swell_height_Valid() const{
    return m_swell_height_isValid;
}

QList<OAIForecast_hours_inner_swellPeriod_inner> OAIForecast_hours_inner::getSwellPeriod() const {
    return m_swell_period;
}
void OAIForecast_hours_inner::setSwellPeriod(const QList<OAIForecast_hours_inner_swellPeriod_inner> &swell_period) {
    m_swell_period = swell_period;
    m_swell_period_isSet = true;
}

bool OAIForecast_hours_inner::is_swell_period_Set() const{
    return m_swell_period_isSet;
}

bool OAIForecast_hours_inner::is_swell_period_Valid() const{
    return m_swell_period_isValid;
}

QString OAIForecast_hours_inner::getTime() const {
    return m_time;
}
void OAIForecast_hours_inner::setTime(const QString &time) {
    m_time = time;
    m_time_isSet = true;
}

bool OAIForecast_hours_inner::is_time_Set() const{
    return m_time_isSet;
}

bool OAIForecast_hours_inner::is_time_Valid() const{
    return m_time_isValid;
}

QList<OAIForecast_hours_inner_waterTemperature_inner> OAIForecast_hours_inner::getWaterTemperature() const {
    return m_water_temperature;
}
void OAIForecast_hours_inner::setWaterTemperature(const QList<OAIForecast_hours_inner_waterTemperature_inner> &water_temperature) {
    m_water_temperature = water_temperature;
    m_water_temperature_isSet = true;
}

bool OAIForecast_hours_inner::is_water_temperature_Set() const{
    return m_water_temperature_isSet;
}

bool OAIForecast_hours_inner::is_water_temperature_Valid() const{
    return m_water_temperature_isValid;
}

QList<OAIForecast_hours_inner_waveDirection_inner> OAIForecast_hours_inner::getWaveDirection() const {
    return m_wave_direction;
}
void OAIForecast_hours_inner::setWaveDirection(const QList<OAIForecast_hours_inner_waveDirection_inner> &wave_direction) {
    m_wave_direction = wave_direction;
    m_wave_direction_isSet = true;
}

bool OAIForecast_hours_inner::is_wave_direction_Set() const{
    return m_wave_direction_isSet;
}

bool OAIForecast_hours_inner::is_wave_direction_Valid() const{
    return m_wave_direction_isValid;
}

QList<OAIForecast_hours_inner_waveHeight_inner> OAIForecast_hours_inner::getWaveHeight() const {
    return m_wave_height;
}
void OAIForecast_hours_inner::setWaveHeight(const QList<OAIForecast_hours_inner_waveHeight_inner> &wave_height) {
    m_wave_height = wave_height;
    m_wave_height_isSet = true;
}

bool OAIForecast_hours_inner::is_wave_height_Set() const{
    return m_wave_height_isSet;
}

bool OAIForecast_hours_inner::is_wave_height_Valid() const{
    return m_wave_height_isValid;
}

QList<OAIForecast_hours_inner_wavePeriod_inner> OAIForecast_hours_inner::getWavePeriod() const {
    return m_wave_period;
}
void OAIForecast_hours_inner::setWavePeriod(const QList<OAIForecast_hours_inner_wavePeriod_inner> &wave_period) {
    m_wave_period = wave_period;
    m_wave_period_isSet = true;
}

bool OAIForecast_hours_inner::is_wave_period_Set() const{
    return m_wave_period_isSet;
}

bool OAIForecast_hours_inner::is_wave_period_Valid() const{
    return m_wave_period_isValid;
}

QList<OAIForecast_hours_inner_windDirection_inner> OAIForecast_hours_inner::getWindDirection() const {
    return m_wind_direction;
}
void OAIForecast_hours_inner::setWindDirection(const QList<OAIForecast_hours_inner_windDirection_inner> &wind_direction) {
    m_wind_direction = wind_direction;
    m_wind_direction_isSet = true;
}

bool OAIForecast_hours_inner::is_wind_direction_Set() const{
    return m_wind_direction_isSet;
}

bool OAIForecast_hours_inner::is_wind_direction_Valid() const{
    return m_wind_direction_isValid;
}

QList<OAIForecast_hours_inner_windSpeed_inner> OAIForecast_hours_inner::getWindSpeed() const {
    return m_wind_speed;
}
void OAIForecast_hours_inner::setWindSpeed(const QList<OAIForecast_hours_inner_windSpeed_inner> &wind_speed) {
    m_wind_speed = wind_speed;
    m_wind_speed_isSet = true;
}

bool OAIForecast_hours_inner::is_wind_speed_Set() const{
    return m_wind_speed_isSet;
}

bool OAIForecast_hours_inner::is_wind_speed_Valid() const{
    return m_wind_speed_isValid;
}

bool OAIForecast_hours_inner::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_air_temperature.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_swell_direction.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_swell_height.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_swell_period.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_water_temperature.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_wave_direction.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_wave_height.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_wave_period.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_wind_direction.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_wind_speed.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIForecast_hours_inner::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
