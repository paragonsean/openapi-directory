/*
 * Stoplight
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: api-v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.GETVersionsVersionIdExportFormat200Response;
import org.openapitools.client.model.POSTVersionsVersionIdPublish200Response;
import org.openapitools.client.model.PUTVersionsVersionIdImport200Response;
import org.openapitools.client.model.PUTVersionsVersionIdImportRequest;
import org.openapitools.client.model.PUTVersionsVersionIdUnpublish200Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class VersionsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public VersionsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public VersionsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for gETVersionsVersionIdExportFormat
     * @param versionId This is the unique identifier for the version. (required)
     * @param format The specification / format that you want to export. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETVersionsVersionIdExportFormatCall(String versionId, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/versions/{versionId}/export/{format}"
            .replace("{" + "versionId" + "}", localVarApiClient.escapeString(versionId.toString()))
            .replace("{" + "format" + "}", localVarApiClient.escapeString(format.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "text/yaml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call gETVersionsVersionIdExportFormatValidateBeforeCall(String versionId, String format, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'versionId' is set
        if (versionId == null) {
            throw new ApiException("Missing the required parameter 'versionId' when calling gETVersionsVersionIdExportFormat(Async)");
        }

        // verify the required parameter 'format' is set
        if (format == null) {
            throw new ApiException("Missing the required parameter 'format' when calling gETVersionsVersionIdExportFormat(Async)");
        }

        return gETVersionsVersionIdExportFormatCall(versionId, format, _callback);

    }

    /**
     * Export
     * Export a version to your choice of API specification.  ### Allowed Formats:  - oas.json - oas.yaml - raml08.yaml - raml10.yaml - stoplight.json - stoplight.yaml  The stoplight format actually returns OAS (Swagger 2) with x-stoplight annotations. If you are exporting with the intent on importing back into Stoplight, this export format preserves the most information.  ### Example URL:  &#x60;https://api.stoplight.io/v1/versions/123/export/oas.json&#x60;
     * @param versionId This is the unique identifier for the version. (required)
     * @param format The specification / format that you want to export. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public void gETVersionsVersionIdExportFormat(String versionId, String format) throws ApiException {
        gETVersionsVersionIdExportFormatWithHttpInfo(versionId, format);
    }

    /**
     * Export
     * Export a version to your choice of API specification.  ### Allowed Formats:  - oas.json - oas.yaml - raml08.yaml - raml10.yaml - stoplight.json - stoplight.yaml  The stoplight format actually returns OAS (Swagger 2) with x-stoplight annotations. If you are exporting with the intent on importing back into Stoplight, this export format preserves the most information.  ### Example URL:  &#x60;https://api.stoplight.io/v1/versions/123/export/oas.json&#x60;
     * @param versionId This is the unique identifier for the version. (required)
     * @param format The specification / format that you want to export. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> gETVersionsVersionIdExportFormatWithHttpInfo(String versionId, String format) throws ApiException {
        okhttp3.Call localVarCall = gETVersionsVersionIdExportFormatValidateBeforeCall(versionId, format, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Export (asynchronously)
     * Export a version to your choice of API specification.  ### Allowed Formats:  - oas.json - oas.yaml - raml08.yaml - raml10.yaml - stoplight.json - stoplight.yaml  The stoplight format actually returns OAS (Swagger 2) with x-stoplight annotations. If you are exporting with the intent on importing back into Stoplight, this export format preserves the most information.  ### Example URL:  &#x60;https://api.stoplight.io/v1/versions/123/export/oas.json&#x60;
     * @param versionId This is the unique identifier for the version. (required)
     * @param format The specification / format that you want to export. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call gETVersionsVersionIdExportFormatAsync(String versionId, String format, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = gETVersionsVersionIdExportFormatValidateBeforeCall(versionId, format, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for pOSTVersionsVersionIdPublish
     * @param versionId This is the unique identifier for the version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTVersionsVersionIdPublishCall(String versionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/versions/{versionId}/publish"
            .replace("{" + "versionId" + "}", localVarApiClient.escapeString(versionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pOSTVersionsVersionIdPublishValidateBeforeCall(String versionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'versionId' is set
        if (versionId == null) {
            throw new ApiException("Missing the required parameter 'versionId' when calling pOSTVersionsVersionIdPublish(Async)");
        }

        return pOSTVersionsVersionIdPublishCall(versionId, _callback);

    }

    /**
     * Publish
     * Re-publish an API version in Stoplight. This will re-publish the given API version, with whatever publish settings have already been setup in the app.  This will only work with APIs that have previously been published at least once.  This works well with the #endpoint:957qEfc97BB5XGAeZ endpoint to augment your continuous integration processes, and automatically re-publish your documentation when certain events happen. Once such scenario is:  1. Swagger is generated from your codebase, and pushed up to Github. 2. A simple script that you write sends a request to the Stoplight API to import the new specification, passing in the URL to the swagger file on Github. 3. After the import succeeds, and your API in Stoplight is up to date, the script sends a request to the Stoplight API (this endpoint) to re-publish your documentation.
     * @param versionId This is the unique identifier for the version. (required)
     * @return POSTVersionsVersionIdPublish200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public POSTVersionsVersionIdPublish200Response pOSTVersionsVersionIdPublish(String versionId) throws ApiException {
        ApiResponse<POSTVersionsVersionIdPublish200Response> localVarResp = pOSTVersionsVersionIdPublishWithHttpInfo(versionId);
        return localVarResp.getData();
    }

    /**
     * Publish
     * Re-publish an API version in Stoplight. This will re-publish the given API version, with whatever publish settings have already been setup in the app.  This will only work with APIs that have previously been published at least once.  This works well with the #endpoint:957qEfc97BB5XGAeZ endpoint to augment your continuous integration processes, and automatically re-publish your documentation when certain events happen. Once such scenario is:  1. Swagger is generated from your codebase, and pushed up to Github. 2. A simple script that you write sends a request to the Stoplight API to import the new specification, passing in the URL to the swagger file on Github. 3. After the import succeeds, and your API in Stoplight is up to date, the script sends a request to the Stoplight API (this endpoint) to re-publish your documentation.
     * @param versionId This is the unique identifier for the version. (required)
     * @return ApiResponse&lt;POSTVersionsVersionIdPublish200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<POSTVersionsVersionIdPublish200Response> pOSTVersionsVersionIdPublishWithHttpInfo(String versionId) throws ApiException {
        okhttp3.Call localVarCall = pOSTVersionsVersionIdPublishValidateBeforeCall(versionId, null);
        Type localVarReturnType = new TypeToken<POSTVersionsVersionIdPublish200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Publish (asynchronously)
     * Re-publish an API version in Stoplight. This will re-publish the given API version, with whatever publish settings have already been setup in the app.  This will only work with APIs that have previously been published at least once.  This works well with the #endpoint:957qEfc97BB5XGAeZ endpoint to augment your continuous integration processes, and automatically re-publish your documentation when certain events happen. Once such scenario is:  1. Swagger is generated from your codebase, and pushed up to Github. 2. A simple script that you write sends a request to the Stoplight API to import the new specification, passing in the URL to the swagger file on Github. 3. After the import succeeds, and your API in Stoplight is up to date, the script sends a request to the Stoplight API (this endpoint) to re-publish your documentation.
     * @param versionId This is the unique identifier for the version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pOSTVersionsVersionIdPublishAsync(String versionId, final ApiCallback<POSTVersionsVersionIdPublish200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = pOSTVersionsVersionIdPublishValidateBeforeCall(versionId, _callback);
        Type localVarReturnType = new TypeToken<POSTVersionsVersionIdPublish200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pUTVersionsVersionIdImport
     * @param versionId This is the unique identifier for the version. (required)
     * @param puTVersionsVersionIdImportRequest  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pUTVersionsVersionIdImportCall(String versionId, PUTVersionsVersionIdImportRequest puTVersionsVersionIdImportRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = puTVersionsVersionIdImportRequest;

        // create path and map variables
        String localVarPath = "/versions/{versionId}/import"
            .replace("{" + "versionId" + "}", localVarApiClient.escapeString(versionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pUTVersionsVersionIdImportValidateBeforeCall(String versionId, PUTVersionsVersionIdImportRequest puTVersionsVersionIdImportRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'versionId' is set
        if (versionId == null) {
            throw new ApiException("Missing the required parameter 'versionId' when calling pUTVersionsVersionIdImport(Async)");
        }

        return pUTVersionsVersionIdImportCall(versionId, puTVersionsVersionIdImportRequest, _callback);

    }

    /**
     * Import
     * Import the given specification into an existing version.   **Warning, this is a destructive action! Any resources present in both the existing version, and the specification being imported, will be overwritten.**  This endpoint is particularly useful when you manage a specification file (Swagger or RAML) outside of Stoplight, and want to keep your Stoplight API version up to date as that specification changes.  By default, a \&quot;merge\&quot; is performed when importing. If a resource exists in the specification that you are importing, and in the Stoplight API, the resource will be overwritten. If a resource exists in the Stoplight API, but not in the spefication that you are importing, the resource will be left alone (and not deleted).  You can include an optional &#x60;options&#x60; property in the request body, to indicate if you would like to perform more of a replacement (instead of a merge). The options are documented in full in the response definition below these notes.  Take this request + request body for example:  &#x60;PUT https://api.stoplight.io/v1/versions/123/import&#x60; &#x60;&#x60;&#x60;json {   \&quot;url\&quot;: \&quot;http://petstore.swagger.io/v2/swagger.json\&quot;,   \&quot;options\&quot;: {     \&quot;removeExtraEndpoints\&quot;: true,     \&quot;removeExtraSchemas\&quot;: true   } } &#x60;&#x60;&#x60;  This request will grab the swagger specification described at &#x60;http://petstore.swagger.io/v2/swagger.json&#x60;, and import it into the Stoplight API version with id &#x60;123&#x60;. Additionally, it will delete any existing endpoints or models that are not described in the petstore swagger being imported.  Instead of a URL, you can provide the actual specification to be imported, either as a string (in the case of YAML) or an object (in the case of JSON). That request would look something like this:  &#x60;PUT https://api.stoplight.io/v1/versions/123/import&#x60; &#x60;&#x60;&#x60;json {   \&quot;specData\&quot;: {     \&quot;swagger\&quot;: \&quot;2.0\&quot;,     \&quot;info\&quot;: {}     ... rest of spec   } } &#x60;&#x60;&#x60;
     * @param versionId This is the unique identifier for the version. (required)
     * @param puTVersionsVersionIdImportRequest  (optional)
     * @return PUTVersionsVersionIdImport200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public PUTVersionsVersionIdImport200Response pUTVersionsVersionIdImport(String versionId, PUTVersionsVersionIdImportRequest puTVersionsVersionIdImportRequest) throws ApiException {
        ApiResponse<PUTVersionsVersionIdImport200Response> localVarResp = pUTVersionsVersionIdImportWithHttpInfo(versionId, puTVersionsVersionIdImportRequest);
        return localVarResp.getData();
    }

    /**
     * Import
     * Import the given specification into an existing version.   **Warning, this is a destructive action! Any resources present in both the existing version, and the specification being imported, will be overwritten.**  This endpoint is particularly useful when you manage a specification file (Swagger or RAML) outside of Stoplight, and want to keep your Stoplight API version up to date as that specification changes.  By default, a \&quot;merge\&quot; is performed when importing. If a resource exists in the specification that you are importing, and in the Stoplight API, the resource will be overwritten. If a resource exists in the Stoplight API, but not in the spefication that you are importing, the resource will be left alone (and not deleted).  You can include an optional &#x60;options&#x60; property in the request body, to indicate if you would like to perform more of a replacement (instead of a merge). The options are documented in full in the response definition below these notes.  Take this request + request body for example:  &#x60;PUT https://api.stoplight.io/v1/versions/123/import&#x60; &#x60;&#x60;&#x60;json {   \&quot;url\&quot;: \&quot;http://petstore.swagger.io/v2/swagger.json\&quot;,   \&quot;options\&quot;: {     \&quot;removeExtraEndpoints\&quot;: true,     \&quot;removeExtraSchemas\&quot;: true   } } &#x60;&#x60;&#x60;  This request will grab the swagger specification described at &#x60;http://petstore.swagger.io/v2/swagger.json&#x60;, and import it into the Stoplight API version with id &#x60;123&#x60;. Additionally, it will delete any existing endpoints or models that are not described in the petstore swagger being imported.  Instead of a URL, you can provide the actual specification to be imported, either as a string (in the case of YAML) or an object (in the case of JSON). That request would look something like this:  &#x60;PUT https://api.stoplight.io/v1/versions/123/import&#x60; &#x60;&#x60;&#x60;json {   \&quot;specData\&quot;: {     \&quot;swagger\&quot;: \&quot;2.0\&quot;,     \&quot;info\&quot;: {}     ... rest of spec   } } &#x60;&#x60;&#x60;
     * @param versionId This is the unique identifier for the version. (required)
     * @param puTVersionsVersionIdImportRequest  (optional)
     * @return ApiResponse&lt;PUTVersionsVersionIdImport200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PUTVersionsVersionIdImport200Response> pUTVersionsVersionIdImportWithHttpInfo(String versionId, PUTVersionsVersionIdImportRequest puTVersionsVersionIdImportRequest) throws ApiException {
        okhttp3.Call localVarCall = pUTVersionsVersionIdImportValidateBeforeCall(versionId, puTVersionsVersionIdImportRequest, null);
        Type localVarReturnType = new TypeToken<PUTVersionsVersionIdImport200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Import (asynchronously)
     * Import the given specification into an existing version.   **Warning, this is a destructive action! Any resources present in both the existing version, and the specification being imported, will be overwritten.**  This endpoint is particularly useful when you manage a specification file (Swagger or RAML) outside of Stoplight, and want to keep your Stoplight API version up to date as that specification changes.  By default, a \&quot;merge\&quot; is performed when importing. If a resource exists in the specification that you are importing, and in the Stoplight API, the resource will be overwritten. If a resource exists in the Stoplight API, but not in the spefication that you are importing, the resource will be left alone (and not deleted).  You can include an optional &#x60;options&#x60; property in the request body, to indicate if you would like to perform more of a replacement (instead of a merge). The options are documented in full in the response definition below these notes.  Take this request + request body for example:  &#x60;PUT https://api.stoplight.io/v1/versions/123/import&#x60; &#x60;&#x60;&#x60;json {   \&quot;url\&quot;: \&quot;http://petstore.swagger.io/v2/swagger.json\&quot;,   \&quot;options\&quot;: {     \&quot;removeExtraEndpoints\&quot;: true,     \&quot;removeExtraSchemas\&quot;: true   } } &#x60;&#x60;&#x60;  This request will grab the swagger specification described at &#x60;http://petstore.swagger.io/v2/swagger.json&#x60;, and import it into the Stoplight API version with id &#x60;123&#x60;. Additionally, it will delete any existing endpoints or models that are not described in the petstore swagger being imported.  Instead of a URL, you can provide the actual specification to be imported, either as a string (in the case of YAML) or an object (in the case of JSON). That request would look something like this:  &#x60;PUT https://api.stoplight.io/v1/versions/123/import&#x60; &#x60;&#x60;&#x60;json {   \&quot;specData\&quot;: {     \&quot;swagger\&quot;: \&quot;2.0\&quot;,     \&quot;info\&quot;: {}     ... rest of spec   } } &#x60;&#x60;&#x60;
     * @param versionId This is the unique identifier for the version. (required)
     * @param puTVersionsVersionIdImportRequest  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pUTVersionsVersionIdImportAsync(String versionId, PUTVersionsVersionIdImportRequest puTVersionsVersionIdImportRequest, final ApiCallback<PUTVersionsVersionIdImport200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = pUTVersionsVersionIdImportValidateBeforeCall(versionId, puTVersionsVersionIdImportRequest, _callback);
        Type localVarReturnType = new TypeToken<PUTVersionsVersionIdImport200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for pUTVersionsVersionIdUnpublish
     * @param versionId This is the unique identifier for the version. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pUTVersionsVersionIdUnpublishCall(String versionId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/versions/{versionId}/unpublish"
            .replace("{" + "versionId" + "}", localVarApiClient.escapeString(versionId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "Authorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pUTVersionsVersionIdUnpublishValidateBeforeCall(String versionId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'versionId' is set
        if (versionId == null) {
            throw new ApiException("Missing the required parameter 'versionId' when calling pUTVersionsVersionIdUnpublish(Async)");
        }

        return pUTVersionsVersionIdUnpublishCall(versionId, _callback);

    }

    /**
     * Unpublish
     * Unpublish the documentation associated with the given API version.
     * @param versionId This is the unique identifier for the version. (required)
     * @return PUTVersionsVersionIdUnpublish200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public PUTVersionsVersionIdUnpublish200Response pUTVersionsVersionIdUnpublish(String versionId) throws ApiException {
        ApiResponse<PUTVersionsVersionIdUnpublish200Response> localVarResp = pUTVersionsVersionIdUnpublishWithHttpInfo(versionId);
        return localVarResp.getData();
    }

    /**
     * Unpublish
     * Unpublish the documentation associated with the given API version.
     * @param versionId This is the unique identifier for the version. (required)
     * @return ApiResponse&lt;PUTVersionsVersionIdUnpublish200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PUTVersionsVersionIdUnpublish200Response> pUTVersionsVersionIdUnpublishWithHttpInfo(String versionId) throws ApiException {
        okhttp3.Call localVarCall = pUTVersionsVersionIdUnpublishValidateBeforeCall(versionId, null);
        Type localVarReturnType = new TypeToken<PUTVersionsVersionIdUnpublish200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Unpublish (asynchronously)
     * Unpublish the documentation associated with the given API version.
     * @param versionId This is the unique identifier for the version. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td>  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call pUTVersionsVersionIdUnpublishAsync(String versionId, final ApiCallback<PUTVersionsVersionIdUnpublish200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = pUTVersionsVersionIdUnpublishValidateBeforeCall(versionId, _callback);
        Type localVarReturnType = new TypeToken<PUTVersionsVersionIdUnpublish200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
