/*
 * Bitbucket API
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.Error;
import org.openapitools.client.model.PaginatedAnnotations;
import org.openapitools.client.model.PaginatedReports;
import org.openapitools.client.model.Report;
import org.openapitools.client.model.ReportAnnotation;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ReportsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ReportsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ReportsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for bulkCreateOrUpdateAnnotations
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param reportAnnotation The annotations to create or update (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call bulkCreateOrUpdateAnnotationsCall(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = reportAnnotation;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call bulkCreateOrUpdateAnnotationsValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling bulkCreateOrUpdateAnnotations(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling bulkCreateOrUpdateAnnotations(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling bulkCreateOrUpdateAnnotations(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling bulkCreateOrUpdateAnnotations(Async)");
        }

        // verify the required parameter 'reportAnnotation' is set
        if (reportAnnotation == null) {
            throw new ApiException("Missing the required parameter 'reportAnnotation' when calling bulkCreateOrUpdateAnnotations(Async)");
        }

        return bulkCreateOrUpdateAnnotationsCall(workspace, repoSlug, commit, reportId, reportAnnotation, _callback);

    }

    /**
     * Bulk create or update annotations
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --location &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001/annotations&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;[   {         \&quot;external_id\&quot;: \&quot;mysystem-annotation001\&quot;,         \&quot;title\&quot;: \&quot;Security scan report\&quot;,         \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,         \&quot;summary\&quot;: \&quot;This line represents a security threat.\&quot;,         \&quot;severity\&quot;: \&quot;HIGH\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,         \&quot;line\&quot;: 42   },   {         \&quot;external_id\&quot;: \&quot;mySystem-annotation002\&quot;,         \&quot;title\&quot;: \&quot;Bug report\&quot;,         \&quot;annotation_type\&quot;: \&quot;BUG\&quot;,         \&quot;result\&quot;: \&quot;FAILED\&quot;,         \&quot;summary\&quot;: \&quot;This line might introduce a bug.\&quot;,         \&quot;severity\&quot;: \&quot;MEDIUM\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\&quot;,         \&quot;line\&quot;: 13   } ]&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param reportAnnotation The annotations to create or update (required)
     * @return List&lt;ReportAnnotation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<ReportAnnotation> bulkCreateOrUpdateAnnotations(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation) throws ApiException {
        ApiResponse<List<ReportAnnotation>> localVarResp = bulkCreateOrUpdateAnnotationsWithHttpInfo(workspace, repoSlug, commit, reportId, reportAnnotation);
        return localVarResp.getData();
    }

    /**
     * Bulk create or update annotations
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --location &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001/annotations&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;[   {         \&quot;external_id\&quot;: \&quot;mysystem-annotation001\&quot;,         \&quot;title\&quot;: \&quot;Security scan report\&quot;,         \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,         \&quot;summary\&quot;: \&quot;This line represents a security threat.\&quot;,         \&quot;severity\&quot;: \&quot;HIGH\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,         \&quot;line\&quot;: 42   },   {         \&quot;external_id\&quot;: \&quot;mySystem-annotation002\&quot;,         \&quot;title\&quot;: \&quot;Bug report\&quot;,         \&quot;annotation_type\&quot;: \&quot;BUG\&quot;,         \&quot;result\&quot;: \&quot;FAILED\&quot;,         \&quot;summary\&quot;: \&quot;This line might introduce a bug.\&quot;,         \&quot;severity\&quot;: \&quot;MEDIUM\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\&quot;,         \&quot;line\&quot;: 13   } ]&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param reportAnnotation The annotations to create or update (required)
     * @return ApiResponse&lt;List&lt;ReportAnnotation&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ReportAnnotation>> bulkCreateOrUpdateAnnotationsWithHttpInfo(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation) throws ApiException {
        okhttp3.Call localVarCall = bulkCreateOrUpdateAnnotationsValidateBeforeCall(workspace, repoSlug, commit, reportId, reportAnnotation, null);
        Type localVarReturnType = new TypeToken<List<ReportAnnotation>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Bulk create or update annotations (asynchronously)
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --location &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001/annotations&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;[   {         \&quot;external_id\&quot;: \&quot;mysystem-annotation001\&quot;,         \&quot;title\&quot;: \&quot;Security scan report\&quot;,         \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,         \&quot;summary\&quot;: \&quot;This line represents a security threat.\&quot;,         \&quot;severity\&quot;: \&quot;HIGH\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,         \&quot;line\&quot;: 42   },   {         \&quot;external_id\&quot;: \&quot;mySystem-annotation002\&quot;,         \&quot;title\&quot;: \&quot;Bug report\&quot;,         \&quot;annotation_type\&quot;: \&quot;BUG\&quot;,         \&quot;result\&quot;: \&quot;FAILED\&quot;,         \&quot;summary\&quot;: \&quot;This line might introduce a bug.\&quot;,         \&quot;severity\&quot;: \&quot;MEDIUM\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\&quot;,         \&quot;line\&quot;: 13   } ]&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param reportAnnotation The annotations to create or update (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call bulkCreateOrUpdateAnnotationsAsync(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation, final ApiCallback<List<ReportAnnotation>> _callback) throws ApiException {

        okhttp3.Call localVarCall = bulkCreateOrUpdateAnnotationsValidateBeforeCall(workspace, repoSlug, commit, reportId, reportAnnotation, _callback);
        Type localVarReturnType = new TypeToken<List<ReportAnnotation>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createOrUpdateAnnotation
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param reportAnnotation The annotation to create or update (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Annotation object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrUpdateAnnotationCall(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = reportAnnotation;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()))
            .replace("{" + "annotationId" + "}", localVarApiClient.escapeString(annotationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createOrUpdateAnnotationValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling createOrUpdateAnnotation(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling createOrUpdateAnnotation(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling createOrUpdateAnnotation(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling createOrUpdateAnnotation(Async)");
        }

        // verify the required parameter 'annotationId' is set
        if (annotationId == null) {
            throw new ApiException("Missing the required parameter 'annotationId' when calling createOrUpdateAnnotation(Async)");
        }

        // verify the required parameter 'reportAnnotation' is set
        if (reportAnnotation == null) {
            throw new ApiException("Missing the required parameter 'reportAnnotation' when calling createOrUpdateAnnotation(Async)");
        }

        return createOrUpdateAnnotationCall(workspace, repoSlug, commit, reportId, annotationId, reportAnnotation, _callback);

    }

    /**
     * Create or update an annotation
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mySystem-001/annotations/mysystem-annotation001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,     \&quot;summary\&quot;: \&quot;This line represents a security thread.\&quot;,     \&quot;severity\&quot;: \&quot;HIGH\&quot;,     \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,     \&quot;line\&quot;: 42 }&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param reportAnnotation The annotation to create or update (required)
     * @return ReportAnnotation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Annotation object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public ReportAnnotation createOrUpdateAnnotation(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation) throws ApiException {
        ApiResponse<ReportAnnotation> localVarResp = createOrUpdateAnnotationWithHttpInfo(workspace, repoSlug, commit, reportId, annotationId, reportAnnotation);
        return localVarResp.getData();
    }

    /**
     * Create or update an annotation
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mySystem-001/annotations/mysystem-annotation001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,     \&quot;summary\&quot;: \&quot;This line represents a security thread.\&quot;,     \&quot;severity\&quot;: \&quot;HIGH\&quot;,     \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,     \&quot;line\&quot;: 42 }&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param reportAnnotation The annotation to create or update (required)
     * @return ApiResponse&lt;ReportAnnotation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Annotation object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReportAnnotation> createOrUpdateAnnotationWithHttpInfo(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation) throws ApiException {
        okhttp3.Call localVarCall = createOrUpdateAnnotationValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, reportAnnotation, null);
        Type localVarReturnType = new TypeToken<ReportAnnotation>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create or update an annotation (asynchronously)
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mySystem-001/annotations/mysystem-annotation001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,     \&quot;summary\&quot;: \&quot;This line represents a security thread.\&quot;,     \&quot;severity\&quot;: \&quot;HIGH\&quot;,     \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,     \&quot;line\&quot;: 42 }&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param reportAnnotation The annotation to create or update (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Annotation object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrUpdateAnnotationAsync(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation, final ApiCallback<ReportAnnotation> _callback) throws ApiException {

        okhttp3.Call localVarCall = createOrUpdateAnnotationValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, reportAnnotation, _callback);
        Type localVarReturnType = new TypeToken<ReportAnnotation>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createOrUpdateReport
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param report The report to create or update (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Report object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrUpdateReportCall(String workspace, String repoSlug, String commit, String reportId, Report report, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = report;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createOrUpdateReportValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, Report report, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling createOrUpdateReport(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling createOrUpdateReport(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling createOrUpdateReport(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling createOrUpdateReport(Async)");
        }

        // verify the required parameter 'report' is set
        if (report == null) {
            throw new ApiException("Missing the required parameter 'report' when calling createOrUpdateReport(Async)");
        }

        return createOrUpdateReportCall(workspace, repoSlug, commit, reportId, report, _callback);

    }

    /**
     * Create or update a report
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;details\&quot;: \&quot;This pull request introduces 10 new dependency vulnerabilities.\&quot;,     \&quot;report_type\&quot;: \&quot;SECURITY\&quot;,     \&quot;reporter\&quot;: \&quot;mySystem\&quot;,     \&quot;link\&quot;: \&quot;http://www.mysystem.com/reports/001\&quot;,     \&quot;result\&quot;: \&quot;FAILED\&quot;,     \&quot;data\&quot;: [         {             \&quot;title\&quot;: \&quot;Duration (seconds)\&quot;,             \&quot;type\&quot;: \&quot;DURATION\&quot;,             \&quot;value\&quot;: 14         },         {             \&quot;title\&quot;: \&quot;Safe to merge?\&quot;,             \&quot;type\&quot;: \&quot;BOOLEAN\&quot;,             \&quot;value\&quot;: false         }     ] }&#39; &#x60;&#x60;&#x60;  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as &#39;Yes&#39; or &#39;No&#39;. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: &#x60;{\&quot;text\&quot;: \&quot;Link text here\&quot;, \&quot;href\&quot;: \&quot;https://link.to.annotation/in/external/tool\&quot;}&#x60; | The value will be read as a JSON object containing the fields \&quot;text\&quot; and \&quot;href\&quot; and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param report The report to create or update (required)
     * @return Report
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Report object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public Report createOrUpdateReport(String workspace, String repoSlug, String commit, String reportId, Report report) throws ApiException {
        ApiResponse<Report> localVarResp = createOrUpdateReportWithHttpInfo(workspace, repoSlug, commit, reportId, report);
        return localVarResp.getData();
    }

    /**
     * Create or update a report
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;details\&quot;: \&quot;This pull request introduces 10 new dependency vulnerabilities.\&quot;,     \&quot;report_type\&quot;: \&quot;SECURITY\&quot;,     \&quot;reporter\&quot;: \&quot;mySystem\&quot;,     \&quot;link\&quot;: \&quot;http://www.mysystem.com/reports/001\&quot;,     \&quot;result\&quot;: \&quot;FAILED\&quot;,     \&quot;data\&quot;: [         {             \&quot;title\&quot;: \&quot;Duration (seconds)\&quot;,             \&quot;type\&quot;: \&quot;DURATION\&quot;,             \&quot;value\&quot;: 14         },         {             \&quot;title\&quot;: \&quot;Safe to merge?\&quot;,             \&quot;type\&quot;: \&quot;BOOLEAN\&quot;,             \&quot;value\&quot;: false         }     ] }&#39; &#x60;&#x60;&#x60;  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as &#39;Yes&#39; or &#39;No&#39;. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: &#x60;{\&quot;text\&quot;: \&quot;Link text here\&quot;, \&quot;href\&quot;: \&quot;https://link.to.annotation/in/external/tool\&quot;}&#x60; | The value will be read as a JSON object containing the fields \&quot;text\&quot; and \&quot;href\&quot; and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param report The report to create or update (required)
     * @return ApiResponse&lt;Report&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Report object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Report> createOrUpdateReportWithHttpInfo(String workspace, String repoSlug, String commit, String reportId, Report report) throws ApiException {
        okhttp3.Call localVarCall = createOrUpdateReportValidateBeforeCall(workspace, repoSlug, commit, reportId, report, null);
        Type localVarReturnType = new TypeToken<Report>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create or update a report (asynchronously)
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;details\&quot;: \&quot;This pull request introduces 10 new dependency vulnerabilities.\&quot;,     \&quot;report_type\&quot;: \&quot;SECURITY\&quot;,     \&quot;reporter\&quot;: \&quot;mySystem\&quot;,     \&quot;link\&quot;: \&quot;http://www.mysystem.com/reports/001\&quot;,     \&quot;result\&quot;: \&quot;FAILED\&quot;,     \&quot;data\&quot;: [         {             \&quot;title\&quot;: \&quot;Duration (seconds)\&quot;,             \&quot;type\&quot;: \&quot;DURATION\&quot;,             \&quot;value\&quot;: 14         },         {             \&quot;title\&quot;: \&quot;Safe to merge?\&quot;,             \&quot;type\&quot;: \&quot;BOOLEAN\&quot;,             \&quot;value\&quot;: false         }     ] }&#39; &#x60;&#x60;&#x60;  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as &#39;Yes&#39; or &#39;No&#39;. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: &#x60;{\&quot;text\&quot;: \&quot;Link text here\&quot;, \&quot;href\&quot;: \&quot;https://link.to.annotation/in/external/tool\&quot;}&#x60; | The value will be read as a JSON object containing the fields \&quot;text\&quot; and \&quot;href\&quot; and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param report The report to create or update (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Report object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrUpdateReportAsync(String workspace, String repoSlug, String commit, String reportId, Report report, final ApiCallback<Report> _callback) throws ApiException {

        okhttp3.Call localVarCall = createOrUpdateReportValidateBeforeCall(workspace, repoSlug, commit, reportId, report, _callback);
        Type localVarReturnType = new TypeToken<Report>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteAnnotation
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the annotation belongs to. (required)
     * @param reportId Either the uuid or external-id of the annotation. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteAnnotationCall(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()))
            .replace("{" + "annotationId" + "}", localVarApiClient.escapeString(annotationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteAnnotationValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling deleteAnnotation(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling deleteAnnotation(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling deleteAnnotation(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling deleteAnnotation(Async)");
        }

        // verify the required parameter 'annotationId' is set
        if (annotationId == null) {
            throw new ApiException("Missing the required parameter 'annotationId' when calling deleteAnnotation(Async)");
        }

        return deleteAnnotationCall(workspace, repoSlug, commit, reportId, annotationId, _callback);

    }

    /**
     * Delete an annotation
     * Deletes a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the annotation belongs to. (required)
     * @param reportId Either the uuid or external-id of the annotation. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public void deleteAnnotation(String workspace, String repoSlug, String commit, String reportId, String annotationId) throws ApiException {
        deleteAnnotationWithHttpInfo(workspace, repoSlug, commit, reportId, annotationId);
    }

    /**
     * Delete an annotation
     * Deletes a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the annotation belongs to. (required)
     * @param reportId Either the uuid or external-id of the annotation. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteAnnotationWithHttpInfo(String workspace, String repoSlug, String commit, String reportId, String annotationId) throws ApiException {
        okhttp3.Call localVarCall = deleteAnnotationValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete an annotation (asynchronously)
     * Deletes a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the annotation belongs to. (required)
     * @param reportId Either the uuid or external-id of the annotation. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteAnnotationAsync(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteAnnotationValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteReport
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteReportCall(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteReportValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling deleteReport(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling deleteReport(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling deleteReport(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling deleteReport(Async)");
        }

        return deleteReportCall(workspace, repoSlug, commit, reportId, _callback);

    }

    /**
     * Delete a report
     * Deletes a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public void deleteReport(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        deleteReportWithHttpInfo(workspace, repoSlug, commit, reportId);
    }

    /**
     * Delete a report
     * Deletes a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteReportWithHttpInfo(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        okhttp3.Call localVarCall = deleteReportValidateBeforeCall(workspace, repoSlug, commit, reportId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a report (asynchronously)
     * Deletes a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteReportAsync(String workspace, String repoSlug, String commit, String reportId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteReportValidateBeforeCall(workspace, repoSlug, commit, reportId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAnnotation
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The annotation with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnnotationCall(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()))
            .replace("{" + "annotationId" + "}", localVarApiClient.escapeString(annotationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAnnotationValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling getAnnotation(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling getAnnotation(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling getAnnotation(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling getAnnotation(Async)");
        }

        // verify the required parameter 'annotationId' is set
        if (annotationId == null) {
            throw new ApiException("Missing the required parameter 'annotationId' when calling getAnnotation(Async)");
        }

        return getAnnotationCall(workspace, repoSlug, commit, reportId, annotationId, _callback);

    }

    /**
     * Get an annotation
     * Returns a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @return ReportAnnotation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The annotation with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public ReportAnnotation getAnnotation(String workspace, String repoSlug, String commit, String reportId, String annotationId) throws ApiException {
        ApiResponse<ReportAnnotation> localVarResp = getAnnotationWithHttpInfo(workspace, repoSlug, commit, reportId, annotationId);
        return localVarResp.getData();
    }

    /**
     * Get an annotation
     * Returns a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @return ApiResponse&lt;ReportAnnotation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The annotation with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReportAnnotation> getAnnotationWithHttpInfo(String workspace, String repoSlug, String commit, String reportId, String annotationId) throws ApiException {
        okhttp3.Call localVarCall = getAnnotationValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, null);
        Type localVarReturnType = new TypeToken<ReportAnnotation>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get an annotation (asynchronously)
     * Returns a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The annotation with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnnotationAsync(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback<ReportAnnotation> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAnnotationValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, _callback);
        Type localVarReturnType = new TypeToken<ReportAnnotation>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAnnotationsForReport
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnnotationsForReportCall(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAnnotationsForReportValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling getAnnotationsForReport(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling getAnnotationsForReport(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling getAnnotationsForReport(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling getAnnotationsForReport(Async)");
        }

        return getAnnotationsForReportCall(workspace, repoSlug, commit, reportId, _callback);

    }

    /**
     * List annotations
     * Returns a paginated list of Annotations for a specified report.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @return PaginatedAnnotations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedAnnotations getAnnotationsForReport(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        ApiResponse<PaginatedAnnotations> localVarResp = getAnnotationsForReportWithHttpInfo(workspace, repoSlug, commit, reportId);
        return localVarResp.getData();
    }

    /**
     * List annotations
     * Returns a paginated list of Annotations for a specified report.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @return ApiResponse&lt;PaginatedAnnotations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedAnnotations> getAnnotationsForReportWithHttpInfo(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        okhttp3.Call localVarCall = getAnnotationsForReportValidateBeforeCall(workspace, repoSlug, commit, reportId, null);
        Type localVarReturnType = new TypeToken<PaginatedAnnotations>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List annotations (asynchronously)
     * Returns a paginated list of Annotations for a specified report.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnnotationsForReportAsync(String workspace, String repoSlug, String commit, String reportId, final ApiCallback<PaginatedAnnotations> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAnnotationsForReportValidateBeforeCall(workspace, repoSlug, commit, reportId, _callback);
        Type localVarReturnType = new TypeToken<PaginatedAnnotations>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getReport
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The report with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReportCall(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReportValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling getReport(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling getReport(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling getReport(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling getReport(Async)");
        }

        return getReportCall(workspace, repoSlug, commit, reportId, _callback);

    }

    /**
     * Get a report
     * Returns a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @return Report
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The report with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public Report getReport(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        ApiResponse<Report> localVarResp = getReportWithHttpInfo(workspace, repoSlug, commit, reportId);
        return localVarResp.getData();
    }

    /**
     * Get a report
     * Returns a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @return ApiResponse&lt;Report&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The report with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Report> getReportWithHttpInfo(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        okhttp3.Call localVarCall = getReportValidateBeforeCall(workspace, repoSlug, commit, reportId, null);
        Type localVarReturnType = new TypeToken<Report>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a report (asynchronously)
     * Returns a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The report with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReportAsync(String workspace, String repoSlug, String commit, String reportId, final ApiCallback<Report> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReportValidateBeforeCall(workspace, repoSlug, commit, reportId, _callback);
        Type localVarReturnType = new TypeToken<Report>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getReportsForCommit
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReportsForCommitCall(String workspace, String repoSlug, String commit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReportsForCommitValidateBeforeCall(String workspace, String repoSlug, String commit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling getReportsForCommit(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling getReportsForCommit(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling getReportsForCommit(Async)");
        }

        return getReportsForCommitCall(workspace, repoSlug, commit, _callback);

    }

    /**
     * List reports
     * Returns a paginated list of Reports linked to this commit.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @return PaginatedReports
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedReports getReportsForCommit(String workspace, String repoSlug, String commit) throws ApiException {
        ApiResponse<PaginatedReports> localVarResp = getReportsForCommitWithHttpInfo(workspace, repoSlug, commit);
        return localVarResp.getData();
    }

    /**
     * List reports
     * Returns a paginated list of Reports linked to this commit.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @return ApiResponse&lt;PaginatedReports&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedReports> getReportsForCommitWithHttpInfo(String workspace, String repoSlug, String commit) throws ApiException {
        okhttp3.Call localVarCall = getReportsForCommitValidateBeforeCall(workspace, repoSlug, commit, null);
        Type localVarReturnType = new TypeToken<PaginatedReports>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List reports (asynchronously)
     * Returns a paginated list of Reports linked to this commit.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReportsForCommitAsync(String workspace, String repoSlug, String commit, final ApiCallback<PaginatedReports> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReportsForCommitValidateBeforeCall(workspace, repoSlug, commit, _callback);
        Type localVarReturnType = new TypeToken<PaginatedReports>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
