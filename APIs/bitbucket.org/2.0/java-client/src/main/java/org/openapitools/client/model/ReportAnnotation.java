/*
 * Bitbucket API
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.Map;
import org.openapitools.client.model.ModelObject;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ReportAnnotation
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:00:39.758646-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ReportAnnotation extends ModelObject {
  /**
   * The type of the report.
   */
  @JsonAdapter(AnnotationTypeEnum.Adapter.class)
  public enum AnnotationTypeEnum {
    VULNERABILITY("VULNERABILITY"),
    
    CODE_SMELL("CODE_SMELL"),
    
    BUG("BUG");

    private String value;

    AnnotationTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AnnotationTypeEnum fromValue(String value) {
      for (AnnotationTypeEnum b : AnnotationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AnnotationTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AnnotationTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AnnotationTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AnnotationTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AnnotationTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ANNOTATION_TYPE = "annotation_type";
  @SerializedName(SERIALIZED_NAME_ANNOTATION_TYPE)
  private AnnotationTypeEnum annotationType;

  public static final String SERIALIZED_NAME_CREATED_ON = "created_on";
  @SerializedName(SERIALIZED_NAME_CREATED_ON)
  private OffsetDateTime createdOn;

  public static final String SERIALIZED_NAME_DETAILS = "details";
  @SerializedName(SERIALIZED_NAME_DETAILS)
  private String details;

  public static final String SERIALIZED_NAME_EXTERNAL_ID = "external_id";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_ID)
  private String externalId;

  public static final String SERIALIZED_NAME_LINE = "line";
  @SerializedName(SERIALIZED_NAME_LINE)
  private Integer line;

  public static final String SERIALIZED_NAME_LINK = "link";
  @SerializedName(SERIALIZED_NAME_LINK)
  private URI link;

  public static final String SERIALIZED_NAME_PATH = "path";
  @SerializedName(SERIALIZED_NAME_PATH)
  private String path;

  /**
   * The state of the report. May be set to PENDING and later updated.
   */
  @JsonAdapter(ResultEnum.Adapter.class)
  public enum ResultEnum {
    PASSED("PASSED"),
    
    FAILED("FAILED"),
    
    SKIPPED("SKIPPED"),
    
    IGNORED("IGNORED");

    private String value;

    ResultEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ResultEnum fromValue(String value) {
      for (ResultEnum b : ResultEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ResultEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ResultEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ResultEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ResultEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ResultEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  private ResultEnum result;

  /**
   * The severity of the annotation.
   */
  @JsonAdapter(SeverityEnum.Adapter.class)
  public enum SeverityEnum {
    CRITICAL("CRITICAL"),
    
    HIGH("HIGH"),
    
    MEDIUM("MEDIUM"),
    
    LOW("LOW");

    private String value;

    SeverityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SeverityEnum fromValue(String value) {
      for (SeverityEnum b : SeverityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SeverityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SeverityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SeverityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SeverityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SeverityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SEVERITY = "severity";
  @SerializedName(SERIALIZED_NAME_SEVERITY)
  private SeverityEnum severity;

  public static final String SERIALIZED_NAME_SUMMARY = "summary";
  @SerializedName(SERIALIZED_NAME_SUMMARY)
  private String summary;

  public static final String SERIALIZED_NAME_UPDATED_ON = "updated_on";
  @SerializedName(SERIALIZED_NAME_UPDATED_ON)
  private OffsetDateTime updatedOn;

  public static final String SERIALIZED_NAME_UUID = "uuid";
  @SerializedName(SERIALIZED_NAME_UUID)
  private String uuid;

  public ReportAnnotation() {
    this.type = this.getClass().getSimpleName();
  }

  public ReportAnnotation annotationType(AnnotationTypeEnum annotationType) {
    this.annotationType = annotationType;
    return this;
  }

  /**
   * The type of the report.
   * @return annotationType
   */
  @javax.annotation.Nullable
  public AnnotationTypeEnum getAnnotationType() {
    return annotationType;
  }

  public void setAnnotationType(AnnotationTypeEnum annotationType) {
    this.annotationType = annotationType;
  }


  public ReportAnnotation createdOn(OffsetDateTime createdOn) {
    this.createdOn = createdOn;
    return this;
  }

  /**
   * The timestamp when the report was created.
   * @return createdOn
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedOn() {
    return createdOn;
  }

  public void setCreatedOn(OffsetDateTime createdOn) {
    this.createdOn = createdOn;
  }


  public ReportAnnotation details(String details) {
    this.details = details;
    return this;
  }

  /**
   * The details to show to users when clicking on the annotation.
   * @return details
   */
  @javax.annotation.Nullable
  public String getDetails() {
    return details;
  }

  public void setDetails(String details) {
    this.details = details;
  }


  public ReportAnnotation externalId(String externalId) {
    this.externalId = externalId;
    return this;
  }

  /**
   * ID of the annotation provided by the annotation creator. It can be used to identify the annotation as an alternative to it&#39;s generated uuid. It is not used by Bitbucket, but only by the annotation creator for updating or deleting this specific annotation. Needs to be unique.
   * @return externalId
   */
  @javax.annotation.Nullable
  public String getExternalId() {
    return externalId;
  }

  public void setExternalId(String externalId) {
    this.externalId = externalId;
  }


  public ReportAnnotation line(Integer line) {
    this.line = line;
    return this;
  }

  /**
   * The line number that the annotation should belong to. If no line number is provided, then it will default to 0 and in a pull request it will appear at the top of the file specified by the path field.
   * minimum: 1
   * @return line
   */
  @javax.annotation.Nullable
  public Integer getLine() {
    return line;
  }

  public void setLine(Integer line) {
    this.line = line;
  }


  public ReportAnnotation link(URI link) {
    this.link = link;
    return this;
  }

  /**
   * A URL linking to the annotation in an external tool.
   * @return link
   */
  @javax.annotation.Nullable
  public URI getLink() {
    return link;
  }

  public void setLink(URI link) {
    this.link = link;
  }


  public ReportAnnotation path(String path) {
    this.path = path;
    return this;
  }

  /**
   * The path of the file on which this annotation should be placed. This is the path of the file relative to the git repository. If no path is provided, then it will appear in the overview modal on all pull requests where the tip of the branch is the given commit, regardless of which files were modified.
   * @return path
   */
  @javax.annotation.Nullable
  public String getPath() {
    return path;
  }

  public void setPath(String path) {
    this.path = path;
  }


  public ReportAnnotation result(ResultEnum result) {
    this.result = result;
    return this;
  }

  /**
   * The state of the report. May be set to PENDING and later updated.
   * @return result
   */
  @javax.annotation.Nullable
  public ResultEnum getResult() {
    return result;
  }

  public void setResult(ResultEnum result) {
    this.result = result;
  }


  public ReportAnnotation severity(SeverityEnum severity) {
    this.severity = severity;
    return this;
  }

  /**
   * The severity of the annotation.
   * @return severity
   */
  @javax.annotation.Nullable
  public SeverityEnum getSeverity() {
    return severity;
  }

  public void setSeverity(SeverityEnum severity) {
    this.severity = severity;
  }


  public ReportAnnotation summary(String summary) {
    this.summary = summary;
    return this;
  }

  /**
   * The message to display to users.
   * @return summary
   */
  @javax.annotation.Nullable
  public String getSummary() {
    return summary;
  }

  public void setSummary(String summary) {
    this.summary = summary;
  }


  public ReportAnnotation updatedOn(OffsetDateTime updatedOn) {
    this.updatedOn = updatedOn;
    return this;
  }

  /**
   * The timestamp when the report was updated.
   * @return updatedOn
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedOn() {
    return updatedOn;
  }

  public void setUpdatedOn(OffsetDateTime updatedOn) {
    this.updatedOn = updatedOn;
  }


  public ReportAnnotation uuid(String uuid) {
    this.uuid = uuid;
    return this;
  }

  /**
   * The UUID that can be used to identify the annotation.
   * @return uuid
   */
  @javax.annotation.Nullable
  public String getUuid() {
    return uuid;
  }

  public void setUuid(String uuid) {
    this.uuid = uuid;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReportAnnotation reportAnnotation = (ReportAnnotation) o;
    return Objects.equals(this.annotationType, reportAnnotation.annotationType) &&
        Objects.equals(this.createdOn, reportAnnotation.createdOn) &&
        Objects.equals(this.details, reportAnnotation.details) &&
        Objects.equals(this.externalId, reportAnnotation.externalId) &&
        Objects.equals(this.line, reportAnnotation.line) &&
        Objects.equals(this.link, reportAnnotation.link) &&
        Objects.equals(this.path, reportAnnotation.path) &&
        Objects.equals(this.result, reportAnnotation.result) &&
        Objects.equals(this.severity, reportAnnotation.severity) &&
        Objects.equals(this.summary, reportAnnotation.summary) &&
        Objects.equals(this.updatedOn, reportAnnotation.updatedOn) &&
        Objects.equals(this.uuid, reportAnnotation.uuid) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotationType, createdOn, details, externalId, line, link, path, result, severity, summary, updatedOn, uuid, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReportAnnotation {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    annotationType: ").append(toIndentedString(annotationType)).append("\n");
    sb.append("    createdOn: ").append(toIndentedString(createdOn)).append("\n");
    sb.append("    details: ").append(toIndentedString(details)).append("\n");
    sb.append("    externalId: ").append(toIndentedString(externalId)).append("\n");
    sb.append("    line: ").append(toIndentedString(line)).append("\n");
    sb.append("    link: ").append(toIndentedString(link)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    severity: ").append(toIndentedString(severity)).append("\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("    updatedOn: ").append(toIndentedString(updatedOn)).append("\n");
    sb.append("    uuid: ").append(toIndentedString(uuid)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("type");
    openapiFields.add("annotation_type");
    openapiFields.add("created_on");
    openapiFields.add("details");
    openapiFields.add("external_id");
    openapiFields.add("line");
    openapiFields.add("link");
    openapiFields.add("path");
    openapiFields.add("result");
    openapiFields.add("severity");
    openapiFields.add("summary");
    openapiFields.add("updated_on");
    openapiFields.add("uuid");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("type");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ReportAnnotation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ReportAnnotation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ReportAnnotation is not found in the empty JSON string", ReportAnnotation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ReportAnnotation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ReportAnnotation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ReportAnnotation.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ReportAnnotation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ReportAnnotation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ReportAnnotation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ReportAnnotation.class));

       return (TypeAdapter<T>) new TypeAdapter<ReportAnnotation>() {
           @Override
           public void write(JsonWriter out, ReportAnnotation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ReportAnnotation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ReportAnnotation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ReportAnnotation
   * @throws IOException if the JSON string is invalid with respect to ReportAnnotation
   */
  public static ReportAnnotation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ReportAnnotation.class);
  }

  /**
   * Convert an instance of ReportAnnotation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

