/*
 * Bitbucket API
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.Error;
import org.openapitools.client.model.PaginatedAccounts;
import org.openapitools.client.model.PaginatedSnippetComments;
import org.openapitools.client.model.PaginatedSnippetCommit;
import org.openapitools.client.model.PaginatedSnippets;
import org.openapitools.client.model.Snippet;
import org.openapitools.client.model.SnippetComment;
import org.openapitools.client.model.SnippetCommit;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SnippetsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SnippetsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SnippetsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for snippetsGet
     * @param role Filter down the result based on the authenticated user&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippets. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsGetCall(String role, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (role != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("role", role));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsGetValidateBeforeCall(String role, final ApiCallback _callback) throws ApiException {
        return snippetsGetCall(role, _callback);

    }

    /**
     * List snippets
     * Returns all snippets. Like pull requests, repositories and workspaces, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by any of the workspaces the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the &#x60;?role&#x3D;[owner|contributor|member]&#x60; query parameter where the roles are defined as follows:  * &#x60;owner&#x60;: all snippets owned by the current user * &#x60;contributor&#x60;: all snippets owned by, or watched by the current user * &#x60;member&#x60;: created in a workspaces or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports &#x60;application/json&#x60; responses and no &#x60;multipart/form-data&#x60; or &#x60;multipart/related&#x60;. As a result, it is not possible to include the file contents.
     * @param role Filter down the result based on the authenticated user&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;). (optional)
     * @return PaginatedSnippets
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippets. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedSnippets snippetsGet(String role) throws ApiException {
        ApiResponse<PaginatedSnippets> localVarResp = snippetsGetWithHttpInfo(role);
        return localVarResp.getData();
    }

    /**
     * List snippets
     * Returns all snippets. Like pull requests, repositories and workspaces, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by any of the workspaces the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the &#x60;?role&#x3D;[owner|contributor|member]&#x60; query parameter where the roles are defined as follows:  * &#x60;owner&#x60;: all snippets owned by the current user * &#x60;contributor&#x60;: all snippets owned by, or watched by the current user * &#x60;member&#x60;: created in a workspaces or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports &#x60;application/json&#x60; responses and no &#x60;multipart/form-data&#x60; or &#x60;multipart/related&#x60;. As a result, it is not possible to include the file contents.
     * @param role Filter down the result based on the authenticated user&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;). (optional)
     * @return ApiResponse&lt;PaginatedSnippets&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippets. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedSnippets> snippetsGetWithHttpInfo(String role) throws ApiException {
        okhttp3.Call localVarCall = snippetsGetValidateBeforeCall(role, null);
        Type localVarReturnType = new TypeToken<PaginatedSnippets>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List snippets (asynchronously)
     * Returns all snippets. Like pull requests, repositories and workspaces, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by any of the workspaces the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the &#x60;?role&#x3D;[owner|contributor|member]&#x60; query parameter where the roles are defined as follows:  * &#x60;owner&#x60;: all snippets owned by the current user * &#x60;contributor&#x60;: all snippets owned by, or watched by the current user * &#x60;member&#x60;: created in a workspaces or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports &#x60;application/json&#x60; responses and no &#x60;multipart/form-data&#x60; or &#x60;multipart/related&#x60;. As a result, it is not possible to include the file contents.
     * @param role Filter down the result based on the authenticated user&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippets. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsGetAsync(String role, final ApiCallback<PaginatedSnippets> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsGetValidateBeforeCall(role, _callback);
        Type localVarReturnType = new TypeToken<PaginatedSnippets>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsPost
     * @param snippet The new snippet object. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created snippet object. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsPostCall(Snippet snippet, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = snippet;

        // create path and map variables
        String localVarPath = "/snippets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsPostValidateBeforeCall(Snippet snippet, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'snippet' is set
        if (snippet == null) {
            throw new ApiException("Missing the required parameter 'snippet' when calling snippetsPost(Async)");
        }

        return snippetsPostCall(snippet, _callback);

    }

    /**
     * Create a snippet
     * Creates a new snippet under the authenticated user&#39;s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file&#x3D;@image.png  Creating snippets through curl has a few limitations and so let&#39;s look at a more complicated scenario.  Snippets are created with a multipart POST. Both &#x60;multipart/form-data&#x60; and &#x60;multipart/related&#x60; are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that &#x60;multipart/related&#x60; can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;is_private\&quot;: true,       \&quot;scm\&quot;: \&quot;git\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;image.png\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet&#39;s properties or meta data. It either has to be the first part, or the request&#39;s &#x60;Content-Type&#x60; header must contain the &#x60;start&#x60; parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the &#x60;Content-ID&#x60; MIME header through which the JSON meta data&#39;s &#x60;files&#x60; element addresses it. The value should be the name of the file.  &#x60;Content-Disposition&#x60; is an optional MIME header. The header&#39;s optional &#x60;filename&#x60; parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, &#x60;filename&#x60; takes precedence over the value of &#x60;Content-ID&#x60;.  When the JSON body omits the &#x60;files&#x60; element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the &#x60;files&#x60; elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet&#39;s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional &#x60;multipart/form-data&#x60; request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title&#x3D;\&quot;My snippet\&quot;               -F file&#x3D;@foo.txt -F file&#x3D;@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the &#x60;file&#x60; field name. To attach multiple files, simply repeat the field.  The advantage of &#x60;multipart/form-data&#x60; over &#x60;multipart/related&#x60; is that it can be easier to build clients.  Essentially all properties are optional, &#x60;title&#x60; and &#x60;files&#x60; included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to members of the workspace). This is controlled through the snippet&#39;s &#x60;is_private&#x60; element:  * **is_private&#x3D;false** -- everyone, including anonymous users can view   the snippet * **is_private&#x3D;true** -- only workspace members can view the snippet  To create the snippet under a workspace, just append the workspace ID to the URL. See [&#x60;/2.0/snippets/{workspace}&#x60;](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-post).
     * @param snippet The new snippet object. (required)
     * @return Snippet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created snippet object. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated </td><td>  -  </td></tr>
     </table>
     */
    public Snippet snippetsPost(Snippet snippet) throws ApiException {
        ApiResponse<Snippet> localVarResp = snippetsPostWithHttpInfo(snippet);
        return localVarResp.getData();
    }

    /**
     * Create a snippet
     * Creates a new snippet under the authenticated user&#39;s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file&#x3D;@image.png  Creating snippets through curl has a few limitations and so let&#39;s look at a more complicated scenario.  Snippets are created with a multipart POST. Both &#x60;multipart/form-data&#x60; and &#x60;multipart/related&#x60; are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that &#x60;multipart/related&#x60; can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;is_private\&quot;: true,       \&quot;scm\&quot;: \&quot;git\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;image.png\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet&#39;s properties or meta data. It either has to be the first part, or the request&#39;s &#x60;Content-Type&#x60; header must contain the &#x60;start&#x60; parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the &#x60;Content-ID&#x60; MIME header through which the JSON meta data&#39;s &#x60;files&#x60; element addresses it. The value should be the name of the file.  &#x60;Content-Disposition&#x60; is an optional MIME header. The header&#39;s optional &#x60;filename&#x60; parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, &#x60;filename&#x60; takes precedence over the value of &#x60;Content-ID&#x60;.  When the JSON body omits the &#x60;files&#x60; element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the &#x60;files&#x60; elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet&#39;s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional &#x60;multipart/form-data&#x60; request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title&#x3D;\&quot;My snippet\&quot;               -F file&#x3D;@foo.txt -F file&#x3D;@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the &#x60;file&#x60; field name. To attach multiple files, simply repeat the field.  The advantage of &#x60;multipart/form-data&#x60; over &#x60;multipart/related&#x60; is that it can be easier to build clients.  Essentially all properties are optional, &#x60;title&#x60; and &#x60;files&#x60; included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to members of the workspace). This is controlled through the snippet&#39;s &#x60;is_private&#x60; element:  * **is_private&#x3D;false** -- everyone, including anonymous users can view   the snippet * **is_private&#x3D;true** -- only workspace members can view the snippet  To create the snippet under a workspace, just append the workspace ID to the URL. See [&#x60;/2.0/snippets/{workspace}&#x60;](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-post).
     * @param snippet The new snippet object. (required)
     * @return ApiResponse&lt;Snippet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created snippet object. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Snippet> snippetsPostWithHttpInfo(Snippet snippet) throws ApiException {
        okhttp3.Call localVarCall = snippetsPostValidateBeforeCall(snippet, null);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a snippet (asynchronously)
     * Creates a new snippet under the authenticated user&#39;s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file&#x3D;@image.png  Creating snippets through curl has a few limitations and so let&#39;s look at a more complicated scenario.  Snippets are created with a multipart POST. Both &#x60;multipart/form-data&#x60; and &#x60;multipart/related&#x60; are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that &#x60;multipart/related&#x60; can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;is_private\&quot;: true,       \&quot;scm\&quot;: \&quot;git\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;image.png\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet&#39;s properties or meta data. It either has to be the first part, or the request&#39;s &#x60;Content-Type&#x60; header must contain the &#x60;start&#x60; parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the &#x60;Content-ID&#x60; MIME header through which the JSON meta data&#39;s &#x60;files&#x60; element addresses it. The value should be the name of the file.  &#x60;Content-Disposition&#x60; is an optional MIME header. The header&#39;s optional &#x60;filename&#x60; parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, &#x60;filename&#x60; takes precedence over the value of &#x60;Content-ID&#x60;.  When the JSON body omits the &#x60;files&#x60; element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the &#x60;files&#x60; elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet&#39;s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional &#x60;multipart/form-data&#x60; request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title&#x3D;\&quot;My snippet\&quot;               -F file&#x3D;@foo.txt -F file&#x3D;@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the &#x60;file&#x60; field name. To attach multiple files, simply repeat the field.  The advantage of &#x60;multipart/form-data&#x60; over &#x60;multipart/related&#x60; is that it can be easier to build clients.  Essentially all properties are optional, &#x60;title&#x60; and &#x60;files&#x60; included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to members of the workspace). This is controlled through the snippet&#39;s &#x60;is_private&#x60; element:  * **is_private&#x3D;false** -- everyone, including anonymous users can view   the snippet * **is_private&#x3D;true** -- only workspace members can view the snippet  To create the snippet under a workspace, just append the workspace ID to the URL. See [&#x60;/2.0/snippets/{workspace}&#x60;](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-workspace-post).
     * @param snippet The new snippet object. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created snippet object. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsPostAsync(Snippet snippet, final ApiCallback<Snippet> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsPostValidateBeforeCall(snippet, _callback);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdCommentsCommentIdDelete
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the comment was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user is not the author of the comment. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsCommentIdDeleteCall(Integer commentId, String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/comments/{comment_id}"
            .replace("{" + "comment_id" + "}", localVarApiClient.escapeString(commentId.toString()))
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdCommentsCommentIdDeleteValidateBeforeCall(Integer commentId, String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commentId' is set
        if (commentId == null) {
            throw new ApiException("Missing the required parameter 'commentId' when calling snippetsWorkspaceEncodedIdCommentsCommentIdDelete(Async)");
        }

        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdCommentsCommentIdDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdCommentsCommentIdDelete(Async)");
        }

        return snippetsWorkspaceEncodedIdCommentsCommentIdDeleteCall(commentId, encodedId, workspace, _callback);

    }

    /**
     * Delete a comment on a snippet
     * Deletes a snippet comment.  Comments can only be removed by the comment author, snippet creator, or workspace admin.
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the comment was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user is not the author of the comment. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdCommentsCommentIdDelete(Integer commentId, String encodedId, String workspace) throws ApiException {
        snippetsWorkspaceEncodedIdCommentsCommentIdDeleteWithHttpInfo(commentId, encodedId, workspace);
    }

    /**
     * Delete a comment on a snippet
     * Deletes a snippet comment.  Comments can only be removed by the comment author, snippet creator, or workspace admin.
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the comment was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user is not the author of the comment. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdCommentsCommentIdDeleteWithHttpInfo(Integer commentId, String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsCommentIdDeleteValidateBeforeCall(commentId, encodedId, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a comment on a snippet (asynchronously)
     * Deletes a snippet comment.  Comments can only be removed by the comment author, snippet creator, or workspace admin.
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the comment was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user is not the author of the comment. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsCommentIdDeleteAsync(Integer commentId, String encodedId, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsCommentIdDeleteValidateBeforeCall(commentId, encodedId, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdCommentsCommentIdGet
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The specified comment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsCommentIdGetCall(Integer commentId, String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/comments/{comment_id}"
            .replace("{" + "comment_id" + "}", localVarApiClient.escapeString(commentId.toString()))
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdCommentsCommentIdGetValidateBeforeCall(Integer commentId, String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commentId' is set
        if (commentId == null) {
            throw new ApiException("Missing the required parameter 'commentId' when calling snippetsWorkspaceEncodedIdCommentsCommentIdGet(Async)");
        }

        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdCommentsCommentIdGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdCommentsCommentIdGet(Async)");
        }

        return snippetsWorkspaceEncodedIdCommentsCommentIdGetCall(commentId, encodedId, workspace, _callback);

    }

    /**
     * Get a comment on a snippet
     * Returns the specific snippet comment.
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return SnippetComment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The specified comment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public SnippetComment snippetsWorkspaceEncodedIdCommentsCommentIdGet(Integer commentId, String encodedId, String workspace) throws ApiException {
        ApiResponse<SnippetComment> localVarResp = snippetsWorkspaceEncodedIdCommentsCommentIdGetWithHttpInfo(commentId, encodedId, workspace);
        return localVarResp.getData();
    }

    /**
     * Get a comment on a snippet
     * Returns the specific snippet comment.
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;SnippetComment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The specified comment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnippetComment> snippetsWorkspaceEncodedIdCommentsCommentIdGetWithHttpInfo(Integer commentId, String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsCommentIdGetValidateBeforeCall(commentId, encodedId, workspace, null);
        Type localVarReturnType = new TypeToken<SnippetComment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a comment on a snippet (asynchronously)
     * Returns the specific snippet comment.
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The specified comment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsCommentIdGetAsync(Integer commentId, String encodedId, String workspace, final ApiCallback<SnippetComment> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsCommentIdGetValidateBeforeCall(commentId, encodedId, workspace, _callback);
        Type localVarReturnType = new TypeToken<SnippetComment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdCommentsCommentIdPut
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippetComment The contents to update the comment to. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated comment object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsCommentIdPutCall(Integer commentId, String encodedId, String workspace, SnippetComment snippetComment, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = snippetComment;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/comments/{comment_id}"
            .replace("{" + "comment_id" + "}", localVarApiClient.escapeString(commentId.toString()))
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdCommentsCommentIdPutValidateBeforeCall(Integer commentId, String encodedId, String workspace, SnippetComment snippetComment, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commentId' is set
        if (commentId == null) {
            throw new ApiException("Missing the required parameter 'commentId' when calling snippetsWorkspaceEncodedIdCommentsCommentIdPut(Async)");
        }

        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdCommentsCommentIdPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdCommentsCommentIdPut(Async)");
        }

        // verify the required parameter 'snippetComment' is set
        if (snippetComment == null) {
            throw new ApiException("Missing the required parameter 'snippetComment' when calling snippetsWorkspaceEncodedIdCommentsCommentIdPut(Async)");
        }

        return snippetsWorkspaceEncodedIdCommentsCommentIdPutCall(commentId, encodedId, workspace, snippetComment, _callback);

    }

    /**
     * Update a comment on a snippet
     * Updates a comment.  The only required field in the body is &#x60;content.raw&#x60;.  Comments can only be updated by their author.
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippetComment The contents to update the comment to. (required)
     * @return SnippetComment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated comment object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public SnippetComment snippetsWorkspaceEncodedIdCommentsCommentIdPut(Integer commentId, String encodedId, String workspace, SnippetComment snippetComment) throws ApiException {
        ApiResponse<SnippetComment> localVarResp = snippetsWorkspaceEncodedIdCommentsCommentIdPutWithHttpInfo(commentId, encodedId, workspace, snippetComment);
        return localVarResp.getData();
    }

    /**
     * Update a comment on a snippet
     * Updates a comment.  The only required field in the body is &#x60;content.raw&#x60;.  Comments can only be updated by their author.
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippetComment The contents to update the comment to. (required)
     * @return ApiResponse&lt;SnippetComment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated comment object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnippetComment> snippetsWorkspaceEncodedIdCommentsCommentIdPutWithHttpInfo(Integer commentId, String encodedId, String workspace, SnippetComment snippetComment) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsCommentIdPutValidateBeforeCall(commentId, encodedId, workspace, snippetComment, null);
        Type localVarReturnType = new TypeToken<SnippetComment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a comment on a snippet (asynchronously)
     * Updates a comment.  The only required field in the body is &#x60;content.raw&#x60;.  Comments can only be updated by their author.
     * @param commentId The id of the comment. (required)
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippetComment The contents to update the comment to. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated comment object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsCommentIdPutAsync(Integer commentId, String encodedId, String workspace, SnippetComment snippetComment, final ApiCallback<SnippetComment> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsCommentIdPutValidateBeforeCall(commentId, encodedId, workspace, snippetComment, _callback);
        Type localVarReturnType = new TypeToken<SnippetComment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdCommentsGet
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippet comments, ordered by creation date. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsGetCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/comments"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdCommentsGetValidateBeforeCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdCommentsGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdCommentsGet(Async)");
        }

        return snippetsWorkspaceEncodedIdCommentsGetCall(encodedId, workspace, _callback);

    }

    /**
     * List comments on a snippet
     * Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedSnippetComments
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippet comments, ordered by creation date. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedSnippetComments snippetsWorkspaceEncodedIdCommentsGet(String encodedId, String workspace) throws ApiException {
        ApiResponse<PaginatedSnippetComments> localVarResp = snippetsWorkspaceEncodedIdCommentsGetWithHttpInfo(encodedId, workspace);
        return localVarResp.getData();
    }

    /**
     * List comments on a snippet
     * Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedSnippetComments&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippet comments, ordered by creation date. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedSnippetComments> snippetsWorkspaceEncodedIdCommentsGetWithHttpInfo(String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsGetValidateBeforeCall(encodedId, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedSnippetComments>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List comments on a snippet (asynchronously)
     * Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippet comments, ordered by creation date. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsGetAsync(String encodedId, String workspace, final ApiCallback<PaginatedSnippetComments> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsGetValidateBeforeCall(encodedId, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedSnippetComments>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdCommentsPost
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippetComment The contents of the new comment. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsPostCall(String encodedId, String workspace, SnippetComment snippetComment, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = snippetComment;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/comments"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdCommentsPostValidateBeforeCall(String encodedId, String workspace, SnippetComment snippetComment, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdCommentsPost(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdCommentsPost(Async)");
        }

        // verify the required parameter 'snippetComment' is set
        if (snippetComment == null) {
            throw new ApiException("Missing the required parameter 'snippetComment' when calling snippetsWorkspaceEncodedIdCommentsPost(Async)");
        }

        return snippetsWorkspaceEncodedIdCommentsPostCall(encodedId, workspace, snippetComment, _callback);

    }

    /**
     * Create a comment on a snippet
     * Creates a new comment.  The only required field in the body is &#x60;content.raw&#x60;.  To create a threaded reply to an existing comment, include &#x60;parent.id&#x60;.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippetComment The contents of the new comment. (required)
     * @return SnippetComment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public SnippetComment snippetsWorkspaceEncodedIdCommentsPost(String encodedId, String workspace, SnippetComment snippetComment) throws ApiException {
        ApiResponse<SnippetComment> localVarResp = snippetsWorkspaceEncodedIdCommentsPostWithHttpInfo(encodedId, workspace, snippetComment);
        return localVarResp.getData();
    }

    /**
     * Create a comment on a snippet
     * Creates a new comment.  The only required field in the body is &#x60;content.raw&#x60;.  To create a threaded reply to an existing comment, include &#x60;parent.id&#x60;.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippetComment The contents of the new comment. (required)
     * @return ApiResponse&lt;SnippetComment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnippetComment> snippetsWorkspaceEncodedIdCommentsPostWithHttpInfo(String encodedId, String workspace, SnippetComment snippetComment) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsPostValidateBeforeCall(encodedId, workspace, snippetComment, null);
        Type localVarReturnType = new TypeToken<SnippetComment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a comment on a snippet (asynchronously)
     * Creates a new comment.  The only required field in the body is &#x60;content.raw&#x60;.  To create a threaded reply to an existing comment, include &#x60;parent.id&#x60;.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippetComment The contents of the new comment. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommentsPostAsync(String encodedId, String workspace, SnippetComment snippetComment, final ApiCallback<SnippetComment> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommentsPostValidateBeforeCall(encodedId, workspace, snippetComment, _callback);
        Type localVarReturnType = new TypeToken<SnippetComment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdCommitsGet
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of snippet commits. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommitsGetCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/commits"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdCommitsGetValidateBeforeCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdCommitsGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdCommitsGet(Async)");
        }

        return snippetsWorkspaceEncodedIdCommitsGetCall(encodedId, workspace, _callback);

    }

    /**
     * List snippet changes
     * Returns the changes (commits) made on this snippet.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedSnippetCommit
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of snippet commits. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedSnippetCommit snippetsWorkspaceEncodedIdCommitsGet(String encodedId, String workspace) throws ApiException {
        ApiResponse<PaginatedSnippetCommit> localVarResp = snippetsWorkspaceEncodedIdCommitsGetWithHttpInfo(encodedId, workspace);
        return localVarResp.getData();
    }

    /**
     * List snippet changes
     * Returns the changes (commits) made on this snippet.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedSnippetCommit&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of snippet commits. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedSnippetCommit> snippetsWorkspaceEncodedIdCommitsGetWithHttpInfo(String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommitsGetValidateBeforeCall(encodedId, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedSnippetCommit>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List snippet changes (asynchronously)
     * Returns the changes (commits) made on this snippet.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of snippet commits. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommitsGetAsync(String encodedId, String workspace, final ApiCallback<PaginatedSnippetCommit> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommitsGetValidateBeforeCall(encodedId, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedSnippetCommit>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdCommitsRevisionGet
     * @param encodedId The snippet id. (required)
     * @param revision The commit&#39;s SHA1. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The specified snippet commit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the commit or the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommitsRevisionGetCall(String encodedId, String revision, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/commits/{revision}"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "revision" + "}", localVarApiClient.escapeString(revision.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdCommitsRevisionGetValidateBeforeCall(String encodedId, String revision, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdCommitsRevisionGet(Async)");
        }

        // verify the required parameter 'revision' is set
        if (revision == null) {
            throw new ApiException("Missing the required parameter 'revision' when calling snippetsWorkspaceEncodedIdCommitsRevisionGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdCommitsRevisionGet(Async)");
        }

        return snippetsWorkspaceEncodedIdCommitsRevisionGetCall(encodedId, revision, workspace, _callback);

    }

    /**
     * Get a previous snippet change
     * Returns the changes made on this snippet in this commit.
     * @param encodedId The snippet id. (required)
     * @param revision The commit&#39;s SHA1. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return SnippetCommit
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The specified snippet commit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the commit or the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public SnippetCommit snippetsWorkspaceEncodedIdCommitsRevisionGet(String encodedId, String revision, String workspace) throws ApiException {
        ApiResponse<SnippetCommit> localVarResp = snippetsWorkspaceEncodedIdCommitsRevisionGetWithHttpInfo(encodedId, revision, workspace);
        return localVarResp.getData();
    }

    /**
     * Get a previous snippet change
     * Returns the changes made on this snippet in this commit.
     * @param encodedId The snippet id. (required)
     * @param revision The commit&#39;s SHA1. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;SnippetCommit&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The specified snippet commit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the commit or the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SnippetCommit> snippetsWorkspaceEncodedIdCommitsRevisionGetWithHttpInfo(String encodedId, String revision, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommitsRevisionGetValidateBeforeCall(encodedId, revision, workspace, null);
        Type localVarReturnType = new TypeToken<SnippetCommit>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a previous snippet change (asynchronously)
     * Returns the changes made on this snippet in this commit.
     * @param encodedId The snippet id. (required)
     * @param revision The commit&#39;s SHA1. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The specified snippet commit. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the commit or the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdCommitsRevisionGetAsync(String encodedId, String revision, String workspace, final ApiCallback<SnippetCommit> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdCommitsRevisionGetValidateBeforeCall(encodedId, revision, workspace, _callback);
        Type localVarReturnType = new TypeToken<SnippetCommit>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdDelete
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the snippet was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to delete the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdDeleteCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdDeleteValidateBeforeCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdDelete(Async)");
        }

        return snippetsWorkspaceEncodedIdDeleteCall(encodedId, workspace, _callback);

    }

    /**
     * Delete a snippet
     * Deletes a snippet and returns an empty response.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the snippet was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to delete the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdDelete(String encodedId, String workspace) throws ApiException {
        snippetsWorkspaceEncodedIdDeleteWithHttpInfo(encodedId, workspace);
    }

    /**
     * Delete a snippet
     * Deletes a snippet and returns an empty response.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the snippet was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to delete the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdDeleteWithHttpInfo(String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdDeleteValidateBeforeCall(encodedId, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a snippet (asynchronously)
     * Deletes a snippet and returns an empty response.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the snippet was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to delete the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdDeleteAsync(String encodedId, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdDeleteValidateBeforeCall(encodedId, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdFilesPathGet
     * @param encodedId The snippet id. (required)
     * @param path Path to the file. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 302 </td><td> A redirect to the most recent revision of the specified file. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdFilesPathGetCall(String encodedId, String path, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/files/{path}"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "path" + "}", localVarApiClient.escapeString(path.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdFilesPathGetValidateBeforeCall(String encodedId, String path, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdFilesPathGet(Async)");
        }

        // verify the required parameter 'path' is set
        if (path == null) {
            throw new ApiException("Missing the required parameter 'path' when calling snippetsWorkspaceEncodedIdFilesPathGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdFilesPathGet(Async)");
        }

        return snippetsWorkspaceEncodedIdFilesPathGetCall(encodedId, path, workspace, _callback);

    }

    /**
     * Get a snippet&#39;s raw file at HEAD
     * Convenience resource for getting to a snippet&#39;s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.
     * @param encodedId The snippet id. (required)
     * @param path Path to the file. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 302 </td><td> A redirect to the most recent revision of the specified file. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdFilesPathGet(String encodedId, String path, String workspace) throws ApiException {
        snippetsWorkspaceEncodedIdFilesPathGetWithHttpInfo(encodedId, path, workspace);
    }

    /**
     * Get a snippet&#39;s raw file at HEAD
     * Convenience resource for getting to a snippet&#39;s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.
     * @param encodedId The snippet id. (required)
     * @param path Path to the file. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 302 </td><td> A redirect to the most recent revision of the specified file. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdFilesPathGetWithHttpInfo(String encodedId, String path, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdFilesPathGetValidateBeforeCall(encodedId, path, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Get a snippet&#39;s raw file at HEAD (asynchronously)
     * Convenience resource for getting to a snippet&#39;s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.
     * @param encodedId The snippet id. (required)
     * @param path Path to the file. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 302 </td><td> A redirect to the most recent revision of the specified file. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdFilesPathGetAsync(String encodedId, String path, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdFilesPathGetValidateBeforeCall(encodedId, path, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdGet
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have access to the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> If the snippet marked as spam. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdGetCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "multipart/form-data",
            "multipart/related"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdGetValidateBeforeCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdGet(Async)");
        }

        return snippetsWorkspaceEncodedIdGetCall(encodedId, workspace, _callback);

    }

    /**
     * Get a snippet
     * Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is &#x60;application/json&#x60;. Since JSON is always &#x60;utf-8&#x60;, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the &#x60;Accept: multipart/related&#x60; HTTP request header.      $ curl -H \&quot;Accept: multipart/related\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj\&quot;         },         \&quot;comments\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\&quot;         },         \&quot;watchers\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\&quot;         },         \&quot;commits\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\&quot;         }       },       \&quot;id\&quot;: kypj,       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;created_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;updated_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;is_private\&quot;: false,       \&quot;files\&quot;: {         \&quot;foo.txt\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\&quot;             }           }         },         \&quot;image.png\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-image.png\&quot;             }           }         }       ],       \&quot;owner\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       },       \&quot;creator\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  multipart/form-data -------------------  As with creating new snippets, &#x60;multipart/form-data&#x60; can be used as an alternative to &#x60;multipart/related&#x60;. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like &#x60;links&#x60; are omitted:      $ curl -H \&quot;Accept: multipart/form-data\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;     Content-Type: text/plain; charset&#x3D;\&quot;utf-8\&quot;      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     ------------------------------5957323a6b76--
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return Snippet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have access to the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> If the snippet marked as spam. </td><td>  -  </td></tr>
     </table>
     */
    public Snippet snippetsWorkspaceEncodedIdGet(String encodedId, String workspace) throws ApiException {
        ApiResponse<Snippet> localVarResp = snippetsWorkspaceEncodedIdGetWithHttpInfo(encodedId, workspace);
        return localVarResp.getData();
    }

    /**
     * Get a snippet
     * Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is &#x60;application/json&#x60;. Since JSON is always &#x60;utf-8&#x60;, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the &#x60;Accept: multipart/related&#x60; HTTP request header.      $ curl -H \&quot;Accept: multipart/related\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj\&quot;         },         \&quot;comments\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\&quot;         },         \&quot;watchers\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\&quot;         },         \&quot;commits\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\&quot;         }       },       \&quot;id\&quot;: kypj,       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;created_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;updated_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;is_private\&quot;: false,       \&quot;files\&quot;: {         \&quot;foo.txt\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\&quot;             }           }         },         \&quot;image.png\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-image.png\&quot;             }           }         }       ],       \&quot;owner\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       },       \&quot;creator\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  multipart/form-data -------------------  As with creating new snippets, &#x60;multipart/form-data&#x60; can be used as an alternative to &#x60;multipart/related&#x60;. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like &#x60;links&#x60; are omitted:      $ curl -H \&quot;Accept: multipart/form-data\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;     Content-Type: text/plain; charset&#x3D;\&quot;utf-8\&quot;      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     ------------------------------5957323a6b76--
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Snippet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have access to the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> If the snippet marked as spam. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Snippet> snippetsWorkspaceEncodedIdGetWithHttpInfo(String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdGetValidateBeforeCall(encodedId, workspace, null);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a snippet (asynchronously)
     * Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is &#x60;application/json&#x60;. Since JSON is always &#x60;utf-8&#x60;, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the &#x60;Accept: multipart/related&#x60; HTTP request header.      $ curl -H \&quot;Accept: multipart/related\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj\&quot;         },         \&quot;comments\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\&quot;         },         \&quot;watchers\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\&quot;         },         \&quot;commits\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\&quot;         }       },       \&quot;id\&quot;: kypj,       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;created_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;updated_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;is_private\&quot;: false,       \&quot;files\&quot;: {         \&quot;foo.txt\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\&quot;             }           }         },         \&quot;image.png\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-image.png\&quot;             }           }         }       ],       \&quot;owner\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       },       \&quot;creator\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  multipart/form-data -------------------  As with creating new snippets, &#x60;multipart/form-data&#x60; can be used as an alternative to &#x60;multipart/related&#x60;. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like &#x60;links&#x60; are omitted:      $ curl -H \&quot;Accept: multipart/form-data\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;     Content-Type: text/plain; charset&#x3D;\&quot;utf-8\&quot;      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     ------------------------------5957323a6b76--
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have access to the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> If the snippet marked as spam. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdGetAsync(String encodedId, String workspace, final ApiCallback<Snippet> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdGetValidateBeforeCall(encodedId, workspace, _callback);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdNodeIdDelete
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the snippet was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to delete the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> If &#x60;{node_id}&#x60; is not the latest revision. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdNodeIdDeleteCall(String encodedId, String nodeId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/{node_id}"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdNodeIdDeleteValidateBeforeCall(String encodedId, String nodeId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdNodeIdDelete(Async)");
        }

        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling snippetsWorkspaceEncodedIdNodeIdDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdNodeIdDelete(Async)");
        }

        return snippetsWorkspaceEncodedIdNodeIdDeleteCall(encodedId, nodeId, workspace, _callback);

    }

    /**
     * Delete a previous revision of a snippet
     * Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use &#x60;DELETE /snippets/{encoded_id}&#x60; instead.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the snippet was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to delete the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> If &#x60;{node_id}&#x60; is not the latest revision. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdNodeIdDelete(String encodedId, String nodeId, String workspace) throws ApiException {
        snippetsWorkspaceEncodedIdNodeIdDeleteWithHttpInfo(encodedId, nodeId, workspace);
    }

    /**
     * Delete a previous revision of a snippet
     * Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use &#x60;DELETE /snippets/{encoded_id}&#x60; instead.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the snippet was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to delete the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> If &#x60;{node_id}&#x60; is not the latest revision. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdNodeIdDeleteWithHttpInfo(String encodedId, String nodeId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdNodeIdDeleteValidateBeforeCall(encodedId, nodeId, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a previous revision of a snippet (asynchronously)
     * Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use &#x60;DELETE /snippets/{encoded_id}&#x60; instead.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the snippet was deleted successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to delete the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> If &#x60;{node_id}&#x60; is not the latest revision. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdNodeIdDeleteAsync(String encodedId, String nodeId, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdNodeIdDeleteValidateBeforeCall(encodedId, nodeId, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdNodeIdFilesPathGet
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param path Path to the file. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the contents of the specified file. </td><td>  * Content-Disposition - attachment <br>  * Content-Type - The mime type as derived from the filename <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the file or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdNodeIdFilesPathGetCall(String encodedId, String nodeId, String path, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/{node_id}/files/{path}"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "path" + "}", localVarApiClient.escapeString(path.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdNodeIdFilesPathGetValidateBeforeCall(String encodedId, String nodeId, String path, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdNodeIdFilesPathGet(Async)");
        }

        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling snippetsWorkspaceEncodedIdNodeIdFilesPathGet(Async)");
        }

        // verify the required parameter 'path' is set
        if (path == null) {
            throw new ApiException("Missing the required parameter 'path' when calling snippetsWorkspaceEncodedIdNodeIdFilesPathGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdNodeIdFilesPathGet(Async)");
        }

        return snippetsWorkspaceEncodedIdNodeIdFilesPathGetCall(encodedId, nodeId, path, workspace, _callback);

    }

    /**
     * Get a snippet&#39;s raw file
     * Retrieves the raw contents of a specific file in the snippet. The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to avoid issues with malevolent executable files.  The file&#39;s mime type is derived from its filename and returned in the &#x60;Content-Type&#x60; header.  Note that for text files, no character encoding is included as part of the content type.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param path Path to the file. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the contents of the specified file. </td><td>  * Content-Disposition - attachment <br>  * Content-Type - The mime type as derived from the filename <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the file or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdNodeIdFilesPathGet(String encodedId, String nodeId, String path, String workspace) throws ApiException {
        snippetsWorkspaceEncodedIdNodeIdFilesPathGetWithHttpInfo(encodedId, nodeId, path, workspace);
    }

    /**
     * Get a snippet&#39;s raw file
     * Retrieves the raw contents of a specific file in the snippet. The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to avoid issues with malevolent executable files.  The file&#39;s mime type is derived from its filename and returned in the &#x60;Content-Type&#x60; header.  Note that for text files, no character encoding is included as part of the content type.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param path Path to the file. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the contents of the specified file. </td><td>  * Content-Disposition - attachment <br>  * Content-Type - The mime type as derived from the filename <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the file or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdNodeIdFilesPathGetWithHttpInfo(String encodedId, String nodeId, String path, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdNodeIdFilesPathGetValidateBeforeCall(encodedId, nodeId, path, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Get a snippet&#39;s raw file (asynchronously)
     * Retrieves the raw contents of a specific file in the snippet. The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to avoid issues with malevolent executable files.  The file&#39;s mime type is derived from its filename and returned in the &#x60;Content-Type&#x60; header.  Note that for text files, no character encoding is included as part of the content type.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param path Path to the file. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the contents of the specified file. </td><td>  * Content-Disposition - attachment <br>  * Content-Type - The mime type as derived from the filename <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the file or snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdNodeIdFilesPathGetAsync(String encodedId, String nodeId, String path, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdNodeIdFilesPathGetValidateBeforeCall(encodedId, nodeId, path, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdNodeIdGet
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have access to the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet, or the revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdNodeIdGetCall(String encodedId, String nodeId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/{node_id}"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "multipart/form-data",
            "multipart/related"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdNodeIdGetValidateBeforeCall(String encodedId, String nodeId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdNodeIdGet(Async)");
        }

        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling snippetsWorkspaceEncodedIdNodeIdGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdNodeIdGet(Async)");
        }

        return snippetsWorkspaceEncodedIdNodeIdGetCall(encodedId, nodeId, workspace, _callback);

    }

    /**
     * Get a previous revision of a snippet
     * Identical to &#x60;GET /snippets/encoded_id&#x60;, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while &#x60;/snippets/encoded_id&#x60; always returns the snippet&#39;s current revision.  Note that only the snippet&#39;s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return Snippet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have access to the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet, or the revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public Snippet snippetsWorkspaceEncodedIdNodeIdGet(String encodedId, String nodeId, String workspace) throws ApiException {
        ApiResponse<Snippet> localVarResp = snippetsWorkspaceEncodedIdNodeIdGetWithHttpInfo(encodedId, nodeId, workspace);
        return localVarResp.getData();
    }

    /**
     * Get a previous revision of a snippet
     * Identical to &#x60;GET /snippets/encoded_id&#x60;, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while &#x60;/snippets/encoded_id&#x60; always returns the snippet&#39;s current revision.  Note that only the snippet&#39;s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Snippet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have access to the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet, or the revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Snippet> snippetsWorkspaceEncodedIdNodeIdGetWithHttpInfo(String encodedId, String nodeId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdNodeIdGetValidateBeforeCall(encodedId, nodeId, workspace, null);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a previous revision of a snippet (asynchronously)
     * Identical to &#x60;GET /snippets/encoded_id&#x60;, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while &#x60;/snippets/encoded_id&#x60; always returns the snippet&#39;s current revision.  Note that only the snippet&#39;s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have access to the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet, or the revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdNodeIdGetAsync(String encodedId, String nodeId, String workspace, final ApiCallback<Snippet> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdNodeIdGetValidateBeforeCall(encodedId, nodeId, workspace, _callback);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdNodeIdPut
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to update the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet or the revision does not exist. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> If &#x60;{node_id}&#x60; is not the latest revision. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdNodeIdPutCall(String encodedId, String nodeId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/{node_id}"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "node_id" + "}", localVarApiClient.escapeString(nodeId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "multipart/form-data",
            "multipart/related"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdNodeIdPutValidateBeforeCall(String encodedId, String nodeId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdNodeIdPut(Async)");
        }

        // verify the required parameter 'nodeId' is set
        if (nodeId == null) {
            throw new ApiException("Missing the required parameter 'nodeId' when calling snippetsWorkspaceEncodedIdNodeIdPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdNodeIdPut(Async)");
        }

        return snippetsWorkspaceEncodedIdNodeIdPutCall(encodedId, nodeId, workspace, _callback);

    }

    /**
     * Update a previous revision of a snippet
     * Identical to &#x60;UPDATE /snippets/encoded_id&#x60;, except that this endpoint takes an explicit commit revision. Only the snippet&#39;s \&quot;HEAD\&quot;/\&quot;tip\&quot; (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted &#x60;/snippets/encoded_id&#x60; could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \&quot;Compare And Swap\&quot;, or CAS operation.  Other than that, the two endpoints are identical in behavior.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return Snippet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to update the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet or the revision does not exist. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> If &#x60;{node_id}&#x60; is not the latest revision. </td><td>  -  </td></tr>
     </table>
     */
    public Snippet snippetsWorkspaceEncodedIdNodeIdPut(String encodedId, String nodeId, String workspace) throws ApiException {
        ApiResponse<Snippet> localVarResp = snippetsWorkspaceEncodedIdNodeIdPutWithHttpInfo(encodedId, nodeId, workspace);
        return localVarResp.getData();
    }

    /**
     * Update a previous revision of a snippet
     * Identical to &#x60;UPDATE /snippets/encoded_id&#x60;, except that this endpoint takes an explicit commit revision. Only the snippet&#39;s \&quot;HEAD\&quot;/\&quot;tip\&quot; (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted &#x60;/snippets/encoded_id&#x60; could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \&quot;Compare And Swap\&quot;, or CAS operation.  Other than that, the two endpoints are identical in behavior.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Snippet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to update the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet or the revision does not exist. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> If &#x60;{node_id}&#x60; is not the latest revision. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Snippet> snippetsWorkspaceEncodedIdNodeIdPutWithHttpInfo(String encodedId, String nodeId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdNodeIdPutValidateBeforeCall(encodedId, nodeId, workspace, null);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a previous revision of a snippet (asynchronously)
     * Identical to &#x60;UPDATE /snippets/encoded_id&#x60;, except that this endpoint takes an explicit commit revision. Only the snippet&#39;s \&quot;HEAD\&quot;/\&quot;tip\&quot; (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted &#x60;/snippets/encoded_id&#x60; could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \&quot;Compare And Swap\&quot;, or CAS operation.  Other than that, the two endpoints are identical in behavior.
     * @param encodedId The snippet id. (required)
     * @param nodeId A commit revision (SHA1). (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to update the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet or the revision does not exist. </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> If &#x60;{node_id}&#x60; is not the latest revision. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdNodeIdPutAsync(String encodedId, String nodeId, String workspace, final ApiCallback<Snippet> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdNodeIdPutValidateBeforeCall(encodedId, nodeId, workspace, _callback);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdPut
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to update the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdPutCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json",
            "multipart/form-data",
            "multipart/related"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdPutValidateBeforeCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdPut(Async)");
        }

        return snippetsWorkspaceEncodedIdPutCall(encodedId, workspace, _callback);

    }

    /**
     * Update a snippet
     * Used to update a snippet. Use this to add and delete files and to change a snippet&#39;s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use &#x60;null&#x60;).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * &#x60;application/json&#x60; * &#x60;multipart/related&#x60; * &#x60;multipart/form-data&#x60;  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the &#x60;Content-Type&#x60; and &#x60;Accept&#x60; headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. &#x60;application/json&#x60; does not support file contents and is therefore limited to a snippet&#39;s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: \&quot;Updated title\&quot;}&#39;   To delete the title:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: null}&#39;  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  &#x60;multipart/related&#x60; can be used to manipulate all of a snippet&#39;s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the &#x60;start&#x60; part contains JSON, the mechanism for manipulating the snippet&#39;s meta data is identical to &#x60;application/json&#x60; requests.  To update one of a snippet&#39;s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My updated snippet\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      Updated file contents.      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the &#x60;files&#x60; list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the &#x60;files&#x60; list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;files\&quot;: {         \&quot;image.png\&quot;: {}       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {         \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;bar.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;bar.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;bar.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--   multipart/form-data -----------------  Again, one can also use &#x60;multipart/form-data&#x60; to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title&#x3D;\&quot;My updated snippet\&quot; -F file&#x3D;@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the &#x60;files&#x60; field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files&#x3D;image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary&#x3D;----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name&#x3D;\&quot;files\&quot;      image.png     ------------------------------ef8871065a86--  The explicit use of the &#x60;files&#x60; element in &#x60;multipart/related&#x60; and &#x60;multipart/form-data&#x60; is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in &#x60;files&#x60;, as a convenience to the client.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return Snippet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to update the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public Snippet snippetsWorkspaceEncodedIdPut(String encodedId, String workspace) throws ApiException {
        ApiResponse<Snippet> localVarResp = snippetsWorkspaceEncodedIdPutWithHttpInfo(encodedId, workspace);
        return localVarResp.getData();
    }

    /**
     * Update a snippet
     * Used to update a snippet. Use this to add and delete files and to change a snippet&#39;s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use &#x60;null&#x60;).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * &#x60;application/json&#x60; * &#x60;multipart/related&#x60; * &#x60;multipart/form-data&#x60;  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the &#x60;Content-Type&#x60; and &#x60;Accept&#x60; headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. &#x60;application/json&#x60; does not support file contents and is therefore limited to a snippet&#39;s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: \&quot;Updated title\&quot;}&#39;   To delete the title:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: null}&#39;  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  &#x60;multipart/related&#x60; can be used to manipulate all of a snippet&#39;s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the &#x60;start&#x60; part contains JSON, the mechanism for manipulating the snippet&#39;s meta data is identical to &#x60;application/json&#x60; requests.  To update one of a snippet&#39;s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My updated snippet\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      Updated file contents.      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the &#x60;files&#x60; list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the &#x60;files&#x60; list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;files\&quot;: {         \&quot;image.png\&quot;: {}       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {         \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;bar.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;bar.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;bar.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--   multipart/form-data -----------------  Again, one can also use &#x60;multipart/form-data&#x60; to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title&#x3D;\&quot;My updated snippet\&quot; -F file&#x3D;@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the &#x60;files&#x60; field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files&#x3D;image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary&#x3D;----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name&#x3D;\&quot;files\&quot;      image.png     ------------------------------ef8871065a86--  The explicit use of the &#x60;files&#x60; element in &#x60;multipart/related&#x60; and &#x60;multipart/form-data&#x60; is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in &#x60;files&#x60;, as a convenience to the client.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Snippet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to update the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Snippet> snippetsWorkspaceEncodedIdPutWithHttpInfo(String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdPutValidateBeforeCall(encodedId, workspace, null);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a snippet (asynchronously)
     * Used to update a snippet. Use this to add and delete files and to change a snippet&#39;s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use &#x60;null&#x60;).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * &#x60;application/json&#x60; * &#x60;multipart/related&#x60; * &#x60;multipart/form-data&#x60;  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the &#x60;Content-Type&#x60; and &#x60;Accept&#x60; headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. &#x60;application/json&#x60; does not support file contents and is therefore limited to a snippet&#39;s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: \&quot;Updated title\&quot;}&#39;   To delete the title:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: null}&#39;  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  &#x60;multipart/related&#x60; can be used to manipulate all of a snippet&#39;s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the &#x60;start&#x60; part contains JSON, the mechanism for manipulating the snippet&#39;s meta data is identical to &#x60;application/json&#x60; requests.  To update one of a snippet&#39;s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My updated snippet\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      Updated file contents.      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the &#x60;files&#x60; list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the &#x60;files&#x60; list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;files\&quot;: {         \&quot;image.png\&quot;: {}       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {         \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;bar.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;bar.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;bar.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--   multipart/form-data -----------------  Again, one can also use &#x60;multipart/form-data&#x60; to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title&#x3D;\&quot;My updated snippet\&quot; -F file&#x3D;@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the &#x60;files&#x60; field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files&#x3D;image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary&#x3D;----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name&#x3D;\&quot;files\&quot;      image.png     ------------------------------ef8871065a86--  The explicit use of the &#x60;files&#x60; element in &#x60;multipart/related&#x60; and &#x60;multipart/form-data&#x60; is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in &#x60;files&#x60;, as a convenience to the client.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The updated snippet object. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the snippet is private and the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If authenticated user does not have permission to update the private snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdPutAsync(String encodedId, String workspace, final ApiCallback<Snippet> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdPutValidateBeforeCall(encodedId, workspace, _callback);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdRevisionDiffGet
     * @param encodedId The snippet id. (required)
     * @param revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param path When used, only one the diff of the specified file will be returned. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw diff contents. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdRevisionDiffGetCall(String encodedId, String revision, String workspace, String path, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/{revision}/diff"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "revision" + "}", localVarApiClient.escapeString(revision.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (path != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("path", path));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdRevisionDiffGetValidateBeforeCall(String encodedId, String revision, String workspace, String path, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdRevisionDiffGet(Async)");
        }

        // verify the required parameter 'revision' is set
        if (revision == null) {
            throw new ApiException("Missing the required parameter 'revision' when calling snippetsWorkspaceEncodedIdRevisionDiffGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdRevisionDiffGet(Async)");
        }

        return snippetsWorkspaceEncodedIdRevisionDiffGetCall(encodedId, revision, workspace, path, _callback);

    }

    /**
     * Get snippet changes between versions
     * Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;patch&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @param encodedId The snippet id. (required)
     * @param revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param path When used, only one the diff of the specified file will be returned. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw diff contents. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdRevisionDiffGet(String encodedId, String revision, String workspace, String path) throws ApiException {
        snippetsWorkspaceEncodedIdRevisionDiffGetWithHttpInfo(encodedId, revision, workspace, path);
    }

    /**
     * Get snippet changes between versions
     * Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;patch&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @param encodedId The snippet id. (required)
     * @param revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param path When used, only one the diff of the specified file will be returned. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw diff contents. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdRevisionDiffGetWithHttpInfo(String encodedId, String revision, String workspace, String path) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdRevisionDiffGetValidateBeforeCall(encodedId, revision, workspace, path, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Get snippet changes between versions (asynchronously)
     * Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;patch&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @param encodedId The snippet id. (required)
     * @param revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param path When used, only one the diff of the specified file will be returned. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw diff contents. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdRevisionDiffGetAsync(String encodedId, String revision, String workspace, String path, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdRevisionDiffGetValidateBeforeCall(encodedId, revision, workspace, path, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdRevisionPatchGet
     * @param encodedId The snippet id. (required)
     * @param revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw patch contents. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdRevisionPatchGetCall(String encodedId, String revision, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/{revision}/patch"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "revision" + "}", localVarApiClient.escapeString(revision.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdRevisionPatchGetValidateBeforeCall(String encodedId, String revision, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdRevisionPatchGet(Async)");
        }

        // verify the required parameter 'revision' is set
        if (revision == null) {
            throw new ApiException("Missing the required parameter 'revision' when calling snippetsWorkspaceEncodedIdRevisionPatchGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdRevisionPatchGet(Async)");
        }

        return snippetsWorkspaceEncodedIdRevisionPatchGetCall(encodedId, revision, workspace, _callback);

    }

    /**
     * Get snippet patch between versions
     * Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;diff&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @param encodedId The snippet id. (required)
     * @param revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw patch contents. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdRevisionPatchGet(String encodedId, String revision, String workspace) throws ApiException {
        snippetsWorkspaceEncodedIdRevisionPatchGetWithHttpInfo(encodedId, revision, workspace);
    }

    /**
     * Get snippet patch between versions
     * Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;diff&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @param encodedId The snippet id. (required)
     * @param revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw patch contents. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdRevisionPatchGetWithHttpInfo(String encodedId, String revision, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdRevisionPatchGetValidateBeforeCall(encodedId, revision, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Get snippet patch between versions (asynchronously)
     * Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;diff&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git does not track this, making it hard for Bitbucket to reliably determine this.
     * @param encodedId The snippet id. (required)
     * @param revision A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like &#x60;staging..production&#x60;. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw patch contents. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdRevisionPatchGetAsync(String encodedId, String revision, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdRevisionPatchGetValidateBeforeCall(encodedId, revision, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdWatchDelete
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the user stopped watching the snippet successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdWatchDeleteCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/watch"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdWatchDeleteValidateBeforeCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdWatchDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdWatchDelete(Async)");
        }

        return snippetsWorkspaceEncodedIdWatchDeleteCall(encodedId, workspace, _callback);

    }

    /**
     * Stop watching a snippet
     * Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the user stopped watching the snippet successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdWatchDelete(String encodedId, String workspace) throws ApiException {
        snippetsWorkspaceEncodedIdWatchDeleteWithHttpInfo(encodedId, workspace);
    }

    /**
     * Stop watching a snippet
     * Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the user stopped watching the snippet successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdWatchDeleteWithHttpInfo(String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdWatchDeleteValidateBeforeCall(encodedId, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Stop watching a snippet (asynchronously)
     * Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the user stopped watching the snippet successfully. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdWatchDeleteAsync(String encodedId, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdWatchDeleteValidateBeforeCall(encodedId, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdWatchGet
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the authenticated user is watching the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist, or if the authenticated user is not watching the snippet. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdWatchGetCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/watch"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdWatchGetValidateBeforeCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdWatchGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdWatchGet(Async)");
        }

        return snippetsWorkspaceEncodedIdWatchGetCall(encodedId, workspace, _callback);

    }

    /**
     * Check if the current user is watching a snippet
     * Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the authenticated user is watching the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist, or if the authenticated user is not watching the snippet. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdWatchGet(String encodedId, String workspace) throws ApiException {
        snippetsWorkspaceEncodedIdWatchGetWithHttpInfo(encodedId, workspace);
    }

    /**
     * Check if the current user is watching a snippet
     * Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the authenticated user is watching the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist, or if the authenticated user is not watching the snippet. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdWatchGetWithHttpInfo(String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdWatchGetValidateBeforeCall(encodedId, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Check if the current user is watching a snippet (asynchronously)
     * Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> If the authenticated user is watching the snippet. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist, or if the authenticated user is not watching the snippet. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdWatchGetAsync(String encodedId, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdWatchGetValidateBeforeCall(encodedId, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdWatchPut
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the authenticated user is now watching the snippet. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdWatchPutCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/watch"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdWatchPutValidateBeforeCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdWatchPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdWatchPut(Async)");
        }

        return snippetsWorkspaceEncodedIdWatchPutCall(encodedId, workspace, _callback);

    }

    /**
     * Watch a snippet
     * Used to start watching a specific snippet. Returns 204 (No Content).
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the authenticated user is now watching the snippet. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void snippetsWorkspaceEncodedIdWatchPut(String encodedId, String workspace) throws ApiException {
        snippetsWorkspaceEncodedIdWatchPutWithHttpInfo(encodedId, workspace);
    }

    /**
     * Watch a snippet
     * Used to start watching a specific snippet. Returns 204 (No Content).
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the authenticated user is now watching the snippet. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> snippetsWorkspaceEncodedIdWatchPutWithHttpInfo(String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdWatchPutValidateBeforeCall(encodedId, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Watch a snippet (asynchronously)
     * Used to start watching a specific snippet. Returns 204 (No Content).
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the authenticated user is now watching the snippet. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceEncodedIdWatchPutAsync(String encodedId, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdWatchPutValidateBeforeCall(encodedId, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceEncodedIdWatchersGet
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of users watching this snippet </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call snippetsWorkspaceEncodedIdWatchersGetCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}/{encoded_id}/watchers"
            .replace("{" + "encoded_id" + "}", localVarApiClient.escapeString(encodedId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceEncodedIdWatchersGetValidateBeforeCall(String encodedId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'encodedId' is set
        if (encodedId == null) {
            throw new ApiException("Missing the required parameter 'encodedId' when calling snippetsWorkspaceEncodedIdWatchersGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceEncodedIdWatchersGet(Async)");
        }

        return snippetsWorkspaceEncodedIdWatchersGetCall(encodedId, workspace, _callback);

    }

    /**
     * List users watching a snippet
     * Returns a paginated list of all users watching a specific snippet.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedAccounts
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of users watching this snippet </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public PaginatedAccounts snippetsWorkspaceEncodedIdWatchersGet(String encodedId, String workspace) throws ApiException {
        ApiResponse<PaginatedAccounts> localVarResp = snippetsWorkspaceEncodedIdWatchersGetWithHttpInfo(encodedId, workspace);
        return localVarResp.getData();
    }

    /**
     * List users watching a snippet
     * Returns a paginated list of all users watching a specific snippet.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedAccounts&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of users watching this snippet </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public ApiResponse<PaginatedAccounts> snippetsWorkspaceEncodedIdWatchersGetWithHttpInfo(String encodedId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdWatchersGetValidateBeforeCall(encodedId, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedAccounts>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List users watching a snippet (asynchronously)
     * Returns a paginated list of all users watching a specific snippet.
     * @param encodedId The snippet id. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of users watching this snippet </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the snippet does not exist. </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call snippetsWorkspaceEncodedIdWatchersGetAsync(String encodedId, String workspace, final ApiCallback<PaginatedAccounts> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceEncodedIdWatchersGetValidateBeforeCall(encodedId, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedAccounts>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspaceGet
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role Filter down the result based on the authenticated user&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippets. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the user does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceGetCall(String workspace, String role, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (role != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("role", role));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspaceGetValidateBeforeCall(String workspace, String role, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspaceGet(Async)");
        }

        return snippetsWorkspaceGetCall(workspace, role, _callback);

    }

    /**
     * List snippets in a workspace
     * Identical to [&#x60;/snippets&#x60;](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-get), except that the result is further filtered by the snippet owner and only those that are owned by &#x60;{workspace}&#x60; are returned.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role Filter down the result based on the authenticated user&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;). (optional)
     * @return PaginatedSnippets
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippets. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the user does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedSnippets snippetsWorkspaceGet(String workspace, String role) throws ApiException {
        ApiResponse<PaginatedSnippets> localVarResp = snippetsWorkspaceGetWithHttpInfo(workspace, role);
        return localVarResp.getData();
    }

    /**
     * List snippets in a workspace
     * Identical to [&#x60;/snippets&#x60;](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-get), except that the result is further filtered by the snippet owner and only those that are owned by &#x60;{workspace}&#x60; are returned.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role Filter down the result based on the authenticated user&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;). (optional)
     * @return ApiResponse&lt;PaginatedSnippets&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippets. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the user does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedSnippets> snippetsWorkspaceGetWithHttpInfo(String workspace, String role) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspaceGetValidateBeforeCall(workspace, role, null);
        Type localVarReturnType = new TypeToken<PaginatedSnippets>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List snippets in a workspace (asynchronously)
     * Identical to [&#x60;/snippets&#x60;](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-get), except that the result is further filtered by the snippet owner and only those that are owned by &#x60;{workspace}&#x60; are returned.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role Filter down the result based on the authenticated user&#39;s role (&#x60;owner&#x60;, &#x60;contributor&#x60;, or &#x60;member&#x60;). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of snippets. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the user does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspaceGetAsync(String workspace, String role, final ApiCallback<PaginatedSnippets> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspaceGetValidateBeforeCall(workspace, role, _callback);
        Type localVarReturnType = new TypeToken<PaginatedSnippets>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for snippetsWorkspacePost
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippet The new snippet object. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created snippet object. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to create snippets in the specified workspace. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspacePostCall(String workspace, Snippet snippet, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = snippet;

        // create path and map variables
        String localVarPath = "/snippets/{workspace}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call snippetsWorkspacePostValidateBeforeCall(String workspace, Snippet snippet, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling snippetsWorkspacePost(Async)");
        }

        // verify the required parameter 'snippet' is set
        if (snippet == null) {
            throw new ApiException("Missing the required parameter 'snippet' when calling snippetsWorkspacePost(Async)");
        }

        return snippetsWorkspacePostCall(workspace, snippet, _callback);

    }

    /**
     * Create a snippet for a workspace
     * Identical to [&#x60;/snippets&#x60;](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-post), except that the new snippet will be created under the workspace specified in the path parameter &#x60;{workspace}&#x60;.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippet The new snippet object. (required)
     * @return Snippet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created snippet object. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to create snippets in the specified workspace. </td><td>  -  </td></tr>
     </table>
     */
    public Snippet snippetsWorkspacePost(String workspace, Snippet snippet) throws ApiException {
        ApiResponse<Snippet> localVarResp = snippetsWorkspacePostWithHttpInfo(workspace, snippet);
        return localVarResp.getData();
    }

    /**
     * Create a snippet for a workspace
     * Identical to [&#x60;/snippets&#x60;](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-post), except that the new snippet will be created under the workspace specified in the path parameter &#x60;{workspace}&#x60;.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippet The new snippet object. (required)
     * @return ApiResponse&lt;Snippet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created snippet object. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to create snippets in the specified workspace. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Snippet> snippetsWorkspacePostWithHttpInfo(String workspace, Snippet snippet) throws ApiException {
        okhttp3.Call localVarCall = snippetsWorkspacePostValidateBeforeCall(workspace, snippet, null);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a snippet for a workspace (asynchronously)
     * Identical to [&#x60;/snippets&#x60;](/cloud/bitbucket/rest/api-group-snippets/#api-snippets-post), except that the new snippet will be created under the workspace specified in the path parameter &#x60;{workspace}&#x60;.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param snippet The new snippet object. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created snippet object. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to create snippets in the specified workspace. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call snippetsWorkspacePostAsync(String workspace, Snippet snippet, final ApiCallback<Snippet> _callback) throws ApiException {

        okhttp3.Call localVarCall = snippetsWorkspacePostValidateBeforeCall(workspace, snippet, _callback);
        Type localVarReturnType = new TypeToken<Snippet>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
