/*
 * Bitbucket API
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.Commit;
import org.openapitools.client.model.CommitComment;
import org.openapitools.client.model.Error;
import org.openapitools.client.model.PaginatedAnnotations;
import org.openapitools.client.model.PaginatedChangeset;
import org.openapitools.client.model.PaginatedCommitComments;
import org.openapitools.client.model.PaginatedDiffstats;
import org.openapitools.client.model.PaginatedReports;
import org.openapitools.client.model.Participant;
import org.openapitools.client.model.Report;
import org.openapitools.client.model.ReportAnnotation;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CommitsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public CommitsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public CommitsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for bulkCreateOrUpdateAnnotations_0
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param reportAnnotation The annotations to create or update (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call bulkCreateOrUpdateAnnotations_0Call(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = reportAnnotation;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call bulkCreateOrUpdateAnnotations_0ValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling bulkCreateOrUpdateAnnotations_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling bulkCreateOrUpdateAnnotations_0(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling bulkCreateOrUpdateAnnotations_0(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling bulkCreateOrUpdateAnnotations_0(Async)");
        }

        // verify the required parameter 'reportAnnotation' is set
        if (reportAnnotation == null) {
            throw new ApiException("Missing the required parameter 'reportAnnotation' when calling bulkCreateOrUpdateAnnotations_0(Async)");
        }

        return bulkCreateOrUpdateAnnotations_0Call(workspace, repoSlug, commit, reportId, reportAnnotation, _callback);

    }

    /**
     * Bulk create or update annotations
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --location &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001/annotations&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;[   {         \&quot;external_id\&quot;: \&quot;mysystem-annotation001\&quot;,         \&quot;title\&quot;: \&quot;Security scan report\&quot;,         \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,         \&quot;summary\&quot;: \&quot;This line represents a security threat.\&quot;,         \&quot;severity\&quot;: \&quot;HIGH\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,         \&quot;line\&quot;: 42   },   {         \&quot;external_id\&quot;: \&quot;mySystem-annotation002\&quot;,         \&quot;title\&quot;: \&quot;Bug report\&quot;,         \&quot;annotation_type\&quot;: \&quot;BUG\&quot;,         \&quot;result\&quot;: \&quot;FAILED\&quot;,         \&quot;summary\&quot;: \&quot;This line might introduce a bug.\&quot;,         \&quot;severity\&quot;: \&quot;MEDIUM\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\&quot;,         \&quot;line\&quot;: 13   } ]&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param reportAnnotation The annotations to create or update (required)
     * @return List&lt;ReportAnnotation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<ReportAnnotation> bulkCreateOrUpdateAnnotations_0(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation) throws ApiException {
        ApiResponse<List<ReportAnnotation>> localVarResp = bulkCreateOrUpdateAnnotations_0WithHttpInfo(workspace, repoSlug, commit, reportId, reportAnnotation);
        return localVarResp.getData();
    }

    /**
     * Bulk create or update annotations
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --location &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001/annotations&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;[   {         \&quot;external_id\&quot;: \&quot;mysystem-annotation001\&quot;,         \&quot;title\&quot;: \&quot;Security scan report\&quot;,         \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,         \&quot;summary\&quot;: \&quot;This line represents a security threat.\&quot;,         \&quot;severity\&quot;: \&quot;HIGH\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,         \&quot;line\&quot;: 42   },   {         \&quot;external_id\&quot;: \&quot;mySystem-annotation002\&quot;,         \&quot;title\&quot;: \&quot;Bug report\&quot;,         \&quot;annotation_type\&quot;: \&quot;BUG\&quot;,         \&quot;result\&quot;: \&quot;FAILED\&quot;,         \&quot;summary\&quot;: \&quot;This line might introduce a bug.\&quot;,         \&quot;severity\&quot;: \&quot;MEDIUM\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\&quot;,         \&quot;line\&quot;: 13   } ]&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param reportAnnotation The annotations to create or update (required)
     * @return ApiResponse&lt;List&lt;ReportAnnotation&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ReportAnnotation>> bulkCreateOrUpdateAnnotations_0WithHttpInfo(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation) throws ApiException {
        okhttp3.Call localVarCall = bulkCreateOrUpdateAnnotations_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, reportAnnotation, null);
        Type localVarReturnType = new TypeToken<List<ReportAnnotation>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Bulk create or update annotations (asynchronously)
     * Bulk upload of annotations. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Add the annotations you want to upload as objects in a JSON array and make sure each annotation has the external_id field set to a unique value. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001. The external id can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). You can upload up to 100 annotations per POST request.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --location &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001/annotations&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;[   {         \&quot;external_id\&quot;: \&quot;mysystem-annotation001\&quot;,         \&quot;title\&quot;: \&quot;Security scan report\&quot;,         \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,         \&quot;summary\&quot;: \&quot;This line represents a security threat.\&quot;,         \&quot;severity\&quot;: \&quot;HIGH\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,         \&quot;line\&quot;: 42   },   {         \&quot;external_id\&quot;: \&quot;mySystem-annotation002\&quot;,         \&quot;title\&quot;: \&quot;Bug report\&quot;,         \&quot;annotation_type\&quot;: \&quot;BUG\&quot;,         \&quot;result\&quot;: \&quot;FAILED\&quot;,         \&quot;summary\&quot;: \&quot;This line might introduce a bug.\&quot;,         \&quot;severity\&quot;: \&quot;MEDIUM\&quot;,       \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Helper.java\&quot;,         \&quot;line\&quot;: 13   } ]&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param reportAnnotation The annotations to create or update (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call bulkCreateOrUpdateAnnotations_0Async(String workspace, String repoSlug, String commit, String reportId, List<ReportAnnotation> reportAnnotation, final ApiCallback<List<ReportAnnotation>> _callback) throws ApiException {

        okhttp3.Call localVarCall = bulkCreateOrUpdateAnnotations_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, reportAnnotation, _callback);
        Type localVarReturnType = new TypeToken<List<ReportAnnotation>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createOrUpdateAnnotation_0
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param reportAnnotation The annotation to create or update (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Annotation object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrUpdateAnnotation_0Call(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = reportAnnotation;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()))
            .replace("{" + "annotationId" + "}", localVarApiClient.escapeString(annotationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createOrUpdateAnnotation_0ValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling createOrUpdateAnnotation_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling createOrUpdateAnnotation_0(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling createOrUpdateAnnotation_0(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling createOrUpdateAnnotation_0(Async)");
        }

        // verify the required parameter 'annotationId' is set
        if (annotationId == null) {
            throw new ApiException("Missing the required parameter 'annotationId' when calling createOrUpdateAnnotation_0(Async)");
        }

        // verify the required parameter 'reportAnnotation' is set
        if (reportAnnotation == null) {
            throw new ApiException("Missing the required parameter 'reportAnnotation' when calling createOrUpdateAnnotation_0(Async)");
        }

        return createOrUpdateAnnotation_0Call(workspace, repoSlug, commit, reportId, annotationId, reportAnnotation, _callback);

    }

    /**
     * Create or update an annotation
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mySystem-001/annotations/mysystem-annotation001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,     \&quot;summary\&quot;: \&quot;This line represents a security thread.\&quot;,     \&quot;severity\&quot;: \&quot;HIGH\&quot;,     \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,     \&quot;line\&quot;: 42 }&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param reportAnnotation The annotation to create or update (required)
     * @return ReportAnnotation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Annotation object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public ReportAnnotation createOrUpdateAnnotation_0(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation) throws ApiException {
        ApiResponse<ReportAnnotation> localVarResp = createOrUpdateAnnotation_0WithHttpInfo(workspace, repoSlug, commit, reportId, annotationId, reportAnnotation);
        return localVarResp.getData();
    }

    /**
     * Create or update an annotation
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mySystem-001/annotations/mysystem-annotation001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,     \&quot;summary\&quot;: \&quot;This line represents a security thread.\&quot;,     \&quot;severity\&quot;: \&quot;HIGH\&quot;,     \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,     \&quot;line\&quot;: 42 }&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param reportAnnotation The annotation to create or update (required)
     * @return ApiResponse&lt;ReportAnnotation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Annotation object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReportAnnotation> createOrUpdateAnnotation_0WithHttpInfo(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation) throws ApiException {
        okhttp3.Call localVarCall = createOrUpdateAnnotation_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, reportAnnotation, null);
        Type localVarReturnType = new TypeToken<ReportAnnotation>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create or update an annotation (asynchronously)
     * Creates or updates an individual annotation for the specified report. Annotations are individual findings that have been identified as part of a report, for example, a line of code that represents a vulnerability. These annotations can be attached to a specific file and even a specific line in that file, however, that is optional. Annotations are not mandatory and a report can contain up to 1000 annotations.  Just as reports, annotation needs to be uploaded with a unique ID that can later be used to identify the report as an alternative to the generated [UUID](https://developer.atlassian.com/bitbucket/api/2/reference/meta/uri-uuid#uuid). If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-annotation001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mySystem-001/annotations/mysystem-annotation001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;annotation_type\&quot;: \&quot;VULNERABILITY\&quot;,     \&quot;summary\&quot;: \&quot;This line represents a security thread.\&quot;,     \&quot;severity\&quot;: \&quot;HIGH\&quot;,     \&quot;path\&quot;: \&quot;my-service/src/main/java/com/myCompany/mysystem/logic/Main.java\&quot;,     \&quot;line\&quot;: 42 }&#39; &#x60;&#x60;&#x60;  ### Possible field values: annotation_type: VULNERABILITY, CODE_SMELL, BUG result: PASSED, FAILED, IGNORED, SKIPPED severity: HIGH, MEDIUM, LOW, CRITICAL  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param reportAnnotation The annotation to create or update (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Annotation object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrUpdateAnnotation_0Async(String workspace, String repoSlug, String commit, String reportId, String annotationId, ReportAnnotation reportAnnotation, final ApiCallback<ReportAnnotation> _callback) throws ApiException {

        okhttp3.Call localVarCall = createOrUpdateAnnotation_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, reportAnnotation, _callback);
        Type localVarReturnType = new TypeToken<ReportAnnotation>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createOrUpdateReport_0
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param report The report to create or update (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Report object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrUpdateReport_0Call(String workspace, String repoSlug, String commit, String reportId, Report report, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = report;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createOrUpdateReport_0ValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, Report report, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling createOrUpdateReport_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling createOrUpdateReport_0(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling createOrUpdateReport_0(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling createOrUpdateReport_0(Async)");
        }

        // verify the required parameter 'report' is set
        if (report == null) {
            throw new ApiException("Missing the required parameter 'report' when calling createOrUpdateReport_0(Async)");
        }

        return createOrUpdateReport_0Call(workspace, repoSlug, commit, reportId, report, _callback);

    }

    /**
     * Create or update a report
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;details\&quot;: \&quot;This pull request introduces 10 new dependency vulnerabilities.\&quot;,     \&quot;report_type\&quot;: \&quot;SECURITY\&quot;,     \&quot;reporter\&quot;: \&quot;mySystem\&quot;,     \&quot;link\&quot;: \&quot;http://www.mysystem.com/reports/001\&quot;,     \&quot;result\&quot;: \&quot;FAILED\&quot;,     \&quot;data\&quot;: [         {             \&quot;title\&quot;: \&quot;Duration (seconds)\&quot;,             \&quot;type\&quot;: \&quot;DURATION\&quot;,             \&quot;value\&quot;: 14         },         {             \&quot;title\&quot;: \&quot;Safe to merge?\&quot;,             \&quot;type\&quot;: \&quot;BOOLEAN\&quot;,             \&quot;value\&quot;: false         }     ] }&#39; &#x60;&#x60;&#x60;  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as &#39;Yes&#39; or &#39;No&#39;. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: &#x60;{\&quot;text\&quot;: \&quot;Link text here\&quot;, \&quot;href\&quot;: \&quot;https://link.to.annotation/in/external/tool\&quot;}&#x60; | The value will be read as a JSON object containing the fields \&quot;text\&quot; and \&quot;href\&quot; and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param report The report to create or update (required)
     * @return Report
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Report object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public Report createOrUpdateReport_0(String workspace, String repoSlug, String commit, String reportId, Report report) throws ApiException {
        ApiResponse<Report> localVarResp = createOrUpdateReport_0WithHttpInfo(workspace, repoSlug, commit, reportId, report);
        return localVarResp.getData();
    }

    /**
     * Create or update a report
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;details\&quot;: \&quot;This pull request introduces 10 new dependency vulnerabilities.\&quot;,     \&quot;report_type\&quot;: \&quot;SECURITY\&quot;,     \&quot;reporter\&quot;: \&quot;mySystem\&quot;,     \&quot;link\&quot;: \&quot;http://www.mysystem.com/reports/001\&quot;,     \&quot;result\&quot;: \&quot;FAILED\&quot;,     \&quot;data\&quot;: [         {             \&quot;title\&quot;: \&quot;Duration (seconds)\&quot;,             \&quot;type\&quot;: \&quot;DURATION\&quot;,             \&quot;value\&quot;: 14         },         {             \&quot;title\&quot;: \&quot;Safe to merge?\&quot;,             \&quot;type\&quot;: \&quot;BOOLEAN\&quot;,             \&quot;value\&quot;: false         }     ] }&#39; &#x60;&#x60;&#x60;  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as &#39;Yes&#39; or &#39;No&#39;. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: &#x60;{\&quot;text\&quot;: \&quot;Link text here\&quot;, \&quot;href\&quot;: \&quot;https://link.to.annotation/in/external/tool\&quot;}&#x60; | The value will be read as a JSON object containing the fields \&quot;text\&quot; and \&quot;href\&quot; and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param report The report to create or update (required)
     * @return ApiResponse&lt;Report&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Report object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Report> createOrUpdateReport_0WithHttpInfo(String workspace, String repoSlug, String commit, String reportId, Report report) throws ApiException {
        okhttp3.Call localVarCall = createOrUpdateReport_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, report, null);
        Type localVarReturnType = new TypeToken<Report>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create or update a report (asynchronously)
     * Creates or updates a report for the specified commit. To upload a report, make sure to generate an ID that is unique across all reports for that commit. If you want to use an existing id from your own system, we recommend prefixing it with your system&#39;s name to avoid collisions, for example, mySystem-001.  ### Sample cURL request: &#x60;&#x60;&#x60; curl --request PUT &#39;https://api.bitbucket.org/2.0/repositories/&lt;username&gt;/&lt;reposity-name&gt;/commit/&lt;commit-hash&gt;/reports/mysystem-001&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data-raw &#39;{     \&quot;title\&quot;: \&quot;Security scan report\&quot;,     \&quot;details\&quot;: \&quot;This pull request introduces 10 new dependency vulnerabilities.\&quot;,     \&quot;report_type\&quot;: \&quot;SECURITY\&quot;,     \&quot;reporter\&quot;: \&quot;mySystem\&quot;,     \&quot;link\&quot;: \&quot;http://www.mysystem.com/reports/001\&quot;,     \&quot;result\&quot;: \&quot;FAILED\&quot;,     \&quot;data\&quot;: [         {             \&quot;title\&quot;: \&quot;Duration (seconds)\&quot;,             \&quot;type\&quot;: \&quot;DURATION\&quot;,             \&quot;value\&quot;: 14         },         {             \&quot;title\&quot;: \&quot;Safe to merge?\&quot;,             \&quot;type\&quot;: \&quot;BOOLEAN\&quot;,             \&quot;value\&quot;: false         }     ] }&#39; &#x60;&#x60;&#x60;  ### Possible field values: report_type: SECURITY, COVERAGE, TEST, BUG result: PASSED, FAILED, PENDING data.type: BOOLEAN, DATE, DURATION, LINK, NUMBER, PERCENTAGE, TEXT  #### Data field formats | Type  Field   | Value Field Type  | Value Field Display | |:--------------|:------------------|:--------------------| | None/ Omitted | Number, String or Boolean (not an array or object) | Plain text | | BOOLEAN | Boolean | The value will be read as a JSON boolean and displayed as &#39;Yes&#39; or &#39;No&#39;. | | DATE  | Number | The value will be read as a JSON number in the form of a Unix timestamp (milliseconds) and will be displayed as a relative date if the date is less than one week ago, otherwise  it will be displayed as an absolute date. | | DURATION | Number | The value will be read as a JSON number in milliseconds and will be displayed in a human readable duration format. | | LINK | Object: &#x60;{\&quot;text\&quot;: \&quot;Link text here\&quot;, \&quot;href\&quot;: \&quot;https://link.to.annotation/in/external/tool\&quot;}&#x60; | The value will be read as a JSON object containing the fields \&quot;text\&quot; and \&quot;href\&quot; and will be displayed as a clickable link on the report. | | NUMBER | Number | The value will be read as a JSON number and large numbers will be  displayed in a human readable format (e.g. 14.3k). | | PERCENTAGE | Number (between 0 and 100) | The value will be read as a JSON number between 0 and 100 and will be displayed with a percentage sign. | | TEXT | String | The value will be read as a JSON string and will be displayed as-is |  Please refer to the [Code Insights documentation](https://confluence.atlassian.com/bitbucket/code-insights-994316785.html) for more information. 
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param report The report to create or update (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> The provided Report object is malformed or incomplete. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createOrUpdateReport_0Async(String workspace, String repoSlug, String commit, String reportId, Report report, final ApiCallback<Report> _callback) throws ApiException {

        okhttp3.Call localVarCall = createOrUpdateReport_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, report, _callback);
        Type localVarReturnType = new TypeToken<Report>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteAnnotation_0
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the annotation belongs to. (required)
     * @param reportId Either the uuid or external-id of the annotation. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteAnnotation_0Call(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()))
            .replace("{" + "annotationId" + "}", localVarApiClient.escapeString(annotationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteAnnotation_0ValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling deleteAnnotation_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling deleteAnnotation_0(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling deleteAnnotation_0(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling deleteAnnotation_0(Async)");
        }

        // verify the required parameter 'annotationId' is set
        if (annotationId == null) {
            throw new ApiException("Missing the required parameter 'annotationId' when calling deleteAnnotation_0(Async)");
        }

        return deleteAnnotation_0Call(workspace, repoSlug, commit, reportId, annotationId, _callback);

    }

    /**
     * Delete an annotation
     * Deletes a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the annotation belongs to. (required)
     * @param reportId Either the uuid or external-id of the annotation. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public void deleteAnnotation_0(String workspace, String repoSlug, String commit, String reportId, String annotationId) throws ApiException {
        deleteAnnotation_0WithHttpInfo(workspace, repoSlug, commit, reportId, annotationId);
    }

    /**
     * Delete an annotation
     * Deletes a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the annotation belongs to. (required)
     * @param reportId Either the uuid or external-id of the annotation. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteAnnotation_0WithHttpInfo(String workspace, String repoSlug, String commit, String reportId, String annotationId) throws ApiException {
        okhttp3.Call localVarCall = deleteAnnotation_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete an annotation (asynchronously)
     * Deletes a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the annotation belongs to. (required)
     * @param reportId Either the uuid or external-id of the annotation. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteAnnotation_0Async(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteAnnotation_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteReport_0
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteReport_0Call(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteReport_0ValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling deleteReport_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling deleteReport_0(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling deleteReport_0(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling deleteReport_0(Async)");
        }

        return deleteReport_0Call(workspace, repoSlug, commit, reportId, _callback);

    }

    /**
     * Delete a report
     * Deletes a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public void deleteReport_0(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        deleteReport_0WithHttpInfo(workspace, repoSlug, commit, reportId);
    }

    /**
     * Delete a report
     * Deletes a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteReport_0WithHttpInfo(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        okhttp3.Call localVarCall = deleteReport_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a report (asynchronously)
     * Deletes a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteReport_0Async(String workspace, String repoSlug, String commit, String reportId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteReport_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAnnotation_0
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The annotation with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnnotation_0Call(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations/{annotationId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()))
            .replace("{" + "annotationId" + "}", localVarApiClient.escapeString(annotationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAnnotation_0ValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling getAnnotation_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling getAnnotation_0(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling getAnnotation_0(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling getAnnotation_0(Async)");
        }

        // verify the required parameter 'annotationId' is set
        if (annotationId == null) {
            throw new ApiException("Missing the required parameter 'annotationId' when calling getAnnotation_0(Async)");
        }

        return getAnnotation_0Call(workspace, repoSlug, commit, reportId, annotationId, _callback);

    }

    /**
     * Get an annotation
     * Returns a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @return ReportAnnotation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The annotation with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public ReportAnnotation getAnnotation_0(String workspace, String repoSlug, String commit, String reportId, String annotationId) throws ApiException {
        ApiResponse<ReportAnnotation> localVarResp = getAnnotation_0WithHttpInfo(workspace, repoSlug, commit, reportId, annotationId);
        return localVarResp.getData();
    }

    /**
     * Get an annotation
     * Returns a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @return ApiResponse&lt;ReportAnnotation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The annotation with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ReportAnnotation> getAnnotation_0WithHttpInfo(String workspace, String repoSlug, String commit, String reportId, String annotationId) throws ApiException {
        okhttp3.Call localVarCall = getAnnotation_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, null);
        Type localVarReturnType = new TypeToken<ReportAnnotation>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get an annotation (asynchronously)
     * Returns a single Annotation matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param annotationId Either the uuid or external-id of the annotation. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The annotation with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnnotation_0Async(String workspace, String repoSlug, String commit, String reportId, String annotationId, final ApiCallback<ReportAnnotation> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAnnotation_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, annotationId, _callback);
        Type localVarReturnType = new TypeToken<ReportAnnotation>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getAnnotationsForReport_0
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnnotationsForReport_0Call(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}/annotations"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAnnotationsForReport_0ValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling getAnnotationsForReport_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling getAnnotationsForReport_0(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling getAnnotationsForReport_0(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling getAnnotationsForReport_0(Async)");
        }

        return getAnnotationsForReport_0Call(workspace, repoSlug, commit, reportId, _callback);

    }

    /**
     * List annotations
     * Returns a paginated list of Annotations for a specified report.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @return PaginatedAnnotations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedAnnotations getAnnotationsForReport_0(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        ApiResponse<PaginatedAnnotations> localVarResp = getAnnotationsForReport_0WithHttpInfo(workspace, repoSlug, commit, reportId);
        return localVarResp.getData();
    }

    /**
     * List annotations
     * Returns a paginated list of Annotations for a specified report.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @return ApiResponse&lt;PaginatedAnnotations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedAnnotations> getAnnotationsForReport_0WithHttpInfo(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        okhttp3.Call localVarCall = getAnnotationsForReport_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, null);
        Type localVarReturnType = new TypeToken<PaginatedAnnotations>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List annotations (asynchronously)
     * Returns a paginated list of Annotations for a specified report.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param reportId Uuid or external-if of the report for which to get annotations for. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getAnnotationsForReport_0Async(String workspace, String repoSlug, String commit, String reportId, final ApiCallback<PaginatedAnnotations> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAnnotationsForReport_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, _callback);
        Type localVarReturnType = new TypeToken<PaginatedAnnotations>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getReport_0
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The report with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReport_0Call(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports/{reportId}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "reportId" + "}", localVarApiClient.escapeString(reportId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReport_0ValidateBeforeCall(String workspace, String repoSlug, String commit, String reportId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling getReport_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling getReport_0(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling getReport_0(Async)");
        }

        // verify the required parameter 'reportId' is set
        if (reportId == null) {
            throw new ApiException("Missing the required parameter 'reportId' when calling getReport_0(Async)");
        }

        return getReport_0Call(workspace, repoSlug, commit, reportId, _callback);

    }

    /**
     * Get a report
     * Returns a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @return Report
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The report with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public Report getReport_0(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        ApiResponse<Report> localVarResp = getReport_0WithHttpInfo(workspace, repoSlug, commit, reportId);
        return localVarResp.getData();
    }

    /**
     * Get a report
     * Returns a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @return ApiResponse&lt;Report&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The report with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Report> getReport_0WithHttpInfo(String workspace, String repoSlug, String commit, String reportId) throws ApiException {
        okhttp3.Call localVarCall = getReport_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, null);
        Type localVarReturnType = new TypeToken<Report>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a report (asynchronously)
     * Returns a single Report matching the provided ID.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit the report belongs to. (required)
     * @param reportId Either the uuid or external-id of the report. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The report with the given ID was not found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReport_0Async(String workspace, String repoSlug, String commit, String reportId, final ApiCallback<Report> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReport_0ValidateBeforeCall(workspace, repoSlug, commit, reportId, _callback);
        Type localVarReturnType = new TypeToken<Report>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getReportsForCommit_0
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReportsForCommit_0Call(String workspace, String repoSlug, String commit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/reports"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReportsForCommit_0ValidateBeforeCall(String workspace, String repoSlug, String commit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling getReportsForCommit_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling getReportsForCommit_0(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling getReportsForCommit_0(Async)");
        }

        return getReportsForCommit_0Call(workspace, repoSlug, commit, _callback);

    }

    /**
     * List reports
     * Returns a paginated list of Reports linked to this commit.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @return PaginatedReports
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedReports getReportsForCommit_0(String workspace, String repoSlug, String commit) throws ApiException {
        ApiResponse<PaginatedReports> localVarResp = getReportsForCommit_0WithHttpInfo(workspace, repoSlug, commit);
        return localVarResp.getData();
    }

    /**
     * List reports
     * Returns a paginated list of Reports linked to this commit.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @return ApiResponse&lt;PaginatedReports&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedReports> getReportsForCommit_0WithHttpInfo(String workspace, String repoSlug, String commit) throws ApiException {
        okhttp3.Call localVarCall = getReportsForCommit_0ValidateBeforeCall(workspace, repoSlug, commit, null);
        Type localVarReturnType = new TypeToken<PaginatedReports>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List reports (asynchronously)
     * Returns a paginated list of Reports linked to this commit.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example &#x60;{workspace UUID}&#x60;. (required)
     * @param repoSlug The repository. (required)
     * @param commit The commit for which to retrieve reports. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getReportsForCommit_0Async(String workspace, String repoSlug, String commit, final ApiCallback<PaginatedReports> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReportsForCommit_0ValidateBeforeCall(workspace, repoSlug, commit, _callback);
        Type localVarReturnType = new TypeToken<PaginatedReports>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitCommitApproveDelete
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> An empty response indicating the authenticated user&#39;s approval has been withdrawn. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit, or the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitApproveDeleteCall(String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/approve"
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitApproveDeleteValidateBeforeCall(String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitCommitApproveDeleteCall(commit, repoSlug, workspace, _callback);

    }

    /**
     * Unapprove a commit
     * Redact the authenticated user&#39;s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> An empty response indicating the authenticated user&#39;s approval has been withdrawn. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit, or the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugCommitCommitApproveDelete(String commit, String repoSlug, String workspace) throws ApiException {
        repositoriesWorkspaceRepoSlugCommitCommitApproveDeleteWithHttpInfo(commit, repoSlug, workspace);
    }

    /**
     * Unapprove a commit
     * Redact the authenticated user&#39;s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> An empty response indicating the authenticated user&#39;s approval has been withdrawn. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit, or the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugCommitCommitApproveDeleteWithHttpInfo(String commit, String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitApproveDeleteValidateBeforeCall(commit, repoSlug, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Unapprove a commit (asynchronously)
     * Redact the authenticated user&#39;s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> An empty response indicating the authenticated user&#39;s approval has been withdrawn. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit, or the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitApproveDeleteAsync(String commit, String repoSlug, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitApproveDeleteValidateBeforeCall(commit, repoSlug, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitCommitApprovePost
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The &#x60;participant&#x60; object recording that the authenticated user approved the commit. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit, or the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitApprovePostCall(String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/approve"
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitApprovePostValidateBeforeCall(String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugCommitCommitApprovePost(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitCommitApprovePost(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitCommitApprovePost(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitCommitApprovePostCall(commit, repoSlug, workspace, _callback);

    }

    /**
     * Approve a commit
     * Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return Participant
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The &#x60;participant&#x60; object recording that the authenticated user approved the commit. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit, or the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public Participant repositoriesWorkspaceRepoSlugCommitCommitApprovePost(String commit, String repoSlug, String workspace) throws ApiException {
        ApiResponse<Participant> localVarResp = repositoriesWorkspaceRepoSlugCommitCommitApprovePostWithHttpInfo(commit, repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * Approve a commit
     * Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Participant&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The &#x60;participant&#x60; object recording that the authenticated user approved the commit. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit, or the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Participant> repositoriesWorkspaceRepoSlugCommitCommitApprovePostWithHttpInfo(String commit, String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitApprovePostValidateBeforeCall(commit, repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<Participant>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Approve a commit (asynchronously)
     * Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The &#x60;participant&#x60; object recording that the authenticated user approved the commit. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit, or the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitApprovePostAsync(String commit, String repoSlug, String workspace, final ApiCallback<Participant> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitApprovePostValidateBeforeCall(commit, repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<Participant>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the comment was deleted by this action or a previous delete. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment doesn&#39;t exist </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteCall(Integer commentId, String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}"
            .replace("{" + "comment_id" + "}", localVarApiClient.escapeString(commentId.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteValidateBeforeCall(Integer commentId, String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commentId' is set
        if (commentId == null) {
            throw new ApiException("Missing the required parameter 'commentId' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteCall(commentId, commit, repoSlug, workspace, _callback);

    }

    /**
     * Delete a commit comment
     * Deletes the specified commit comment.  Note that deleting comments that have visible replies that point to them will not really delete the resource. This is to retain the integrity of the original comment tree. Instead, the &#x60;deleted&#x60; element is set to &#x60;true&#x60; and the content is blanked out. The comment will continue to be returned by the collections and self endpoints.
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the comment was deleted by this action or a previous delete. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment doesn&#39;t exist </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDelete(Integer commentId, String commit, String repoSlug, String workspace) throws ApiException {
        repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteWithHttpInfo(commentId, commit, repoSlug, workspace);
    }

    /**
     * Delete a commit comment
     * Deletes the specified commit comment.  Note that deleting comments that have visible replies that point to them will not really delete the resource. This is to retain the integrity of the original comment tree. Instead, the &#x60;deleted&#x60; element is set to &#x60;true&#x60; and the content is blanked out. The comment will continue to be returned by the collections and self endpoints.
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the comment was deleted by this action or a previous delete. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment doesn&#39;t exist </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteWithHttpInfo(Integer commentId, String commit, String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteValidateBeforeCall(commentId, commit, repoSlug, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a commit comment (asynchronously)
     * Deletes the specified commit comment.  Note that deleting comments that have visible replies that point to them will not really delete the resource. This is to retain the integrity of the original comment tree. Instead, the &#x60;deleted&#x60; element is set to &#x60;true&#x60; and the content is blanked out. The comment will continue to be returned by the collections and self endpoints.
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates the comment was deleted by this action or a previous delete. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the comment doesn&#39;t exist </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteAsync(Integer commentId, String commit, String repoSlug, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdDeleteValidateBeforeCall(commentId, commit, repoSlug, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The commit comment. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetCall(Integer commentId, String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}"
            .replace("{" + "comment_id" + "}", localVarApiClient.escapeString(commentId.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetValidateBeforeCall(Integer commentId, String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commentId' is set
        if (commentId == null) {
            throw new ApiException("Missing the required parameter 'commentId' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetCall(commentId, commit, repoSlug, workspace, _callback);

    }

    /**
     * Get a commit comment
     * Returns the specified commit comment.
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return CommitComment
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The commit comment. </td><td>  -  </td></tr>
     </table>
     */
    public CommitComment repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGet(Integer commentId, String commit, String repoSlug, String workspace) throws ApiException {
        ApiResponse<CommitComment> localVarResp = repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetWithHttpInfo(commentId, commit, repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * Get a commit comment
     * Returns the specified commit comment.
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;CommitComment&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The commit comment. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CommitComment> repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetWithHttpInfo(Integer commentId, String commit, String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetValidateBeforeCall(commentId, commit, repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<CommitComment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a commit comment (asynchronously)
     * Returns the specified commit comment.
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The commit comment. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetAsync(Integer commentId, String commit, String repoSlug, String workspace, final ApiCallback<CommitComment> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdGetValidateBeforeCall(commentId, commit, repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<CommitComment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param commitComment The updated comment. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly updated comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the comment update was detected as spam </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutCall(Integer commentId, String commit, String repoSlug, String workspace, CommitComment commitComment, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = commitComment;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/comments/{comment_id}"
            .replace("{" + "comment_id" + "}", localVarApiClient.escapeString(commentId.toString()))
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutValidateBeforeCall(Integer commentId, String commit, String repoSlug, String workspace, CommitComment commitComment, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commentId' is set
        if (commentId == null) {
            throw new ApiException("Missing the required parameter 'commentId' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(Async)");
        }

        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(Async)");
        }

        // verify the required parameter 'commitComment' is set
        if (commitComment == null) {
            throw new ApiException("Missing the required parameter 'commitComment' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutCall(commentId, commit, repoSlug, workspace, commitComment, _callback);

    }

    /**
     * Update a commit comment
     * Used to update the contents of a comment. Only the content of the comment can be updated.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \\   -X PUT -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;One more thing!\&quot;}&#39; &#x60;&#x60;&#x60;
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param commitComment The updated comment. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly updated comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the comment update was detected as spam </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPut(Integer commentId, String commit, String repoSlug, String workspace, CommitComment commitComment) throws ApiException {
        repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutWithHttpInfo(commentId, commit, repoSlug, workspace, commitComment);
    }

    /**
     * Update a commit comment
     * Used to update the contents of a comment. Only the content of the comment can be updated.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \\   -X PUT -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;One more thing!\&quot;}&#39; &#x60;&#x60;&#x60;
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param commitComment The updated comment. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly updated comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the comment update was detected as spam </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutWithHttpInfo(Integer commentId, String commit, String repoSlug, String workspace, CommitComment commitComment) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutValidateBeforeCall(commentId, commit, repoSlug, workspace, commitComment, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update a commit comment (asynchronously)
     * Used to update the contents of a comment. Only the content of the comment can be updated.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/7f71b5/comments/5728901 \\   -X PUT -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;One more thing!\&quot;}&#39; &#x60;&#x60;&#x60;
     * @param commentId The id of the comment. (required)
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param commitComment The updated comment. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly updated comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the comment update was detected as spam </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutAsync(Integer commentId, String commit, String repoSlug, String workspace, CommitComment commitComment, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsCommentIdPutValidateBeforeCall(commentId, commit, repoSlug, workspace, commitComment, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitCommitCommentsGet
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commit comments. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsGetCall(String commit, String repoSlug, String workspace, String q, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/comments"
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsGetValidateBeforeCall(String commit, String repoSlug, String workspace, String q, String sort, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitCommitCommentsGetCall(commit, repoSlug, workspace, q, sort, _callback);

    }

    /**
     * List a commit&#39;s comments
     * Returns the commit&#39;s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @return PaginatedCommitComments
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commit comments. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedCommitComments repositoriesWorkspaceRepoSlugCommitCommitCommentsGet(String commit, String repoSlug, String workspace, String q, String sort) throws ApiException {
        ApiResponse<PaginatedCommitComments> localVarResp = repositoriesWorkspaceRepoSlugCommitCommitCommentsGetWithHttpInfo(commit, repoSlug, workspace, q, sort);
        return localVarResp.getData();
    }

    /**
     * List a commit&#39;s comments
     * Returns the commit&#39;s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @return ApiResponse&lt;PaginatedCommitComments&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commit comments. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedCommitComments> repositoriesWorkspaceRepoSlugCommitCommitCommentsGetWithHttpInfo(String commit, String repoSlug, String workspace, String q, String sort) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsGetValidateBeforeCall(commit, repoSlug, workspace, q, sort, null);
        Type localVarReturnType = new TypeToken<PaginatedCommitComments>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List a commit&#39;s comments (asynchronously)
     * Returns the commit&#39;s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commit comments. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsGetAsync(String commit, String repoSlug, String workspace, String q, String sort, final ApiCallback<PaginatedCommitComments> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsGetValidateBeforeCall(commit, repoSlug, workspace, q, sort, _callback);
        Type localVarReturnType = new TypeToken<PaginatedCommitComments>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitCommitCommentsPost
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param commitComment The specified comment. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the comment was detected as spam, or if the parent comment is not attached to the same node as the new comment </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If a parent ID was passed in that cannot be found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsPostCall(String commit, String repoSlug, String workspace, CommitComment commitComment, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = commitComment;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}/comments"
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsPostValidateBeforeCall(String commit, String repoSlug, String workspace, CommitComment commitComment, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(Async)");
        }

        // verify the required parameter 'commitComment' is set
        if (commitComment == null) {
            throw new ApiException("Missing the required parameter 'commitComment' when calling repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitCommitCommentsPostCall(commit, repoSlug, workspace, commitComment, _callback);

    }

    /**
     * Create comment for a commit
     * Creates new comment on the specified commit.  To post a reply to an existing comment, include the &#x60;parent.id&#x60; field:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;One more thing!\&quot;},        \&quot;parent\&quot;: {\&quot;id\&quot;: 5728901}}&#39; &#x60;&#x60;&#x60;
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param commitComment The specified comment. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the comment was detected as spam, or if the parent comment is not attached to the same node as the new comment </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If a parent ID was passed in that cannot be found </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugCommitCommitCommentsPost(String commit, String repoSlug, String workspace, CommitComment commitComment) throws ApiException {
        repositoriesWorkspaceRepoSlugCommitCommitCommentsPostWithHttpInfo(commit, repoSlug, workspace, commitComment);
    }

    /**
     * Create comment for a commit
     * Creates new comment on the specified commit.  To post a reply to an existing comment, include the &#x60;parent.id&#x60; field:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;One more thing!\&quot;},        \&quot;parent\&quot;: {\&quot;id\&quot;: 5728901}}&#39; &#x60;&#x60;&#x60;
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param commitComment The specified comment. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the comment was detected as spam, or if the parent comment is not attached to the same node as the new comment </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If a parent ID was passed in that cannot be found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugCommitCommitCommentsPostWithHttpInfo(String commit, String repoSlug, String workspace, CommitComment commitComment) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsPostValidateBeforeCall(commit, repoSlug, workspace, commitComment, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Create comment for a commit (asynchronously)
     * Creates new comment on the specified commit.  To post a reply to an existing comment, include the &#x60;parent.id&#x60; field:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;One more thing!\&quot;},        \&quot;parent\&quot;: {\&quot;id\&quot;: 5728901}}&#39; &#x60;&#x60;&#x60;
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param commitComment The specified comment. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created comment. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the comment was detected as spam, or if the parent comment is not attached to the same node as the new comment </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If a parent ID was passed in that cannot be found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitCommentsPostAsync(String commit, String repoSlug, String workspace, CommitComment commitComment, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitCommentsPostValidateBeforeCall(commit, repoSlug, workspace, commitComment, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitCommitGet
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The commit object </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitGetCall(String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commit/{commit}"
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitGetValidateBeforeCall(String commit, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugCommitCommitGet(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitCommitGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitCommitGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitCommitGetCall(commit, repoSlug, workspace, _callback);

    }

    /**
     * Get a commit
     * Returns the specified commit.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a1 {     \&quot;rendered\&quot;: {         \&quot;message\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;         }     },     \&quot;hash\&quot;: \&quot;f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;,     \&quot;repository\&quot;: {         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;links\&quot;: {             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi\&quot;             },             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B85d08b4e-571d-44e9-a507-fa476535aa98%7D?ts&#x3D;1730260\&quot;             }         },         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;comments\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/comments\&quot;         },         \&quot;patch\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/patch/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;diff\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diff/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;approve\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/approve\&quot;         },         \&quot;statuses\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/statuses\&quot;         }     },     \&quot;author\&quot;: {         \&quot;raw\&quot;: \&quot;Brodie Rao &lt;a@b.c&gt;\&quot;,         \&quot;type\&quot;: \&quot;author\&quot;,         \&quot;user\&quot;: {             \&quot;display_name\&quot;: \&quot;Brodie Rao\&quot;,             \&quot;uuid\&quot;: \&quot;{9484702e-c663-4afd-aefb-c93a8cd31c28}\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D/\&quot;                 },                 \&quot;avatar\&quot;: {                     \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca/613070db-28b0-421f-8dba-ae8a87e2a5c7/128\&quot;                 }             },             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;nickname\&quot;: \&quot;brodie\&quot;,             \&quot;account_id\&quot;: \&quot;557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca\&quot;         }     },     \&quot;summary\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;     },     \&quot;participants\&quot;: [],     \&quot;parents\&quot;: [         {             \&quot;type\&quot;: \&quot;commit\&quot;,             \&quot;hash\&quot;: \&quot;f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 }             }         }     ],     \&quot;date\&quot;: \&quot;2012-07-16T19:37:54+00:00\&quot;,     \&quot;message\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,     \&quot;type\&quot;: \&quot;commit\&quot; } &#x60;&#x60;&#x60;
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return Commit
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The commit object </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public Commit repositoriesWorkspaceRepoSlugCommitCommitGet(String commit, String repoSlug, String workspace) throws ApiException {
        ApiResponse<Commit> localVarResp = repositoriesWorkspaceRepoSlugCommitCommitGetWithHttpInfo(commit, repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * Get a commit
     * Returns the specified commit.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a1 {     \&quot;rendered\&quot;: {         \&quot;message\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;         }     },     \&quot;hash\&quot;: \&quot;f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;,     \&quot;repository\&quot;: {         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;links\&quot;: {             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi\&quot;             },             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B85d08b4e-571d-44e9-a507-fa476535aa98%7D?ts&#x3D;1730260\&quot;             }         },         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;comments\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/comments\&quot;         },         \&quot;patch\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/patch/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;diff\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diff/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;approve\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/approve\&quot;         },         \&quot;statuses\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/statuses\&quot;         }     },     \&quot;author\&quot;: {         \&quot;raw\&quot;: \&quot;Brodie Rao &lt;a@b.c&gt;\&quot;,         \&quot;type\&quot;: \&quot;author\&quot;,         \&quot;user\&quot;: {             \&quot;display_name\&quot;: \&quot;Brodie Rao\&quot;,             \&quot;uuid\&quot;: \&quot;{9484702e-c663-4afd-aefb-c93a8cd31c28}\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D/\&quot;                 },                 \&quot;avatar\&quot;: {                     \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca/613070db-28b0-421f-8dba-ae8a87e2a5c7/128\&quot;                 }             },             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;nickname\&quot;: \&quot;brodie\&quot;,             \&quot;account_id\&quot;: \&quot;557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca\&quot;         }     },     \&quot;summary\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;     },     \&quot;participants\&quot;: [],     \&quot;parents\&quot;: [         {             \&quot;type\&quot;: \&quot;commit\&quot;,             \&quot;hash\&quot;: \&quot;f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 }             }         }     ],     \&quot;date\&quot;: \&quot;2012-07-16T19:37:54+00:00\&quot;,     \&quot;message\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,     \&quot;type\&quot;: \&quot;commit\&quot; } &#x60;&#x60;&#x60;
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Commit&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The commit object </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Commit> repositoriesWorkspaceRepoSlugCommitCommitGetWithHttpInfo(String commit, String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitGetValidateBeforeCall(commit, repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<Commit>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a commit (asynchronously)
     * Returns the specified commit.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a1 {     \&quot;rendered\&quot;: {         \&quot;message\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;         }     },     \&quot;hash\&quot;: \&quot;f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;,     \&quot;repository\&quot;: {         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;links\&quot;: {             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi\&quot;             },             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B85d08b4e-571d-44e9-a507-fa476535aa98%7D?ts&#x3D;1730260\&quot;             }         },         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;comments\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/comments\&quot;         },         \&quot;patch\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/patch/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;diff\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diff/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;approve\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/approve\&quot;         },         \&quot;statuses\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/statuses\&quot;         }     },     \&quot;author\&quot;: {         \&quot;raw\&quot;: \&quot;Brodie Rao &lt;a@b.c&gt;\&quot;,         \&quot;type\&quot;: \&quot;author\&quot;,         \&quot;user\&quot;: {             \&quot;display_name\&quot;: \&quot;Brodie Rao\&quot;,             \&quot;uuid\&quot;: \&quot;{9484702e-c663-4afd-aefb-c93a8cd31c28}\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D/\&quot;                 },                 \&quot;avatar\&quot;: {                     \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca/613070db-28b0-421f-8dba-ae8a87e2a5c7/128\&quot;                 }             },             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;nickname\&quot;: \&quot;brodie\&quot;,             \&quot;account_id\&quot;: \&quot;557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca\&quot;         }     },     \&quot;summary\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;     },     \&quot;participants\&quot;: [],     \&quot;parents\&quot;: [         {             \&quot;type\&quot;: \&quot;commit\&quot;,             \&quot;hash\&quot;: \&quot;f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 }             }         }     ],     \&quot;date\&quot;: \&quot;2012-07-16T19:37:54+00:00\&quot;,     \&quot;message\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,     \&quot;type\&quot;: \&quot;commit\&quot; } &#x60;&#x60;&#x60;
     * @param commit The commit&#39;s SHA1. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The commit object </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified commit or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitCommitGetAsync(String commit, String repoSlug, String workspace, final ApiCallback<Commit> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitCommitGetValidateBeforeCall(commit, repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<Commit>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitsGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitsGetCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commits"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitsGetValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitsGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitsGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitsGetCall(repoSlug, workspace, _callback);

    }

    /**
     * List commits
     * These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60;. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to &#x60;git log --all&#x60;).  #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude&#x3D;master  Returns all commits in the repo that are not on master (similar to &#x60;git log --all ^master&#x60;).  #### GET /repositories/{workspace}/{repo_slug}/commits/?include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;fu&amp;exclude&#x3D;fubar  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;fu&#x60; or &#x60;fubar&#x60; (similar to &#x60;git log foo bar ^fu ^fubar&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;src/&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedChangeset
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedChangeset repositoriesWorkspaceRepoSlugCommitsGet(String repoSlug, String workspace) throws ApiException {
        ApiResponse<PaginatedChangeset> localVarResp = repositoriesWorkspaceRepoSlugCommitsGetWithHttpInfo(repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * List commits
     * These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60;. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to &#x60;git log --all&#x60;).  #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude&#x3D;master  Returns all commits in the repo that are not on master (similar to &#x60;git log --all ^master&#x60;).  #### GET /repositories/{workspace}/{repo_slug}/commits/?include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;fu&amp;exclude&#x3D;fubar  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;fu&#x60; or &#x60;fubar&#x60; (similar to &#x60;git log foo bar ^fu ^fubar&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;src/&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedChangeset&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedChangeset> repositoriesWorkspaceRepoSlugCommitsGetWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitsGetValidateBeforeCall(repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedChangeset>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List commits (asynchronously)
     * These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60;. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to &#x60;git log --all&#x60;).  #### GET /repositories/{workspace}/{repo_slug}/commits/?exclude&#x3D;master  Returns all commits in the repo that are not on master (similar to &#x60;git log --all ^master&#x60;).  #### GET /repositories/{workspace}/{repo_slug}/commits/?include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;fu&amp;exclude&#x3D;fubar  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;fu&#x60; or &#x60;fubar&#x60; (similar to &#x60;git log foo bar ^fu ^fubar&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;src/&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitsGetAsync(String repoSlug, String workspace, final ApiCallback<PaginatedChangeset> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitsGetValidateBeforeCall(repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedChangeset>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitsPost
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitsPostCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commits"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitsPostValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitsPost(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitsPost(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitsPostCall(repoSlug, workspace, _callback);

    }

    /**
     * List commits with include/exclude
     * Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedChangeset
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedChangeset repositoriesWorkspaceRepoSlugCommitsPost(String repoSlug, String workspace) throws ApiException {
        ApiResponse<PaginatedChangeset> localVarResp = repositoriesWorkspaceRepoSlugCommitsPostWithHttpInfo(repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * List commits with include/exclude
     * Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedChangeset&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedChangeset> repositoriesWorkspaceRepoSlugCommitsPostWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitsPostValidateBeforeCall(repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedChangeset>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List commits with include/exclude (asynchronously)
     * Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitsPostAsync(String repoSlug, String workspace, final ApiCallback<PaginatedChangeset> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitsPostValidateBeforeCall(repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedChangeset>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitsRevisionGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revision A commit SHA1 or ref name. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitsRevisionGetCall(String repoSlug, String revision, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commits/{revision}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "revision" + "}", localVarApiClient.escapeString(revision.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitsRevisionGetValidateBeforeCall(String repoSlug, String revision, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitsRevisionGet(Async)");
        }

        // verify the required parameter 'revision' is set
        if (revision == null) {
            throw new ApiException("Missing the required parameter 'revision' when calling repositoriesWorkspaceRepoSlugCommitsRevisionGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitsRevisionGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitsRevisionGetCall(repoSlug, revision, workspace, _callback);

    }

    /**
     * List commits for revision
     * These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60;. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on ref &#x60;master&#x60; (similar to &#x60;git log master&#x60;).  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include&#x3D;foo&amp;exclude&#x3D;master  Returns all commits on ref &#x60;dev&#x60; or &#x60;foo&#x60;, except those that are reachable on &#x60;master&#x60; (similar to &#x60;git log dev foo ^master&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;dev&#x60; or &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path&#x3D;src/&amp;include&#x3D;foo&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;dev&#x60; or &#x60;foo&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revision A commit SHA1 or ref name. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedChangeset
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedChangeset repositoriesWorkspaceRepoSlugCommitsRevisionGet(String repoSlug, String revision, String workspace) throws ApiException {
        ApiResponse<PaginatedChangeset> localVarResp = repositoriesWorkspaceRepoSlugCommitsRevisionGetWithHttpInfo(repoSlug, revision, workspace);
        return localVarResp.getData();
    }

    /**
     * List commits for revision
     * These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60;. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on ref &#x60;master&#x60; (similar to &#x60;git log master&#x60;).  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include&#x3D;foo&amp;exclude&#x3D;master  Returns all commits on ref &#x60;dev&#x60; or &#x60;foo&#x60;, except those that are reachable on &#x60;master&#x60; (similar to &#x60;git log dev foo ^master&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;dev&#x60; or &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path&#x3D;src/&amp;include&#x3D;foo&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;dev&#x60; or &#x60;foo&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revision A commit SHA1 or ref name. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedChangeset&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedChangeset> repositoriesWorkspaceRepoSlugCommitsRevisionGetWithHttpInfo(String repoSlug, String revision, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitsRevisionGetValidateBeforeCall(repoSlug, revision, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedChangeset>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List commits for revision (asynchronously)
     * These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60;. Like these tools, the DAG can be filtered.  #### GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on ref &#x60;master&#x60; (similar to &#x60;git log master&#x60;).  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?include&#x3D;foo&amp;exclude&#x3D;master  Returns all commits on ref &#x60;dev&#x60; or &#x60;foo&#x60;, except those that are reachable on &#x60;master&#x60; (similar to &#x60;git log dev foo ^master&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;dev&#x60; or &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  #### GET /repositories/{workspace}/{repo_slug}/commits/dev?path&#x3D;src/&amp;include&#x3D;foo&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;dev&#x60; or &#x60;foo&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revision A commit SHA1 or ref name. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitsRevisionGetAsync(String repoSlug, String revision, String workspace, final ApiCallback<PaginatedChangeset> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitsRevisionGetValidateBeforeCall(repoSlug, revision, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedChangeset>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugCommitsRevisionPost
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revision A commit SHA1 or ref name. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitsRevisionPostCall(String repoSlug, String revision, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/commits/{revision}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "revision" + "}", localVarApiClient.escapeString(revision.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugCommitsRevisionPostValidateBeforeCall(String repoSlug, String revision, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugCommitsRevisionPost(Async)");
        }

        // verify the required parameter 'revision' is set
        if (revision == null) {
            throw new ApiException("Missing the required parameter 'revision' when calling repositoriesWorkspaceRepoSlugCommitsRevisionPost(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugCommitsRevisionPost(Async)");
        }

        return repositoriesWorkspaceRepoSlugCommitsRevisionPostCall(repoSlug, revision, workspace, _callback);

    }

    /**
     * List commits for revision using include/exclude
     * Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits/{revision}&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revision A commit SHA1 or ref name. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedChangeset
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedChangeset repositoriesWorkspaceRepoSlugCommitsRevisionPost(String repoSlug, String revision, String workspace) throws ApiException {
        ApiResponse<PaginatedChangeset> localVarResp = repositoriesWorkspaceRepoSlugCommitsRevisionPostWithHttpInfo(repoSlug, revision, workspace);
        return localVarResp.getData();
    }

    /**
     * List commits for revision using include/exclude
     * Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits/{revision}&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revision A commit SHA1 or ref name. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedChangeset&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedChangeset> repositoriesWorkspaceRepoSlugCommitsRevisionPostWithHttpInfo(String repoSlug, String revision, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitsRevisionPostValidateBeforeCall(repoSlug, revision, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedChangeset>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List commits for revision using include/exclude (asynchronously)
     * Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits/{revision}&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revision A commit SHA1 or ref name. (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified revision does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugCommitsRevisionPostAsync(String repoSlug, String revision, String workspace, final ApiCallback<PaginatedChangeset> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugCommitsRevisionPostValidateBeforeCall(repoSlug, revision, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedChangeset>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugDiffSpecGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param context Generate diffs with &lt;n&gt; lines of context instead of the usual three. (optional)
     * @param path Limit the diff to a particular file (this parameter can be repeated for multiple paths). (optional)
     * @param ignoreWhitespace Generate diffs that ignore whitespace. (optional)
     * @param binary Generate diffs that include binary files, true if omitted. (optional)
     * @param renames Whether to perform rename detection, true if omitted. (optional)
     * @param merge This parameter is deprecated and will be removed at the end of 2022. The &#39;topic&#39; parameter should be used instead. The &#39;merge&#39; and &#39;topic&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diff from the destination to the merge result is returned. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. True if omitted. (optional)
     * @param topic If true, returns 2-way &#39;three-dot&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw diff </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the diff was too large and timed out.  Since this endpoint does not employ any form of pagination, but instead returns the diff as a single document, it can run into trouble on very large diffs. If Bitbucket times out in cases like these, a 555 status code is returned. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugDiffSpecGetCall(String repoSlug, String spec, String workspace, Integer context, String path, Boolean ignoreWhitespace, Boolean binary, Boolean renames, Boolean merge, Boolean topic, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/diff/{spec}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "spec" + "}", localVarApiClient.escapeString(spec.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (context != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("context", context));
        }

        if (path != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("path", path));
        }

        if (ignoreWhitespace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ignore_whitespace", ignoreWhitespace));
        }

        if (binary != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("binary", binary));
        }

        if (renames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("renames", renames));
        }

        if (merge != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("merge", merge));
        }

        if (topic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("topic", topic));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugDiffSpecGetValidateBeforeCall(String repoSlug, String spec, String workspace, Integer context, String path, Boolean ignoreWhitespace, Boolean binary, Boolean renames, Boolean merge, Boolean topic, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugDiffSpecGet(Async)");
        }

        // verify the required parameter 'spec' is set
        if (spec == null) {
            throw new ApiException("Missing the required parameter 'spec' when calling repositoriesWorkspaceRepoSlugDiffSpecGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugDiffSpecGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugDiffSpecGetCall(repoSlug, spec, workspace, context, path, ignoreWhitespace, binary, renames, merge, topic, _callback);

    }

    /**
     * Compare two commits
     * Produces a raw git-style diff.  #### Single commit spec  If the &#x60;spec&#x60; argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by &#x60;..&#x60; may be provided as the &#x60;spec&#x60;, e.g., &#x60;3a8b42..9ff173&#x60;. When two commits are provided and the &#x60;topic&#x60; query parameter is true or absent, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the &#x60;topic&#x60; query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in &#x60;git diff&#x60;.  #### Comparison to patches  While similar to patches, diffs:  * Don&#39;t have a commit header (username, commit message, etc) * Support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter   the diff to just that one file diff  #### Response  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param context Generate diffs with &lt;n&gt; lines of context instead of the usual three. (optional)
     * @param path Limit the diff to a particular file (this parameter can be repeated for multiple paths). (optional)
     * @param ignoreWhitespace Generate diffs that ignore whitespace. (optional)
     * @param binary Generate diffs that include binary files, true if omitted. (optional)
     * @param renames Whether to perform rename detection, true if omitted. (optional)
     * @param merge This parameter is deprecated and will be removed at the end of 2022. The &#39;topic&#39; parameter should be used instead. The &#39;merge&#39; and &#39;topic&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diff from the destination to the merge result is returned. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. True if omitted. (optional)
     * @param topic If true, returns 2-way &#39;three-dot&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw diff </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the diff was too large and timed out.  Since this endpoint does not employ any form of pagination, but instead returns the diff as a single document, it can run into trouble on very large diffs. If Bitbucket times out in cases like these, a 555 status code is returned. </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugDiffSpecGet(String repoSlug, String spec, String workspace, Integer context, String path, Boolean ignoreWhitespace, Boolean binary, Boolean renames, Boolean merge, Boolean topic) throws ApiException {
        repositoriesWorkspaceRepoSlugDiffSpecGetWithHttpInfo(repoSlug, spec, workspace, context, path, ignoreWhitespace, binary, renames, merge, topic);
    }

    /**
     * Compare two commits
     * Produces a raw git-style diff.  #### Single commit spec  If the &#x60;spec&#x60; argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by &#x60;..&#x60; may be provided as the &#x60;spec&#x60;, e.g., &#x60;3a8b42..9ff173&#x60;. When two commits are provided and the &#x60;topic&#x60; query parameter is true or absent, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the &#x60;topic&#x60; query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in &#x60;git diff&#x60;.  #### Comparison to patches  While similar to patches, diffs:  * Don&#39;t have a commit header (username, commit message, etc) * Support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter   the diff to just that one file diff  #### Response  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param context Generate diffs with &lt;n&gt; lines of context instead of the usual three. (optional)
     * @param path Limit the diff to a particular file (this parameter can be repeated for multiple paths). (optional)
     * @param ignoreWhitespace Generate diffs that ignore whitespace. (optional)
     * @param binary Generate diffs that include binary files, true if omitted. (optional)
     * @param renames Whether to perform rename detection, true if omitted. (optional)
     * @param merge This parameter is deprecated and will be removed at the end of 2022. The &#39;topic&#39; parameter should be used instead. The &#39;merge&#39; and &#39;topic&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diff from the destination to the merge result is returned. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. True if omitted. (optional)
     * @param topic If true, returns 2-way &#39;three-dot&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw diff </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the diff was too large and timed out.  Since this endpoint does not employ any form of pagination, but instead returns the diff as a single document, it can run into trouble on very large diffs. If Bitbucket times out in cases like these, a 555 status code is returned. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugDiffSpecGetWithHttpInfo(String repoSlug, String spec, String workspace, Integer context, String path, Boolean ignoreWhitespace, Boolean binary, Boolean renames, Boolean merge, Boolean topic) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugDiffSpecGetValidateBeforeCall(repoSlug, spec, workspace, context, path, ignoreWhitespace, binary, renames, merge, topic, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Compare two commits (asynchronously)
     * Produces a raw git-style diff.  #### Single commit spec  If the &#x60;spec&#x60; argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by &#x60;..&#x60; may be provided as the &#x60;spec&#x60;, e.g., &#x60;3a8b42..9ff173&#x60;. When two commits are provided and the &#x60;topic&#x60; query parameter is true or absent, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the &#x60;topic&#x60; query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in &#x60;git diff&#x60;.  #### Comparison to patches  While similar to patches, diffs:  * Don&#39;t have a commit header (username, commit message, etc) * Support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter   the diff to just that one file diff  #### Response  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param context Generate diffs with &lt;n&gt; lines of context instead of the usual three. (optional)
     * @param path Limit the diff to a particular file (this parameter can be repeated for multiple paths). (optional)
     * @param ignoreWhitespace Generate diffs that ignore whitespace. (optional)
     * @param binary Generate diffs that include binary files, true if omitted. (optional)
     * @param renames Whether to perform rename detection, true if omitted. (optional)
     * @param merge This parameter is deprecated and will be removed at the end of 2022. The &#39;topic&#39; parameter should be used instead. The &#39;merge&#39; and &#39;topic&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diff from the destination to the merge result is returned. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. True if omitted. (optional)
     * @param topic If true, returns 2-way &#39;three-dot&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw diff </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the diff was too large and timed out.  Since this endpoint does not employ any form of pagination, but instead returns the diff as a single document, it can run into trouble on very large diffs. If Bitbucket times out in cases like these, a 555 status code is returned. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugDiffSpecGetAsync(String repoSlug, String spec, String workspace, Integer context, String path, Boolean ignoreWhitespace, Boolean binary, Boolean renames, Boolean merge, Boolean topic, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugDiffSpecGetValidateBeforeCall(repoSlug, spec, workspace, context, path, ignoreWhitespace, binary, renames, merge, topic, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugDiffstatSpecGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param ignoreWhitespace Generate diffs that ignore whitespace (optional)
     * @param merge This parameter is deprecated and will be removed at the end of 2022. The &#39;topic&#39; parameter should be used instead. The &#39;merge&#39; and &#39;topic&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diffstat from the destination to the merge result is returned. If false, a simple &#39;two dot&#39; diffstat between the source and destination is returned. True if omitted. (optional)
     * @param path Limit the diffstat to a particular file (this parameter can be repeated for multiple paths). (optional)
     * @param renames Whether to perform rename detection, true if omitted. (optional)
     * @param topic If true, returns 2-way &#39;three-dot&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The diff stats </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If generating the diffstat timed out. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugDiffstatSpecGetCall(String repoSlug, String spec, String workspace, Boolean ignoreWhitespace, Boolean merge, String path, Boolean renames, Boolean topic, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/diffstat/{spec}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "spec" + "}", localVarApiClient.escapeString(spec.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (ignoreWhitespace != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ignore_whitespace", ignoreWhitespace));
        }

        if (merge != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("merge", merge));
        }

        if (path != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("path", path));
        }

        if (renames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("renames", renames));
        }

        if (topic != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("topic", topic));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugDiffstatSpecGetValidateBeforeCall(String repoSlug, String spec, String workspace, Boolean ignoreWhitespace, Boolean merge, String path, Boolean renames, Boolean topic, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugDiffstatSpecGet(Async)");
        }

        // verify the required parameter 'spec' is set
        if (spec == null) {
            throw new ApiException("Missing the required parameter 'spec' when calling repositoriesWorkspaceRepoSlugDiffstatSpecGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugDiffstatSpecGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugDiffstatSpecGetCall(repoSlug, spec, workspace, ignoreWhitespace, merge, path, renames, topic, _callback);

    }

    /**
     * Compare two commit diff stats
     * Produces a response in JSON format with a record for every path modified, including information on the type of the change and the number of lines added and removed.  #### Single commit spec  If the &#x60;spec&#x60; argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by &#x60;..&#x60; may be provided as the &#x60;spec&#x60;, e.g., &#x60;3a8b42..9ff173&#x60;. When two commits are provided and the &#x60;topic&#x60; query parameter is true or absent, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the &#x60;topic&#x60; query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in &#x60;git diff&#x60;.  #### Sample output &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diffstat/d222fa2..e174964 {     \&quot;pagelen\&quot;: 500,     \&quot;values\&quot;: [         {             \&quot;type\&quot;: \&quot;diffstat\&quot;,             \&quot;status\&quot;: \&quot;modified\&quot;,             \&quot;lines_removed\&quot;: 1,             \&quot;lines_added\&quot;: 2,             \&quot;old\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;escaped_path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/e1749643d655d7c7014001a6c0f58abaf42ad850/setup.py\&quot;                     }                 }             },             \&quot;new\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;escaped_path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/d222fa235229c55dad20b190b0b571adf737d5a6/setup.py\&quot;                     }                 }             }         }     ],     \&quot;page\&quot;: 1,     \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param ignoreWhitespace Generate diffs that ignore whitespace (optional)
     * @param merge This parameter is deprecated and will be removed at the end of 2022. The &#39;topic&#39; parameter should be used instead. The &#39;merge&#39; and &#39;topic&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diffstat from the destination to the merge result is returned. If false, a simple &#39;two dot&#39; diffstat between the source and destination is returned. True if omitted. (optional)
     * @param path Limit the diffstat to a particular file (this parameter can be repeated for multiple paths). (optional)
     * @param renames Whether to perform rename detection, true if omitted. (optional)
     * @param topic If true, returns 2-way &#39;three-dot&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. (optional)
     * @return PaginatedDiffstats
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The diff stats </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If generating the diffstat timed out. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedDiffstats repositoriesWorkspaceRepoSlugDiffstatSpecGet(String repoSlug, String spec, String workspace, Boolean ignoreWhitespace, Boolean merge, String path, Boolean renames, Boolean topic) throws ApiException {
        ApiResponse<PaginatedDiffstats> localVarResp = repositoriesWorkspaceRepoSlugDiffstatSpecGetWithHttpInfo(repoSlug, spec, workspace, ignoreWhitespace, merge, path, renames, topic);
        return localVarResp.getData();
    }

    /**
     * Compare two commit diff stats
     * Produces a response in JSON format with a record for every path modified, including information on the type of the change and the number of lines added and removed.  #### Single commit spec  If the &#x60;spec&#x60; argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by &#x60;..&#x60; may be provided as the &#x60;spec&#x60;, e.g., &#x60;3a8b42..9ff173&#x60;. When two commits are provided and the &#x60;topic&#x60; query parameter is true or absent, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the &#x60;topic&#x60; query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in &#x60;git diff&#x60;.  #### Sample output &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diffstat/d222fa2..e174964 {     \&quot;pagelen\&quot;: 500,     \&quot;values\&quot;: [         {             \&quot;type\&quot;: \&quot;diffstat\&quot;,             \&quot;status\&quot;: \&quot;modified\&quot;,             \&quot;lines_removed\&quot;: 1,             \&quot;lines_added\&quot;: 2,             \&quot;old\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;escaped_path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/e1749643d655d7c7014001a6c0f58abaf42ad850/setup.py\&quot;                     }                 }             },             \&quot;new\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;escaped_path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/d222fa235229c55dad20b190b0b571adf737d5a6/setup.py\&quot;                     }                 }             }         }     ],     \&quot;page\&quot;: 1,     \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param ignoreWhitespace Generate diffs that ignore whitespace (optional)
     * @param merge This parameter is deprecated and will be removed at the end of 2022. The &#39;topic&#39; parameter should be used instead. The &#39;merge&#39; and &#39;topic&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diffstat from the destination to the merge result is returned. If false, a simple &#39;two dot&#39; diffstat between the source and destination is returned. True if omitted. (optional)
     * @param path Limit the diffstat to a particular file (this parameter can be repeated for multiple paths). (optional)
     * @param renames Whether to perform rename detection, true if omitted. (optional)
     * @param topic If true, returns 2-way &#39;three-dot&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. (optional)
     * @return ApiResponse&lt;PaginatedDiffstats&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The diff stats </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If generating the diffstat timed out. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedDiffstats> repositoriesWorkspaceRepoSlugDiffstatSpecGetWithHttpInfo(String repoSlug, String spec, String workspace, Boolean ignoreWhitespace, Boolean merge, String path, Boolean renames, Boolean topic) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugDiffstatSpecGetValidateBeforeCall(repoSlug, spec, workspace, ignoreWhitespace, merge, path, renames, topic, null);
        Type localVarReturnType = new TypeToken<PaginatedDiffstats>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Compare two commit diff stats (asynchronously)
     * Produces a response in JSON format with a record for every path modified, including information on the type of the change and the number of lines added and removed.  #### Single commit spec  If the &#x60;spec&#x60; argument to this API is a single commit, the diff is produced against the first parent of the specified commit.  #### Two commit spec  Two commits separated by &#x60;..&#x60; may be provided as the &#x60;spec&#x60;, e.g., &#x60;3a8b42..9ff173&#x60;. When two commits are provided and the &#x60;topic&#x60; query parameter is true or absent, this API produces a 2-way three dot diff. This is the diff between source commit and the merge base of the source commit and the destination commit. When the &#x60;topic&#x60; query param is false, a simple git-style diff is produced.  The two commits are interpreted as follows:  * First commit: the commit containing the changes we wish to preview * Second commit: the commit representing the state to which we want to   compare the first commit * **Note**: This is the opposite of the order used in &#x60;git diff&#x60;.  #### Sample output &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diffstat/d222fa2..e174964 {     \&quot;pagelen\&quot;: 500,     \&quot;values\&quot;: [         {             \&quot;type\&quot;: \&quot;diffstat\&quot;,             \&quot;status\&quot;: \&quot;modified\&quot;,             \&quot;lines_removed\&quot;: 1,             \&quot;lines_added\&quot;: 2,             \&quot;old\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;escaped_path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/e1749643d655d7c7014001a6c0f58abaf42ad850/setup.py\&quot;                     }                 }             },             \&quot;new\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;escaped_path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/d222fa235229c55dad20b190b0b571adf737d5a6/setup.py\&quot;                     }                 }             }         }     ],     \&quot;page\&quot;: 1,     \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param ignoreWhitespace Generate diffs that ignore whitespace (optional)
     * @param merge This parameter is deprecated and will be removed at the end of 2022. The &#39;topic&#39; parameter should be used instead. The &#39;merge&#39; and &#39;topic&#39; parameters cannot be both used at the same time.  If true, the source commit is merged into the destination commit, and then a diffstat from the destination to the merge result is returned. If false, a simple &#39;two dot&#39; diffstat between the source and destination is returned. True if omitted. (optional)
     * @param path Limit the diffstat to a particular file (this parameter can be repeated for multiple paths). (optional)
     * @param renames Whether to perform rename detection, true if omitted. (optional)
     * @param topic If true, returns 2-way &#39;three-dot&#39; diff. This is a diff between the source commit and the merge base of the source commit and the destination commit. If false, a simple &#39;two dot&#39; diff between the source and destination is returned. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The diff stats </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If generating the diffstat timed out. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugDiffstatSpecGetAsync(String repoSlug, String spec, String workspace, Boolean ignoreWhitespace, Boolean merge, String path, Boolean renames, Boolean topic, final ApiCallback<PaginatedDiffstats> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugDiffstatSpecGetValidateBeforeCall(repoSlug, spec, workspace, ignoreWhitespace, merge, path, renames, topic, _callback);
        Type localVarReturnType = new TypeToken<PaginatedDiffstats>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugMergeBaseRevspecGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revspec A commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The merge base of the provided spec. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to any of the repositories specified. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository or ref in the spec does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugMergeBaseRevspecGetCall(String repoSlug, String revspec, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/merge-base/{revspec}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "revspec" + "}", localVarApiClient.escapeString(revspec.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugMergeBaseRevspecGetValidateBeforeCall(String repoSlug, String revspec, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(Async)");
        }

        // verify the required parameter 'revspec' is set
        if (revspec == null) {
            throw new ApiException("Missing the required parameter 'revspec' when calling repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugMergeBaseRevspecGetCall(repoSlug, revspec, workspace, _callback);

    }

    /**
     * Get the common ancestor between two commits
     * Returns the best common ancestor between two commits, specified in a revspec of 2 commits (e.g. 3a8b42..9ff173).  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revspec A commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return Commit
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The merge base of the provided spec. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to any of the repositories specified. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository or ref in the spec does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public Commit repositoriesWorkspaceRepoSlugMergeBaseRevspecGet(String repoSlug, String revspec, String workspace) throws ApiException {
        ApiResponse<Commit> localVarResp = repositoriesWorkspaceRepoSlugMergeBaseRevspecGetWithHttpInfo(repoSlug, revspec, workspace);
        return localVarResp.getData();
    }

    /**
     * Get the common ancestor between two commits
     * Returns the best common ancestor between two commits, specified in a revspec of 2 commits (e.g. 3a8b42..9ff173).  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revspec A commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Commit&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The merge base of the provided spec. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to any of the repositories specified. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository or ref in the spec does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Commit> repositoriesWorkspaceRepoSlugMergeBaseRevspecGetWithHttpInfo(String repoSlug, String revspec, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugMergeBaseRevspecGetValidateBeforeCall(repoSlug, revspec, workspace, null);
        Type localVarReturnType = new TypeToken<Commit>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get the common ancestor between two commits (asynchronously)
     * Returns the best common ancestor between two commits, specified in a revspec of 2 commits (e.g. 3a8b42..9ff173).  If more than one best common ancestor exists, only one will be returned. It is unspecified which will be returned.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param revspec A commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The merge base of the provided spec. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have access to any of the repositories specified. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository or ref in the spec does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugMergeBaseRevspecGetAsync(String repoSlug, String revspec, String workspace, final ApiCallback<Commit> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugMergeBaseRevspecGetValidateBeforeCall(repoSlug, revspec, workspace, _callback);
        Type localVarReturnType = new TypeToken<Commit>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPatchSpecGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw patches </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the diff was too large and timed out.  Since this endpoint does not employ any form of pagination, but instead returns the diff as a single document, it can run into trouble on very large diffs. If Bitbucket times out in cases like these, a 555 status code is returned. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPatchSpecGetCall(String repoSlug, String spec, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/patch/{spec}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "spec" + "}", localVarApiClient.escapeString(spec.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPatchSpecGetValidateBeforeCall(String repoSlug, String spec, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPatchSpecGet(Async)");
        }

        // verify the required parameter 'spec' is set
        if (spec == null) {
            throw new ApiException("Missing the required parameter 'spec' when calling repositoriesWorkspaceRepoSlugPatchSpecGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPatchSpecGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugPatchSpecGetCall(repoSlug, spec, workspace, _callback);

    }

    /**
     * Get a patch for two commits
     * Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. &#x60;3a8b42..9ff173&#x60; where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (&#x60;3a8b42&#x60; and its ancestors in our example).  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the &#x60;path&#x3D;foo/bar.py&#x60; query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw patches </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the diff was too large and timed out.  Since this endpoint does not employ any form of pagination, but instead returns the diff as a single document, it can run into trouble on very large diffs. If Bitbucket times out in cases like these, a 555 status code is returned. </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugPatchSpecGet(String repoSlug, String spec, String workspace) throws ApiException {
        repositoriesWorkspaceRepoSlugPatchSpecGetWithHttpInfo(repoSlug, spec, workspace);
    }

    /**
     * Get a patch for two commits
     * Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. &#x60;3a8b42..9ff173&#x60; where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (&#x60;3a8b42&#x60; and its ancestors in our example).  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the &#x60;path&#x3D;foo/bar.py&#x60; query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw patches </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the diff was too large and timed out.  Since this endpoint does not employ any form of pagination, but instead returns the diff as a single document, it can run into trouble on very large diffs. If Bitbucket times out in cases like these, a 555 status code is returned. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugPatchSpecGetWithHttpInfo(String repoSlug, String spec, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPatchSpecGetValidateBeforeCall(repoSlug, spec, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Get a patch for two commits (asynchronously)
     * Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. &#x60;3a8b42..9ff173&#x60; where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (&#x60;3a8b42&#x60; and its ancestors in our example).  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the &#x60;path&#x3D;foo/bar.py&#x60; query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param spec A commit SHA (e.g. &#x60;3a8b42&#x60;) or a commit range using double dot notation (e.g. &#x60;3a8b42..9ff173&#x60;).  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The raw patches </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the diff was too large and timed out.  Since this endpoint does not employ any form of pagination, but instead returns the diff as a single document, it can run into trouble on very large diffs. If Bitbucket times out in cases like these, a 555 status code is returned. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPatchSpecGetAsync(String repoSlug, String spec, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPatchSpecGetValidateBeforeCall(repoSlug, spec, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
