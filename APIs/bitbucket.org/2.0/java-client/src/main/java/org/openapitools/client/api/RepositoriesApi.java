/*
 * Bitbucket API
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.Error;
import org.openapitools.client.model.PaginatedAccounts;
import org.openapitools.client.model.PaginatedFiles;
import org.openapitools.client.model.PaginatedRepositories;
import org.openapitools.client.model.PaginatedRepositoryGroupPermissions;
import org.openapitools.client.model.PaginatedRepositoryPermissions;
import org.openapitools.client.model.PaginatedRepositoryUserPermissions;
import org.openapitools.client.model.PaginatedTreeentries;
import org.openapitools.client.model.PaginatedWebhookSubscriptions;
import org.openapitools.client.model.Repository;
import org.openapitools.client.model.RepositoryGroupPermission;
import org.openapitools.client.model.RepositoryInheritanceState;
import org.openapitools.client.model.RepositoryUserPermission;
import org.openapitools.client.model.WebhookSubscription;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RepositoriesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public RepositoriesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RepositoriesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for repositoriesGet
     * @param after Filter the results to include only repositories created on or after this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)  timestamp. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60; (optional)
     * @param role Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). &#x60;role&#x60; parameter must also be specified.  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All public repositories. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesGetCall(String after, String role, String q, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (after != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("after", after));
        }

        if (role != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("role", role));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesGetValidateBeforeCall(String after, String role, String q, String sort, final ApiCallback _callback) throws ApiException {
        return repositoriesGetCall(after, role, q, sort, _callback);

    }

    /**
     * List public repositories
     * Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @param after Filter the results to include only repositories created on or after this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)  timestamp. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60; (optional)
     * @param role Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). &#x60;role&#x60; parameter must also be specified.  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @return PaginatedRepositories
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All public repositories. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedRepositories repositoriesGet(String after, String role, String q, String sort) throws ApiException {
        ApiResponse<PaginatedRepositories> localVarResp = repositoriesGetWithHttpInfo(after, role, q, sort);
        return localVarResp.getData();
    }

    /**
     * List public repositories
     * Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @param after Filter the results to include only repositories created on or after this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)  timestamp. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60; (optional)
     * @param role Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). &#x60;role&#x60; parameter must also be specified.  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @return ApiResponse&lt;PaginatedRepositories&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All public repositories. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedRepositories> repositoriesGetWithHttpInfo(String after, String role, String q, String sort) throws ApiException {
        okhttp3.Call localVarCall = repositoriesGetValidateBeforeCall(after, role, q, sort, null);
        Type localVarReturnType = new TypeToken<PaginatedRepositories>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List public repositories (asynchronously)
     * Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @param after Filter the results to include only repositories created on or after this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)  timestamp. Example: &#x60;YYYY-MM-DDTHH:mm:ss.sssZ&#x60; (optional)
     * @param role Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). &#x60;role&#x60; parameter must also be specified.  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All public repositories. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesGetAsync(String after, String role, String q, String sort, final ApiCallback<PaginatedRepositories> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesGetValidateBeforeCall(after, role, q, sort, _callback);
        Type localVarReturnType = new TypeToken<PaginatedRepositories>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceGet
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role  Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).          (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repositories owned by the specified account. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified account does not exist. </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> If the specified account marked as spam. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceGetCall(String workspace, String role, String q, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}"
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (role != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("role", role));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceGetValidateBeforeCall(String workspace, String role, String q, String sort, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceGet(Async)");
        }

        return repositoriesWorkspaceGetCall(workspace, role, q, sort, _callback);

    }

    /**
     * List repositories in a workspace
     * Returns a paginated list of all repositories owned by the specified workspace.  The result can be narrowed down based on the authenticated user&#39;s role.  E.g. with &#x60;?role&#x3D;contributor&#x60;, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role  Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).          (optional)
     * @return PaginatedRepositories
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repositories owned by the specified account. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified account does not exist. </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> If the specified account marked as spam. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedRepositories repositoriesWorkspaceGet(String workspace, String role, String q, String sort) throws ApiException {
        ApiResponse<PaginatedRepositories> localVarResp = repositoriesWorkspaceGetWithHttpInfo(workspace, role, q, sort);
        return localVarResp.getData();
    }

    /**
     * List repositories in a workspace
     * Returns a paginated list of all repositories owned by the specified workspace.  The result can be narrowed down based on the authenticated user&#39;s role.  E.g. with &#x60;?role&#x3D;contributor&#x60;, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role  Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).          (optional)
     * @return ApiResponse&lt;PaginatedRepositories&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repositories owned by the specified account. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified account does not exist. </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> If the specified account marked as spam. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedRepositories> repositoriesWorkspaceGetWithHttpInfo(String workspace, String role, String q, String sort) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceGetValidateBeforeCall(workspace, role, q, sort, null);
        Type localVarReturnType = new TypeToken<PaginatedRepositories>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List repositories in a workspace (asynchronously)
     * Returns a paginated list of all repositories owned by the specified workspace.  The result can be narrowed down based on the authenticated user&#39;s role.  E.g. with &#x60;?role&#x3D;contributor&#x60;, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role  Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort  Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).          (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repositories owned by the specified account. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the specified account does not exist. </td><td>  -  </td></tr>
        <tr><td> 410 </td><td> If the specified account marked as spam. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceGetAsync(String workspace, String role, String q, String sort, final ApiCallback<PaginatedRepositories> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceGetValidateBeforeCall(workspace, role, q, sort, _callback);
        Type localVarReturnType = new TypeToken<PaginatedRepositories>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugDelete
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param redirectTo If a repository has been moved to a new location, use this parameter to show users a friendly message in the Bitbucket UI that the repository has moved to a new location. However, a GET to this endpoint will still return a 404.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates successful deletion. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the caller either does not have admin access to the repository, or the repository is set to read-only. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugDeleteCall(String repoSlug, String workspace, String redirectTo, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (redirectTo != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("redirect_to", redirectTo));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugDeleteValidateBeforeCall(String repoSlug, String workspace, String redirectTo, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugDelete(Async)");
        }

        return repositoriesWorkspaceRepoSlugDeleteCall(repoSlug, workspace, redirectTo, _callback);

    }

    /**
     * Delete a repository
     * Deletes the repository. This is an irreversible operation.  This does not affect its forks.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param redirectTo If a repository has been moved to a new location, use this parameter to show users a friendly message in the Bitbucket UI that the repository has moved to a new location. However, a GET to this endpoint will still return a 404.  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates successful deletion. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the caller either does not have admin access to the repository, or the repository is set to read-only. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugDelete(String repoSlug, String workspace, String redirectTo) throws ApiException {
        repositoriesWorkspaceRepoSlugDeleteWithHttpInfo(repoSlug, workspace, redirectTo);
    }

    /**
     * Delete a repository
     * Deletes the repository. This is an irreversible operation.  This does not affect its forks.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param redirectTo If a repository has been moved to a new location, use this parameter to show users a friendly message in the Bitbucket UI that the repository has moved to a new location. However, a GET to this endpoint will still return a 404.  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates successful deletion. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the caller either does not have admin access to the repository, or the repository is set to read-only. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugDeleteWithHttpInfo(String repoSlug, String workspace, String redirectTo) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugDeleteValidateBeforeCall(repoSlug, workspace, redirectTo, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a repository (asynchronously)
     * Deletes the repository. This is an irreversible operation.  This does not affect its forks.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param redirectTo If a repository has been moved to a new location, use this parameter to show users a friendly message in the Bitbucket UI that the repository has moved to a new location. However, a GET to this endpoint will still return a 404.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Indicates successful deletion. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the caller either does not have admin access to the repository, or the repository is set to read-only. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugDeleteAsync(String repoSlug, String workspace, String redirectTo, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugDeleteValidateBeforeCall(repoSlug, workspace, redirectTo, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0
     * @param commit The commit&#39;s SHA1. (required)
     * @param path Path to the file. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param renames  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;. (optional)
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits that modified the specified file </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0Call(String commit, String path, String repoSlug, String workspace, String renames, String q, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/filehistory/{commit}/{path}"
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "path" + "}", localVarApiClient.escapeString(path.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (renames != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("renames", renames));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0ValidateBeforeCall(String commit, String path, String repoSlug, String workspace, String renames, String q, String sort, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0(Async)");
        }

        // verify the required parameter 'path' is set
        if (path == null) {
            throw new ApiException("Missing the required parameter 'path' when calling repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0(Async)");
        }

        return repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0Call(commit, path, repoSlug, workspace, renames, q, sort, _callback);

    }

    /**
     * List commits that modified a file
     * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order &lt;sha&gt; &lt;path&gt;  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the &#x60;?renames&#x3D;false&#x60; query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  For example, if you wanted to find commits made before 2011-05-18 against a file named &#x60;README.rst&#x60;, but you only wanted the path and date, your query would look like this:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst&#39;\\   &#39;?fields&#x3D;values.next,values.path,values.commit.date&amp;q&#x3D;commit.date&lt;&#x3D;2011-05-18&#39; {   \&quot;values\&quot;: [     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-17T07:32:09+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.rst\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:33:28+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:15:39+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     }   ] } &#x60;&#x60;&#x60;  In the response you can see that the file was renamed to &#x60;README.rst&#x60; by the commit made on 2011-05-16, and was previously named &#x60;README.txt&#x60;.
     * @param commit The commit&#39;s SHA1. (required)
     * @param path Path to the file. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param renames  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;. (optional)
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).  (optional)
     * @return PaginatedFiles
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits that modified the specified file </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedFiles repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0(String commit, String path, String repoSlug, String workspace, String renames, String q, String sort) throws ApiException {
        ApiResponse<PaginatedFiles> localVarResp = repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0WithHttpInfo(commit, path, repoSlug, workspace, renames, q, sort);
        return localVarResp.getData();
    }

    /**
     * List commits that modified a file
     * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order &lt;sha&gt; &lt;path&gt;  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the &#x60;?renames&#x3D;false&#x60; query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  For example, if you wanted to find commits made before 2011-05-18 against a file named &#x60;README.rst&#x60;, but you only wanted the path and date, your query would look like this:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst&#39;\\   &#39;?fields&#x3D;values.next,values.path,values.commit.date&amp;q&#x3D;commit.date&lt;&#x3D;2011-05-18&#39; {   \&quot;values\&quot;: [     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-17T07:32:09+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.rst\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:33:28+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:15:39+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     }   ] } &#x60;&#x60;&#x60;  In the response you can see that the file was renamed to &#x60;README.rst&#x60; by the commit made on 2011-05-16, and was previously named &#x60;README.txt&#x60;.
     * @param commit The commit&#39;s SHA1. (required)
     * @param path Path to the file. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param renames  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;. (optional)
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).  (optional)
     * @return ApiResponse&lt;PaginatedFiles&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits that modified the specified file </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedFiles> repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0WithHttpInfo(String commit, String path, String repoSlug, String workspace, String renames, String q, String sort) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0ValidateBeforeCall(commit, path, repoSlug, workspace, renames, q, sort, null);
        Type localVarReturnType = new TypeToken<PaginatedFiles>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List commits that modified a file (asynchronously)
     * Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order &lt;sha&gt; &lt;path&gt;  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the &#x60;?renames&#x3D;false&#x60; query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to only provide exactly the data you want.  For example, if you wanted to find commits made before 2011-05-18 against a file named &#x60;README.rst&#x60;, but you only wanted the path and date, your query would look like this:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst&#39;\\   &#39;?fields&#x3D;values.next,values.path,values.commit.date&amp;q&#x3D;commit.date&lt;&#x3D;2011-05-18&#39; {   \&quot;values\&quot;: [     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-17T07:32:09+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.rst\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:33:28+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:15:39+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     }   ] } &#x60;&#x60;&#x60;  In the response you can see that the file was renamed to &#x60;README.rst&#x60; by the commit made on 2011-05-16, and was previously named &#x60;README.txt&#x60;.
     * @param commit The commit&#39;s SHA1. (required)
     * @param path Path to the file. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param renames  When &#x60;true&#x60;, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying &#x60;false&#x60;. (optional)
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results).  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of commits that modified the specified file </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0Async(String commit, String path, String repoSlug, String workspace, String renames, String q, String sort, final ApiCallback<PaginatedFiles> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugFilehistoryCommitPathGet_0ValidateBeforeCall(commit, path, repoSlug, workspace, renames, q, sort, _callback);
        Type localVarReturnType = new TypeToken<PaginatedFiles>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugForksGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All forks. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugForksGetCall(String repoSlug, String workspace, String role, String q, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/forks"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (role != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("role", role));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugForksGetValidateBeforeCall(String repoSlug, String workspace, String role, String q, String sort, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugForksGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugForksGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugForksGetCall(repoSlug, workspace, role, q, sort, _callback);

    }

    /**
     * List repository forks
     * Returns a paginated list of all the forks of the specified repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @return PaginatedRepositories
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All forks. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedRepositories repositoriesWorkspaceRepoSlugForksGet(String repoSlug, String workspace, String role, String q, String sort) throws ApiException {
        ApiResponse<PaginatedRepositories> localVarResp = repositoriesWorkspaceRepoSlugForksGetWithHttpInfo(repoSlug, workspace, role, q, sort);
        return localVarResp.getData();
    }

    /**
     * List repository forks
     * Returns a paginated list of all the forks of the specified repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @return ApiResponse&lt;PaginatedRepositories&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All forks. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedRepositories> repositoriesWorkspaceRepoSlugForksGetWithHttpInfo(String repoSlug, String workspace, String role, String q, String sort) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugForksGetValidateBeforeCall(repoSlug, workspace, role, q, sort, null);
        Type localVarReturnType = new TypeToken<PaginatedRepositories>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List repository forks (asynchronously)
     * Returns a paginated list of all the forks of the specified repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param role Filters the result based on the authenticated user&#39;s role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user  (optional)
     * @param q Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param sort Field by which the results should be sorted as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering).  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> All forks. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugForksGetAsync(String repoSlug, String workspace, String role, String q, String sort, final ApiCallback<PaginatedRepositories> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugForksGetValidateBeforeCall(repoSlug, workspace, role, q, sort, _callback);
        Type localVarReturnType = new TypeToken<PaginatedRepositories>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugForksPost
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository A repository object. This can be left blank. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created fork. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugForksPostCall(String repoSlug, String workspace, Repository repository, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = repository;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/forks"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugForksPostValidateBeforeCall(String repoSlug, String workspace, Repository repository, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugForksPost(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugForksPost(Async)");
        }

        return repositoriesWorkspaceRepoSlugForksPostCall(repoSlug, workspace, repository, _callback);

    }

    /**
     * Fork a repository
     * Creates a new fork of the specified repository.  #### Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  &#x60;&#x60;&#x60; $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H &#39;Content-Type: application/json&#39; -d &#39;{     \&quot;name\&quot;: \&quot;bbql_fork\&quot;,     \&quot;workspace\&quot;: {       \&quot;slug\&quot;: \&quot;atlassian\&quot;     } }&#39; &#x60;&#x60;&#x60;  To fork a repository into the same workspace, also specify a new &#x60;name&#x60;.  When you specify a value for &#x60;name&#x60;, it will also affect the &#x60;slug&#x60;. The &#x60;slug&#x60; is reflected in the repository URL of the new fork. It is derived from &#x60;name&#x60; by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, &#x60;My repo&#x60; would turn into &#x60;my_repo&#x60;.  You need contributor access to create new forks within a workspace.   #### Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal &#x60;repository&#x60; JSON schema and you can override the new fork&#39;s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo&#39;s fork_policy might prohibit   the creation of public forks, in which &#x60;is_private&#x3D;False&#x60; would fail) * has_issues (to initialize or disable the new repo&#39;s issue tracker --   note that the actual contents of the parent repository&#39;s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo&#39;s wiki --   note that the actual contents of the parent repository&#39;s wiki are not   copied during forking) * project (when forking into a private project, the fork&#39;s &#x60;is_private&#x60;   must be &#x60;true&#x60;)  Properties that cannot be modified include:  * scm * parent * full_name
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository A repository object. This can be left blank. (optional)
     * @return Repository
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created fork. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
     </table>
     */
    public Repository repositoriesWorkspaceRepoSlugForksPost(String repoSlug, String workspace, Repository repository) throws ApiException {
        ApiResponse<Repository> localVarResp = repositoriesWorkspaceRepoSlugForksPostWithHttpInfo(repoSlug, workspace, repository);
        return localVarResp.getData();
    }

    /**
     * Fork a repository
     * Creates a new fork of the specified repository.  #### Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  &#x60;&#x60;&#x60; $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H &#39;Content-Type: application/json&#39; -d &#39;{     \&quot;name\&quot;: \&quot;bbql_fork\&quot;,     \&quot;workspace\&quot;: {       \&quot;slug\&quot;: \&quot;atlassian\&quot;     } }&#39; &#x60;&#x60;&#x60;  To fork a repository into the same workspace, also specify a new &#x60;name&#x60;.  When you specify a value for &#x60;name&#x60;, it will also affect the &#x60;slug&#x60;. The &#x60;slug&#x60; is reflected in the repository URL of the new fork. It is derived from &#x60;name&#x60; by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, &#x60;My repo&#x60; would turn into &#x60;my_repo&#x60;.  You need contributor access to create new forks within a workspace.   #### Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal &#x60;repository&#x60; JSON schema and you can override the new fork&#39;s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo&#39;s fork_policy might prohibit   the creation of public forks, in which &#x60;is_private&#x3D;False&#x60; would fail) * has_issues (to initialize or disable the new repo&#39;s issue tracker --   note that the actual contents of the parent repository&#39;s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo&#39;s wiki --   note that the actual contents of the parent repository&#39;s wiki are not   copied during forking) * project (when forking into a private project, the fork&#39;s &#x60;is_private&#x60;   must be &#x60;true&#x60;)  Properties that cannot be modified include:  * scm * parent * full_name
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository A repository object. This can be left blank. (optional)
     * @return ApiResponse&lt;Repository&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created fork. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
     </table>
     */
    public ApiResponse<Repository> repositoriesWorkspaceRepoSlugForksPostWithHttpInfo(String repoSlug, String workspace, Repository repository) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugForksPostValidateBeforeCall(repoSlug, workspace, repository, null);
        Type localVarReturnType = new TypeToken<Repository>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Fork a repository (asynchronously)
     * Creates a new fork of the specified repository.  #### Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  &#x60;&#x60;&#x60; $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H &#39;Content-Type: application/json&#39; -d &#39;{     \&quot;name\&quot;: \&quot;bbql_fork\&quot;,     \&quot;workspace\&quot;: {       \&quot;slug\&quot;: \&quot;atlassian\&quot;     } }&#39; &#x60;&#x60;&#x60;  To fork a repository into the same workspace, also specify a new &#x60;name&#x60;.  When you specify a value for &#x60;name&#x60;, it will also affect the &#x60;slug&#x60;. The &#x60;slug&#x60; is reflected in the repository URL of the new fork. It is derived from &#x60;name&#x60; by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, &#x60;My repo&#x60; would turn into &#x60;my_repo&#x60;.  You need contributor access to create new forks within a workspace.   #### Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal &#x60;repository&#x60; JSON schema and you can override the new fork&#39;s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo&#39;s fork_policy might prohibit   the creation of public forks, in which &#x60;is_private&#x3D;False&#x60; would fail) * has_issues (to initialize or disable the new repo&#39;s issue tracker --   note that the actual contents of the parent repository&#39;s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo&#39;s wiki --   note that the actual contents of the parent repository&#39;s wiki are not   copied during forking) * project (when forking into a private project, the fork&#39;s &#x60;is_private&#x60;   must be &#x60;true&#x60;)  Properties that cannot be modified include:  * scm * parent * full_name
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository A repository object. This can be left blank. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The newly created fork. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugForksPostAsync(String repoSlug, String workspace, Repository repository, final ApiCallback<Repository> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugForksPostValidateBeforeCall(repoSlug, workspace, repository, _callback);
        Type localVarReturnType = new TypeToken<Repository>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repository object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the repository is private and the authenticated user does not have access to it. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugGetCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugGetValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugGetCall(repoSlug, workspace, _callback);

    }

    /**
     * Get a repository
     * Returns the object describing this repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return Repository
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repository object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the repository is private and the authenticated user does not have access to it. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location. </td><td>  -  </td></tr>
     </table>
     */
    public Repository repositoriesWorkspaceRepoSlugGet(String repoSlug, String workspace) throws ApiException {
        ApiResponse<Repository> localVarResp = repositoriesWorkspaceRepoSlugGetWithHttpInfo(repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * Get a repository
     * Returns the object describing this repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Repository&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repository object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the repository is private and the authenticated user does not have access to it. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Repository> repositoriesWorkspaceRepoSlugGetWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugGetValidateBeforeCall(repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<Repository>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a repository (asynchronously)
     * Returns the object describing this repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repository object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the repository is private and the authenticated user does not have access to it. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugGetAsync(String repoSlug, String workspace, final ApiCallback<Repository> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugGetValidateBeforeCall(repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<Repository>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugHooksGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of installed webhooks. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to access the webhooks. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksGetCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/hooks"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugHooksGetValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugHooksGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugHooksGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugHooksGetCall(repoSlug, workspace, _callback);

    }

    /**
     * List webhooks for a repository
     * Returns a paginated list of webhooks installed on this repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedWebhookSubscriptions
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of installed webhooks. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to access the webhooks. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedWebhookSubscriptions repositoriesWorkspaceRepoSlugHooksGet(String repoSlug, String workspace) throws ApiException {
        ApiResponse<PaginatedWebhookSubscriptions> localVarResp = repositoriesWorkspaceRepoSlugHooksGetWithHttpInfo(repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * List webhooks for a repository
     * Returns a paginated list of webhooks installed on this repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedWebhookSubscriptions&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of installed webhooks. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to access the webhooks. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedWebhookSubscriptions> repositoriesWorkspaceRepoSlugHooksGetWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksGetValidateBeforeCall(repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedWebhookSubscriptions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List webhooks for a repository (asynchronously)
     * Returns a paginated list of webhooks installed on this repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The paginated list of installed webhooks. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to access the webhooks. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksGetAsync(String repoSlug, String workspace, final ApiCallback<PaginatedWebhookSubscriptions> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksGetValidateBeforeCall(repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedWebhookSubscriptions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugHooksPost
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> If the webhook was registered successfully. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to install webhooks on the specified repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksPostCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/hooks"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugHooksPostValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugHooksPost(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugHooksPost(Async)");
        }

        return repositoriesWorkspaceRepoSlugHooksPostCall(repoSlug, workspace, _callback);

    }

    /**
     * Create a webhook for a repository
     * Creates a new webhook on the specified repository.  Example:  &#x60;&#x60;&#x60; $ curl -X POST -u credentials -H &#39;Content-Type: application/json&#39;   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d &#39;     {       \&quot;description\&quot;: \&quot;Webhook Description\&quot;,       \&quot;url\&quot;: \&quot;https://example.com/\&quot;,       \&quot;active\&quot;: true,       \&quot;events\&quot;: [         \&quot;repo:push\&quot;,         \&quot;issue:created\&quot;,         \&quot;issue:updated\&quot;       ]     }&#39; &#x60;&#x60;&#x60;  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: &#x60;webhook&#x60;, &#x60;repository&#x60; and &#x60;issue&#x60;.  Also note that the &#x60;url&#x60; must properly resolve and cannot be an internal, non-routed address.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return WebhookSubscription
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> If the webhook was registered successfully. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to install webhooks on the specified repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public WebhookSubscription repositoriesWorkspaceRepoSlugHooksPost(String repoSlug, String workspace) throws ApiException {
        ApiResponse<WebhookSubscription> localVarResp = repositoriesWorkspaceRepoSlugHooksPostWithHttpInfo(repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * Create a webhook for a repository
     * Creates a new webhook on the specified repository.  Example:  &#x60;&#x60;&#x60; $ curl -X POST -u credentials -H &#39;Content-Type: application/json&#39;   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d &#39;     {       \&quot;description\&quot;: \&quot;Webhook Description\&quot;,       \&quot;url\&quot;: \&quot;https://example.com/\&quot;,       \&quot;active\&quot;: true,       \&quot;events\&quot;: [         \&quot;repo:push\&quot;,         \&quot;issue:created\&quot;,         \&quot;issue:updated\&quot;       ]     }&#39; &#x60;&#x60;&#x60;  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: &#x60;webhook&#x60;, &#x60;repository&#x60; and &#x60;issue&#x60;.  Also note that the &#x60;url&#x60; must properly resolve and cannot be an internal, non-routed address.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;WebhookSubscription&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> If the webhook was registered successfully. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to install webhooks on the specified repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WebhookSubscription> repositoriesWorkspaceRepoSlugHooksPostWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksPostValidateBeforeCall(repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<WebhookSubscription>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a webhook for a repository (asynchronously)
     * Creates a new webhook on the specified repository.  Example:  &#x60;&#x60;&#x60; $ curl -X POST -u credentials -H &#39;Content-Type: application/json&#39;   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks   -d &#39;     {       \&quot;description\&quot;: \&quot;Webhook Description\&quot;,       \&quot;url\&quot;: \&quot;https://example.com/\&quot;,       \&quot;active\&quot;: true,       \&quot;events\&quot;: [         \&quot;repo:push\&quot;,         \&quot;issue:created\&quot;,         \&quot;issue:updated\&quot;       ]     }&#39; &#x60;&#x60;&#x60;  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: &#x60;webhook&#x60;, &#x60;repository&#x60; and &#x60;issue&#x60;.  Also note that the &#x60;url&#x60; must properly resolve and cannot be an internal, non-routed address.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> If the webhook was registered successfully. </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to install webhooks on the specified repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksPostAsync(String repoSlug, String workspace, final ApiCallback<WebhookSubscription> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksPostValidateBeforeCall(repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<WebhookSubscription>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugHooksUidDelete
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> When the webhook was deleted successfully </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to delete the webhook. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksUidDeleteCall(String repoSlug, String uid, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/hooks/{uid}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugHooksUidDeleteValidateBeforeCall(String repoSlug, String uid, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugHooksUidDelete(Async)");
        }

        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling repositoriesWorkspaceRepoSlugHooksUidDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugHooksUidDelete(Async)");
        }

        return repositoriesWorkspaceRepoSlugHooksUidDeleteCall(repoSlug, uid, workspace, _callback);

    }

    /**
     * Delete a webhook for a repository
     * Deletes the specified webhook subscription from the given repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> When the webhook was deleted successfully </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to delete the webhook. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugHooksUidDelete(String repoSlug, String uid, String workspace) throws ApiException {
        repositoriesWorkspaceRepoSlugHooksUidDeleteWithHttpInfo(repoSlug, uid, workspace);
    }

    /**
     * Delete a webhook for a repository
     * Deletes the specified webhook subscription from the given repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> When the webhook was deleted successfully </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to delete the webhook. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugHooksUidDeleteWithHttpInfo(String repoSlug, String uid, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksUidDeleteValidateBeforeCall(repoSlug, uid, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a webhook for a repository (asynchronously)
     * Deletes the specified webhook subscription from the given repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> When the webhook was deleted successfully </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to delete the webhook. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksUidDeleteAsync(String repoSlug, String uid, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksUidDeleteValidateBeforeCall(repoSlug, uid, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugHooksUidGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The webhook subscription object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksUidGetCall(String repoSlug, String uid, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/hooks/{uid}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugHooksUidGetValidateBeforeCall(String repoSlug, String uid, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugHooksUidGet(Async)");
        }

        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling repositoriesWorkspaceRepoSlugHooksUidGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugHooksUidGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugHooksUidGetCall(repoSlug, uid, workspace, _callback);

    }

    /**
     * Get a webhook for a repository
     * Returns the webhook with the specified id installed on the specified repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return WebhookSubscription
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The webhook subscription object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public WebhookSubscription repositoriesWorkspaceRepoSlugHooksUidGet(String repoSlug, String uid, String workspace) throws ApiException {
        ApiResponse<WebhookSubscription> localVarResp = repositoriesWorkspaceRepoSlugHooksUidGetWithHttpInfo(repoSlug, uid, workspace);
        return localVarResp.getData();
    }

    /**
     * Get a webhook for a repository
     * Returns the webhook with the specified id installed on the specified repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;WebhookSubscription&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The webhook subscription object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WebhookSubscription> repositoriesWorkspaceRepoSlugHooksUidGetWithHttpInfo(String repoSlug, String uid, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksUidGetValidateBeforeCall(repoSlug, uid, workspace, null);
        Type localVarReturnType = new TypeToken<WebhookSubscription>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a webhook for a repository (asynchronously)
     * Returns the webhook with the specified id installed on the specified repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The webhook subscription object. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksUidGetAsync(String repoSlug, String uid, String workspace, final ApiCallback<WebhookSubscription> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksUidGetValidateBeforeCall(repoSlug, uid, workspace, _callback);
        Type localVarReturnType = new TypeToken<WebhookSubscription>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugHooksUidPut
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The webhook subscription object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to update the webhook. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksUidPutCall(String repoSlug, String uid, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/hooks/{uid}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugHooksUidPutValidateBeforeCall(String repoSlug, String uid, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugHooksUidPut(Async)");
        }

        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling repositoriesWorkspaceRepoSlugHooksUidPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugHooksUidPut(Async)");
        }

        return repositoriesWorkspaceRepoSlugHooksUidPutCall(repoSlug, uid, workspace, _callback);

    }

    /**
     * Update a webhook for a repository
     * Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return WebhookSubscription
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The webhook subscription object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to update the webhook. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public WebhookSubscription repositoriesWorkspaceRepoSlugHooksUidPut(String repoSlug, String uid, String workspace) throws ApiException {
        ApiResponse<WebhookSubscription> localVarResp = repositoriesWorkspaceRepoSlugHooksUidPutWithHttpInfo(repoSlug, uid, workspace);
        return localVarResp.getData();
    }

    /**
     * Update a webhook for a repository
     * Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;WebhookSubscription&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The webhook subscription object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to update the webhook. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WebhookSubscription> repositoriesWorkspaceRepoSlugHooksUidPutWithHttpInfo(String repoSlug, String uid, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksUidPutValidateBeforeCall(repoSlug, uid, workspace, null);
        Type localVarReturnType = new TypeToken<WebhookSubscription>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a webhook for a repository (asynchronously)
     * Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param uid Installed webhook&#39;s ID (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The webhook subscription object. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have permission to update the webhook. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the webhook or repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugHooksUidPutAsync(String repoSlug, String uid, String workspace, final ApiCallback<WebhookSubscription> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugHooksUidPutValidateBeforeCall(repoSlug, uid, workspace, _callback);
        Type localVarReturnType = new TypeToken<WebhookSubscription>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugOverrideSettingsGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repository setting inheritance state </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugOverrideSettingsGetCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/override-settings"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugOverrideSettingsGetValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugOverrideSettingsGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugOverrideSettingsGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugOverrideSettingsGetCall(repoSlug, workspace, _callback);

    }

    /**
     * Retrieve the inheritance state for repository settings
     * 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return RepositoryInheritanceState
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repository setting inheritance state </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location </td><td>  -  </td></tr>
     </table>
     */
    public RepositoryInheritanceState repositoriesWorkspaceRepoSlugOverrideSettingsGet(String repoSlug, String workspace) throws ApiException {
        ApiResponse<RepositoryInheritanceState> localVarResp = repositoriesWorkspaceRepoSlugOverrideSettingsGetWithHttpInfo(repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * Retrieve the inheritance state for repository settings
     * 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;RepositoryInheritanceState&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repository setting inheritance state </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RepositoryInheritanceState> repositoriesWorkspaceRepoSlugOverrideSettingsGetWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugOverrideSettingsGetValidateBeforeCall(repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<RepositoryInheritanceState>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve the inheritance state for repository settings (asynchronously)
     * 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The repository setting inheritance state </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugOverrideSettingsGetAsync(String repoSlug, String workspace, final ApiCallback<RepositoryInheritanceState> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugOverrideSettingsGetValidateBeforeCall(repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<RepositoryInheritanceState>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugOverrideSettingsPut
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The repository setting inheritance state was set and no content returned </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugOverrideSettingsPutCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/override-settings"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugOverrideSettingsPutValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugOverrideSettingsPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugOverrideSettingsPut(Async)");
        }

        return repositoriesWorkspaceRepoSlugOverrideSettingsPutCall(repoSlug, workspace, _callback);

    }

    /**
     * Set the inheritance state for repository settings                 
     * 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The repository setting inheritance state was set and no content returned </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugOverrideSettingsPut(String repoSlug, String workspace) throws ApiException {
        repositoriesWorkspaceRepoSlugOverrideSettingsPutWithHttpInfo(repoSlug, workspace);
    }

    /**
     * Set the inheritance state for repository settings                 
     * 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The repository setting inheritance state was set and no content returned </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugOverrideSettingsPutWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugOverrideSettingsPutValidateBeforeCall(repoSlug, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Set the inheritance state for repository settings                  (asynchronously)
     * 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The repository setting inheritance state was set and no content returned </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If no repository exists at this location </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugOverrideSettingsPutAsync(String repoSlug, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugOverrideSettingsPutValidateBeforeCall(repoSlug, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Paginated of explicit group permissions on the repository. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or both of the workspace and repository doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/permissions-config/groups"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetCall(repoSlug, workspace, _callback);

    }

    /**
     * List explicit group permissions for a repository
     * Returns a paginated list of explicit group permissions for the given repository. This endpoint does not support BBQL features.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups  HTTP/1.1 200 Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,       \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Administrators\&quot;,         \&quot;slug\&quot;: \&quot;administrators\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/                    geordi/permissions-config/groups/administrators\&quot;         }       }     },     {       \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,       \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Developers\&quot;,         \&quot;slug\&quot;: \&quot;developers\&quot;       },       \&quot;permission\&quot;: \&quot;read\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/                    geordi/permissions-config/groups/developers\&quot;         }       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedRepositoryGroupPermissions
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Paginated of explicit group permissions on the repository. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or both of the workspace and repository doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedRepositoryGroupPermissions repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGet(String repoSlug, String workspace) throws ApiException {
        ApiResponse<PaginatedRepositoryGroupPermissions> localVarResp = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetWithHttpInfo(repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * List explicit group permissions for a repository
     * Returns a paginated list of explicit group permissions for the given repository. This endpoint does not support BBQL features.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups  HTTP/1.1 200 Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,       \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Administrators\&quot;,         \&quot;slug\&quot;: \&quot;administrators\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/                    geordi/permissions-config/groups/administrators\&quot;         }       }     },     {       \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,       \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Developers\&quot;,         \&quot;slug\&quot;: \&quot;developers\&quot;       },       \&quot;permission\&quot;: \&quot;read\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/                    geordi/permissions-config/groups/developers\&quot;         }       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedRepositoryGroupPermissions&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Paginated of explicit group permissions on the repository. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or both of the workspace and repository doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedRepositoryGroupPermissions> repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetValidateBeforeCall(repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedRepositoryGroupPermissions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List explicit group permissions for a repository (asynchronously)
     * Returns a paginated list of explicit group permissions for the given repository. This endpoint does not support BBQL features.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups  HTTP/1.1 200 Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,       \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Administrators\&quot;,         \&quot;slug\&quot;: \&quot;administrators\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/                    geordi/permissions-config/groups/administrators\&quot;         }       }     },     {       \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,       \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Developers\&quot;,         \&quot;slug\&quot;: \&quot;developers\&quot;       },       \&quot;permission\&quot;: \&quot;read\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/                    geordi/permissions-config/groups/developers\&quot;         }       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Paginated of explicit group permissions on the repository. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or both of the workspace and repository doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetAsync(String repoSlug, String workspace, final ApiCallback<PaginatedRepositoryGroupPermissions> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGetValidateBeforeCall(repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedRepositoryGroupPermissions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Group permission deleted </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The workspace does not exist, the repository does not exist, or the group does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteCall(String groupSlug, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}"
            .replace("{" + "group_slug" + "}", localVarApiClient.escapeString(groupSlug.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteValidateBeforeCall(String groupSlug, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupSlug' is set
        if (groupSlug == null) {
            throw new ApiException("Missing the required parameter 'groupSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(Async)");
        }

        return repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteCall(groupSlug, repoSlug, workspace, _callback);

    }

    /**
     * Delete an explicit group permission for a repository
     * Deletes the repository group permission between the requested repository and group, if one exists.  Only users with admin permission for the repository may access this resource.  Example:  $ curl -X DELETE https://api.bitbucket.org/2.0/repositories/atlassian_tutorial /geordi/permissions-config/groups/developers   HTTP/1.1 204
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Group permission deleted </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The workspace does not exist, the repository does not exist, or the group does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDelete(String groupSlug, String repoSlug, String workspace) throws ApiException {
        repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteWithHttpInfo(groupSlug, repoSlug, workspace);
    }

    /**
     * Delete an explicit group permission for a repository
     * Deletes the repository group permission between the requested repository and group, if one exists.  Only users with admin permission for the repository may access this resource.  Example:  $ curl -X DELETE https://api.bitbucket.org/2.0/repositories/atlassian_tutorial /geordi/permissions-config/groups/developers   HTTP/1.1 204
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Group permission deleted </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The workspace does not exist, the repository does not exist, or the group does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteWithHttpInfo(String groupSlug, String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteValidateBeforeCall(groupSlug, repoSlug, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete an explicit group permission for a repository (asynchronously)
     * Deletes the repository group permission between the requested repository and group, if one exists.  Only users with admin permission for the repository may access this resource.  Example:  $ curl -X DELETE https://api.bitbucket.org/2.0/repositories/atlassian_tutorial /geordi/permissions-config/groups/developers   HTTP/1.1 204
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Group permission deleted </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The workspace does not exist, the repository does not exist, or the group does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteAsync(String groupSlug, String repoSlug, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugDeleteValidateBeforeCall(groupSlug, repoSlug, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group permission for group slug and repository </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The given user, workspace, and/or repository could not be found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetCall(String groupSlug, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}"
            .replace("{" + "group_slug" + "}", localVarApiClient.escapeString(groupSlug.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetValidateBeforeCall(String groupSlug, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupSlug' is set
        if (groupSlug == null) {
            throw new ApiException("Missing the required parameter 'groupSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetCall(groupSlug, repoSlug, workspace, _callback);

    }

    /**
     * Get an explicit group permission for a repository
     * Returns the group permission for a given group slug and repository  Only users with admin permission for the repository may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60; * &#x60;none&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers  HTTP/1.1 200 Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers  {     \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,     \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Developers\&quot;,         \&quot;slug\&quot;: \&quot;developers\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;read\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;:         \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers\&quot;       }     } } &#x60;&#x60;&#x60;
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return RepositoryGroupPermission
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group permission for group slug and repository </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The given user, workspace, and/or repository could not be found </td><td>  -  </td></tr>
     </table>
     */
    public RepositoryGroupPermission repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGet(String groupSlug, String repoSlug, String workspace) throws ApiException {
        ApiResponse<RepositoryGroupPermission> localVarResp = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetWithHttpInfo(groupSlug, repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * Get an explicit group permission for a repository
     * Returns the group permission for a given group slug and repository  Only users with admin permission for the repository may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60; * &#x60;none&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers  HTTP/1.1 200 Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers  {     \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,     \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Developers\&quot;,         \&quot;slug\&quot;: \&quot;developers\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;read\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;:         \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers\&quot;       }     } } &#x60;&#x60;&#x60;
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;RepositoryGroupPermission&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group permission for group slug and repository </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The given user, workspace, and/or repository could not be found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RepositoryGroupPermission> repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetWithHttpInfo(String groupSlug, String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetValidateBeforeCall(groupSlug, repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<RepositoryGroupPermission>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get an explicit group permission for a repository (asynchronously)
     * Returns the group permission for a given group slug and repository  Only users with admin permission for the repository may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60; * &#x60;none&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers  HTTP/1.1 200 Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers  {     \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,     \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Developers\&quot;,         \&quot;slug\&quot;: \&quot;developers\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;read\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;:         \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers\&quot;       }     } } &#x60;&#x60;&#x60;
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group permission for group slug and repository </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The given user, workspace, and/or repository could not be found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetAsync(String groupSlug, String repoSlug, String workspace, final ApiCallback<RepositoryGroupPermission> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugGetValidateBeforeCall(groupSlug, repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<RepositoryGroupPermission>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group permission updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> No permission value was provided or the value is invalid(not one of read, write, or admin) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> You have reached your plan&#39;s user limit and must upgrade before giving access to additional users. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The workspace does not exist, the repository does not exist, or the group does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutCall(String groupSlug, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}"
            .replace("{" + "group_slug" + "}", localVarApiClient.escapeString(groupSlug.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutValidateBeforeCall(String groupSlug, String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupSlug' is set
        if (groupSlug == null) {
            throw new ApiException("Missing the required parameter 'groupSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(Async)");
        }

        return repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutCall(groupSlug, repoSlug, workspace, _callback);

    }

    /**
     * Update an explicit group permission for a repository
     * Updates the group permission if it exists.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example: &#x60;&#x60;&#x60; $ curl -X PUT -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers -d &#39;{     \&quot;permission\&quot;: \&quot;write\&quot; }&#39;  HTTP/1.1 200 Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers  {     \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,     \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Developers\&quot;,         \&quot;slug\&quot;: \&quot;developers\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;write\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;:         \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers\&quot;       }     } } &#x60;&#x60;&#x60;
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return RepositoryGroupPermission
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group permission updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> No permission value was provided or the value is invalid(not one of read, write, or admin) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> You have reached your plan&#39;s user limit and must upgrade before giving access to additional users. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The workspace does not exist, the repository does not exist, or the group does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public RepositoryGroupPermission repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPut(String groupSlug, String repoSlug, String workspace) throws ApiException {
        ApiResponse<RepositoryGroupPermission> localVarResp = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutWithHttpInfo(groupSlug, repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * Update an explicit group permission for a repository
     * Updates the group permission if it exists.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example: &#x60;&#x60;&#x60; $ curl -X PUT -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers -d &#39;{     \&quot;permission\&quot;: \&quot;write\&quot; }&#39;  HTTP/1.1 200 Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers  {     \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,     \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Developers\&quot;,         \&quot;slug\&quot;: \&quot;developers\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;write\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;:         \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers\&quot;       }     } } &#x60;&#x60;&#x60;
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;RepositoryGroupPermission&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group permission updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> No permission value was provided or the value is invalid(not one of read, write, or admin) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> You have reached your plan&#39;s user limit and must upgrade before giving access to additional users. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The workspace does not exist, the repository does not exist, or the group does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RepositoryGroupPermission> repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutWithHttpInfo(String groupSlug, String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutValidateBeforeCall(groupSlug, repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<RepositoryGroupPermission>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update an explicit group permission for a repository (asynchronously)
     * Updates the group permission if it exists.  Only users with admin permission for the repository may access this resource.  The only authentication method supported for this endpoint is via app passwords.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example: &#x60;&#x60;&#x60; $ curl -X PUT -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers -d &#39;{     \&quot;permission\&quot;: \&quot;write\&quot; }&#39;  HTTP/1.1 200 Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers  {     \&quot;type\&quot;: \&quot;repository_group_permission\&quot;,     \&quot;group\&quot;: {         \&quot;type\&quot;: \&quot;group\&quot;,         \&quot;name\&quot;: \&quot;Developers\&quot;,         \&quot;slug\&quot;: \&quot;developers\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;write\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;:         \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers\&quot;       }     } } &#x60;&#x60;&#x60;
     * @param groupSlug Slug of the requested group. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Group permission updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> No permission value was provided or the value is invalid(not one of read, write, or admin) </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> You have reached your plan&#39;s user limit and must upgrade before giving access to additional users. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> The workspace does not exist, the repository does not exist, or the group does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutAsync(String groupSlug, String repoSlug, String workspace, final ApiCallback<RepositoryGroupPermission> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugPutValidateBeforeCall(groupSlug, repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<RepositoryGroupPermission>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Paginated of explicit user permissions on the repository. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No repository exists for the given repository slug and workspace. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersGetCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/permissions-config/users"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersGetValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugPermissionsConfigUsersGetCall(repoSlug, workspace, _callback);

    }

    /**
     * List explicit user permissions for a repository
     * Returns a paginated list of explicit user permissions for the given repository. This endpoint does not support BBQL features.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/users  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {         \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,         \&quot;user\&quot;: {             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;display_name\&quot;: \&quot;Colin Cameron\&quot;,             \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,             \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;         },         \&quot;permission\&quot;: \&quot;admin\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/                      permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;           }         }     },     {       \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Conaty\&quot;,         \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;,         \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324c\&quot;       },       \&quot;permission\&quot;: \&quot;write\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0//repositories/atlassian_tutorial/geordi/                    permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324c\&quot;         }       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedRepositoryUserPermissions
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Paginated of explicit user permissions on the repository. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No repository exists for the given repository slug and workspace. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedRepositoryUserPermissions repositoriesWorkspaceRepoSlugPermissionsConfigUsersGet(String repoSlug, String workspace) throws ApiException {
        ApiResponse<PaginatedRepositoryUserPermissions> localVarResp = repositoriesWorkspaceRepoSlugPermissionsConfigUsersGetWithHttpInfo(repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * List explicit user permissions for a repository
     * Returns a paginated list of explicit user permissions for the given repository. This endpoint does not support BBQL features.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/users  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {         \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,         \&quot;user\&quot;: {             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;display_name\&quot;: \&quot;Colin Cameron\&quot;,             \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,             \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;         },         \&quot;permission\&quot;: \&quot;admin\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/                      permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;           }         }     },     {       \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Conaty\&quot;,         \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;,         \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324c\&quot;       },       \&quot;permission\&quot;: \&quot;write\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0//repositories/atlassian_tutorial/geordi/                    permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324c\&quot;         }       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedRepositoryUserPermissions&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Paginated of explicit user permissions on the repository. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No repository exists for the given repository slug and workspace. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedRepositoryUserPermissions> repositoriesWorkspaceRepoSlugPermissionsConfigUsersGetWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigUsersGetValidateBeforeCall(repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedRepositoryUserPermissions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List explicit user permissions for a repository (asynchronously)
     * Returns a paginated list of explicit user permissions for the given repository. This endpoint does not support BBQL features.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/users  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {         \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,         \&quot;user\&quot;: {             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;display_name\&quot;: \&quot;Colin Cameron\&quot;,             \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,             \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;         },         \&quot;permission\&quot;: \&quot;admin\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/                      permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;           }         }     },     {       \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Conaty\&quot;,         \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;,         \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324c\&quot;       },       \&quot;permission\&quot;: \&quot;write\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0//repositories/atlassian_tutorial/geordi/                    permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324c\&quot;         }       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Paginated of explicit user permissions on the repository. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No repository exists for the given repository slug and workspace. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersGetAsync(String repoSlug, String workspace, final ApiCallback<PaginatedRepositoryUserPermissions> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigUsersGetValidateBeforeCall(repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedRepositoryUserPermissions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The repository user permission was deleted and no content returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or more of the workspace, repository, and user doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteCall(String repoSlug, String selectedUserId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "selected_user_id" + "}", localVarApiClient.escapeString(selectedUserId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteValidateBeforeCall(String repoSlug, String selectedUserId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(Async)");
        }

        // verify the required parameter 'selectedUserId' is set
        if (selectedUserId == null) {
            throw new ApiException("Missing the required parameter 'selectedUserId' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(Async)");
        }

        return repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteCall(repoSlug, selectedUserId, workspace, _callback);

    }

    /**
     * Delete an explicit user permission for a repository
     * Deletes the repository user permission between the requested repository and user, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  &#x60;&#x60;&#x60; $ curl -X DELETE https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/ permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a   HTTP/1.1 204 &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The repository user permission was deleted and no content returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or more of the workspace, repository, and user doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDelete(String repoSlug, String selectedUserId, String workspace) throws ApiException {
        repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteWithHttpInfo(repoSlug, selectedUserId, workspace);
    }

    /**
     * Delete an explicit user permission for a repository
     * Deletes the repository user permission between the requested repository and user, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  &#x60;&#x60;&#x60; $ curl -X DELETE https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/ permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a   HTTP/1.1 204 &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The repository user permission was deleted and no content returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or more of the workspace, repository, and user doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteWithHttpInfo(String repoSlug, String selectedUserId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteValidateBeforeCall(repoSlug, selectedUserId, workspace, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete an explicit user permission for a repository (asynchronously)
     * Deletes the repository user permission between the requested repository and user, if one exists.  Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  &#x60;&#x60;&#x60; $ curl -X DELETE https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/ permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a   HTTP/1.1 204 &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> The repository user permission was deleted and no content returned. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or more of the workspace, repository, and user doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteAsync(String repoSlug, String selectedUserId, String workspace, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdDeleteValidateBeforeCall(repoSlug, selectedUserId, workspace, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Explicit user permission for user and repository </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or both of the workspace and repository doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetCall(String repoSlug, String selectedUserId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "selected_user_id" + "}", localVarApiClient.escapeString(selectedUserId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetValidateBeforeCall(String repoSlug, String selectedUserId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(Async)");
        }

        // verify the required parameter 'selectedUserId' is set
        if (selectedUserId == null) {
            throw new ApiException("Missing the required parameter 'selectedUserId' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetCall(repoSlug, selectedUserId, workspace, _callback);

    }

    /**
     * Get an explicit user permission for a repository
     * Returns the explicit user permission for a given user and repository.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60; * &#x60;none&#x60;  Example:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/         permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39;  HTTP/1.1 200 Location: &#39;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/            permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39;  {     \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,     \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Colin Cameron\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;admin\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/                      permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;         }     } } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return RepositoryUserPermission
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Explicit user permission for user and repository </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or both of the workspace and repository doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public RepositoryUserPermission repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGet(String repoSlug, String selectedUserId, String workspace) throws ApiException {
        ApiResponse<RepositoryUserPermission> localVarResp = repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetWithHttpInfo(repoSlug, selectedUserId, workspace);
        return localVarResp.getData();
    }

    /**
     * Get an explicit user permission for a repository
     * Returns the explicit user permission for a given user and repository.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60; * &#x60;none&#x60;  Example:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/         permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39;  HTTP/1.1 200 Location: &#39;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/            permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39;  {     \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,     \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Colin Cameron\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;admin\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/                      permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;         }     } } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;RepositoryUserPermission&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Explicit user permission for user and repository </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or both of the workspace and repository doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RepositoryUserPermission> repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetWithHttpInfo(String repoSlug, String selectedUserId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetValidateBeforeCall(repoSlug, selectedUserId, workspace, null);
        Type localVarReturnType = new TypeToken<RepositoryUserPermission>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get an explicit user permission for a repository (asynchronously)
     * Returns the explicit user permission for a given user and repository.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60; * &#x60;none&#x60;  Example:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/         permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39;  HTTP/1.1 200 Location: &#39;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/            permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39;  {     \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,     \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Colin Cameron\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;admin\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/                      permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;         }     } } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Explicit user permission for user and repository </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or both of the workspace and repository doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetAsync(String repoSlug, String selectedUserId, String workspace, final ApiCallback<RepositoryUserPermission> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdGetValidateBeforeCall(repoSlug, selectedUserId, workspace, _callback);
        Type localVarReturnType = new TypeToken<RepositoryUserPermission>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Explicit user permission updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> No permission value was provided or the value is invalid (not one of read, write, or admin), or the selected user is not a valid user to update. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> You have reached your plan&#39;s user limit and must upgrade before giving access to additional users. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or more of the workspace, repository, and selected user doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutCall(String repoSlug, String selectedUserId, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "selected_user_id" + "}", localVarApiClient.escapeString(selectedUserId.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutValidateBeforeCall(String repoSlug, String selectedUserId, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(Async)");
        }

        // verify the required parameter 'selectedUserId' is set
        if (selectedUserId == null) {
            throw new ApiException("Missing the required parameter 'selectedUserId' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(Async)");
        }

        return repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutCall(repoSlug, selectedUserId, workspace, _callback);

    }

    /**
     * Update an explicit user permission for a repository
     * Updates the explicit user permission for a given user and repository. The selected user must be a member of the workspace, and cannot be the workspace owner. Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl -X PUT -H \&quot;Content-Type: application/json\&quot; &#39;https://api.bitbucket.org/2.0/repositories/ atlassian_tutorial/geordi/permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39; -d         &#39;{     \&quot;permission\&quot;: \&quot;write\&quot; }&#39;  HTTP/1.1 200 Location: &#39;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/ permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39;   {     \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,     \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Colin Cameron\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;write\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/                      permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;         }     } } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return RepositoryUserPermission
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Explicit user permission updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> No permission value was provided or the value is invalid (not one of read, write, or admin), or the selected user is not a valid user to update. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> You have reached your plan&#39;s user limit and must upgrade before giving access to additional users. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or more of the workspace, repository, and selected user doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public RepositoryUserPermission repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPut(String repoSlug, String selectedUserId, String workspace) throws ApiException {
        ApiResponse<RepositoryUserPermission> localVarResp = repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutWithHttpInfo(repoSlug, selectedUserId, workspace);
        return localVarResp.getData();
    }

    /**
     * Update an explicit user permission for a repository
     * Updates the explicit user permission for a given user and repository. The selected user must be a member of the workspace, and cannot be the workspace owner. Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl -X PUT -H \&quot;Content-Type: application/json\&quot; &#39;https://api.bitbucket.org/2.0/repositories/ atlassian_tutorial/geordi/permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39; -d         &#39;{     \&quot;permission\&quot;: \&quot;write\&quot; }&#39;  HTTP/1.1 200 Location: &#39;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/ permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39;   {     \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,     \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Colin Cameron\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;write\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/                      permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;         }     } } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;RepositoryUserPermission&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Explicit user permission updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> No permission value was provided or the value is invalid (not one of read, write, or admin), or the selected user is not a valid user to update. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> You have reached your plan&#39;s user limit and must upgrade before giving access to additional users. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or more of the workspace, repository, and selected user doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RepositoryUserPermission> repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutWithHttpInfo(String repoSlug, String selectedUserId, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutValidateBeforeCall(repoSlug, selectedUserId, workspace, null);
        Type localVarReturnType = new TypeToken<RepositoryUserPermission>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update an explicit user permission for a repository (asynchronously)
     * Updates the explicit user permission for a given user and repository. The selected user must be a member of the workspace, and cannot be the workspace owner. Only users with admin permission for the repository may access this resource.  The only authentication method for this endpoint is via app passwords.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl -X PUT -H \&quot;Content-Type: application/json\&quot; &#39;https://api.bitbucket.org/2.0/repositories/ atlassian_tutorial/geordi/permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39; -d         &#39;{     \&quot;permission\&quot;: \&quot;write\&quot; }&#39;  HTTP/1.1 200 Location: &#39;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/ permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a&#39;   {     \&quot;type\&quot;: \&quot;repository_user_permission\&quot;,     \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Colin Cameron\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;account_id\&quot;: \&quot;557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;     },     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;atlassian_tutorial/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;permission\&quot;: \&quot;write\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/                      permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\&quot;         }     } } &#x60;&#x60;&#x60;
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param selectedUserId This can either be the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;, OR an Atlassian Account ID.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Explicit user permission updated </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> No permission value was provided or the value is invalid (not one of read, write, or admin), or the selected user is not a valid user to update. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> The user couldn&#39;t be authenticated. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> You have reached your plan&#39;s user limit and must upgrade before giving access to additional users. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The requesting user isn&#39;t an admin of the repository, or the authentication method was not via app password. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> One or more of the workspace, repository, and selected user doesn&#39;t exist for the given identifiers. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutAsync(String repoSlug, String selectedUserId, String workspace, final ApiCallback<RepositoryUserPermission> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIdPutValidateBeforeCall(repoSlug, selectedUserId, workspace, _callback);
        Type localVarReturnType = new TypeToken<RepositoryUserPermission>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPost
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository The repository that is to be created. Note that most object elements are optional. Elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored as the URL implies them. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The newly created repository. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPostCall(String repoSlug, String workspace, Repository repository, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = repository;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPostValidateBeforeCall(String repoSlug, String workspace, Repository repository, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPost(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPost(Async)");
        }

        return repositoriesWorkspaceRepoSlugPostCall(repoSlug, workspace, repository, _callback);

    }

    /**
     * Create a repository
     * Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;MARS\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  or  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;{ba516952-992a-4c2d-acbd-17d502922f96}\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  The project must be assigned for all repositories. If the project is not provided, the repository is automatically assigned to the oldest project in the workspace.  Note: In the examples above, the workspace ID &#x60;teamsinspace&#x60;, and/or the repository name &#x60;hablanding&#x60; can be replaced by UUIDs.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository The repository that is to be created. Note that most object elements are optional. Elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored as the URL implies them. (optional)
     * @return Repository
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The newly created repository. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
     </table>
     */
    public Repository repositoriesWorkspaceRepoSlugPost(String repoSlug, String workspace, Repository repository) throws ApiException {
        ApiResponse<Repository> localVarResp = repositoriesWorkspaceRepoSlugPostWithHttpInfo(repoSlug, workspace, repository);
        return localVarResp.getData();
    }

    /**
     * Create a repository
     * Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;MARS\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  or  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;{ba516952-992a-4c2d-acbd-17d502922f96}\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  The project must be assigned for all repositories. If the project is not provided, the repository is automatically assigned to the oldest project in the workspace.  Note: In the examples above, the workspace ID &#x60;teamsinspace&#x60;, and/or the repository name &#x60;hablanding&#x60; can be replaced by UUIDs.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository The repository that is to be created. Note that most object elements are optional. Elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored as the URL implies them. (optional)
     * @return ApiResponse&lt;Repository&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The newly created repository. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Repository> repositoriesWorkspaceRepoSlugPostWithHttpInfo(String repoSlug, String workspace, Repository repository) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPostValidateBeforeCall(repoSlug, workspace, repository, null);
        Type localVarReturnType = new TypeToken<Repository>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a repository (asynchronously)
     * Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;MARS\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  or  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;{ba516952-992a-4c2d-acbd-17d502922f96}\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  The project must be assigned for all repositories. If the project is not provided, the repository is automatically assigned to the oldest project in the workspace.  Note: In the examples above, the workspace ID &#x60;teamsinspace&#x60;, and/or the repository name &#x60;hablanding&#x60; can be replaced by UUIDs.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository The repository that is to be created. Note that most object elements are optional. Elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored as the URL implies them. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The newly created repository. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPostAsync(String repoSlug, String workspace, Repository repository, final ApiCallback<Repository> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPostValidateBeforeCall(repoSlug, workspace, repository, _callback);
        Type localVarReturnType = new TypeToken<Repository>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugPut
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository The repository that is to be updated.  Note that the elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored since the URL implies them.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The existing repository has been updated </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 201 </td><td> A new repository has been created </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPutCall(String repoSlug, String workspace, Repository repository, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = repository;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugPutValidateBeforeCall(String repoSlug, String workspace, Repository repository, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugPut(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugPut(Async)");
        }

        return repositoriesWorkspaceRepoSlugPutCall(repoSlug, workspace, repository, _callback);

    }

    /**
     * Update a repository
     * Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.  #### Creation  See the POST documentation for the repository endpoint for an example of the request body.  #### Update  Note: Changing the &#x60;name&#x60; of the repository will cause the location to be changed. This is because the URL of the repo is derived from the name (a process called slugification). In such a scenario, it is possible for the request to fail if the newly created slug conflicts with an existing repository&#39;s slug. But if there is no conflict, the new location will be returned in the &#x60;Location&#x60; header of the response.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository The repository that is to be updated.  Note that the elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored since the URL implies them.  (optional)
     * @return Repository
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The existing repository has been updated </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 201 </td><td> A new repository has been created </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
     </table>
     */
    public Repository repositoriesWorkspaceRepoSlugPut(String repoSlug, String workspace, Repository repository) throws ApiException {
        ApiResponse<Repository> localVarResp = repositoriesWorkspaceRepoSlugPutWithHttpInfo(repoSlug, workspace, repository);
        return localVarResp.getData();
    }

    /**
     * Update a repository
     * Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.  #### Creation  See the POST documentation for the repository endpoint for an example of the request body.  #### Update  Note: Changing the &#x60;name&#x60; of the repository will cause the location to be changed. This is because the URL of the repo is derived from the name (a process called slugification). In such a scenario, it is possible for the request to fail if the newly created slug conflicts with an existing repository&#39;s slug. But if there is no conflict, the new location will be returned in the &#x60;Location&#x60; header of the response.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository The repository that is to be updated.  Note that the elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored since the URL implies them.  (optional)
     * @return ApiResponse&lt;Repository&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The existing repository has been updated </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 201 </td><td> A new repository has been created </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Repository> repositoriesWorkspaceRepoSlugPutWithHttpInfo(String repoSlug, String workspace, Repository repository) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPutValidateBeforeCall(repoSlug, workspace, repository, null);
        Type localVarReturnType = new TypeToken<Repository>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a repository (asynchronously)
     * Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.  #### Creation  See the POST documentation for the repository endpoint for an example of the request body.  #### Update  Note: Changing the &#x60;name&#x60; of the repository will cause the location to be changed. This is because the URL of the repo is derived from the name (a process called slugification). In such a scenario, it is possible for the request to fail if the newly created slug conflicts with an existing repository&#39;s slug. But if there is no conflict, the new location will be returned in the &#x60;Location&#x60; header of the response.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param repository The repository that is to be updated.  Note that the elements \&quot;owner\&quot; and \&quot;full_name\&quot; are ignored since the URL implies them.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The existing repository has been updated </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 201 </td><td> A new repository has been created </td><td>  * Location - The location of the project. This header is only provided when the project key is updated. <br>  </td></tr>
        <tr><td> 400 </td><td> If the input document was invalid, or if the caller lacks the privilege to create repositories under the targeted account. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> If the request was not authenticated. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugPutAsync(String repoSlug, String workspace, Repository repository, final ApiCallback<Repository> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugPutValidateBeforeCall(repoSlug, workspace, repository, _callback);
        Type localVarReturnType = new TypeToken<Repository>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugSrcCommitPathGet_0
     * @param commit The commit&#39;s SHA1. (required)
     * @param path Path to the file. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param format If &#39;meta&#39; is provided, returns the (json) meta data for the contents of the file.  If &#39;rendered&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file&#39;s actual contents. (optional)
     * @param q Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). (optional)
     * @param maxDepth If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If the path matches a file, then the raw contents of the file are returned.  If the &#x60;format&#x3D;meta&#x60; query parameter is provided, a json document containing the file&#39;s meta data is returned.  If the &#x60;format&#x3D;rendered&#x60; query parameter is provided, the contents of the file in HTML-formated rendered markup is returned. If the path matches a directory, then a paginated list of file and directory entries is returned (if the &#x60;format&#x3D;meta&#x60; query parameter was provided, then the json document containing the directory&#39;s meta data is returned.)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the path or commit in the URL does not exist. </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the call times out, possibly because the specified recursion depth is too large. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugSrcCommitPathGet_0Call(String commit, String path, String repoSlug, String workspace, String format, String q, String sort, Integer maxDepth, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/src/{commit}/{path}"
            .replace("{" + "commit" + "}", localVarApiClient.escapeString(commit.toString()))
            .replace("{" + "path" + "}", localVarApiClient.escapeString(path.toString()))
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (maxDepth != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max_depth", maxDepth));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugSrcCommitPathGet_0ValidateBeforeCall(String commit, String path, String repoSlug, String workspace, String format, String q, String sort, Integer maxDepth, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'commit' is set
        if (commit == null) {
            throw new ApiException("Missing the required parameter 'commit' when calling repositoriesWorkspaceRepoSlugSrcCommitPathGet_0(Async)");
        }

        // verify the required parameter 'path' is set
        if (path == null) {
            throw new ApiException("Missing the required parameter 'path' when calling repositoriesWorkspaceRepoSlugSrcCommitPathGet_0(Async)");
        }

        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugSrcCommitPathGet_0(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugSrcCommitPathGet_0(Async)");
        }

        return repositoriesWorkspaceRepoSlugSrcCommitPathGet_0Call(commit, path, repoSlug, workspace, format, q, sort, maxDepth, _callback);

    }

    /**
     * Get file or directory contents
     * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When &#x60;path&#x60; points to a file, this endpoint returns the raw contents. The response&#39;s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian&#39;s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty &#x60;__init__.py&#x60; always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter &#x60;?format&#x3D;meta&#x60;, instead of returning the file&#39;s raw contents, Bitbucket instead returns the JSON object describing the file&#39;s properties:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format&#x3D;meta {   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;     }   },   \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,   \&quot;commit\&quot;: {     \&quot;type\&quot;: \&quot;commit\&quot;,     \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       }     }   },   \&quot;attributes\&quot;: [],   \&quot;type\&quot;: \&quot;commit_file\&quot;,   \&quot;size\&quot;: 0 } &#x60;&#x60;&#x60;  File objects contain an &#x60;attributes&#x60; element that contains a list of possible modifiers. Currently defined values are:  * &#x60;link&#x60; -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * &#x60;executable&#x60; -- indicates that the file has the executable bit set. * &#x60;subrepository&#x60; -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * &#x60;binary&#x60; -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file&#39;s size without incurring the overhead of receiving its full contents.   #### Directory listings  When &#x60;path&#x60; points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;path\&quot;: \&quot;tests/test_project\&quot;,       \&quot;type\&quot;: \&quot;commit_directory\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;         }       },       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       }     },     {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;         }       },       \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       },       \&quot;attributes\&quot;: [],       \&quot;type\&quot;: \&quot;commit_file\&quot;,       \&quot;size\&quot;: 0     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  When listing the contents of the repo&#39;s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \&quot;walk\&quot; the entire directory tree, the client can either parse each response and follow the &#x60;self&#x60; links of each &#x60;commit_directory&#x60; object, or can specify a &#x60;max_depth&#x60; to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the &#x60;max_depth&#x60; parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a &#x60;commit_file&#x60;, or a &#x60;commit_directory&#x60;, both of which contain a &#x60;path&#x60; element. This path is the absolute path from the root of the repository. Each object also contains a &#x60;commit&#x60; object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their &#x60;self&#x60; link returns the paginated contents of the directory. The &#x60;meta&#x60; link on the other hand returns the actual &#x60;directory&#x60; object itself, e.g.:  &#x60;&#x60;&#x60;javascript {   \&quot;path\&quot;: \&quot;tests/test_project\&quot;,   \&quot;type\&quot;: \&quot;commit_directory\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;     }   },   \&quot;commit\&quot;: { ... } } &#x60;&#x60;&#x60;  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  &#x60;size &gt; 1024 and attributes &#x3D; \&quot;binary\&quot;&#x60;  which after urlencoding yields the query string:  &#x60;?q&#x3D;size%3E1024+and+attributes%3D%22binary%22&#x60;  To change the ordering of the response, use the &#x60;?sort&#x60; parameter:  &#x60;.../src/eefd5ef/?sort&#x3D;-size&#x60;  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @param commit The commit&#39;s SHA1. (required)
     * @param path Path to the file. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param format If &#39;meta&#39; is provided, returns the (json) meta data for the contents of the file.  If &#39;rendered&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file&#39;s actual contents. (optional)
     * @param q Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). (optional)
     * @param maxDepth If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1. (optional)
     * @return PaginatedTreeentries
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If the path matches a file, then the raw contents of the file are returned.  If the &#x60;format&#x3D;meta&#x60; query parameter is provided, a json document containing the file&#39;s meta data is returned.  If the &#x60;format&#x3D;rendered&#x60; query parameter is provided, the contents of the file in HTML-formated rendered markup is returned. If the path matches a directory, then a paginated list of file and directory entries is returned (if the &#x60;format&#x3D;meta&#x60; query parameter was provided, then the json document containing the directory&#39;s meta data is returned.)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the path or commit in the URL does not exist. </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the call times out, possibly because the specified recursion depth is too large. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedTreeentries repositoriesWorkspaceRepoSlugSrcCommitPathGet_0(String commit, String path, String repoSlug, String workspace, String format, String q, String sort, Integer maxDepth) throws ApiException {
        ApiResponse<PaginatedTreeentries> localVarResp = repositoriesWorkspaceRepoSlugSrcCommitPathGet_0WithHttpInfo(commit, path, repoSlug, workspace, format, q, sort, maxDepth);
        return localVarResp.getData();
    }

    /**
     * Get file or directory contents
     * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When &#x60;path&#x60; points to a file, this endpoint returns the raw contents. The response&#39;s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian&#39;s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty &#x60;__init__.py&#x60; always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter &#x60;?format&#x3D;meta&#x60;, instead of returning the file&#39;s raw contents, Bitbucket instead returns the JSON object describing the file&#39;s properties:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format&#x3D;meta {   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;     }   },   \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,   \&quot;commit\&quot;: {     \&quot;type\&quot;: \&quot;commit\&quot;,     \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       }     }   },   \&quot;attributes\&quot;: [],   \&quot;type\&quot;: \&quot;commit_file\&quot;,   \&quot;size\&quot;: 0 } &#x60;&#x60;&#x60;  File objects contain an &#x60;attributes&#x60; element that contains a list of possible modifiers. Currently defined values are:  * &#x60;link&#x60; -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * &#x60;executable&#x60; -- indicates that the file has the executable bit set. * &#x60;subrepository&#x60; -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * &#x60;binary&#x60; -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file&#39;s size without incurring the overhead of receiving its full contents.   #### Directory listings  When &#x60;path&#x60; points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;path\&quot;: \&quot;tests/test_project\&quot;,       \&quot;type\&quot;: \&quot;commit_directory\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;         }       },       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       }     },     {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;         }       },       \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       },       \&quot;attributes\&quot;: [],       \&quot;type\&quot;: \&quot;commit_file\&quot;,       \&quot;size\&quot;: 0     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  When listing the contents of the repo&#39;s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \&quot;walk\&quot; the entire directory tree, the client can either parse each response and follow the &#x60;self&#x60; links of each &#x60;commit_directory&#x60; object, or can specify a &#x60;max_depth&#x60; to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the &#x60;max_depth&#x60; parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a &#x60;commit_file&#x60;, or a &#x60;commit_directory&#x60;, both of which contain a &#x60;path&#x60; element. This path is the absolute path from the root of the repository. Each object also contains a &#x60;commit&#x60; object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their &#x60;self&#x60; link returns the paginated contents of the directory. The &#x60;meta&#x60; link on the other hand returns the actual &#x60;directory&#x60; object itself, e.g.:  &#x60;&#x60;&#x60;javascript {   \&quot;path\&quot;: \&quot;tests/test_project\&quot;,   \&quot;type\&quot;: \&quot;commit_directory\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;     }   },   \&quot;commit\&quot;: { ... } } &#x60;&#x60;&#x60;  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  &#x60;size &gt; 1024 and attributes &#x3D; \&quot;binary\&quot;&#x60;  which after urlencoding yields the query string:  &#x60;?q&#x3D;size%3E1024+and+attributes%3D%22binary%22&#x60;  To change the ordering of the response, use the &#x60;?sort&#x60; parameter:  &#x60;.../src/eefd5ef/?sort&#x3D;-size&#x60;  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @param commit The commit&#39;s SHA1. (required)
     * @param path Path to the file. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param format If &#39;meta&#39; is provided, returns the (json) meta data for the contents of the file.  If &#39;rendered&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file&#39;s actual contents. (optional)
     * @param q Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). (optional)
     * @param maxDepth If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1. (optional)
     * @return ApiResponse&lt;PaginatedTreeentries&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If the path matches a file, then the raw contents of the file are returned.  If the &#x60;format&#x3D;meta&#x60; query parameter is provided, a json document containing the file&#39;s meta data is returned.  If the &#x60;format&#x3D;rendered&#x60; query parameter is provided, the contents of the file in HTML-formated rendered markup is returned. If the path matches a directory, then a paginated list of file and directory entries is returned (if the &#x60;format&#x3D;meta&#x60; query parameter was provided, then the json document containing the directory&#39;s meta data is returned.)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the path or commit in the URL does not exist. </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the call times out, possibly because the specified recursion depth is too large. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedTreeentries> repositoriesWorkspaceRepoSlugSrcCommitPathGet_0WithHttpInfo(String commit, String path, String repoSlug, String workspace, String format, String q, String sort, Integer maxDepth) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugSrcCommitPathGet_0ValidateBeforeCall(commit, path, repoSlug, workspace, format, q, sort, maxDepth, null);
        Type localVarReturnType = new TypeToken<PaginatedTreeentries>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get file or directory contents (asynchronously)
     * This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  #### Raw file contents  When &#x60;path&#x60; points to a file, this endpoint returns the raw contents. The response&#39;s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian&#39;s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty &#x60;__init__.py&#x60; always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  #### File meta data  When the request for a file path includes the query parameter &#x60;?format&#x3D;meta&#x60;, instead of returning the file&#39;s raw contents, Bitbucket instead returns the JSON object describing the file&#39;s properties:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format&#x3D;meta {   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;     }   },   \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,   \&quot;commit\&quot;: {     \&quot;type\&quot;: \&quot;commit\&quot;,     \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       }     }   },   \&quot;attributes\&quot;: [],   \&quot;type\&quot;: \&quot;commit_file\&quot;,   \&quot;size\&quot;: 0 } &#x60;&#x60;&#x60;  File objects contain an &#x60;attributes&#x60; element that contains a list of possible modifiers. Currently defined values are:  * &#x60;link&#x60; -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * &#x60;executable&#x60; -- indicates that the file has the executable bit set. * &#x60;subrepository&#x60; -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * &#x60;binary&#x60; -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file&#39;s size without incurring the overhead of receiving its full contents.   #### Directory listings  When &#x60;path&#x60; points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;path\&quot;: \&quot;tests/test_project\&quot;,       \&quot;type\&quot;: \&quot;commit_directory\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;         }       },       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       }     },     {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;         }       },       \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       },       \&quot;attributes\&quot;: [],       \&quot;type\&quot;: \&quot;commit_file\&quot;,       \&quot;size\&quot;: 0     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  When listing the contents of the repo&#39;s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \&quot;walk\&quot; the entire directory tree, the client can either parse each response and follow the &#x60;self&#x60; links of each &#x60;commit_directory&#x60; object, or can specify a &#x60;max_depth&#x60; to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the &#x60;max_depth&#x60; parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a &#x60;commit_file&#x60;, or a &#x60;commit_directory&#x60;, both of which contain a &#x60;path&#x60; element. This path is the absolute path from the root of the repository. Each object also contains a &#x60;commit&#x60; object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their &#x60;self&#x60; link returns the paginated contents of the directory. The &#x60;meta&#x60; link on the other hand returns the actual &#x60;directory&#x60; object itself, e.g.:  &#x60;&#x60;&#x60;javascript {   \&quot;path\&quot;: \&quot;tests/test_project\&quot;,   \&quot;type\&quot;: \&quot;commit_directory\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;     }   },   \&quot;commit\&quot;: { ... } } &#x60;&#x60;&#x60;  #### Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  &#x60;size &gt; 1024 and attributes &#x3D; \&quot;binary\&quot;&#x60;  which after urlencoding yields the query string:  &#x60;?q&#x3D;size%3E1024+and+attributes%3D%22binary%22&#x60;  To change the ordering of the response, use the &#x60;?sort&#x60; parameter:  &#x60;.../src/eefd5ef/?sort&#x3D;-size&#x60;  See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * @param commit The commit&#39;s SHA1. (required)
     * @param path Path to the file. (required)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param format If &#39;meta&#39; is provided, returns the (json) meta data for the contents of the file.  If &#39;rendered&#39; is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. Since Git does not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file&#39;s actual contents. (optional)
     * @param q Optional filter expression as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort Optional sorting parameter as per [filtering and sorting](/cloud/bitbucket/rest/intro/#sorting-query-results). (optional)
     * @param maxDepth If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If the path matches a file, then the raw contents of the file are returned.  If the &#x60;format&#x3D;meta&#x60; query parameter is provided, a json document containing the file&#39;s meta data is returned.  If the &#x60;format&#x3D;rendered&#x60; query parameter is provided, the contents of the file in HTML-formated rendered markup is returned. If the path matches a directory, then a paginated list of file and directory entries is returned (if the &#x60;format&#x3D;meta&#x60; query parameter was provided, then the json document containing the directory&#39;s meta data is returned.)  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the path or commit in the URL does not exist. </td><td>  -  </td></tr>
        <tr><td> 555 </td><td> If the call times out, possibly because the specified recursion depth is too large. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugSrcCommitPathGet_0Async(String commit, String path, String repoSlug, String workspace, String format, String q, String sort, Integer maxDepth, final ApiCallback<PaginatedTreeentries> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugSrcCommitPathGet_0ValidateBeforeCall(commit, path, repoSlug, workspace, format, q, sort, maxDepth, _callback);
        Type localVarReturnType = new TypeToken<PaginatedTreeentries>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugSrcGet_0
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param format Instead of returning the file&#39;s contents, return the (json) meta data for it. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If the path matches a file, then the raw contents of the file are returned (unless the &#x60;format&#x3D;meta&#x60; query parameter was provided, in which case a json document containing the file&#39;s meta data is returned). If the path matches a directory, then a paginated list of file and directory entries is returned (if the &#x60;format&#x3D;meta&#x60; query parameter was provided, then the json document containing the directory&#39;s meta data is returned).  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the path or commit in the URL does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugSrcGet_0Call(String repoSlug, String workspace, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/src"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugSrcGet_0ValidateBeforeCall(String repoSlug, String workspace, String format, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugSrcGet_0(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugSrcGet_0(Async)");
        }

        return repositoriesWorkspaceRepoSlugSrcGet_0Call(repoSlug, workspace, format, _callback);

    }

    /**
     * Get the root directory of the main branch
     * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo&#39;s main branch.  To create new commits, [POST to this endpoint](#post)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param format Instead of returning the file&#39;s contents, return the (json) meta data for it. (optional)
     * @return PaginatedTreeentries
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If the path matches a file, then the raw contents of the file are returned (unless the &#x60;format&#x3D;meta&#x60; query parameter was provided, in which case a json document containing the file&#39;s meta data is returned). If the path matches a directory, then a paginated list of file and directory entries is returned (if the &#x60;format&#x3D;meta&#x60; query parameter was provided, then the json document containing the directory&#39;s meta data is returned).  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the path or commit in the URL does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedTreeentries repositoriesWorkspaceRepoSlugSrcGet_0(String repoSlug, String workspace, String format) throws ApiException {
        ApiResponse<PaginatedTreeentries> localVarResp = repositoriesWorkspaceRepoSlugSrcGet_0WithHttpInfo(repoSlug, workspace, format);
        return localVarResp.getData();
    }

    /**
     * Get the root directory of the main branch
     * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo&#39;s main branch.  To create new commits, [POST to this endpoint](#post)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param format Instead of returning the file&#39;s contents, return the (json) meta data for it. (optional)
     * @return ApiResponse&lt;PaginatedTreeentries&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If the path matches a file, then the raw contents of the file are returned (unless the &#x60;format&#x3D;meta&#x60; query parameter was provided, in which case a json document containing the file&#39;s meta data is returned). If the path matches a directory, then a paginated list of file and directory entries is returned (if the &#x60;format&#x3D;meta&#x60; query parameter was provided, then the json document containing the directory&#39;s meta data is returned).  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the path or commit in the URL does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedTreeentries> repositoriesWorkspaceRepoSlugSrcGet_0WithHttpInfo(String repoSlug, String workspace, String format) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugSrcGet_0ValidateBeforeCall(repoSlug, workspace, format, null);
        Type localVarReturnType = new TypeToken<PaginatedTreeentries>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get the root directory of the main branch (asynchronously)
     * This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo&#39;s main branch.  To create new commits, [POST to this endpoint](#post)
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param format Instead of returning the file&#39;s contents, return the (json) meta data for it. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If the path matches a file, then the raw contents of the file are returned (unless the &#x60;format&#x3D;meta&#x60; query parameter was provided, in which case a json document containing the file&#39;s meta data is returned). If the path matches a directory, then a paginated list of file and directory entries is returned (if the &#x60;format&#x3D;meta&#x60; query parameter was provided, then the json document containing the directory&#39;s meta data is returned).  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the path or commit in the URL does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugSrcGet_0Async(String repoSlug, String workspace, String format, final ApiCallback<PaginatedTreeentries> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugSrcGet_0ValidateBeforeCall(repoSlug, workspace, format, _callback);
        Type localVarReturnType = new TypeToken<PaginatedTreeentries>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugSrcPost_0
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param message The commit message. When omitted, Bitbucket uses a canned string. (optional)
     * @param author  The raw string to be used as the new commit&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user&#39;s full/display name and primary email address. Commits cannot be created anonymously. (optional)
     * @param parents  A comma-separated list of SHA1s of the commits that should be the parents of the newly created commit.  When omitted, the new commit will inherit from and become a child of the main branch&#39;s tip/HEAD commit.  When more than one SHA1 is provided, the first SHA1 identifies the commit from which the content will be inherited.\&quot;. (optional)
     * @param files  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit.  (optional)
     * @param branch  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo&#39;s root commit and also define the repo&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td>   </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have write or admin access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugSrcPost_0Call(String repoSlug, String workspace, String message, String author, String parents, String files, String branch, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/src"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (message != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("message", message));
        }

        if (author != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("author", author));
        }

        if (parents != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("parents", parents));
        }

        if (files != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("files", files));
        }

        if (branch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("branch", branch));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugSrcPost_0ValidateBeforeCall(String repoSlug, String workspace, String message, String author, String parents, String files, String branch, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugSrcPost_0(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugSrcPost_0(Async)");
        }

        return repositoriesWorkspaceRepoSlugSrcPost_0Call(repoSlug, workspace, message, author, parents, files, branch, _callback);

    }

    /**
     * Create a commit by uploading a file
     * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png&#x3D;@image.png &#x60;&#x60;&#x60;  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the &#x60;image.png&#x60; file to the repository in the &#x60;/repo/path/to&#x60; directory.  To create a commit that deletes files, use the &#x60;files&#x60; parameter:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files&#x3D;/file/to/delete/1.txt \\   -F files&#x3D;/file/to/delete/2.txt &#x60;&#x60;&#x60;  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts &#x60;multipart/form-data&#x60; (as in the examples above), as well as &#x60;application/x-www-form-urlencoded&#x60;.  #### multipart/form-data  A &#x60;multipart/form-data&#x60; post contains a series of \&quot;form fields\&quot; that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a &#x60;Content-Disposition&#x60; parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above &#x60;curl&#x60; example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For &#x60;multipart/form-data&#x60; bodies that should not lead to any ambiguity, as the &#x60;Content-Disposition&#x60; header will contain the &#x60;filename&#x60; parameter to distinguish between a file named \&quot;message\&quot; and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple &#x60;application/x-www-form-urlencoded&#x60; POST. This can be convenient when uploading pure text files:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \&quot;/path/to/me.txt&#x3D;Lorem ipsum.\&quot; \\   --data-urlencode \&quot;message&#x3D;Initial commit\&quot; \\   --data-urlencode \&quot;author&#x3D;Erik van Zijst &lt;erik.van.zijst@gmail.com&gt;\&quot; &#x60;&#x60;&#x60;  There could be a field name clash if a client were to upload a file named \&quot;message\&quot;, as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. &#x60;curl --data-urlencode \&quot;/message&#x3D;file contents\&quot;&#x60;.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a &#x60;x-attributes&#x60; value in the &#x60;Content-Disposition&#x60; header. For example, to upload an executable file, as well as create a symlink from &#x60;README.txt&#x60; to &#x60;README&#x60;:  &#x60;&#x60;&#x60; --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;bin/shutdown.sh\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;shutdown.sh\&quot;; x-attributes:\&quot;executable\&quot;  #!/bin/sh halt  --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;/README.txt\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;README.txt\&quot;; x-attributes:\&quot;link\&quot;  README --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;-- &#x60;&#x60;&#x60;  Links are files that contain the target path and have &#x60;x-attributes:\&quot;link\&quot;&#x60; set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying &#x60;x-attributes&#x3D;\&quot;link\&quot;&#x60; will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include &#x60;x-attributes&#x3D;\&quot;executable\&quot;&#x60; in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param message The commit message. When omitted, Bitbucket uses a canned string. (optional)
     * @param author  The raw string to be used as the new commit&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user&#39;s full/display name and primary email address. Commits cannot be created anonymously. (optional)
     * @param parents  A comma-separated list of SHA1s of the commits that should be the parents of the newly created commit.  When omitted, the new commit will inherit from and become a child of the main branch&#39;s tip/HEAD commit.  When more than one SHA1 is provided, the first SHA1 identifies the commit from which the content will be inherited.\&quot;. (optional)
     * @param files  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit.  (optional)
     * @param branch  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo&#39;s root commit and also define the repo&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty.  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td>   </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have write or admin access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public void repositoriesWorkspaceRepoSlugSrcPost_0(String repoSlug, String workspace, String message, String author, String parents, String files, String branch) throws ApiException {
        repositoriesWorkspaceRepoSlugSrcPost_0WithHttpInfo(repoSlug, workspace, message, author, parents, files, branch);
    }

    /**
     * Create a commit by uploading a file
     * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png&#x3D;@image.png &#x60;&#x60;&#x60;  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the &#x60;image.png&#x60; file to the repository in the &#x60;/repo/path/to&#x60; directory.  To create a commit that deletes files, use the &#x60;files&#x60; parameter:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files&#x3D;/file/to/delete/1.txt \\   -F files&#x3D;/file/to/delete/2.txt &#x60;&#x60;&#x60;  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts &#x60;multipart/form-data&#x60; (as in the examples above), as well as &#x60;application/x-www-form-urlencoded&#x60;.  #### multipart/form-data  A &#x60;multipart/form-data&#x60; post contains a series of \&quot;form fields\&quot; that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a &#x60;Content-Disposition&#x60; parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above &#x60;curl&#x60; example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For &#x60;multipart/form-data&#x60; bodies that should not lead to any ambiguity, as the &#x60;Content-Disposition&#x60; header will contain the &#x60;filename&#x60; parameter to distinguish between a file named \&quot;message\&quot; and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple &#x60;application/x-www-form-urlencoded&#x60; POST. This can be convenient when uploading pure text files:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \&quot;/path/to/me.txt&#x3D;Lorem ipsum.\&quot; \\   --data-urlencode \&quot;message&#x3D;Initial commit\&quot; \\   --data-urlencode \&quot;author&#x3D;Erik van Zijst &lt;erik.van.zijst@gmail.com&gt;\&quot; &#x60;&#x60;&#x60;  There could be a field name clash if a client were to upload a file named \&quot;message\&quot;, as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. &#x60;curl --data-urlencode \&quot;/message&#x3D;file contents\&quot;&#x60;.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a &#x60;x-attributes&#x60; value in the &#x60;Content-Disposition&#x60; header. For example, to upload an executable file, as well as create a symlink from &#x60;README.txt&#x60; to &#x60;README&#x60;:  &#x60;&#x60;&#x60; --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;bin/shutdown.sh\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;shutdown.sh\&quot;; x-attributes:\&quot;executable\&quot;  #!/bin/sh halt  --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;/README.txt\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;README.txt\&quot;; x-attributes:\&quot;link\&quot;  README --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;-- &#x60;&#x60;&#x60;  Links are files that contain the target path and have &#x60;x-attributes:\&quot;link\&quot;&#x60; set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying &#x60;x-attributes&#x3D;\&quot;link\&quot;&#x60; will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include &#x60;x-attributes&#x3D;\&quot;executable\&quot;&#x60; in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param message The commit message. When omitted, Bitbucket uses a canned string. (optional)
     * @param author  The raw string to be used as the new commit&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user&#39;s full/display name and primary email address. Commits cannot be created anonymously. (optional)
     * @param parents  A comma-separated list of SHA1s of the commits that should be the parents of the newly created commit.  When omitted, the new commit will inherit from and become a child of the main branch&#39;s tip/HEAD commit.  When more than one SHA1 is provided, the first SHA1 identifies the commit from which the content will be inherited.\&quot;. (optional)
     * @param files  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit.  (optional)
     * @param branch  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo&#39;s root commit and also define the repo&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty.  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td>   </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have write or admin access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> repositoriesWorkspaceRepoSlugSrcPost_0WithHttpInfo(String repoSlug, String workspace, String message, String author, String parents, String files, String branch) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugSrcPost_0ValidateBeforeCall(repoSlug, workspace, message, author, parents, files, branch, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Create a commit by uploading a file (asynchronously)
     * This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png&#x3D;@image.png &#x60;&#x60;&#x60;  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the &#x60;image.png&#x60; file to the repository in the &#x60;/repo/path/to&#x60; directory.  To create a commit that deletes files, use the &#x60;files&#x60; parameter:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files&#x3D;/file/to/delete/1.txt \\   -F files&#x3D;/file/to/delete/2.txt &#x60;&#x60;&#x60;  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts &#x60;multipart/form-data&#x60; (as in the examples above), as well as &#x60;application/x-www-form-urlencoded&#x60;.  #### multipart/form-data  A &#x60;multipart/form-data&#x60; post contains a series of \&quot;form fields\&quot; that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a &#x60;Content-Disposition&#x60; parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above &#x60;curl&#x60; example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For &#x60;multipart/form-data&#x60; bodies that should not lead to any ambiguity, as the &#x60;Content-Disposition&#x60; header will contain the &#x60;filename&#x60; parameter to distinguish between a file named \&quot;message\&quot; and the commit message field.  #### application/x-www-form-urlencoded  It is also possible to upload new files using a simple &#x60;application/x-www-form-urlencoded&#x60; POST. This can be convenient when uploading pure text files:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \&quot;/path/to/me.txt&#x3D;Lorem ipsum.\&quot; \\   --data-urlencode \&quot;message&#x3D;Initial commit\&quot; \\   --data-urlencode \&quot;author&#x3D;Erik van Zijst &lt;erik.van.zijst@gmail.com&gt;\&quot; &#x60;&#x60;&#x60;  There could be a field name clash if a client were to upload a file named \&quot;message\&quot;, as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. &#x60;curl --data-urlencode \&quot;/message&#x3D;file contents\&quot;&#x60;.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  #### Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a &#x60;x-attributes&#x60; value in the &#x60;Content-Disposition&#x60; header. For example, to upload an executable file, as well as create a symlink from &#x60;README.txt&#x60; to &#x60;README&#x60;:  &#x60;&#x60;&#x60; --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;bin/shutdown.sh\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;shutdown.sh\&quot;; x-attributes:\&quot;executable\&quot;  #!/bin/sh halt  --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;/README.txt\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;README.txt\&quot;; x-attributes:\&quot;link\&quot;  README --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;-- &#x60;&#x60;&#x60;  Links are files that contain the target path and have &#x60;x-attributes:\&quot;link\&quot;&#x60; set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying &#x60;x-attributes&#x3D;\&quot;link\&quot;&#x60; will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include &#x60;x-attributes&#x3D;\&quot;executable\&quot;&#x60; in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param message The commit message. When omitted, Bitbucket uses a canned string. (optional)
     * @param author  The raw string to be used as the new commit&#39;s author. This string follows the format &#x60;Erik van Zijst &lt;evzijst@atlassian.com&gt;&#x60;.  When omitted, Bitbucket uses the authenticated user&#39;s full/display name and primary email address. Commits cannot be created anonymously. (optional)
     * @param parents  A comma-separated list of SHA1s of the commits that should be the parents of the newly created commit.  When omitted, the new commit will inherit from and become a child of the main branch&#39;s tip/HEAD commit.  When more than one SHA1 is provided, the first SHA1 identifies the commit from which the content will be inherited.\&quot;. (optional)
     * @param files  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this &#x60;files&#x60; meta data field is redundant. However, when the &#x60;files&#x60; field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit.  (optional)
     * @param branch  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch&#39;s new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch&#39;s tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch&#39;s tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch&#39;s current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo&#39;s root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo&#39;s root commit and also define the repo&#39;s main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with &#x60;parents&#x60;, but omitting the &#x60;files&#x60; fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td>   </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> If the authenticated user does not have write or admin access </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> If the repository does not exist. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugSrcPost_0Async(String repoSlug, String workspace, String message, String author, String parents, String files, String branch, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugSrcPost_0ValidateBeforeCall(repoSlug, workspace, message, author, parents, files, branch, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for repositoriesWorkspaceRepoSlugWatchersGet
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of all the watchers on the specified repository. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugWatchersGetCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/repositories/{workspace}/{repo_slug}/watchers"
            .replace("{" + "repo_slug" + "}", localVarApiClient.escapeString(repoSlug.toString()))
            .replace("{" + "workspace" + "}", localVarApiClient.escapeString(workspace.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repositoriesWorkspaceRepoSlugWatchersGetValidateBeforeCall(String repoSlug, String workspace, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'repoSlug' is set
        if (repoSlug == null) {
            throw new ApiException("Missing the required parameter 'repoSlug' when calling repositoriesWorkspaceRepoSlugWatchersGet(Async)");
        }

        // verify the required parameter 'workspace' is set
        if (workspace == null) {
            throw new ApiException("Missing the required parameter 'workspace' when calling repositoriesWorkspaceRepoSlugWatchersGet(Async)");
        }

        return repositoriesWorkspaceRepoSlugWatchersGetCall(repoSlug, workspace, _callback);

    }

    /**
     * List repositories watchers
     * Returns a paginated list of all the watchers on the specified repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return PaginatedAccounts
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of all the watchers on the specified repository. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedAccounts repositoriesWorkspaceRepoSlugWatchersGet(String repoSlug, String workspace) throws ApiException {
        ApiResponse<PaginatedAccounts> localVarResp = repositoriesWorkspaceRepoSlugWatchersGetWithHttpInfo(repoSlug, workspace);
        return localVarResp.getData();
    }

    /**
     * List repositories watchers
     * Returns a paginated list of all the watchers on the specified repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @return ApiResponse&lt;PaginatedAccounts&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of all the watchers on the specified repository. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedAccounts> repositoriesWorkspaceRepoSlugWatchersGetWithHttpInfo(String repoSlug, String workspace) throws ApiException {
        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugWatchersGetValidateBeforeCall(repoSlug, workspace, null);
        Type localVarReturnType = new TypeToken<PaginatedAccounts>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List repositories watchers (asynchronously)
     * Returns a paginated list of all the watchers on the specified repository.
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;.  (required)
     * @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: &#x60;{workspace UUID}&#x60;.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A paginated list of all the watchers on the specified repository. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call repositoriesWorkspaceRepoSlugWatchersGetAsync(String repoSlug, String workspace, final ApiCallback<PaginatedAccounts> _callback) throws ApiException {

        okhttp3.Call localVarCall = repositoriesWorkspaceRepoSlugWatchersGetValidateBeforeCall(repoSlug, workspace, _callback);
        Type localVarReturnType = new TypeToken<PaginatedAccounts>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for userPermissionsRepositoriesGet
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Repository permissions for the repositories a caller has explicit access to. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call userPermissionsRepositoriesGetCall(String q, String sort, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/user/permissions/repositories";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (q != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("q", q));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "oauth2", "basic" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call userPermissionsRepositoriesGetValidateBeforeCall(String q, String sort, final ApiCallback _callback) throws ApiException {
        return userPermissionsRepositoriesGetCall(q, sort, _callback);

    }

    /**
     * List repository permissions for a user
     * Returns an object for each repository the caller has explicit access to and their effective permission — the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between explicit and implicit privileges.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/user/permissions/repositories  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository or permission by adding the following query string parameters:  * &#x60;q&#x3D;repository.name&#x3D;\&quot;geordi\&quot;&#x60; or &#x60;q&#x3D;permission&gt;\&quot;read\&quot;&#x60; * &#x60;sort&#x3D;repository.name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @return PaginatedRepositoryPermissions
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Repository permissions for the repositories a caller has explicit access to. </td><td>  -  </td></tr>
     </table>
     */
    public PaginatedRepositoryPermissions userPermissionsRepositoriesGet(String q, String sort) throws ApiException {
        ApiResponse<PaginatedRepositoryPermissions> localVarResp = userPermissionsRepositoriesGetWithHttpInfo(q, sort);
        return localVarResp.getData();
    }

    /**
     * List repository permissions for a user
     * Returns an object for each repository the caller has explicit access to and their effective permission — the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between explicit and implicit privileges.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/user/permissions/repositories  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository or permission by adding the following query string parameters:  * &#x60;q&#x3D;repository.name&#x3D;\&quot;geordi\&quot;&#x60; or &#x60;q&#x3D;permission&gt;\&quot;read\&quot;&#x60; * &#x60;sort&#x3D;repository.name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @return ApiResponse&lt;PaginatedRepositoryPermissions&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Repository permissions for the repositories a caller has explicit access to. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PaginatedRepositoryPermissions> userPermissionsRepositoriesGetWithHttpInfo(String q, String sort) throws ApiException {
        okhttp3.Call localVarCall = userPermissionsRepositoriesGetValidateBeforeCall(q, sort, null);
        Type localVarReturnType = new TypeToken<PaginatedRepositoryPermissions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List repository permissions for a user (asynchronously)
     * Returns an object for each repository the caller has explicit access to and their effective permission — the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between explicit and implicit privileges.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/user/permissions/repositories  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by repository or permission by adding the following query string parameters:  * &#x60;q&#x3D;repository.name&#x3D;\&quot;geordi\&quot;&#x60; or &#x60;q&#x3D;permission&gt;\&quot;read\&quot;&#x60; * &#x60;sort&#x3D;repository.name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.
     * @param q  Query string to narrow down the response as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param sort  Name of a response property sort the result by as per [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Repository permissions for the repositories a caller has explicit access to. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call userPermissionsRepositoriesGetAsync(String q, String sort, final ApiCallback<PaginatedRepositoryPermissions> _callback) throws ApiException {

        okhttp3.Call localVarCall = userPermissionsRepositoriesGetValidateBeforeCall(q, sort, _callback);
        Type localVarReturnType = new TypeToken<PaginatedRepositoryPermissions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
