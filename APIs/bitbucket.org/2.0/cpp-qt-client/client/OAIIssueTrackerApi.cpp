/**
 * Bitbucket API
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIIssueTrackerApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIIssueTrackerApi::OAIIssueTrackerApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIIssueTrackerApi::~OAIIssueTrackerApi() {
}

void OAIIssueTrackerApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://api.bitbucket.org/2.0"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugComponentsComponentIdGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugComponentsComponentIdGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugComponentsGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugComponentsGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesExportPost", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesExportPost", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesImportGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesImportGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesImportPost", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesImportPost", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdDelete", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdDelete", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdPut", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdPut", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugIssuesPost", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugIssuesPost", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugMilestonesGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugMilestonesGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugVersionsGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugVersionsGet", 0);
    _serverConfigs.insert("repositoriesWorkspaceRepoSlugVersionsVersionIdGet", defaultConf);
    _serverIndices.insert("repositoriesWorkspaceRepoSlugVersionsVersionIdGet", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIIssueTrackerApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIIssueTrackerApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIIssueTrackerApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIIssueTrackerApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIIssueTrackerApi::setUsername(const QString &username) {
    _username = username;
}

void OAIIssueTrackerApi::setPassword(const QString &password) {
    _password = password;
}


void OAIIssueTrackerApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIIssueTrackerApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIIssueTrackerApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIIssueTrackerApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIIssueTrackerApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIIssueTrackerApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIIssueTrackerApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIIssueTrackerApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIIssueTrackerApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIIssueTrackerApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIIssueTrackerApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIIssueTrackerApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIIssueTrackerApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugComponentsComponentIdGet(const qint32 &component_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugComponentsComponentIdGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugComponentsComponentIdGet")].URL()+"/repositories/{workspace}/{repo_slug}/components/{component_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString component_idPathParam("{");
        component_idPathParam.append("component_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "component_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"component_id"+pathSuffix : pathPrefix;
        fullPath.replace(component_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(component_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugComponentsComponentIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugComponentsComponentIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugComponentsComponentIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIComponent output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugComponentsComponentIdGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugComponentsComponentIdGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugComponentsComponentIdGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugComponentsComponentIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugComponentsComponentIdGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugComponentsComponentIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugComponentsGet(const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugComponentsGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugComponentsGet")].URL()+"/repositories/{workspace}/{repo_slug}/components");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugComponentsGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugComponentsGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugComponentsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaginated_components output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugComponentsGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugComponentsGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugComponentsGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugComponentsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugComponentsGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugComponentsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesExportPost(const QString &repo_slug, const QString &workspace, const ::OpenAPI::OptionalParam<OAIExport_options> &oai_export_options) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesExportPost"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesExportPost")].URL()+"/repositories/{workspace}/{repo_slug}/issues/export");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if (oai_export_options.hasValue()){

        
        QByteArray output = oai_export_options.value().asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesExportPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    scope.append("repository:admin");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesExportPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesExportPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportPostSignal();
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportPostSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        scope.append("repository:admin");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportPostSignalE(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportPostSignalError(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(const QString &repo_name, const QString &repo_slug, const QString &task_id, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_namePathParam("{");
        repo_namePathParam.append("repo_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_name"+pathSuffix : pathPrefix;
        fullPath.replace(repo_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_name)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString task_idPathParam("{");
        task_idPathParam.append("task_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "task_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"task_id"+pathSuffix : pathPrefix;
        fullPath.replace(task_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(task_id)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    scope.append("repository:admin");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue_job_status output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        scope.append("repository:admin");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesGet(const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaginated_issues output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesImportGet(const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesImportGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesImportGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/import");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesImportGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    scope.append("repository:admin");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesImportGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesImportGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue_job_status output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        scope.append("repository:admin");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesImportPost(const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesImportPost"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesImportPost")].URL()+"/repositories/{workspace}/{repo_slug}/issues/import");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesImportPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    scope.append("repository:admin");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesImportPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesImportPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue_job_status output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportPostSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportPostSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        scope.append("repository:admin");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportPostSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportPostSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesImportPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaginated_issue_attachments output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(const QString &issue_id, const QString &path, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString pathPathParam("{");
        pathPathParam.append("path").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "path", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"path"+pathSuffix : pathPrefix;
        fullPath.replace(pathPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(path)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteSignal();
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteSignalE(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteSignalError(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(const QString &issue_id, const QString &path, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString pathPathParam("{");
        pathPathParam.append("path").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "path", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"path"+pathSuffix : pathPrefix;
        fullPath.replace(pathPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(path)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetSignal();
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetSignalE(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetSignalError(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostSignal();
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostSignalE(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostSignalError(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(const QString &change_id, const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes/{change_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString change_idPathParam("{");
        change_idPathParam.append("change_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "change_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"change_id"+pathSuffix : pathPrefix;
        fullPath.replace(change_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(change_id)));
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue_change output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(const QString &issue_id, const QString &repo_slug, const QString &workspace, const ::OpenAPI::OptionalParam<QString> &q, const ::OpenAPI::OptionalParam<QString> &sort) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (q.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "q", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("q")).append(querySuffix).append(QUrl::toPercentEncoding(q.stringValue()));
    }
    if (sort.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "sort", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("sort")).append(querySuffix).append(QUrl::toPercentEncoding(sort.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaginated_log_entries output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(const QString &issue_id, const QString &repo_slug, const QString &workspace, const OAIIssue_change &oai_issue_change) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_issue_change.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue_change output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(const qint32 &comment_id, const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString comment_idPathParam("{");
        comment_idPathParam.append("comment_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "comment_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"comment_id"+pathSuffix : pathPrefix;
        fullPath.replace(comment_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(comment_id)));
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteSignal();
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteSignalE(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteSignalError(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(const qint32 &comment_id, const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString comment_idPathParam("{");
        comment_idPathParam.append("comment_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "comment_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"comment_id"+pathSuffix : pathPrefix;
        fullPath.replace(comment_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(comment_id)));
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue_comment output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(const qint32 &comment_id, const QString &issue_id, const QString &repo_slug, const QString &workspace, const OAIIssue_comment &oai_issue_comment) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString comment_idPathParam("{");
        comment_idPathParam.append("comment_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "comment_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"comment_id"+pathSuffix : pathPrefix;
        fullPath.replace(comment_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(comment_id)));
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_issue_comment.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue_comment output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(const QString &issue_id, const QString &repo_slug, const QString &workspace, const ::OpenAPI::OptionalParam<QString> &q) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (q.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "q", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("q")).append(querySuffix).append(QUrl::toPercentEncoding(q.stringValue()));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaginated_issue_comments output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(const QString &issue_id, const QString &repo_slug, const QString &workspace, const OAIIssue_comment &oai_issue_comment) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_issue_comment.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostSignal();
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostSignalE(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostSignalError(error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdDelete"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdDelete")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdDeleteSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdDeleteSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdDeleteSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdDeleteSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdGet(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdPut(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdPut"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdPut")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdPutCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdPutCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdPutSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdPutSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdPutSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdPutSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("account:write");
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIError output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("account:write");
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("account");
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIError output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("account");
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVotePutCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("account:write");
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVotePutCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdVotePutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIError output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVotePutSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVotePutSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("account:write");
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVotePutSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVotePutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVotePutSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdVotePutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("account:write");
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIError output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("account:write");
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDeleteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("account");
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIError output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("account");
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(const QString &issue_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut")].URL()+"/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString issue_idPathParam("{");
        issue_idPathParam.append("issue_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "issue_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"issue_id"+pathSuffix : pathPrefix;
        fullPath.replace(issue_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(issue_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("account:write");
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIError output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("account:write");
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPutSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesPost(const QString &repo_slug, const QString &workspace, const OAIIssue &oai_issue) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugIssuesPost"][_serverIndices.value("repositoriesWorkspaceRepoSlugIssuesPost")].URL()+"/repositories/{workspace}/{repo_slug}/issues");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_issue.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue:write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesPostCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugIssuesPostCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIIssue output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesPostSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesPostSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue:write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesPostSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesPostSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugIssuesPostSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugIssuesPostSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugMilestonesGet(const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugMilestonesGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugMilestonesGet")].URL()+"/repositories/{workspace}/{repo_slug}/milestones");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugMilestonesGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugMilestonesGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugMilestonesGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaginated_milestones output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(const qint32 &milestone_id, const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet")].URL()+"/repositories/{workspace}/{repo_slug}/milestones/{milestone_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString milestone_idPathParam("{");
        milestone_idPathParam.append("milestone_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "milestone_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"milestone_id"+pathSuffix : pathPrefix;
        fullPath.replace(milestone_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(milestone_id)));
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMilestone output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugVersionsGet(const QString &repo_slug, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugVersionsGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugVersionsGet")].URL()+"/repositories/{workspace}/{repo_slug}/versions");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugVersionsGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugVersionsGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugVersionsGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPaginated_versions output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugVersionsGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugVersionsGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugVersionsGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugVersionsGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugVersionsGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugVersionsGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugVersionsVersionIdGet(const QString &repo_slug, const qint32 &version_id, const QString &workspace) {
    QString fullPath = QString(_serverConfigs["repositoriesWorkspaceRepoSlugVersionsVersionIdGet"][_serverIndices.value("repositoriesWorkspaceRepoSlugVersionsVersionIdGet")].URL()+"/repositories/{workspace}/{repo_slug}/versions/{version_id}");
    
    if (_apiKeys.contains("api_key")) {
        addHeaders("api_key",_apiKeys.find("api_key").value());
    }
    
    if (!_username.isEmpty() && !_password.isEmpty()) {
        QByteArray b64;
        b64.append(_username.toUtf8() + ":" + _password.toUtf8());
        addHeaders("Authorization","Basic " + b64.toBase64());
    }
    
    {
        QString repo_slugPathParam("{");
        repo_slugPathParam.append("repo_slug").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "repo_slug", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"repo_slug"+pathSuffix : pathPrefix;
        fullPath.replace(repo_slugPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(repo_slug)));
    }
    
    {
        QString version_idPathParam("{");
        version_idPathParam.append("version_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "version_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"version_id"+pathSuffix : pathPrefix;
        fullPath.replace(version_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(version_id)));
    }
    
    {
        QString workspacePathParam("{");
        workspacePathParam.append("workspace").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "workspace", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"workspace"+pathSuffix : pathPrefix;
        fullPath.replace(workspacePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(workspace)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugVersionsVersionIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this]() {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("issue");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugVersionsVersionIdGetCallback);
    connect(this, &OAIIssueTrackerApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIIssueTrackerApi::repositoriesWorkspaceRepoSlugVersionsVersionIdGetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIVersion output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT repositoriesWorkspaceRepoSlugVersionsVersionIdGetSignal(output);
        Q_EMIT repositoriesWorkspaceRepoSlugVersionsVersionIdGetSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("issue");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://bitbucket.org/site/oauth2/authorize");
        QString tokenUrl("https://bitbucket.org/site/oauth2/access_token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugVersionsVersionIdGetSignalE(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugVersionsVersionIdGetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT repositoriesWorkspaceRepoSlugVersionsVersionIdGetSignalError(output, error_type, error_str);
        Q_EMIT repositoriesWorkspaceRepoSlugVersionsVersionIdGetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIIssueTrackerApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace OpenAPI
