/**
 * Metadata API
 * The Metadata API has operations that retrieve configuration details pertaining to the different eBay marketplaces. In addition to marketplace information, the API also has operations that get information that helps sellers list items on eBay.
 *
 * The version of the OpenAPI document: v1.6.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAutomotivePartsCompatibilityPolicy.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAutomotivePartsCompatibilityPolicy::OAIAutomotivePartsCompatibilityPolicy(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAutomotivePartsCompatibilityPolicy::OAIAutomotivePartsCompatibilityPolicy() {
    this->initializeModel();
}

OAIAutomotivePartsCompatibilityPolicy::~OAIAutomotivePartsCompatibilityPolicy() {}

void OAIAutomotivePartsCompatibilityPolicy::initializeModel() {

    m_category_id_isSet = false;
    m_category_id_isValid = false;

    m_category_tree_id_isSet = false;
    m_category_tree_id_isValid = false;

    m_compatibility_based_on_isSet = false;
    m_compatibility_based_on_isValid = false;

    m_compatible_vehicle_types_isSet = false;
    m_compatible_vehicle_types_isValid = false;

    m_max_number_of_compatible_vehicles_isSet = false;
    m_max_number_of_compatible_vehicles_isValid = false;
}

void OAIAutomotivePartsCompatibilityPolicy::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAutomotivePartsCompatibilityPolicy::fromJsonObject(QJsonObject json) {

    m_category_id_isValid = ::OpenAPI::fromJsonValue(m_category_id, json[QString("categoryId")]);
    m_category_id_isSet = !json[QString("categoryId")].isNull() && m_category_id_isValid;

    m_category_tree_id_isValid = ::OpenAPI::fromJsonValue(m_category_tree_id, json[QString("categoryTreeId")]);
    m_category_tree_id_isSet = !json[QString("categoryTreeId")].isNull() && m_category_tree_id_isValid;

    m_compatibility_based_on_isValid = ::OpenAPI::fromJsonValue(m_compatibility_based_on, json[QString("compatibilityBasedOn")]);
    m_compatibility_based_on_isSet = !json[QString("compatibilityBasedOn")].isNull() && m_compatibility_based_on_isValid;

    m_compatible_vehicle_types_isValid = ::OpenAPI::fromJsonValue(m_compatible_vehicle_types, json[QString("compatibleVehicleTypes")]);
    m_compatible_vehicle_types_isSet = !json[QString("compatibleVehicleTypes")].isNull() && m_compatible_vehicle_types_isValid;

    m_max_number_of_compatible_vehicles_isValid = ::OpenAPI::fromJsonValue(m_max_number_of_compatible_vehicles, json[QString("maxNumberOfCompatibleVehicles")]);
    m_max_number_of_compatible_vehicles_isSet = !json[QString("maxNumberOfCompatibleVehicles")].isNull() && m_max_number_of_compatible_vehicles_isValid;
}

QString OAIAutomotivePartsCompatibilityPolicy::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAutomotivePartsCompatibilityPolicy::asJsonObject() const {
    QJsonObject obj;
    if (m_category_id_isSet) {
        obj.insert(QString("categoryId"), ::OpenAPI::toJsonValue(m_category_id));
    }
    if (m_category_tree_id_isSet) {
        obj.insert(QString("categoryTreeId"), ::OpenAPI::toJsonValue(m_category_tree_id));
    }
    if (m_compatibility_based_on_isSet) {
        obj.insert(QString("compatibilityBasedOn"), ::OpenAPI::toJsonValue(m_compatibility_based_on));
    }
    if (m_compatible_vehicle_types.size() > 0) {
        obj.insert(QString("compatibleVehicleTypes"), ::OpenAPI::toJsonValue(m_compatible_vehicle_types));
    }
    if (m_max_number_of_compatible_vehicles_isSet) {
        obj.insert(QString("maxNumberOfCompatibleVehicles"), ::OpenAPI::toJsonValue(m_max_number_of_compatible_vehicles));
    }
    return obj;
}

QString OAIAutomotivePartsCompatibilityPolicy::getCategoryId() const {
    return m_category_id;
}
void OAIAutomotivePartsCompatibilityPolicy::setCategoryId(const QString &category_id) {
    m_category_id = category_id;
    m_category_id_isSet = true;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_category_id_Set() const{
    return m_category_id_isSet;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_category_id_Valid() const{
    return m_category_id_isValid;
}

QString OAIAutomotivePartsCompatibilityPolicy::getCategoryTreeId() const {
    return m_category_tree_id;
}
void OAIAutomotivePartsCompatibilityPolicy::setCategoryTreeId(const QString &category_tree_id) {
    m_category_tree_id = category_tree_id;
    m_category_tree_id_isSet = true;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_category_tree_id_Set() const{
    return m_category_tree_id_isSet;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_category_tree_id_Valid() const{
    return m_category_tree_id_isValid;
}

QString OAIAutomotivePartsCompatibilityPolicy::getCompatibilityBasedOn() const {
    return m_compatibility_based_on;
}
void OAIAutomotivePartsCompatibilityPolicy::setCompatibilityBasedOn(const QString &compatibility_based_on) {
    m_compatibility_based_on = compatibility_based_on;
    m_compatibility_based_on_isSet = true;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_compatibility_based_on_Set() const{
    return m_compatibility_based_on_isSet;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_compatibility_based_on_Valid() const{
    return m_compatibility_based_on_isValid;
}

QList<QString> OAIAutomotivePartsCompatibilityPolicy::getCompatibleVehicleTypes() const {
    return m_compatible_vehicle_types;
}
void OAIAutomotivePartsCompatibilityPolicy::setCompatibleVehicleTypes(const QList<QString> &compatible_vehicle_types) {
    m_compatible_vehicle_types = compatible_vehicle_types;
    m_compatible_vehicle_types_isSet = true;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_compatible_vehicle_types_Set() const{
    return m_compatible_vehicle_types_isSet;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_compatible_vehicle_types_Valid() const{
    return m_compatible_vehicle_types_isValid;
}

qint32 OAIAutomotivePartsCompatibilityPolicy::getMaxNumberOfCompatibleVehicles() const {
    return m_max_number_of_compatible_vehicles;
}
void OAIAutomotivePartsCompatibilityPolicy::setMaxNumberOfCompatibleVehicles(const qint32 &max_number_of_compatible_vehicles) {
    m_max_number_of_compatible_vehicles = max_number_of_compatible_vehicles;
    m_max_number_of_compatible_vehicles_isSet = true;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_max_number_of_compatible_vehicles_Set() const{
    return m_max_number_of_compatible_vehicles_isSet;
}

bool OAIAutomotivePartsCompatibilityPolicy::is_max_number_of_compatible_vehicles_Valid() const{
    return m_max_number_of_compatible_vehicles_isValid;
}

bool OAIAutomotivePartsCompatibilityPolicy::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_category_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_category_tree_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_compatibility_based_on_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_compatible_vehicle_types.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_number_of_compatible_vehicles_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAutomotivePartsCompatibilityPolicy::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
