/**
 * Negotiation API
 * The <b>Negotiations API</b> gives sellers the ability to proactively send discount offers to buyers who have shown an \"interest\" in their listings.  <br><br>By sending buyers discount offers on listings where they have shown an interest, sellers can increase the velocity of their sales.  <br><br>There are various ways for a buyer to show <i>interest </i> in a listing. For example, if a buyer adds the listing to their <b>Watch</b> list, or if they add the listing to their shopping cart and later abandon the cart, they are deemed to have shown an interest in the listing.  <br><br>In the offers that sellers send, they can discount their listings by either a percentage off the listing price, or they can set a new discounted price that is lower than the original listing price.  <br><br>For details about how seller offers work, see <a href=\"/api-docs/sell/static/marketing/offers-to-buyers.html\" title=\"Selling Integration Guide\">Sending offers to buyers</a>.
 *
 * The version of the OpenAPI document: v1.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import OfferedItem from './OfferedItem';
import TimeDuration from './TimeDuration';
import User from './User';

/**
 * The Offer model module.
 * @module model/Offer
 * @version v1.1.0
 */
class Offer {
    /**
     * Constructs a new <code>Offer</code>.
     * A complex type that defines an offer that a seller makes to eligible buyers.
     * @alias module:model/Offer
     */
    constructor() { 
        
        Offer.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Offer</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Offer} obj Optional instance to populate.
     * @return {module:model/Offer} The populated <code>Offer</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Offer();

            if (data.hasOwnProperty('allowCounterOffer')) {
                obj['allowCounterOffer'] = ApiClient.convertToType(data['allowCounterOffer'], 'Boolean');
            }
            if (data.hasOwnProperty('buyer')) {
                obj['buyer'] = User.constructFromObject(data['buyer']);
            }
            if (data.hasOwnProperty('creationDate')) {
                obj['creationDate'] = ApiClient.convertToType(data['creationDate'], 'String');
            }
            if (data.hasOwnProperty('initiatedBy')) {
                obj['initiatedBy'] = ApiClient.convertToType(data['initiatedBy'], 'String');
            }
            if (data.hasOwnProperty('lastModifiedDate')) {
                obj['lastModifiedDate'] = ApiClient.convertToType(data['lastModifiedDate'], 'String');
            }
            if (data.hasOwnProperty('message')) {
                obj['message'] = ApiClient.convertToType(data['message'], 'String');
            }
            if (data.hasOwnProperty('offerDuration')) {
                obj['offerDuration'] = TimeDuration.constructFromObject(data['offerDuration']);
            }
            if (data.hasOwnProperty('offerId')) {
                obj['offerId'] = ApiClient.convertToType(data['offerId'], 'String');
            }
            if (data.hasOwnProperty('offerStatus')) {
                obj['offerStatus'] = ApiClient.convertToType(data['offerStatus'], 'String');
            }
            if (data.hasOwnProperty('offerType')) {
                obj['offerType'] = ApiClient.convertToType(data['offerType'], 'String');
            }
            if (data.hasOwnProperty('offeredItems')) {
                obj['offeredItems'] = ApiClient.convertToType(data['offeredItems'], [OfferedItem]);
            }
            if (data.hasOwnProperty('revision')) {
                obj['revision'] = ApiClient.convertToType(data['revision'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Offer</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Offer</code>.
     */
    static validateJSON(data) {
        // validate the optional field `buyer`
        if (data['buyer']) { // data not null
          User.validateJSON(data['buyer']);
        }
        // ensure the json data is a string
        if (data['creationDate'] && !(typeof data['creationDate'] === 'string' || data['creationDate'] instanceof String)) {
            throw new Error("Expected the field `creationDate` to be a primitive type in the JSON string but got " + data['creationDate']);
        }
        // ensure the json data is a string
        if (data['initiatedBy'] && !(typeof data['initiatedBy'] === 'string' || data['initiatedBy'] instanceof String)) {
            throw new Error("Expected the field `initiatedBy` to be a primitive type in the JSON string but got " + data['initiatedBy']);
        }
        // ensure the json data is a string
        if (data['lastModifiedDate'] && !(typeof data['lastModifiedDate'] === 'string' || data['lastModifiedDate'] instanceof String)) {
            throw new Error("Expected the field `lastModifiedDate` to be a primitive type in the JSON string but got " + data['lastModifiedDate']);
        }
        // ensure the json data is a string
        if (data['message'] && !(typeof data['message'] === 'string' || data['message'] instanceof String)) {
            throw new Error("Expected the field `message` to be a primitive type in the JSON string but got " + data['message']);
        }
        // validate the optional field `offerDuration`
        if (data['offerDuration']) { // data not null
          TimeDuration.validateJSON(data['offerDuration']);
        }
        // ensure the json data is a string
        if (data['offerId'] && !(typeof data['offerId'] === 'string' || data['offerId'] instanceof String)) {
            throw new Error("Expected the field `offerId` to be a primitive type in the JSON string but got " + data['offerId']);
        }
        // ensure the json data is a string
        if (data['offerStatus'] && !(typeof data['offerStatus'] === 'string' || data['offerStatus'] instanceof String)) {
            throw new Error("Expected the field `offerStatus` to be a primitive type in the JSON string but got " + data['offerStatus']);
        }
        // ensure the json data is a string
        if (data['offerType'] && !(typeof data['offerType'] === 'string' || data['offerType'] instanceof String)) {
            throw new Error("Expected the field `offerType` to be a primitive type in the JSON string but got " + data['offerType']);
        }
        if (data['offeredItems']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['offeredItems'])) {
                throw new Error("Expected the field `offeredItems` to be an array in the JSON data but got " + data['offeredItems']);
            }
            // validate the optional field `offeredItems` (array)
            for (const item of data['offeredItems']) {
                OfferedItem.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['revision'] && !(typeof data['revision'] === 'string' || data['revision'] instanceof String)) {
            throw new Error("Expected the field `revision` to be a primitive type in the JSON string but got " + data['revision']);
        }

        return true;
    }


}



/**
 * If set to true, the buyer is allowed to make a counter-offer to the seller's offer.
 * @member {Boolean} allowCounterOffer
 */
Offer.prototype['allowCounterOffer'] = undefined;

/**
 * @member {module:model/User} buyer
 */
Offer.prototype['buyer'] = undefined;

/**
 * The date and time when the seller's offer was created. The returned timestamp is formatted as an ISO 8601 string, which is based on the 24-hour Coordinated Universal Time (UTC) clock. Format: [YYYY]-[MM]-[DD]T[hh]:[mm]:[ss].[sss]Z Example: 2018-08-20T07:09:00.000Z
 * @member {String} creationDate
 */
Offer.prototype['creationDate'] = undefined;

/**
 * The eBay UserName of the user (seller) who initiated the offer.
 * @member {String} initiatedBy
 */
Offer.prototype['initiatedBy'] = undefined;

/**
 * The date and time when the offer was last modified. The returned timestamp is formatted as an ISO 8601 string.
 * @member {String} lastModifiedDate
 */
Offer.prototype['lastModifiedDate'] = undefined;

/**
 * A seller-defined message related to the offer being made. This message is sent to the list of &quot;interested&quot; buyers along with the offer message from eBay.
 * @member {String} message
 */
Offer.prototype['message'] = undefined;

/**
 * @member {module:model/TimeDuration} offerDuration
 */
Offer.prototype['offerDuration'] = undefined;

/**
 * A unique eBay-assigned identifier for the offer.
 * @member {String} offerId
 */
Offer.prototype['offerId'] = undefined;

/**
 * The current state, or status, of an offer. Status states include PENDING, COUNTERED, ACCEPTED, and DECLINED. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/negotiation/types/api:OfferStatusEnum'>eBay API documentation</a>
 * @member {String} offerStatus
 */
Offer.prototype['offerStatus'] = undefined;

/**
 * The type of offer being made. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/sell/negotiation/types/api:OfferTypeEnum'>eBay API documentation</a>
 * @member {String} offerType
 */
Offer.prototype['offerType'] = undefined;

/**
 * The list of items associated with the offer. Currently, the offer list is restricted to a single offer.
 * @member {Array.<module:model/OfferedItem>} offeredItems
 */
Offer.prototype['offeredItems'] = undefined;

/**
 * A unique, eBay-assigned ID for the revision of the offer.
 * @member {String} revision
 */
Offer.prototype['revision'] = undefined;






export default Offer;

