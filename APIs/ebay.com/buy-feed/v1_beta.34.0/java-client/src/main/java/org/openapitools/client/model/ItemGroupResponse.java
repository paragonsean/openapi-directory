/*
 * Item Feed Service
 * <span class=\"tablenote\"><b>Note:</b> This is a <a href=\"https://developer.ebay.com/api-docs/static/versioning.html#limited \" target=\"_blank\"> <img src=\"/cms/img/docs/partners-api.svg\" class=\"legend-icon partners-icon\" title=\"Limited Release\"  alt=\"Limited Release\" />(Limited Release)</a> API available only to select developers approved by business units. For information on how to obtain access to this API in production, see the <a href=\"api-docs/buy/static/buy-requirements.html\" target=\"_blank\">Buy APIs Requirements</a>.</span><br><br>The Feed API provides the ability to download TSV_GZIP feed files containing eBay items and an hourly snapshot file of the items that have changed within an hour for a specific category, date and marketplace. <p>In addition to the API, there is an open source <a href=\"https://github.com/eBay/FeedSDK \" target=\"_blank\">Feed SDK</a> written in Java that downloads, combines files into a single file when needed, and unzips the entire feed file. It also lets you specify field filters to curate the items in the file.</p>
 *
 * The version of the OpenAPI document: v1_beta.34.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ItemGroup;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The type that defines the array for the items returned in the &lt;b&gt;Item Group&lt;/b&gt; feed file.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:40:11.216954-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ItemGroupResponse {
  public static final String SERIALIZED_NAME_ITEM_GROUPS = "itemGroups";
  @SerializedName(SERIALIZED_NAME_ITEM_GROUPS)
  private List<ItemGroup> itemGroups = new ArrayList<>();

  public ItemGroupResponse() {
  }

  public ItemGroupResponse itemGroups(List<ItemGroup> itemGroups) {
    this.itemGroups = itemGroups;
    return this;
  }

  public ItemGroupResponse addItemGroupsItem(ItemGroup itemGroupsItem) {
    if (this.itemGroups == null) {
      this.itemGroups = new ArrayList<>();
    }
    this.itemGroups.add(itemGroupsItem);
    return this;
  }

  /**
   * The container for the array of items groups returned by the &lt;b&gt; getItemGroupFeed&lt;/b&gt; method. The data in the file is tab separated and the first row is the header, which labels the columns and indicates the order of the values for each item. The header labels match the fields that are described in the &lt;a href&#x3D;\&quot;/api-docs/buy/feed/resources/item_group/methods/getItemGroupFeed#h3-response-fields\&quot;&gt;Response fields&lt;/a&gt; section.
   * @return itemGroups
   */
  @javax.annotation.Nullable
  public List<ItemGroup> getItemGroups() {
    return itemGroups;
  }

  public void setItemGroups(List<ItemGroup> itemGroups) {
    this.itemGroups = itemGroups;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ItemGroupResponse itemGroupResponse = (ItemGroupResponse) o;
    return Objects.equals(this.itemGroups, itemGroupResponse.itemGroups);
  }

  @Override
  public int hashCode() {
    return Objects.hash(itemGroups);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ItemGroupResponse {\n");
    sb.append("    itemGroups: ").append(toIndentedString(itemGroups)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("itemGroups");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ItemGroupResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ItemGroupResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ItemGroupResponse is not found in the empty JSON string", ItemGroupResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ItemGroupResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ItemGroupResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("itemGroups") != null && !jsonObj.get("itemGroups").isJsonNull()) {
        JsonArray jsonArrayitemGroups = jsonObj.getAsJsonArray("itemGroups");
        if (jsonArrayitemGroups != null) {
          // ensure the json data is an array
          if (!jsonObj.get("itemGroups").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `itemGroups` to be an array in the JSON string but got `%s`", jsonObj.get("itemGroups").toString()));
          }

          // validate the optional field `itemGroups` (array)
          for (int i = 0; i < jsonArrayitemGroups.size(); i++) {
            ItemGroup.validateJsonElement(jsonArrayitemGroups.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ItemGroupResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ItemGroupResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ItemGroupResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ItemGroupResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<ItemGroupResponse>() {
           @Override
           public void write(JsonWriter out, ItemGroupResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ItemGroupResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ItemGroupResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ItemGroupResponse
   * @throws IOException if the JSON string is invalid with respect to ItemGroupResponse
   */
  public static ItemGroupResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ItemGroupResponse.class);
  }

  /**
   * Convert an instance of ItemGroupResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

