/*
 * Compliance API
 * Service for providing information to sellers about their listings being non-compliant, or at risk for becoming non-compliant, against eBay listing policies.
 *
 * The version of the OpenAPI document: 1.4.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CorrectiveRecommendations;
import org.openapitools.client.model.NameValueList;
import org.openapitools.client.model.VariationDetails;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This type is used by each listing violation that is returned under the violations container.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:39:33.329665-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ComplianceDetail {
  public static final String SERIALIZED_NAME_COMPLIANCE_STATE = "complianceState";
  @SerializedName(SERIALIZED_NAME_COMPLIANCE_STATE)
  private String complianceState;

  public static final String SERIALIZED_NAME_CORRECTIVE_RECOMMENDATIONS = "correctiveRecommendations";
  @SerializedName(SERIALIZED_NAME_CORRECTIVE_RECOMMENDATIONS)
  private CorrectiveRecommendations correctiveRecommendations;

  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  private String message;

  public static final String SERIALIZED_NAME_REASON_CODE = "reasonCode";
  @SerializedName(SERIALIZED_NAME_REASON_CODE)
  private String reasonCode;

  public static final String SERIALIZED_NAME_VARIATION = "variation";
  @SerializedName(SERIALIZED_NAME_VARIATION)
  private VariationDetails variation;

  public static final String SERIALIZED_NAME_VIOLATION_DATA = "violationData";
  @SerializedName(SERIALIZED_NAME_VIOLATION_DATA)
  private List<NameValueList> violationData = new ArrayList<>();

  public ComplianceDetail() {
  }

  public ComplianceDetail complianceState(String complianceState) {
    this.complianceState = complianceState;
    return this;
  }

  /**
   * The enumeration value returned in this field indicates if the listing violation is considered to be OUT_OF_COMPLIANCE with an eBay listing policy, or the listing is considered to be AT_RISK of becoming non-compliant against an eBay listing policy. Generally, OUT_OF_COMPLIANCE policy violations can prevent the seller from revising a listing until the underlying violation(s) can be remedied. When the compliance state is AT_RISK, the seller is not blocked from revising the listing, but the seller should correct the violation to prevent the listing from being blocked for revisions in the future. Note: This field is returned for most violations, but not all. In the case that this field is not returned, it can be assumed that the state of the listing violation is OUT_OF_COMPLIANCE. For implementation help, refer to &lt;a href&#x3D;&#39;https://developer.ebay.com/api-docs/sell/compliance/types/com:ComplianceStateEnum&#39;&gt;eBay API documentation&lt;/a&gt;
   * @return complianceState
   */
  @javax.annotation.Nullable
  public String getComplianceState() {
    return complianceState;
  }

  public void setComplianceState(String complianceState) {
    this.complianceState = complianceState;
  }


  public ComplianceDetail correctiveRecommendations(CorrectiveRecommendations correctiveRecommendations) {
    this.correctiveRecommendations = correctiveRecommendations;
    return this;
  }

  /**
   * Get correctiveRecommendations
   * @return correctiveRecommendations
   */
  @javax.annotation.Nullable
  public CorrectiveRecommendations getCorrectiveRecommendations() {
    return correctiveRecommendations;
  }

  public void setCorrectiveRecommendations(CorrectiveRecommendations correctiveRecommendations) {
    this.correctiveRecommendations = correctiveRecommendations;
  }


  public ComplianceDetail message(String message) {
    this.message = message;
    return this;
  }

  /**
   * This field provides a textual summary of the listing violation. A message field is returned for each listing violation. This message will vary widely based on the compliance type and corresponding reason code.
   * @return message
   */
  @javax.annotation.Nullable
  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }


  public ComplianceDetail reasonCode(String reasonCode) {
    this.reasonCode = reasonCode;
    return this;
  }

  /**
   * This value states the nature of the listing violation. A reasonCode value is returned for each listing violation, and each compliance type can have several reason codes and related messages. The reasonCode values vary by compliance type. The reason codes for each compliance type are summarized below. Aspects adoption The reason codes for ASPECTS_ADOPTION compliance indicate that for the given violation, aspects listed in the violationData container are either missing from the listing or they have invalid values. The reason codes specify whether the violation is for required aspects, recommended (preferred) aspects, or soon to be required aspects. MISSING_OR_INVALID_REQUIRED_ASPECTS MISSING_OR_INVALID_PREFERRED_ASPECTS MISSING_OR_INVALID_SOON_TO_BE_REQUIRED_ASPECTS HTTPS The reason codes for HTTPS compliance identify where in the listing the violation occurs. For HTTPS policy violations, the seller will just need to remove the HTTP link (or update to HTTPS) from the listing details or product details: NON_SECURE_HTTP_LINK_IN_LISTING NON_SECURE_HTTP_LINK_IN_PRODUCT Non-eBay links The reason codes for OUTSIDE_EBAY_BUYING_AND_SELLING compliance identify the specific type of data (e.g., telephone number) that violated the policy. For each of these violations, the seller will just need to revise the listing, removing this information: UNAPPROVED_DOMAIN_WEBLINK_IN_LISTING PHONE_NUMBER_IN_LISTING EMAIL_ADDRESS_IN_LISTING Product adoption Product Adoption is not enforced at this time. Product adoption conformance Product Adoption is not enforced at this time. Returns policy The only RETURNS_POLICY reason code is UNSUPPORTED_RETURNS_PERIOD. The seller will have to revise their listing (or return business policy) with a supported return period for the site and category. The GetCategoryFeatures call of the Trading API can be used to verify the supported return periods for a particular category. For most eBay categories, the minimum return period that can be stated in a Returns Policy is 14 days for domestic and international sales, but some categories require a minimum 30-day return period.
   * @return reasonCode
   */
  @javax.annotation.Nullable
  public String getReasonCode() {
    return reasonCode;
  }

  public void setReasonCode(String reasonCode) {
    this.reasonCode = reasonCode;
  }


  public ComplianceDetail variation(VariationDetails variation) {
    this.variation = variation;
    return this;
  }

  /**
   * Get variation
   * @return variation
   */
  @javax.annotation.Nullable
  public VariationDetails getVariation() {
    return variation;
  }

  public void setVariation(VariationDetails variation) {
    this.variation = variation;
  }


  public ComplianceDetail violationData(List<NameValueList> violationData) {
    this.violationData = violationData;
    return this;
  }

  public ComplianceDetail addViolationDataItem(NameValueList violationDataItem) {
    if (this.violationData == null) {
      this.violationData = new ArrayList<>();
    }
    this.violationData.add(violationDataItem);
    return this;
  }

  /**
   * This container provides more information about the listing violation, if applicable. The type of information that appears here will vary based on the compliance type and type of violation. For example, for ASPECTS_ADOPTION violations, this container lists the missing aspect(s) or aspect(s) with invalid values.
   * @return violationData
   */
  @javax.annotation.Nullable
  public List<NameValueList> getViolationData() {
    return violationData;
  }

  public void setViolationData(List<NameValueList> violationData) {
    this.violationData = violationData;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComplianceDetail complianceDetail = (ComplianceDetail) o;
    return Objects.equals(this.complianceState, complianceDetail.complianceState) &&
        Objects.equals(this.correctiveRecommendations, complianceDetail.correctiveRecommendations) &&
        Objects.equals(this.message, complianceDetail.message) &&
        Objects.equals(this.reasonCode, complianceDetail.reasonCode) &&
        Objects.equals(this.variation, complianceDetail.variation) &&
        Objects.equals(this.violationData, complianceDetail.violationData);
  }

  @Override
  public int hashCode() {
    return Objects.hash(complianceState, correctiveRecommendations, message, reasonCode, variation, violationData);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComplianceDetail {\n");
    sb.append("    complianceState: ").append(toIndentedString(complianceState)).append("\n");
    sb.append("    correctiveRecommendations: ").append(toIndentedString(correctiveRecommendations)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    reasonCode: ").append(toIndentedString(reasonCode)).append("\n");
    sb.append("    variation: ").append(toIndentedString(variation)).append("\n");
    sb.append("    violationData: ").append(toIndentedString(violationData)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("complianceState");
    openapiFields.add("correctiveRecommendations");
    openapiFields.add("message");
    openapiFields.add("reasonCode");
    openapiFields.add("variation");
    openapiFields.add("violationData");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ComplianceDetail
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ComplianceDetail.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ComplianceDetail is not found in the empty JSON string", ComplianceDetail.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ComplianceDetail.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ComplianceDetail` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("complianceState") != null && !jsonObj.get("complianceState").isJsonNull()) && !jsonObj.get("complianceState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `complianceState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("complianceState").toString()));
      }
      // validate the optional field `correctiveRecommendations`
      if (jsonObj.get("correctiveRecommendations") != null && !jsonObj.get("correctiveRecommendations").isJsonNull()) {
        CorrectiveRecommendations.validateJsonElement(jsonObj.get("correctiveRecommendations"));
      }
      if ((jsonObj.get("message") != null && !jsonObj.get("message").isJsonNull()) && !jsonObj.get("message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `message` to be a primitive type in the JSON string but got `%s`", jsonObj.get("message").toString()));
      }
      if ((jsonObj.get("reasonCode") != null && !jsonObj.get("reasonCode").isJsonNull()) && !jsonObj.get("reasonCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reasonCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reasonCode").toString()));
      }
      // validate the optional field `variation`
      if (jsonObj.get("variation") != null && !jsonObj.get("variation").isJsonNull()) {
        VariationDetails.validateJsonElement(jsonObj.get("variation"));
      }
      if (jsonObj.get("violationData") != null && !jsonObj.get("violationData").isJsonNull()) {
        JsonArray jsonArrayviolationData = jsonObj.getAsJsonArray("violationData");
        if (jsonArrayviolationData != null) {
          // ensure the json data is an array
          if (!jsonObj.get("violationData").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `violationData` to be an array in the JSON string but got `%s`", jsonObj.get("violationData").toString()));
          }

          // validate the optional field `violationData` (array)
          for (int i = 0; i < jsonArrayviolationData.size(); i++) {
            NameValueList.validateJsonElement(jsonArrayviolationData.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ComplianceDetail.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ComplianceDetail' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ComplianceDetail> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ComplianceDetail.class));

       return (TypeAdapter<T>) new TypeAdapter<ComplianceDetail>() {
           @Override
           public void write(JsonWriter out, ComplianceDetail value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ComplianceDetail read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ComplianceDetail given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ComplianceDetail
   * @throws IOException if the JSON string is invalid with respect to ComplianceDetail
   */
  public static ComplianceDetail fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ComplianceDetail.class);
  }

  /**
   * Convert an instance of ComplianceDetail to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

