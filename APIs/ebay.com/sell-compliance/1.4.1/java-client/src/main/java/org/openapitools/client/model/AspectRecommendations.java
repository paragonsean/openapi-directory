/*
 * Compliance API
 * Service for providing information to sellers about their listings being non-compliant, or at risk for becoming non-compliant, against eBay listing policies.
 *
 * The version of the OpenAPI document: 1.4.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This type is used by the aspectsRecommendation container, which is returned if eBay has found a listing with missing or invalid item aspects (ASPECTS_ADOPTION compliance type).
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:39:33.329665-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AspectRecommendations {
  public static final String SERIALIZED_NAME_LOCALIZED_ASPECT_NAME = "localizedAspectName";
  @SerializedName(SERIALIZED_NAME_LOCALIZED_ASPECT_NAME)
  private String localizedAspectName;

  public static final String SERIALIZED_NAME_SUGGESTED_VALUES = "suggestedValues";
  @SerializedName(SERIALIZED_NAME_SUGGESTED_VALUES)
  private List<String> suggestedValues = new ArrayList<>();

  public AspectRecommendations() {
  }

  public AspectRecommendations localizedAspectName(String localizedAspectName) {
    this.localizedAspectName = localizedAspectName;
    return this;
  }

  /**
   * The name of the item aspect for which eBay has a recommendation. In many cases, the same item aspect(s) that are returned under the violationData array for ASPECTS_ADOPTION listing violations are also returned here Note: This name is always localized for the specified marketplace.
   * @return localizedAspectName
   */
  @javax.annotation.Nullable
  public String getLocalizedAspectName() {
    return localizedAspectName;
  }

  public void setLocalizedAspectName(String localizedAspectName) {
    this.localizedAspectName = localizedAspectName;
  }


  public AspectRecommendations suggestedValues(List<String> suggestedValues) {
    this.suggestedValues = suggestedValues;
    return this;
  }

  public AspectRecommendations addSuggestedValuesItem(String suggestedValuesItem) {
    if (this.suggestedValues == null) {
      this.suggestedValues = new ArrayList<>();
    }
    this.suggestedValues.add(suggestedValuesItem);
    return this;
  }

  /**
   * One or more valid values for the corresponding item aspect (in localizedAspectName) are returned here. These suggested values for the item aspect depend on the listing category and on the information specified in the listing. Sellers should confirm accuracy of the values before applying them to the listing. Please use getItemAspectsForCategory in the Taxonomy API or GetCategorySpecifics in the Trading API to get a comprehensive list of required and recommended aspects for a given category and a list of supported aspect values for each.
   * @return suggestedValues
   */
  @javax.annotation.Nullable
  public List<String> getSuggestedValues() {
    return suggestedValues;
  }

  public void setSuggestedValues(List<String> suggestedValues) {
    this.suggestedValues = suggestedValues;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AspectRecommendations aspectRecommendations = (AspectRecommendations) o;
    return Objects.equals(this.localizedAspectName, aspectRecommendations.localizedAspectName) &&
        Objects.equals(this.suggestedValues, aspectRecommendations.suggestedValues);
  }

  @Override
  public int hashCode() {
    return Objects.hash(localizedAspectName, suggestedValues);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AspectRecommendations {\n");
    sb.append("    localizedAspectName: ").append(toIndentedString(localizedAspectName)).append("\n");
    sb.append("    suggestedValues: ").append(toIndentedString(suggestedValues)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("localizedAspectName");
    openapiFields.add("suggestedValues");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AspectRecommendations
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AspectRecommendations.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AspectRecommendations is not found in the empty JSON string", AspectRecommendations.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AspectRecommendations.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AspectRecommendations` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("localizedAspectName") != null && !jsonObj.get("localizedAspectName").isJsonNull()) && !jsonObj.get("localizedAspectName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `localizedAspectName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("localizedAspectName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("suggestedValues") != null && !jsonObj.get("suggestedValues").isJsonNull() && !jsonObj.get("suggestedValues").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `suggestedValues` to be an array in the JSON string but got `%s`", jsonObj.get("suggestedValues").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AspectRecommendations.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AspectRecommendations' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AspectRecommendations> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AspectRecommendations.class));

       return (TypeAdapter<T>) new TypeAdapter<AspectRecommendations>() {
           @Override
           public void write(JsonWriter out, AspectRecommendations value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AspectRecommendations read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AspectRecommendations given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AspectRecommendations
   * @throws IOException if the JSON string is invalid with respect to AspectRecommendations
   */
  public static AspectRecommendations fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AspectRecommendations.class);
  }

  /**
   * Convert an instance of AspectRecommendations to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

