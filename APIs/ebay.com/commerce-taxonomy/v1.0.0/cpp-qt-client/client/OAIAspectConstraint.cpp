/**
 * Taxonomy API
 * Use the Taxonomy API to discover the most appropriate eBay categories under which sellers can offer inventory items for sale, and the most likely categories under which buyers can browse or search for items to purchase. In addition, the Taxonomy API provides metadata about the required and recommended category aspects to include in listings, and also has two operations to retrieve parts compatibility information.
 *
 * The version of the OpenAPI document: v1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAspectConstraint.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAspectConstraint::OAIAspectConstraint(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAspectConstraint::OAIAspectConstraint() {
    this->initializeModel();
}

OAIAspectConstraint::~OAIAspectConstraint() {}

void OAIAspectConstraint::initializeModel() {

    m_aspect_applicable_to_isSet = false;
    m_aspect_applicable_to_isValid = false;

    m_aspect_data_type_isSet = false;
    m_aspect_data_type_isValid = false;

    m_aspect_enabled_for_variations_isSet = false;
    m_aspect_enabled_for_variations_isValid = false;

    m_aspect_format_isSet = false;
    m_aspect_format_isValid = false;

    m_aspect_max_length_isSet = false;
    m_aspect_max_length_isValid = false;

    m_aspect_mode_isSet = false;
    m_aspect_mode_isValid = false;

    m_aspect_required_isSet = false;
    m_aspect_required_isValid = false;

    m_aspect_usage_isSet = false;
    m_aspect_usage_isValid = false;

    m_expected_required_by_date_isSet = false;
    m_expected_required_by_date_isValid = false;

    m_item_to_aspect_cardinality_isSet = false;
    m_item_to_aspect_cardinality_isValid = false;
}

void OAIAspectConstraint::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAspectConstraint::fromJsonObject(QJsonObject json) {

    m_aspect_applicable_to_isValid = ::OpenAPI::fromJsonValue(m_aspect_applicable_to, json[QString("aspectApplicableTo")]);
    m_aspect_applicable_to_isSet = !json[QString("aspectApplicableTo")].isNull() && m_aspect_applicable_to_isValid;

    m_aspect_data_type_isValid = ::OpenAPI::fromJsonValue(m_aspect_data_type, json[QString("aspectDataType")]);
    m_aspect_data_type_isSet = !json[QString("aspectDataType")].isNull() && m_aspect_data_type_isValid;

    m_aspect_enabled_for_variations_isValid = ::OpenAPI::fromJsonValue(m_aspect_enabled_for_variations, json[QString("aspectEnabledForVariations")]);
    m_aspect_enabled_for_variations_isSet = !json[QString("aspectEnabledForVariations")].isNull() && m_aspect_enabled_for_variations_isValid;

    m_aspect_format_isValid = ::OpenAPI::fromJsonValue(m_aspect_format, json[QString("aspectFormat")]);
    m_aspect_format_isSet = !json[QString("aspectFormat")].isNull() && m_aspect_format_isValid;

    m_aspect_max_length_isValid = ::OpenAPI::fromJsonValue(m_aspect_max_length, json[QString("aspectMaxLength")]);
    m_aspect_max_length_isSet = !json[QString("aspectMaxLength")].isNull() && m_aspect_max_length_isValid;

    m_aspect_mode_isValid = ::OpenAPI::fromJsonValue(m_aspect_mode, json[QString("aspectMode")]);
    m_aspect_mode_isSet = !json[QString("aspectMode")].isNull() && m_aspect_mode_isValid;

    m_aspect_required_isValid = ::OpenAPI::fromJsonValue(m_aspect_required, json[QString("aspectRequired")]);
    m_aspect_required_isSet = !json[QString("aspectRequired")].isNull() && m_aspect_required_isValid;

    m_aspect_usage_isValid = ::OpenAPI::fromJsonValue(m_aspect_usage, json[QString("aspectUsage")]);
    m_aspect_usage_isSet = !json[QString("aspectUsage")].isNull() && m_aspect_usage_isValid;

    m_expected_required_by_date_isValid = ::OpenAPI::fromJsonValue(m_expected_required_by_date, json[QString("expectedRequiredByDate")]);
    m_expected_required_by_date_isSet = !json[QString("expectedRequiredByDate")].isNull() && m_expected_required_by_date_isValid;

    m_item_to_aspect_cardinality_isValid = ::OpenAPI::fromJsonValue(m_item_to_aspect_cardinality, json[QString("itemToAspectCardinality")]);
    m_item_to_aspect_cardinality_isSet = !json[QString("itemToAspectCardinality")].isNull() && m_item_to_aspect_cardinality_isValid;
}

QString OAIAspectConstraint::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAspectConstraint::asJsonObject() const {
    QJsonObject obj;
    if (m_aspect_applicable_to.size() > 0) {
        obj.insert(QString("aspectApplicableTo"), ::OpenAPI::toJsonValue(m_aspect_applicable_to));
    }
    if (m_aspect_data_type_isSet) {
        obj.insert(QString("aspectDataType"), ::OpenAPI::toJsonValue(m_aspect_data_type));
    }
    if (m_aspect_enabled_for_variations_isSet) {
        obj.insert(QString("aspectEnabledForVariations"), ::OpenAPI::toJsonValue(m_aspect_enabled_for_variations));
    }
    if (m_aspect_format_isSet) {
        obj.insert(QString("aspectFormat"), ::OpenAPI::toJsonValue(m_aspect_format));
    }
    if (m_aspect_max_length_isSet) {
        obj.insert(QString("aspectMaxLength"), ::OpenAPI::toJsonValue(m_aspect_max_length));
    }
    if (m_aspect_mode_isSet) {
        obj.insert(QString("aspectMode"), ::OpenAPI::toJsonValue(m_aspect_mode));
    }
    if (m_aspect_required_isSet) {
        obj.insert(QString("aspectRequired"), ::OpenAPI::toJsonValue(m_aspect_required));
    }
    if (m_aspect_usage_isSet) {
        obj.insert(QString("aspectUsage"), ::OpenAPI::toJsonValue(m_aspect_usage));
    }
    if (m_expected_required_by_date_isSet) {
        obj.insert(QString("expectedRequiredByDate"), ::OpenAPI::toJsonValue(m_expected_required_by_date));
    }
    if (m_item_to_aspect_cardinality_isSet) {
        obj.insert(QString("itemToAspectCardinality"), ::OpenAPI::toJsonValue(m_item_to_aspect_cardinality));
    }
    return obj;
}

QList<QString> OAIAspectConstraint::getAspectApplicableTo() const {
    return m_aspect_applicable_to;
}
void OAIAspectConstraint::setAspectApplicableTo(const QList<QString> &aspect_applicable_to) {
    m_aspect_applicable_to = aspect_applicable_to;
    m_aspect_applicable_to_isSet = true;
}

bool OAIAspectConstraint::is_aspect_applicable_to_Set() const{
    return m_aspect_applicable_to_isSet;
}

bool OAIAspectConstraint::is_aspect_applicable_to_Valid() const{
    return m_aspect_applicable_to_isValid;
}

QString OAIAspectConstraint::getAspectDataType() const {
    return m_aspect_data_type;
}
void OAIAspectConstraint::setAspectDataType(const QString &aspect_data_type) {
    m_aspect_data_type = aspect_data_type;
    m_aspect_data_type_isSet = true;
}

bool OAIAspectConstraint::is_aspect_data_type_Set() const{
    return m_aspect_data_type_isSet;
}

bool OAIAspectConstraint::is_aspect_data_type_Valid() const{
    return m_aspect_data_type_isValid;
}

bool OAIAspectConstraint::isAspectEnabledForVariations() const {
    return m_aspect_enabled_for_variations;
}
void OAIAspectConstraint::setAspectEnabledForVariations(const bool &aspect_enabled_for_variations) {
    m_aspect_enabled_for_variations = aspect_enabled_for_variations;
    m_aspect_enabled_for_variations_isSet = true;
}

bool OAIAspectConstraint::is_aspect_enabled_for_variations_Set() const{
    return m_aspect_enabled_for_variations_isSet;
}

bool OAIAspectConstraint::is_aspect_enabled_for_variations_Valid() const{
    return m_aspect_enabled_for_variations_isValid;
}

QString OAIAspectConstraint::getAspectFormat() const {
    return m_aspect_format;
}
void OAIAspectConstraint::setAspectFormat(const QString &aspect_format) {
    m_aspect_format = aspect_format;
    m_aspect_format_isSet = true;
}

bool OAIAspectConstraint::is_aspect_format_Set() const{
    return m_aspect_format_isSet;
}

bool OAIAspectConstraint::is_aspect_format_Valid() const{
    return m_aspect_format_isValid;
}

qint32 OAIAspectConstraint::getAspectMaxLength() const {
    return m_aspect_max_length;
}
void OAIAspectConstraint::setAspectMaxLength(const qint32 &aspect_max_length) {
    m_aspect_max_length = aspect_max_length;
    m_aspect_max_length_isSet = true;
}

bool OAIAspectConstraint::is_aspect_max_length_Set() const{
    return m_aspect_max_length_isSet;
}

bool OAIAspectConstraint::is_aspect_max_length_Valid() const{
    return m_aspect_max_length_isValid;
}

QString OAIAspectConstraint::getAspectMode() const {
    return m_aspect_mode;
}
void OAIAspectConstraint::setAspectMode(const QString &aspect_mode) {
    m_aspect_mode = aspect_mode;
    m_aspect_mode_isSet = true;
}

bool OAIAspectConstraint::is_aspect_mode_Set() const{
    return m_aspect_mode_isSet;
}

bool OAIAspectConstraint::is_aspect_mode_Valid() const{
    return m_aspect_mode_isValid;
}

bool OAIAspectConstraint::isAspectRequired() const {
    return m_aspect_required;
}
void OAIAspectConstraint::setAspectRequired(const bool &aspect_required) {
    m_aspect_required = aspect_required;
    m_aspect_required_isSet = true;
}

bool OAIAspectConstraint::is_aspect_required_Set() const{
    return m_aspect_required_isSet;
}

bool OAIAspectConstraint::is_aspect_required_Valid() const{
    return m_aspect_required_isValid;
}

QString OAIAspectConstraint::getAspectUsage() const {
    return m_aspect_usage;
}
void OAIAspectConstraint::setAspectUsage(const QString &aspect_usage) {
    m_aspect_usage = aspect_usage;
    m_aspect_usage_isSet = true;
}

bool OAIAspectConstraint::is_aspect_usage_Set() const{
    return m_aspect_usage_isSet;
}

bool OAIAspectConstraint::is_aspect_usage_Valid() const{
    return m_aspect_usage_isValid;
}

QString OAIAspectConstraint::getExpectedRequiredByDate() const {
    return m_expected_required_by_date;
}
void OAIAspectConstraint::setExpectedRequiredByDate(const QString &expected_required_by_date) {
    m_expected_required_by_date = expected_required_by_date;
    m_expected_required_by_date_isSet = true;
}

bool OAIAspectConstraint::is_expected_required_by_date_Set() const{
    return m_expected_required_by_date_isSet;
}

bool OAIAspectConstraint::is_expected_required_by_date_Valid() const{
    return m_expected_required_by_date_isValid;
}

QString OAIAspectConstraint::getItemToAspectCardinality() const {
    return m_item_to_aspect_cardinality;
}
void OAIAspectConstraint::setItemToAspectCardinality(const QString &item_to_aspect_cardinality) {
    m_item_to_aspect_cardinality = item_to_aspect_cardinality;
    m_item_to_aspect_cardinality_isSet = true;
}

bool OAIAspectConstraint::is_item_to_aspect_cardinality_Set() const{
    return m_item_to_aspect_cardinality_isSet;
}

bool OAIAspectConstraint::is_item_to_aspect_cardinality_Valid() const{
    return m_item_to_aspect_cardinality_isValid;
}

bool OAIAspectConstraint::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_aspect_applicable_to.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_aspect_data_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_aspect_enabled_for_variations_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_aspect_format_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_aspect_max_length_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_aspect_mode_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_aspect_required_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_aspect_usage_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_expected_required_by_date_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_item_to_aspect_cardinality_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAspectConstraint::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
