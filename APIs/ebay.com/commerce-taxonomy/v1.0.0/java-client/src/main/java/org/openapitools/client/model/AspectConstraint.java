/*
 * Taxonomy API
 * Use the Taxonomy API to discover the most appropriate eBay categories under which sellers can offer inventory items for sale, and the most likely categories under which buyers can browse or search for items to purchase. In addition, the Taxonomy API provides metadata about the required and recommended category aspects to include in listings, and also has two operations to retrieve parts compatibility information.
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This type contains information about the formatting, occurrence, and support of an aspect.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:39:48.978907-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AspectConstraint {
  public static final String SERIALIZED_NAME_ASPECT_APPLICABLE_TO = "aspectApplicableTo";
  @SerializedName(SERIALIZED_NAME_ASPECT_APPLICABLE_TO)
  private List<String> aspectApplicableTo = new ArrayList<>();

  public static final String SERIALIZED_NAME_ASPECT_DATA_TYPE = "aspectDataType";
  @SerializedName(SERIALIZED_NAME_ASPECT_DATA_TYPE)
  private String aspectDataType;

  public static final String SERIALIZED_NAME_ASPECT_ENABLED_FOR_VARIATIONS = "aspectEnabledForVariations";
  @SerializedName(SERIALIZED_NAME_ASPECT_ENABLED_FOR_VARIATIONS)
  private Boolean aspectEnabledForVariations;

  public static final String SERIALIZED_NAME_ASPECT_FORMAT = "aspectFormat";
  @SerializedName(SERIALIZED_NAME_ASPECT_FORMAT)
  private String aspectFormat;

  public static final String SERIALIZED_NAME_ASPECT_MAX_LENGTH = "aspectMaxLength";
  @SerializedName(SERIALIZED_NAME_ASPECT_MAX_LENGTH)
  private Integer aspectMaxLength;

  public static final String SERIALIZED_NAME_ASPECT_MODE = "aspectMode";
  @SerializedName(SERIALIZED_NAME_ASPECT_MODE)
  private String aspectMode;

  public static final String SERIALIZED_NAME_ASPECT_REQUIRED = "aspectRequired";
  @SerializedName(SERIALIZED_NAME_ASPECT_REQUIRED)
  private Boolean aspectRequired;

  public static final String SERIALIZED_NAME_ASPECT_USAGE = "aspectUsage";
  @SerializedName(SERIALIZED_NAME_ASPECT_USAGE)
  private String aspectUsage;

  public static final String SERIALIZED_NAME_EXPECTED_REQUIRED_BY_DATE = "expectedRequiredByDate";
  @SerializedName(SERIALIZED_NAME_EXPECTED_REQUIRED_BY_DATE)
  private String expectedRequiredByDate;

  public static final String SERIALIZED_NAME_ITEM_TO_ASPECT_CARDINALITY = "itemToAspectCardinality";
  @SerializedName(SERIALIZED_NAME_ITEM_TO_ASPECT_CARDINALITY)
  private String itemToAspectCardinality;

  public AspectConstraint() {
  }

  public AspectConstraint aspectApplicableTo(List<String> aspectApplicableTo) {
    this.aspectApplicableTo = aspectApplicableTo;
    return this;
  }

  public AspectConstraint addAspectApplicableToItem(String aspectApplicableToItem) {
    if (this.aspectApplicableTo == null) {
      this.aspectApplicableTo = new ArrayList<>();
    }
    this.aspectApplicableTo.add(aspectApplicableToItem);
    return this;
  }

  /**
   * This value indicate if the aspect identified by the aspects.localizedAspectName field is a product aspect (relevant to catalog products in the category) or an item/instance aspect, which is an aspect whose value will vary based on a particular instance of the product.
   * @return aspectApplicableTo
   */
  @javax.annotation.Nullable
  public List<String> getAspectApplicableTo() {
    return aspectApplicableTo;
  }

  public void setAspectApplicableTo(List<String> aspectApplicableTo) {
    this.aspectApplicableTo = aspectApplicableTo;
  }


  public AspectConstraint aspectDataType(String aspectDataType) {
    this.aspectDataType = aspectDataType;
    return this;
  }

  /**
   * The data type of this aspect. For implementation help, refer to &lt;a href&#x3D;&#39;https://developer.ebay.com/api-docs/commerce/taxonomy/types/txn:AspectDataTypeEnum&#39;&gt;eBay API documentation&lt;/a&gt;
   * @return aspectDataType
   */
  @javax.annotation.Nullable
  public String getAspectDataType() {
    return aspectDataType;
  }

  public void setAspectDataType(String aspectDataType) {
    this.aspectDataType = aspectDataType;
  }


  public AspectConstraint aspectEnabledForVariations(Boolean aspectEnabledForVariations) {
    this.aspectEnabledForVariations = aspectEnabledForVariations;
    return this;
  }

  /**
   * A value of true indicates that this aspect can be used to help identify item variations.
   * @return aspectEnabledForVariations
   */
  @javax.annotation.Nullable
  public Boolean getAspectEnabledForVariations() {
    return aspectEnabledForVariations;
  }

  public void setAspectEnabledForVariations(Boolean aspectEnabledForVariations) {
    this.aspectEnabledForVariations = aspectEnabledForVariations;
  }


  public AspectConstraint aspectFormat(String aspectFormat) {
    this.aspectFormat = aspectFormat;
    return this;
  }

  /**
   * Returned only if the value of aspectDataType identifies a data type that requires specific formatting. Currently, this field provides formatting hints as follows: DATE: YYYY, YYYYMM, YYYYMMDD NUMBER: int32, double
   * @return aspectFormat
   */
  @javax.annotation.Nullable
  public String getAspectFormat() {
    return aspectFormat;
  }

  public void setAspectFormat(String aspectFormat) {
    this.aspectFormat = aspectFormat;
  }


  public AspectConstraint aspectMaxLength(Integer aspectMaxLength) {
    this.aspectMaxLength = aspectMaxLength;
    return this;
  }

  /**
   * The maximum length of the item/instance aspect&#39;s value. The seller must make sure not to exceed this length when specifying the instance aspect&#39;s value for a product. This field is only returned for instance aspects.
   * @return aspectMaxLength
   */
  @javax.annotation.Nullable
  public Integer getAspectMaxLength() {
    return aspectMaxLength;
  }

  public void setAspectMaxLength(Integer aspectMaxLength) {
    this.aspectMaxLength = aspectMaxLength;
  }


  public AspectConstraint aspectMode(String aspectMode) {
    this.aspectMode = aspectMode;
    return this;
  }

  /**
   * The manner in which values of this aspect must be specified by the seller (as free text or by selecting from available options). For implementation help, refer to &lt;a href&#x3D;&#39;https://developer.ebay.com/api-docs/commerce/taxonomy/types/txn:AspectModeEnum&#39;&gt;eBay API documentation&lt;/a&gt;
   * @return aspectMode
   */
  @javax.annotation.Nullable
  public String getAspectMode() {
    return aspectMode;
  }

  public void setAspectMode(String aspectMode) {
    this.aspectMode = aspectMode;
  }


  public AspectConstraint aspectRequired(Boolean aspectRequired) {
    this.aspectRequired = aspectRequired;
    return this;
  }

  /**
   * A value of true indicates that this aspect is required when offering items in the specified category.
   * @return aspectRequired
   */
  @javax.annotation.Nullable
  public Boolean getAspectRequired() {
    return aspectRequired;
  }

  public void setAspectRequired(Boolean aspectRequired) {
    this.aspectRequired = aspectRequired;
  }


  public AspectConstraint aspectUsage(String aspectUsage) {
    this.aspectUsage = aspectUsage;
    return this;
  }

  /**
   * The enumeration value returned in this field will indicate if the corresponding aspect is recommended or optional. Note: This field is always returned, even for hard-mandated/required aspects (where aspectRequired: true). The value returned for required aspects will be RECOMMENDED, but they are actually required and a seller will be blocked from listing or revising an item without these aspects. For implementation help, refer to &lt;a href&#x3D;&#39;https://developer.ebay.com/api-docs/commerce/taxonomy/types/txn:AspectUsageEnum&#39;&gt;eBay API documentation&lt;/a&gt;
   * @return aspectUsage
   */
  @javax.annotation.Nullable
  public String getAspectUsage() {
    return aspectUsage;
  }

  public void setAspectUsage(String aspectUsage) {
    this.aspectUsage = aspectUsage;
  }


  public AspectConstraint expectedRequiredByDate(String expectedRequiredByDate) {
    this.expectedRequiredByDate = expectedRequiredByDate;
    return this;
  }

  /**
   * The expected date after which the aspect will be required. Note: The value returned in this field specifies only an approximate date, which may not reflect the actual date after which the aspect is required.
   * @return expectedRequiredByDate
   */
  @javax.annotation.Nullable
  public String getExpectedRequiredByDate() {
    return expectedRequiredByDate;
  }

  public void setExpectedRequiredByDate(String expectedRequiredByDate) {
    this.expectedRequiredByDate = expectedRequiredByDate;
  }


  public AspectConstraint itemToAspectCardinality(String itemToAspectCardinality) {
    this.itemToAspectCardinality = itemToAspectCardinality;
    return this;
  }

  /**
   * Indicates whether this aspect can accept single or multiple values for items in the specified category. For implementation help, refer to &lt;a href&#x3D;&#39;https://developer.ebay.com/api-docs/commerce/taxonomy/types/txn:ItemToAspectCardinalityEnum&#39;&gt;eBay API documentation&lt;/a&gt;
   * @return itemToAspectCardinality
   */
  @javax.annotation.Nullable
  public String getItemToAspectCardinality() {
    return itemToAspectCardinality;
  }

  public void setItemToAspectCardinality(String itemToAspectCardinality) {
    this.itemToAspectCardinality = itemToAspectCardinality;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AspectConstraint aspectConstraint = (AspectConstraint) o;
    return Objects.equals(this.aspectApplicableTo, aspectConstraint.aspectApplicableTo) &&
        Objects.equals(this.aspectDataType, aspectConstraint.aspectDataType) &&
        Objects.equals(this.aspectEnabledForVariations, aspectConstraint.aspectEnabledForVariations) &&
        Objects.equals(this.aspectFormat, aspectConstraint.aspectFormat) &&
        Objects.equals(this.aspectMaxLength, aspectConstraint.aspectMaxLength) &&
        Objects.equals(this.aspectMode, aspectConstraint.aspectMode) &&
        Objects.equals(this.aspectRequired, aspectConstraint.aspectRequired) &&
        Objects.equals(this.aspectUsage, aspectConstraint.aspectUsage) &&
        Objects.equals(this.expectedRequiredByDate, aspectConstraint.expectedRequiredByDate) &&
        Objects.equals(this.itemToAspectCardinality, aspectConstraint.itemToAspectCardinality);
  }

  @Override
  public int hashCode() {
    return Objects.hash(aspectApplicableTo, aspectDataType, aspectEnabledForVariations, aspectFormat, aspectMaxLength, aspectMode, aspectRequired, aspectUsage, expectedRequiredByDate, itemToAspectCardinality);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AspectConstraint {\n");
    sb.append("    aspectApplicableTo: ").append(toIndentedString(aspectApplicableTo)).append("\n");
    sb.append("    aspectDataType: ").append(toIndentedString(aspectDataType)).append("\n");
    sb.append("    aspectEnabledForVariations: ").append(toIndentedString(aspectEnabledForVariations)).append("\n");
    sb.append("    aspectFormat: ").append(toIndentedString(aspectFormat)).append("\n");
    sb.append("    aspectMaxLength: ").append(toIndentedString(aspectMaxLength)).append("\n");
    sb.append("    aspectMode: ").append(toIndentedString(aspectMode)).append("\n");
    sb.append("    aspectRequired: ").append(toIndentedString(aspectRequired)).append("\n");
    sb.append("    aspectUsage: ").append(toIndentedString(aspectUsage)).append("\n");
    sb.append("    expectedRequiredByDate: ").append(toIndentedString(expectedRequiredByDate)).append("\n");
    sb.append("    itemToAspectCardinality: ").append(toIndentedString(itemToAspectCardinality)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("aspectApplicableTo");
    openapiFields.add("aspectDataType");
    openapiFields.add("aspectEnabledForVariations");
    openapiFields.add("aspectFormat");
    openapiFields.add("aspectMaxLength");
    openapiFields.add("aspectMode");
    openapiFields.add("aspectRequired");
    openapiFields.add("aspectUsage");
    openapiFields.add("expectedRequiredByDate");
    openapiFields.add("itemToAspectCardinality");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AspectConstraint
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AspectConstraint.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AspectConstraint is not found in the empty JSON string", AspectConstraint.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AspectConstraint.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AspectConstraint` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("aspectApplicableTo") != null && !jsonObj.get("aspectApplicableTo").isJsonNull() && !jsonObj.get("aspectApplicableTo").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `aspectApplicableTo` to be an array in the JSON string but got `%s`", jsonObj.get("aspectApplicableTo").toString()));
      }
      if ((jsonObj.get("aspectDataType") != null && !jsonObj.get("aspectDataType").isJsonNull()) && !jsonObj.get("aspectDataType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `aspectDataType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("aspectDataType").toString()));
      }
      if ((jsonObj.get("aspectFormat") != null && !jsonObj.get("aspectFormat").isJsonNull()) && !jsonObj.get("aspectFormat").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `aspectFormat` to be a primitive type in the JSON string but got `%s`", jsonObj.get("aspectFormat").toString()));
      }
      if ((jsonObj.get("aspectMode") != null && !jsonObj.get("aspectMode").isJsonNull()) && !jsonObj.get("aspectMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `aspectMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("aspectMode").toString()));
      }
      if ((jsonObj.get("aspectUsage") != null && !jsonObj.get("aspectUsage").isJsonNull()) && !jsonObj.get("aspectUsage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `aspectUsage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("aspectUsage").toString()));
      }
      if ((jsonObj.get("expectedRequiredByDate") != null && !jsonObj.get("expectedRequiredByDate").isJsonNull()) && !jsonObj.get("expectedRequiredByDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expectedRequiredByDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expectedRequiredByDate").toString()));
      }
      if ((jsonObj.get("itemToAspectCardinality") != null && !jsonObj.get("itemToAspectCardinality").isJsonNull()) && !jsonObj.get("itemToAspectCardinality").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `itemToAspectCardinality` to be a primitive type in the JSON string but got `%s`", jsonObj.get("itemToAspectCardinality").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AspectConstraint.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AspectConstraint' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AspectConstraint> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AspectConstraint.class));

       return (TypeAdapter<T>) new TypeAdapter<AspectConstraint>() {
           @Override
           public void write(JsonWriter out, AspectConstraint value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AspectConstraint read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AspectConstraint given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AspectConstraint
   * @throws IOException if the JSON string is invalid with respect to AspectConstraint
   */
  public static AspectConstraint fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AspectConstraint.class);
  }

  /**
   * Convert an instance of AspectConstraint to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

