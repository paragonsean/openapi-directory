/**
 * Fulfillment API
 * Use the Fulfillment API to complete the process of packaging, addressing, handling, and shipping each order on behalf of the seller, in accordance with the payment method and timing specified at checkout.
 *
 * The version of the OpenAPI document: v1.20.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIOrderSearchPagedCollection.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIOrderSearchPagedCollection::OAIOrderSearchPagedCollection(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIOrderSearchPagedCollection::OAIOrderSearchPagedCollection() {
    this->initializeModel();
}

OAIOrderSearchPagedCollection::~OAIOrderSearchPagedCollection() {}

void OAIOrderSearchPagedCollection::initializeModel() {

    m_href_isSet = false;
    m_href_isValid = false;

    m_limit_isSet = false;
    m_limit_isValid = false;

    m_next_isSet = false;
    m_next_isValid = false;

    m_offset_isSet = false;
    m_offset_isValid = false;

    m_orders_isSet = false;
    m_orders_isValid = false;

    m_prev_isSet = false;
    m_prev_isValid = false;

    m_total_isSet = false;
    m_total_isValid = false;

    m_warnings_isSet = false;
    m_warnings_isValid = false;
}

void OAIOrderSearchPagedCollection::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIOrderSearchPagedCollection::fromJsonObject(QJsonObject json) {

    m_href_isValid = ::OpenAPI::fromJsonValue(m_href, json[QString("href")]);
    m_href_isSet = !json[QString("href")].isNull() && m_href_isValid;

    m_limit_isValid = ::OpenAPI::fromJsonValue(m_limit, json[QString("limit")]);
    m_limit_isSet = !json[QString("limit")].isNull() && m_limit_isValid;

    m_next_isValid = ::OpenAPI::fromJsonValue(m_next, json[QString("next")]);
    m_next_isSet = !json[QString("next")].isNull() && m_next_isValid;

    m_offset_isValid = ::OpenAPI::fromJsonValue(m_offset, json[QString("offset")]);
    m_offset_isSet = !json[QString("offset")].isNull() && m_offset_isValid;

    m_orders_isValid = ::OpenAPI::fromJsonValue(m_orders, json[QString("orders")]);
    m_orders_isSet = !json[QString("orders")].isNull() && m_orders_isValid;

    m_prev_isValid = ::OpenAPI::fromJsonValue(m_prev, json[QString("prev")]);
    m_prev_isSet = !json[QString("prev")].isNull() && m_prev_isValid;

    m_total_isValid = ::OpenAPI::fromJsonValue(m_total, json[QString("total")]);
    m_total_isSet = !json[QString("total")].isNull() && m_total_isValid;

    m_warnings_isValid = ::OpenAPI::fromJsonValue(m_warnings, json[QString("warnings")]);
    m_warnings_isSet = !json[QString("warnings")].isNull() && m_warnings_isValid;
}

QString OAIOrderSearchPagedCollection::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIOrderSearchPagedCollection::asJsonObject() const {
    QJsonObject obj;
    if (m_href_isSet) {
        obj.insert(QString("href"), ::OpenAPI::toJsonValue(m_href));
    }
    if (m_limit_isSet) {
        obj.insert(QString("limit"), ::OpenAPI::toJsonValue(m_limit));
    }
    if (m_next_isSet) {
        obj.insert(QString("next"), ::OpenAPI::toJsonValue(m_next));
    }
    if (m_offset_isSet) {
        obj.insert(QString("offset"), ::OpenAPI::toJsonValue(m_offset));
    }
    if (m_orders.size() > 0) {
        obj.insert(QString("orders"), ::OpenAPI::toJsonValue(m_orders));
    }
    if (m_prev_isSet) {
        obj.insert(QString("prev"), ::OpenAPI::toJsonValue(m_prev));
    }
    if (m_total_isSet) {
        obj.insert(QString("total"), ::OpenAPI::toJsonValue(m_total));
    }
    if (m_warnings.size() > 0) {
        obj.insert(QString("warnings"), ::OpenAPI::toJsonValue(m_warnings));
    }
    return obj;
}

QString OAIOrderSearchPagedCollection::getHref() const {
    return m_href;
}
void OAIOrderSearchPagedCollection::setHref(const QString &href) {
    m_href = href;
    m_href_isSet = true;
}

bool OAIOrderSearchPagedCollection::is_href_Set() const{
    return m_href_isSet;
}

bool OAIOrderSearchPagedCollection::is_href_Valid() const{
    return m_href_isValid;
}

qint32 OAIOrderSearchPagedCollection::getLimit() const {
    return m_limit;
}
void OAIOrderSearchPagedCollection::setLimit(const qint32 &limit) {
    m_limit = limit;
    m_limit_isSet = true;
}

bool OAIOrderSearchPagedCollection::is_limit_Set() const{
    return m_limit_isSet;
}

bool OAIOrderSearchPagedCollection::is_limit_Valid() const{
    return m_limit_isValid;
}

QString OAIOrderSearchPagedCollection::getNext() const {
    return m_next;
}
void OAIOrderSearchPagedCollection::setNext(const QString &next) {
    m_next = next;
    m_next_isSet = true;
}

bool OAIOrderSearchPagedCollection::is_next_Set() const{
    return m_next_isSet;
}

bool OAIOrderSearchPagedCollection::is_next_Valid() const{
    return m_next_isValid;
}

qint32 OAIOrderSearchPagedCollection::getOffset() const {
    return m_offset;
}
void OAIOrderSearchPagedCollection::setOffset(const qint32 &offset) {
    m_offset = offset;
    m_offset_isSet = true;
}

bool OAIOrderSearchPagedCollection::is_offset_Set() const{
    return m_offset_isSet;
}

bool OAIOrderSearchPagedCollection::is_offset_Valid() const{
    return m_offset_isValid;
}

QList<OAIOrder> OAIOrderSearchPagedCollection::getOrders() const {
    return m_orders;
}
void OAIOrderSearchPagedCollection::setOrders(const QList<OAIOrder> &orders) {
    m_orders = orders;
    m_orders_isSet = true;
}

bool OAIOrderSearchPagedCollection::is_orders_Set() const{
    return m_orders_isSet;
}

bool OAIOrderSearchPagedCollection::is_orders_Valid() const{
    return m_orders_isValid;
}

QString OAIOrderSearchPagedCollection::getPrev() const {
    return m_prev;
}
void OAIOrderSearchPagedCollection::setPrev(const QString &prev) {
    m_prev = prev;
    m_prev_isSet = true;
}

bool OAIOrderSearchPagedCollection::is_prev_Set() const{
    return m_prev_isSet;
}

bool OAIOrderSearchPagedCollection::is_prev_Valid() const{
    return m_prev_isValid;
}

qint32 OAIOrderSearchPagedCollection::getTotal() const {
    return m_total;
}
void OAIOrderSearchPagedCollection::setTotal(const qint32 &total) {
    m_total = total;
    m_total_isSet = true;
}

bool OAIOrderSearchPagedCollection::is_total_Set() const{
    return m_total_isSet;
}

bool OAIOrderSearchPagedCollection::is_total_Valid() const{
    return m_total_isValid;
}

QList<OAIError> OAIOrderSearchPagedCollection::getWarnings() const {
    return m_warnings;
}
void OAIOrderSearchPagedCollection::setWarnings(const QList<OAIError> &warnings) {
    m_warnings = warnings;
    m_warnings_isSet = true;
}

bool OAIOrderSearchPagedCollection::is_warnings_Set() const{
    return m_warnings_isSet;
}

bool OAIOrderSearchPagedCollection::is_warnings_Valid() const{
    return m_warnings_isValid;
}

bool OAIOrderSearchPagedCollection::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_href_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_next_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_offset_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_orders.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_prev_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_total_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_warnings.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIOrderSearchPagedCollection::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
