/*
 * Fulfillment API
 * Use the Fulfillment API to complete the process of packaging, addressing, handling, and shipping each order on behalf of the seller, in accordance with the payment method and timing specified at checkout.
 *
 * The version of the OpenAPI document: v1.20.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This type contains information about a buyer request to cancel an order.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:39:33.190773-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CancelRequest {
  public static final String SERIALIZED_NAME_CANCEL_COMPLETED_DATE = "cancelCompletedDate";
  @SerializedName(SERIALIZED_NAME_CANCEL_COMPLETED_DATE)
  private String cancelCompletedDate;

  public static final String SERIALIZED_NAME_CANCEL_INITIATOR = "cancelInitiator";
  @SerializedName(SERIALIZED_NAME_CANCEL_INITIATOR)
  private String cancelInitiator;

  public static final String SERIALIZED_NAME_CANCEL_REASON = "cancelReason";
  @SerializedName(SERIALIZED_NAME_CANCEL_REASON)
  private String cancelReason;

  public static final String SERIALIZED_NAME_CANCEL_REQUEST_ID = "cancelRequestId";
  @SerializedName(SERIALIZED_NAME_CANCEL_REQUEST_ID)
  private String cancelRequestId;

  public static final String SERIALIZED_NAME_CANCEL_REQUEST_STATE = "cancelRequestState";
  @SerializedName(SERIALIZED_NAME_CANCEL_REQUEST_STATE)
  private String cancelRequestState;

  public static final String SERIALIZED_NAME_CANCEL_REQUESTED_DATE = "cancelRequestedDate";
  @SerializedName(SERIALIZED_NAME_CANCEL_REQUESTED_DATE)
  private String cancelRequestedDate;

  public CancelRequest() {
  }

  public CancelRequest cancelCompletedDate(String cancelCompletedDate) {
    this.cancelCompletedDate = cancelCompletedDate;
    return this;
  }

  /**
   * The date and time that the order cancellation was completed, if applicable. This timestamp is in ISO 8601 format, which uses the 24-hour Universal Coordinated Time (UTC) clock. This field is not returned until the cancellation request has actually been approved by the seller.&lt;br&gt;&lt;br&gt;&lt;b&gt;Format:&lt;/b&gt; &lt;code&gt;[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss].[sss]Z&lt;/code&gt; &lt;br&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;2015-08-04T19:09:02.768Z&lt;/code&gt;
   * @return cancelCompletedDate
   */
  @javax.annotation.Nullable
  public String getCancelCompletedDate() {
    return cancelCompletedDate;
  }

  public void setCancelCompletedDate(String cancelCompletedDate) {
    this.cancelCompletedDate = cancelCompletedDate;
  }


  public CancelRequest cancelInitiator(String cancelInitiator) {
    this.cancelInitiator = cancelInitiator;
    return this;
  }

  /**
   * This string value indicates the party who made the initial cancellation request. Typically, either the &#39;Buyer&#39; or &#39;Seller&#39;. If a cancellation request has been made, this field should be returned.
   * @return cancelInitiator
   */
  @javax.annotation.Nullable
  public String getCancelInitiator() {
    return cancelInitiator;
  }

  public void setCancelInitiator(String cancelInitiator) {
    this.cancelInitiator = cancelInitiator;
  }


  public CancelRequest cancelReason(String cancelReason) {
    this.cancelReason = cancelReason;
    return this;
  }

  /**
   * The reason why the &lt;b&gt;cancelInitiator&lt;/b&gt; initiated the cancellation request. Cancellation reasons for a buyer might include &#39;order placed by mistake&#39; or &#39;order won&#39;t arrive in time&#39;. For a seller, a typical cancellation reason is &#39;out of stock&#39;. If a cancellation request has been made, this field should be returned.
   * @return cancelReason
   */
  @javax.annotation.Nullable
  public String getCancelReason() {
    return cancelReason;
  }

  public void setCancelReason(String cancelReason) {
    this.cancelReason = cancelReason;
  }


  public CancelRequest cancelRequestId(String cancelRequestId) {
    this.cancelRequestId = cancelRequestId;
    return this;
  }

  /**
   * The unique identifier of the order cancellation request. This field is returned for each cancellation request.
   * @return cancelRequestId
   */
  @javax.annotation.Nullable
  public String getCancelRequestId() {
    return cancelRequestId;
  }

  public void setCancelRequestId(String cancelRequestId) {
    this.cancelRequestId = cancelRequestId;
  }


  public CancelRequest cancelRequestState(String cancelRequestState) {
    this.cancelRequestState = cancelRequestState;
    return this;
  }

  /**
   * The current stage or condition of the cancellation request. This field is returned for each cancellation request. For implementation help, refer to &lt;a href&#x3D;&#39;https://developer.ebay.com/api-docs/sell/fulfillment/types/sel:CancelRequestStateEnum&#39;&gt;eBay API documentation&lt;/a&gt;
   * @return cancelRequestState
   */
  @javax.annotation.Nullable
  public String getCancelRequestState() {
    return cancelRequestState;
  }

  public void setCancelRequestState(String cancelRequestState) {
    this.cancelRequestState = cancelRequestState;
  }


  public CancelRequest cancelRequestedDate(String cancelRequestedDate) {
    this.cancelRequestedDate = cancelRequestedDate;
    return this;
  }

  /**
   * The date and time that the order cancellation was requested. This timestamp is in ISO 8601 format, which uses the 24-hour Universal Coordinated Time (UTC) clock. This field is returned for each cancellation request.&lt;br&gt;&lt;br&gt;&lt;b&gt;Format:&lt;/b&gt; &lt;code&gt;[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss].[sss]Z&lt;/code&gt; &lt;br&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;2015-08-04T19:09:02.768Z&lt;/code&gt;
   * @return cancelRequestedDate
   */
  @javax.annotation.Nullable
  public String getCancelRequestedDate() {
    return cancelRequestedDate;
  }

  public void setCancelRequestedDate(String cancelRequestedDate) {
    this.cancelRequestedDate = cancelRequestedDate;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CancelRequest cancelRequest = (CancelRequest) o;
    return Objects.equals(this.cancelCompletedDate, cancelRequest.cancelCompletedDate) &&
        Objects.equals(this.cancelInitiator, cancelRequest.cancelInitiator) &&
        Objects.equals(this.cancelReason, cancelRequest.cancelReason) &&
        Objects.equals(this.cancelRequestId, cancelRequest.cancelRequestId) &&
        Objects.equals(this.cancelRequestState, cancelRequest.cancelRequestState) &&
        Objects.equals(this.cancelRequestedDate, cancelRequest.cancelRequestedDate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cancelCompletedDate, cancelInitiator, cancelReason, cancelRequestId, cancelRequestState, cancelRequestedDate);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CancelRequest {\n");
    sb.append("    cancelCompletedDate: ").append(toIndentedString(cancelCompletedDate)).append("\n");
    sb.append("    cancelInitiator: ").append(toIndentedString(cancelInitiator)).append("\n");
    sb.append("    cancelReason: ").append(toIndentedString(cancelReason)).append("\n");
    sb.append("    cancelRequestId: ").append(toIndentedString(cancelRequestId)).append("\n");
    sb.append("    cancelRequestState: ").append(toIndentedString(cancelRequestState)).append("\n");
    sb.append("    cancelRequestedDate: ").append(toIndentedString(cancelRequestedDate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cancelCompletedDate");
    openapiFields.add("cancelInitiator");
    openapiFields.add("cancelReason");
    openapiFields.add("cancelRequestId");
    openapiFields.add("cancelRequestState");
    openapiFields.add("cancelRequestedDate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CancelRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CancelRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CancelRequest is not found in the empty JSON string", CancelRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CancelRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CancelRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("cancelCompletedDate") != null && !jsonObj.get("cancelCompletedDate").isJsonNull()) && !jsonObj.get("cancelCompletedDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cancelCompletedDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cancelCompletedDate").toString()));
      }
      if ((jsonObj.get("cancelInitiator") != null && !jsonObj.get("cancelInitiator").isJsonNull()) && !jsonObj.get("cancelInitiator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cancelInitiator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cancelInitiator").toString()));
      }
      if ((jsonObj.get("cancelReason") != null && !jsonObj.get("cancelReason").isJsonNull()) && !jsonObj.get("cancelReason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cancelReason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cancelReason").toString()));
      }
      if ((jsonObj.get("cancelRequestId") != null && !jsonObj.get("cancelRequestId").isJsonNull()) && !jsonObj.get("cancelRequestId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cancelRequestId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cancelRequestId").toString()));
      }
      if ((jsonObj.get("cancelRequestState") != null && !jsonObj.get("cancelRequestState").isJsonNull()) && !jsonObj.get("cancelRequestState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cancelRequestState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cancelRequestState").toString()));
      }
      if ((jsonObj.get("cancelRequestedDate") != null && !jsonObj.get("cancelRequestedDate").isJsonNull()) && !jsonObj.get("cancelRequestedDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cancelRequestedDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cancelRequestedDate").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CancelRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CancelRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CancelRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CancelRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CancelRequest>() {
           @Override
           public void write(JsonWriter out, CancelRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CancelRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CancelRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CancelRequest
   * @throws IOException if the JSON string is invalid with respect to CancelRequest
   */
  public static CancelRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CancelRequest.class);
  }

  /**
   * Convert an instance of CancelRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

