/*
 * Fulfillment API
 * Use the Fulfillment API to complete the process of packaging, addressing, handling, and shipping each order on behalf of the seller, in accordance with the payment method and timing specified at checkout.
 *
 * The version of the OpenAPI document: v1.20.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Amount;
import org.openapitools.client.model.OrderRefund;
import org.openapitools.client.model.Payment;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This type contains information about the various monetary exchanges that apply to the net balance due for the order.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:39:33.190773-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PaymentSummary {
  public static final String SERIALIZED_NAME_PAYMENTS = "payments";
  @SerializedName(SERIALIZED_NAME_PAYMENTS)
  private List<Payment> payments = new ArrayList<>();

  public static final String SERIALIZED_NAME_REFUNDS = "refunds";
  @SerializedName(SERIALIZED_NAME_REFUNDS)
  private List<OrderRefund> refunds = new ArrayList<>();

  public static final String SERIALIZED_NAME_TOTAL_DUE_SELLER = "totalDueSeller";
  @SerializedName(SERIALIZED_NAME_TOTAL_DUE_SELLER)
  private Amount totalDueSeller;

  public PaymentSummary() {
  }

  public PaymentSummary payments(List<Payment> payments) {
    this.payments = payments;
    return this;
  }

  public PaymentSummary addPaymentsItem(Payment paymentsItem) {
    if (this.payments == null) {
      this.payments = new ArrayList<>();
    }
    this.payments.add(paymentsItem);
    return this;
  }

  /**
   * This array consists of payment information for the order, including payment status, payment method, payment amount, and payment date. This array is always returned, although some of the fields under this container will not be returned until payment has been made.
   * @return payments
   */
  @javax.annotation.Nullable
  public List<Payment> getPayments() {
    return payments;
  }

  public void setPayments(List<Payment> payments) {
    this.payments = payments;
  }


  public PaymentSummary refunds(List<OrderRefund> refunds) {
    this.refunds = refunds;
    return this;
  }

  public PaymentSummary addRefundsItem(OrderRefund refundsItem) {
    if (this.refunds == null) {
      this.refunds = new ArrayList<>();
    }
    this.refunds.add(refundsItem);
    return this;
  }

  /**
   * This array is always returned, but is returned as an empty array unless the seller has submitted a partial or full refund to the buyer for the order. If a refund has occurred, the refund amount and refund date will be shown for each refund.
   * @return refunds
   */
  @javax.annotation.Nullable
  public List<OrderRefund> getRefunds() {
    return refunds;
  }

  public void setRefunds(List<OrderRefund> refunds) {
    this.refunds = refunds;
  }


  public PaymentSummary totalDueSeller(Amount totalDueSeller) {
    this.totalDueSeller = totalDueSeller;
    return this;
  }

  /**
   * Get totalDueSeller
   * @return totalDueSeller
   */
  @javax.annotation.Nullable
  public Amount getTotalDueSeller() {
    return totalDueSeller;
  }

  public void setTotalDueSeller(Amount totalDueSeller) {
    this.totalDueSeller = totalDueSeller;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PaymentSummary paymentSummary = (PaymentSummary) o;
    return Objects.equals(this.payments, paymentSummary.payments) &&
        Objects.equals(this.refunds, paymentSummary.refunds) &&
        Objects.equals(this.totalDueSeller, paymentSummary.totalDueSeller);
  }

  @Override
  public int hashCode() {
    return Objects.hash(payments, refunds, totalDueSeller);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PaymentSummary {\n");
    sb.append("    payments: ").append(toIndentedString(payments)).append("\n");
    sb.append("    refunds: ").append(toIndentedString(refunds)).append("\n");
    sb.append("    totalDueSeller: ").append(toIndentedString(totalDueSeller)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("payments");
    openapiFields.add("refunds");
    openapiFields.add("totalDueSeller");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PaymentSummary
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PaymentSummary.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PaymentSummary is not found in the empty JSON string", PaymentSummary.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PaymentSummary.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PaymentSummary` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("payments") != null && !jsonObj.get("payments").isJsonNull()) {
        JsonArray jsonArraypayments = jsonObj.getAsJsonArray("payments");
        if (jsonArraypayments != null) {
          // ensure the json data is an array
          if (!jsonObj.get("payments").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `payments` to be an array in the JSON string but got `%s`", jsonObj.get("payments").toString()));
          }

          // validate the optional field `payments` (array)
          for (int i = 0; i < jsonArraypayments.size(); i++) {
            Payment.validateJsonElement(jsonArraypayments.get(i));
          };
        }
      }
      if (jsonObj.get("refunds") != null && !jsonObj.get("refunds").isJsonNull()) {
        JsonArray jsonArrayrefunds = jsonObj.getAsJsonArray("refunds");
        if (jsonArrayrefunds != null) {
          // ensure the json data is an array
          if (!jsonObj.get("refunds").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `refunds` to be an array in the JSON string but got `%s`", jsonObj.get("refunds").toString()));
          }

          // validate the optional field `refunds` (array)
          for (int i = 0; i < jsonArrayrefunds.size(); i++) {
            OrderRefund.validateJsonElement(jsonArrayrefunds.get(i));
          };
        }
      }
      // validate the optional field `totalDueSeller`
      if (jsonObj.get("totalDueSeller") != null && !jsonObj.get("totalDueSeller").isJsonNull()) {
        Amount.validateJsonElement(jsonObj.get("totalDueSeller"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PaymentSummary.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PaymentSummary' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PaymentSummary> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PaymentSummary.class));

       return (TypeAdapter<T>) new TypeAdapter<PaymentSummary>() {
           @Override
           public void write(JsonWriter out, PaymentSummary value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PaymentSummary read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PaymentSummary given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PaymentSummary
   * @throws IOException if the JSON string is invalid with respect to PaymentSummary
   */
  public static PaymentSummary fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PaymentSummary.class);
  }

  /**
   * Convert an instance of PaymentSummary to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

