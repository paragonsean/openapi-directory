/*
 * Fulfillment API
 * Use the Fulfillment API to complete the process of packaging, addressing, handling, and shipping each order on behalf of the seller, in accordance with the payment method and timing specified at checkout.
 *
 * The version of the OpenAPI document: v1.20.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Address;
import org.openapitools.client.model.PickupStep;
import org.openapitools.client.model.ShippingStep;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This type contains a set of specifications for processing a fulfillment of an order, including the type of fulfillment, shipping carrier and service, addressing details, and estimated delivery window. These instructions are derived from the buyer&#39;s and seller&#39;s eBay account preferences, the listing parameters, and the buyer&#39;s checkout selections. The seller can use them as a starting point for packaging, addressing, and shipping the order.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:39:33.190773-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FulfillmentStartInstruction {
  public static final String SERIALIZED_NAME_EBAY_SUPPORTED_FULFILLMENT = "ebaySupportedFulfillment";
  @SerializedName(SERIALIZED_NAME_EBAY_SUPPORTED_FULFILLMENT)
  private Boolean ebaySupportedFulfillment;

  public static final String SERIALIZED_NAME_FINAL_DESTINATION_ADDRESS = "finalDestinationAddress";
  @SerializedName(SERIALIZED_NAME_FINAL_DESTINATION_ADDRESS)
  private Address finalDestinationAddress;

  public static final String SERIALIZED_NAME_FULFILLMENT_INSTRUCTIONS_TYPE = "fulfillmentInstructionsType";
  @SerializedName(SERIALIZED_NAME_FULFILLMENT_INSTRUCTIONS_TYPE)
  private String fulfillmentInstructionsType;

  public static final String SERIALIZED_NAME_MAX_ESTIMATED_DELIVERY_DATE = "maxEstimatedDeliveryDate";
  @SerializedName(SERIALIZED_NAME_MAX_ESTIMATED_DELIVERY_DATE)
  private String maxEstimatedDeliveryDate;

  public static final String SERIALIZED_NAME_MIN_ESTIMATED_DELIVERY_DATE = "minEstimatedDeliveryDate";
  @SerializedName(SERIALIZED_NAME_MIN_ESTIMATED_DELIVERY_DATE)
  private String minEstimatedDeliveryDate;

  public static final String SERIALIZED_NAME_PICKUP_STEP = "pickupStep";
  @SerializedName(SERIALIZED_NAME_PICKUP_STEP)
  private PickupStep pickupStep;

  public static final String SERIALIZED_NAME_SHIPPING_STEP = "shippingStep";
  @SerializedName(SERIALIZED_NAME_SHIPPING_STEP)
  private ShippingStep shippingStep;

  public FulfillmentStartInstruction() {
  }

  public FulfillmentStartInstruction ebaySupportedFulfillment(Boolean ebaySupportedFulfillment) {
    this.ebaySupportedFulfillment = ebaySupportedFulfillment;
    return this;
  }

  /**
   * This field is only returned if its value is &lt;code&gt;true&lt;/code&gt; and indicates that the fulfillment will be shipped via eBay&#39;s Global Shipping Program, eBay International Shipping, or the Authenticity Guarantee service program. &lt;br&gt;&lt;br&gt;For more information, see the &lt;a href&#x3D;\&quot;https://www.ebay.com/help/selling/shipping-items/setting-shipping-options/global-shipping-program?id&#x3D;4646 \&quot; target&#x3D;\&quot;_blank\&quot;&gt;Global Shipping Program&lt;/a&gt; help topic.
   * @return ebaySupportedFulfillment
   */
  @javax.annotation.Nullable
  public Boolean getEbaySupportedFulfillment() {
    return ebaySupportedFulfillment;
  }

  public void setEbaySupportedFulfillment(Boolean ebaySupportedFulfillment) {
    this.ebaySupportedFulfillment = ebaySupportedFulfillment;
  }


  public FulfillmentStartInstruction finalDestinationAddress(Address finalDestinationAddress) {
    this.finalDestinationAddress = finalDestinationAddress;
    return this;
  }

  /**
   * Get finalDestinationAddress
   * @return finalDestinationAddress
   */
  @javax.annotation.Nullable
  public Address getFinalDestinationAddress() {
    return finalDestinationAddress;
  }

  public void setFinalDestinationAddress(Address finalDestinationAddress) {
    this.finalDestinationAddress = finalDestinationAddress;
  }


  public FulfillmentStartInstruction fulfillmentInstructionsType(String fulfillmentInstructionsType) {
    this.fulfillmentInstructionsType = fulfillmentInstructionsType;
    return this;
  }

  /**
   * The enumeration value returned in this field indicates the method of fulfillment that will be used to deliver this set of line items (this package) to the buyer. This field will have a value of &lt;code&gt;SHIP_TO&lt;/code&gt; if the &lt;b&gt;ebaySupportedFulfillment&lt;/b&gt; field is returned with a value of &lt;code&gt;true&lt;/code&gt;. See the &lt;strong&gt;FulfillmentInstructionsType&lt;/strong&gt; definition for more information about different fulfillment types. For implementation help, refer to &lt;a href&#x3D;&#39;https://developer.ebay.com/api-docs/sell/fulfillment/types/sel:FulfillmentInstructionsType&#39;&gt;eBay API documentation&lt;/a&gt;
   * @return fulfillmentInstructionsType
   */
  @javax.annotation.Nullable
  public String getFulfillmentInstructionsType() {
    return fulfillmentInstructionsType;
  }

  public void setFulfillmentInstructionsType(String fulfillmentInstructionsType) {
    this.fulfillmentInstructionsType = fulfillmentInstructionsType;
  }


  public FulfillmentStartInstruction maxEstimatedDeliveryDate(String maxEstimatedDeliveryDate) {
    this.maxEstimatedDeliveryDate = maxEstimatedDeliveryDate;
    return this;
  }

  /**
   * This is the estimated latest date that the fulfillment will be completed. This timestamp is in ISO 8601 format, which uses the 24-hour Universal Coordinated Time (UTC) clock. This field is not returned ifthe value of the &lt;b&gt;fulfillmentInstructionsType&lt;/b&gt; field is &lt;code&gt;DIGITAL&lt;/code&gt; or &lt;code&gt;PREPARE_FOR_PICKUP&lt;/code&gt;.  &lt;br&gt;&lt;br&gt;&lt;b&gt;Format:&lt;/b&gt; &lt;code&gt;[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss].[sss]Z&lt;/code&gt; &lt;br&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;2015-08-04T19:09:02.768Z&lt;/code&gt;
   * @return maxEstimatedDeliveryDate
   */
  @javax.annotation.Nullable
  public String getMaxEstimatedDeliveryDate() {
    return maxEstimatedDeliveryDate;
  }

  public void setMaxEstimatedDeliveryDate(String maxEstimatedDeliveryDate) {
    this.maxEstimatedDeliveryDate = maxEstimatedDeliveryDate;
  }


  public FulfillmentStartInstruction minEstimatedDeliveryDate(String minEstimatedDeliveryDate) {
    this.minEstimatedDeliveryDate = minEstimatedDeliveryDate;
    return this;
  }

  /**
   * This is the estimated earliest date that the fulfillment will be completed. This timestamp is in ISO 8601 format, which uses the 24-hour Universal Coordinated Time (UTC) clock. This field is not returned if  the value of the &lt;b&gt;fulfillmentInstructionsType&lt;/b&gt; field is &lt;code&gt;DIGITAL&lt;/code&gt; or &lt;code&gt;PREPARE_FOR_PICKUP&lt;/code&gt;.  &lt;br&gt;&lt;br&gt;&lt;b&gt;Format:&lt;/b&gt; &lt;code&gt;[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss].[sss]Z&lt;/code&gt; &lt;br&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;2015-08-04T19:09:02.768Z&lt;/code&gt;
   * @return minEstimatedDeliveryDate
   */
  @javax.annotation.Nullable
  public String getMinEstimatedDeliveryDate() {
    return minEstimatedDeliveryDate;
  }

  public void setMinEstimatedDeliveryDate(String minEstimatedDeliveryDate) {
    this.minEstimatedDeliveryDate = minEstimatedDeliveryDate;
  }


  public FulfillmentStartInstruction pickupStep(PickupStep pickupStep) {
    this.pickupStep = pickupStep;
    return this;
  }

  /**
   * Get pickupStep
   * @return pickupStep
   */
  @javax.annotation.Nullable
  public PickupStep getPickupStep() {
    return pickupStep;
  }

  public void setPickupStep(PickupStep pickupStep) {
    this.pickupStep = pickupStep;
  }


  public FulfillmentStartInstruction shippingStep(ShippingStep shippingStep) {
    this.shippingStep = shippingStep;
    return this;
  }

  /**
   * Get shippingStep
   * @return shippingStep
   */
  @javax.annotation.Nullable
  public ShippingStep getShippingStep() {
    return shippingStep;
  }

  public void setShippingStep(ShippingStep shippingStep) {
    this.shippingStep = shippingStep;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FulfillmentStartInstruction fulfillmentStartInstruction = (FulfillmentStartInstruction) o;
    return Objects.equals(this.ebaySupportedFulfillment, fulfillmentStartInstruction.ebaySupportedFulfillment) &&
        Objects.equals(this.finalDestinationAddress, fulfillmentStartInstruction.finalDestinationAddress) &&
        Objects.equals(this.fulfillmentInstructionsType, fulfillmentStartInstruction.fulfillmentInstructionsType) &&
        Objects.equals(this.maxEstimatedDeliveryDate, fulfillmentStartInstruction.maxEstimatedDeliveryDate) &&
        Objects.equals(this.minEstimatedDeliveryDate, fulfillmentStartInstruction.minEstimatedDeliveryDate) &&
        Objects.equals(this.pickupStep, fulfillmentStartInstruction.pickupStep) &&
        Objects.equals(this.shippingStep, fulfillmentStartInstruction.shippingStep);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ebaySupportedFulfillment, finalDestinationAddress, fulfillmentInstructionsType, maxEstimatedDeliveryDate, minEstimatedDeliveryDate, pickupStep, shippingStep);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FulfillmentStartInstruction {\n");
    sb.append("    ebaySupportedFulfillment: ").append(toIndentedString(ebaySupportedFulfillment)).append("\n");
    sb.append("    finalDestinationAddress: ").append(toIndentedString(finalDestinationAddress)).append("\n");
    sb.append("    fulfillmentInstructionsType: ").append(toIndentedString(fulfillmentInstructionsType)).append("\n");
    sb.append("    maxEstimatedDeliveryDate: ").append(toIndentedString(maxEstimatedDeliveryDate)).append("\n");
    sb.append("    minEstimatedDeliveryDate: ").append(toIndentedString(minEstimatedDeliveryDate)).append("\n");
    sb.append("    pickupStep: ").append(toIndentedString(pickupStep)).append("\n");
    sb.append("    shippingStep: ").append(toIndentedString(shippingStep)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ebaySupportedFulfillment");
    openapiFields.add("finalDestinationAddress");
    openapiFields.add("fulfillmentInstructionsType");
    openapiFields.add("maxEstimatedDeliveryDate");
    openapiFields.add("minEstimatedDeliveryDate");
    openapiFields.add("pickupStep");
    openapiFields.add("shippingStep");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FulfillmentStartInstruction
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FulfillmentStartInstruction.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FulfillmentStartInstruction is not found in the empty JSON string", FulfillmentStartInstruction.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FulfillmentStartInstruction.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FulfillmentStartInstruction` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `finalDestinationAddress`
      if (jsonObj.get("finalDestinationAddress") != null && !jsonObj.get("finalDestinationAddress").isJsonNull()) {
        Address.validateJsonElement(jsonObj.get("finalDestinationAddress"));
      }
      if ((jsonObj.get("fulfillmentInstructionsType") != null && !jsonObj.get("fulfillmentInstructionsType").isJsonNull()) && !jsonObj.get("fulfillmentInstructionsType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fulfillmentInstructionsType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fulfillmentInstructionsType").toString()));
      }
      if ((jsonObj.get("maxEstimatedDeliveryDate") != null && !jsonObj.get("maxEstimatedDeliveryDate").isJsonNull()) && !jsonObj.get("maxEstimatedDeliveryDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxEstimatedDeliveryDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxEstimatedDeliveryDate").toString()));
      }
      if ((jsonObj.get("minEstimatedDeliveryDate") != null && !jsonObj.get("minEstimatedDeliveryDate").isJsonNull()) && !jsonObj.get("minEstimatedDeliveryDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minEstimatedDeliveryDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minEstimatedDeliveryDate").toString()));
      }
      // validate the optional field `pickupStep`
      if (jsonObj.get("pickupStep") != null && !jsonObj.get("pickupStep").isJsonNull()) {
        PickupStep.validateJsonElement(jsonObj.get("pickupStep"));
      }
      // validate the optional field `shippingStep`
      if (jsonObj.get("shippingStep") != null && !jsonObj.get("shippingStep").isJsonNull()) {
        ShippingStep.validateJsonElement(jsonObj.get("shippingStep"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FulfillmentStartInstruction.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FulfillmentStartInstruction' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FulfillmentStartInstruction> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FulfillmentStartInstruction.class));

       return (TypeAdapter<T>) new TypeAdapter<FulfillmentStartInstruction>() {
           @Override
           public void write(JsonWriter out, FulfillmentStartInstruction value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FulfillmentStartInstruction read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FulfillmentStartInstruction given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FulfillmentStartInstruction
   * @throws IOException if the JSON string is invalid with respect to FulfillmentStartInstruction
   */
  public static FulfillmentStartInstruction fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FulfillmentStartInstruction.class);
  }

  /**
   * Convert an instance of FulfillmentStartInstruction to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

