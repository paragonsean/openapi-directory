/*
 * Fulfillment API
 * Use the Fulfillment API to complete the process of packaging, addressing, handling, and shipping each order on behalf of the seller, in accordance with the payment method and timing specified at checkout.
 *
 * The version of the OpenAPI document: v1.20.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Amount;
import org.openapitools.client.model.SellerActionsToRelease;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This type contains information about a hold placed on a payment to a seller for an order, including the reason why the buyer&#39;s payment for the order is being held, the expected release date of the funds into the seller&#39;s account, the current state of the hold, and the actual release date if the payment has been released, and possible actions the seller can take to expedite the payout of funds into their account.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:39:33.190773-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PaymentHold {
  public static final String SERIALIZED_NAME_EXPECTED_RELEASE_DATE = "expectedReleaseDate";
  @SerializedName(SERIALIZED_NAME_EXPECTED_RELEASE_DATE)
  private String expectedReleaseDate;

  public static final String SERIALIZED_NAME_HOLD_AMOUNT = "holdAmount";
  @SerializedName(SERIALIZED_NAME_HOLD_AMOUNT)
  private Amount holdAmount;

  public static final String SERIALIZED_NAME_HOLD_REASON = "holdReason";
  @SerializedName(SERIALIZED_NAME_HOLD_REASON)
  private String holdReason;

  public static final String SERIALIZED_NAME_HOLD_STATE = "holdState";
  @SerializedName(SERIALIZED_NAME_HOLD_STATE)
  private String holdState;

  public static final String SERIALIZED_NAME_RELEASE_DATE = "releaseDate";
  @SerializedName(SERIALIZED_NAME_RELEASE_DATE)
  private String releaseDate;

  public static final String SERIALIZED_NAME_SELLER_ACTIONS_TO_RELEASE = "sellerActionsToRelease";
  @SerializedName(SERIALIZED_NAME_SELLER_ACTIONS_TO_RELEASE)
  private List<SellerActionsToRelease> sellerActionsToRelease = new ArrayList<>();

  public PaymentHold() {
  }

  public PaymentHold expectedReleaseDate(String expectedReleaseDate) {
    this.expectedReleaseDate = expectedReleaseDate;
    return this;
  }

  /**
   * The date and time that the payment being held is expected to be released to the seller. This timestamp is in ISO 8601 format, which uses the 24-hour Universal Coordinated Time (UTC) clock. This field will be returned if known by eBay. &lt;br&gt;&lt;br&gt;&lt;b&gt;Format:&lt;/b&gt; &lt;code&gt;[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss].[sss]Z&lt;/code&gt; &lt;br&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;2015-08-04T19:09:02.768Z&lt;/code&gt;
   * @return expectedReleaseDate
   */
  @javax.annotation.Nullable
  public String getExpectedReleaseDate() {
    return expectedReleaseDate;
  }

  public void setExpectedReleaseDate(String expectedReleaseDate) {
    this.expectedReleaseDate = expectedReleaseDate;
  }


  public PaymentHold holdAmount(Amount holdAmount) {
    this.holdAmount = holdAmount;
    return this;
  }

  /**
   * Get holdAmount
   * @return holdAmount
   */
  @javax.annotation.Nullable
  public Amount getHoldAmount() {
    return holdAmount;
  }

  public void setHoldAmount(Amount holdAmount) {
    this.holdAmount = holdAmount;
  }


  public PaymentHold holdReason(String holdReason) {
    this.holdReason = holdReason;
    return this;
  }

  /**
   * The reason that the payment is being held. A seller&#39;s payment may be held for a number of reasons, including when the seller is new, the seller&#39;s level is below standard, or if a return case or &#39;Significantly not as described&#39; case is pending against the seller. This field is always returned with the &lt;strong&gt;paymentHolds&lt;/strong&gt; array.
   * @return holdReason
   */
  @javax.annotation.Nullable
  public String getHoldReason() {
    return holdReason;
  }

  public void setHoldReason(String holdReason) {
    this.holdReason = holdReason;
  }


  public PaymentHold holdState(String holdState) {
    this.holdState = holdState;
    return this;
  }

  /**
   * The current stage or condition of the hold. This field is always returned with the &lt;strong&gt;paymentHolds&lt;/strong&gt; array.&lt;br&gt;&lt;br&gt;&lt;b&gt;Applicable values:&lt;/b&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;HELD&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;HELD_PENDING&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;NOT_HELD&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;RELEASE_CONFIRMED&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;RELEASE_FAILED&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;RELEASE_PENDING&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;RELEASED&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
   * @return holdState
   */
  @javax.annotation.Nullable
  public String getHoldState() {
    return holdState;
  }

  public void setHoldState(String holdState) {
    this.holdState = holdState;
  }


  public PaymentHold releaseDate(String releaseDate) {
    this.releaseDate = releaseDate;
    return this;
  }

  /**
   * The date and time that the payment being held was actually released to the seller. This timestamp is in ISO 8601 format, which uses the 24-hour Universal Coordinated Time (UTC) clock. This field is not returned until the seller&#39;s payment is actually released into the seller&#39;s account.&lt;br&gt;&lt;br&gt;&lt;b&gt;Format:&lt;/b&gt; &lt;code&gt;[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss].[sss]Z&lt;/code&gt; &lt;br&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;2015-08-04T19:09:02.768Z&lt;/code&gt;
   * @return releaseDate
   */
  @javax.annotation.Nullable
  public String getReleaseDate() {
    return releaseDate;
  }

  public void setReleaseDate(String releaseDate) {
    this.releaseDate = releaseDate;
  }


  public PaymentHold sellerActionsToRelease(List<SellerActionsToRelease> sellerActionsToRelease) {
    this.sellerActionsToRelease = sellerActionsToRelease;
    return this;
  }

  public PaymentHold addSellerActionsToReleaseItem(SellerActionsToRelease sellerActionsToReleaseItem) {
    if (this.sellerActionsToRelease == null) {
      this.sellerActionsToRelease = new ArrayList<>();
    }
    this.sellerActionsToRelease.add(sellerActionsToReleaseItem);
    return this;
  }

  /**
   * A list of one or more possible actions that the seller can take to expedite the release of the payment hold.
   * @return sellerActionsToRelease
   */
  @javax.annotation.Nullable
  public List<SellerActionsToRelease> getSellerActionsToRelease() {
    return sellerActionsToRelease;
  }

  public void setSellerActionsToRelease(List<SellerActionsToRelease> sellerActionsToRelease) {
    this.sellerActionsToRelease = sellerActionsToRelease;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PaymentHold paymentHold = (PaymentHold) o;
    return Objects.equals(this.expectedReleaseDate, paymentHold.expectedReleaseDate) &&
        Objects.equals(this.holdAmount, paymentHold.holdAmount) &&
        Objects.equals(this.holdReason, paymentHold.holdReason) &&
        Objects.equals(this.holdState, paymentHold.holdState) &&
        Objects.equals(this.releaseDate, paymentHold.releaseDate) &&
        Objects.equals(this.sellerActionsToRelease, paymentHold.sellerActionsToRelease);
  }

  @Override
  public int hashCode() {
    return Objects.hash(expectedReleaseDate, holdAmount, holdReason, holdState, releaseDate, sellerActionsToRelease);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PaymentHold {\n");
    sb.append("    expectedReleaseDate: ").append(toIndentedString(expectedReleaseDate)).append("\n");
    sb.append("    holdAmount: ").append(toIndentedString(holdAmount)).append("\n");
    sb.append("    holdReason: ").append(toIndentedString(holdReason)).append("\n");
    sb.append("    holdState: ").append(toIndentedString(holdState)).append("\n");
    sb.append("    releaseDate: ").append(toIndentedString(releaseDate)).append("\n");
    sb.append("    sellerActionsToRelease: ").append(toIndentedString(sellerActionsToRelease)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("expectedReleaseDate");
    openapiFields.add("holdAmount");
    openapiFields.add("holdReason");
    openapiFields.add("holdState");
    openapiFields.add("releaseDate");
    openapiFields.add("sellerActionsToRelease");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PaymentHold
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PaymentHold.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PaymentHold is not found in the empty JSON string", PaymentHold.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PaymentHold.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PaymentHold` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("expectedReleaseDate") != null && !jsonObj.get("expectedReleaseDate").isJsonNull()) && !jsonObj.get("expectedReleaseDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expectedReleaseDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expectedReleaseDate").toString()));
      }
      // validate the optional field `holdAmount`
      if (jsonObj.get("holdAmount") != null && !jsonObj.get("holdAmount").isJsonNull()) {
        Amount.validateJsonElement(jsonObj.get("holdAmount"));
      }
      if ((jsonObj.get("holdReason") != null && !jsonObj.get("holdReason").isJsonNull()) && !jsonObj.get("holdReason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `holdReason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("holdReason").toString()));
      }
      if ((jsonObj.get("holdState") != null && !jsonObj.get("holdState").isJsonNull()) && !jsonObj.get("holdState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `holdState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("holdState").toString()));
      }
      if ((jsonObj.get("releaseDate") != null && !jsonObj.get("releaseDate").isJsonNull()) && !jsonObj.get("releaseDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `releaseDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("releaseDate").toString()));
      }
      if (jsonObj.get("sellerActionsToRelease") != null && !jsonObj.get("sellerActionsToRelease").isJsonNull()) {
        JsonArray jsonArraysellerActionsToRelease = jsonObj.getAsJsonArray("sellerActionsToRelease");
        if (jsonArraysellerActionsToRelease != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sellerActionsToRelease").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sellerActionsToRelease` to be an array in the JSON string but got `%s`", jsonObj.get("sellerActionsToRelease").toString()));
          }

          // validate the optional field `sellerActionsToRelease` (array)
          for (int i = 0; i < jsonArraysellerActionsToRelease.size(); i++) {
            SellerActionsToRelease.validateJsonElement(jsonArraysellerActionsToRelease.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PaymentHold.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PaymentHold' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PaymentHold> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PaymentHold.class));

       return (TypeAdapter<T>) new TypeAdapter<PaymentHold>() {
           @Override
           public void write(JsonWriter out, PaymentHold value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PaymentHold read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PaymentHold given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PaymentHold
   * @throws IOException if the JSON string is invalid with respect to PaymentHold
   */
  public static PaymentHold fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PaymentHold.class);
  }

  /**
   * Convert an instance of PaymentHold to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

