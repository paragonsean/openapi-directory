/*
 * Analytics API
 * The <b>Analytics API</b> retrieves call-limit data and the quotas that are set for the RESTful APIs and the legacy Trading API.  <br><br>Responses from calls made to <b>getRateLimits</b> and <b>getUerRateLimits</b> include a list of the applicable resources and the \"call limit\", or quota, that is set for each resource. In addition to quota information, the response also includes the number of remaining calls available before the limit is reached, the time remaining before the quota resets, and the length of the \"time window\" to which the quota applies.  <br><br>The <b>getRateLimits</b> and <b>getUserRateLimits</b> methods retrieve call-limit information for either an application or user, respectively, and each method must be called with an appropriate OAuth token. That is, <b>getRateLimites</b> requires an access token generated with a client credentials grant and <b>getUserRateLimites</b> requires an access token generated with an authorization code grant. For more information, see <a href=\"/api-docs/static/oauth-tokens.html\">OAuth tokens</a>.  <br><br>Users can analyze the response data to see whether or not a limit might be reached, and from that determine if any action needs to be taken (such as programmatically throttling their request rate). For more on call limits, see <a href=\"https://developer.ebay.com/support/app-check \" target=\"_blank\">Compatible Application Check</a>.
 *
 * The version of the OpenAPI document: v1_beta.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * This complex type defines a \&quot;rate\&quot; as the quota of calls that can be made to a resource per time window, the remaining number of calls before the threshold is met, the amount of time until the time window resets, and the length of the time window (in seconds).
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:39:35.701874-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Rate {
  public static final String SERIALIZED_NAME_LIMIT = "limit";
  @SerializedName(SERIALIZED_NAME_LIMIT)
  private Integer limit;

  public static final String SERIALIZED_NAME_REMAINING = "remaining";
  @SerializedName(SERIALIZED_NAME_REMAINING)
  private Integer remaining;

  public static final String SERIALIZED_NAME_RESET = "reset";
  @SerializedName(SERIALIZED_NAME_RESET)
  private String reset;

  public static final String SERIALIZED_NAME_TIME_WINDOW = "timeWindow";
  @SerializedName(SERIALIZED_NAME_TIME_WINDOW)
  private Integer timeWindow;

  public Rate() {
  }

  public Rate limit(Integer limit) {
    this.limit = limit;
    return this;
  }

  /**
   * The maximum number of requests that can be made to this resource during a set time period. The length of time to which the limit is applied is defined by the associated &lt;b&gt;timeWindow&lt;/b&gt; value.  &lt;br&gt;&lt;br&gt;This value is often referred to as the \&quot;call quota\&quot; for the resource.
   * @return limit
   */
  @javax.annotation.Nullable
  public Integer getLimit() {
    return limit;
  }

  public void setLimit(Integer limit) {
    this.limit = limit;
  }


  public Rate remaining(Integer remaining) {
    this.remaining = remaining;
    return this;
  }

  /**
   * The remaining number of requests that can be made to this resource before the associated time window resets.
   * @return remaining
   */
  @javax.annotation.Nullable
  public Integer getRemaining() {
    return remaining;
  }

  public void setRemaining(Integer remaining) {
    this.remaining = remaining;
  }


  public Rate reset(String reset) {
    this.reset = reset;
    return this;
  }

  /**
   * The data and time the time window and accumulated calls for this resource reset.  &lt;br&gt;&lt;br&gt;When the &lt;b&gt;reset&lt;/b&gt; time is reached, the &lt;b&gt;remaining&lt;/b&gt; value is reset to the value of &lt;b&gt;limit&lt;/b&gt;, and this &lt;b&gt;reset&lt;/b&gt; value is reset to the current time plus the number of seconds defined by the &lt;b&gt;timeWindow&lt;/b&gt; value. &lt;br&gt;&lt;br&gt;The time stamp is formatted as an &lt;a href&#x3D;\&quot;http://www.iso.org/iso/home/standards/iso8601.htm \&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO 8601&lt;/a&gt; string, which is based on the 24-hour Universal Coordinated Time (UTC) clock. &lt;br&gt;&lt;br&gt;&lt;b&gt;Format:&lt;/b&gt; &lt;code&gt;[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss].[sss]Z&lt;/code&gt; &lt;br&gt;&lt;b&gt;Example:&lt;/b&gt; &lt;code&gt;2018-08-04T07:09:00.000Z&lt;/code&gt;
   * @return reset
   */
  @javax.annotation.Nullable
  public String getReset() {
    return reset;
  }

  public void setReset(String reset) {
    this.reset = reset;
  }


  public Rate timeWindow(Integer timeWindow) {
    this.timeWindow = timeWindow;
    return this;
  }

  /**
   * A period of time, expressed in seconds. The call quota for a resource is applied to the period of time defined by the value of this field.
   * @return timeWindow
   */
  @javax.annotation.Nullable
  public Integer getTimeWindow() {
    return timeWindow;
  }

  public void setTimeWindow(Integer timeWindow) {
    this.timeWindow = timeWindow;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Rate rate = (Rate) o;
    return Objects.equals(this.limit, rate.limit) &&
        Objects.equals(this.remaining, rate.remaining) &&
        Objects.equals(this.reset, rate.reset) &&
        Objects.equals(this.timeWindow, rate.timeWindow);
  }

  @Override
  public int hashCode() {
    return Objects.hash(limit, remaining, reset, timeWindow);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Rate {\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    remaining: ").append(toIndentedString(remaining)).append("\n");
    sb.append("    reset: ").append(toIndentedString(reset)).append("\n");
    sb.append("    timeWindow: ").append(toIndentedString(timeWindow)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("limit");
    openapiFields.add("remaining");
    openapiFields.add("reset");
    openapiFields.add("timeWindow");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Rate
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Rate.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Rate is not found in the empty JSON string", Rate.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Rate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Rate` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("reset") != null && !jsonObj.get("reset").isJsonNull()) && !jsonObj.get("reset").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reset` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reset").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Rate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Rate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Rate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Rate.class));

       return (TypeAdapter<T>) new TypeAdapter<Rate>() {
           @Override
           public void write(JsonWriter out, Rate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Rate read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Rate given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Rate
   * @throws IOException if the JSON string is invalid with respect to Rate
   */
  public static Rate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Rate.class);
  }

  /**
   * Convert an instance of Rate to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

