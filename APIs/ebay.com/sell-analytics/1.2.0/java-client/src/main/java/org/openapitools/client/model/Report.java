/*
 *  Seller Service Metrics API 
 * The <i>Analytics API</i> provides data and information about a seller and their eBay business.  <br><br>The resources and methods in this API let sellers review information on their listing performance, metrics on their customer service performance, and details on their eBay seller performance rating.  <br><br>The three resources in the Analytics API provide the following data and information: <ul><li><b>Customer Service Metric</b> &ndash; Returns data on a seller's customer service performance as compared to other seller's in the same peer group.</li> <li><b>Traffic Report</b> &ndash; Returns data that shows how buyers are engaging with a seller's listings.</li> <li><b>Seller Standards Profile</b> &ndash; Returns data pertaining to a seller's performance rating.</li></ul> Sellers can use the data and information returned by the various Analytics API methods to determine where they can make improvements to increase sales and how they might improve their seller status as viewed by eBay buyers.  <br><br>For details on using this API, see <a href=\"/api-docs/sell/static/performance/analyzing-performance.html\" title=\"Selling Integration Guide\">Analyzing seller performance</a>.
 *
 * The version of the OpenAPI document: 1.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Error;
import org.openapitools.client.model.Header;
import org.openapitools.client.model.Metadata;
import org.openapitools.client.model.Record;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The complex type that defines that defines the report.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T12:39:44.123290-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Report {
  public static final String SERIALIZED_NAME_DIMENSION_METADATA = "dimensionMetadata";
  @SerializedName(SERIALIZED_NAME_DIMENSION_METADATA)
  private List<Metadata> dimensionMetadata = new ArrayList<>();

  public static final String SERIALIZED_NAME_END_DATE = "endDate";
  @SerializedName(SERIALIZED_NAME_END_DATE)
  private String endDate;

  public static final String SERIALIZED_NAME_HEADER = "header";
  @SerializedName(SERIALIZED_NAME_HEADER)
  private Header header;

  public static final String SERIALIZED_NAME_LAST_UPDATED_DATE = "lastUpdatedDate";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATED_DATE)
  private String lastUpdatedDate;

  public static final String SERIALIZED_NAME_RECORDS = "records";
  @SerializedName(SERIALIZED_NAME_RECORDS)
  private List<Record> records = new ArrayList<>();

  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private String startDate;

  public static final String SERIALIZED_NAME_WARNINGS = "warnings";
  @SerializedName(SERIALIZED_NAME_WARNINGS)
  private List<Error> warnings = new ArrayList<>();

  public Report() {
  }

  public Report dimensionMetadata(List<Metadata> dimensionMetadata) {
    this.dimensionMetadata = dimensionMetadata;
    return this;
  }

  public Report addDimensionMetadataItem(Metadata dimensionMetadataItem) {
    if (this.dimensionMetadata == null) {
      this.dimensionMetadata = new ArrayList<>();
    }
    this.dimensionMetadata.add(dimensionMetadataItem);
    return this;
  }

  /**
   * A complex type containing the header of the report and the type of data containted in the rows of the report.
   * @return dimensionMetadata
   */
  @javax.annotation.Nullable
  public List<Metadata> getDimensionMetadata() {
    return dimensionMetadata;
  }

  public void setDimensionMetadata(List<Metadata> dimensionMetadata) {
    this.dimensionMetadata = dimensionMetadata;
  }


  public Report endDate(String endDate) {
    this.endDate = endDate;
    return this;
  }

  /**
   * The time stamp is formatted as an ISO 8601 string, which is based on the 24-hour Universal Coordinated Time (UTC) clock. If you specify an end date that is beyond the lastUpdatedDate value, eBay returns a report that contains data only up to the lastUpdateDate date. Format: [YYYY]-[MM]-[DD]T[hh]:[mm]:[ss].[sss]Z Example: 2018-08-20T07:09:00.000Z
   * @return endDate
   */
  @javax.annotation.Nullable
  public String getEndDate() {
    return endDate;
  }

  public void setEndDate(String endDate) {
    this.endDate = endDate;
  }


  public Report header(Header header) {
    this.header = header;
    return this;
  }

  /**
   * Get header
   * @return header
   */
  @javax.annotation.Nullable
  public Header getHeader() {
    return header;
  }

  public void setHeader(Header header) {
    this.header = header;
  }


  public Report lastUpdatedDate(String lastUpdatedDate) {
    this.lastUpdatedDate = lastUpdatedDate;
    return this;
  }

  /**
   * The date and time, in ISO 8601 format, that indicates the last time the data returned in the report was updated.
   * @return lastUpdatedDate
   */
  @javax.annotation.Nullable
  public String getLastUpdatedDate() {
    return lastUpdatedDate;
  }

  public void setLastUpdatedDate(String lastUpdatedDate) {
    this.lastUpdatedDate = lastUpdatedDate;
  }


  public Report records(List<Record> records) {
    this.records = records;
    return this;
  }

  public Report addRecordsItem(Record recordsItem) {
    if (this.records == null) {
      this.records = new ArrayList<>();
    }
    this.records.add(recordsItem);
    return this;
  }

  /**
   * A complex type containing the individual data records for the traffic report.
   * @return records
   */
  @javax.annotation.Nullable
  public List<Record> getRecords() {
    return records;
  }

  public void setRecords(List<Record> records) {
    this.records = records;
  }


  public Report startDate(String startDate) {
    this.startDate = startDate;
    return this;
  }

  /**
   * The start date of the date range used to calculate the report, in ISO 8601 format.
   * @return startDate
   */
  @javax.annotation.Nullable
  public String getStartDate() {
    return startDate;
  }

  public void setStartDate(String startDate) {
    this.startDate = startDate;
  }


  public Report warnings(List<Error> warnings) {
    this.warnings = warnings;
    return this;
  }

  public Report addWarningsItem(Error warningsItem) {
    if (this.warnings == null) {
      this.warnings = new ArrayList<>();
    }
    this.warnings.add(warningsItem);
    return this;
  }

  /**
   * An array of any process errors or warnings that were generated during the processing of the call processing.
   * @return warnings
   */
  @javax.annotation.Nullable
  public List<Error> getWarnings() {
    return warnings;
  }

  public void setWarnings(List<Error> warnings) {
    this.warnings = warnings;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Report report = (Report) o;
    return Objects.equals(this.dimensionMetadata, report.dimensionMetadata) &&
        Objects.equals(this.endDate, report.endDate) &&
        Objects.equals(this.header, report.header) &&
        Objects.equals(this.lastUpdatedDate, report.lastUpdatedDate) &&
        Objects.equals(this.records, report.records) &&
        Objects.equals(this.startDate, report.startDate) &&
        Objects.equals(this.warnings, report.warnings);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dimensionMetadata, endDate, header, lastUpdatedDate, records, startDate, warnings);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Report {\n");
    sb.append("    dimensionMetadata: ").append(toIndentedString(dimensionMetadata)).append("\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    header: ").append(toIndentedString(header)).append("\n");
    sb.append("    lastUpdatedDate: ").append(toIndentedString(lastUpdatedDate)).append("\n");
    sb.append("    records: ").append(toIndentedString(records)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    warnings: ").append(toIndentedString(warnings)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dimensionMetadata");
    openapiFields.add("endDate");
    openapiFields.add("header");
    openapiFields.add("lastUpdatedDate");
    openapiFields.add("records");
    openapiFields.add("startDate");
    openapiFields.add("warnings");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Report
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Report.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Report is not found in the empty JSON string", Report.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Report.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Report` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("dimensionMetadata") != null && !jsonObj.get("dimensionMetadata").isJsonNull()) {
        JsonArray jsonArraydimensionMetadata = jsonObj.getAsJsonArray("dimensionMetadata");
        if (jsonArraydimensionMetadata != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dimensionMetadata").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dimensionMetadata` to be an array in the JSON string but got `%s`", jsonObj.get("dimensionMetadata").toString()));
          }

          // validate the optional field `dimensionMetadata` (array)
          for (int i = 0; i < jsonArraydimensionMetadata.size(); i++) {
            Metadata.validateJsonElement(jsonArraydimensionMetadata.get(i));
          };
        }
      }
      if ((jsonObj.get("endDate") != null && !jsonObj.get("endDate").isJsonNull()) && !jsonObj.get("endDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endDate").toString()));
      }
      // validate the optional field `header`
      if (jsonObj.get("header") != null && !jsonObj.get("header").isJsonNull()) {
        Header.validateJsonElement(jsonObj.get("header"));
      }
      if ((jsonObj.get("lastUpdatedDate") != null && !jsonObj.get("lastUpdatedDate").isJsonNull()) && !jsonObj.get("lastUpdatedDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastUpdatedDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastUpdatedDate").toString()));
      }
      if (jsonObj.get("records") != null && !jsonObj.get("records").isJsonNull()) {
        JsonArray jsonArrayrecords = jsonObj.getAsJsonArray("records");
        if (jsonArrayrecords != null) {
          // ensure the json data is an array
          if (!jsonObj.get("records").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `records` to be an array in the JSON string but got `%s`", jsonObj.get("records").toString()));
          }

          // validate the optional field `records` (array)
          for (int i = 0; i < jsonArrayrecords.size(); i++) {
            Record.validateJsonElement(jsonArrayrecords.get(i));
          };
        }
      }
      if ((jsonObj.get("startDate") != null && !jsonObj.get("startDate").isJsonNull()) && !jsonObj.get("startDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startDate").toString()));
      }
      if (jsonObj.get("warnings") != null && !jsonObj.get("warnings").isJsonNull()) {
        JsonArray jsonArraywarnings = jsonObj.getAsJsonArray("warnings");
        if (jsonArraywarnings != null) {
          // ensure the json data is an array
          if (!jsonObj.get("warnings").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `warnings` to be an array in the JSON string but got `%s`", jsonObj.get("warnings").toString()));
          }

          // validate the optional field `warnings` (array)
          for (int i = 0; i < jsonArraywarnings.size(); i++) {
            Error.validateJsonElement(jsonArraywarnings.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Report.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Report' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Report> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Report.class));

       return (TypeAdapter<T>) new TypeAdapter<Report>() {
           @Override
           public void write(JsonWriter out, Report value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Report read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Report given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Report
   * @throws IOException if the JSON string is invalid with respect to Report
   */
  public static Report fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Report.class);
  }

  /**
   * Convert an instance of Report to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

