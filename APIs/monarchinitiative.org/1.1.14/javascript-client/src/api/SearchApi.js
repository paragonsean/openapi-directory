/**
 * BioLink API
 * API integration layer for linked biological objects.   __Source:__ https://github.com/biolink/biolink-api/
 *
 * The version of the OpenAPI document: 1.1.14
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import AutocompleteResults from '../model/AutocompleteResults';
import LayResults from '../model/LayResults';
import SearchResult from '../model/SearchResult';

/**
* Search service.
* @module api/SearchApi
* @version 1.1.14
*/
export default class SearchApi {

    /**
    * Constructs a new SearchApi. 
    * @alias module:api/SearchApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the getAutocomplete operation.
     * @callback module:api/SearchApi~getAutocompleteCallback
     * @param {String} error Error message, if any.
     * @param {module:model/AutocompleteResults} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Returns list of matching concepts or entities using lexical search
     * @param {String} term 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [fq] fq string passed directly to solr, note that multiple filters will be combined with an AND operator. Combining fq_string with other parameters may result in unexpected behavior.
     * @param {Array.<String>} [category] e.g. gene, disease
     * @param {Array.<String>} [prefix] ontology prefix: HP, -MONDO
     * @param {Boolean} [includeEqs = false)] Include equivalent ids in prefix filter
     * @param {Array.<String>} [boostFx] boost function e.g. pow(edges,0.334)
     * @param {Array.<String>} [boostQ] boost query e.g. category:genotype^-10
     * @param {Array.<String>} [taxon] taxon filter, eg NCBITaxon:9606, includes inferred taxa
     * @param {Number} [rows = 20)] number of rows
     * @param {String} [start = '0')] row number to start from
     * @param {String} [highlightClass] highlight class
     * @param {String} [minMatch] minimum should match parameter, see solr docs for details
     * @param {Boolean} [excludeGroups = false)] Exclude grouping classes (classes with subclasses)
     * @param {Boolean} [minimalTokenizer = false)] set to true to use the minimal tokenizer, good for variants and genotypes
     * @param {module:api/SearchApi~getAutocompleteCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/AutocompleteResults}
     */
    getAutocomplete(term, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'term' is set
      if (term === undefined || term === null) {
        throw new Error("Missing the required parameter 'term' when calling getAutocomplete");
      }

      let pathParams = {
        'term': term
      };
      let queryParams = {
        'fq': this.apiClient.buildCollectionParam(opts['fq'], 'multi'),
        'category': this.apiClient.buildCollectionParam(opts['category'], 'multi'),
        'prefix': this.apiClient.buildCollectionParam(opts['prefix'], 'multi'),
        'include_eqs': opts['includeEqs'],
        'boost_fx': this.apiClient.buildCollectionParam(opts['boostFx'], 'multi'),
        'boost_q': this.apiClient.buildCollectionParam(opts['boostQ'], 'multi'),
        'taxon': this.apiClient.buildCollectionParam(opts['taxon'], 'multi'),
        'rows': opts['rows'],
        'start': opts['start'],
        'highlight_class': opts['highlightClass'],
        'min_match': opts['minMatch'],
        'exclude_groups': opts['excludeGroups'],
        'minimal_tokenizer': opts['minimalTokenizer']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = AutocompleteResults;
      return this.apiClient.callApi(
        '/search/entity/autocomplete/{term}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getSearchEntities operation.
     * @callback module:api/SearchApi~getSearchEntitiesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/SearchResult} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Returns list of matching concepts or entities using lexical search
     * @param {String} term search string, e.g. shh, parkinson, femur
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} [fq] fq string passed directly to solr, note that multiple filters will be combined with an AND operator. Combining fq_string with other parameters may result in unexpected behavior.
     * @param {Array.<String>} [category] e.g. gene, disease
     * @param {Array.<String>} [prefix] ontology prefix: HP, -MONDO
     * @param {Boolean} [includeEqs = false)] Include equivalent ids in prefix filter
     * @param {Array.<String>} [boostFx] boost function e.g. pow(edges,0.334)
     * @param {Array.<String>} [boostQ] boost query e.g. category:genotype^-10
     * @param {Array.<String>} [taxon] taxon filter, eg NCBITaxon:9606, includes inferred taxa
     * @param {Number} [rows = 20)] number of rows
     * @param {String} [start = '0')] row number to start from
     * @param {String} [highlightClass] highlight class
     * @param {String} [minMatch] minimum should match parameter, see solr docs for details
     * @param {Boolean} [excludeGroups = false)] Exclude grouping classes (classes with subclasses)
     * @param {Boolean} [minimalTokenizer = false)] set to true to use the minimal tokenizer, good for variants and genotypes
     * @param {module:api/SearchApi~getSearchEntitiesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/SearchResult}
     */
    getSearchEntities(term, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'term' is set
      if (term === undefined || term === null) {
        throw new Error("Missing the required parameter 'term' when calling getSearchEntities");
      }

      let pathParams = {
        'term': term
      };
      let queryParams = {
        'fq': this.apiClient.buildCollectionParam(opts['fq'], 'multi'),
        'category': this.apiClient.buildCollectionParam(opts['category'], 'multi'),
        'prefix': this.apiClient.buildCollectionParam(opts['prefix'], 'multi'),
        'include_eqs': opts['includeEqs'],
        'boost_fx': this.apiClient.buildCollectionParam(opts['boostFx'], 'multi'),
        'boost_q': this.apiClient.buildCollectionParam(opts['boostQ'], 'multi'),
        'taxon': this.apiClient.buildCollectionParam(opts['taxon'], 'multi'),
        'rows': opts['rows'],
        'start': opts['start'],
        'highlight_class': opts['highlightClass'],
        'min_match': opts['minMatch'],
        'exclude_groups': opts['excludeGroups'],
        'minimal_tokenizer': opts['minimalTokenizer']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = SearchResult;
      return this.apiClient.callApi(
        '/search/entity/{term}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getSearchHpoEntities operation.
     * @callback module:api/SearchApi~getSearchHpoEntitiesCallback
     * @param {String} error Error message, if any.
     * @param {module:model/LayResults} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Returns list of matching concepts or entities using lexical search
     * @param {String} term search string, e.g. muscle atrophy, frequent infections
     * @param {Object} opts Optional parameters
     * @param {Number} [rows = 10)] number of rows
     * @param {String} [start = '0')] row number to start from
     * @param {String} [phenotypeGroup] phenotype group id
     * @param {String} [phenotypeGroupLabel] phenotype group label
     * @param {String} [anatomicalSystem] anatomical system id
     * @param {String} [anatomicalSystemLabel] anatomical system label
     * @param {String} [highlightClass] highlight class
     * @param {module:api/SearchApi~getSearchHpoEntitiesCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/LayResults}
     */
    getSearchHpoEntities(term, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'term' is set
      if (term === undefined || term === null) {
        throw new Error("Missing the required parameter 'term' when calling getSearchHpoEntities");
      }

      let pathParams = {
        'term': term
      };
      let queryParams = {
        'rows': opts['rows'],
        'start': opts['start'],
        'phenotype_group': opts['phenotypeGroup'],
        'phenotype_group_label': opts['phenotypeGroupLabel'],
        'anatomical_system': opts['anatomicalSystem'],
        'anatomical_system_label': opts['anatomicalSystemLabel'],
        'highlight_class': opts['highlightClass']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = LayResults;
      return this.apiClient.callApi(
        '/search/entity/hpo-pl/{term}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
