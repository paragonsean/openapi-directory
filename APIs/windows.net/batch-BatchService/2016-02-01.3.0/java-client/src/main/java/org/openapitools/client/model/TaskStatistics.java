/*
 * BatchService
 * A client for issuing REST requests to the Azure Batch service.
 *
 * The version of the OpenAPI document: 2016-02-01.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Resource usage statistics for a task.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:59:04.102636-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TaskStatistics {
  public static final String SERIALIZED_NAME_KERNEL_C_P_U_TIME = "kernelCPUTime";
  @SerializedName(SERIALIZED_NAME_KERNEL_C_P_U_TIME)
  private String kernelCPUTime;

  public static final String SERIALIZED_NAME_LAST_UPDATE_TIME = "lastUpdateTime";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATE_TIME)
  private OffsetDateTime lastUpdateTime;

  public static final String SERIALIZED_NAME_READ_I_O_GI_B = "readIOGiB";
  @SerializedName(SERIALIZED_NAME_READ_I_O_GI_B)
  private Double readIOGiB;

  public static final String SERIALIZED_NAME_READ_I_OPS = "readIOps";
  @SerializedName(SERIALIZED_NAME_READ_I_OPS)
  private Long readIOps;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private OffsetDateTime startTime;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private String url;

  public static final String SERIALIZED_NAME_USER_C_P_U_TIME = "userCPUTime";
  @SerializedName(SERIALIZED_NAME_USER_C_P_U_TIME)
  private String userCPUTime;

  public static final String SERIALIZED_NAME_WAIT_TIME = "waitTime";
  @SerializedName(SERIALIZED_NAME_WAIT_TIME)
  private String waitTime;

  public static final String SERIALIZED_NAME_WALL_CLOCK_TIME = "wallClockTime";
  @SerializedName(SERIALIZED_NAME_WALL_CLOCK_TIME)
  private String wallClockTime;

  public static final String SERIALIZED_NAME_WRITE_I_O_GI_B = "writeIOGiB";
  @SerializedName(SERIALIZED_NAME_WRITE_I_O_GI_B)
  private Double writeIOGiB;

  public static final String SERIALIZED_NAME_WRITE_I_OPS = "writeIOps";
  @SerializedName(SERIALIZED_NAME_WRITE_I_OPS)
  private Long writeIOps;

  public TaskStatistics() {
  }

  public TaskStatistics kernelCPUTime(String kernelCPUTime) {
    this.kernelCPUTime = kernelCPUTime;
    return this;
  }

  /**
   * The total kernel mode CPU time (summed across all cores and all compute nodes) consumed by the task.
   * @return kernelCPUTime
   */
  @javax.annotation.Nonnull
  public String getKernelCPUTime() {
    return kernelCPUTime;
  }

  public void setKernelCPUTime(String kernelCPUTime) {
    this.kernelCPUTime = kernelCPUTime;
  }


  public TaskStatistics lastUpdateTime(OffsetDateTime lastUpdateTime) {
    this.lastUpdateTime = lastUpdateTime;
    return this;
  }

  /**
   * The time at which the statistics were last updated. All statistics are limited to the range between startTime and lastUpdateTime.
   * @return lastUpdateTime
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getLastUpdateTime() {
    return lastUpdateTime;
  }

  public void setLastUpdateTime(OffsetDateTime lastUpdateTime) {
    this.lastUpdateTime = lastUpdateTime;
  }


  public TaskStatistics readIOGiB(Double readIOGiB) {
    this.readIOGiB = readIOGiB;
    return this;
  }

  /**
   * The total gibibytes read from disk by the task.
   * @return readIOGiB
   */
  @javax.annotation.Nonnull
  public Double getReadIOGiB() {
    return readIOGiB;
  }

  public void setReadIOGiB(Double readIOGiB) {
    this.readIOGiB = readIOGiB;
  }


  public TaskStatistics readIOps(Long readIOps) {
    this.readIOps = readIOps;
    return this;
  }

  /**
   * The total number of disk read operations made by the task.
   * @return readIOps
   */
  @javax.annotation.Nonnull
  public Long getReadIOps() {
    return readIOps;
  }

  public void setReadIOps(Long readIOps) {
    this.readIOps = readIOps;
  }


  public TaskStatistics startTime(OffsetDateTime startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * The start time of the time range covered by the statistics.
   * @return startTime
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getStartTime() {
    return startTime;
  }

  public void setStartTime(OffsetDateTime startTime) {
    this.startTime = startTime;
  }


  public TaskStatistics url(String url) {
    this.url = url;
    return this;
  }

  /**
   * The URL of the statistics.
   * @return url
   */
  @javax.annotation.Nonnull
  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }


  public TaskStatistics userCPUTime(String userCPUTime) {
    this.userCPUTime = userCPUTime;
    return this;
  }

  /**
   * The total user mode CPU time (summed across all cores and all compute nodes) consumed by the task.
   * @return userCPUTime
   */
  @javax.annotation.Nonnull
  public String getUserCPUTime() {
    return userCPUTime;
  }

  public void setUserCPUTime(String userCPUTime) {
    this.userCPUTime = userCPUTime;
  }


  public TaskStatistics waitTime(String waitTime) {
    this.waitTime = waitTime;
    return this;
  }

  /**
   * The total wait time of the task. The wait time for a task is defined as the elapsed time between the creation of the task and the start of task execution. (If the task is retried due to failures, the wait time is the time to the most recent task execution.)
   * @return waitTime
   */
  @javax.annotation.Nonnull
  public String getWaitTime() {
    return waitTime;
  }

  public void setWaitTime(String waitTime) {
    this.waitTime = waitTime;
  }


  public TaskStatistics wallClockTime(String wallClockTime) {
    this.wallClockTime = wallClockTime;
    return this;
  }

  /**
   * The total wall clock time of the task.
   * @return wallClockTime
   */
  @javax.annotation.Nonnull
  public String getWallClockTime() {
    return wallClockTime;
  }

  public void setWallClockTime(String wallClockTime) {
    this.wallClockTime = wallClockTime;
  }


  public TaskStatistics writeIOGiB(Double writeIOGiB) {
    this.writeIOGiB = writeIOGiB;
    return this;
  }

  /**
   * The total gibibytes written to disk by the task.
   * @return writeIOGiB
   */
  @javax.annotation.Nonnull
  public Double getWriteIOGiB() {
    return writeIOGiB;
  }

  public void setWriteIOGiB(Double writeIOGiB) {
    this.writeIOGiB = writeIOGiB;
  }


  public TaskStatistics writeIOps(Long writeIOps) {
    this.writeIOps = writeIOps;
    return this;
  }

  /**
   * The total number of disk write operations made by the task.
   * @return writeIOps
   */
  @javax.annotation.Nonnull
  public Long getWriteIOps() {
    return writeIOps;
  }

  public void setWriteIOps(Long writeIOps) {
    this.writeIOps = writeIOps;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TaskStatistics taskStatistics = (TaskStatistics) o;
    return Objects.equals(this.kernelCPUTime, taskStatistics.kernelCPUTime) &&
        Objects.equals(this.lastUpdateTime, taskStatistics.lastUpdateTime) &&
        Objects.equals(this.readIOGiB, taskStatistics.readIOGiB) &&
        Objects.equals(this.readIOps, taskStatistics.readIOps) &&
        Objects.equals(this.startTime, taskStatistics.startTime) &&
        Objects.equals(this.url, taskStatistics.url) &&
        Objects.equals(this.userCPUTime, taskStatistics.userCPUTime) &&
        Objects.equals(this.waitTime, taskStatistics.waitTime) &&
        Objects.equals(this.wallClockTime, taskStatistics.wallClockTime) &&
        Objects.equals(this.writeIOGiB, taskStatistics.writeIOGiB) &&
        Objects.equals(this.writeIOps, taskStatistics.writeIOps);
  }

  @Override
  public int hashCode() {
    return Objects.hash(kernelCPUTime, lastUpdateTime, readIOGiB, readIOps, startTime, url, userCPUTime, waitTime, wallClockTime, writeIOGiB, writeIOps);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TaskStatistics {\n");
    sb.append("    kernelCPUTime: ").append(toIndentedString(kernelCPUTime)).append("\n");
    sb.append("    lastUpdateTime: ").append(toIndentedString(lastUpdateTime)).append("\n");
    sb.append("    readIOGiB: ").append(toIndentedString(readIOGiB)).append("\n");
    sb.append("    readIOps: ").append(toIndentedString(readIOps)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    userCPUTime: ").append(toIndentedString(userCPUTime)).append("\n");
    sb.append("    waitTime: ").append(toIndentedString(waitTime)).append("\n");
    sb.append("    wallClockTime: ").append(toIndentedString(wallClockTime)).append("\n");
    sb.append("    writeIOGiB: ").append(toIndentedString(writeIOGiB)).append("\n");
    sb.append("    writeIOps: ").append(toIndentedString(writeIOps)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("kernelCPUTime");
    openapiFields.add("lastUpdateTime");
    openapiFields.add("readIOGiB");
    openapiFields.add("readIOps");
    openapiFields.add("startTime");
    openapiFields.add("url");
    openapiFields.add("userCPUTime");
    openapiFields.add("waitTime");
    openapiFields.add("wallClockTime");
    openapiFields.add("writeIOGiB");
    openapiFields.add("writeIOps");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("kernelCPUTime");
    openapiRequiredFields.add("lastUpdateTime");
    openapiRequiredFields.add("readIOGiB");
    openapiRequiredFields.add("readIOps");
    openapiRequiredFields.add("startTime");
    openapiRequiredFields.add("url");
    openapiRequiredFields.add("userCPUTime");
    openapiRequiredFields.add("waitTime");
    openapiRequiredFields.add("wallClockTime");
    openapiRequiredFields.add("writeIOGiB");
    openapiRequiredFields.add("writeIOps");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TaskStatistics
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TaskStatistics.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TaskStatistics is not found in the empty JSON string", TaskStatistics.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TaskStatistics.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TaskStatistics` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TaskStatistics.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("kernelCPUTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kernelCPUTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kernelCPUTime").toString()));
      }
      if (!jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      if (!jsonObj.get("userCPUTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `userCPUTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("userCPUTime").toString()));
      }
      if (!jsonObj.get("waitTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `waitTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("waitTime").toString()));
      }
      if (!jsonObj.get("wallClockTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `wallClockTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("wallClockTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TaskStatistics.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TaskStatistics' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TaskStatistics> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TaskStatistics.class));

       return (TypeAdapter<T>) new TypeAdapter<TaskStatistics>() {
           @Override
           public void write(JsonWriter out, TaskStatistics value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TaskStatistics read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TaskStatistics given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TaskStatistics
   * @throws IOException if the JSON string is invalid with respect to TaskStatistics
   */
  public static TaskStatistics fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TaskStatistics.class);
  }

  /**
   * Convert an instance of TaskStatistics to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

