# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.compute_node_information import ComputeNodeInformation
from openapi_server.models.task_scheduling_error import TaskSchedulingError
from openapi_server import util


class SubtaskInformation(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, end_time: datetime=None, exit_code: int=None, id: int=None, node_info: ComputeNodeInformation=None, previous_state: str=None, previous_state_transition_time: datetime=None, scheduling_error: TaskSchedulingError=None, start_time: datetime=None, state: str=None, state_transition_time: datetime=None):
        """SubtaskInformation - a model defined in OpenAPI

        :param end_time: The end_time of this SubtaskInformation.
        :param exit_code: The exit_code of this SubtaskInformation.
        :param id: The id of this SubtaskInformation.
        :param node_info: The node_info of this SubtaskInformation.
        :param previous_state: The previous_state of this SubtaskInformation.
        :param previous_state_transition_time: The previous_state_transition_time of this SubtaskInformation.
        :param scheduling_error: The scheduling_error of this SubtaskInformation.
        :param start_time: The start_time of this SubtaskInformation.
        :param state: The state of this SubtaskInformation.
        :param state_transition_time: The state_transition_time of this SubtaskInformation.
        """
        self.openapi_types = {
            'end_time': datetime,
            'exit_code': int,
            'id': int,
            'node_info': ComputeNodeInformation,
            'previous_state': str,
            'previous_state_transition_time': datetime,
            'scheduling_error': TaskSchedulingError,
            'start_time': datetime,
            'state': str,
            'state_transition_time': datetime
        }

        self.attribute_map = {
            'end_time': 'endTime',
            'exit_code': 'exitCode',
            'id': 'id',
            'node_info': 'nodeInfo',
            'previous_state': 'previousState',
            'previous_state_transition_time': 'previousStateTransitionTime',
            'scheduling_error': 'schedulingError',
            'start_time': 'startTime',
            'state': 'state',
            'state_transition_time': 'stateTransitionTime'
        }

        self._end_time = end_time
        self._exit_code = exit_code
        self._id = id
        self._node_info = node_info
        self._previous_state = previous_state
        self._previous_state_transition_time = previous_state_transition_time
        self._scheduling_error = scheduling_error
        self._start_time = start_time
        self._state = state
        self._state_transition_time = state_transition_time

    @classmethod
    def from_dict(cls, dikt: dict) -> 'SubtaskInformation':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The SubtaskInformation of this SubtaskInformation.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def end_time(self):
        """Gets the end_time of this SubtaskInformation.

        Gets or sets the time at which the subtask completed. This property is set only if the subtask is in the Completed state.

        :return: The end_time of this SubtaskInformation.
        :rtype: datetime
        """
        return self._end_time

    @end_time.setter
    def end_time(self, end_time):
        """Sets the end_time of this SubtaskInformation.

        Gets or sets the time at which the subtask completed. This property is set only if the subtask is in the Completed state.

        :param end_time: The end_time of this SubtaskInformation.
        :type end_time: datetime
        """

        self._end_time = end_time

    @property
    def exit_code(self):
        """Gets the exit_code of this SubtaskInformation.

        Gets or sets the exit code of the subtask. This property is set only if the subtask is in the Completed state.

        :return: The exit_code of this SubtaskInformation.
        :rtype: int
        """
        return self._exit_code

    @exit_code.setter
    def exit_code(self, exit_code):
        """Sets the exit_code of this SubtaskInformation.

        Gets or sets the exit code of the subtask. This property is set only if the subtask is in the Completed state.

        :param exit_code: The exit_code of this SubtaskInformation.
        :type exit_code: int
        """

        self._exit_code = exit_code

    @property
    def id(self):
        """Gets the id of this SubtaskInformation.

        Gets or sets the id of the subtask.

        :return: The id of this SubtaskInformation.
        :rtype: int
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this SubtaskInformation.

        Gets or sets the id of the subtask.

        :param id: The id of this SubtaskInformation.
        :type id: int
        """

        self._id = id

    @property
    def node_info(self):
        """Gets the node_info of this SubtaskInformation.


        :return: The node_info of this SubtaskInformation.
        :rtype: ComputeNodeInformation
        """
        return self._node_info

    @node_info.setter
    def node_info(self, node_info):
        """Sets the node_info of this SubtaskInformation.


        :param node_info: The node_info of this SubtaskInformation.
        :type node_info: ComputeNodeInformation
        """

        self._node_info = node_info

    @property
    def previous_state(self):
        """Gets the previous_state of this SubtaskInformation.

        Gets or sets the previous state of the subtask. This property is not set if the subtask is in its initial Active state.

        :return: The previous_state of this SubtaskInformation.
        :rtype: str
        """
        return self._previous_state

    @previous_state.setter
    def previous_state(self, previous_state):
        """Sets the previous_state of this SubtaskInformation.

        Gets or sets the previous state of the subtask. This property is not set if the subtask is in its initial Active state.

        :param previous_state: The previous_state of this SubtaskInformation.
        :type previous_state: str
        """
        allowed_values = ["active", "preparing", "running", "completed"]  # noqa: E501
        if previous_state not in allowed_values:
            raise ValueError(
                "Invalid value for `previous_state` ({0}), must be one of {1}"
                .format(previous_state, allowed_values)
            )

        self._previous_state = previous_state

    @property
    def previous_state_transition_time(self):
        """Gets the previous_state_transition_time of this SubtaskInformation.

        Gets or sets the time at which the subtask entered its previous state. This property is not set if the subtask is in its initial Active state.

        :return: The previous_state_transition_time of this SubtaskInformation.
        :rtype: datetime
        """
        return self._previous_state_transition_time

    @previous_state_transition_time.setter
    def previous_state_transition_time(self, previous_state_transition_time):
        """Sets the previous_state_transition_time of this SubtaskInformation.

        Gets or sets the time at which the subtask entered its previous state. This property is not set if the subtask is in its initial Active state.

        :param previous_state_transition_time: The previous_state_transition_time of this SubtaskInformation.
        :type previous_state_transition_time: datetime
        """

        self._previous_state_transition_time = previous_state_transition_time

    @property
    def scheduling_error(self):
        """Gets the scheduling_error of this SubtaskInformation.


        :return: The scheduling_error of this SubtaskInformation.
        :rtype: TaskSchedulingError
        """
        return self._scheduling_error

    @scheduling_error.setter
    def scheduling_error(self, scheduling_error):
        """Sets the scheduling_error of this SubtaskInformation.


        :param scheduling_error: The scheduling_error of this SubtaskInformation.
        :type scheduling_error: TaskSchedulingError
        """

        self._scheduling_error = scheduling_error

    @property
    def start_time(self):
        """Gets the start_time of this SubtaskInformation.

        Gets or sets the time at which the subtask started running. If the subtask has been restarted or retried, this is the most recent time at which the subtask started running.

        :return: The start_time of this SubtaskInformation.
        :rtype: datetime
        """
        return self._start_time

    @start_time.setter
    def start_time(self, start_time):
        """Sets the start_time of this SubtaskInformation.

        Gets or sets the time at which the subtask started running. If the subtask has been restarted or retried, this is the most recent time at which the subtask started running.

        :param start_time: The start_time of this SubtaskInformation.
        :type start_time: datetime
        """

        self._start_time = start_time

    @property
    def state(self):
        """Gets the state of this SubtaskInformation.

        Gets or sets the current state of the subtask.

        :return: The state of this SubtaskInformation.
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this SubtaskInformation.

        Gets or sets the current state of the subtask.

        :param state: The state of this SubtaskInformation.
        :type state: str
        """
        allowed_values = ["active", "preparing", "running", "completed"]  # noqa: E501
        if state not in allowed_values:
            raise ValueError(
                "Invalid value for `state` ({0}), must be one of {1}"
                .format(state, allowed_values)
            )

        self._state = state

    @property
    def state_transition_time(self):
        """Gets the state_transition_time of this SubtaskInformation.

        Gets or sets the time at which the subtask entered its current state.

        :return: The state_transition_time of this SubtaskInformation.
        :rtype: datetime
        """
        return self._state_transition_time

    @state_transition_time.setter
    def state_transition_time(self, state_transition_time):
        """Sets the state_transition_time of this SubtaskInformation.

        Gets or sets the time at which the subtask entered its current state.

        :param state_transition_time: The state_transition_time of this SubtaskInformation.
        :type state_transition_time: datetime
        """

        self._state_transition_time = state_transition_time
