/*
 * BatchService
 * A client for issuing REST requests to the Azure Batch service.
 *
 * The version of the OpenAPI document: 2016-07-01.3.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Schedule
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:59:00.212826-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Schedule {
  public static final String SERIALIZED_NAME_DO_NOT_RUN_AFTER = "doNotRunAfter";
  @SerializedName(SERIALIZED_NAME_DO_NOT_RUN_AFTER)
  private OffsetDateTime doNotRunAfter;

  public static final String SERIALIZED_NAME_DO_NOT_RUN_UNTIL = "doNotRunUntil";
  @SerializedName(SERIALIZED_NAME_DO_NOT_RUN_UNTIL)
  private OffsetDateTime doNotRunUntil;

  public static final String SERIALIZED_NAME_RECURRENCE_INTERVAL = "recurrenceInterval";
  @SerializedName(SERIALIZED_NAME_RECURRENCE_INTERVAL)
  private String recurrenceInterval;

  public static final String SERIALIZED_NAME_START_WINDOW = "startWindow";
  @SerializedName(SERIALIZED_NAME_START_WINDOW)
  private String startWindow;

  public Schedule() {
  }

  public Schedule doNotRunAfter(OffsetDateTime doNotRunAfter) {
    this.doNotRunAfter = doNotRunAfter;
    return this;
  }

  /**
   * If you do not specify a doNotRunAfter time, and you are creating a recurring job schedule, the job schedule will remain active until you explicitly terminate it.
   * @return doNotRunAfter
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDoNotRunAfter() {
    return doNotRunAfter;
  }

  public void setDoNotRunAfter(OffsetDateTime doNotRunAfter) {
    this.doNotRunAfter = doNotRunAfter;
  }


  public Schedule doNotRunUntil(OffsetDateTime doNotRunUntil) {
    this.doNotRunUntil = doNotRunUntil;
    return this;
  }

  /**
   * If you do not specify a doNotRunUntil time, the schedule becomes ready to create jobs immediately.
   * @return doNotRunUntil
   */
  @javax.annotation.Nullable
  public OffsetDateTime getDoNotRunUntil() {
    return doNotRunUntil;
  }

  public void setDoNotRunUntil(OffsetDateTime doNotRunUntil) {
    this.doNotRunUntil = doNotRunUntil;
  }


  public Schedule recurrenceInterval(String recurrenceInterval) {
    this.recurrenceInterval = recurrenceInterval;
    return this;
  }

  /**
   * Because a job schedule can have at most one active job under it at any given time, if it is time to create a new job under a job schedule, but the previous job is still running, the Batch service will not create the new job until the previous job finishes. If the previous job does not finish within the startWindow period of the new recurrenceInterval, then no new job will be scheduled for that interval. For recurring jobs, you should normally specify a jobManagerTask in the jobSpecification. If you do not use jobManagerTask, you will need an external process to monitor when jobs are created, add tasks to the jobs and terminate the jobs ready for the next recurrence. The default is that the schedule does not recur: one job is created, within the startWindow after the doNotRunUntil time, and the schedule is complete as soon as that job finishes. The minimum value is 1 minute. If you specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).
   * @return recurrenceInterval
   */
  @javax.annotation.Nullable
  public String getRecurrenceInterval() {
    return recurrenceInterval;
  }

  public void setRecurrenceInterval(String recurrenceInterval) {
    this.recurrenceInterval = recurrenceInterval;
  }


  public Schedule startWindow(String startWindow) {
    this.startWindow = startWindow;
    return this;
  }

  /**
   * If a job is not created within the startWindow interval, then the &#39;opportunity&#39; is lost; no job will be created until the next recurrence of the schedule. If the schedule is recurring, and the startWindow is longer than the recurrence interval, then this is equivalent to an infinite startWindow, because the job that is &#39;due&#39; in one recurrenceInterval is not carried forward into the next recurrence interval. The default is infinite. The minimum value is 1 minute. If you specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).
   * @return startWindow
   */
  @javax.annotation.Nullable
  public String getStartWindow() {
    return startWindow;
  }

  public void setStartWindow(String startWindow) {
    this.startWindow = startWindow;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Schedule schedule = (Schedule) o;
    return Objects.equals(this.doNotRunAfter, schedule.doNotRunAfter) &&
        Objects.equals(this.doNotRunUntil, schedule.doNotRunUntil) &&
        Objects.equals(this.recurrenceInterval, schedule.recurrenceInterval) &&
        Objects.equals(this.startWindow, schedule.startWindow);
  }

  @Override
  public int hashCode() {
    return Objects.hash(doNotRunAfter, doNotRunUntil, recurrenceInterval, startWindow);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Schedule {\n");
    sb.append("    doNotRunAfter: ").append(toIndentedString(doNotRunAfter)).append("\n");
    sb.append("    doNotRunUntil: ").append(toIndentedString(doNotRunUntil)).append("\n");
    sb.append("    recurrenceInterval: ").append(toIndentedString(recurrenceInterval)).append("\n");
    sb.append("    startWindow: ").append(toIndentedString(startWindow)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("doNotRunAfter");
    openapiFields.add("doNotRunUntil");
    openapiFields.add("recurrenceInterval");
    openapiFields.add("startWindow");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Schedule
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Schedule.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Schedule is not found in the empty JSON string", Schedule.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Schedule.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Schedule` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("recurrenceInterval") != null && !jsonObj.get("recurrenceInterval").isJsonNull()) && !jsonObj.get("recurrenceInterval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recurrenceInterval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recurrenceInterval").toString()));
      }
      if ((jsonObj.get("startWindow") != null && !jsonObj.get("startWindow").isJsonNull()) && !jsonObj.get("startWindow").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startWindow` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startWindow").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Schedule.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Schedule' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Schedule> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Schedule.class));

       return (TypeAdapter<T>) new TypeAdapter<Schedule>() {
           @Override
           public void write(JsonWriter out, Schedule value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Schedule read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Schedule given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Schedule
   * @throws IOException if the JSON string is invalid with respect to Schedule
   */
  public static Schedule fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Schedule.class);
  }

  /**
   * Convert an instance of Schedule to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

