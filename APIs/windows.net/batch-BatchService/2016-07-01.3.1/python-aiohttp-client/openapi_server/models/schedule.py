# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class Schedule(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, do_not_run_after: datetime=None, do_not_run_until: datetime=None, recurrence_interval: str=None, start_window: str=None):
        """Schedule - a model defined in OpenAPI

        :param do_not_run_after: The do_not_run_after of this Schedule.
        :param do_not_run_until: The do_not_run_until of this Schedule.
        :param recurrence_interval: The recurrence_interval of this Schedule.
        :param start_window: The start_window of this Schedule.
        """
        self.openapi_types = {
            'do_not_run_after': datetime,
            'do_not_run_until': datetime,
            'recurrence_interval': str,
            'start_window': str
        }

        self.attribute_map = {
            'do_not_run_after': 'doNotRunAfter',
            'do_not_run_until': 'doNotRunUntil',
            'recurrence_interval': 'recurrenceInterval',
            'start_window': 'startWindow'
        }

        self._do_not_run_after = do_not_run_after
        self._do_not_run_until = do_not_run_until
        self._recurrence_interval = recurrence_interval
        self._start_window = start_window

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Schedule':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Schedule of this Schedule.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def do_not_run_after(self):
        """Gets the do_not_run_after of this Schedule.

        If you do not specify a doNotRunAfter time, and you are creating a recurring job schedule, the job schedule will remain active until you explicitly terminate it.

        :return: The do_not_run_after of this Schedule.
        :rtype: datetime
        """
        return self._do_not_run_after

    @do_not_run_after.setter
    def do_not_run_after(self, do_not_run_after):
        """Sets the do_not_run_after of this Schedule.

        If you do not specify a doNotRunAfter time, and you are creating a recurring job schedule, the job schedule will remain active until you explicitly terminate it.

        :param do_not_run_after: The do_not_run_after of this Schedule.
        :type do_not_run_after: datetime
        """

        self._do_not_run_after = do_not_run_after

    @property
    def do_not_run_until(self):
        """Gets the do_not_run_until of this Schedule.

        If you do not specify a doNotRunUntil time, the schedule becomes ready to create jobs immediately.

        :return: The do_not_run_until of this Schedule.
        :rtype: datetime
        """
        return self._do_not_run_until

    @do_not_run_until.setter
    def do_not_run_until(self, do_not_run_until):
        """Sets the do_not_run_until of this Schedule.

        If you do not specify a doNotRunUntil time, the schedule becomes ready to create jobs immediately.

        :param do_not_run_until: The do_not_run_until of this Schedule.
        :type do_not_run_until: datetime
        """

        self._do_not_run_until = do_not_run_until

    @property
    def recurrence_interval(self):
        """Gets the recurrence_interval of this Schedule.

        Because a job schedule can have at most one active job under it at any given time, if it is time to create a new job under a job schedule, but the previous job is still running, the Batch service will not create the new job until the previous job finishes. If the previous job does not finish within the startWindow period of the new recurrenceInterval, then no new job will be scheduled for that interval. For recurring jobs, you should normally specify a jobManagerTask in the jobSpecification. If you do not use jobManagerTask, you will need an external process to monitor when jobs are created, add tasks to the jobs and terminate the jobs ready for the next recurrence. The default is that the schedule does not recur: one job is created, within the startWindow after the doNotRunUntil time, and the schedule is complete as soon as that job finishes. The minimum value is 1 minute. If you specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).

        :return: The recurrence_interval of this Schedule.
        :rtype: str
        """
        return self._recurrence_interval

    @recurrence_interval.setter
    def recurrence_interval(self, recurrence_interval):
        """Sets the recurrence_interval of this Schedule.

        Because a job schedule can have at most one active job under it at any given time, if it is time to create a new job under a job schedule, but the previous job is still running, the Batch service will not create the new job until the previous job finishes. If the previous job does not finish within the startWindow period of the new recurrenceInterval, then no new job will be scheduled for that interval. For recurring jobs, you should normally specify a jobManagerTask in the jobSpecification. If you do not use jobManagerTask, you will need an external process to monitor when jobs are created, add tasks to the jobs and terminate the jobs ready for the next recurrence. The default is that the schedule does not recur: one job is created, within the startWindow after the doNotRunUntil time, and the schedule is complete as soon as that job finishes. The minimum value is 1 minute. If you specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).

        :param recurrence_interval: The recurrence_interval of this Schedule.
        :type recurrence_interval: str
        """

        self._recurrence_interval = recurrence_interval

    @property
    def start_window(self):
        """Gets the start_window of this Schedule.

        If a job is not created within the startWindow interval, then the 'opportunity' is lost; no job will be created until the next recurrence of the schedule. If the schedule is recurring, and the startWindow is longer than the recurrence interval, then this is equivalent to an infinite startWindow, because the job that is 'due' in one recurrenceInterval is not carried forward into the next recurrence interval. The default is infinite. The minimum value is 1 minute. If you specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).

        :return: The start_window of this Schedule.
        :rtype: str
        """
        return self._start_window

    @start_window.setter
    def start_window(self, start_window):
        """Sets the start_window of this Schedule.

        If a job is not created within the startWindow interval, then the 'opportunity' is lost; no job will be created until the next recurrence of the schedule. If the schedule is recurring, and the startWindow is longer than the recurrence interval, then this is equivalent to an infinite startWindow, because the job that is 'due' in one recurrenceInterval is not carried forward into the next recurrence interval. The default is infinite. The minimum value is 1 minute. If you specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).

        :param start_window: The start_window of this Schedule.
        :type start_window: str
        """

        self._start_window = start_window
