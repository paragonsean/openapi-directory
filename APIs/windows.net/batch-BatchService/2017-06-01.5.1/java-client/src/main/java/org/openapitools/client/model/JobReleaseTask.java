/*
 * BatchService
 * A client for issuing REST requests to the Azure Batch service.
 *
 * The version of the OpenAPI document: 2017-06-01.5.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.EnvironmentSetting;
import org.openapitools.client.model.ResourceFile;
import org.openapitools.client.model.UserIdentity;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The Job Release task runs when the job ends, because of one of the following: The user calls the Terminate Job API, or the Delete Job API while the job is still active, the job&#39;s maximum wall clock time constraint is reached, and the job is still active, or the job&#39;s Job Manager task completed, and the job is configured to terminate when the Job Manager completes. The Job Release task runs on each compute node where tasks of the job have run and the Job Preparation task ran and completed. If you reimage a compute node after it has run the Job Preparation task, and the job ends without any further tasks of the job running on that compute node (and hence the Job Preparation task does not re-run), then the Job Release task does not run on that node. If a compute node reboots while the Job Release task is still running, the Job Release task runs again when the compute node starts up. The job is not marked as complete until all Job Release tasks have completed. The Job Release task runs in the background. It does not occupy a scheduling slot; that is, it does not count towards the maxTasksPerNode limit specified on the pool.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:59:11.127296-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class JobReleaseTask {
  public static final String SERIALIZED_NAME_COMMAND_LINE = "commandLine";
  @SerializedName(SERIALIZED_NAME_COMMAND_LINE)
  private String commandLine;

  public static final String SERIALIZED_NAME_ENVIRONMENT_SETTINGS = "environmentSettings";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT_SETTINGS)
  private List<EnvironmentSetting> environmentSettings = new ArrayList<>();

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_MAX_WALL_CLOCK_TIME = "maxWallClockTime";
  @SerializedName(SERIALIZED_NAME_MAX_WALL_CLOCK_TIME)
  private String maxWallClockTime;

  public static final String SERIALIZED_NAME_RESOURCE_FILES = "resourceFiles";
  @SerializedName(SERIALIZED_NAME_RESOURCE_FILES)
  private List<ResourceFile> resourceFiles = new ArrayList<>();

  public static final String SERIALIZED_NAME_RETENTION_TIME = "retentionTime";
  @SerializedName(SERIALIZED_NAME_RETENTION_TIME)
  private String retentionTime;

  public static final String SERIALIZED_NAME_USER_IDENTITY = "userIdentity";
  @SerializedName(SERIALIZED_NAME_USER_IDENTITY)
  private UserIdentity userIdentity;

  public JobReleaseTask() {
  }

  public JobReleaseTask commandLine(String commandLine) {
    this.commandLine = commandLine;
    return this;
  }

  /**
   * The command line does not run under a shell, and therefore cannot take advantage of shell features such as environment variable expansion. If you want to take advantage of such features, you should invoke the shell in the command line, for example using \&quot;cmd /c MyCommand\&quot; in Windows or \&quot;/bin/sh -c MyCommand\&quot; in Linux.
   * @return commandLine
   */
  @javax.annotation.Nonnull
  public String getCommandLine() {
    return commandLine;
  }

  public void setCommandLine(String commandLine) {
    this.commandLine = commandLine;
  }


  public JobReleaseTask environmentSettings(List<EnvironmentSetting> environmentSettings) {
    this.environmentSettings = environmentSettings;
    return this;
  }

  public JobReleaseTask addEnvironmentSettingsItem(EnvironmentSetting environmentSettingsItem) {
    if (this.environmentSettings == null) {
      this.environmentSettings = new ArrayList<>();
    }
    this.environmentSettings.add(environmentSettingsItem);
    return this;
  }

  /**
   * Get environmentSettings
   * @return environmentSettings
   */
  @javax.annotation.Nullable
  public List<EnvironmentSetting> getEnvironmentSettings() {
    return environmentSettings;
  }

  public void setEnvironmentSettings(List<EnvironmentSetting> environmentSettings) {
    this.environmentSettings = environmentSettings;
  }


  public JobReleaseTask id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The ID can contain any combination of alphanumeric characters including hyphens and underscores and cannot contain more than 64 characters. If you do not specify this property, the Batch service assigns a default value of &#39;jobrelease&#39;. No other task in the job can have the same ID as the Job Release task. If you try to submit a task with the same id, the Batch service rejects the request with error code TaskIdSameAsJobReleaseTask; if you are calling the REST API directly, the HTTP status code is 409 (Conflict).
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public JobReleaseTask maxWallClockTime(String maxWallClockTime) {
    this.maxWallClockTime = maxWallClockTime;
    return this;
  }

  /**
   * Get maxWallClockTime
   * @return maxWallClockTime
   */
  @javax.annotation.Nullable
  public String getMaxWallClockTime() {
    return maxWallClockTime;
  }

  public void setMaxWallClockTime(String maxWallClockTime) {
    this.maxWallClockTime = maxWallClockTime;
  }


  public JobReleaseTask resourceFiles(List<ResourceFile> resourceFiles) {
    this.resourceFiles = resourceFiles;
    return this;
  }

  public JobReleaseTask addResourceFilesItem(ResourceFile resourceFilesItem) {
    if (this.resourceFiles == null) {
      this.resourceFiles = new ArrayList<>();
    }
    this.resourceFiles.add(resourceFilesItem);
    return this;
  }

  /**
   * Files listed under this element are located in the task&#39;s working directory.
   * @return resourceFiles
   */
  @javax.annotation.Nullable
  public List<ResourceFile> getResourceFiles() {
    return resourceFiles;
  }

  public void setResourceFiles(List<ResourceFile> resourceFiles) {
    this.resourceFiles = resourceFiles;
  }


  public JobReleaseTask retentionTime(String retentionTime) {
    this.retentionTime = retentionTime;
    return this;
  }

  /**
   * The default is infinite, i.e. the task directory will be retained until the compute node is removed or reimaged.
   * @return retentionTime
   */
  @javax.annotation.Nullable
  public String getRetentionTime() {
    return retentionTime;
  }

  public void setRetentionTime(String retentionTime) {
    this.retentionTime = retentionTime;
  }


  public JobReleaseTask userIdentity(UserIdentity userIdentity) {
    this.userIdentity = userIdentity;
    return this;
  }

  /**
   * Get userIdentity
   * @return userIdentity
   */
  @javax.annotation.Nullable
  public UserIdentity getUserIdentity() {
    return userIdentity;
  }

  public void setUserIdentity(UserIdentity userIdentity) {
    this.userIdentity = userIdentity;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    JobReleaseTask jobReleaseTask = (JobReleaseTask) o;
    return Objects.equals(this.commandLine, jobReleaseTask.commandLine) &&
        Objects.equals(this.environmentSettings, jobReleaseTask.environmentSettings) &&
        Objects.equals(this.id, jobReleaseTask.id) &&
        Objects.equals(this.maxWallClockTime, jobReleaseTask.maxWallClockTime) &&
        Objects.equals(this.resourceFiles, jobReleaseTask.resourceFiles) &&
        Objects.equals(this.retentionTime, jobReleaseTask.retentionTime) &&
        Objects.equals(this.userIdentity, jobReleaseTask.userIdentity);
  }

  @Override
  public int hashCode() {
    return Objects.hash(commandLine, environmentSettings, id, maxWallClockTime, resourceFiles, retentionTime, userIdentity);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class JobReleaseTask {\n");
    sb.append("    commandLine: ").append(toIndentedString(commandLine)).append("\n");
    sb.append("    environmentSettings: ").append(toIndentedString(environmentSettings)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    maxWallClockTime: ").append(toIndentedString(maxWallClockTime)).append("\n");
    sb.append("    resourceFiles: ").append(toIndentedString(resourceFiles)).append("\n");
    sb.append("    retentionTime: ").append(toIndentedString(retentionTime)).append("\n");
    sb.append("    userIdentity: ").append(toIndentedString(userIdentity)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("commandLine");
    openapiFields.add("environmentSettings");
    openapiFields.add("id");
    openapiFields.add("maxWallClockTime");
    openapiFields.add("resourceFiles");
    openapiFields.add("retentionTime");
    openapiFields.add("userIdentity");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("commandLine");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to JobReleaseTask
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!JobReleaseTask.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in JobReleaseTask is not found in the empty JSON string", JobReleaseTask.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!JobReleaseTask.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `JobReleaseTask` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : JobReleaseTask.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("commandLine").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `commandLine` to be a primitive type in the JSON string but got `%s`", jsonObj.get("commandLine").toString()));
      }
      if (jsonObj.get("environmentSettings") != null && !jsonObj.get("environmentSettings").isJsonNull()) {
        JsonArray jsonArrayenvironmentSettings = jsonObj.getAsJsonArray("environmentSettings");
        if (jsonArrayenvironmentSettings != null) {
          // ensure the json data is an array
          if (!jsonObj.get("environmentSettings").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `environmentSettings` to be an array in the JSON string but got `%s`", jsonObj.get("environmentSettings").toString()));
          }

          // validate the optional field `environmentSettings` (array)
          for (int i = 0; i < jsonArrayenvironmentSettings.size(); i++) {
            EnvironmentSetting.validateJsonElement(jsonArrayenvironmentSettings.get(i));
          };
        }
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("maxWallClockTime") != null && !jsonObj.get("maxWallClockTime").isJsonNull()) && !jsonObj.get("maxWallClockTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxWallClockTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxWallClockTime").toString()));
      }
      if (jsonObj.get("resourceFiles") != null && !jsonObj.get("resourceFiles").isJsonNull()) {
        JsonArray jsonArrayresourceFiles = jsonObj.getAsJsonArray("resourceFiles");
        if (jsonArrayresourceFiles != null) {
          // ensure the json data is an array
          if (!jsonObj.get("resourceFiles").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `resourceFiles` to be an array in the JSON string but got `%s`", jsonObj.get("resourceFiles").toString()));
          }

          // validate the optional field `resourceFiles` (array)
          for (int i = 0; i < jsonArrayresourceFiles.size(); i++) {
            ResourceFile.validateJsonElement(jsonArrayresourceFiles.get(i));
          };
        }
      }
      if ((jsonObj.get("retentionTime") != null && !jsonObj.get("retentionTime").isJsonNull()) && !jsonObj.get("retentionTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `retentionTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("retentionTime").toString()));
      }
      // validate the optional field `userIdentity`
      if (jsonObj.get("userIdentity") != null && !jsonObj.get("userIdentity").isJsonNull()) {
        UserIdentity.validateJsonElement(jsonObj.get("userIdentity"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!JobReleaseTask.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'JobReleaseTask' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<JobReleaseTask> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(JobReleaseTask.class));

       return (TypeAdapter<T>) new TypeAdapter<JobReleaseTask>() {
           @Override
           public void write(JsonWriter out, JobReleaseTask value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public JobReleaseTask read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of JobReleaseTask given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of JobReleaseTask
   * @throws IOException if the JSON string is invalid with respect to JobReleaseTask
   */
  public static JobReleaseTask fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, JobReleaseTask.class);
  }

  /**
   * Convert an instance of JobReleaseTask to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

