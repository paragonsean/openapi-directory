/*
 * BatchService
 * A client for issuing REST requests to the Azure Batch service.
 *
 * The version of the OpenAPI document: 2017-09-01.6.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CertificateReference;
import org.openapitools.client.model.ComputeNodeEndpointConfiguration;
import org.openapitools.client.model.ComputeNodeError;
import org.openapitools.client.model.StartTask;
import org.openapitools.client.model.StartTaskInformation;
import org.openapitools.client.model.TaskInformation;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * ComputeNode
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:58:41.987830-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ComputeNode {
  public static final String SERIALIZED_NAME_AFFINITY_ID = "affinityId";
  @SerializedName(SERIALIZED_NAME_AFFINITY_ID)
  private String affinityId;

  public static final String SERIALIZED_NAME_ALLOCATION_TIME = "allocationTime";
  @SerializedName(SERIALIZED_NAME_ALLOCATION_TIME)
  private OffsetDateTime allocationTime;

  public static final String SERIALIZED_NAME_CERTIFICATE_REFERENCES = "certificateReferences";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_REFERENCES)
  private List<CertificateReference> certificateReferences = new ArrayList<>();

  public static final String SERIALIZED_NAME_ENDPOINT_CONFIGURATION = "endpointConfiguration";
  @SerializedName(SERIALIZED_NAME_ENDPOINT_CONFIGURATION)
  private ComputeNodeEndpointConfiguration endpointConfiguration;

  public static final String SERIALIZED_NAME_ERRORS = "errors";
  @SerializedName(SERIALIZED_NAME_ERRORS)
  private List<ComputeNodeError> errors = new ArrayList<>();

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IP_ADDRESS = "ipAddress";
  @SerializedName(SERIALIZED_NAME_IP_ADDRESS)
  private String ipAddress;

  public static final String SERIALIZED_NAME_IS_DEDICATED = "isDedicated";
  @SerializedName(SERIALIZED_NAME_IS_DEDICATED)
  private Boolean isDedicated;

  public static final String SERIALIZED_NAME_LAST_BOOT_TIME = "lastBootTime";
  @SerializedName(SERIALIZED_NAME_LAST_BOOT_TIME)
  private OffsetDateTime lastBootTime;

  public static final String SERIALIZED_NAME_RECENT_TASKS = "recentTasks";
  @SerializedName(SERIALIZED_NAME_RECENT_TASKS)
  private List<TaskInformation> recentTasks = new ArrayList<>();

  public static final String SERIALIZED_NAME_RUNNING_TASKS_COUNT = "runningTasksCount";
  @SerializedName(SERIALIZED_NAME_RUNNING_TASKS_COUNT)
  private Integer runningTasksCount;

  /**
   * Gets or Sets schedulingState
   */
  @JsonAdapter(SchedulingStateEnum.Adapter.class)
  public enum SchedulingStateEnum {
    ENABLED("enabled"),
    
    DISABLED("disabled");

    private String value;

    SchedulingStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SchedulingStateEnum fromValue(String value) {
      for (SchedulingStateEnum b : SchedulingStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SchedulingStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SchedulingStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SchedulingStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SchedulingStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SchedulingStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SCHEDULING_STATE = "schedulingState";
  @SerializedName(SERIALIZED_NAME_SCHEDULING_STATE)
  private SchedulingStateEnum schedulingState;

  public static final String SERIALIZED_NAME_START_TASK = "startTask";
  @SerializedName(SERIALIZED_NAME_START_TASK)
  private StartTask startTask;

  public static final String SERIALIZED_NAME_START_TASK_INFO = "startTaskInfo";
  @SerializedName(SERIALIZED_NAME_START_TASK_INFO)
  private StartTaskInformation startTaskInfo;

  /**
   * The low-priority node has been preempted. Tasks which were running on the node when it was preempted will be rescheduled when another node becomes available.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    IDLE("idle"),
    
    REBOOTING("rebooting"),
    
    REIMAGING("reimaging"),
    
    RUNNING("running"),
    
    UNUSABLE("unusable"),
    
    CREATING("creating"),
    
    STARTING("starting"),
    
    WAITINGFORSTARTTASK("waitingforstarttask"),
    
    STARTTASKFAILED("starttaskfailed"),
    
    UNKNOWN("unknown"),
    
    LEAVINGPOOL("leavingpool"),
    
    OFFLINE("offline"),
    
    PREEMPTED("preempted");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_STATE_TRANSITION_TIME = "stateTransitionTime";
  @SerializedName(SERIALIZED_NAME_STATE_TRANSITION_TIME)
  private OffsetDateTime stateTransitionTime;

  public static final String SERIALIZED_NAME_TOTAL_TASKS_RUN = "totalTasksRun";
  @SerializedName(SERIALIZED_NAME_TOTAL_TASKS_RUN)
  private Integer totalTasksRun;

  public static final String SERIALIZED_NAME_TOTAL_TASKS_SUCCEEDED = "totalTasksSucceeded";
  @SerializedName(SERIALIZED_NAME_TOTAL_TASKS_SUCCEEDED)
  private Integer totalTasksSucceeded;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private String url;

  public static final String SERIALIZED_NAME_VM_SIZE = "vmSize";
  @SerializedName(SERIALIZED_NAME_VM_SIZE)
  private String vmSize;

  public ComputeNode() {
  }

  public ComputeNode affinityId(String affinityId) {
    this.affinityId = affinityId;
    return this;
  }

  /**
   * Note that this is just a soft affinity. If the target node is busy or unavailable at the time the task is scheduled, then the task will be scheduled elsewhere.
   * @return affinityId
   */
  @javax.annotation.Nullable
  public String getAffinityId() {
    return affinityId;
  }

  public void setAffinityId(String affinityId) {
    this.affinityId = affinityId;
  }


  public ComputeNode allocationTime(OffsetDateTime allocationTime) {
    this.allocationTime = allocationTime;
    return this;
  }

  /**
   * Get allocationTime
   * @return allocationTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getAllocationTime() {
    return allocationTime;
  }

  public void setAllocationTime(OffsetDateTime allocationTime) {
    this.allocationTime = allocationTime;
  }


  public ComputeNode certificateReferences(List<CertificateReference> certificateReferences) {
    this.certificateReferences = certificateReferences;
    return this;
  }

  public ComputeNode addCertificateReferencesItem(CertificateReference certificateReferencesItem) {
    if (this.certificateReferences == null) {
      this.certificateReferences = new ArrayList<>();
    }
    this.certificateReferences.add(certificateReferencesItem);
    return this;
  }

  /**
   * For Windows compute nodes, the Batch service installs the certificates to the specified certificate store and location. For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this location. For certificates with visibility of &#39;remoteUser&#39;, a &#39;certs&#39; directory is created in the user&#39;s home directory (e.g., /home/{user-name}/certs) and certificates are placed in that directory.
   * @return certificateReferences
   */
  @javax.annotation.Nullable
  public List<CertificateReference> getCertificateReferences() {
    return certificateReferences;
  }

  public void setCertificateReferences(List<CertificateReference> certificateReferences) {
    this.certificateReferences = certificateReferences;
  }


  public ComputeNode endpointConfiguration(ComputeNodeEndpointConfiguration endpointConfiguration) {
    this.endpointConfiguration = endpointConfiguration;
    return this;
  }

  /**
   * Get endpointConfiguration
   * @return endpointConfiguration
   */
  @javax.annotation.Nullable
  public ComputeNodeEndpointConfiguration getEndpointConfiguration() {
    return endpointConfiguration;
  }

  public void setEndpointConfiguration(ComputeNodeEndpointConfiguration endpointConfiguration) {
    this.endpointConfiguration = endpointConfiguration;
  }


  public ComputeNode errors(List<ComputeNodeError> errors) {
    this.errors = errors;
    return this;
  }

  public ComputeNode addErrorsItem(ComputeNodeError errorsItem) {
    if (this.errors == null) {
      this.errors = new ArrayList<>();
    }
    this.errors.add(errorsItem);
    return this;
  }

  /**
   * Get errors
   * @return errors
   */
  @javax.annotation.Nullable
  public List<ComputeNodeError> getErrors() {
    return errors;
  }

  public void setErrors(List<ComputeNodeError> errors) {
    this.errors = errors;
  }


  public ComputeNode id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Every node that is added to a pool is assigned a unique ID. Whenever a node is removed from a pool, all of its local files are deleted, and the ID is reclaimed and could be reused for new nodes.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public ComputeNode ipAddress(String ipAddress) {
    this.ipAddress = ipAddress;
    return this;
  }

  /**
   * Every node that is added to a pool is assigned a unique IP address. Whenever a node is removed from a pool, all of its local files are deleted, and the IP address is reclaimed and could be reused for new nodes.
   * @return ipAddress
   */
  @javax.annotation.Nullable
  public String getIpAddress() {
    return ipAddress;
  }

  public void setIpAddress(String ipAddress) {
    this.ipAddress = ipAddress;
  }


  public ComputeNode isDedicated(Boolean isDedicated) {
    this.isDedicated = isDedicated;
    return this;
  }

  /**
   * Get isDedicated
   * @return isDedicated
   */
  @javax.annotation.Nullable
  public Boolean getIsDedicated() {
    return isDedicated;
  }

  public void setIsDedicated(Boolean isDedicated) {
    this.isDedicated = isDedicated;
  }


  public ComputeNode lastBootTime(OffsetDateTime lastBootTime) {
    this.lastBootTime = lastBootTime;
    return this;
  }

  /**
   * This property may not be present if the node state is unusable.
   * @return lastBootTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastBootTime() {
    return lastBootTime;
  }

  public void setLastBootTime(OffsetDateTime lastBootTime) {
    this.lastBootTime = lastBootTime;
  }


  public ComputeNode recentTasks(List<TaskInformation> recentTasks) {
    this.recentTasks = recentTasks;
    return this;
  }

  public ComputeNode addRecentTasksItem(TaskInformation recentTasksItem) {
    if (this.recentTasks == null) {
      this.recentTasks = new ArrayList<>();
    }
    this.recentTasks.add(recentTasksItem);
    return this;
  }

  /**
   * This property is present only if at least one task has run on this node since it was assigned to the pool.
   * @return recentTasks
   */
  @javax.annotation.Nullable
  public List<TaskInformation> getRecentTasks() {
    return recentTasks;
  }

  public void setRecentTasks(List<TaskInformation> recentTasks) {
    this.recentTasks = recentTasks;
  }


  public ComputeNode runningTasksCount(Integer runningTasksCount) {
    this.runningTasksCount = runningTasksCount;
    return this;
  }

  /**
   * Get runningTasksCount
   * @return runningTasksCount
   */
  @javax.annotation.Nullable
  public Integer getRunningTasksCount() {
    return runningTasksCount;
  }

  public void setRunningTasksCount(Integer runningTasksCount) {
    this.runningTasksCount = runningTasksCount;
  }


  public ComputeNode schedulingState(SchedulingStateEnum schedulingState) {
    this.schedulingState = schedulingState;
    return this;
  }

  /**
   * Get schedulingState
   * @return schedulingState
   */
  @javax.annotation.Nullable
  public SchedulingStateEnum getSchedulingState() {
    return schedulingState;
  }

  public void setSchedulingState(SchedulingStateEnum schedulingState) {
    this.schedulingState = schedulingState;
  }


  public ComputeNode startTask(StartTask startTask) {
    this.startTask = startTask;
    return this;
  }

  /**
   * Get startTask
   * @return startTask
   */
  @javax.annotation.Nullable
  public StartTask getStartTask() {
    return startTask;
  }

  public void setStartTask(StartTask startTask) {
    this.startTask = startTask;
  }


  public ComputeNode startTaskInfo(StartTaskInformation startTaskInfo) {
    this.startTaskInfo = startTaskInfo;
    return this;
  }

  /**
   * Get startTaskInfo
   * @return startTaskInfo
   */
  @javax.annotation.Nullable
  public StartTaskInformation getStartTaskInfo() {
    return startTaskInfo;
  }

  public void setStartTaskInfo(StartTaskInformation startTaskInfo) {
    this.startTaskInfo = startTaskInfo;
  }


  public ComputeNode state(StateEnum state) {
    this.state = state;
    return this;
  }

  /**
   * The low-priority node has been preempted. Tasks which were running on the node when it was preempted will be rescheduled when another node becomes available.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }

  public void setState(StateEnum state) {
    this.state = state;
  }


  public ComputeNode stateTransitionTime(OffsetDateTime stateTransitionTime) {
    this.stateTransitionTime = stateTransitionTime;
    return this;
  }

  /**
   * Get stateTransitionTime
   * @return stateTransitionTime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStateTransitionTime() {
    return stateTransitionTime;
  }

  public void setStateTransitionTime(OffsetDateTime stateTransitionTime) {
    this.stateTransitionTime = stateTransitionTime;
  }


  public ComputeNode totalTasksRun(Integer totalTasksRun) {
    this.totalTasksRun = totalTasksRun;
    return this;
  }

  /**
   * Get totalTasksRun
   * @return totalTasksRun
   */
  @javax.annotation.Nullable
  public Integer getTotalTasksRun() {
    return totalTasksRun;
  }

  public void setTotalTasksRun(Integer totalTasksRun) {
    this.totalTasksRun = totalTasksRun;
  }


  public ComputeNode totalTasksSucceeded(Integer totalTasksSucceeded) {
    this.totalTasksSucceeded = totalTasksSucceeded;
    return this;
  }

  /**
   * Get totalTasksSucceeded
   * @return totalTasksSucceeded
   */
  @javax.annotation.Nullable
  public Integer getTotalTasksSucceeded() {
    return totalTasksSucceeded;
  }

  public void setTotalTasksSucceeded(Integer totalTasksSucceeded) {
    this.totalTasksSucceeded = totalTasksSucceeded;
  }


  public ComputeNode url(String url) {
    this.url = url;
    return this;
  }

  /**
   * Get url
   * @return url
   */
  @javax.annotation.Nullable
  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }


  public ComputeNode vmSize(String vmSize) {
    this.vmSize = vmSize;
    return this;
  }

  /**
   * For information about available sizes of virtual machines for Cloud Services pools (pools created with cloudServiceConfiguration), see Sizes for Cloud Services (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/). Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2. For information about available VM sizes for pools using images from the Virtual Machines Marketplace (pools created with virtualMachineConfiguration) see Sizes for Virtual Machines (Linux) (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/) or Sizes for Virtual Machines (Windows) (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/). Batch supports all Azure VM sizes except STANDARD_A0 and those with premium storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
   * @return vmSize
   */
  @javax.annotation.Nullable
  public String getVmSize() {
    return vmSize;
  }

  public void setVmSize(String vmSize) {
    this.vmSize = vmSize;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComputeNode computeNode = (ComputeNode) o;
    return Objects.equals(this.affinityId, computeNode.affinityId) &&
        Objects.equals(this.allocationTime, computeNode.allocationTime) &&
        Objects.equals(this.certificateReferences, computeNode.certificateReferences) &&
        Objects.equals(this.endpointConfiguration, computeNode.endpointConfiguration) &&
        Objects.equals(this.errors, computeNode.errors) &&
        Objects.equals(this.id, computeNode.id) &&
        Objects.equals(this.ipAddress, computeNode.ipAddress) &&
        Objects.equals(this.isDedicated, computeNode.isDedicated) &&
        Objects.equals(this.lastBootTime, computeNode.lastBootTime) &&
        Objects.equals(this.recentTasks, computeNode.recentTasks) &&
        Objects.equals(this.runningTasksCount, computeNode.runningTasksCount) &&
        Objects.equals(this.schedulingState, computeNode.schedulingState) &&
        Objects.equals(this.startTask, computeNode.startTask) &&
        Objects.equals(this.startTaskInfo, computeNode.startTaskInfo) &&
        Objects.equals(this.state, computeNode.state) &&
        Objects.equals(this.stateTransitionTime, computeNode.stateTransitionTime) &&
        Objects.equals(this.totalTasksRun, computeNode.totalTasksRun) &&
        Objects.equals(this.totalTasksSucceeded, computeNode.totalTasksSucceeded) &&
        Objects.equals(this.url, computeNode.url) &&
        Objects.equals(this.vmSize, computeNode.vmSize);
  }

  @Override
  public int hashCode() {
    return Objects.hash(affinityId, allocationTime, certificateReferences, endpointConfiguration, errors, id, ipAddress, isDedicated, lastBootTime, recentTasks, runningTasksCount, schedulingState, startTask, startTaskInfo, state, stateTransitionTime, totalTasksRun, totalTasksSucceeded, url, vmSize);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComputeNode {\n");
    sb.append("    affinityId: ").append(toIndentedString(affinityId)).append("\n");
    sb.append("    allocationTime: ").append(toIndentedString(allocationTime)).append("\n");
    sb.append("    certificateReferences: ").append(toIndentedString(certificateReferences)).append("\n");
    sb.append("    endpointConfiguration: ").append(toIndentedString(endpointConfiguration)).append("\n");
    sb.append("    errors: ").append(toIndentedString(errors)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    ipAddress: ").append(toIndentedString(ipAddress)).append("\n");
    sb.append("    isDedicated: ").append(toIndentedString(isDedicated)).append("\n");
    sb.append("    lastBootTime: ").append(toIndentedString(lastBootTime)).append("\n");
    sb.append("    recentTasks: ").append(toIndentedString(recentTasks)).append("\n");
    sb.append("    runningTasksCount: ").append(toIndentedString(runningTasksCount)).append("\n");
    sb.append("    schedulingState: ").append(toIndentedString(schedulingState)).append("\n");
    sb.append("    startTask: ").append(toIndentedString(startTask)).append("\n");
    sb.append("    startTaskInfo: ").append(toIndentedString(startTaskInfo)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    stateTransitionTime: ").append(toIndentedString(stateTransitionTime)).append("\n");
    sb.append("    totalTasksRun: ").append(toIndentedString(totalTasksRun)).append("\n");
    sb.append("    totalTasksSucceeded: ").append(toIndentedString(totalTasksSucceeded)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    vmSize: ").append(toIndentedString(vmSize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("affinityId");
    openapiFields.add("allocationTime");
    openapiFields.add("certificateReferences");
    openapiFields.add("endpointConfiguration");
    openapiFields.add("errors");
    openapiFields.add("id");
    openapiFields.add("ipAddress");
    openapiFields.add("isDedicated");
    openapiFields.add("lastBootTime");
    openapiFields.add("recentTasks");
    openapiFields.add("runningTasksCount");
    openapiFields.add("schedulingState");
    openapiFields.add("startTask");
    openapiFields.add("startTaskInfo");
    openapiFields.add("state");
    openapiFields.add("stateTransitionTime");
    openapiFields.add("totalTasksRun");
    openapiFields.add("totalTasksSucceeded");
    openapiFields.add("url");
    openapiFields.add("vmSize");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ComputeNode
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ComputeNode.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ComputeNode is not found in the empty JSON string", ComputeNode.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ComputeNode.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ComputeNode` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("affinityId") != null && !jsonObj.get("affinityId").isJsonNull()) && !jsonObj.get("affinityId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `affinityId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("affinityId").toString()));
      }
      if (jsonObj.get("certificateReferences") != null && !jsonObj.get("certificateReferences").isJsonNull()) {
        JsonArray jsonArraycertificateReferences = jsonObj.getAsJsonArray("certificateReferences");
        if (jsonArraycertificateReferences != null) {
          // ensure the json data is an array
          if (!jsonObj.get("certificateReferences").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `certificateReferences` to be an array in the JSON string but got `%s`", jsonObj.get("certificateReferences").toString()));
          }

          // validate the optional field `certificateReferences` (array)
          for (int i = 0; i < jsonArraycertificateReferences.size(); i++) {
            CertificateReference.validateJsonElement(jsonArraycertificateReferences.get(i));
          };
        }
      }
      // validate the optional field `endpointConfiguration`
      if (jsonObj.get("endpointConfiguration") != null && !jsonObj.get("endpointConfiguration").isJsonNull()) {
        ComputeNodeEndpointConfiguration.validateJsonElement(jsonObj.get("endpointConfiguration"));
      }
      if (jsonObj.get("errors") != null && !jsonObj.get("errors").isJsonNull()) {
        JsonArray jsonArrayerrors = jsonObj.getAsJsonArray("errors");
        if (jsonArrayerrors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("errors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `errors` to be an array in the JSON string but got `%s`", jsonObj.get("errors").toString()));
          }

          // validate the optional field `errors` (array)
          for (int i = 0; i < jsonArrayerrors.size(); i++) {
            ComputeNodeError.validateJsonElement(jsonArrayerrors.get(i));
          };
        }
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("ipAddress") != null && !jsonObj.get("ipAddress").isJsonNull()) && !jsonObj.get("ipAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipAddress").toString()));
      }
      if (jsonObj.get("recentTasks") != null && !jsonObj.get("recentTasks").isJsonNull()) {
        JsonArray jsonArrayrecentTasks = jsonObj.getAsJsonArray("recentTasks");
        if (jsonArrayrecentTasks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("recentTasks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `recentTasks` to be an array in the JSON string but got `%s`", jsonObj.get("recentTasks").toString()));
          }

          // validate the optional field `recentTasks` (array)
          for (int i = 0; i < jsonArrayrecentTasks.size(); i++) {
            TaskInformation.validateJsonElement(jsonArrayrecentTasks.get(i));
          };
        }
      }
      if ((jsonObj.get("schedulingState") != null && !jsonObj.get("schedulingState").isJsonNull()) && !jsonObj.get("schedulingState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `schedulingState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("schedulingState").toString()));
      }
      // validate the optional field `schedulingState`
      if (jsonObj.get("schedulingState") != null && !jsonObj.get("schedulingState").isJsonNull()) {
        SchedulingStateEnum.validateJsonElement(jsonObj.get("schedulingState"));
      }
      // validate the optional field `startTask`
      if (jsonObj.get("startTask") != null && !jsonObj.get("startTask").isJsonNull()) {
        StartTask.validateJsonElement(jsonObj.get("startTask"));
      }
      // validate the optional field `startTaskInfo`
      if (jsonObj.get("startTaskInfo") != null && !jsonObj.get("startTaskInfo").isJsonNull()) {
        StartTaskInformation.validateJsonElement(jsonObj.get("startTaskInfo"));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("url") != null && !jsonObj.get("url").isJsonNull()) && !jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      if ((jsonObj.get("vmSize") != null && !jsonObj.get("vmSize").isJsonNull()) && !jsonObj.get("vmSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vmSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vmSize").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ComputeNode.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ComputeNode' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ComputeNode> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ComputeNode.class));

       return (TypeAdapter<T>) new TypeAdapter<ComputeNode>() {
           @Override
           public void write(JsonWriter out, ComputeNode value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ComputeNode read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ComputeNode given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ComputeNode
   * @throws IOException if the JSON string is invalid with respect to ComputeNode
   */
  public static ComputeNode fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ComputeNode.class);
  }

  /**
   * Convert an instance of ComputeNode to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

