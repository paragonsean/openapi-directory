/*
 * BulkSMS JSON REST API
 * ## Overview  The JSON REST API allows you to submit and receive [BulkSMS](https://www.bulksms.com/) messages. You can also get access to past messages and see your account profile.  The base URL to use for this service is `https://api.bulksms.com/v1`.  The base URL cannot be used on its own; you must append a path that identifies an operation and you may have to specify some path parameters as well.  [Click here](/developer/) to go to the main BulkSMS developer site.  In order to give you an idea on how the API can be used, some JSON snippets are provided below.  Have a look at the [messages section](#tag/Message) for more information.  Probably the most simple example  ``` {     \"to\": \"+27001234567\",     \"body\": \"Hello World!\" } ```   You can send unicode automatically using the `auto-unicode` query parameter.  Alternatively, you can specify `UNICODE` for the `encoding` property in the request body.  Please note: when `auto-unicode` is specified and the value of the `encoding` property is `UNICODE`, the message will always be sent as `UNICODE`.  Here is an example that sets the `encoding` explicitly  ``` {   \"to\": \"+27001234567\",   \"body\": \"Dobr치 pr치ce! Jak se m치코?\",   \"encoding\": \"UNICODE\" } ```  You can also specify a from number  ``` {     \"from\": \"+27007654321\",     \"to\": \"+27001234567\",     \"body\": \"Hello World!\" } ```  Similar to above, but repliable  ``` {     \"from\": { \"type\": \"REPLIABLE\" },     \"to\": \"+27001234567\",     \"body\": \"Hello World!\" } ```  A message to a group called Everyone  ``` {     \"to\": { \"type\": \"GROUP\", \"name\": \"Everyone\" },     \"body\": \"Hello World!\" } ```  A message to multiple recipients  ``` {     \"to\": [\"+27001234567\", \"+27002345678\", \"+27003456789\"],     \"body\": \"Happy Holidays!\" } ```  Sending more than one message in the same request  ``` [     {         \"to\": \"+27001234567\",         \"body\": \"Hello World!\"     },     {         \"to\": \"+27002345678\",         \"body\": \"Hello Universe!\"     } ] ```  **The insecure base URL `http://api.bulksms.com/v1` is deprecated** and may in future result in a `301` redirect response, or insecure requests may be rejected outright. Please use the secure (`https`) URI above.  ### HTTP Content Type  All API methods expect requests to supply a `Content-Type` header with the value `application/json`. All responses will have the `Content-Type` header set to `application/json`.  ### JSON Formatting  You are advised to format your JSON resources according to strict JSON format rules. While the API does attempt to parse strictly invalid JSON documents, doing so may lead to incorrect interpretation and unexpected results.  Good JSON libraries will produce valid JSON suitable for submission, but if you are manually generating the JSON text, be careful to follow the JSON format. This include correct escaping of control characters and double quoting of property names.  See the [JSON specification](https://tools.ietf.org/html/rfc4627) for further information.  ### Date Formatting  Dates are formatted according to ISO-8601, such as `1970-01-01T10:00:00+01:00` for 1st January 1970, 10AM UTC+1.  See the [Wikipedia ISO 8601 reference](https://en.wikipedia.org/wiki/ISO_8601) for further information.  Specifically, calendar dates are formatted with the 'extended' format `YYYY-MM-DD`. Basic format, week dates and ordinal dates are not supported. Times are also formatted in the 'extended' format `hh:mm:ss`. Hours, minutes and seconds are mandatory. Offset from UTC must be provided; this is to ensure that there is no misunderstanding regarding times provided to the API.  The format we look for is `yyyy-MM-ddThh:mm:ss[Z|[+-]hh:mm]`  Examples of valid date/times are`2011-12-31T12:00:00Z` `2011-12-31T12:00:00+02:00`  ### Entity Format Modifications  It is expected that over time some changes will be made to the request and response formats of various methods available in the API. Where possible, these will be implemented in a backwards compatible way. To make this possible you are required to ignore unknown properties. This enables the addition of information in response documents while maintaining compatibility with older clients.  ### Optional Request Entity Properties  There are many instances where requests can be made without having to specify every single property allowable in the request format. Any such optional properties are noted as such in the documentation and their default value is noted. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import org.openapitools.client.model.Error;
import org.openapitools.client.model.Message;
import java.time.OffsetDateTime;
import org.openapitools.client.model.SubmissionEntry;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MessageApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MessageApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MessageApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for messagesGet
     * @param limit The maximum number of messages that are returned.  The default is 1000. The value of &#x60;limit&#x60; is not a guarantee that a specific number of messages will be in the response, even if there are more messages available.  Consider the case where you have 150 messages and you specify &#x60;limit&#x3D;50&#x60;.  It is possible that only 49 messages will be returned.  The  way to make sure that there are no more messages is to submit a new call using the &#x60;id&#x60; filter field with the &#x60;&lt;&#x60; operator (described below). (optional)
     * @param filter See the message filtering for more information. (optional)
     * @param sortOrder The default value is DESCENDING  If the &#x60;sortOrder&#x60; is DESCENDING, the newest messages be first in the result.  ASCENDING places the oldest messages on top of the response.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Contains the requested array of messages </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesGetCall(BigDecimal limit, String filter, String sortOrder, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (sortOrder != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortOrder", sortOrder));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesGetValidateBeforeCall(BigDecimal limit, String filter, String sortOrder, final ApiCallback _callback) throws ApiException {
        return messagesGetCall(limit, filter, sortOrder, _callback);

    }

    /**
     * Retrieve Messages
     * Retrieve the messages you have sent or received.    Scheduled messages are available for retrieval only after the delivery date.  All the parameters are optional.  If a value is not supplied for &#x60;filter&#x60;, the messages are not filtered.  Messages can be filtered by supplying query clauses in the &#x60;filter&#x60; parameter. Each clause has the form &#x60;name&#x3D;value&#x60; where &#x60;name&#x60; is the name of a filter field and &#x60;value&#x60; is a valid value for that field.  A value for a field is optional. Include a clause for a field in the filter only when there is a need to fetch messages that match some value for that field. For a numeric filter field, you can also use the less than operator (&#x60;&lt;&#x60;).  If present, the filter value must have at least one clause, but it can contain a combination of clauses. Multiple clauses are separated with the &#x60;&amp;&#x60; symbol.  Semantically, multiple clauses form a [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction).  For example, if you want to list all messages that were sent as part of a particular submission, your filter contains two clauses and will look something like this &#x60;&#x60;&#x60; type%3DSENT&amp;submission.id%3D1-00000000000522347562 &#x60;&#x60;&#x60; Because &#x60;filter&#x60; is a request parameter, it is important to note that the value for this parameter must be *URL encoded*. In particular, the &#x60;&#x3D;&#x60; encodes to &#x60;%3D&#x60; and the &#x60;&amp;&#x60; encodes to &#x60;%26&#x60;.  Note that you do not have to encode the &#x60;&lt;&#x60; character.  Using the previous example to illustrate; after encoding and encasing it, the clauses are transformed into a request that looks like this &#x60;&#x60;&#x60; GET /v1/messages?filter&#x3D;type%3DSENT%26submission.id%3D1-00000000000522347562 &#x60;&#x60;&#x60; If the field name or the field value of a clause is not valid, a [bad_request error](errors#bad-request) is returned instead of the usual result.  The &#x60;detail&#x60; field of this error provides more information about the problem.  The table below lists the fields available for filtering  | Field | Type   | Values | Note and example | |-------|------|--------------------|------| | id            | Integer  | Positive integer  | Use the &#x60;id&#x60; field with &#x60;&lt;&#x60; (or with &#x60;&gt;&#x60;) to fetch messages that are older (or newer) than those that are already fetched. &lt;br/&gt;&#x60;filter&#x3D;id&lt;123456&#x60; | | type          | String  | SENT, RECEIVED  | SENT are Mobile Terminating (MT) SMSs; RECEIVED are Mobile Originating (MO) SMSs.&lt;br/&gt;&#x60;filter&#x3D;type%3DSENT&#x60; | | submission.id | String  |  | &#x60;filter&#x3D;submission.id%3D1-00000000000522347562&#x60; | | status.type   | String  | ACCEPTED, SENT, DELIVERED, FAILED  | See the message &#x60;status.type&#x60; field for more information. &lt;br/&gt;&#x60;filter&#x3D;status.type%3DDELIVERED&#x60; | | status.id| String  |  | See the message &#x60;status.id&#x60; field for more information. &#x60;filter&#x3D;status.id%3DFAILED.EXPIRED&#x60;| | submission.date | String | Formatted Date | A fully specified date (e.g. 2017-01-01T10:00:00+01:00).  Use this field with &#x60;&lt;&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x60; or &#x60;&gt;&#x3D;&#x60; to limit the values. &lt;br/&gt;&#x60;filter&#x3D;submission.date%3E%3D2017-01-01T10%3A00%3A00%2B01%3A00&#x60; | | userSuppliedId  | String | | Use a string value you specified in the &#x60;userSuppliedId&#x60; property when you sent the message. Only &#x60;SENT&#x60; messages will be retrieved. &lt;br/&gt;&#x60;filter&#x3D;userSuppliedId%3Dacc009876&#x60; | 
     * @param limit The maximum number of messages that are returned.  The default is 1000. The value of &#x60;limit&#x60; is not a guarantee that a specific number of messages will be in the response, even if there are more messages available.  Consider the case where you have 150 messages and you specify &#x60;limit&#x3D;50&#x60;.  It is possible that only 49 messages will be returned.  The  way to make sure that there are no more messages is to submit a new call using the &#x60;id&#x60; filter field with the &#x60;&lt;&#x60; operator (described below). (optional)
     * @param filter See the message filtering for more information. (optional)
     * @param sortOrder The default value is DESCENDING  If the &#x60;sortOrder&#x60; is DESCENDING, the newest messages be first in the result.  ASCENDING places the oldest messages on top of the response.  (optional)
     * @return List&lt;Message&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Contains the requested array of messages </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
     </table>
     */
    public List<Message> messagesGet(BigDecimal limit, String filter, String sortOrder) throws ApiException {
        ApiResponse<List<Message>> localVarResp = messagesGetWithHttpInfo(limit, filter, sortOrder);
        return localVarResp.getData();
    }

    /**
     * Retrieve Messages
     * Retrieve the messages you have sent or received.    Scheduled messages are available for retrieval only after the delivery date.  All the parameters are optional.  If a value is not supplied for &#x60;filter&#x60;, the messages are not filtered.  Messages can be filtered by supplying query clauses in the &#x60;filter&#x60; parameter. Each clause has the form &#x60;name&#x3D;value&#x60; where &#x60;name&#x60; is the name of a filter field and &#x60;value&#x60; is a valid value for that field.  A value for a field is optional. Include a clause for a field in the filter only when there is a need to fetch messages that match some value for that field. For a numeric filter field, you can also use the less than operator (&#x60;&lt;&#x60;).  If present, the filter value must have at least one clause, but it can contain a combination of clauses. Multiple clauses are separated with the &#x60;&amp;&#x60; symbol.  Semantically, multiple clauses form a [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction).  For example, if you want to list all messages that were sent as part of a particular submission, your filter contains two clauses and will look something like this &#x60;&#x60;&#x60; type%3DSENT&amp;submission.id%3D1-00000000000522347562 &#x60;&#x60;&#x60; Because &#x60;filter&#x60; is a request parameter, it is important to note that the value for this parameter must be *URL encoded*. In particular, the &#x60;&#x3D;&#x60; encodes to &#x60;%3D&#x60; and the &#x60;&amp;&#x60; encodes to &#x60;%26&#x60;.  Note that you do not have to encode the &#x60;&lt;&#x60; character.  Using the previous example to illustrate; after encoding and encasing it, the clauses are transformed into a request that looks like this &#x60;&#x60;&#x60; GET /v1/messages?filter&#x3D;type%3DSENT%26submission.id%3D1-00000000000522347562 &#x60;&#x60;&#x60; If the field name or the field value of a clause is not valid, a [bad_request error](errors#bad-request) is returned instead of the usual result.  The &#x60;detail&#x60; field of this error provides more information about the problem.  The table below lists the fields available for filtering  | Field | Type   | Values | Note and example | |-------|------|--------------------|------| | id            | Integer  | Positive integer  | Use the &#x60;id&#x60; field with &#x60;&lt;&#x60; (or with &#x60;&gt;&#x60;) to fetch messages that are older (or newer) than those that are already fetched. &lt;br/&gt;&#x60;filter&#x3D;id&lt;123456&#x60; | | type          | String  | SENT, RECEIVED  | SENT are Mobile Terminating (MT) SMSs; RECEIVED are Mobile Originating (MO) SMSs.&lt;br/&gt;&#x60;filter&#x3D;type%3DSENT&#x60; | | submission.id | String  |  | &#x60;filter&#x3D;submission.id%3D1-00000000000522347562&#x60; | | status.type   | String  | ACCEPTED, SENT, DELIVERED, FAILED  | See the message &#x60;status.type&#x60; field for more information. &lt;br/&gt;&#x60;filter&#x3D;status.type%3DDELIVERED&#x60; | | status.id| String  |  | See the message &#x60;status.id&#x60; field for more information. &#x60;filter&#x3D;status.id%3DFAILED.EXPIRED&#x60;| | submission.date | String | Formatted Date | A fully specified date (e.g. 2017-01-01T10:00:00+01:00).  Use this field with &#x60;&lt;&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x60; or &#x60;&gt;&#x3D;&#x60; to limit the values. &lt;br/&gt;&#x60;filter&#x3D;submission.date%3E%3D2017-01-01T10%3A00%3A00%2B01%3A00&#x60; | | userSuppliedId  | String | | Use a string value you specified in the &#x60;userSuppliedId&#x60; property when you sent the message. Only &#x60;SENT&#x60; messages will be retrieved. &lt;br/&gt;&#x60;filter&#x3D;userSuppliedId%3Dacc009876&#x60; | 
     * @param limit The maximum number of messages that are returned.  The default is 1000. The value of &#x60;limit&#x60; is not a guarantee that a specific number of messages will be in the response, even if there are more messages available.  Consider the case where you have 150 messages and you specify &#x60;limit&#x3D;50&#x60;.  It is possible that only 49 messages will be returned.  The  way to make sure that there are no more messages is to submit a new call using the &#x60;id&#x60; filter field with the &#x60;&lt;&#x60; operator (described below). (optional)
     * @param filter See the message filtering for more information. (optional)
     * @param sortOrder The default value is DESCENDING  If the &#x60;sortOrder&#x60; is DESCENDING, the newest messages be first in the result.  ASCENDING places the oldest messages on top of the response.  (optional)
     * @return ApiResponse&lt;List&lt;Message&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Contains the requested array of messages </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Message>> messagesGetWithHttpInfo(BigDecimal limit, String filter, String sortOrder) throws ApiException {
        okhttp3.Call localVarCall = messagesGetValidateBeforeCall(limit, filter, sortOrder, null);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve Messages (asynchronously)
     * Retrieve the messages you have sent or received.    Scheduled messages are available for retrieval only after the delivery date.  All the parameters are optional.  If a value is not supplied for &#x60;filter&#x60;, the messages are not filtered.  Messages can be filtered by supplying query clauses in the &#x60;filter&#x60; parameter. Each clause has the form &#x60;name&#x3D;value&#x60; where &#x60;name&#x60; is the name of a filter field and &#x60;value&#x60; is a valid value for that field.  A value for a field is optional. Include a clause for a field in the filter only when there is a need to fetch messages that match some value for that field. For a numeric filter field, you can also use the less than operator (&#x60;&lt;&#x60;).  If present, the filter value must have at least one clause, but it can contain a combination of clauses. Multiple clauses are separated with the &#x60;&amp;&#x60; symbol.  Semantically, multiple clauses form a [logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction).  For example, if you want to list all messages that were sent as part of a particular submission, your filter contains two clauses and will look something like this &#x60;&#x60;&#x60; type%3DSENT&amp;submission.id%3D1-00000000000522347562 &#x60;&#x60;&#x60; Because &#x60;filter&#x60; is a request parameter, it is important to note that the value for this parameter must be *URL encoded*. In particular, the &#x60;&#x3D;&#x60; encodes to &#x60;%3D&#x60; and the &#x60;&amp;&#x60; encodes to &#x60;%26&#x60;.  Note that you do not have to encode the &#x60;&lt;&#x60; character.  Using the previous example to illustrate; after encoding and encasing it, the clauses are transformed into a request that looks like this &#x60;&#x60;&#x60; GET /v1/messages?filter&#x3D;type%3DSENT%26submission.id%3D1-00000000000522347562 &#x60;&#x60;&#x60; If the field name or the field value of a clause is not valid, a [bad_request error](errors#bad-request) is returned instead of the usual result.  The &#x60;detail&#x60; field of this error provides more information about the problem.  The table below lists the fields available for filtering  | Field | Type   | Values | Note and example | |-------|------|--------------------|------| | id            | Integer  | Positive integer  | Use the &#x60;id&#x60; field with &#x60;&lt;&#x60; (or with &#x60;&gt;&#x60;) to fetch messages that are older (or newer) than those that are already fetched. &lt;br/&gt;&#x60;filter&#x3D;id&lt;123456&#x60; | | type          | String  | SENT, RECEIVED  | SENT are Mobile Terminating (MT) SMSs; RECEIVED are Mobile Originating (MO) SMSs.&lt;br/&gt;&#x60;filter&#x3D;type%3DSENT&#x60; | | submission.id | String  |  | &#x60;filter&#x3D;submission.id%3D1-00000000000522347562&#x60; | | status.type   | String  | ACCEPTED, SENT, DELIVERED, FAILED  | See the message &#x60;status.type&#x60; field for more information. &lt;br/&gt;&#x60;filter&#x3D;status.type%3DDELIVERED&#x60; | | status.id| String  |  | See the message &#x60;status.id&#x60; field for more information. &#x60;filter&#x3D;status.id%3DFAILED.EXPIRED&#x60;| | submission.date | String | Formatted Date | A fully specified date (e.g. 2017-01-01T10:00:00+01:00).  Use this field with &#x60;&lt;&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&gt;&#x60; or &#x60;&gt;&#x3D;&#x60; to limit the values. &lt;br/&gt;&#x60;filter&#x3D;submission.date%3E%3D2017-01-01T10%3A00%3A00%2B01%3A00&#x60; | | userSuppliedId  | String | | Use a string value you specified in the &#x60;userSuppliedId&#x60; property when you sent the message. Only &#x60;SENT&#x60; messages will be retrieved. &lt;br/&gt;&#x60;filter&#x3D;userSuppliedId%3Dacc009876&#x60; | 
     * @param limit The maximum number of messages that are returned.  The default is 1000. The value of &#x60;limit&#x60; is not a guarantee that a specific number of messages will be in the response, even if there are more messages available.  Consider the case where you have 150 messages and you specify &#x60;limit&#x3D;50&#x60;.  It is possible that only 49 messages will be returned.  The  way to make sure that there are no more messages is to submit a new call using the &#x60;id&#x60; filter field with the &#x60;&lt;&#x60; operator (described below). (optional)
     * @param filter See the message filtering for more information. (optional)
     * @param sortOrder The default value is DESCENDING  If the &#x60;sortOrder&#x60; is DESCENDING, the newest messages be first in the result.  ASCENDING places the oldest messages on top of the response.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Contains the requested array of messages </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesGetAsync(BigDecimal limit, String filter, String sortOrder, final ApiCallback<List<Message>> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesGetValidateBeforeCall(limit, filter, sortOrder, _callback);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for messagesIdGet
     * @param id The &#x60;id&#x60; of the message you want to retrieve (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The message detail </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A [not-found error](errors/#not-found) if the message cannot be found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIdGetCall(String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesIdGetValidateBeforeCall(String id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling messagesIdGet(Async)");
        }

        return messagesIdGetCall(id, _callback);

    }

    /**
     * Show Message
     * Get a the message by &#x60;id&#x60;. &#x60;&#x60;&#x60;http GET /v1/messages/4023457654 &#x60;&#x60;&#x60; 
     * @param id The &#x60;id&#x60; of the message you want to retrieve (required)
     * @return Message
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The message detail </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A [not-found error](errors/#not-found) if the message cannot be found. </td><td>  -  </td></tr>
     </table>
     */
    public Message messagesIdGet(String id) throws ApiException {
        ApiResponse<Message> localVarResp = messagesIdGetWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Show Message
     * Get a the message by &#x60;id&#x60;. &#x60;&#x60;&#x60;http GET /v1/messages/4023457654 &#x60;&#x60;&#x60; 
     * @param id The &#x60;id&#x60; of the message you want to retrieve (required)
     * @return ApiResponse&lt;Message&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The message detail </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A [not-found error](errors/#not-found) if the message cannot be found. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Message> messagesIdGetWithHttpInfo(String id) throws ApiException {
        okhttp3.Call localVarCall = messagesIdGetValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<Message>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Show Message (asynchronously)
     * Get a the message by &#x60;id&#x60;. &#x60;&#x60;&#x60;http GET /v1/messages/4023457654 &#x60;&#x60;&#x60; 
     * @param id The &#x60;id&#x60; of the message you want to retrieve (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The message detail </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> A [not-found error](errors/#not-found) if the message cannot be found. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIdGetAsync(String id, final ApiCallback<Message> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesIdGetValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<Message>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for messagesIdRelatedReceivedMessagesGet
     * @param id The &#x60;id&#x60; of the sent message (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of related messages.  If the &#x60;id&#x60; is not a sent message, the array will be empty. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIdRelatedReceivedMessagesGetCall(String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/{id}/relatedReceivedMessages"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesIdRelatedReceivedMessagesGetValidateBeforeCall(String id, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling messagesIdRelatedReceivedMessagesGet(Async)");
        }

        return messagesIdRelatedReceivedMessagesGetCall(id, _callback);

    }

    /**
     * List Related Messages
     * Get the messages related to a sent message identified by &#x60;id&#x60;.  For more information how this work, see the &#x60;relatedSentMessageId&#x60; field in the message. 
     * @param id The &#x60;id&#x60; of the sent message (required)
     * @return List&lt;Message&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of related messages.  If the &#x60;id&#x60; is not a sent message, the array will be empty. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
     </table>
     */
    public List<Message> messagesIdRelatedReceivedMessagesGet(String id) throws ApiException {
        ApiResponse<List<Message>> localVarResp = messagesIdRelatedReceivedMessagesGetWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * List Related Messages
     * Get the messages related to a sent message identified by &#x60;id&#x60;.  For more information how this work, see the &#x60;relatedSentMessageId&#x60; field in the message. 
     * @param id The &#x60;id&#x60; of the sent message (required)
     * @return ApiResponse&lt;List&lt;Message&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of related messages.  If the &#x60;id&#x60; is not a sent message, the array will be empty. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Message>> messagesIdRelatedReceivedMessagesGetWithHttpInfo(String id) throws ApiException {
        okhttp3.Call localVarCall = messagesIdRelatedReceivedMessagesGetValidateBeforeCall(id, null);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Related Messages (asynchronously)
     * Get the messages related to a sent message identified by &#x60;id&#x60;.  For more information how this work, see the &#x60;relatedSentMessageId&#x60; field in the message. 
     * @param id The &#x60;id&#x60; of the sent message (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> An array of related messages.  If the &#x60;id&#x60; is not a sent message, the array will be empty. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesIdRelatedReceivedMessagesGetAsync(String id, final ApiCallback<List<Message>> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesIdRelatedReceivedMessagesGetValidateBeforeCall(id, _callback);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for messagesPost
     * @param submissionEntry Contains details of the message (or messages) that you want to send.  One &#x60;SubmissionEntry&#x60; can produce many messages, and your request may contain multiple such entries.  (required)
     * @param deduplicationId Safeguards against the possibility of sending the same messages more than once.  If a communication failure occurs during a submission, you cannot be sure that the submission was processed; therefore you would have to submit it again. When you post the retry, you must use the &#x60;deduplication-id&#x60; of the original post. The BulkSMS system uses this ID to check that the request was not previously processed. (If it was previously processed, the submission will succeed, and the behaviour will be indistinguishable to you from a non-duplicated submission). The ID expires after about 12 hours.  (optional)
     * @param autoUnicode Specifies how to deal with message text that contains characters not present in the GSM 03.38 character set.  Messages that contain only GSM 03.38 characters are not affected by this setting.  If the value is &#x60;true&#x60; then a message containing non-GSM 03.38 characters will be transmitted as a Unicode SMS (which is most likely more costly).   Please note: when &#x60;auto-unicode&#x60; is &#x60;true&#x60; and the value of the &#x60;encoding&#x60; property is specified as &#x60;UNICODE&#x60;, the message will always be sent as &#x60;UNICODE&#x60;.  If the value is &#x60;false&#x60; and the &#x60;encoding&#x60; property is &#x60;TEXT&#x60; then non-GSM 03.38 characters will be replaced by the &#x60;?&#x60; character.  When using this setting on the API, you should take case to ensure that your message is _clean_.    Invisible unicode and unexpected characters could unintentionally convert an message to &#x60;UNICODE&#x60;.  A common mistake is to use the backtick character (\\&#x60;) which is unicode and will turn your &#x60;TEXT&#x60; message into a &#x60;UNICODE&#x60; message.  (optional, default to false)
     * @param scheduleDate Allows you to send a message in the future.  An example value is &#x60;2019-02-18T13:00:00+02:00&#x60;.  It encodes to &#x60;2019-02-18T13%3A00%3A00%2B02%3A00&#x60;. Credits are deducted from your account immediately. Once submitted, scheduled messages cannot be changed or cancelled. The date can be a maximum of two years in the future. If the value is in the past, the message will be sent immediately. The date format requires you to supply an offset from UTC. You can decide to use the offset of your timezone, or maybe the zone of the recipient&#39;s location is more appropriate. If the destination is a group, the group members are determined at the time that you submit the message; not the time the message is scheduled to be sent.  (optional)
     * @param scheduleDescription A note that is stored together with a scheduled submission, which could be used to more easily identify the scheduled submission at a later date.  The value of this field is ignored if the &#x60;schedule-date&#x60; is not provided. A value that is longer than 256 characters is truncated.  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> An array of the messages that were created from the request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden.  Inspect the body of the response for further details - for example, you may have insufficient credits remaining </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesPostCall(List<SubmissionEntry> submissionEntry, Integer deduplicationId, Boolean autoUnicode, OffsetDateTime scheduleDate, String scheduleDescription, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = submissionEntry;

        // create path and map variables
        String localVarPath = "/messages";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deduplicationId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deduplication-id", deduplicationId));
        }

        if (autoUnicode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("auto-unicode", autoUnicode));
        }

        if (scheduleDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("schedule-date", scheduleDate));
        }

        if (scheduleDescription != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("schedule-description", scheduleDescription));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesPostValidateBeforeCall(List<SubmissionEntry> submissionEntry, Integer deduplicationId, Boolean autoUnicode, OffsetDateTime scheduleDate, String scheduleDescription, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'submissionEntry' is set
        if (submissionEntry == null) {
            throw new ApiException("Missing the required parameter 'submissionEntry' when calling messagesPost(Async)");
        }

        return messagesPostCall(submissionEntry, deduplicationId, autoUnicode, scheduleDate, scheduleDescription, _callback);

    }

    /**
     * Send Messages
     * Send messages to one or more recipients.  You can post up to &#x60;30 000&#x60; messages in a batch.  But note that the &#x60;deduplication-id&#x60; is set per submission, so it is recommended that you use a smaller number, like &#x60;4000&#x60; per submission in order to make resubmissions on network failures more practical.  #### Repliability  When a sent message is _repliable_,  the BulkSMS system can process an SMS response sent by your recipient.  The message sent by your customer is called a mobile originating (MO) message and would be available under &#x60;RECEIVED&#x60; messages.  You can obtain a list of MOs using the [retrieve messages API call](#tag/Message%2Fpaths%2F~1messages%2Fget). In addition you can also get a list of the MOs that are associated with a specific sent message (see the [list related messages API call](#tag/Message%2Fpaths%2F~1messages~1%7Bid%7D~1relatedReceivedMessages%2Fget)).  If you use a specific _sender id_ in the &#x60;from&#x60; property of the send message, the message will not be repliable. If you want a message to be repliable, you need to specify &#x60;REPLIABLE&#x60; in the &#x60;from.type&#x60; property.  If you do not set the &#x60;from&#x60; property, your account settings are considered to determine whether or not the message is repliable. If the _default repliable_ setting on your account is _yes_ then the message will be repliable.  If this setting is _no_, the message will not be repliable.   #### Body templates  When sending a message you can use template fields to customise the message text.  *Field based templates* allow you to create a message with place-holders for custom fields.  Fields are identified by a zero based index; the first field is &#x60;F0&#x60;, the second is &#x60;F1&#x60; and so on.    For example, let&#39;s say you want to send a daily SMS message to all your clients that tell them what their current balance is.  The &#x60;body&#x60; of the message could look something like this   &#x60;&#x60;&#x60; Good morning {F0######}, your balance is {F1######} &#x60;&#x60;&#x60;  In this message, the first field, &#x60;F0&#x60;, is the name  of the customer and he second field &#x60;F1&#x60; is the balance for that customer.  The &#x60;#&#x60; used to specify the maximum length  of the field.  Note that the maximum length allowed for the value includes the space taken by the braces, template name and hash symbol.  For example, the value &#x60;{F0#}&#x60; specifies a maximum length of &#x60;5&#x60;.  If the data is longer than this length, the data will be truncated when the message body is constructed.  The data fields are provided in the property named &#x60;fields&#x60; in the &#x60;to&#x60; element.  Here is a complete example of how this might look  &#x60;&#x60;&#x60; {   \&quot;body\&quot;: \&quot;Good morning {F0######}, your balance is {F1######}\&quot;,   \&quot;to\&quot;:  [       {\&quot;address\&quot;: \&quot;27456789\&quot;,\&quot;fields\&quot;: [\&quot;Harry\&quot;, \&quot;$1345.23\&quot;] },       {\&quot;address\&quot;: \&quot;27456785\&quot;,\&quot;fields\&quot;: [\&quot;Sally\&quot;, \&quot;$2345.58\&quot;] }   ] } &#x60;&#x60;&#x60;  If you are sending to contacts (or to groups) in your phonebook, you can use the *Phonebook based templates*.  These are similar to the templates described above, but they have specific names. The template for the contact&#39;s first name is identified by &#x60;fn&#x60; and the template for the contact&#39;s surname is identified by &#x60;sn&#x60;.  Below in an example that will work if the numbers are registered in your phonebook.   &#x60;&#x60;&#x60; {   \&quot;body\&quot;: \&quot;Hi {fn######} {sn######}, have a great day!\&quot;,   \&quot;to\&quot;:  [       {\&quot;address\&quot;: \&quot;27456789\&quot; },       {\&quot;address\&quot;: \&quot;27456785\&quot; }   ] } &#x60;&#x60;&#x60; 
     * @param submissionEntry Contains details of the message (or messages) that you want to send.  One &#x60;SubmissionEntry&#x60; can produce many messages, and your request may contain multiple such entries.  (required)
     * @param deduplicationId Safeguards against the possibility of sending the same messages more than once.  If a communication failure occurs during a submission, you cannot be sure that the submission was processed; therefore you would have to submit it again. When you post the retry, you must use the &#x60;deduplication-id&#x60; of the original post. The BulkSMS system uses this ID to check that the request was not previously processed. (If it was previously processed, the submission will succeed, and the behaviour will be indistinguishable to you from a non-duplicated submission). The ID expires after about 12 hours.  (optional)
     * @param autoUnicode Specifies how to deal with message text that contains characters not present in the GSM 03.38 character set.  Messages that contain only GSM 03.38 characters are not affected by this setting.  If the value is &#x60;true&#x60; then a message containing non-GSM 03.38 characters will be transmitted as a Unicode SMS (which is most likely more costly).   Please note: when &#x60;auto-unicode&#x60; is &#x60;true&#x60; and the value of the &#x60;encoding&#x60; property is specified as &#x60;UNICODE&#x60;, the message will always be sent as &#x60;UNICODE&#x60;.  If the value is &#x60;false&#x60; and the &#x60;encoding&#x60; property is &#x60;TEXT&#x60; then non-GSM 03.38 characters will be replaced by the &#x60;?&#x60; character.  When using this setting on the API, you should take case to ensure that your message is _clean_.    Invisible unicode and unexpected characters could unintentionally convert an message to &#x60;UNICODE&#x60;.  A common mistake is to use the backtick character (\\&#x60;) which is unicode and will turn your &#x60;TEXT&#x60; message into a &#x60;UNICODE&#x60; message.  (optional, default to false)
     * @param scheduleDate Allows you to send a message in the future.  An example value is &#x60;2019-02-18T13:00:00+02:00&#x60;.  It encodes to &#x60;2019-02-18T13%3A00%3A00%2B02%3A00&#x60;. Credits are deducted from your account immediately. Once submitted, scheduled messages cannot be changed or cancelled. The date can be a maximum of two years in the future. If the value is in the past, the message will be sent immediately. The date format requires you to supply an offset from UTC. You can decide to use the offset of your timezone, or maybe the zone of the recipient&#39;s location is more appropriate. If the destination is a group, the group members are determined at the time that you submit the message; not the time the message is scheduled to be sent.  (optional)
     * @param scheduleDescription A note that is stored together with a scheduled submission, which could be used to more easily identify the scheduled submission at a later date.  The value of this field is ignored if the &#x60;schedule-date&#x60; is not provided. A value that is longer than 256 characters is truncated.  (optional)
     * @return List&lt;Message&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> An array of the messages that were created from the request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden.  Inspect the body of the response for further details - for example, you may have insufficient credits remaining </td><td>  -  </td></tr>
     </table>
     */
    public List<Message> messagesPost(List<SubmissionEntry> submissionEntry, Integer deduplicationId, Boolean autoUnicode, OffsetDateTime scheduleDate, String scheduleDescription) throws ApiException {
        ApiResponse<List<Message>> localVarResp = messagesPostWithHttpInfo(submissionEntry, deduplicationId, autoUnicode, scheduleDate, scheduleDescription);
        return localVarResp.getData();
    }

    /**
     * Send Messages
     * Send messages to one or more recipients.  You can post up to &#x60;30 000&#x60; messages in a batch.  But note that the &#x60;deduplication-id&#x60; is set per submission, so it is recommended that you use a smaller number, like &#x60;4000&#x60; per submission in order to make resubmissions on network failures more practical.  #### Repliability  When a sent message is _repliable_,  the BulkSMS system can process an SMS response sent by your recipient.  The message sent by your customer is called a mobile originating (MO) message and would be available under &#x60;RECEIVED&#x60; messages.  You can obtain a list of MOs using the [retrieve messages API call](#tag/Message%2Fpaths%2F~1messages%2Fget). In addition you can also get a list of the MOs that are associated with a specific sent message (see the [list related messages API call](#tag/Message%2Fpaths%2F~1messages~1%7Bid%7D~1relatedReceivedMessages%2Fget)).  If you use a specific _sender id_ in the &#x60;from&#x60; property of the send message, the message will not be repliable. If you want a message to be repliable, you need to specify &#x60;REPLIABLE&#x60; in the &#x60;from.type&#x60; property.  If you do not set the &#x60;from&#x60; property, your account settings are considered to determine whether or not the message is repliable. If the _default repliable_ setting on your account is _yes_ then the message will be repliable.  If this setting is _no_, the message will not be repliable.   #### Body templates  When sending a message you can use template fields to customise the message text.  *Field based templates* allow you to create a message with place-holders for custom fields.  Fields are identified by a zero based index; the first field is &#x60;F0&#x60;, the second is &#x60;F1&#x60; and so on.    For example, let&#39;s say you want to send a daily SMS message to all your clients that tell them what their current balance is.  The &#x60;body&#x60; of the message could look something like this   &#x60;&#x60;&#x60; Good morning {F0######}, your balance is {F1######} &#x60;&#x60;&#x60;  In this message, the first field, &#x60;F0&#x60;, is the name  of the customer and he second field &#x60;F1&#x60; is the balance for that customer.  The &#x60;#&#x60; used to specify the maximum length  of the field.  Note that the maximum length allowed for the value includes the space taken by the braces, template name and hash symbol.  For example, the value &#x60;{F0#}&#x60; specifies a maximum length of &#x60;5&#x60;.  If the data is longer than this length, the data will be truncated when the message body is constructed.  The data fields are provided in the property named &#x60;fields&#x60; in the &#x60;to&#x60; element.  Here is a complete example of how this might look  &#x60;&#x60;&#x60; {   \&quot;body\&quot;: \&quot;Good morning {F0######}, your balance is {F1######}\&quot;,   \&quot;to\&quot;:  [       {\&quot;address\&quot;: \&quot;27456789\&quot;,\&quot;fields\&quot;: [\&quot;Harry\&quot;, \&quot;$1345.23\&quot;] },       {\&quot;address\&quot;: \&quot;27456785\&quot;,\&quot;fields\&quot;: [\&quot;Sally\&quot;, \&quot;$2345.58\&quot;] }   ] } &#x60;&#x60;&#x60;  If you are sending to contacts (or to groups) in your phonebook, you can use the *Phonebook based templates*.  These are similar to the templates described above, but they have specific names. The template for the contact&#39;s first name is identified by &#x60;fn&#x60; and the template for the contact&#39;s surname is identified by &#x60;sn&#x60;.  Below in an example that will work if the numbers are registered in your phonebook.   &#x60;&#x60;&#x60; {   \&quot;body\&quot;: \&quot;Hi {fn######} {sn######}, have a great day!\&quot;,   \&quot;to\&quot;:  [       {\&quot;address\&quot;: \&quot;27456789\&quot; },       {\&quot;address\&quot;: \&quot;27456785\&quot; }   ] } &#x60;&#x60;&#x60; 
     * @param submissionEntry Contains details of the message (or messages) that you want to send.  One &#x60;SubmissionEntry&#x60; can produce many messages, and your request may contain multiple such entries.  (required)
     * @param deduplicationId Safeguards against the possibility of sending the same messages more than once.  If a communication failure occurs during a submission, you cannot be sure that the submission was processed; therefore you would have to submit it again. When you post the retry, you must use the &#x60;deduplication-id&#x60; of the original post. The BulkSMS system uses this ID to check that the request was not previously processed. (If it was previously processed, the submission will succeed, and the behaviour will be indistinguishable to you from a non-duplicated submission). The ID expires after about 12 hours.  (optional)
     * @param autoUnicode Specifies how to deal with message text that contains characters not present in the GSM 03.38 character set.  Messages that contain only GSM 03.38 characters are not affected by this setting.  If the value is &#x60;true&#x60; then a message containing non-GSM 03.38 characters will be transmitted as a Unicode SMS (which is most likely more costly).   Please note: when &#x60;auto-unicode&#x60; is &#x60;true&#x60; and the value of the &#x60;encoding&#x60; property is specified as &#x60;UNICODE&#x60;, the message will always be sent as &#x60;UNICODE&#x60;.  If the value is &#x60;false&#x60; and the &#x60;encoding&#x60; property is &#x60;TEXT&#x60; then non-GSM 03.38 characters will be replaced by the &#x60;?&#x60; character.  When using this setting on the API, you should take case to ensure that your message is _clean_.    Invisible unicode and unexpected characters could unintentionally convert an message to &#x60;UNICODE&#x60;.  A common mistake is to use the backtick character (\\&#x60;) which is unicode and will turn your &#x60;TEXT&#x60; message into a &#x60;UNICODE&#x60; message.  (optional, default to false)
     * @param scheduleDate Allows you to send a message in the future.  An example value is &#x60;2019-02-18T13:00:00+02:00&#x60;.  It encodes to &#x60;2019-02-18T13%3A00%3A00%2B02%3A00&#x60;. Credits are deducted from your account immediately. Once submitted, scheduled messages cannot be changed or cancelled. The date can be a maximum of two years in the future. If the value is in the past, the message will be sent immediately. The date format requires you to supply an offset from UTC. You can decide to use the offset of your timezone, or maybe the zone of the recipient&#39;s location is more appropriate. If the destination is a group, the group members are determined at the time that you submit the message; not the time the message is scheduled to be sent.  (optional)
     * @param scheduleDescription A note that is stored together with a scheduled submission, which could be used to more easily identify the scheduled submission at a later date.  The value of this field is ignored if the &#x60;schedule-date&#x60; is not provided. A value that is longer than 256 characters is truncated.  (optional)
     * @return ApiResponse&lt;List&lt;Message&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> An array of the messages that were created from the request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden.  Inspect the body of the response for further details - for example, you may have insufficient credits remaining </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Message>> messagesPostWithHttpInfo(List<SubmissionEntry> submissionEntry, Integer deduplicationId, Boolean autoUnicode, OffsetDateTime scheduleDate, String scheduleDescription) throws ApiException {
        okhttp3.Call localVarCall = messagesPostValidateBeforeCall(submissionEntry, deduplicationId, autoUnicode, scheduleDate, scheduleDescription, null);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Send Messages (asynchronously)
     * Send messages to one or more recipients.  You can post up to &#x60;30 000&#x60; messages in a batch.  But note that the &#x60;deduplication-id&#x60; is set per submission, so it is recommended that you use a smaller number, like &#x60;4000&#x60; per submission in order to make resubmissions on network failures more practical.  #### Repliability  When a sent message is _repliable_,  the BulkSMS system can process an SMS response sent by your recipient.  The message sent by your customer is called a mobile originating (MO) message and would be available under &#x60;RECEIVED&#x60; messages.  You can obtain a list of MOs using the [retrieve messages API call](#tag/Message%2Fpaths%2F~1messages%2Fget). In addition you can also get a list of the MOs that are associated with a specific sent message (see the [list related messages API call](#tag/Message%2Fpaths%2F~1messages~1%7Bid%7D~1relatedReceivedMessages%2Fget)).  If you use a specific _sender id_ in the &#x60;from&#x60; property of the send message, the message will not be repliable. If you want a message to be repliable, you need to specify &#x60;REPLIABLE&#x60; in the &#x60;from.type&#x60; property.  If you do not set the &#x60;from&#x60; property, your account settings are considered to determine whether or not the message is repliable. If the _default repliable_ setting on your account is _yes_ then the message will be repliable.  If this setting is _no_, the message will not be repliable.   #### Body templates  When sending a message you can use template fields to customise the message text.  *Field based templates* allow you to create a message with place-holders for custom fields.  Fields are identified by a zero based index; the first field is &#x60;F0&#x60;, the second is &#x60;F1&#x60; and so on.    For example, let&#39;s say you want to send a daily SMS message to all your clients that tell them what their current balance is.  The &#x60;body&#x60; of the message could look something like this   &#x60;&#x60;&#x60; Good morning {F0######}, your balance is {F1######} &#x60;&#x60;&#x60;  In this message, the first field, &#x60;F0&#x60;, is the name  of the customer and he second field &#x60;F1&#x60; is the balance for that customer.  The &#x60;#&#x60; used to specify the maximum length  of the field.  Note that the maximum length allowed for the value includes the space taken by the braces, template name and hash symbol.  For example, the value &#x60;{F0#}&#x60; specifies a maximum length of &#x60;5&#x60;.  If the data is longer than this length, the data will be truncated when the message body is constructed.  The data fields are provided in the property named &#x60;fields&#x60; in the &#x60;to&#x60; element.  Here is a complete example of how this might look  &#x60;&#x60;&#x60; {   \&quot;body\&quot;: \&quot;Good morning {F0######}, your balance is {F1######}\&quot;,   \&quot;to\&quot;:  [       {\&quot;address\&quot;: \&quot;27456789\&quot;,\&quot;fields\&quot;: [\&quot;Harry\&quot;, \&quot;$1345.23\&quot;] },       {\&quot;address\&quot;: \&quot;27456785\&quot;,\&quot;fields\&quot;: [\&quot;Sally\&quot;, \&quot;$2345.58\&quot;] }   ] } &#x60;&#x60;&#x60;  If you are sending to contacts (or to groups) in your phonebook, you can use the *Phonebook based templates*.  These are similar to the templates described above, but they have specific names. The template for the contact&#39;s first name is identified by &#x60;fn&#x60; and the template for the contact&#39;s surname is identified by &#x60;sn&#x60;.  Below in an example that will work if the numbers are registered in your phonebook.   &#x60;&#x60;&#x60; {   \&quot;body\&quot;: \&quot;Hi {fn######} {sn######}, have a great day!\&quot;,   \&quot;to\&quot;:  [       {\&quot;address\&quot;: \&quot;27456789\&quot; },       {\&quot;address\&quot;: \&quot;27456785\&quot; }   ] } &#x60;&#x60;&#x60; 
     * @param submissionEntry Contains details of the message (or messages) that you want to send.  One &#x60;SubmissionEntry&#x60; can produce many messages, and your request may contain multiple such entries.  (required)
     * @param deduplicationId Safeguards against the possibility of sending the same messages more than once.  If a communication failure occurs during a submission, you cannot be sure that the submission was processed; therefore you would have to submit it again. When you post the retry, you must use the &#x60;deduplication-id&#x60; of the original post. The BulkSMS system uses this ID to check that the request was not previously processed. (If it was previously processed, the submission will succeed, and the behaviour will be indistinguishable to you from a non-duplicated submission). The ID expires after about 12 hours.  (optional)
     * @param autoUnicode Specifies how to deal with message text that contains characters not present in the GSM 03.38 character set.  Messages that contain only GSM 03.38 characters are not affected by this setting.  If the value is &#x60;true&#x60; then a message containing non-GSM 03.38 characters will be transmitted as a Unicode SMS (which is most likely more costly).   Please note: when &#x60;auto-unicode&#x60; is &#x60;true&#x60; and the value of the &#x60;encoding&#x60; property is specified as &#x60;UNICODE&#x60;, the message will always be sent as &#x60;UNICODE&#x60;.  If the value is &#x60;false&#x60; and the &#x60;encoding&#x60; property is &#x60;TEXT&#x60; then non-GSM 03.38 characters will be replaced by the &#x60;?&#x60; character.  When using this setting on the API, you should take case to ensure that your message is _clean_.    Invisible unicode and unexpected characters could unintentionally convert an message to &#x60;UNICODE&#x60;.  A common mistake is to use the backtick character (\\&#x60;) which is unicode and will turn your &#x60;TEXT&#x60; message into a &#x60;UNICODE&#x60; message.  (optional, default to false)
     * @param scheduleDate Allows you to send a message in the future.  An example value is &#x60;2019-02-18T13:00:00+02:00&#x60;.  It encodes to &#x60;2019-02-18T13%3A00%3A00%2B02%3A00&#x60;. Credits are deducted from your account immediately. Once submitted, scheduled messages cannot be changed or cancelled. The date can be a maximum of two years in the future. If the value is in the past, the message will be sent immediately. The date format requires you to supply an offset from UTC. You can decide to use the offset of your timezone, or maybe the zone of the recipient&#39;s location is more appropriate. If the destination is a group, the group members are determined at the time that you submit the message; not the time the message is scheduled to be sent.  (optional)
     * @param scheduleDescription A note that is stored together with a scheduled submission, which could be used to more easily identify the scheduled submission at a later date.  The value of this field is ignored if the &#x60;schedule-date&#x60; is not provided. A value that is longer than 256 characters is truncated.  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> An array of the messages that were created from the request </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden.  Inspect the body of the response for further details - for example, you may have insufficient credits remaining </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesPostAsync(List<SubmissionEntry> submissionEntry, Integer deduplicationId, Boolean autoUnicode, OffsetDateTime scheduleDate, String scheduleDescription, final ApiCallback<List<Message>> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesPostValidateBeforeCall(submissionEntry, deduplicationId, autoUnicode, scheduleDate, scheduleDescription, _callback);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for messagesSendGet
     * @param to The phone number of the recipient. (required)
     * @param body The text you want to send. (required)
     * @param deduplicationId Refer to the &#x60;deduplication-id&#x60; parameter. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> An array of messages </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden.  Inspect the body of the response for further details - for example, you may have insufficient credits remaining </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesSendGetCall(String to, String body, Integer deduplicationId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/send";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (to != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("to", to));
        }

        if (body != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("body", body));
        }

        if (deduplicationId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deduplication-id", deduplicationId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call messagesSendGetValidateBeforeCall(String to, String body, Integer deduplicationId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'to' is set
        if (to == null) {
            throw new ApiException("Missing the required parameter 'to' when calling messagesSendGet(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling messagesSendGet(Async)");
        }

        return messagesSendGetCall(to, body, deduplicationId, _callback);

    }

    /**
     * Send message by simple GET or POST
     * A really simple interface for people who require a GET mechanism to submit a single message.  The URI is interpreted as UTF-8. HTTP Basic Auth is used for authentication.  __Note__ BulkSMS recommends that you use the more flexible Send Messages Operation when submitting SMS messages from your application.  Here is an example of a GET &#x60;&#x60;&#x60;http GET /v1/messages/send?to&#x3D;%2b270000000&amp;body&#x3D;Hello%20World &#x60;&#x60;&#x60;  You can also use the same parameters to POST form encoded fields to &#x60;/messages&#x60;. Here is an example of a POST &#x60;&#x60;&#x60;http POST /v1/messages Content-Type: application/x-www-form-urlencoded  to&#x3D;%2b27000000000&amp;body&#x3D;Hello+World &#x60;&#x60;&#x60; 
     * @param to The phone number of the recipient. (required)
     * @param body The text you want to send. (required)
     * @param deduplicationId Refer to the &#x60;deduplication-id&#x60; parameter. (optional)
     * @return List&lt;Message&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> An array of messages </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden.  Inspect the body of the response for further details - for example, you may have insufficient credits remaining </td><td>  -  </td></tr>
     </table>
     */
    public List<Message> messagesSendGet(String to, String body, Integer deduplicationId) throws ApiException {
        ApiResponse<List<Message>> localVarResp = messagesSendGetWithHttpInfo(to, body, deduplicationId);
        return localVarResp.getData();
    }

    /**
     * Send message by simple GET or POST
     * A really simple interface for people who require a GET mechanism to submit a single message.  The URI is interpreted as UTF-8. HTTP Basic Auth is used for authentication.  __Note__ BulkSMS recommends that you use the more flexible Send Messages Operation when submitting SMS messages from your application.  Here is an example of a GET &#x60;&#x60;&#x60;http GET /v1/messages/send?to&#x3D;%2b270000000&amp;body&#x3D;Hello%20World &#x60;&#x60;&#x60;  You can also use the same parameters to POST form encoded fields to &#x60;/messages&#x60;. Here is an example of a POST &#x60;&#x60;&#x60;http POST /v1/messages Content-Type: application/x-www-form-urlencoded  to&#x3D;%2b27000000000&amp;body&#x3D;Hello+World &#x60;&#x60;&#x60; 
     * @param to The phone number of the recipient. (required)
     * @param body The text you want to send. (required)
     * @param deduplicationId Refer to the &#x60;deduplication-id&#x60; parameter. (optional)
     * @return ApiResponse&lt;List&lt;Message&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> An array of messages </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden.  Inspect the body of the response for further details - for example, you may have insufficient credits remaining </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Message>> messagesSendGetWithHttpInfo(String to, String body, Integer deduplicationId) throws ApiException {
        okhttp3.Call localVarCall = messagesSendGetValidateBeforeCall(to, body, deduplicationId, null);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Send message by simple GET or POST (asynchronously)
     * A really simple interface for people who require a GET mechanism to submit a single message.  The URI is interpreted as UTF-8. HTTP Basic Auth is used for authentication.  __Note__ BulkSMS recommends that you use the more flexible Send Messages Operation when submitting SMS messages from your application.  Here is an example of a GET &#x60;&#x60;&#x60;http GET /v1/messages/send?to&#x3D;%2b270000000&amp;body&#x3D;Hello%20World &#x60;&#x60;&#x60;  You can also use the same parameters to POST form encoded fields to &#x60;/messages&#x60;. Here is an example of a POST &#x60;&#x60;&#x60;http POST /v1/messages Content-Type: application/x-www-form-urlencoded  to&#x3D;%2b27000000000&amp;body&#x3D;Hello+World &#x60;&#x60;&#x60; 
     * @param to The phone number of the recipient. (required)
     * @param body The text you want to send. (required)
     * @param deduplicationId Refer to the &#x60;deduplication-id&#x60; parameter. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> An array of messages </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request. The content or structure of your submission, or a parameter, was found to be invalid. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden.  Inspect the body of the response for further details - for example, you may have insufficient credits remaining </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call messagesSendGetAsync(String to, String body, Integer deduplicationId, final ApiCallback<List<Message>> _callback) throws ApiException {

        okhttp3.Call localVarCall = messagesSendGetValidateBeforeCall(to, body, deduplicationId, _callback);
        Type localVarReturnType = new TypeToken<List<Message>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
