# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.message_status import MessageStatus
from openapi_server.models.message_submission import MessageSubmission
from openapi_server import util


class Message(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, body: object=None, credit_cost: float=None, encoding: str=None, _from: str=None, id: str=None, message_class: int=None, number_of_parts: int=None, protocol_id: int=None, related_sent_message_id: str=None, status: MessageStatus=None, submission: MessageSubmission=None, to: str=None, type: str=None, user_supplied_id: str=None):
        """Message - a model defined in OpenAPI

        :param body: The body of this Message.
        :param credit_cost: The credit_cost of this Message.
        :param encoding: The encoding of this Message.
        :param _from: The _from of this Message.
        :param id: The id of this Message.
        :param message_class: The message_class of this Message.
        :param number_of_parts: The number_of_parts of this Message.
        :param protocol_id: The protocol_id of this Message.
        :param related_sent_message_id: The related_sent_message_id of this Message.
        :param status: The status of this Message.
        :param submission: The submission of this Message.
        :param to: The to of this Message.
        :param type: The type of this Message.
        :param user_supplied_id: The user_supplied_id of this Message.
        """
        self.openapi_types = {
            'body': object,
            'credit_cost': float,
            'encoding': str,
            '_from': str,
            'id': str,
            'message_class': int,
            'number_of_parts': int,
            'protocol_id': int,
            'related_sent_message_id': str,
            'status': MessageStatus,
            'submission': MessageSubmission,
            'to': str,
            'type': str,
            'user_supplied_id': str
        }

        self.attribute_map = {
            'body': 'body',
            'credit_cost': 'creditCost',
            'encoding': 'encoding',
            '_from': 'from',
            'id': 'id',
            'message_class': 'messageClass',
            'number_of_parts': 'numberOfParts',
            'protocol_id': 'protocolId',
            'related_sent_message_id': 'relatedSentMessageId',
            'status': 'status',
            'submission': 'submission',
            'to': 'to',
            'type': 'type',
            'user_supplied_id': 'userSuppliedId'
        }

        self._body = body
        self._credit_cost = credit_cost
        self._encoding = encoding
        self.__from = _from
        self._id = id
        self._message_class = message_class
        self._number_of_parts = number_of_parts
        self._protocol_id = protocol_id
        self._related_sent_message_id = related_sent_message_id
        self._status = status
        self._submission = submission
        self._to = to
        self._type = type
        self._user_supplied_id = user_supplied_id

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Message':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Message of this Message.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def body(self):
        """Gets the body of this Message.

        The content of the message

        :return: The body of this Message.
        :rtype: object
        """
        return self._body

    @body.setter
    def body(self, body):
        """Sets the body of this Message.

        The content of the message

        :param body: The body of this Message.
        :type body: object
        """
        if body is None:
            raise ValueError("Invalid value for `body`, must not be `None`")

        self._body = body

    @property
    def credit_cost(self):
        """Gets the credit_cost of this Message.

        The cost of the message (in credits).   Note that this field does not have a value in the submission response.

        :return: The credit_cost of this Message.
        :rtype: float
        """
        return self._credit_cost

    @credit_cost.setter
    def credit_cost(self, credit_cost):
        """Sets the credit_cost of this Message.

        The cost of the message (in credits).   Note that this field does not have a value in the submission response.

        :param credit_cost: The credit_cost of this Message.
        :type credit_cost: float
        """

        self._credit_cost = credit_cost

    @property
    def encoding(self):
        """Gets the encoding of this Message.

        The type of the content.  See the `encoding` field for more information.

        :return: The encoding of this Message.
        :rtype: str
        """
        return self._encoding

    @encoding.setter
    def encoding(self, encoding):
        """Sets the encoding of this Message.

        The type of the content.  See the `encoding` field for more information.

        :param encoding: The encoding of this Message.
        :type encoding: str
        """
        allowed_values = ["TEXT", "UNICODE", "BINARY"]  # noqa: E501
        if encoding not in allowed_values:
            raise ValueError(
                "Invalid value for `encoding` ({0}), must be one of {1}"
                .format(encoding, allowed_values)
            )

        self._encoding = encoding

    @property
    def _from(self):
        """Gets the _from of this Message.

        The address part of the sender id

        :return: The _from of this Message.
        :rtype: str
        """
        return self.__from

    @_from.setter
    def _from(self, _from):
        """Sets the _from of this Message.

        The address part of the sender id

        :param _from: The _from of this Message.
        :type _from: str
        """

        self.__from = _from

    @property
    def id(self):
        """Gets the id of this Message.

        A unique identifier that is assigned when the message is created.

        :return: The id of this Message.
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this Message.

        A unique identifier that is assigned when the message is created.

        :param id: The id of this Message.
        :type id: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")

        self._id = id

    @property
    def message_class(self):
        """Gets the message_class of this Message.

        See the `messageClass` field for more information.

        :return: The message_class of this Message.
        :rtype: int
        """
        return self._message_class

    @message_class.setter
    def message_class(self, message_class):
        """Sets the message_class of this Message.

        See the `messageClass` field for more information.

        :param message_class: The message_class of this Message.
        :type message_class: int
        """

        self._message_class = message_class

    @property
    def number_of_parts(self):
        """Gets the number_of_parts of this Message.

        The number of parts.  If this is a concatenated message, the number of parts will be more than 1.  Note that this field does not have a value in the submission response.

        :return: The number_of_parts of this Message.
        :rtype: int
        """
        return self._number_of_parts

    @number_of_parts.setter
    def number_of_parts(self, number_of_parts):
        """Sets the number_of_parts of this Message.

        The number of parts.  If this is a concatenated message, the number of parts will be more than 1.  Note that this field does not have a value in the submission response.

        :param number_of_parts: The number_of_parts of this Message.
        :type number_of_parts: int
        """

        self._number_of_parts = number_of_parts

    @property
    def protocol_id(self):
        """Gets the protocol_id of this Message.

        See the `protocolId` field for more information.

        :return: The protocol_id of this Message.
        :rtype: int
        """
        return self._protocol_id

    @protocol_id.setter
    def protocol_id(self, protocol_id):
        """Sets the protocol_id of this Message.

        See the `protocolId` field for more information.

        :param protocol_id: The protocol_id of this Message.
        :type protocol_id: int
        """

        self._protocol_id = protocol_id

    @property
    def related_sent_message_id(self):
        """Gets the related_sent_message_id of this Message.

        This field has a value only if the type is RECEIVED. With SMS messages, it is not possible to link a reply directly with a specific sent message.  However, if you specified `REPLIABLE` in the `from` property, BulkSMS will link any reply to the most recent message sent to a given phone number.  The `relatedSentMessageId` property keeps the information about this link.  You can use this property to derive an implicit conversation from a set of messages.   - If a received reply message has a `relatedSentMessageId`, you can use it to retrieve the last message that was sent before the reply was received.   - If you have the `id` of the sent message and you want all the received messages that relate to it, you can use the List Related Messages Operation. 

        :return: The related_sent_message_id of this Message.
        :rtype: str
        """
        return self._related_sent_message_id

    @related_sent_message_id.setter
    def related_sent_message_id(self, related_sent_message_id):
        """Sets the related_sent_message_id of this Message.

        This field has a value only if the type is RECEIVED. With SMS messages, it is not possible to link a reply directly with a specific sent message.  However, if you specified `REPLIABLE` in the `from` property, BulkSMS will link any reply to the most recent message sent to a given phone number.  The `relatedSentMessageId` property keeps the information about this link.  You can use this property to derive an implicit conversation from a set of messages.   - If a received reply message has a `relatedSentMessageId`, you can use it to retrieve the last message that was sent before the reply was received.   - If you have the `id` of the sent message and you want all the received messages that relate to it, you can use the List Related Messages Operation. 

        :param related_sent_message_id: The related_sent_message_id of this Message.
        :type related_sent_message_id: str
        """

        self._related_sent_message_id = related_sent_message_id

    @property
    def status(self):
        """Gets the status of this Message.


        :return: The status of this Message.
        :rtype: MessageStatus
        """
        return self._status

    @status.setter
    def status(self, status):
        """Sets the status of this Message.


        :param status: The status of this Message.
        :type status: MessageStatus
        """
        if status is None:
            raise ValueError("Invalid value for `status`, must not be `None`")

        self._status = status

    @property
    def submission(self):
        """Gets the submission of this Message.


        :return: The submission of this Message.
        :rtype: MessageSubmission
        """
        return self._submission

    @submission.setter
    def submission(self, submission):
        """Sets the submission of this Message.


        :param submission: The submission of this Message.
        :type submission: MessageSubmission
        """

        self._submission = submission

    @property
    def to(self):
        """Gets the to of this Message.

        The phone number of the recipient

        :return: The to of this Message.
        :rtype: str
        """
        return self._to

    @to.setter
    def to(self, to):
        """Sets the to of this Message.

        The phone number of the recipient

        :param to: The to of this Message.
        :type to: str
        """
        if to is None:
            raise ValueError("Invalid value for `to`, must not be `None`")

        self._to = to

    @property
    def type(self):
        """Gets the type of this Message.

        The message direction

        :return: The type of this Message.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this Message.

        The message direction

        :param type: The type of this Message.
        :type type: str
        """
        allowed_values = ["SENT", "RECEIVED"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def user_supplied_id(self):
        """Gets the user_supplied_id of this Message.

        This is the value you supplied in the `userSuppliedId` field. Has a value only if the `type` is SENT. 

        :return: The user_supplied_id of this Message.
        :rtype: str
        """
        return self._user_supplied_id

    @user_supplied_id.setter
    def user_supplied_id(self, user_supplied_id):
        """Sets the user_supplied_id of this Message.

        This is the value you supplied in the `userSuppliedId` field. Has a value only if the `type` is SENT. 

        :param user_supplied_id: The user_supplied_id of this Message.
        :type user_supplied_id: str
        """

        self._user_supplied_id = user_supplied_id
