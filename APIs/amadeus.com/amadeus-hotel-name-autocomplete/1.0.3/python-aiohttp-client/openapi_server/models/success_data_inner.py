# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.success_data_inner_address import SuccessDataInnerAddress
from openapi_server.models.success_data_inner_geo_code import SuccessDataInnerGeoCode
import re
from openapi_server import util


class SuccessDataInner(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, address: SuccessDataInnerAddress=None, geo_code: SuccessDataInnerGeoCode=None, hotel_ids: list[str]=None, iata_code: str=None, id: float=None, name: str=None, relevance: int=None, sub_type: str=None, type: str=None):
        """SuccessDataInner - a model defined in OpenAPI

        :param address: The address of this SuccessDataInner.
        :param geo_code: The geo_code of this SuccessDataInner.
        :param hotel_ids: The hotel_ids of this SuccessDataInner.
        :param iata_code: The iata_code of this SuccessDataInner.
        :param id: The id of this SuccessDataInner.
        :param name: The name of this SuccessDataInner.
        :param relevance: The relevance of this SuccessDataInner.
        :param sub_type: The sub_type of this SuccessDataInner.
        :param type: The type of this SuccessDataInner.
        """
        self.openapi_types = {
            'address': SuccessDataInnerAddress,
            'geo_code': SuccessDataInnerGeoCode,
            'hotel_ids': list[str],
            'iata_code': str,
            'id': float,
            'name': str,
            'relevance': int,
            'sub_type': str,
            'type': str
        }

        self.attribute_map = {
            'address': 'address',
            'geo_code': 'geoCode',
            'hotel_ids': 'hotelIds',
            'iata_code': 'iataCode',
            'id': 'id',
            'name': 'name',
            'relevance': 'relevance',
            'sub_type': 'subType',
            'type': 'type'
        }

        self._address = address
        self._geo_code = geo_code
        self._hotel_ids = hotel_ids
        self._iata_code = iata_code
        self._id = id
        self._name = name
        self._relevance = relevance
        self._sub_type = sub_type
        self._type = type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'SuccessDataInner':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Success_data_inner of this SuccessDataInner.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def address(self):
        """Gets the address of this SuccessDataInner.


        :return: The address of this SuccessDataInner.
        :rtype: SuccessDataInnerAddress
        """
        return self._address

    @address.setter
    def address(self, address):
        """Sets the address of this SuccessDataInner.


        :param address: The address of this SuccessDataInner.
        :type address: SuccessDataInnerAddress
        """

        self._address = address

    @property
    def geo_code(self):
        """Gets the geo_code of this SuccessDataInner.


        :return: The geo_code of this SuccessDataInner.
        :rtype: SuccessDataInnerGeoCode
        """
        return self._geo_code

    @geo_code.setter
    def geo_code(self, geo_code):
        """Sets the geo_code of this SuccessDataInner.


        :param geo_code: The geo_code of this SuccessDataInner.
        :type geo_code: SuccessDataInnerGeoCode
        """

        self._geo_code = geo_code

    @property
    def hotel_ids(self):
        """Gets the hotel_ids of this SuccessDataInner.

        HotelIDs associated with the location only if it's a hotel. For leisure property dupes ID are listed as well. 

        :return: The hotel_ids of this SuccessDataInner.
        :rtype: list[str]
        """
        return self._hotel_ids

    @hotel_ids.setter
    def hotel_ids(self, hotel_ids):
        """Sets the hotel_ids of this SuccessDataInner.

        HotelIDs associated with the location only if it's a hotel. For leisure property dupes ID are listed as well. 

        :param hotel_ids: The hotel_ids of this SuccessDataInner.
        :type hotel_ids: list[str]
        """
        if hotel_ids is None:
            raise ValueError("Invalid value for `hotel_ids`, must not be `None`")
        if hotel_ids is not None and len(hotel_ids) > 10:
            raise ValueError("Invalid value for `hotel_ids`, number of items must be less than or equal to `10`")
        if hotel_ids is not None and len(hotel_ids) < 1:
            raise ValueError("Invalid value for `hotel_ids`, number of items must be greater than or equal to `1`")

        self._hotel_ids = hotel_ids

    @property
    def iata_code(self):
        """Gets the iata_code of this SuccessDataInner.

        [IATA codes](http://www.iata.org/publications/Pages/code-search.aspx) associated with the location.

        :return: The iata_code of this SuccessDataInner.
        :rtype: str
        """
        return self._iata_code

    @iata_code.setter
    def iata_code(self, iata_code):
        """Sets the iata_code of this SuccessDataInner.

        [IATA codes](http://www.iata.org/publications/Pages/code-search.aspx) associated with the location.

        :param iata_code: The iata_code of this SuccessDataInner.
        :type iata_code: str
        """
        if iata_code is None:
            raise ValueError("Invalid value for `iata_code`, must not be `None`")
        if iata_code is not None and len(iata_code) > 3:
            raise ValueError("Invalid value for `iata_code`, length must be less than or equal to `3`")
        if iata_code is not None and len(iata_code) < 3:
            raise ValueError("Invalid value for `iata_code`, length must be greater than or equal to `3`")
        if iata_code is not None and not re.search(r'^[A-Z]+', iata_code):
            raise ValueError("Invalid value for `iata_code`, must be a follow pattern or equal to `/^[A-Z]+/`")

        self._iata_code = iata_code

    @property
    def id(self):
        """Gets the id of this SuccessDataInner.

        ID of the resource.

        :return: The id of this SuccessDataInner.
        :rtype: float
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this SuccessDataInner.

        ID of the resource.

        :param id: The id of this SuccessDataInner.
        :type id: float
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")
        if id is not None and id > 1E+1:
            raise ValueError("Invalid value for `id`, must be a value less than or equal to `1E+1`")
        if id is not None and id < 1:
            raise ValueError("Invalid value for `id`, must be a value greater than or equal to `1`")

        self._id = id

    @property
    def name(self):
        """Gets the name of this SuccessDataInner.

        Name of the location (Hotel Name)

        :return: The name of this SuccessDataInner.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this SuccessDataInner.

        Name of the location (Hotel Name)

        :param name: The name of this SuccessDataInner.
        :type name: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        if name is not None and len(name) > 80:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `80`")
        if name is not None and len(name) < 1:
            raise ValueError("Invalid value for `name`, length must be greater than or equal to `1`")
        if name is not None and not re.search(r'^[A-Za-z0-9 - * \'.]+', name):
            raise ValueError("Invalid value for `name`, must be a follow pattern or equal to `/^[A-Za-z0-9 - * '.]+/`")

        self._name = name

    @property
    def relevance(self):
        """Gets the relevance of this SuccessDataInner.

        A no. between 1-100. The higher the number better is the relevant search for that location.

        :return: The relevance of this SuccessDataInner.
        :rtype: int
        """
        return self._relevance

    @relevance.setter
    def relevance(self, relevance):
        """Sets the relevance of this SuccessDataInner.

        A no. between 1-100. The higher the number better is the relevant search for that location.

        :param relevance: The relevance of this SuccessDataInner.
        :type relevance: int
        """

        self._relevance = relevance

    @property
    def sub_type(self):
        """Gets the sub_type of this SuccessDataInner.

        The category of the location or Point of reference (HOTEL_LEISURE,HOTEL_GDS).

        :return: The sub_type of this SuccessDataInner.
        :rtype: str
        """
        return self._sub_type

    @sub_type.setter
    def sub_type(self, sub_type):
        """Sets the sub_type of this SuccessDataInner.

        The category of the location or Point of reference (HOTEL_LEISURE,HOTEL_GDS).

        :param sub_type: The sub_type of this SuccessDataInner.
        :type sub_type: str
        """
        allowed_values = ["HOTEL_GDS", "HOTEL_LEISURE"]  # noqa: E501
        if sub_type not in allowed_values:
            raise ValueError(
                "Invalid value for `sub_type` ({0}), must be one of {1}"
                .format(sub_type, allowed_values)
            )

        self._sub_type = sub_type

    @property
    def type(self):
        """Gets the type of this SuccessDataInner.

        Type of resource or the resource name.

        :return: The type of this SuccessDataInner.
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this SuccessDataInner.

        Type of resource or the resource name.

        :param type: The type of this SuccessDataInner.
        :type type: str
        """
        if type is None:
            raise ValueError("Invalid value for `type`, must not be `None`")

        self._type = type
