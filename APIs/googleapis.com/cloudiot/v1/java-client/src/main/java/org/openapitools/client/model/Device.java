/*
 * Cloud IoT API
 * Registers and manages IoT (Internet of Things) devices that connect to the Google Cloud Platform. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DeviceConfig;
import org.openapitools.client.model.DeviceCredential;
import org.openapitools.client.model.DeviceState;
import org.openapitools.client.model.GatewayConfig;
import org.openapitools.client.model.Status;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The device resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:25.758673-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Device {
  public static final String SERIALIZED_NAME_BLOCKED = "blocked";
  @SerializedName(SERIALIZED_NAME_BLOCKED)
  private Boolean blocked;

  public static final String SERIALIZED_NAME_CONFIG = "config";
  @SerializedName(SERIALIZED_NAME_CONFIG)
  private DeviceConfig config;

  public static final String SERIALIZED_NAME_CREDENTIALS = "credentials";
  @SerializedName(SERIALIZED_NAME_CREDENTIALS)
  private List<DeviceCredential> credentials = new ArrayList<>();

  public static final String SERIALIZED_NAME_GATEWAY_CONFIG = "gatewayConfig";
  @SerializedName(SERIALIZED_NAME_GATEWAY_CONFIG)
  private GatewayConfig gatewayConfig;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_LAST_CONFIG_ACK_TIME = "lastConfigAckTime";
  @SerializedName(SERIALIZED_NAME_LAST_CONFIG_ACK_TIME)
  private String lastConfigAckTime;

  public static final String SERIALIZED_NAME_LAST_CONFIG_SEND_TIME = "lastConfigSendTime";
  @SerializedName(SERIALIZED_NAME_LAST_CONFIG_SEND_TIME)
  private String lastConfigSendTime;

  public static final String SERIALIZED_NAME_LAST_ERROR_STATUS = "lastErrorStatus";
  @SerializedName(SERIALIZED_NAME_LAST_ERROR_STATUS)
  private Status lastErrorStatus;

  public static final String SERIALIZED_NAME_LAST_ERROR_TIME = "lastErrorTime";
  @SerializedName(SERIALIZED_NAME_LAST_ERROR_TIME)
  private String lastErrorTime;

  public static final String SERIALIZED_NAME_LAST_EVENT_TIME = "lastEventTime";
  @SerializedName(SERIALIZED_NAME_LAST_EVENT_TIME)
  private String lastEventTime;

  public static final String SERIALIZED_NAME_LAST_HEARTBEAT_TIME = "lastHeartbeatTime";
  @SerializedName(SERIALIZED_NAME_LAST_HEARTBEAT_TIME)
  private String lastHeartbeatTime;

  public static final String SERIALIZED_NAME_LAST_STATE_TIME = "lastStateTime";
  @SerializedName(SERIALIZED_NAME_LAST_STATE_TIME)
  private String lastStateTime;

  /**
   * **Beta Feature** The logging verbosity for device activity. If unspecified, DeviceRegistry.log_level will be used.
   */
  @JsonAdapter(LogLevelEnum.Adapter.class)
  public enum LogLevelEnum {
    LOG_LEVEL_UNSPECIFIED("LOG_LEVEL_UNSPECIFIED"),
    
    NONE("NONE"),
    
    ERROR("ERROR"),
    
    INFO("INFO"),
    
    DEBUG("DEBUG");

    private String value;

    LogLevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LogLevelEnum fromValue(String value) {
      for (LogLevelEnum b : LogLevelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LogLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LogLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LogLevelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LogLevelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LogLevelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LOG_LEVEL = "logLevel";
  @SerializedName(SERIALIZED_NAME_LOG_LEVEL)
  private LogLevelEnum logLevel;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private Map<String, String> metadata = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NUM_ID = "numId";
  @SerializedName(SERIALIZED_NAME_NUM_ID)
  private String numId;

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private DeviceState state;

  public Device() {
  }

  public Device blocked(Boolean blocked) {
    this.blocked = blocked;
    return this;
  }

  /**
   * If a device is blocked, connections or requests from this device will fail. Can be used to temporarily prevent the device from connecting if, for example, the sensor is generating bad data and needs maintenance.
   * @return blocked
   */
  @javax.annotation.Nullable
  public Boolean getBlocked() {
    return blocked;
  }

  public void setBlocked(Boolean blocked) {
    this.blocked = blocked;
  }


  public Device config(DeviceConfig config) {
    this.config = config;
    return this;
  }

  /**
   * Get config
   * @return config
   */
  @javax.annotation.Nullable
  public DeviceConfig getConfig() {
    return config;
  }

  public void setConfig(DeviceConfig config) {
    this.config = config;
  }


  public Device credentials(List<DeviceCredential> credentials) {
    this.credentials = credentials;
    return this;
  }

  public Device addCredentialsItem(DeviceCredential credentialsItem) {
    if (this.credentials == null) {
      this.credentials = new ArrayList<>();
    }
    this.credentials.add(credentialsItem);
    return this;
  }

  /**
   * The credentials used to authenticate this device. To allow credential rotation without interruption, multiple device credentials can be bound to this device. No more than 3 credentials can be bound to a single device at a time. When new credentials are added to a device, they are verified against the registry credentials. For details, see the description of the &#x60;DeviceRegistry.credentials&#x60; field.
   * @return credentials
   */
  @javax.annotation.Nullable
  public List<DeviceCredential> getCredentials() {
    return credentials;
  }

  public void setCredentials(List<DeviceCredential> credentials) {
    this.credentials = credentials;
  }


  public Device gatewayConfig(GatewayConfig gatewayConfig) {
    this.gatewayConfig = gatewayConfig;
    return this;
  }

  /**
   * Get gatewayConfig
   * @return gatewayConfig
   */
  @javax.annotation.Nullable
  public GatewayConfig getGatewayConfig() {
    return gatewayConfig;
  }

  public void setGatewayConfig(GatewayConfig gatewayConfig) {
    this.gatewayConfig = gatewayConfig;
  }


  public Device id(String id) {
    this.id = id;
    return this;
  }

  /**
   * The user-defined device identifier. The device ID must be unique within a device registry.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public Device lastConfigAckTime(String lastConfigAckTime) {
    this.lastConfigAckTime = lastConfigAckTime;
    return this;
  }

  /**
   * [Output only] The last time a cloud-to-device config version acknowledgment was received from the device. This field is only for configurations sent through MQTT.
   * @return lastConfigAckTime
   */
  @javax.annotation.Nullable
  public String getLastConfigAckTime() {
    return lastConfigAckTime;
  }

  public void setLastConfigAckTime(String lastConfigAckTime) {
    this.lastConfigAckTime = lastConfigAckTime;
  }


  public Device lastConfigSendTime(String lastConfigSendTime) {
    this.lastConfigSendTime = lastConfigSendTime;
    return this;
  }

  /**
   * [Output only] The last time a cloud-to-device config version was sent to the device.
   * @return lastConfigSendTime
   */
  @javax.annotation.Nullable
  public String getLastConfigSendTime() {
    return lastConfigSendTime;
  }

  public void setLastConfigSendTime(String lastConfigSendTime) {
    this.lastConfigSendTime = lastConfigSendTime;
  }


  public Device lastErrorStatus(Status lastErrorStatus) {
    this.lastErrorStatus = lastErrorStatus;
    return this;
  }

  /**
   * Get lastErrorStatus
   * @return lastErrorStatus
   */
  @javax.annotation.Nullable
  public Status getLastErrorStatus() {
    return lastErrorStatus;
  }

  public void setLastErrorStatus(Status lastErrorStatus) {
    this.lastErrorStatus = lastErrorStatus;
  }


  public Device lastErrorTime(String lastErrorTime) {
    this.lastErrorTime = lastErrorTime;
    return this;
  }

  /**
   * [Output only] The time the most recent error occurred, such as a failure to publish to Cloud Pub/Sub. This field is the timestamp of &#39;last_error_status&#39;.
   * @return lastErrorTime
   */
  @javax.annotation.Nullable
  public String getLastErrorTime() {
    return lastErrorTime;
  }

  public void setLastErrorTime(String lastErrorTime) {
    this.lastErrorTime = lastErrorTime;
  }


  public Device lastEventTime(String lastEventTime) {
    this.lastEventTime = lastEventTime;
    return this;
  }

  /**
   * [Output only] The last time a telemetry event was received. Timestamps are periodically collected and written to storage; they may be stale by a few minutes.
   * @return lastEventTime
   */
  @javax.annotation.Nullable
  public String getLastEventTime() {
    return lastEventTime;
  }

  public void setLastEventTime(String lastEventTime) {
    this.lastEventTime = lastEventTime;
  }


  public Device lastHeartbeatTime(String lastHeartbeatTime) {
    this.lastHeartbeatTime = lastHeartbeatTime;
    return this;
  }

  /**
   * [Output only] The last time an MQTT &#x60;PINGREQ&#x60; was received. This field applies only to devices connecting through MQTT. MQTT clients usually only send &#x60;PINGREQ&#x60; messages if the connection is idle, and no other messages have been sent. Timestamps are periodically collected and written to storage; they may be stale by a few minutes.
   * @return lastHeartbeatTime
   */
  @javax.annotation.Nullable
  public String getLastHeartbeatTime() {
    return lastHeartbeatTime;
  }

  public void setLastHeartbeatTime(String lastHeartbeatTime) {
    this.lastHeartbeatTime = lastHeartbeatTime;
  }


  public Device lastStateTime(String lastStateTime) {
    this.lastStateTime = lastStateTime;
    return this;
  }

  /**
   * [Output only] The last time a state event was received. Timestamps are periodically collected and written to storage; they may be stale by a few minutes.
   * @return lastStateTime
   */
  @javax.annotation.Nullable
  public String getLastStateTime() {
    return lastStateTime;
  }

  public void setLastStateTime(String lastStateTime) {
    this.lastStateTime = lastStateTime;
  }


  public Device logLevel(LogLevelEnum logLevel) {
    this.logLevel = logLevel;
    return this;
  }

  /**
   * **Beta Feature** The logging verbosity for device activity. If unspecified, DeviceRegistry.log_level will be used.
   * @return logLevel
   */
  @javax.annotation.Nullable
  public LogLevelEnum getLogLevel() {
    return logLevel;
  }

  public void setLogLevel(LogLevelEnum logLevel) {
    this.logLevel = logLevel;
  }


  public Device metadata(Map<String, String> metadata) {
    this.metadata = metadata;
    return this;
  }

  public Device putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * The metadata key-value pairs assigned to the device. This metadata is not interpreted or indexed by Cloud IoT Core. It can be used to add contextual information for the device. Keys must conform to the regular expression a-zA-Z+ and be less than 128 bytes in length. Values are free-form strings. Each value must be less than or equal to 32 KB in size. The total size of all keys and values must be less than 256 KB, and the maximum number of key-value pairs is 500.
   * @return metadata
   */
  @javax.annotation.Nullable
  public Map<String, String> getMetadata() {
    return metadata;
  }

  public void setMetadata(Map<String, String> metadata) {
    this.metadata = metadata;
  }


  public Device name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The resource path name. For example, &#x60;projects/p1/locations/us-central1/registries/registry0/devices/dev0&#x60; or &#x60;projects/p1/locations/us-central1/registries/registry0/devices/{num_id}&#x60;. When &#x60;name&#x60; is populated as a response from the service, it always ends in the device numeric ID.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Device numId(String numId) {
    this.numId = numId;
    return this;
  }

  /**
   * [Output only] A server-defined unique numeric ID for the device. This is a more compact way to identify devices, and it is globally unique.
   * @return numId
   */
  @javax.annotation.Nullable
  public String getNumId() {
    return numId;
  }

  public void setNumId(String numId) {
    this.numId = numId;
  }


  public Device state(DeviceState state) {
    this.state = state;
    return this;
  }

  /**
   * Get state
   * @return state
   */
  @javax.annotation.Nullable
  public DeviceState getState() {
    return state;
  }

  public void setState(DeviceState state) {
    this.state = state;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Device device = (Device) o;
    return Objects.equals(this.blocked, device.blocked) &&
        Objects.equals(this.config, device.config) &&
        Objects.equals(this.credentials, device.credentials) &&
        Objects.equals(this.gatewayConfig, device.gatewayConfig) &&
        Objects.equals(this.id, device.id) &&
        Objects.equals(this.lastConfigAckTime, device.lastConfigAckTime) &&
        Objects.equals(this.lastConfigSendTime, device.lastConfigSendTime) &&
        Objects.equals(this.lastErrorStatus, device.lastErrorStatus) &&
        Objects.equals(this.lastErrorTime, device.lastErrorTime) &&
        Objects.equals(this.lastEventTime, device.lastEventTime) &&
        Objects.equals(this.lastHeartbeatTime, device.lastHeartbeatTime) &&
        Objects.equals(this.lastStateTime, device.lastStateTime) &&
        Objects.equals(this.logLevel, device.logLevel) &&
        Objects.equals(this.metadata, device.metadata) &&
        Objects.equals(this.name, device.name) &&
        Objects.equals(this.numId, device.numId) &&
        Objects.equals(this.state, device.state);
  }

  @Override
  public int hashCode() {
    return Objects.hash(blocked, config, credentials, gatewayConfig, id, lastConfigAckTime, lastConfigSendTime, lastErrorStatus, lastErrorTime, lastEventTime, lastHeartbeatTime, lastStateTime, logLevel, metadata, name, numId, state);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Device {\n");
    sb.append("    blocked: ").append(toIndentedString(blocked)).append("\n");
    sb.append("    config: ").append(toIndentedString(config)).append("\n");
    sb.append("    credentials: ").append(toIndentedString(credentials)).append("\n");
    sb.append("    gatewayConfig: ").append(toIndentedString(gatewayConfig)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    lastConfigAckTime: ").append(toIndentedString(lastConfigAckTime)).append("\n");
    sb.append("    lastConfigSendTime: ").append(toIndentedString(lastConfigSendTime)).append("\n");
    sb.append("    lastErrorStatus: ").append(toIndentedString(lastErrorStatus)).append("\n");
    sb.append("    lastErrorTime: ").append(toIndentedString(lastErrorTime)).append("\n");
    sb.append("    lastEventTime: ").append(toIndentedString(lastEventTime)).append("\n");
    sb.append("    lastHeartbeatTime: ").append(toIndentedString(lastHeartbeatTime)).append("\n");
    sb.append("    lastStateTime: ").append(toIndentedString(lastStateTime)).append("\n");
    sb.append("    logLevel: ").append(toIndentedString(logLevel)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    numId: ").append(toIndentedString(numId)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("blocked");
    openapiFields.add("config");
    openapiFields.add("credentials");
    openapiFields.add("gatewayConfig");
    openapiFields.add("id");
    openapiFields.add("lastConfigAckTime");
    openapiFields.add("lastConfigSendTime");
    openapiFields.add("lastErrorStatus");
    openapiFields.add("lastErrorTime");
    openapiFields.add("lastEventTime");
    openapiFields.add("lastHeartbeatTime");
    openapiFields.add("lastStateTime");
    openapiFields.add("logLevel");
    openapiFields.add("metadata");
    openapiFields.add("name");
    openapiFields.add("numId");
    openapiFields.add("state");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Device
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Device.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Device is not found in the empty JSON string", Device.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Device.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Device` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `config`
      if (jsonObj.get("config") != null && !jsonObj.get("config").isJsonNull()) {
        DeviceConfig.validateJsonElement(jsonObj.get("config"));
      }
      if (jsonObj.get("credentials") != null && !jsonObj.get("credentials").isJsonNull()) {
        JsonArray jsonArraycredentials = jsonObj.getAsJsonArray("credentials");
        if (jsonArraycredentials != null) {
          // ensure the json data is an array
          if (!jsonObj.get("credentials").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `credentials` to be an array in the JSON string but got `%s`", jsonObj.get("credentials").toString()));
          }

          // validate the optional field `credentials` (array)
          for (int i = 0; i < jsonArraycredentials.size(); i++) {
            DeviceCredential.validateJsonElement(jsonArraycredentials.get(i));
          };
        }
      }
      // validate the optional field `gatewayConfig`
      if (jsonObj.get("gatewayConfig") != null && !jsonObj.get("gatewayConfig").isJsonNull()) {
        GatewayConfig.validateJsonElement(jsonObj.get("gatewayConfig"));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("lastConfigAckTime") != null && !jsonObj.get("lastConfigAckTime").isJsonNull()) && !jsonObj.get("lastConfigAckTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastConfigAckTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastConfigAckTime").toString()));
      }
      if ((jsonObj.get("lastConfigSendTime") != null && !jsonObj.get("lastConfigSendTime").isJsonNull()) && !jsonObj.get("lastConfigSendTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastConfigSendTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastConfigSendTime").toString()));
      }
      // validate the optional field `lastErrorStatus`
      if (jsonObj.get("lastErrorStatus") != null && !jsonObj.get("lastErrorStatus").isJsonNull()) {
        Status.validateJsonElement(jsonObj.get("lastErrorStatus"));
      }
      if ((jsonObj.get("lastErrorTime") != null && !jsonObj.get("lastErrorTime").isJsonNull()) && !jsonObj.get("lastErrorTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastErrorTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastErrorTime").toString()));
      }
      if ((jsonObj.get("lastEventTime") != null && !jsonObj.get("lastEventTime").isJsonNull()) && !jsonObj.get("lastEventTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastEventTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastEventTime").toString()));
      }
      if ((jsonObj.get("lastHeartbeatTime") != null && !jsonObj.get("lastHeartbeatTime").isJsonNull()) && !jsonObj.get("lastHeartbeatTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastHeartbeatTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastHeartbeatTime").toString()));
      }
      if ((jsonObj.get("lastStateTime") != null && !jsonObj.get("lastStateTime").isJsonNull()) && !jsonObj.get("lastStateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastStateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastStateTime").toString()));
      }
      if ((jsonObj.get("logLevel") != null && !jsonObj.get("logLevel").isJsonNull()) && !jsonObj.get("logLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logLevel").toString()));
      }
      // validate the optional field `logLevel`
      if (jsonObj.get("logLevel") != null && !jsonObj.get("logLevel").isJsonNull()) {
        LogLevelEnum.validateJsonElement(jsonObj.get("logLevel"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("numId") != null && !jsonObj.get("numId").isJsonNull()) && !jsonObj.get("numId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `numId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("numId").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        DeviceState.validateJsonElement(jsonObj.get("state"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Device.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Device' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Device> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Device.class));

       return (TypeAdapter<T>) new TypeAdapter<Device>() {
           @Override
           public void write(JsonWriter out, Device value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Device read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Device given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Device
   * @throws IOException if the JSON string is invalid with respect to Device
   */
  public static Device fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Device.class);
  }

  /**
   * Convert an instance of Device to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

