/*
 * Service Management API
 * Google Service Management allows service producers to publish their services on Google Cloud Platform so that they can be discovered and used by service consumers.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DocumentationRule;
import org.openapitools.client.model.Page;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &#x60;Documentation&#x60; provides the information for describing a service. Example: documentation: summary: &gt; The Google Calendar API gives access to most calendar features. pages: - name: Overview content: (&#x3D;&#x3D; include google/foo/overview.md &#x3D;&#x3D;) - name: Tutorial content: (&#x3D;&#x3D; include google/foo/tutorial.md &#x3D;&#x3D;) subpages: - name: Java content: (&#x3D;&#x3D; include google/foo/tutorial_java.md &#x3D;&#x3D;) rules: - selector: google.calendar.Calendar.Get description: &gt; ... - selector: google.calendar.Calendar.Put description: &gt; ... Documentation is provided in markdown syntax. In addition to standard markdown features, definition lists, tables and fenced code blocks are supported. Section headers can be provided and are interpreted relative to the section nesting of the context where a documentation fragment is embedded. Documentation from the IDL is merged with documentation defined via the config at normalization time, where documentation provided by config rules overrides IDL provided. A number of constructs specific to the API platform are supported in documentation text. In order to reference a proto element, the following notation can be used: [fully.qualified.proto.name][] To override the display text used for the link, this can be used: [display text][fully.qualified.proto.name] Text can be excluded from doc using the following notation: (-- internal comment --) A few directives are available in documentation. Note that directives must appear on a single line to be properly identified. The &#x60;include&#x60; directive includes a markdown file from an external source: (&#x3D;&#x3D; include path/to/file &#x3D;&#x3D;) The &#x60;resource_for&#x60; directive marks a message to be the resource of a collection in REST view. If it is not specified, tools attempt to infer the resource from the operations in a collection: (&#x3D;&#x3D; resource_for v1.shelves.books &#x3D;&#x3D;) The directive &#x60;suppress_warning&#x60; does not directly affect documentation and is documented together with service config validation.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:49:08.497622-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Documentation {
  public static final String SERIALIZED_NAME_DOCUMENTATION_ROOT_URL = "documentationRootUrl";
  @SerializedName(SERIALIZED_NAME_DOCUMENTATION_ROOT_URL)
  private String documentationRootUrl;

  public static final String SERIALIZED_NAME_OVERVIEW = "overview";
  @SerializedName(SERIALIZED_NAME_OVERVIEW)
  private String overview;

  public static final String SERIALIZED_NAME_PAGES = "pages";
  @SerializedName(SERIALIZED_NAME_PAGES)
  private List<Page> pages = new ArrayList<>();

  public static final String SERIALIZED_NAME_RULES = "rules";
  @SerializedName(SERIALIZED_NAME_RULES)
  private List<DocumentationRule> rules = new ArrayList<>();

  public static final String SERIALIZED_NAME_SECTION_OVERRIDES = "sectionOverrides";
  @SerializedName(SERIALIZED_NAME_SECTION_OVERRIDES)
  private List<Page> sectionOverrides = new ArrayList<>();

  public static final String SERIALIZED_NAME_SERVICE_ROOT_URL = "serviceRootUrl";
  @SerializedName(SERIALIZED_NAME_SERVICE_ROOT_URL)
  private String serviceRootUrl;

  public static final String SERIALIZED_NAME_SUMMARY = "summary";
  @SerializedName(SERIALIZED_NAME_SUMMARY)
  private String summary;

  public Documentation() {
  }

  public Documentation documentationRootUrl(String documentationRootUrl) {
    this.documentationRootUrl = documentationRootUrl;
    return this;
  }

  /**
   * The URL to the root of documentation.
   * @return documentationRootUrl
   */
  @javax.annotation.Nullable
  public String getDocumentationRootUrl() {
    return documentationRootUrl;
  }

  public void setDocumentationRootUrl(String documentationRootUrl) {
    this.documentationRootUrl = documentationRootUrl;
  }


  public Documentation overview(String overview) {
    this.overview = overview;
    return this;
  }

  /**
   * Declares a single overview page. For example: documentation: summary: ... overview: (&#x3D;&#x3D; include overview.md &#x3D;&#x3D;) This is a shortcut for the following declaration (using pages style): documentation: summary: ... pages: - name: Overview content: (&#x3D;&#x3D; include overview.md &#x3D;&#x3D;) Note: you cannot specify both &#x60;overview&#x60; field and &#x60;pages&#x60; field.
   * @return overview
   */
  @javax.annotation.Nullable
  public String getOverview() {
    return overview;
  }

  public void setOverview(String overview) {
    this.overview = overview;
  }


  public Documentation pages(List<Page> pages) {
    this.pages = pages;
    return this;
  }

  public Documentation addPagesItem(Page pagesItem) {
    if (this.pages == null) {
      this.pages = new ArrayList<>();
    }
    this.pages.add(pagesItem);
    return this;
  }

  /**
   * The top level pages for the documentation set.
   * @return pages
   */
  @javax.annotation.Nullable
  public List<Page> getPages() {
    return pages;
  }

  public void setPages(List<Page> pages) {
    this.pages = pages;
  }


  public Documentation rules(List<DocumentationRule> rules) {
    this.rules = rules;
    return this;
  }

  public Documentation addRulesItem(DocumentationRule rulesItem) {
    if (this.rules == null) {
      this.rules = new ArrayList<>();
    }
    this.rules.add(rulesItem);
    return this;
  }

  /**
   * A list of documentation rules that apply to individual API elements. **NOTE:** All service configuration rules follow \&quot;last one wins\&quot; order.
   * @return rules
   */
  @javax.annotation.Nullable
  public List<DocumentationRule> getRules() {
    return rules;
  }

  public void setRules(List<DocumentationRule> rules) {
    this.rules = rules;
  }


  public Documentation sectionOverrides(List<Page> sectionOverrides) {
    this.sectionOverrides = sectionOverrides;
    return this;
  }

  public Documentation addSectionOverridesItem(Page sectionOverridesItem) {
    if (this.sectionOverrides == null) {
      this.sectionOverrides = new ArrayList<>();
    }
    this.sectionOverrides.add(sectionOverridesItem);
    return this;
  }

  /**
   * Specifies section and content to override boilerplate content provided by go/api-docgen. Currently overrides following sections: 1. rest.service.client_libraries
   * @return sectionOverrides
   */
  @javax.annotation.Nullable
  public List<Page> getSectionOverrides() {
    return sectionOverrides;
  }

  public void setSectionOverrides(List<Page> sectionOverrides) {
    this.sectionOverrides = sectionOverrides;
  }


  public Documentation serviceRootUrl(String serviceRootUrl) {
    this.serviceRootUrl = serviceRootUrl;
    return this;
  }

  /**
   * Specifies the service root url if the default one (the service name from the yaml file) is not suitable. This can be seen in any fully specified service urls as well as sections that show a base that other urls are relative to.
   * @return serviceRootUrl
   */
  @javax.annotation.Nullable
  public String getServiceRootUrl() {
    return serviceRootUrl;
  }

  public void setServiceRootUrl(String serviceRootUrl) {
    this.serviceRootUrl = serviceRootUrl;
  }


  public Documentation summary(String summary) {
    this.summary = summary;
    return this;
  }

  /**
   * A short description of what the service does. The summary must be plain text. It becomes the overview of the service displayed in Google Cloud Console. NOTE: This field is equivalent to the standard field &#x60;description&#x60;.
   * @return summary
   */
  @javax.annotation.Nullable
  public String getSummary() {
    return summary;
  }

  public void setSummary(String summary) {
    this.summary = summary;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Documentation documentation = (Documentation) o;
    return Objects.equals(this.documentationRootUrl, documentation.documentationRootUrl) &&
        Objects.equals(this.overview, documentation.overview) &&
        Objects.equals(this.pages, documentation.pages) &&
        Objects.equals(this.rules, documentation.rules) &&
        Objects.equals(this.sectionOverrides, documentation.sectionOverrides) &&
        Objects.equals(this.serviceRootUrl, documentation.serviceRootUrl) &&
        Objects.equals(this.summary, documentation.summary);
  }

  @Override
  public int hashCode() {
    return Objects.hash(documentationRootUrl, overview, pages, rules, sectionOverrides, serviceRootUrl, summary);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Documentation {\n");
    sb.append("    documentationRootUrl: ").append(toIndentedString(documentationRootUrl)).append("\n");
    sb.append("    overview: ").append(toIndentedString(overview)).append("\n");
    sb.append("    pages: ").append(toIndentedString(pages)).append("\n");
    sb.append("    rules: ").append(toIndentedString(rules)).append("\n");
    sb.append("    sectionOverrides: ").append(toIndentedString(sectionOverrides)).append("\n");
    sb.append("    serviceRootUrl: ").append(toIndentedString(serviceRootUrl)).append("\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("documentationRootUrl");
    openapiFields.add("overview");
    openapiFields.add("pages");
    openapiFields.add("rules");
    openapiFields.add("sectionOverrides");
    openapiFields.add("serviceRootUrl");
    openapiFields.add("summary");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Documentation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Documentation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Documentation is not found in the empty JSON string", Documentation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Documentation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Documentation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("documentationRootUrl") != null && !jsonObj.get("documentationRootUrl").isJsonNull()) && !jsonObj.get("documentationRootUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentationRootUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentationRootUrl").toString()));
      }
      if ((jsonObj.get("overview") != null && !jsonObj.get("overview").isJsonNull()) && !jsonObj.get("overview").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `overview` to be a primitive type in the JSON string but got `%s`", jsonObj.get("overview").toString()));
      }
      if (jsonObj.get("pages") != null && !jsonObj.get("pages").isJsonNull()) {
        JsonArray jsonArraypages = jsonObj.getAsJsonArray("pages");
        if (jsonArraypages != null) {
          // ensure the json data is an array
          if (!jsonObj.get("pages").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `pages` to be an array in the JSON string but got `%s`", jsonObj.get("pages").toString()));
          }

          // validate the optional field `pages` (array)
          for (int i = 0; i < jsonArraypages.size(); i++) {
            Page.validateJsonElement(jsonArraypages.get(i));
          };
        }
      }
      if (jsonObj.get("rules") != null && !jsonObj.get("rules").isJsonNull()) {
        JsonArray jsonArrayrules = jsonObj.getAsJsonArray("rules");
        if (jsonArrayrules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("rules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `rules` to be an array in the JSON string but got `%s`", jsonObj.get("rules").toString()));
          }

          // validate the optional field `rules` (array)
          for (int i = 0; i < jsonArrayrules.size(); i++) {
            DocumentationRule.validateJsonElement(jsonArrayrules.get(i));
          };
        }
      }
      if (jsonObj.get("sectionOverrides") != null && !jsonObj.get("sectionOverrides").isJsonNull()) {
        JsonArray jsonArraysectionOverrides = jsonObj.getAsJsonArray("sectionOverrides");
        if (jsonArraysectionOverrides != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sectionOverrides").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sectionOverrides` to be an array in the JSON string but got `%s`", jsonObj.get("sectionOverrides").toString()));
          }

          // validate the optional field `sectionOverrides` (array)
          for (int i = 0; i < jsonArraysectionOverrides.size(); i++) {
            Page.validateJsonElement(jsonArraysectionOverrides.get(i));
          };
        }
      }
      if ((jsonObj.get("serviceRootUrl") != null && !jsonObj.get("serviceRootUrl").isJsonNull()) && !jsonObj.get("serviceRootUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceRootUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceRootUrl").toString()));
      }
      if ((jsonObj.get("summary") != null && !jsonObj.get("summary").isJsonNull()) && !jsonObj.get("summary").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `summary` to be a primitive type in the JSON string but got `%s`", jsonObj.get("summary").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Documentation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Documentation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Documentation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Documentation.class));

       return (TypeAdapter<T>) new TypeAdapter<Documentation>() {
           @Override
           public void write(JsonWriter out, Documentation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Documentation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Documentation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Documentation
   * @throws IOException if the JSON string is invalid with respect to Documentation
   */
  public static Documentation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Documentation.class);
  }

  /**
   * Convert an instance of Documentation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

