# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class SocketAddress(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, address: str=None, ipv4_compat: bool=None, named_port: str=None, port_value: int=None, protocol: str=None, resolver_name: str=None):
        """SocketAddress - a model defined in OpenAPI

        :param address: The address of this SocketAddress.
        :param ipv4_compat: The ipv4_compat of this SocketAddress.
        :param named_port: The named_port of this SocketAddress.
        :param port_value: The port_value of this SocketAddress.
        :param protocol: The protocol of this SocketAddress.
        :param resolver_name: The resolver_name of this SocketAddress.
        """
        self.openapi_types = {
            'address': str,
            'ipv4_compat': bool,
            'named_port': str,
            'port_value': int,
            'protocol': str,
            'resolver_name': str
        }

        self.attribute_map = {
            'address': 'address',
            'ipv4_compat': 'ipv4Compat',
            'named_port': 'namedPort',
            'port_value': 'portValue',
            'protocol': 'protocol',
            'resolver_name': 'resolverName'
        }

        self._address = address
        self._ipv4_compat = ipv4_compat
        self._named_port = named_port
        self._port_value = port_value
        self._protocol = protocol
        self._resolver_name = resolver_name

    @classmethod
    def from_dict(cls, dikt: dict) -> 'SocketAddress':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The SocketAddress of this SocketAddress.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def address(self):
        """Gets the address of this SocketAddress.

        The address for this socket. :ref:`Listeners ` will bind to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::`` to bind to any address. [#comment:TODO(zuercher) reinstate when implemented: It is possible to distinguish a Listener address via the prefix/suffix matching in :ref:`FilterChainMatch `.] When used within an upstream :ref:`BindConfig `, the address controls the source address of outbound connections. For :ref:`clusters `, the cluster type determines whether the address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized via :ref:`resolver_name `.

        :return: The address of this SocketAddress.
        :rtype: str
        """
        return self._address

    @address.setter
    def address(self, address):
        """Sets the address of this SocketAddress.

        The address for this socket. :ref:`Listeners ` will bind to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::`` to bind to any address. [#comment:TODO(zuercher) reinstate when implemented: It is possible to distinguish a Listener address via the prefix/suffix matching in :ref:`FilterChainMatch `.] When used within an upstream :ref:`BindConfig `, the address controls the source address of outbound connections. For :ref:`clusters `, the cluster type determines whether the address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized via :ref:`resolver_name `.

        :param address: The address of this SocketAddress.
        :type address: str
        """

        self._address = address

    @property
    def ipv4_compat(self):
        """Gets the ipv4_compat of this SocketAddress.

        When binding to an IPv6 address above, this enables `IPv4 compatibility `_. Binding to ``::`` will allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into IPv6 space as ``::FFFF:``.

        :return: The ipv4_compat of this SocketAddress.
        :rtype: bool
        """
        return self._ipv4_compat

    @ipv4_compat.setter
    def ipv4_compat(self, ipv4_compat):
        """Sets the ipv4_compat of this SocketAddress.

        When binding to an IPv6 address above, this enables `IPv4 compatibility `_. Binding to ``::`` will allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into IPv6 space as ``::FFFF:``.

        :param ipv4_compat: The ipv4_compat of this SocketAddress.
        :type ipv4_compat: bool
        """

        self._ipv4_compat = ipv4_compat

    @property
    def named_port(self):
        """Gets the named_port of this SocketAddress.

        This is only valid if :ref:`resolver_name ` is specified below and the named resolver is capable of named port resolution.

        :return: The named_port of this SocketAddress.
        :rtype: str
        """
        return self._named_port

    @named_port.setter
    def named_port(self, named_port):
        """Sets the named_port of this SocketAddress.

        This is only valid if :ref:`resolver_name ` is specified below and the named resolver is capable of named port resolution.

        :param named_port: The named_port of this SocketAddress.
        :type named_port: str
        """

        self._named_port = named_port

    @property
    def port_value(self):
        """Gets the port_value of this SocketAddress.


        :return: The port_value of this SocketAddress.
        :rtype: int
        """
        return self._port_value

    @port_value.setter
    def port_value(self, port_value):
        """Sets the port_value of this SocketAddress.


        :param port_value: The port_value of this SocketAddress.
        :type port_value: int
        """

        self._port_value = port_value

    @property
    def protocol(self):
        """Gets the protocol of this SocketAddress.


        :return: The protocol of this SocketAddress.
        :rtype: str
        """
        return self._protocol

    @protocol.setter
    def protocol(self, protocol):
        """Sets the protocol of this SocketAddress.


        :param protocol: The protocol of this SocketAddress.
        :type protocol: str
        """
        allowed_values = ["TCP", "UDP"]  # noqa: E501
        if protocol not in allowed_values:
            raise ValueError(
                "Invalid value for `protocol` ({0}), must be one of {1}"
                .format(protocol, allowed_values)
            )

        self._protocol = protocol

    @property
    def resolver_name(self):
        """Gets the resolver_name of this SocketAddress.

        The name of the custom resolver. This must have been registered with Envoy. If this is empty, a context dependent default applies. If the address is a concrete IP address, no resolution will occur. If address is a hostname this should be set for resolution other than DNS. Specifying a custom resolver with ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.

        :return: The resolver_name of this SocketAddress.
        :rtype: str
        """
        return self._resolver_name

    @resolver_name.setter
    def resolver_name(self, resolver_name):
        """Sets the resolver_name of this SocketAddress.

        The name of the custom resolver. This must have been registered with Envoy. If this is empty, a context dependent default applies. If the address is a concrete IP address, no resolution will occur. If address is a hostname this should be set for resolution other than DNS. Specifying a custom resolver with ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.

        :param resolver_name: The resolver_name of this SocketAddress.
        :type resolver_name: str
        """

        self._resolver_name = resolver_name
