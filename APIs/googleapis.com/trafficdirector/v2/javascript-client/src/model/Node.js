/**
 * Traffic Director API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Address from './Address';
import BuildVersion from './BuildVersion';
import Extension from './Extension';
import Locality from './Locality';

/**
 * The Node model module.
 * @module model/Node
 * @version v2
 */
class Node {
    /**
     * Constructs a new <code>Node</code>.
     * Identifies a specific Envoy instance. The node identifier is presented to the management server, which may use this identifier to distinguish per Envoy configuration for serving. [#next-free-field: 12]
     * @alias module:model/Node
     */
    constructor() { 
        
        Node.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Node</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Node} obj Optional instance to populate.
     * @return {module:model/Node} The populated <code>Node</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Node();

            if (data.hasOwnProperty('buildVersion')) {
                obj['buildVersion'] = ApiClient.convertToType(data['buildVersion'], 'String');
            }
            if (data.hasOwnProperty('clientFeatures')) {
                obj['clientFeatures'] = ApiClient.convertToType(data['clientFeatures'], ['String']);
            }
            if (data.hasOwnProperty('cluster')) {
                obj['cluster'] = ApiClient.convertToType(data['cluster'], 'String');
            }
            if (data.hasOwnProperty('extensions')) {
                obj['extensions'] = ApiClient.convertToType(data['extensions'], [Extension]);
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('listeningAddresses')) {
                obj['listeningAddresses'] = ApiClient.convertToType(data['listeningAddresses'], [Address]);
            }
            if (data.hasOwnProperty('locality')) {
                obj['locality'] = Locality.constructFromObject(data['locality']);
            }
            if (data.hasOwnProperty('metadata')) {
                obj['metadata'] = ApiClient.convertToType(data['metadata'], {'String': Object});
            }
            if (data.hasOwnProperty('userAgentBuildVersion')) {
                obj['userAgentBuildVersion'] = BuildVersion.constructFromObject(data['userAgentBuildVersion']);
            }
            if (data.hasOwnProperty('userAgentName')) {
                obj['userAgentName'] = ApiClient.convertToType(data['userAgentName'], 'String');
            }
            if (data.hasOwnProperty('userAgentVersion')) {
                obj['userAgentVersion'] = ApiClient.convertToType(data['userAgentVersion'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Node</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Node</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['buildVersion'] && !(typeof data['buildVersion'] === 'string' || data['buildVersion'] instanceof String)) {
            throw new Error("Expected the field `buildVersion` to be a primitive type in the JSON string but got " + data['buildVersion']);
        }
        // ensure the json data is an array
        if (!Array.isArray(data['clientFeatures'])) {
            throw new Error("Expected the field `clientFeatures` to be an array in the JSON data but got " + data['clientFeatures']);
        }
        // ensure the json data is a string
        if (data['cluster'] && !(typeof data['cluster'] === 'string' || data['cluster'] instanceof String)) {
            throw new Error("Expected the field `cluster` to be a primitive type in the JSON string but got " + data['cluster']);
        }
        if (data['extensions']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['extensions'])) {
                throw new Error("Expected the field `extensions` to be an array in the JSON data but got " + data['extensions']);
            }
            // validate the optional field `extensions` (array)
            for (const item of data['extensions']) {
                Extension.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        if (data['listeningAddresses']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['listeningAddresses'])) {
                throw new Error("Expected the field `listeningAddresses` to be an array in the JSON data but got " + data['listeningAddresses']);
            }
            // validate the optional field `listeningAddresses` (array)
            for (const item of data['listeningAddresses']) {
                Address.validateJSON(item);
            };
        }
        // validate the optional field `locality`
        if (data['locality']) { // data not null
          Locality.validateJSON(data['locality']);
        }
        // validate the optional field `userAgentBuildVersion`
        if (data['userAgentBuildVersion']) { // data not null
          BuildVersion.validateJSON(data['userAgentBuildVersion']);
        }
        // ensure the json data is a string
        if (data['userAgentName'] && !(typeof data['userAgentName'] === 'string' || data['userAgentName'] instanceof String)) {
            throw new Error("Expected the field `userAgentName` to be a primitive type in the JSON string but got " + data['userAgentName']);
        }
        // ensure the json data is a string
        if (data['userAgentVersion'] && !(typeof data['userAgentVersion'] === 'string' || data['userAgentVersion'] instanceof String)) {
            throw new Error("Expected the field `userAgentVersion` to be a primitive type in the JSON string but got " + data['userAgentVersion']);
        }

        return true;
    }


}



/**
 * This is motivated by informing a management server during canary which version of Envoy is being tested in a heterogeneous fleet. This will be set by Envoy in management server RPCs. This field is deprecated in favor of the user_agent_name and user_agent_version values.
 * @member {String} buildVersion
 */
Node.prototype['buildVersion'] = undefined;

/**
 * Client feature support list. These are well known features described in the Envoy API repository for a given major version of an API. Client features use reverse DNS naming scheme, for example `com.acme.feature`. See :ref:`the list of features ` that xDS client may support.
 * @member {Array.<String>} clientFeatures
 */
Node.prototype['clientFeatures'] = undefined;

/**
 * Defines the local service cluster name where Envoy is running. Though optional, it should be set if any of the following features are used: :ref:`statsd `, :ref:`health check cluster verification `, :ref:`runtime override directory `, :ref:`user agent addition `, :ref:`HTTP global rate limiting `, :ref:`CDS `, and :ref:`HTTP tracing `, either in this message or via :option:`--service-cluster`.
 * @member {String} cluster
 */
Node.prototype['cluster'] = undefined;

/**
 * List of extensions and their versions supported by the node.
 * @member {Array.<module:model/Extension>} extensions
 */
Node.prototype['extensions'] = undefined;

/**
 * An opaque node identifier for the Envoy node. This also provides the local service node name. It should be set if any of the following features are used: :ref:`statsd `, :ref:`CDS `, and :ref:`HTTP tracing `, either in this message or via :option:`--service-node`.
 * @member {String} id
 */
Node.prototype['id'] = undefined;

/**
 * Known listening ports on the node as a generic hint to the management server for filtering :ref:`listeners ` to be returned. For example, if there is a listener bound to port 80, the list can optionally contain the SocketAddress `(0.0.0.0,80)`. The field is optional and just a hint.
 * @member {Array.<module:model/Address>} listeningAddresses
 */
Node.prototype['listeningAddresses'] = undefined;

/**
 * @member {module:model/Locality} locality
 */
Node.prototype['locality'] = undefined;

/**
 * Opaque metadata extending the node identifier. Envoy will pass this directly to the management server.
 * @member {Object.<String, Object>} metadata
 */
Node.prototype['metadata'] = undefined;

/**
 * @member {module:model/BuildVersion} userAgentBuildVersion
 */
Node.prototype['userAgentBuildVersion'] = undefined;

/**
 * Free-form string that identifies the entity requesting config. E.g. \"envoy\" or \"grpc\"
 * @member {String} userAgentName
 */
Node.prototype['userAgentName'] = undefined;

/**
 * Free-form string that identifies the version of the entity requesting config. E.g. \"1.12.2\" or \"abcd1234\", or \"SpecialEnvoyBuild\"
 * @member {String} userAgentVersion
 */
Node.prototype['userAgentVersion'] = undefined;






export default Node;

