/*
 * Gmail Postmaster Tools API
 * The Postmaster Tools API is a RESTful API that provides programmatic access to email traffic metrics (like spam reports, delivery errors etc) otherwise available through the Gmail Postmaster Tools UI currently.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DeliveryError;
import org.openapitools.client.model.FeedbackLoop;
import org.openapitools.client.model.IpReputation;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Email traffic statistics pertaining to a specific date.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:39:02.811696-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TrafficStats {
  public static final String SERIALIZED_NAME_DELIVERY_ERRORS = "deliveryErrors";
  @SerializedName(SERIALIZED_NAME_DELIVERY_ERRORS)
  private List<DeliveryError> deliveryErrors = new ArrayList<>();

  public static final String SERIALIZED_NAME_DKIM_SUCCESS_RATIO = "dkimSuccessRatio";
  @SerializedName(SERIALIZED_NAME_DKIM_SUCCESS_RATIO)
  private Double dkimSuccessRatio;

  public static final String SERIALIZED_NAME_DMARC_SUCCESS_RATIO = "dmarcSuccessRatio";
  @SerializedName(SERIALIZED_NAME_DMARC_SUCCESS_RATIO)
  private Double dmarcSuccessRatio;

  /**
   * Reputation of the domain.
   */
  @JsonAdapter(DomainReputationEnum.Adapter.class)
  public enum DomainReputationEnum {
    REPUTATION_CATEGORY_UNSPECIFIED("REPUTATION_CATEGORY_UNSPECIFIED"),
    
    HIGH("HIGH"),
    
    MEDIUM("MEDIUM"),
    
    LOW("LOW"),
    
    BAD("BAD");

    private String value;

    DomainReputationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DomainReputationEnum fromValue(String value) {
      for (DomainReputationEnum b : DomainReputationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DomainReputationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DomainReputationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DomainReputationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DomainReputationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DomainReputationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DOMAIN_REPUTATION = "domainReputation";
  @SerializedName(SERIALIZED_NAME_DOMAIN_REPUTATION)
  private DomainReputationEnum domainReputation;

  public static final String SERIALIZED_NAME_INBOUND_ENCRYPTION_RATIO = "inboundEncryptionRatio";
  @SerializedName(SERIALIZED_NAME_INBOUND_ENCRYPTION_RATIO)
  private Double inboundEncryptionRatio;

  public static final String SERIALIZED_NAME_IP_REPUTATIONS = "ipReputations";
  @SerializedName(SERIALIZED_NAME_IP_REPUTATIONS)
  private List<IpReputation> ipReputations = new ArrayList<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OUTBOUND_ENCRYPTION_RATIO = "outboundEncryptionRatio";
  @SerializedName(SERIALIZED_NAME_OUTBOUND_ENCRYPTION_RATIO)
  private Double outboundEncryptionRatio;

  public static final String SERIALIZED_NAME_SPAMMY_FEEDBACK_LOOPS = "spammyFeedbackLoops";
  @SerializedName(SERIALIZED_NAME_SPAMMY_FEEDBACK_LOOPS)
  private List<FeedbackLoop> spammyFeedbackLoops = new ArrayList<>();

  public static final String SERIALIZED_NAME_SPF_SUCCESS_RATIO = "spfSuccessRatio";
  @SerializedName(SERIALIZED_NAME_SPF_SUCCESS_RATIO)
  private Double spfSuccessRatio;

  public static final String SERIALIZED_NAME_USER_REPORTED_SPAM_RATIO = "userReportedSpamRatio";
  @SerializedName(SERIALIZED_NAME_USER_REPORTED_SPAM_RATIO)
  private Double userReportedSpamRatio;

  public static final String SERIALIZED_NAME_USER_REPORTED_SPAM_RATIO_LOWER_BOUND = "userReportedSpamRatioLowerBound";
  @SerializedName(SERIALIZED_NAME_USER_REPORTED_SPAM_RATIO_LOWER_BOUND)
  private Double userReportedSpamRatioLowerBound;

  public static final String SERIALIZED_NAME_USER_REPORTED_SPAM_RATIO_UPPER_BOUND = "userReportedSpamRatioUpperBound";
  @SerializedName(SERIALIZED_NAME_USER_REPORTED_SPAM_RATIO_UPPER_BOUND)
  private Double userReportedSpamRatioUpperBound;

  public TrafficStats() {
  }

  public TrafficStats deliveryErrors(List<DeliveryError> deliveryErrors) {
    this.deliveryErrors = deliveryErrors;
    return this;
  }

  public TrafficStats addDeliveryErrorsItem(DeliveryError deliveryErrorsItem) {
    if (this.deliveryErrors == null) {
      this.deliveryErrors = new ArrayList<>();
    }
    this.deliveryErrors.add(deliveryErrorsItem);
    return this;
  }

  /**
   * Delivery errors for the domain. This metric only pertains to traffic that passed [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).
   * @return deliveryErrors
   */
  @javax.annotation.Nullable
  public List<DeliveryError> getDeliveryErrors() {
    return deliveryErrors;
  }

  public void setDeliveryErrors(List<DeliveryError> deliveryErrors) {
    this.deliveryErrors = deliveryErrors;
  }


  public TrafficStats dkimSuccessRatio(Double dkimSuccessRatio) {
    this.dkimSuccessRatio = dkimSuccessRatio;
    return this;
  }

  /**
   * The ratio of mail that successfully authenticated with DKIM vs. all mail that attempted to authenticate with [DKIM](http://www.dkim.org/). Spoofed mail is excluded.
   * @return dkimSuccessRatio
   */
  @javax.annotation.Nullable
  public Double getDkimSuccessRatio() {
    return dkimSuccessRatio;
  }

  public void setDkimSuccessRatio(Double dkimSuccessRatio) {
    this.dkimSuccessRatio = dkimSuccessRatio;
  }


  public TrafficStats dmarcSuccessRatio(Double dmarcSuccessRatio) {
    this.dmarcSuccessRatio = dmarcSuccessRatio;
    return this;
  }

  /**
   * The ratio of mail that passed [DMARC](https://dmarc.org/) alignment checks vs all mail received from the domain that successfully authenticated with either of [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).
   * @return dmarcSuccessRatio
   */
  @javax.annotation.Nullable
  public Double getDmarcSuccessRatio() {
    return dmarcSuccessRatio;
  }

  public void setDmarcSuccessRatio(Double dmarcSuccessRatio) {
    this.dmarcSuccessRatio = dmarcSuccessRatio;
  }


  public TrafficStats domainReputation(DomainReputationEnum domainReputation) {
    this.domainReputation = domainReputation;
    return this;
  }

  /**
   * Reputation of the domain.
   * @return domainReputation
   */
  @javax.annotation.Nullable
  public DomainReputationEnum getDomainReputation() {
    return domainReputation;
  }

  public void setDomainReputation(DomainReputationEnum domainReputation) {
    this.domainReputation = domainReputation;
  }


  public TrafficStats inboundEncryptionRatio(Double inboundEncryptionRatio) {
    this.inboundEncryptionRatio = inboundEncryptionRatio;
    return this;
  }

  /**
   * The ratio of incoming mail (to Gmail), that passed secure transport (TLS) vs all mail received from that domain. This metric only pertains to traffic that passed [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).
   * @return inboundEncryptionRatio
   */
  @javax.annotation.Nullable
  public Double getInboundEncryptionRatio() {
    return inboundEncryptionRatio;
  }

  public void setInboundEncryptionRatio(Double inboundEncryptionRatio) {
    this.inboundEncryptionRatio = inboundEncryptionRatio;
  }


  public TrafficStats ipReputations(List<IpReputation> ipReputations) {
    this.ipReputations = ipReputations;
    return this;
  }

  public TrafficStats addIpReputationsItem(IpReputation ipReputationsItem) {
    if (this.ipReputations == null) {
      this.ipReputations = new ArrayList<>();
    }
    this.ipReputations.add(ipReputationsItem);
    return this;
  }

  /**
   * Reputation information pertaining to the IP addresses of the email servers for the domain. There is exactly one entry for each reputation category except REPUTATION_CATEGORY_UNSPECIFIED.
   * @return ipReputations
   */
  @javax.annotation.Nullable
  public List<IpReputation> getIpReputations() {
    return ipReputations;
  }

  public void setIpReputations(List<IpReputation> ipReputations) {
    this.ipReputations = ipReputations;
  }


  public TrafficStats name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The resource name of the traffic statistics. Traffic statistic names have the form &#x60;domains/{domain}/trafficStats/{date}&#x60;, where domain_name is the fully qualified domain name (i.e., mymail.mydomain.com) of the domain this traffic statistics pertains to and date is the date in yyyymmdd format that these statistics corresponds to. For example: domains/mymail.mydomain.com/trafficStats/20160807
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public TrafficStats outboundEncryptionRatio(Double outboundEncryptionRatio) {
    this.outboundEncryptionRatio = outboundEncryptionRatio;
    return this;
  }

  /**
   * The ratio of outgoing mail (from Gmail) that was accepted over secure transport (TLS).
   * @return outboundEncryptionRatio
   */
  @javax.annotation.Nullable
  public Double getOutboundEncryptionRatio() {
    return outboundEncryptionRatio;
  }

  public void setOutboundEncryptionRatio(Double outboundEncryptionRatio) {
    this.outboundEncryptionRatio = outboundEncryptionRatio;
  }


  public TrafficStats spammyFeedbackLoops(List<FeedbackLoop> spammyFeedbackLoops) {
    this.spammyFeedbackLoops = spammyFeedbackLoops;
    return this;
  }

  public TrafficStats addSpammyFeedbackLoopsItem(FeedbackLoop spammyFeedbackLoopsItem) {
    if (this.spammyFeedbackLoops == null) {
      this.spammyFeedbackLoops = new ArrayList<>();
    }
    this.spammyFeedbackLoops.add(spammyFeedbackLoopsItem);
    return this;
  }

  /**
   * Spammy [Feedback loop identifiers] (https://support.google.com/mail/answer/6254652) with their individual spam rates. This metric only pertains to traffic that is authenticated by [DKIM](http://www.dkim.org/).
   * @return spammyFeedbackLoops
   */
  @javax.annotation.Nullable
  public List<FeedbackLoop> getSpammyFeedbackLoops() {
    return spammyFeedbackLoops;
  }

  public void setSpammyFeedbackLoops(List<FeedbackLoop> spammyFeedbackLoops) {
    this.spammyFeedbackLoops = spammyFeedbackLoops;
  }


  public TrafficStats spfSuccessRatio(Double spfSuccessRatio) {
    this.spfSuccessRatio = spfSuccessRatio;
    return this;
  }

  /**
   * The ratio of mail that successfully authenticated with SPF vs. all mail that attempted to authenticate with [SPF](http://www.openspf.org/). Spoofed mail is excluded.
   * @return spfSuccessRatio
   */
  @javax.annotation.Nullable
  public Double getSpfSuccessRatio() {
    return spfSuccessRatio;
  }

  public void setSpfSuccessRatio(Double spfSuccessRatio) {
    this.spfSuccessRatio = spfSuccessRatio;
  }


  public TrafficStats userReportedSpamRatio(Double userReportedSpamRatio) {
    this.userReportedSpamRatio = userReportedSpamRatio;
    return this;
  }

  /**
   * The ratio of user-report spam vs. email that was sent to the inbox. This is potentially inexact -- users may want to refer to the description of the interval fields userReportedSpamRatioLowerBound and userReportedSpamRatioUpperBound for more explicit accuracy guarantees. This metric only pertains to emails authenticated by [DKIM](http://www.dkim.org/).
   * @return userReportedSpamRatio
   */
  @javax.annotation.Nullable
  public Double getUserReportedSpamRatio() {
    return userReportedSpamRatio;
  }

  public void setUserReportedSpamRatio(Double userReportedSpamRatio) {
    this.userReportedSpamRatio = userReportedSpamRatio;
  }


  public TrafficStats userReportedSpamRatioLowerBound(Double userReportedSpamRatioLowerBound) {
    this.userReportedSpamRatioLowerBound = userReportedSpamRatioLowerBound;
    return this;
  }

  /**
   * The lower bound of the confidence interval for the user reported spam ratio. If this field is set, then the value of userReportedSpamRatio is set to the midpoint of this interval and is thus inexact. However, the true ratio is guaranteed to be in between this lower bound and the corresponding upper bound 95% of the time. This metric only pertains to emails authenticated by [DKIM](http://www.dkim.org/).
   * @return userReportedSpamRatioLowerBound
   */
  @javax.annotation.Nullable
  public Double getUserReportedSpamRatioLowerBound() {
    return userReportedSpamRatioLowerBound;
  }

  public void setUserReportedSpamRatioLowerBound(Double userReportedSpamRatioLowerBound) {
    this.userReportedSpamRatioLowerBound = userReportedSpamRatioLowerBound;
  }


  public TrafficStats userReportedSpamRatioUpperBound(Double userReportedSpamRatioUpperBound) {
    this.userReportedSpamRatioUpperBound = userReportedSpamRatioUpperBound;
    return this;
  }

  /**
   * The upper bound of the confidence interval for the user reported spam ratio. If this field is set, then the value of userReportedSpamRatio is set to the midpoint of this interval and is thus inexact. However, the true ratio is guaranteed to be in between this upper bound and the corresponding lower bound 95% of the time. This metric only pertains to emails authenticated by [DKIM](http://www.dkim.org/).
   * @return userReportedSpamRatioUpperBound
   */
  @javax.annotation.Nullable
  public Double getUserReportedSpamRatioUpperBound() {
    return userReportedSpamRatioUpperBound;
  }

  public void setUserReportedSpamRatioUpperBound(Double userReportedSpamRatioUpperBound) {
    this.userReportedSpamRatioUpperBound = userReportedSpamRatioUpperBound;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TrafficStats trafficStats = (TrafficStats) o;
    return Objects.equals(this.deliveryErrors, trafficStats.deliveryErrors) &&
        Objects.equals(this.dkimSuccessRatio, trafficStats.dkimSuccessRatio) &&
        Objects.equals(this.dmarcSuccessRatio, trafficStats.dmarcSuccessRatio) &&
        Objects.equals(this.domainReputation, trafficStats.domainReputation) &&
        Objects.equals(this.inboundEncryptionRatio, trafficStats.inboundEncryptionRatio) &&
        Objects.equals(this.ipReputations, trafficStats.ipReputations) &&
        Objects.equals(this.name, trafficStats.name) &&
        Objects.equals(this.outboundEncryptionRatio, trafficStats.outboundEncryptionRatio) &&
        Objects.equals(this.spammyFeedbackLoops, trafficStats.spammyFeedbackLoops) &&
        Objects.equals(this.spfSuccessRatio, trafficStats.spfSuccessRatio) &&
        Objects.equals(this.userReportedSpamRatio, trafficStats.userReportedSpamRatio) &&
        Objects.equals(this.userReportedSpamRatioLowerBound, trafficStats.userReportedSpamRatioLowerBound) &&
        Objects.equals(this.userReportedSpamRatioUpperBound, trafficStats.userReportedSpamRatioUpperBound);
  }

  @Override
  public int hashCode() {
    return Objects.hash(deliveryErrors, dkimSuccessRatio, dmarcSuccessRatio, domainReputation, inboundEncryptionRatio, ipReputations, name, outboundEncryptionRatio, spammyFeedbackLoops, spfSuccessRatio, userReportedSpamRatio, userReportedSpamRatioLowerBound, userReportedSpamRatioUpperBound);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TrafficStats {\n");
    sb.append("    deliveryErrors: ").append(toIndentedString(deliveryErrors)).append("\n");
    sb.append("    dkimSuccessRatio: ").append(toIndentedString(dkimSuccessRatio)).append("\n");
    sb.append("    dmarcSuccessRatio: ").append(toIndentedString(dmarcSuccessRatio)).append("\n");
    sb.append("    domainReputation: ").append(toIndentedString(domainReputation)).append("\n");
    sb.append("    inboundEncryptionRatio: ").append(toIndentedString(inboundEncryptionRatio)).append("\n");
    sb.append("    ipReputations: ").append(toIndentedString(ipReputations)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    outboundEncryptionRatio: ").append(toIndentedString(outboundEncryptionRatio)).append("\n");
    sb.append("    spammyFeedbackLoops: ").append(toIndentedString(spammyFeedbackLoops)).append("\n");
    sb.append("    spfSuccessRatio: ").append(toIndentedString(spfSuccessRatio)).append("\n");
    sb.append("    userReportedSpamRatio: ").append(toIndentedString(userReportedSpamRatio)).append("\n");
    sb.append("    userReportedSpamRatioLowerBound: ").append(toIndentedString(userReportedSpamRatioLowerBound)).append("\n");
    sb.append("    userReportedSpamRatioUpperBound: ").append(toIndentedString(userReportedSpamRatioUpperBound)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("deliveryErrors");
    openapiFields.add("dkimSuccessRatio");
    openapiFields.add("dmarcSuccessRatio");
    openapiFields.add("domainReputation");
    openapiFields.add("inboundEncryptionRatio");
    openapiFields.add("ipReputations");
    openapiFields.add("name");
    openapiFields.add("outboundEncryptionRatio");
    openapiFields.add("spammyFeedbackLoops");
    openapiFields.add("spfSuccessRatio");
    openapiFields.add("userReportedSpamRatio");
    openapiFields.add("userReportedSpamRatioLowerBound");
    openapiFields.add("userReportedSpamRatioUpperBound");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TrafficStats
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TrafficStats.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TrafficStats is not found in the empty JSON string", TrafficStats.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TrafficStats.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TrafficStats` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("deliveryErrors") != null && !jsonObj.get("deliveryErrors").isJsonNull()) {
        JsonArray jsonArraydeliveryErrors = jsonObj.getAsJsonArray("deliveryErrors");
        if (jsonArraydeliveryErrors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("deliveryErrors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `deliveryErrors` to be an array in the JSON string but got `%s`", jsonObj.get("deliveryErrors").toString()));
          }

          // validate the optional field `deliveryErrors` (array)
          for (int i = 0; i < jsonArraydeliveryErrors.size(); i++) {
            DeliveryError.validateJsonElement(jsonArraydeliveryErrors.get(i));
          };
        }
      }
      if ((jsonObj.get("domainReputation") != null && !jsonObj.get("domainReputation").isJsonNull()) && !jsonObj.get("domainReputation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `domainReputation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("domainReputation").toString()));
      }
      // validate the optional field `domainReputation`
      if (jsonObj.get("domainReputation") != null && !jsonObj.get("domainReputation").isJsonNull()) {
        DomainReputationEnum.validateJsonElement(jsonObj.get("domainReputation"));
      }
      if (jsonObj.get("ipReputations") != null && !jsonObj.get("ipReputations").isJsonNull()) {
        JsonArray jsonArrayipReputations = jsonObj.getAsJsonArray("ipReputations");
        if (jsonArrayipReputations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ipReputations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ipReputations` to be an array in the JSON string but got `%s`", jsonObj.get("ipReputations").toString()));
          }

          // validate the optional field `ipReputations` (array)
          for (int i = 0; i < jsonArrayipReputations.size(); i++) {
            IpReputation.validateJsonElement(jsonArrayipReputations.get(i));
          };
        }
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("spammyFeedbackLoops") != null && !jsonObj.get("spammyFeedbackLoops").isJsonNull()) {
        JsonArray jsonArrayspammyFeedbackLoops = jsonObj.getAsJsonArray("spammyFeedbackLoops");
        if (jsonArrayspammyFeedbackLoops != null) {
          // ensure the json data is an array
          if (!jsonObj.get("spammyFeedbackLoops").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `spammyFeedbackLoops` to be an array in the JSON string but got `%s`", jsonObj.get("spammyFeedbackLoops").toString()));
          }

          // validate the optional field `spammyFeedbackLoops` (array)
          for (int i = 0; i < jsonArrayspammyFeedbackLoops.size(); i++) {
            FeedbackLoop.validateJsonElement(jsonArrayspammyFeedbackLoops.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TrafficStats.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TrafficStats' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TrafficStats> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TrafficStats.class));

       return (TypeAdapter<T>) new TypeAdapter<TrafficStats>() {
           @Override
           public void write(JsonWriter out, TrafficStats value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TrafficStats read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TrafficStats given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TrafficStats
   * @throws IOException if the JSON string is invalid with respect to TrafficStats
   */
  public static TrafficStats fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TrafficStats.class);
  }

  /**
   * Convert an instance of TrafficStats to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

