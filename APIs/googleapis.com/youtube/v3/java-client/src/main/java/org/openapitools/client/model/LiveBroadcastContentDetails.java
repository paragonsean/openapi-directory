/*
 * YouTube Data API v3
 * The YouTube Data API v3 is an API that provides access to YouTube data, such as videos, playlists, and channels.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.MonitorStreamInfo;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Detailed settings of a broadcast.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:42:06.328357-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LiveBroadcastContentDetails {
  public static final String SERIALIZED_NAME_BOUND_STREAM_ID = "boundStreamId";
  @SerializedName(SERIALIZED_NAME_BOUND_STREAM_ID)
  private String boundStreamId;

  public static final String SERIALIZED_NAME_BOUND_STREAM_LAST_UPDATE_TIME_MS = "boundStreamLastUpdateTimeMs";
  @SerializedName(SERIALIZED_NAME_BOUND_STREAM_LAST_UPDATE_TIME_MS)
  private OffsetDateTime boundStreamLastUpdateTimeMs;

  /**
   * Gets or Sets closedCaptionsType
   */
  @JsonAdapter(ClosedCaptionsTypeEnum.Adapter.class)
  public enum ClosedCaptionsTypeEnum {
    CLOSED_CAPTIONS_TYPE_UNSPECIFIED("closedCaptionsTypeUnspecified"),
    
    CLOSED_CAPTIONS_DISABLED("closedCaptionsDisabled"),
    
    CLOSED_CAPTIONS_HTTP_POST("closedCaptionsHttpPost"),
    
    CLOSED_CAPTIONS_EMBEDDED("closedCaptionsEmbedded");

    private String value;

    ClosedCaptionsTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ClosedCaptionsTypeEnum fromValue(String value) {
      for (ClosedCaptionsTypeEnum b : ClosedCaptionsTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ClosedCaptionsTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClosedCaptionsTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClosedCaptionsTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ClosedCaptionsTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ClosedCaptionsTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_CLOSED_CAPTIONS_TYPE = "closedCaptionsType";
  @SerializedName(SERIALIZED_NAME_CLOSED_CAPTIONS_TYPE)
  private ClosedCaptionsTypeEnum closedCaptionsType;

  public static final String SERIALIZED_NAME_ENABLE_AUTO_START = "enableAutoStart";
  @SerializedName(SERIALIZED_NAME_ENABLE_AUTO_START)
  private Boolean enableAutoStart;

  public static final String SERIALIZED_NAME_ENABLE_AUTO_STOP = "enableAutoStop";
  @SerializedName(SERIALIZED_NAME_ENABLE_AUTO_STOP)
  private Boolean enableAutoStop;

  public static final String SERIALIZED_NAME_ENABLE_CLOSED_CAPTIONS = "enableClosedCaptions";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_ENABLE_CLOSED_CAPTIONS)
  private Boolean enableClosedCaptions;

  public static final String SERIALIZED_NAME_ENABLE_CONTENT_ENCRYPTION = "enableContentEncryption";
  @SerializedName(SERIALIZED_NAME_ENABLE_CONTENT_ENCRYPTION)
  private Boolean enableContentEncryption;

  public static final String SERIALIZED_NAME_ENABLE_DVR = "enableDvr";
  @SerializedName(SERIALIZED_NAME_ENABLE_DVR)
  private Boolean enableDvr;

  public static final String SERIALIZED_NAME_ENABLE_EMBED = "enableEmbed";
  @SerializedName(SERIALIZED_NAME_ENABLE_EMBED)
  private Boolean enableEmbed;

  public static final String SERIALIZED_NAME_ENABLE_LOW_LATENCY = "enableLowLatency";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_ENABLE_LOW_LATENCY)
  private Boolean enableLowLatency;

  /**
   * If both this and enable_low_latency are set, they must match. LATENCY_NORMAL should match enable_low_latency&#x3D;false LATENCY_LOW should match enable_low_latency&#x3D;true LATENCY_ULTRA_LOW should have enable_low_latency omitted.
   */
  @JsonAdapter(LatencyPreferenceEnum.Adapter.class)
  public enum LatencyPreferenceEnum {
    LATENCY_PREFERENCE_UNSPECIFIED("latencyPreferenceUnspecified"),
    
    NORMAL("normal"),
    
    LOW("low"),
    
    ULTRA_LOW("ultraLow");

    private String value;

    LatencyPreferenceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LatencyPreferenceEnum fromValue(String value) {
      for (LatencyPreferenceEnum b : LatencyPreferenceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LatencyPreferenceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LatencyPreferenceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LatencyPreferenceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LatencyPreferenceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LatencyPreferenceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LATENCY_PREFERENCE = "latencyPreference";
  @SerializedName(SERIALIZED_NAME_LATENCY_PREFERENCE)
  private LatencyPreferenceEnum latencyPreference;

  public static final String SERIALIZED_NAME_MESH = "mesh";
  @SerializedName(SERIALIZED_NAME_MESH)
  private byte[] mesh;

  public static final String SERIALIZED_NAME_MONITOR_STREAM = "monitorStream";
  @SerializedName(SERIALIZED_NAME_MONITOR_STREAM)
  private MonitorStreamInfo monitorStream;

  /**
   * The projection format of this broadcast. This defaults to rectangular.
   */
  @JsonAdapter(ProjectionEnum.Adapter.class)
  public enum ProjectionEnum {
    PROJECTION_UNSPECIFIED("projectionUnspecified"),
    
    RECTANGULAR("rectangular"),
    
    _360("360"),
    
    MESH("mesh");

    private String value;

    ProjectionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProjectionEnum fromValue(String value) {
      for (ProjectionEnum b : ProjectionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProjectionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProjectionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProjectionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProjectionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProjectionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PROJECTION = "projection";
  @SerializedName(SERIALIZED_NAME_PROJECTION)
  private ProjectionEnum projection;

  public static final String SERIALIZED_NAME_RECORD_FROM_START = "recordFromStart";
  @SerializedName(SERIALIZED_NAME_RECORD_FROM_START)
  private Boolean recordFromStart;

  public static final String SERIALIZED_NAME_START_WITH_SLATE = "startWithSlate";
  @SerializedName(SERIALIZED_NAME_START_WITH_SLATE)
  private Boolean startWithSlate;

  /**
   * The 3D stereo layout of this broadcast. This defaults to mono.
   */
  @JsonAdapter(StereoLayoutEnum.Adapter.class)
  public enum StereoLayoutEnum {
    STEREO_LAYOUT_UNSPECIFIED("stereoLayoutUnspecified"),
    
    MONO("mono"),
    
    LEFT_RIGHT("leftRight"),
    
    TOP_BOTTOM("topBottom");

    private String value;

    StereoLayoutEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StereoLayoutEnum fromValue(String value) {
      for (StereoLayoutEnum b : StereoLayoutEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StereoLayoutEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StereoLayoutEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StereoLayoutEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StereoLayoutEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StereoLayoutEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STEREO_LAYOUT = "stereoLayout";
  @SerializedName(SERIALIZED_NAME_STEREO_LAYOUT)
  private StereoLayoutEnum stereoLayout;

  public LiveBroadcastContentDetails() {
  }

  public LiveBroadcastContentDetails boundStreamId(String boundStreamId) {
    this.boundStreamId = boundStreamId;
    return this;
  }

  /**
   * This value uniquely identifies the live stream bound to the broadcast.
   * @return boundStreamId
   */
  @javax.annotation.Nullable
  public String getBoundStreamId() {
    return boundStreamId;
  }

  public void setBoundStreamId(String boundStreamId) {
    this.boundStreamId = boundStreamId;
  }


  public LiveBroadcastContentDetails boundStreamLastUpdateTimeMs(OffsetDateTime boundStreamLastUpdateTimeMs) {
    this.boundStreamLastUpdateTimeMs = boundStreamLastUpdateTimeMs;
    return this;
  }

  /**
   * The date and time that the live stream referenced by boundStreamId was last updated.
   * @return boundStreamLastUpdateTimeMs
   */
  @javax.annotation.Nullable
  public OffsetDateTime getBoundStreamLastUpdateTimeMs() {
    return boundStreamLastUpdateTimeMs;
  }

  public void setBoundStreamLastUpdateTimeMs(OffsetDateTime boundStreamLastUpdateTimeMs) {
    this.boundStreamLastUpdateTimeMs = boundStreamLastUpdateTimeMs;
  }


  public LiveBroadcastContentDetails closedCaptionsType(ClosedCaptionsTypeEnum closedCaptionsType) {
    this.closedCaptionsType = closedCaptionsType;
    return this;
  }

  /**
   * Get closedCaptionsType
   * @return closedCaptionsType
   */
  @javax.annotation.Nullable
  public ClosedCaptionsTypeEnum getClosedCaptionsType() {
    return closedCaptionsType;
  }

  public void setClosedCaptionsType(ClosedCaptionsTypeEnum closedCaptionsType) {
    this.closedCaptionsType = closedCaptionsType;
  }


  public LiveBroadcastContentDetails enableAutoStart(Boolean enableAutoStart) {
    this.enableAutoStart = enableAutoStart;
    return this;
  }

  /**
   * This setting indicates whether auto start is enabled for this broadcast. The default value for this property is false. This setting can only be used by Events.
   * @return enableAutoStart
   */
  @javax.annotation.Nullable
  public Boolean getEnableAutoStart() {
    return enableAutoStart;
  }

  public void setEnableAutoStart(Boolean enableAutoStart) {
    this.enableAutoStart = enableAutoStart;
  }


  public LiveBroadcastContentDetails enableAutoStop(Boolean enableAutoStop) {
    this.enableAutoStop = enableAutoStop;
    return this;
  }

  /**
   * This setting indicates whether auto stop is enabled for this broadcast. The default value for this property is false. This setting can only be used by Events.
   * @return enableAutoStop
   */
  @javax.annotation.Nullable
  public Boolean getEnableAutoStop() {
    return enableAutoStop;
  }

  public void setEnableAutoStop(Boolean enableAutoStop) {
    this.enableAutoStop = enableAutoStop;
  }


  @Deprecated
  public LiveBroadcastContentDetails enableClosedCaptions(Boolean enableClosedCaptions) {
    this.enableClosedCaptions = enableClosedCaptions;
    return this;
  }

  /**
   * This setting indicates whether HTTP POST closed captioning is enabled for this broadcast. The ingestion URL of the closed captions is returned through the liveStreams API. This is mutually exclusive with using the closed_captions_type property, and is equivalent to setting closed_captions_type to CLOSED_CAPTIONS_HTTP_POST.
   * @return enableClosedCaptions
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getEnableClosedCaptions() {
    return enableClosedCaptions;
  }

  @Deprecated
  public void setEnableClosedCaptions(Boolean enableClosedCaptions) {
    this.enableClosedCaptions = enableClosedCaptions;
  }


  public LiveBroadcastContentDetails enableContentEncryption(Boolean enableContentEncryption) {
    this.enableContentEncryption = enableContentEncryption;
    return this;
  }

  /**
   * This setting indicates whether YouTube should enable content encryption for the broadcast.
   * @return enableContentEncryption
   */
  @javax.annotation.Nullable
  public Boolean getEnableContentEncryption() {
    return enableContentEncryption;
  }

  public void setEnableContentEncryption(Boolean enableContentEncryption) {
    this.enableContentEncryption = enableContentEncryption;
  }


  public LiveBroadcastContentDetails enableDvr(Boolean enableDvr) {
    this.enableDvr = enableDvr;
    return this;
  }

  /**
   * This setting determines whether viewers can access DVR controls while watching the video. DVR controls enable the viewer to control the video playback experience by pausing, rewinding, or fast forwarding content. The default value for this property is true. *Important:* You must set the value to true and also set the enableArchive property&#39;s value to true if you want to make playback available immediately after the broadcast ends.
   * @return enableDvr
   */
  @javax.annotation.Nullable
  public Boolean getEnableDvr() {
    return enableDvr;
  }

  public void setEnableDvr(Boolean enableDvr) {
    this.enableDvr = enableDvr;
  }


  public LiveBroadcastContentDetails enableEmbed(Boolean enableEmbed) {
    this.enableEmbed = enableEmbed;
    return this;
  }

  /**
   * This setting indicates whether the broadcast video can be played in an embedded player. If you choose to archive the video (using the enableArchive property), this setting will also apply to the archived video.
   * @return enableEmbed
   */
  @javax.annotation.Nullable
  public Boolean getEnableEmbed() {
    return enableEmbed;
  }

  public void setEnableEmbed(Boolean enableEmbed) {
    this.enableEmbed = enableEmbed;
  }


  @Deprecated
  public LiveBroadcastContentDetails enableLowLatency(Boolean enableLowLatency) {
    this.enableLowLatency = enableLowLatency;
    return this;
  }

  /**
   * Indicates whether this broadcast has low latency enabled.
   * @return enableLowLatency
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getEnableLowLatency() {
    return enableLowLatency;
  }

  @Deprecated
  public void setEnableLowLatency(Boolean enableLowLatency) {
    this.enableLowLatency = enableLowLatency;
  }


  public LiveBroadcastContentDetails latencyPreference(LatencyPreferenceEnum latencyPreference) {
    this.latencyPreference = latencyPreference;
    return this;
  }

  /**
   * If both this and enable_low_latency are set, they must match. LATENCY_NORMAL should match enable_low_latency&#x3D;false LATENCY_LOW should match enable_low_latency&#x3D;true LATENCY_ULTRA_LOW should have enable_low_latency omitted.
   * @return latencyPreference
   */
  @javax.annotation.Nullable
  public LatencyPreferenceEnum getLatencyPreference() {
    return latencyPreference;
  }

  public void setLatencyPreference(LatencyPreferenceEnum latencyPreference) {
    this.latencyPreference = latencyPreference;
  }


  public LiveBroadcastContentDetails mesh(byte[] mesh) {
    this.mesh = mesh;
    return this;
  }

  /**
   * The mesh for projecting the video if projection is mesh. The mesh value must be a UTF-8 string containing the base-64 encoding of 3D mesh data that follows the Spherical Video V2 RFC specification for an mshp box, excluding the box size and type but including the following four reserved zero bytes for the version and flags.
   * @return mesh
   */
  @javax.annotation.Nullable
  public byte[] getMesh() {
    return mesh;
  }

  public void setMesh(byte[] mesh) {
    this.mesh = mesh;
  }


  public LiveBroadcastContentDetails monitorStream(MonitorStreamInfo monitorStream) {
    this.monitorStream = monitorStream;
    return this;
  }

  /**
   * Get monitorStream
   * @return monitorStream
   */
  @javax.annotation.Nullable
  public MonitorStreamInfo getMonitorStream() {
    return monitorStream;
  }

  public void setMonitorStream(MonitorStreamInfo monitorStream) {
    this.monitorStream = monitorStream;
  }


  public LiveBroadcastContentDetails projection(ProjectionEnum projection) {
    this.projection = projection;
    return this;
  }

  /**
   * The projection format of this broadcast. This defaults to rectangular.
   * @return projection
   */
  @javax.annotation.Nullable
  public ProjectionEnum getProjection() {
    return projection;
  }

  public void setProjection(ProjectionEnum projection) {
    this.projection = projection;
  }


  public LiveBroadcastContentDetails recordFromStart(Boolean recordFromStart) {
    this.recordFromStart = recordFromStart;
    return this;
  }

  /**
   * Automatically start recording after the event goes live. The default value for this property is true. *Important:* You must also set the enableDvr property&#39;s value to true if you want the playback to be available immediately after the broadcast ends. If you set this property&#39;s value to true but do not also set the enableDvr property to true, there may be a delay of around one day before the archived video will be available for playback.
   * @return recordFromStart
   */
  @javax.annotation.Nullable
  public Boolean getRecordFromStart() {
    return recordFromStart;
  }

  public void setRecordFromStart(Boolean recordFromStart) {
    this.recordFromStart = recordFromStart;
  }


  public LiveBroadcastContentDetails startWithSlate(Boolean startWithSlate) {
    this.startWithSlate = startWithSlate;
    return this;
  }

  /**
   * This setting indicates whether the broadcast should automatically begin with an in-stream slate when you update the broadcast&#39;s status to live. After updating the status, you then need to send a liveCuepoints.insert request that sets the cuepoint&#39;s eventState to end to remove the in-stream slate and make your broadcast stream visible to viewers.
   * @return startWithSlate
   */
  @javax.annotation.Nullable
  public Boolean getStartWithSlate() {
    return startWithSlate;
  }

  public void setStartWithSlate(Boolean startWithSlate) {
    this.startWithSlate = startWithSlate;
  }


  public LiveBroadcastContentDetails stereoLayout(StereoLayoutEnum stereoLayout) {
    this.stereoLayout = stereoLayout;
    return this;
  }

  /**
   * The 3D stereo layout of this broadcast. This defaults to mono.
   * @return stereoLayout
   */
  @javax.annotation.Nullable
  public StereoLayoutEnum getStereoLayout() {
    return stereoLayout;
  }

  public void setStereoLayout(StereoLayoutEnum stereoLayout) {
    this.stereoLayout = stereoLayout;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LiveBroadcastContentDetails liveBroadcastContentDetails = (LiveBroadcastContentDetails) o;
    return Objects.equals(this.boundStreamId, liveBroadcastContentDetails.boundStreamId) &&
        Objects.equals(this.boundStreamLastUpdateTimeMs, liveBroadcastContentDetails.boundStreamLastUpdateTimeMs) &&
        Objects.equals(this.closedCaptionsType, liveBroadcastContentDetails.closedCaptionsType) &&
        Objects.equals(this.enableAutoStart, liveBroadcastContentDetails.enableAutoStart) &&
        Objects.equals(this.enableAutoStop, liveBroadcastContentDetails.enableAutoStop) &&
        Objects.equals(this.enableClosedCaptions, liveBroadcastContentDetails.enableClosedCaptions) &&
        Objects.equals(this.enableContentEncryption, liveBroadcastContentDetails.enableContentEncryption) &&
        Objects.equals(this.enableDvr, liveBroadcastContentDetails.enableDvr) &&
        Objects.equals(this.enableEmbed, liveBroadcastContentDetails.enableEmbed) &&
        Objects.equals(this.enableLowLatency, liveBroadcastContentDetails.enableLowLatency) &&
        Objects.equals(this.latencyPreference, liveBroadcastContentDetails.latencyPreference) &&
        Arrays.equals(this.mesh, liveBroadcastContentDetails.mesh) &&
        Objects.equals(this.monitorStream, liveBroadcastContentDetails.monitorStream) &&
        Objects.equals(this.projection, liveBroadcastContentDetails.projection) &&
        Objects.equals(this.recordFromStart, liveBroadcastContentDetails.recordFromStart) &&
        Objects.equals(this.startWithSlate, liveBroadcastContentDetails.startWithSlate) &&
        Objects.equals(this.stereoLayout, liveBroadcastContentDetails.stereoLayout);
  }

  @Override
  public int hashCode() {
    return Objects.hash(boundStreamId, boundStreamLastUpdateTimeMs, closedCaptionsType, enableAutoStart, enableAutoStop, enableClosedCaptions, enableContentEncryption, enableDvr, enableEmbed, enableLowLatency, latencyPreference, Arrays.hashCode(mesh), monitorStream, projection, recordFromStart, startWithSlate, stereoLayout);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LiveBroadcastContentDetails {\n");
    sb.append("    boundStreamId: ").append(toIndentedString(boundStreamId)).append("\n");
    sb.append("    boundStreamLastUpdateTimeMs: ").append(toIndentedString(boundStreamLastUpdateTimeMs)).append("\n");
    sb.append("    closedCaptionsType: ").append(toIndentedString(closedCaptionsType)).append("\n");
    sb.append("    enableAutoStart: ").append(toIndentedString(enableAutoStart)).append("\n");
    sb.append("    enableAutoStop: ").append(toIndentedString(enableAutoStop)).append("\n");
    sb.append("    enableClosedCaptions: ").append(toIndentedString(enableClosedCaptions)).append("\n");
    sb.append("    enableContentEncryption: ").append(toIndentedString(enableContentEncryption)).append("\n");
    sb.append("    enableDvr: ").append(toIndentedString(enableDvr)).append("\n");
    sb.append("    enableEmbed: ").append(toIndentedString(enableEmbed)).append("\n");
    sb.append("    enableLowLatency: ").append(toIndentedString(enableLowLatency)).append("\n");
    sb.append("    latencyPreference: ").append(toIndentedString(latencyPreference)).append("\n");
    sb.append("    mesh: ").append(toIndentedString(mesh)).append("\n");
    sb.append("    monitorStream: ").append(toIndentedString(monitorStream)).append("\n");
    sb.append("    projection: ").append(toIndentedString(projection)).append("\n");
    sb.append("    recordFromStart: ").append(toIndentedString(recordFromStart)).append("\n");
    sb.append("    startWithSlate: ").append(toIndentedString(startWithSlate)).append("\n");
    sb.append("    stereoLayout: ").append(toIndentedString(stereoLayout)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("boundStreamId");
    openapiFields.add("boundStreamLastUpdateTimeMs");
    openapiFields.add("closedCaptionsType");
    openapiFields.add("enableAutoStart");
    openapiFields.add("enableAutoStop");
    openapiFields.add("enableClosedCaptions");
    openapiFields.add("enableContentEncryption");
    openapiFields.add("enableDvr");
    openapiFields.add("enableEmbed");
    openapiFields.add("enableLowLatency");
    openapiFields.add("latencyPreference");
    openapiFields.add("mesh");
    openapiFields.add("monitorStream");
    openapiFields.add("projection");
    openapiFields.add("recordFromStart");
    openapiFields.add("startWithSlate");
    openapiFields.add("stereoLayout");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LiveBroadcastContentDetails
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LiveBroadcastContentDetails.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LiveBroadcastContentDetails is not found in the empty JSON string", LiveBroadcastContentDetails.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LiveBroadcastContentDetails.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LiveBroadcastContentDetails` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("boundStreamId") != null && !jsonObj.get("boundStreamId").isJsonNull()) && !jsonObj.get("boundStreamId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `boundStreamId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("boundStreamId").toString()));
      }
      if ((jsonObj.get("closedCaptionsType") != null && !jsonObj.get("closedCaptionsType").isJsonNull()) && !jsonObj.get("closedCaptionsType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `closedCaptionsType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("closedCaptionsType").toString()));
      }
      // validate the optional field `closedCaptionsType`
      if (jsonObj.get("closedCaptionsType") != null && !jsonObj.get("closedCaptionsType").isJsonNull()) {
        ClosedCaptionsTypeEnum.validateJsonElement(jsonObj.get("closedCaptionsType"));
      }
      if ((jsonObj.get("latencyPreference") != null && !jsonObj.get("latencyPreference").isJsonNull()) && !jsonObj.get("latencyPreference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `latencyPreference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("latencyPreference").toString()));
      }
      // validate the optional field `latencyPreference`
      if (jsonObj.get("latencyPreference") != null && !jsonObj.get("latencyPreference").isJsonNull()) {
        LatencyPreferenceEnum.validateJsonElement(jsonObj.get("latencyPreference"));
      }
      // validate the optional field `monitorStream`
      if (jsonObj.get("monitorStream") != null && !jsonObj.get("monitorStream").isJsonNull()) {
        MonitorStreamInfo.validateJsonElement(jsonObj.get("monitorStream"));
      }
      if ((jsonObj.get("projection") != null && !jsonObj.get("projection").isJsonNull()) && !jsonObj.get("projection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `projection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("projection").toString()));
      }
      // validate the optional field `projection`
      if (jsonObj.get("projection") != null && !jsonObj.get("projection").isJsonNull()) {
        ProjectionEnum.validateJsonElement(jsonObj.get("projection"));
      }
      if ((jsonObj.get("stereoLayout") != null && !jsonObj.get("stereoLayout").isJsonNull()) && !jsonObj.get("stereoLayout").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stereoLayout` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stereoLayout").toString()));
      }
      // validate the optional field `stereoLayout`
      if (jsonObj.get("stereoLayout") != null && !jsonObj.get("stereoLayout").isJsonNull()) {
        StereoLayoutEnum.validateJsonElement(jsonObj.get("stereoLayout"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LiveBroadcastContentDetails.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LiveBroadcastContentDetails' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LiveBroadcastContentDetails> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LiveBroadcastContentDetails.class));

       return (TypeAdapter<T>) new TypeAdapter<LiveBroadcastContentDetails>() {
           @Override
           public void write(JsonWriter out, LiveBroadcastContentDetails value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LiveBroadcastContentDetails read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LiveBroadcastContentDetails given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LiveBroadcastContentDetails
   * @throws IOException if the JSON string is invalid with respect to LiveBroadcastContentDetails
   */
  public static LiveBroadcastContentDetails fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LiveBroadcastContentDetails.class);
  }

  /**
   * Convert an instance of LiveBroadcastContentDetails to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

