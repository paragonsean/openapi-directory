/*
 * Cloud Video Intelligence API
 * Detects objects, explicit content, and scene changes in videos. It also specifies the region for annotation and transcribes speech to text. Supports both asynchronous API and streaming API.
 *
 * The version of the OpenAPI document: v1p1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Word-specific information for recognized words. Word information is only included in the response when certain request parameters are set, such as &#x60;enable_word_time_offsets&#x60;.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:50:35.281755-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudVideointelligenceV1p2beta1WordInfo {
  public static final String SERIALIZED_NAME_CONFIDENCE = "confidence";
  @SerializedName(SERIALIZED_NAME_CONFIDENCE)
  private Float confidence;

  public static final String SERIALIZED_NAME_END_TIME = "endTime";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private String endTime;

  public static final String SERIALIZED_NAME_SPEAKER_TAG = "speakerTag";
  @SerializedName(SERIALIZED_NAME_SPEAKER_TAG)
  private Integer speakerTag;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private String startTime;

  public static final String SERIALIZED_NAME_WORD = "word";
  @SerializedName(SERIALIZED_NAME_WORD)
  private String word;

  public GoogleCloudVideointelligenceV1p2beta1WordInfo() {
  }

  public GoogleCloudVideointelligenceV1p2beta1WordInfo(
     Float confidence, 
     Integer speakerTag
  ) {
    this();
    this.confidence = confidence;
    this.speakerTag = speakerTag;
  }

  /**
   * Output only. The confidence estimate between 0.0 and 1.0. A higher number indicates an estimated greater likelihood that the recognized words are correct. This field is set only for the top alternative. This field is not guaranteed to be accurate and users should not rely on it to be always provided. The default of 0.0 is a sentinel value indicating &#x60;confidence&#x60; was not set.
   * @return confidence
   */
  @javax.annotation.Nullable
  public Float getConfidence() {
    return confidence;
  }



  public GoogleCloudVideointelligenceV1p2beta1WordInfo endTime(String endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * Time offset relative to the beginning of the audio, and corresponding to the end of the spoken word. This field is only set if &#x60;enable_word_time_offsets&#x3D;true&#x60; and only in the top hypothesis. This is an experimental feature and the accuracy of the time offset can vary.
   * @return endTime
   */
  @javax.annotation.Nullable
  public String getEndTime() {
    return endTime;
  }

  public void setEndTime(String endTime) {
    this.endTime = endTime;
  }


  /**
   * Output only. A distinct integer value is assigned for every speaker within the audio. This field specifies which one of those speakers was detected to have spoken this word. Value ranges from 1 up to diarization_speaker_count, and is only set if speaker diarization is enabled.
   * @return speakerTag
   */
  @javax.annotation.Nullable
  public Integer getSpeakerTag() {
    return speakerTag;
  }



  public GoogleCloudVideointelligenceV1p2beta1WordInfo startTime(String startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Time offset relative to the beginning of the audio, and corresponding to the start of the spoken word. This field is only set if &#x60;enable_word_time_offsets&#x3D;true&#x60; and only in the top hypothesis. This is an experimental feature and the accuracy of the time offset can vary.
   * @return startTime
   */
  @javax.annotation.Nullable
  public String getStartTime() {
    return startTime;
  }

  public void setStartTime(String startTime) {
    this.startTime = startTime;
  }


  public GoogleCloudVideointelligenceV1p2beta1WordInfo word(String word) {
    this.word = word;
    return this;
  }

  /**
   * The word corresponding to this set of information.
   * @return word
   */
  @javax.annotation.Nullable
  public String getWord() {
    return word;
  }

  public void setWord(String word) {
    this.word = word;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudVideointelligenceV1p2beta1WordInfo googleCloudVideointelligenceV1p2beta1WordInfo = (GoogleCloudVideointelligenceV1p2beta1WordInfo) o;
    return Objects.equals(this.confidence, googleCloudVideointelligenceV1p2beta1WordInfo.confidence) &&
        Objects.equals(this.endTime, googleCloudVideointelligenceV1p2beta1WordInfo.endTime) &&
        Objects.equals(this.speakerTag, googleCloudVideointelligenceV1p2beta1WordInfo.speakerTag) &&
        Objects.equals(this.startTime, googleCloudVideointelligenceV1p2beta1WordInfo.startTime) &&
        Objects.equals(this.word, googleCloudVideointelligenceV1p2beta1WordInfo.word);
  }

  @Override
  public int hashCode() {
    return Objects.hash(confidence, endTime, speakerTag, startTime, word);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudVideointelligenceV1p2beta1WordInfo {\n");
    sb.append("    confidence: ").append(toIndentedString(confidence)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    speakerTag: ").append(toIndentedString(speakerTag)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    word: ").append(toIndentedString(word)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("confidence");
    openapiFields.add("endTime");
    openapiFields.add("speakerTag");
    openapiFields.add("startTime");
    openapiFields.add("word");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudVideointelligenceV1p2beta1WordInfo
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudVideointelligenceV1p2beta1WordInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudVideointelligenceV1p2beta1WordInfo is not found in the empty JSON string", GoogleCloudVideointelligenceV1p2beta1WordInfo.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudVideointelligenceV1p2beta1WordInfo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudVideointelligenceV1p2beta1WordInfo` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("endTime") != null && !jsonObj.get("endTime").isJsonNull()) && !jsonObj.get("endTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endTime").toString()));
      }
      if ((jsonObj.get("startTime") != null && !jsonObj.get("startTime").isJsonNull()) && !jsonObj.get("startTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startTime").toString()));
      }
      if ((jsonObj.get("word") != null && !jsonObj.get("word").isJsonNull()) && !jsonObj.get("word").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `word` to be a primitive type in the JSON string but got `%s`", jsonObj.get("word").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudVideointelligenceV1p2beta1WordInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudVideointelligenceV1p2beta1WordInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudVideointelligenceV1p2beta1WordInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudVideointelligenceV1p2beta1WordInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudVideointelligenceV1p2beta1WordInfo>() {
           @Override
           public void write(JsonWriter out, GoogleCloudVideointelligenceV1p2beta1WordInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudVideointelligenceV1p2beta1WordInfo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudVideointelligenceV1p2beta1WordInfo given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudVideointelligenceV1p2beta1WordInfo
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudVideointelligenceV1p2beta1WordInfo
   */
  public static GoogleCloudVideointelligenceV1p2beta1WordInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudVideointelligenceV1p2beta1WordInfo.class);
  }

  /**
   * Convert an instance of GoogleCloudVideointelligenceV1p2beta1WordInfo to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

