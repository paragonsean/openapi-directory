/**
 * API Discovery Service
 * Provides information about other Google APIs, such as what APIs are available, the resource, and method details for each API.
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIJsonSchema.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIJsonSchema::OAIJsonSchema(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIJsonSchema::OAIJsonSchema() {
    this->initializeModel();
}

OAIJsonSchema::~OAIJsonSchema() {}

void OAIJsonSchema::initializeModel() {

    m_ref_isSet = false;
    m_ref_isValid = false;

    m_additional_properties_isSet = false;
    m_additional_properties_isValid = false;

    m_annotations_isSet = false;
    m_annotations_isValid = false;

    m_deprecated_isSet = false;
    m_deprecated_isValid = false;

    m_description_isSet = false;
    m_description_isValid = false;

    m_r_enum_isSet = false;
    m_r_enum_isValid = false;

    m_enum_deprecated_isSet = false;
    m_enum_deprecated_isValid = false;

    m_enum_descriptions_isSet = false;
    m_enum_descriptions_isValid = false;

    m_format_isSet = false;
    m_format_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_items_isSet = false;
    m_items_isValid = false;

    m_location_isSet = false;
    m_location_isValid = false;

    m_maximum_isSet = false;
    m_maximum_isValid = false;

    m_minimum_isSet = false;
    m_minimum_isValid = false;

    m_pattern_isSet = false;
    m_pattern_isValid = false;

    m_properties_isSet = false;
    m_properties_isValid = false;

    m_read_only_isSet = false;
    m_read_only_isValid = false;

    m_repeated_isSet = false;
    m_repeated_isValid = false;

    m_required_isSet = false;
    m_required_isValid = false;

    m_type_isSet = false;
    m_type_isValid = false;

    m_variant_isSet = false;
    m_variant_isValid = false;
}

void OAIJsonSchema::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIJsonSchema::fromJsonObject(QJsonObject json) {

    m_ref_isValid = ::OpenAPI::fromJsonValue(m_ref, json[QString("$ref")]);
    m_ref_isSet = !json[QString("$ref")].isNull() && m_ref_isValid;

    m_additional_properties_isValid = ::OpenAPI::fromJsonValue(m_additional_properties, json[QString("additionalProperties")]);
    m_additional_properties_isSet = !json[QString("additionalProperties")].isNull() && m_additional_properties_isValid;

    m_annotations_isValid = ::OpenAPI::fromJsonValue(m_annotations, json[QString("annotations")]);
    m_annotations_isSet = !json[QString("annotations")].isNull() && m_annotations_isValid;

    m_deprecated_isValid = ::OpenAPI::fromJsonValue(m_deprecated, json[QString("deprecated")]);
    m_deprecated_isSet = !json[QString("deprecated")].isNull() && m_deprecated_isValid;

    m_description_isValid = ::OpenAPI::fromJsonValue(m_description, json[QString("description")]);
    m_description_isSet = !json[QString("description")].isNull() && m_description_isValid;

    m_r_enum_isValid = ::OpenAPI::fromJsonValue(m_r_enum, json[QString("enum")]);
    m_r_enum_isSet = !json[QString("enum")].isNull() && m_r_enum_isValid;

    m_enum_deprecated_isValid = ::OpenAPI::fromJsonValue(m_enum_deprecated, json[QString("enumDeprecated")]);
    m_enum_deprecated_isSet = !json[QString("enumDeprecated")].isNull() && m_enum_deprecated_isValid;

    m_enum_descriptions_isValid = ::OpenAPI::fromJsonValue(m_enum_descriptions, json[QString("enumDescriptions")]);
    m_enum_descriptions_isSet = !json[QString("enumDescriptions")].isNull() && m_enum_descriptions_isValid;

    m_format_isValid = ::OpenAPI::fromJsonValue(m_format, json[QString("format")]);
    m_format_isSet = !json[QString("format")].isNull() && m_format_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_items_isValid = ::OpenAPI::fromJsonValue(m_items, json[QString("items")]);
    m_items_isSet = !json[QString("items")].isNull() && m_items_isValid;

    m_location_isValid = ::OpenAPI::fromJsonValue(m_location, json[QString("location")]);
    m_location_isSet = !json[QString("location")].isNull() && m_location_isValid;

    m_maximum_isValid = ::OpenAPI::fromJsonValue(m_maximum, json[QString("maximum")]);
    m_maximum_isSet = !json[QString("maximum")].isNull() && m_maximum_isValid;

    m_minimum_isValid = ::OpenAPI::fromJsonValue(m_minimum, json[QString("minimum")]);
    m_minimum_isSet = !json[QString("minimum")].isNull() && m_minimum_isValid;

    m_pattern_isValid = ::OpenAPI::fromJsonValue(m_pattern, json[QString("pattern")]);
    m_pattern_isSet = !json[QString("pattern")].isNull() && m_pattern_isValid;

    m_properties_isValid = ::OpenAPI::fromJsonValue(m_properties, json[QString("properties")]);
    m_properties_isSet = !json[QString("properties")].isNull() && m_properties_isValid;

    m_read_only_isValid = ::OpenAPI::fromJsonValue(m_read_only, json[QString("readOnly")]);
    m_read_only_isSet = !json[QString("readOnly")].isNull() && m_read_only_isValid;

    m_repeated_isValid = ::OpenAPI::fromJsonValue(m_repeated, json[QString("repeated")]);
    m_repeated_isSet = !json[QString("repeated")].isNull() && m_repeated_isValid;

    m_required_isValid = ::OpenAPI::fromJsonValue(m_required, json[QString("required")]);
    m_required_isSet = !json[QString("required")].isNull() && m_required_isValid;

    m_type_isValid = ::OpenAPI::fromJsonValue(m_type, json[QString("type")]);
    m_type_isSet = !json[QString("type")].isNull() && m_type_isValid;

    m_variant_isValid = ::OpenAPI::fromJsonValue(m_variant, json[QString("variant")]);
    m_variant_isSet = !json[QString("variant")].isNull() && m_variant_isValid;
}

QString OAIJsonSchema::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIJsonSchema::asJsonObject() const {
    QJsonObject obj;
    if (m_ref_isSet) {
        obj.insert(QString("$ref"), ::OpenAPI::toJsonValue(m_ref));
    }
    if (m_additional_properties.isSet()) {
        obj.insert(QString("additionalProperties"), ::OpenAPI::toJsonValue(m_additional_properties));
    }
    if (m_annotations.isSet()) {
        obj.insert(QString("annotations"), ::OpenAPI::toJsonValue(m_annotations));
    }
    if (m_deprecated_isSet) {
        obj.insert(QString("deprecated"), ::OpenAPI::toJsonValue(m_deprecated));
    }
    if (m_description_isSet) {
        obj.insert(QString("description"), ::OpenAPI::toJsonValue(m_description));
    }
    if (m_r_enum.size() > 0) {
        obj.insert(QString("enum"), ::OpenAPI::toJsonValue(m_r_enum));
    }
    if (m_enum_deprecated.size() > 0) {
        obj.insert(QString("enumDeprecated"), ::OpenAPI::toJsonValue(m_enum_deprecated));
    }
    if (m_enum_descriptions.size() > 0) {
        obj.insert(QString("enumDescriptions"), ::OpenAPI::toJsonValue(m_enum_descriptions));
    }
    if (m_format_isSet) {
        obj.insert(QString("format"), ::OpenAPI::toJsonValue(m_format));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_items.isSet()) {
        obj.insert(QString("items"), ::OpenAPI::toJsonValue(m_items));
    }
    if (m_location_isSet) {
        obj.insert(QString("location"), ::OpenAPI::toJsonValue(m_location));
    }
    if (m_maximum_isSet) {
        obj.insert(QString("maximum"), ::OpenAPI::toJsonValue(m_maximum));
    }
    if (m_minimum_isSet) {
        obj.insert(QString("minimum"), ::OpenAPI::toJsonValue(m_minimum));
    }
    if (m_pattern_isSet) {
        obj.insert(QString("pattern"), ::OpenAPI::toJsonValue(m_pattern));
    }
    if (m_properties.size() > 0) {
        obj.insert(QString("properties"), ::OpenAPI::toJsonValue(m_properties));
    }
    if (m_read_only_isSet) {
        obj.insert(QString("readOnly"), ::OpenAPI::toJsonValue(m_read_only));
    }
    if (m_repeated_isSet) {
        obj.insert(QString("repeated"), ::OpenAPI::toJsonValue(m_repeated));
    }
    if (m_required_isSet) {
        obj.insert(QString("required"), ::OpenAPI::toJsonValue(m_required));
    }
    if (m_type_isSet) {
        obj.insert(QString("type"), ::OpenAPI::toJsonValue(m_type));
    }
    if (m_variant.isSet()) {
        obj.insert(QString("variant"), ::OpenAPI::toJsonValue(m_variant));
    }
    return obj;
}

QString OAIJsonSchema::getRef() const {
    return m_ref;
}
void OAIJsonSchema::setRef(const QString &ref) {
    m_ref = ref;
    m_ref_isSet = true;
}

bool OAIJsonSchema::is_ref_Set() const{
    return m_ref_isSet;
}

bool OAIJsonSchema::is_ref_Valid() const{
    return m_ref_isValid;
}

OAIJsonSchema OAIJsonSchema::getAdditionalProperties() const {
    return m_additional_properties;
}
void OAIJsonSchema::setAdditionalProperties(const OAIJsonSchema &additional_properties) {
    m_additional_properties = additional_properties;
    m_additional_properties_isSet = true;
}

bool OAIJsonSchema::is_additional_properties_Set() const{
    return m_additional_properties_isSet;
}

bool OAIJsonSchema::is_additional_properties_Valid() const{
    return m_additional_properties_isValid;
}

OAIJsonSchema_annotations OAIJsonSchema::getAnnotations() const {
    return m_annotations;
}
void OAIJsonSchema::setAnnotations(const OAIJsonSchema_annotations &annotations) {
    m_annotations = annotations;
    m_annotations_isSet = true;
}

bool OAIJsonSchema::is_annotations_Set() const{
    return m_annotations_isSet;
}

bool OAIJsonSchema::is_annotations_Valid() const{
    return m_annotations_isValid;
}

bool OAIJsonSchema::isDeprecated() const {
    return m_deprecated;
}
void OAIJsonSchema::setDeprecated(const bool &deprecated) {
    m_deprecated = deprecated;
    m_deprecated_isSet = true;
}

bool OAIJsonSchema::is_deprecated_Set() const{
    return m_deprecated_isSet;
}

bool OAIJsonSchema::is_deprecated_Valid() const{
    return m_deprecated_isValid;
}

QString OAIJsonSchema::getDescription() const {
    return m_description;
}
void OAIJsonSchema::setDescription(const QString &description) {
    m_description = description;
    m_description_isSet = true;
}

bool OAIJsonSchema::is_description_Set() const{
    return m_description_isSet;
}

bool OAIJsonSchema::is_description_Valid() const{
    return m_description_isValid;
}

QList<QString> OAIJsonSchema::getREnum() const {
    return m_r_enum;
}
void OAIJsonSchema::setREnum(const QList<QString> &r_enum) {
    m_r_enum = r_enum;
    m_r_enum_isSet = true;
}

bool OAIJsonSchema::is_r_enum_Set() const{
    return m_r_enum_isSet;
}

bool OAIJsonSchema::is_r_enum_Valid() const{
    return m_r_enum_isValid;
}

QList<bool> OAIJsonSchema::getEnumDeprecated() const {
    return m_enum_deprecated;
}
void OAIJsonSchema::setEnumDeprecated(const QList<bool> &enum_deprecated) {
    m_enum_deprecated = enum_deprecated;
    m_enum_deprecated_isSet = true;
}

bool OAIJsonSchema::is_enum_deprecated_Set() const{
    return m_enum_deprecated_isSet;
}

bool OAIJsonSchema::is_enum_deprecated_Valid() const{
    return m_enum_deprecated_isValid;
}

QList<QString> OAIJsonSchema::getEnumDescriptions() const {
    return m_enum_descriptions;
}
void OAIJsonSchema::setEnumDescriptions(const QList<QString> &enum_descriptions) {
    m_enum_descriptions = enum_descriptions;
    m_enum_descriptions_isSet = true;
}

bool OAIJsonSchema::is_enum_descriptions_Set() const{
    return m_enum_descriptions_isSet;
}

bool OAIJsonSchema::is_enum_descriptions_Valid() const{
    return m_enum_descriptions_isValid;
}

QString OAIJsonSchema::getFormat() const {
    return m_format;
}
void OAIJsonSchema::setFormat(const QString &format) {
    m_format = format;
    m_format_isSet = true;
}

bool OAIJsonSchema::is_format_Set() const{
    return m_format_isSet;
}

bool OAIJsonSchema::is_format_Valid() const{
    return m_format_isValid;
}

QString OAIJsonSchema::getId() const {
    return m_id;
}
void OAIJsonSchema::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIJsonSchema::is_id_Set() const{
    return m_id_isSet;
}

bool OAIJsonSchema::is_id_Valid() const{
    return m_id_isValid;
}

OAIJsonSchema OAIJsonSchema::getItems() const {
    return m_items;
}
void OAIJsonSchema::setItems(const OAIJsonSchema &items) {
    m_items = items;
    m_items_isSet = true;
}

bool OAIJsonSchema::is_items_Set() const{
    return m_items_isSet;
}

bool OAIJsonSchema::is_items_Valid() const{
    return m_items_isValid;
}

QString OAIJsonSchema::getLocation() const {
    return m_location;
}
void OAIJsonSchema::setLocation(const QString &location) {
    m_location = location;
    m_location_isSet = true;
}

bool OAIJsonSchema::is_location_Set() const{
    return m_location_isSet;
}

bool OAIJsonSchema::is_location_Valid() const{
    return m_location_isValid;
}

QString OAIJsonSchema::getMaximum() const {
    return m_maximum;
}
void OAIJsonSchema::setMaximum(const QString &maximum) {
    m_maximum = maximum;
    m_maximum_isSet = true;
}

bool OAIJsonSchema::is_maximum_Set() const{
    return m_maximum_isSet;
}

bool OAIJsonSchema::is_maximum_Valid() const{
    return m_maximum_isValid;
}

QString OAIJsonSchema::getMinimum() const {
    return m_minimum;
}
void OAIJsonSchema::setMinimum(const QString &minimum) {
    m_minimum = minimum;
    m_minimum_isSet = true;
}

bool OAIJsonSchema::is_minimum_Set() const{
    return m_minimum_isSet;
}

bool OAIJsonSchema::is_minimum_Valid() const{
    return m_minimum_isValid;
}

QString OAIJsonSchema::getPattern() const {
    return m_pattern;
}
void OAIJsonSchema::setPattern(const QString &pattern) {
    m_pattern = pattern;
    m_pattern_isSet = true;
}

bool OAIJsonSchema::is_pattern_Set() const{
    return m_pattern_isSet;
}

bool OAIJsonSchema::is_pattern_Valid() const{
    return m_pattern_isValid;
}

QMap<QString, OAIJsonSchema> OAIJsonSchema::getProperties() const {
    return m_properties;
}
void OAIJsonSchema::setProperties(const QMap<QString, OAIJsonSchema> &properties) {
    m_properties = properties;
    m_properties_isSet = true;
}

bool OAIJsonSchema::is_properties_Set() const{
    return m_properties_isSet;
}

bool OAIJsonSchema::is_properties_Valid() const{
    return m_properties_isValid;
}

bool OAIJsonSchema::isReadOnly() const {
    return m_read_only;
}
void OAIJsonSchema::setReadOnly(const bool &read_only) {
    m_read_only = read_only;
    m_read_only_isSet = true;
}

bool OAIJsonSchema::is_read_only_Set() const{
    return m_read_only_isSet;
}

bool OAIJsonSchema::is_read_only_Valid() const{
    return m_read_only_isValid;
}

bool OAIJsonSchema::isRepeated() const {
    return m_repeated;
}
void OAIJsonSchema::setRepeated(const bool &repeated) {
    m_repeated = repeated;
    m_repeated_isSet = true;
}

bool OAIJsonSchema::is_repeated_Set() const{
    return m_repeated_isSet;
}

bool OAIJsonSchema::is_repeated_Valid() const{
    return m_repeated_isValid;
}

bool OAIJsonSchema::isRequired() const {
    return m_required;
}
void OAIJsonSchema::setRequired(const bool &required) {
    m_required = required;
    m_required_isSet = true;
}

bool OAIJsonSchema::is_required_Set() const{
    return m_required_isSet;
}

bool OAIJsonSchema::is_required_Valid() const{
    return m_required_isValid;
}

QString OAIJsonSchema::getType() const {
    return m_type;
}
void OAIJsonSchema::setType(const QString &type) {
    m_type = type;
    m_type_isSet = true;
}

bool OAIJsonSchema::is_type_Set() const{
    return m_type_isSet;
}

bool OAIJsonSchema::is_type_Valid() const{
    return m_type_isValid;
}

OAIJsonSchema_variant OAIJsonSchema::getVariant() const {
    return m_variant;
}
void OAIJsonSchema::setVariant(const OAIJsonSchema_variant &variant) {
    m_variant = variant;
    m_variant_isSet = true;
}

bool OAIJsonSchema::is_variant_Set() const{
    return m_variant_isSet;
}

bool OAIJsonSchema::is_variant_Valid() const{
    return m_variant_isValid;
}

bool OAIJsonSchema::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_ref_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_additional_properties.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_annotations.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_deprecated_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_description_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_r_enum.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_enum_deprecated.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_enum_descriptions.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_format_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_items.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_location_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_maximum_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_minimum_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pattern_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_properties.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_only_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_repeated_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_required_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_variant.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIJsonSchema::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
