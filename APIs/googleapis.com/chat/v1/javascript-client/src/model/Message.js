/**
 * Google Chat API
 * The Google Chat API lets you build Chat apps to integrate your services with Google Chat and manage Chat resources such as spaces, members, and messages.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import ActionResponse from './ActionResponse';
import Annotation from './Annotation';
import AttachedGif from './AttachedGif';
import Attachment from './Attachment';
import Card from './Card';
import CardWithId from './CardWithId';
import DeletionMetadata from './DeletionMetadata';
import EmojiReactionSummary from './EmojiReactionSummary';
import MatchedUrl from './MatchedUrl';
import QuotedMessageMetadata from './QuotedMessageMetadata';
import SlashCommand from './SlashCommand';
import Space from './Space';
import Thread from './Thread';
import User from './User';

/**
 * The Message model module.
 * @module model/Message
 * @version v1
 */
class Message {
    /**
     * Constructs a new <code>Message</code>.
     * A message in a Google Chat space.
     * @alias module:model/Message
     */
    constructor() { 
        
        Message.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Message</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Message} obj Optional instance to populate.
     * @return {module:model/Message} The populated <code>Message</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Message();

            if (data.hasOwnProperty('actionResponse')) {
                obj['actionResponse'] = ActionResponse.constructFromObject(data['actionResponse']);
            }
            if (data.hasOwnProperty('annotations')) {
                obj['annotations'] = ApiClient.convertToType(data['annotations'], [Annotation]);
            }
            if (data.hasOwnProperty('argumentText')) {
                obj['argumentText'] = ApiClient.convertToType(data['argumentText'], 'String');
            }
            if (data.hasOwnProperty('attachedGifs')) {
                obj['attachedGifs'] = ApiClient.convertToType(data['attachedGifs'], [AttachedGif]);
            }
            if (data.hasOwnProperty('attachment')) {
                obj['attachment'] = ApiClient.convertToType(data['attachment'], [Attachment]);
            }
            if (data.hasOwnProperty('cards')) {
                obj['cards'] = ApiClient.convertToType(data['cards'], [Card]);
            }
            if (data.hasOwnProperty('cardsV2')) {
                obj['cardsV2'] = ApiClient.convertToType(data['cardsV2'], [CardWithId]);
            }
            if (data.hasOwnProperty('clientAssignedMessageId')) {
                obj['clientAssignedMessageId'] = ApiClient.convertToType(data['clientAssignedMessageId'], 'String');
            }
            if (data.hasOwnProperty('createTime')) {
                obj['createTime'] = ApiClient.convertToType(data['createTime'], 'String');
            }
            if (data.hasOwnProperty('deleteTime')) {
                obj['deleteTime'] = ApiClient.convertToType(data['deleteTime'], 'String');
            }
            if (data.hasOwnProperty('deletionMetadata')) {
                obj['deletionMetadata'] = DeletionMetadata.constructFromObject(data['deletionMetadata']);
            }
            if (data.hasOwnProperty('emojiReactionSummaries')) {
                obj['emojiReactionSummaries'] = ApiClient.convertToType(data['emojiReactionSummaries'], [EmojiReactionSummary]);
            }
            if (data.hasOwnProperty('fallbackText')) {
                obj['fallbackText'] = ApiClient.convertToType(data['fallbackText'], 'String');
            }
            if (data.hasOwnProperty('formattedText')) {
                obj['formattedText'] = ApiClient.convertToType(data['formattedText'], 'String');
            }
            if (data.hasOwnProperty('lastUpdateTime')) {
                obj['lastUpdateTime'] = ApiClient.convertToType(data['lastUpdateTime'], 'String');
            }
            if (data.hasOwnProperty('matchedUrl')) {
                obj['matchedUrl'] = MatchedUrl.constructFromObject(data['matchedUrl']);
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('privateMessageViewer')) {
                obj['privateMessageViewer'] = User.constructFromObject(data['privateMessageViewer']);
            }
            if (data.hasOwnProperty('quotedMessageMetadata')) {
                obj['quotedMessageMetadata'] = QuotedMessageMetadata.constructFromObject(data['quotedMessageMetadata']);
            }
            if (data.hasOwnProperty('sender')) {
                obj['sender'] = User.constructFromObject(data['sender']);
            }
            if (data.hasOwnProperty('slashCommand')) {
                obj['slashCommand'] = SlashCommand.constructFromObject(data['slashCommand']);
            }
            if (data.hasOwnProperty('space')) {
                obj['space'] = Space.constructFromObject(data['space']);
            }
            if (data.hasOwnProperty('text')) {
                obj['text'] = ApiClient.convertToType(data['text'], 'String');
            }
            if (data.hasOwnProperty('thread')) {
                obj['thread'] = Thread.constructFromObject(data['thread']);
            }
            if (data.hasOwnProperty('threadReply')) {
                obj['threadReply'] = ApiClient.convertToType(data['threadReply'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Message</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Message</code>.
     */
    static validateJSON(data) {
        // validate the optional field `actionResponse`
        if (data['actionResponse']) { // data not null
          ActionResponse.validateJSON(data['actionResponse']);
        }
        if (data['annotations']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['annotations'])) {
                throw new Error("Expected the field `annotations` to be an array in the JSON data but got " + data['annotations']);
            }
            // validate the optional field `annotations` (array)
            for (const item of data['annotations']) {
                Annotation.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['argumentText'] && !(typeof data['argumentText'] === 'string' || data['argumentText'] instanceof String)) {
            throw new Error("Expected the field `argumentText` to be a primitive type in the JSON string but got " + data['argumentText']);
        }
        if (data['attachedGifs']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['attachedGifs'])) {
                throw new Error("Expected the field `attachedGifs` to be an array in the JSON data but got " + data['attachedGifs']);
            }
            // validate the optional field `attachedGifs` (array)
            for (const item of data['attachedGifs']) {
                AttachedGif.validateJSON(item);
            };
        }
        if (data['attachment']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['attachment'])) {
                throw new Error("Expected the field `attachment` to be an array in the JSON data but got " + data['attachment']);
            }
            // validate the optional field `attachment` (array)
            for (const item of data['attachment']) {
                Attachment.validateJSON(item);
            };
        }
        if (data['cards']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['cards'])) {
                throw new Error("Expected the field `cards` to be an array in the JSON data but got " + data['cards']);
            }
            // validate the optional field `cards` (array)
            for (const item of data['cards']) {
                Card.validateJSON(item);
            };
        }
        if (data['cardsV2']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['cardsV2'])) {
                throw new Error("Expected the field `cardsV2` to be an array in the JSON data but got " + data['cardsV2']);
            }
            // validate the optional field `cardsV2` (array)
            for (const item of data['cardsV2']) {
                CardWithId.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['clientAssignedMessageId'] && !(typeof data['clientAssignedMessageId'] === 'string' || data['clientAssignedMessageId'] instanceof String)) {
            throw new Error("Expected the field `clientAssignedMessageId` to be a primitive type in the JSON string but got " + data['clientAssignedMessageId']);
        }
        // ensure the json data is a string
        if (data['createTime'] && !(typeof data['createTime'] === 'string' || data['createTime'] instanceof String)) {
            throw new Error("Expected the field `createTime` to be a primitive type in the JSON string but got " + data['createTime']);
        }
        // ensure the json data is a string
        if (data['deleteTime'] && !(typeof data['deleteTime'] === 'string' || data['deleteTime'] instanceof String)) {
            throw new Error("Expected the field `deleteTime` to be a primitive type in the JSON string but got " + data['deleteTime']);
        }
        // validate the optional field `deletionMetadata`
        if (data['deletionMetadata']) { // data not null
          DeletionMetadata.validateJSON(data['deletionMetadata']);
        }
        if (data['emojiReactionSummaries']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['emojiReactionSummaries'])) {
                throw new Error("Expected the field `emojiReactionSummaries` to be an array in the JSON data but got " + data['emojiReactionSummaries']);
            }
            // validate the optional field `emojiReactionSummaries` (array)
            for (const item of data['emojiReactionSummaries']) {
                EmojiReactionSummary.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['fallbackText'] && !(typeof data['fallbackText'] === 'string' || data['fallbackText'] instanceof String)) {
            throw new Error("Expected the field `fallbackText` to be a primitive type in the JSON string but got " + data['fallbackText']);
        }
        // ensure the json data is a string
        if (data['formattedText'] && !(typeof data['formattedText'] === 'string' || data['formattedText'] instanceof String)) {
            throw new Error("Expected the field `formattedText` to be a primitive type in the JSON string but got " + data['formattedText']);
        }
        // ensure the json data is a string
        if (data['lastUpdateTime'] && !(typeof data['lastUpdateTime'] === 'string' || data['lastUpdateTime'] instanceof String)) {
            throw new Error("Expected the field `lastUpdateTime` to be a primitive type in the JSON string but got " + data['lastUpdateTime']);
        }
        // validate the optional field `matchedUrl`
        if (data['matchedUrl']) { // data not null
          MatchedUrl.validateJSON(data['matchedUrl']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // validate the optional field `privateMessageViewer`
        if (data['privateMessageViewer']) { // data not null
          User.validateJSON(data['privateMessageViewer']);
        }
        // validate the optional field `quotedMessageMetadata`
        if (data['quotedMessageMetadata']) { // data not null
          QuotedMessageMetadata.validateJSON(data['quotedMessageMetadata']);
        }
        // validate the optional field `sender`
        if (data['sender']) { // data not null
          User.validateJSON(data['sender']);
        }
        // validate the optional field `slashCommand`
        if (data['slashCommand']) { // data not null
          SlashCommand.validateJSON(data['slashCommand']);
        }
        // validate the optional field `space`
        if (data['space']) { // data not null
          Space.validateJSON(data['space']);
        }
        // ensure the json data is a string
        if (data['text'] && !(typeof data['text'] === 'string' || data['text'] instanceof String)) {
            throw new Error("Expected the field `text` to be a primitive type in the JSON string but got " + data['text']);
        }
        // validate the optional field `thread`
        if (data['thread']) { // data not null
          Thread.validateJSON(data['thread']);
        }

        return true;
    }


}



/**
 * @member {module:model/ActionResponse} actionResponse
 */
Message.prototype['actionResponse'] = undefined;

/**
 * Output only. Annotations associated with the `text` in this message.
 * @member {Array.<module:model/Annotation>} annotations
 */
Message.prototype['annotations'] = undefined;

/**
 * Output only. Plain-text body of the message with all Chat app mentions stripped out.
 * @member {String} argumentText
 */
Message.prototype['argumentText'] = undefined;

/**
 * Output only. GIF images that are attached to the message.
 * @member {Array.<module:model/AttachedGif>} attachedGifs
 */
Message.prototype['attachedGifs'] = undefined;

/**
 * User-uploaded attachment.
 * @member {Array.<module:model/Attachment>} attachment
 */
Message.prototype['attachment'] = undefined;

/**
 * Deprecated: Use `cards_v2` instead. Rich, formatted, and interactive cards that you can use to display UI elements such as: formatted texts, buttons, and clickable images. Cards are normally displayed below the plain-text body of the message. `cards` and `cards_v2` can have a maximum size of 32 KB.
 * @member {Array.<module:model/Card>} cards
 */
Message.prototype['cards'] = undefined;

/**
 * An array of [cards](https://developers.google.com/chat/api/reference/rest/v1/cards). Only Chat apps can create cards. If your Chat app [authenticates as a user](https://developers.google.com/chat/api/guides/auth/users), the messages can't contain cards. To learn about cards and how to create them, see [Design dynamic, interactive, and consistent UIs with cards](https://developers.google.com/chat/ui). [Card builder](https://addons.gsuite.google.com/uikit/builder)
 * @member {Array.<module:model/CardWithId>} cardsV2
 */
Message.prototype['cardsV2'] = undefined;

/**
 * Optional. A custom ID for the message. You can use field to identify a message, or to get, delete, or update a message. To set a custom ID, specify the [`messageId`](https://developers.google.com/chat/api/reference/rest/v1/spaces.messages/create#body.QUERY_PARAMETERS.message_id) field when you create the message. For details, see [Name a message](https://developers.google.com/chat/api/guides/v1/messages/create#name_a_created_message).
 * @member {String} clientAssignedMessageId
 */
Message.prototype['clientAssignedMessageId'] = undefined;

/**
 * Optional. Immutable. For spaces created in Chat, the time at which the message was created. This field is output only, except when used in import mode spaces. For import mode spaces, set this field to the historical timestamp at which the message was created in the source in order to preserve the original creation time.
 * @member {String} createTime
 */
Message.prototype['createTime'] = undefined;

/**
 * Output only. The time at which the message was deleted in Google Chat. If the message is never deleted, this field is empty.
 * @member {String} deleteTime
 */
Message.prototype['deleteTime'] = undefined;

/**
 * @member {module:model/DeletionMetadata} deletionMetadata
 */
Message.prototype['deletionMetadata'] = undefined;

/**
 * Output only. The list of emoji reaction summaries on the message.
 * @member {Array.<module:model/EmojiReactionSummary>} emojiReactionSummaries
 */
Message.prototype['emojiReactionSummaries'] = undefined;

/**
 * A plain-text description of the message's cards, used when the actual cards can't be displayed—for example, mobile notifications.
 * @member {String} fallbackText
 */
Message.prototype['fallbackText'] = undefined;

/**
 * Output only. Contains the message `text` with markups added to communicate formatting. This field might not capture all formatting visible in the UI, but includes the following: * [Markup syntax](https://developers.google.com/chat/format-messages) for bold, italic, strikethrough, monospace, and monospace block. * [User mentions](https://developers.google.com/chat/format-messages#messages-@mention) using the format ``. * Custom hyperlinks using the format `<{url}|{rendered_text}>` where the first string is the URL and the second is the rendered text—for example, ``. * Custom emoji using the format `:{emoji_name}:`—for example, `:smile:`. This doesn't apply to Unicode emoji, such as `U+1F600` for a grinning face emoji. For more information, see [View text formatting sent in a message](https://developers.google.com/chat/format-messages#view_text_formatting_sent_in_a_message)
 * @member {String} formattedText
 */
Message.prototype['formattedText'] = undefined;

/**
 * Output only. The time at which the message was last edited by a user. If the message has never been edited, this field is empty.
 * @member {String} lastUpdateTime
 */
Message.prototype['lastUpdateTime'] = undefined;

/**
 * @member {module:model/MatchedUrl} matchedUrl
 */
Message.prototype['matchedUrl'] = undefined;

/**
 * Resource name of the message. Format: `spaces/{space}/messages/{message}` Where `{space}` is the ID of the space where the message is posted and `{message}` is a system-assigned ID for the message. For example, `spaces/AAAAAAAAAAA/messages/BBBBBBBBBBB.BBBBBBBBBBB`. If you set a custom ID when you create a message, you can use this ID to specify the message in a request by replacing `{message}` with the value from the `clientAssignedMessageId` field. For example, `spaces/AAAAAAAAAAA/messages/client-custom-name`. For details, see [Name a message](https://developers.google.com/chat/api/guides/v1/messages/create#name_a_created_message).
 * @member {String} name
 */
Message.prototype['name'] = undefined;

/**
 * @member {module:model/User} privateMessageViewer
 */
Message.prototype['privateMessageViewer'] = undefined;

/**
 * @member {module:model/QuotedMessageMetadata} quotedMessageMetadata
 */
Message.prototype['quotedMessageMetadata'] = undefined;

/**
 * @member {module:model/User} sender
 */
Message.prototype['sender'] = undefined;

/**
 * @member {module:model/SlashCommand} slashCommand
 */
Message.prototype['slashCommand'] = undefined;

/**
 * @member {module:model/Space} space
 */
Message.prototype['space'] = undefined;

/**
 * Plain-text body of the message. The first link to an image, video, or web page generates a [preview chip](https://developers.google.com/chat/how-tos/preview-links). You can also [@mention a Google Chat user](https://developers.google.com/chat/format-messages#messages-@mention), or everyone in the space. To learn about creating text messages, see [Send a text message](https://developers.google.com/chat/api/guides/v1/messages/create#create-text-messages).
 * @member {String} text
 */
Message.prototype['text'] = undefined;

/**
 * @member {module:model/Thread} thread
 */
Message.prototype['thread'] = undefined;

/**
 * Output only. When `true`, the message is a response in a reply thread. When `false`, the message is visible in the space's top-level conversation as either the first message of a thread or a message with no threaded replies. If the space doesn't support reply in threads, this field is always `false`.
 * @member {Boolean} threadReply
 */
Message.prototype['threadReply'] = undefined;






export default Message;

