/*
 * Google Chat API
 * The Google Chat API lets you build Chat apps to integrate your services with Google Chat and manage Chat resources such as spaces, members, and messages.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.SpaceDetails;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A space in Google Chat. Spaces are conversations between two or more users or 1:1 messages between a user and a Chat app.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:45.023335-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Space {
  public static final String SERIALIZED_NAME_ADMIN_INSTALLED = "adminInstalled";
  @SerializedName(SERIALIZED_NAME_ADMIN_INSTALLED)
  private Boolean adminInstalled;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_EXTERNAL_USER_ALLOWED = "externalUserAllowed";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_USER_ALLOWED)
  private Boolean externalUserAllowed;

  public static final String SERIALIZED_NAME_IMPORT_MODE = "importMode";
  @SerializedName(SERIALIZED_NAME_IMPORT_MODE)
  private Boolean importMode;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SINGLE_USER_BOT_DM = "singleUserBotDm";
  @SerializedName(SERIALIZED_NAME_SINGLE_USER_BOT_DM)
  private Boolean singleUserBotDm;

  public static final String SERIALIZED_NAME_SPACE_DETAILS = "spaceDetails";
  @SerializedName(SERIALIZED_NAME_SPACE_DETAILS)
  private SpaceDetails spaceDetails;

  /**
   * The message history state for messages and threads in this space.
   */
  @JsonAdapter(SpaceHistoryStateEnum.Adapter.class)
  public enum SpaceHistoryStateEnum {
    STATE_UNSPECIFIED("HISTORY_STATE_UNSPECIFIED"),
    
    OFF("HISTORY_OFF"),
    
    ON("HISTORY_ON");

    private String value;

    SpaceHistoryStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SpaceHistoryStateEnum fromValue(String value) {
      for (SpaceHistoryStateEnum b : SpaceHistoryStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SpaceHistoryStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SpaceHistoryStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SpaceHistoryStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SpaceHistoryStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SpaceHistoryStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SPACE_HISTORY_STATE = "spaceHistoryState";
  @SerializedName(SERIALIZED_NAME_SPACE_HISTORY_STATE)
  private SpaceHistoryStateEnum spaceHistoryState;

  /**
   * Output only. The threading state in the Chat space.
   */
  @JsonAdapter(SpaceThreadingStateEnum.Adapter.class)
  public enum SpaceThreadingStateEnum {
    SPACE_THREADING_STATE_UNSPECIFIED("SPACE_THREADING_STATE_UNSPECIFIED"),
    
    THREADED_MESSAGES("THREADED_MESSAGES"),
    
    GROUPED_MESSAGES("GROUPED_MESSAGES"),
    
    UNTHREADED_MESSAGES("UNTHREADED_MESSAGES");

    private String value;

    SpaceThreadingStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SpaceThreadingStateEnum fromValue(String value) {
      for (SpaceThreadingStateEnum b : SpaceThreadingStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SpaceThreadingStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SpaceThreadingStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SpaceThreadingStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SpaceThreadingStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SpaceThreadingStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SPACE_THREADING_STATE = "spaceThreadingState";
  @SerializedName(SERIALIZED_NAME_SPACE_THREADING_STATE)
  private SpaceThreadingStateEnum spaceThreadingState;

  /**
   * The type of space. Required when creating a space or updating the space type of a space. Output only for other usage.
   */
  @JsonAdapter(SpaceTypeEnum.Adapter.class)
  public enum SpaceTypeEnum {
    SPACE_TYPE_UNSPECIFIED("SPACE_TYPE_UNSPECIFIED"),
    
    SPACE("SPACE"),
    
    GROUP_CHAT("GROUP_CHAT"),
    
    DIRECT_MESSAGE("DIRECT_MESSAGE");

    private String value;

    SpaceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SpaceTypeEnum fromValue(String value) {
      for (SpaceTypeEnum b : SpaceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SpaceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SpaceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SpaceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SpaceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SpaceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SPACE_TYPE = "spaceType";
  @SerializedName(SERIALIZED_NAME_SPACE_TYPE)
  private SpaceTypeEnum spaceType;

  public static final String SERIALIZED_NAME_THREADED = "threaded";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_THREADED)
  private Boolean threaded;

  /**
   * Output only. Deprecated: Use &#x60;space_type&#x60; instead. The type of a space.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    TYPE_UNSPECIFIED("TYPE_UNSPECIFIED"),
    
    ROOM("ROOM"),
    
    DM("DM");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public Space() {
  }

  public Space(
     Boolean adminInstalled, 
     SpaceThreadingStateEnum spaceThreadingState, 
     Boolean threaded, 
     TypeEnum type
  ) {
    this();
    this.adminInstalled = adminInstalled;
    this.spaceThreadingState = spaceThreadingState;
    this.threaded = threaded;
    this.type = type;
  }

  /**
   * Output only. Whether the Chat app was installed by a Google Workspace administrator. Administrators can install a Chat app for their domain, organizational unit, or a group of users. Administrators can only install Chat apps for direct messaging between users and the app. To support admin install, your app must feature direct messaging.
   * @return adminInstalled
   */
  @javax.annotation.Nullable
  public Boolean getAdminInstalled() {
    return adminInstalled;
  }



  public Space createTime(String createTime) {
    this.createTime = createTime;
    return this;
  }

  /**
   * Optional. Immutable. For spaces created in Chat, the time the space was created. This field is output only, except when used in import mode spaces. For import mode spaces, set this field to the historical timestamp at which the space was created in the source in order to preserve the original creation time. Only populated in the output when &#x60;spaceType&#x60; is &#x60;GROUP_CHAT&#x60; or &#x60;SPACE&#x60;.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }

  public void setCreateTime(String createTime) {
    this.createTime = createTime;
  }


  public Space displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * The space&#39;s display name. Required when [creating a space](https://developers.google.com/chat/api/reference/rest/v1/spaces/create). If you receive the error message &#x60;ALREADY_EXISTS&#x60; when creating a space or updating the &#x60;displayName&#x60;, try a different &#x60;displayName&#x60;. An existing space within the Google Workspace organization might already use this display name. For direct messages, this field might be empty. Supports up to 128 characters.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public Space externalUserAllowed(Boolean externalUserAllowed) {
    this.externalUserAllowed = externalUserAllowed;
    return this;
  }

  /**
   * Immutable. Whether this space permits any Google Chat user as a member. Input when creating a space in a Google Workspace organization. Omit this field when creating spaces in the following conditions: * The authenticated user uses a Google Account. By default, the space permits any Google Chat user. * The space is used to [import data to Google Chat] (https://developers.google.com/chat/api/guides/import-data-overview). Import mode spaces must only permit members from the same Google Workspace organization. For existing spaces, this field is output only.
   * @return externalUserAllowed
   */
  @javax.annotation.Nullable
  public Boolean getExternalUserAllowed() {
    return externalUserAllowed;
  }

  public void setExternalUserAllowed(Boolean externalUserAllowed) {
    this.externalUserAllowed = externalUserAllowed;
  }


  public Space importMode(Boolean importMode) {
    this.importMode = importMode;
    return this;
  }

  /**
   * Optional. Whether this space is created in &#x60;Import Mode&#x60; as part of a data migration into Google Workspace. While spaces are being imported, they aren&#39;t visible to users until the import is complete.
   * @return importMode
   */
  @javax.annotation.Nullable
  public Boolean getImportMode() {
    return importMode;
  }

  public void setImportMode(Boolean importMode) {
    this.importMode = importMode;
  }


  public Space name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Resource name of the space. Format: &#x60;spaces/{space}&#x60;
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Space singleUserBotDm(Boolean singleUserBotDm) {
    this.singleUserBotDm = singleUserBotDm;
    return this;
  }

  /**
   * Optional. Whether the space is a DM between a Chat app and a single human.
   * @return singleUserBotDm
   */
  @javax.annotation.Nullable
  public Boolean getSingleUserBotDm() {
    return singleUserBotDm;
  }

  public void setSingleUserBotDm(Boolean singleUserBotDm) {
    this.singleUserBotDm = singleUserBotDm;
  }


  public Space spaceDetails(SpaceDetails spaceDetails) {
    this.spaceDetails = spaceDetails;
    return this;
  }

  /**
   * Get spaceDetails
   * @return spaceDetails
   */
  @javax.annotation.Nullable
  public SpaceDetails getSpaceDetails() {
    return spaceDetails;
  }

  public void setSpaceDetails(SpaceDetails spaceDetails) {
    this.spaceDetails = spaceDetails;
  }


  public Space spaceHistoryState(SpaceHistoryStateEnum spaceHistoryState) {
    this.spaceHistoryState = spaceHistoryState;
    return this;
  }

  /**
   * The message history state for messages and threads in this space.
   * @return spaceHistoryState
   */
  @javax.annotation.Nullable
  public SpaceHistoryStateEnum getSpaceHistoryState() {
    return spaceHistoryState;
  }

  public void setSpaceHistoryState(SpaceHistoryStateEnum spaceHistoryState) {
    this.spaceHistoryState = spaceHistoryState;
  }


  /**
   * Output only. The threading state in the Chat space.
   * @return spaceThreadingState
   */
  @javax.annotation.Nullable
  public SpaceThreadingStateEnum getSpaceThreadingState() {
    return spaceThreadingState;
  }



  public Space spaceType(SpaceTypeEnum spaceType) {
    this.spaceType = spaceType;
    return this;
  }

  /**
   * The type of space. Required when creating a space or updating the space type of a space. Output only for other usage.
   * @return spaceType
   */
  @javax.annotation.Nullable
  public SpaceTypeEnum getSpaceType() {
    return spaceType;
  }

  public void setSpaceType(SpaceTypeEnum spaceType) {
    this.spaceType = spaceType;
  }


  /**
   * Output only. Deprecated: Use &#x60;spaceThreadingState&#x60; instead. Whether messages are threaded in this space.
   * @return threaded
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getThreaded() {
    return threaded;
  }



  /**
   * Output only. Deprecated: Use &#x60;space_type&#x60; instead. The type of a space.
   * @return type
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Space space = (Space) o;
    return Objects.equals(this.adminInstalled, space.adminInstalled) &&
        Objects.equals(this.createTime, space.createTime) &&
        Objects.equals(this.displayName, space.displayName) &&
        Objects.equals(this.externalUserAllowed, space.externalUserAllowed) &&
        Objects.equals(this.importMode, space.importMode) &&
        Objects.equals(this.name, space.name) &&
        Objects.equals(this.singleUserBotDm, space.singleUserBotDm) &&
        Objects.equals(this.spaceDetails, space.spaceDetails) &&
        Objects.equals(this.spaceHistoryState, space.spaceHistoryState) &&
        Objects.equals(this.spaceThreadingState, space.spaceThreadingState) &&
        Objects.equals(this.spaceType, space.spaceType) &&
        Objects.equals(this.threaded, space.threaded) &&
        Objects.equals(this.type, space.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(adminInstalled, createTime, displayName, externalUserAllowed, importMode, name, singleUserBotDm, spaceDetails, spaceHistoryState, spaceThreadingState, spaceType, threaded, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Space {\n");
    sb.append("    adminInstalled: ").append(toIndentedString(adminInstalled)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    externalUserAllowed: ").append(toIndentedString(externalUserAllowed)).append("\n");
    sb.append("    importMode: ").append(toIndentedString(importMode)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    singleUserBotDm: ").append(toIndentedString(singleUserBotDm)).append("\n");
    sb.append("    spaceDetails: ").append(toIndentedString(spaceDetails)).append("\n");
    sb.append("    spaceHistoryState: ").append(toIndentedString(spaceHistoryState)).append("\n");
    sb.append("    spaceThreadingState: ").append(toIndentedString(spaceThreadingState)).append("\n");
    sb.append("    spaceType: ").append(toIndentedString(spaceType)).append("\n");
    sb.append("    threaded: ").append(toIndentedString(threaded)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("adminInstalled");
    openapiFields.add("createTime");
    openapiFields.add("displayName");
    openapiFields.add("externalUserAllowed");
    openapiFields.add("importMode");
    openapiFields.add("name");
    openapiFields.add("singleUserBotDm");
    openapiFields.add("spaceDetails");
    openapiFields.add("spaceHistoryState");
    openapiFields.add("spaceThreadingState");
    openapiFields.add("spaceType");
    openapiFields.add("threaded");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Space
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Space.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Space is not found in the empty JSON string", Space.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Space.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Space` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `spaceDetails`
      if (jsonObj.get("spaceDetails") != null && !jsonObj.get("spaceDetails").isJsonNull()) {
        SpaceDetails.validateJsonElement(jsonObj.get("spaceDetails"));
      }
      if ((jsonObj.get("spaceHistoryState") != null && !jsonObj.get("spaceHistoryState").isJsonNull()) && !jsonObj.get("spaceHistoryState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `spaceHistoryState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("spaceHistoryState").toString()));
      }
      // validate the optional field `spaceHistoryState`
      if (jsonObj.get("spaceHistoryState") != null && !jsonObj.get("spaceHistoryState").isJsonNull()) {
        SpaceHistoryStateEnum.validateJsonElement(jsonObj.get("spaceHistoryState"));
      }
      if ((jsonObj.get("spaceThreadingState") != null && !jsonObj.get("spaceThreadingState").isJsonNull()) && !jsonObj.get("spaceThreadingState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `spaceThreadingState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("spaceThreadingState").toString()));
      }
      // validate the optional field `spaceThreadingState`
      if (jsonObj.get("spaceThreadingState") != null && !jsonObj.get("spaceThreadingState").isJsonNull()) {
        SpaceThreadingStateEnum.validateJsonElement(jsonObj.get("spaceThreadingState"));
      }
      if ((jsonObj.get("spaceType") != null && !jsonObj.get("spaceType").isJsonNull()) && !jsonObj.get("spaceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `spaceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("spaceType").toString()));
      }
      // validate the optional field `spaceType`
      if (jsonObj.get("spaceType") != null && !jsonObj.get("spaceType").isJsonNull()) {
        SpaceTypeEnum.validateJsonElement(jsonObj.get("spaceType"));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Space.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Space' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Space> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Space.class));

       return (TypeAdapter<T>) new TypeAdapter<Space>() {
           @Override
           public void write(JsonWriter out, Space value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Space read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Space given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Space
   * @throws IOException if the JSON string is invalid with respect to Space
   */
  public static Space fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Space.class);
  }

  /**
   * Convert an instance of Space to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

