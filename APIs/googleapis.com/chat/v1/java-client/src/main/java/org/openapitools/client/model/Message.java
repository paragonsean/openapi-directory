/*
 * Google Chat API
 * The Google Chat API lets you build Chat apps to integrate your services with Google Chat and manage Chat resources such as spaces, members, and messages.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ActionResponse;
import org.openapitools.client.model.Annotation;
import org.openapitools.client.model.AttachedGif;
import org.openapitools.client.model.Attachment;
import org.openapitools.client.model.Card;
import org.openapitools.client.model.CardWithId;
import org.openapitools.client.model.DeletionMetadata;
import org.openapitools.client.model.EmojiReactionSummary;
import org.openapitools.client.model.MatchedUrl;
import org.openapitools.client.model.QuotedMessageMetadata;
import org.openapitools.client.model.SlashCommand;
import org.openapitools.client.model.Space;
import org.openapitools.client.model.Thread;
import org.openapitools.client.model.User;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A message in a Google Chat space.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:45.023335-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Message {
  public static final String SERIALIZED_NAME_ACTION_RESPONSE = "actionResponse";
  @SerializedName(SERIALIZED_NAME_ACTION_RESPONSE)
  private ActionResponse actionResponse;

  public static final String SERIALIZED_NAME_ANNOTATIONS = "annotations";
  @SerializedName(SERIALIZED_NAME_ANNOTATIONS)
  private List<Annotation> annotations = new ArrayList<>();

  public static final String SERIALIZED_NAME_ARGUMENT_TEXT = "argumentText";
  @SerializedName(SERIALIZED_NAME_ARGUMENT_TEXT)
  private String argumentText;

  public static final String SERIALIZED_NAME_ATTACHED_GIFS = "attachedGifs";
  @SerializedName(SERIALIZED_NAME_ATTACHED_GIFS)
  private List<AttachedGif> attachedGifs = new ArrayList<>();

  public static final String SERIALIZED_NAME_ATTACHMENT = "attachment";
  @SerializedName(SERIALIZED_NAME_ATTACHMENT)
  private List<Attachment> attachment = new ArrayList<>();

  public static final String SERIALIZED_NAME_CARDS = "cards";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_CARDS)
  private List<Card> cards = new ArrayList<>();

  public static final String SERIALIZED_NAME_CARDS_V2 = "cardsV2";
  @SerializedName(SERIALIZED_NAME_CARDS_V2)
  private List<CardWithId> cardsV2 = new ArrayList<>();

  public static final String SERIALIZED_NAME_CLIENT_ASSIGNED_MESSAGE_ID = "clientAssignedMessageId";
  @SerializedName(SERIALIZED_NAME_CLIENT_ASSIGNED_MESSAGE_ID)
  private String clientAssignedMessageId;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DELETE_TIME = "deleteTime";
  @SerializedName(SERIALIZED_NAME_DELETE_TIME)
  private String deleteTime;

  public static final String SERIALIZED_NAME_DELETION_METADATA = "deletionMetadata";
  @SerializedName(SERIALIZED_NAME_DELETION_METADATA)
  private DeletionMetadata deletionMetadata;

  public static final String SERIALIZED_NAME_EMOJI_REACTION_SUMMARIES = "emojiReactionSummaries";
  @SerializedName(SERIALIZED_NAME_EMOJI_REACTION_SUMMARIES)
  private List<EmojiReactionSummary> emojiReactionSummaries = new ArrayList<>();

  public static final String SERIALIZED_NAME_FALLBACK_TEXT = "fallbackText";
  @SerializedName(SERIALIZED_NAME_FALLBACK_TEXT)
  private String fallbackText;

  public static final String SERIALIZED_NAME_FORMATTED_TEXT = "formattedText";
  @SerializedName(SERIALIZED_NAME_FORMATTED_TEXT)
  private String formattedText;

  public static final String SERIALIZED_NAME_LAST_UPDATE_TIME = "lastUpdateTime";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATE_TIME)
  private String lastUpdateTime;

  public static final String SERIALIZED_NAME_MATCHED_URL = "matchedUrl";
  @SerializedName(SERIALIZED_NAME_MATCHED_URL)
  private MatchedUrl matchedUrl;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PRIVATE_MESSAGE_VIEWER = "privateMessageViewer";
  @SerializedName(SERIALIZED_NAME_PRIVATE_MESSAGE_VIEWER)
  private User privateMessageViewer;

  public static final String SERIALIZED_NAME_QUOTED_MESSAGE_METADATA = "quotedMessageMetadata";
  @SerializedName(SERIALIZED_NAME_QUOTED_MESSAGE_METADATA)
  private QuotedMessageMetadata quotedMessageMetadata;

  public static final String SERIALIZED_NAME_SENDER = "sender";
  @SerializedName(SERIALIZED_NAME_SENDER)
  private User sender;

  public static final String SERIALIZED_NAME_SLASH_COMMAND = "slashCommand";
  @SerializedName(SERIALIZED_NAME_SLASH_COMMAND)
  private SlashCommand slashCommand;

  public static final String SERIALIZED_NAME_SPACE = "space";
  @SerializedName(SERIALIZED_NAME_SPACE)
  private Space space;

  public static final String SERIALIZED_NAME_TEXT = "text";
  @SerializedName(SERIALIZED_NAME_TEXT)
  private String text;

  public static final String SERIALIZED_NAME_THREAD = "thread";
  @SerializedName(SERIALIZED_NAME_THREAD)
  private Thread thread;

  public static final String SERIALIZED_NAME_THREAD_REPLY = "threadReply";
  @SerializedName(SERIALIZED_NAME_THREAD_REPLY)
  private Boolean threadReply;

  public Message() {
  }

  public Message(
     List<Annotation> annotations, 
     String argumentText, 
     List<AttachedGif> attachedGifs, 
     String deleteTime, 
     List<EmojiReactionSummary> emojiReactionSummaries, 
     String formattedText, 
     String lastUpdateTime, 
     Boolean threadReply
  ) {
    this();
    this.annotations = annotations;
    this.argumentText = argumentText;
    this.attachedGifs = attachedGifs;
    this.deleteTime = deleteTime;
    this.emojiReactionSummaries = emojiReactionSummaries;
    this.formattedText = formattedText;
    this.lastUpdateTime = lastUpdateTime;
    this.threadReply = threadReply;
  }

  public Message actionResponse(ActionResponse actionResponse) {
    this.actionResponse = actionResponse;
    return this;
  }

  /**
   * Get actionResponse
   * @return actionResponse
   */
  @javax.annotation.Nullable
  public ActionResponse getActionResponse() {
    return actionResponse;
  }

  public void setActionResponse(ActionResponse actionResponse) {
    this.actionResponse = actionResponse;
  }


  /**
   * Output only. Annotations associated with the &#x60;text&#x60; in this message.
   * @return annotations
   */
  @javax.annotation.Nullable
  public List<Annotation> getAnnotations() {
    return annotations;
  }



  /**
   * Output only. Plain-text body of the message with all Chat app mentions stripped out.
   * @return argumentText
   */
  @javax.annotation.Nullable
  public String getArgumentText() {
    return argumentText;
  }



  /**
   * Output only. GIF images that are attached to the message.
   * @return attachedGifs
   */
  @javax.annotation.Nullable
  public List<AttachedGif> getAttachedGifs() {
    return attachedGifs;
  }



  public Message attachment(List<Attachment> attachment) {
    this.attachment = attachment;
    return this;
  }

  public Message addAttachmentItem(Attachment attachmentItem) {
    if (this.attachment == null) {
      this.attachment = new ArrayList<>();
    }
    this.attachment.add(attachmentItem);
    return this;
  }

  /**
   * User-uploaded attachment.
   * @return attachment
   */
  @javax.annotation.Nullable
  public List<Attachment> getAttachment() {
    return attachment;
  }

  public void setAttachment(List<Attachment> attachment) {
    this.attachment = attachment;
  }


  @Deprecated
  public Message cards(List<Card> cards) {
    this.cards = cards;
    return this;
  }

  public Message addCardsItem(Card cardsItem) {
    if (this.cards == null) {
      this.cards = new ArrayList<>();
    }
    this.cards.add(cardsItem);
    return this;
  }

  /**
   * Deprecated: Use &#x60;cards_v2&#x60; instead. Rich, formatted, and interactive cards that you can use to display UI elements such as: formatted texts, buttons, and clickable images. Cards are normally displayed below the plain-text body of the message. &#x60;cards&#x60; and &#x60;cards_v2&#x60; can have a maximum size of 32 KB.
   * @return cards
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public List<Card> getCards() {
    return cards;
  }

  @Deprecated
  public void setCards(List<Card> cards) {
    this.cards = cards;
  }


  public Message cardsV2(List<CardWithId> cardsV2) {
    this.cardsV2 = cardsV2;
    return this;
  }

  public Message addCardsV2Item(CardWithId cardsV2Item) {
    if (this.cardsV2 == null) {
      this.cardsV2 = new ArrayList<>();
    }
    this.cardsV2.add(cardsV2Item);
    return this;
  }

  /**
   * An array of [cards](https://developers.google.com/chat/api/reference/rest/v1/cards). Only Chat apps can create cards. If your Chat app [authenticates as a user](https://developers.google.com/chat/api/guides/auth/users), the messages can&#39;t contain cards. To learn about cards and how to create them, see [Design dynamic, interactive, and consistent UIs with cards](https://developers.google.com/chat/ui). [Card builder](https://addons.gsuite.google.com/uikit/builder)
   * @return cardsV2
   */
  @javax.annotation.Nullable
  public List<CardWithId> getCardsV2() {
    return cardsV2;
  }

  public void setCardsV2(List<CardWithId> cardsV2) {
    this.cardsV2 = cardsV2;
  }


  public Message clientAssignedMessageId(String clientAssignedMessageId) {
    this.clientAssignedMessageId = clientAssignedMessageId;
    return this;
  }

  /**
   * Optional. A custom ID for the message. You can use field to identify a message, or to get, delete, or update a message. To set a custom ID, specify the [&#x60;messageId&#x60;](https://developers.google.com/chat/api/reference/rest/v1/spaces.messages/create#body.QUERY_PARAMETERS.message_id) field when you create the message. For details, see [Name a message](https://developers.google.com/chat/api/guides/v1/messages/create#name_a_created_message).
   * @return clientAssignedMessageId
   */
  @javax.annotation.Nullable
  public String getClientAssignedMessageId() {
    return clientAssignedMessageId;
  }

  public void setClientAssignedMessageId(String clientAssignedMessageId) {
    this.clientAssignedMessageId = clientAssignedMessageId;
  }


  public Message createTime(String createTime) {
    this.createTime = createTime;
    return this;
  }

  /**
   * Optional. Immutable. For spaces created in Chat, the time at which the message was created. This field is output only, except when used in import mode spaces. For import mode spaces, set this field to the historical timestamp at which the message was created in the source in order to preserve the original creation time.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }

  public void setCreateTime(String createTime) {
    this.createTime = createTime;
  }


  /**
   * Output only. The time at which the message was deleted in Google Chat. If the message is never deleted, this field is empty.
   * @return deleteTime
   */
  @javax.annotation.Nullable
  public String getDeleteTime() {
    return deleteTime;
  }



  public Message deletionMetadata(DeletionMetadata deletionMetadata) {
    this.deletionMetadata = deletionMetadata;
    return this;
  }

  /**
   * Get deletionMetadata
   * @return deletionMetadata
   */
  @javax.annotation.Nullable
  public DeletionMetadata getDeletionMetadata() {
    return deletionMetadata;
  }

  public void setDeletionMetadata(DeletionMetadata deletionMetadata) {
    this.deletionMetadata = deletionMetadata;
  }


  /**
   * Output only. The list of emoji reaction summaries on the message.
   * @return emojiReactionSummaries
   */
  @javax.annotation.Nullable
  public List<EmojiReactionSummary> getEmojiReactionSummaries() {
    return emojiReactionSummaries;
  }



  public Message fallbackText(String fallbackText) {
    this.fallbackText = fallbackText;
    return this;
  }

  /**
   * A plain-text description of the message&#39;s cards, used when the actual cards can&#39;t be displayed—for example, mobile notifications.
   * @return fallbackText
   */
  @javax.annotation.Nullable
  public String getFallbackText() {
    return fallbackText;
  }

  public void setFallbackText(String fallbackText) {
    this.fallbackText = fallbackText;
  }


  /**
   * Output only. Contains the message &#x60;text&#x60; with markups added to communicate formatting. This field might not capture all formatting visible in the UI, but includes the following: * [Markup syntax](https://developers.google.com/chat/format-messages) for bold, italic, strikethrough, monospace, and monospace block. * [User mentions](https://developers.google.com/chat/format-messages#messages-@mention) using the format &#x60;&#x60;. * Custom hyperlinks using the format &#x60;&lt;{url}|{rendered_text}&gt;&#x60; where the first string is the URL and the second is the rendered text—for example, &#x60;&#x60;. * Custom emoji using the format &#x60;:{emoji_name}:&#x60;—for example, &#x60;:smile:&#x60;. This doesn&#39;t apply to Unicode emoji, such as &#x60;U+1F600&#x60; for a grinning face emoji. For more information, see [View text formatting sent in a message](https://developers.google.com/chat/format-messages#view_text_formatting_sent_in_a_message)
   * @return formattedText
   */
  @javax.annotation.Nullable
  public String getFormattedText() {
    return formattedText;
  }



  /**
   * Output only. The time at which the message was last edited by a user. If the message has never been edited, this field is empty.
   * @return lastUpdateTime
   */
  @javax.annotation.Nullable
  public String getLastUpdateTime() {
    return lastUpdateTime;
  }



  public Message matchedUrl(MatchedUrl matchedUrl) {
    this.matchedUrl = matchedUrl;
    return this;
  }

  /**
   * Get matchedUrl
   * @return matchedUrl
   */
  @javax.annotation.Nullable
  public MatchedUrl getMatchedUrl() {
    return matchedUrl;
  }

  public void setMatchedUrl(MatchedUrl matchedUrl) {
    this.matchedUrl = matchedUrl;
  }


  public Message name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Resource name of the message. Format: &#x60;spaces/{space}/messages/{message}&#x60; Where &#x60;{space}&#x60; is the ID of the space where the message is posted and &#x60;{message}&#x60; is a system-assigned ID for the message. For example, &#x60;spaces/AAAAAAAAAAA/messages/BBBBBBBBBBB.BBBBBBBBBBB&#x60;. If you set a custom ID when you create a message, you can use this ID to specify the message in a request by replacing &#x60;{message}&#x60; with the value from the &#x60;clientAssignedMessageId&#x60; field. For example, &#x60;spaces/AAAAAAAAAAA/messages/client-custom-name&#x60;. For details, see [Name a message](https://developers.google.com/chat/api/guides/v1/messages/create#name_a_created_message).
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Message privateMessageViewer(User privateMessageViewer) {
    this.privateMessageViewer = privateMessageViewer;
    return this;
  }

  /**
   * Get privateMessageViewer
   * @return privateMessageViewer
   */
  @javax.annotation.Nullable
  public User getPrivateMessageViewer() {
    return privateMessageViewer;
  }

  public void setPrivateMessageViewer(User privateMessageViewer) {
    this.privateMessageViewer = privateMessageViewer;
  }


  public Message quotedMessageMetadata(QuotedMessageMetadata quotedMessageMetadata) {
    this.quotedMessageMetadata = quotedMessageMetadata;
    return this;
  }

  /**
   * Get quotedMessageMetadata
   * @return quotedMessageMetadata
   */
  @javax.annotation.Nullable
  public QuotedMessageMetadata getQuotedMessageMetadata() {
    return quotedMessageMetadata;
  }

  public void setQuotedMessageMetadata(QuotedMessageMetadata quotedMessageMetadata) {
    this.quotedMessageMetadata = quotedMessageMetadata;
  }


  public Message sender(User sender) {
    this.sender = sender;
    return this;
  }

  /**
   * Get sender
   * @return sender
   */
  @javax.annotation.Nullable
  public User getSender() {
    return sender;
  }

  public void setSender(User sender) {
    this.sender = sender;
  }


  public Message slashCommand(SlashCommand slashCommand) {
    this.slashCommand = slashCommand;
    return this;
  }

  /**
   * Get slashCommand
   * @return slashCommand
   */
  @javax.annotation.Nullable
  public SlashCommand getSlashCommand() {
    return slashCommand;
  }

  public void setSlashCommand(SlashCommand slashCommand) {
    this.slashCommand = slashCommand;
  }


  public Message space(Space space) {
    this.space = space;
    return this;
  }

  /**
   * Get space
   * @return space
   */
  @javax.annotation.Nullable
  public Space getSpace() {
    return space;
  }

  public void setSpace(Space space) {
    this.space = space;
  }


  public Message text(String text) {
    this.text = text;
    return this;
  }

  /**
   * Plain-text body of the message. The first link to an image, video, or web page generates a [preview chip](https://developers.google.com/chat/how-tos/preview-links). You can also [@mention a Google Chat user](https://developers.google.com/chat/format-messages#messages-@mention), or everyone in the space. To learn about creating text messages, see [Send a text message](https://developers.google.com/chat/api/guides/v1/messages/create#create-text-messages).
   * @return text
   */
  @javax.annotation.Nullable
  public String getText() {
    return text;
  }

  public void setText(String text) {
    this.text = text;
  }


  public Message thread(Thread thread) {
    this.thread = thread;
    return this;
  }

  /**
   * Get thread
   * @return thread
   */
  @javax.annotation.Nullable
  public Thread getThread() {
    return thread;
  }

  public void setThread(Thread thread) {
    this.thread = thread;
  }


  /**
   * Output only. When &#x60;true&#x60;, the message is a response in a reply thread. When &#x60;false&#x60;, the message is visible in the space&#39;s top-level conversation as either the first message of a thread or a message with no threaded replies. If the space doesn&#39;t support reply in threads, this field is always &#x60;false&#x60;.
   * @return threadReply
   */
  @javax.annotation.Nullable
  public Boolean getThreadReply() {
    return threadReply;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Message message = (Message) o;
    return Objects.equals(this.actionResponse, message.actionResponse) &&
        Objects.equals(this.annotations, message.annotations) &&
        Objects.equals(this.argumentText, message.argumentText) &&
        Objects.equals(this.attachedGifs, message.attachedGifs) &&
        Objects.equals(this.attachment, message.attachment) &&
        Objects.equals(this.cards, message.cards) &&
        Objects.equals(this.cardsV2, message.cardsV2) &&
        Objects.equals(this.clientAssignedMessageId, message.clientAssignedMessageId) &&
        Objects.equals(this.createTime, message.createTime) &&
        Objects.equals(this.deleteTime, message.deleteTime) &&
        Objects.equals(this.deletionMetadata, message.deletionMetadata) &&
        Objects.equals(this.emojiReactionSummaries, message.emojiReactionSummaries) &&
        Objects.equals(this.fallbackText, message.fallbackText) &&
        Objects.equals(this.formattedText, message.formattedText) &&
        Objects.equals(this.lastUpdateTime, message.lastUpdateTime) &&
        Objects.equals(this.matchedUrl, message.matchedUrl) &&
        Objects.equals(this.name, message.name) &&
        Objects.equals(this.privateMessageViewer, message.privateMessageViewer) &&
        Objects.equals(this.quotedMessageMetadata, message.quotedMessageMetadata) &&
        Objects.equals(this.sender, message.sender) &&
        Objects.equals(this.slashCommand, message.slashCommand) &&
        Objects.equals(this.space, message.space) &&
        Objects.equals(this.text, message.text) &&
        Objects.equals(this.thread, message.thread) &&
        Objects.equals(this.threadReply, message.threadReply);
  }

  @Override
  public int hashCode() {
    return Objects.hash(actionResponse, annotations, argumentText, attachedGifs, attachment, cards, cardsV2, clientAssignedMessageId, createTime, deleteTime, deletionMetadata, emojiReactionSummaries, fallbackText, formattedText, lastUpdateTime, matchedUrl, name, privateMessageViewer, quotedMessageMetadata, sender, slashCommand, space, text, thread, threadReply);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Message {\n");
    sb.append("    actionResponse: ").append(toIndentedString(actionResponse)).append("\n");
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    argumentText: ").append(toIndentedString(argumentText)).append("\n");
    sb.append("    attachedGifs: ").append(toIndentedString(attachedGifs)).append("\n");
    sb.append("    attachment: ").append(toIndentedString(attachment)).append("\n");
    sb.append("    cards: ").append(toIndentedString(cards)).append("\n");
    sb.append("    cardsV2: ").append(toIndentedString(cardsV2)).append("\n");
    sb.append("    clientAssignedMessageId: ").append(toIndentedString(clientAssignedMessageId)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    deleteTime: ").append(toIndentedString(deleteTime)).append("\n");
    sb.append("    deletionMetadata: ").append(toIndentedString(deletionMetadata)).append("\n");
    sb.append("    emojiReactionSummaries: ").append(toIndentedString(emojiReactionSummaries)).append("\n");
    sb.append("    fallbackText: ").append(toIndentedString(fallbackText)).append("\n");
    sb.append("    formattedText: ").append(toIndentedString(formattedText)).append("\n");
    sb.append("    lastUpdateTime: ").append(toIndentedString(lastUpdateTime)).append("\n");
    sb.append("    matchedUrl: ").append(toIndentedString(matchedUrl)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    privateMessageViewer: ").append(toIndentedString(privateMessageViewer)).append("\n");
    sb.append("    quotedMessageMetadata: ").append(toIndentedString(quotedMessageMetadata)).append("\n");
    sb.append("    sender: ").append(toIndentedString(sender)).append("\n");
    sb.append("    slashCommand: ").append(toIndentedString(slashCommand)).append("\n");
    sb.append("    space: ").append(toIndentedString(space)).append("\n");
    sb.append("    text: ").append(toIndentedString(text)).append("\n");
    sb.append("    thread: ").append(toIndentedString(thread)).append("\n");
    sb.append("    threadReply: ").append(toIndentedString(threadReply)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("actionResponse");
    openapiFields.add("annotations");
    openapiFields.add("argumentText");
    openapiFields.add("attachedGifs");
    openapiFields.add("attachment");
    openapiFields.add("cards");
    openapiFields.add("cardsV2");
    openapiFields.add("clientAssignedMessageId");
    openapiFields.add("createTime");
    openapiFields.add("deleteTime");
    openapiFields.add("deletionMetadata");
    openapiFields.add("emojiReactionSummaries");
    openapiFields.add("fallbackText");
    openapiFields.add("formattedText");
    openapiFields.add("lastUpdateTime");
    openapiFields.add("matchedUrl");
    openapiFields.add("name");
    openapiFields.add("privateMessageViewer");
    openapiFields.add("quotedMessageMetadata");
    openapiFields.add("sender");
    openapiFields.add("slashCommand");
    openapiFields.add("space");
    openapiFields.add("text");
    openapiFields.add("thread");
    openapiFields.add("threadReply");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Message
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Message.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Message is not found in the empty JSON string", Message.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Message.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Message` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `actionResponse`
      if (jsonObj.get("actionResponse") != null && !jsonObj.get("actionResponse").isJsonNull()) {
        ActionResponse.validateJsonElement(jsonObj.get("actionResponse"));
      }
      if (jsonObj.get("annotations") != null && !jsonObj.get("annotations").isJsonNull()) {
        JsonArray jsonArrayannotations = jsonObj.getAsJsonArray("annotations");
        if (jsonArrayannotations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("annotations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `annotations` to be an array in the JSON string but got `%s`", jsonObj.get("annotations").toString()));
          }

          // validate the optional field `annotations` (array)
          for (int i = 0; i < jsonArrayannotations.size(); i++) {
            Annotation.validateJsonElement(jsonArrayannotations.get(i));
          };
        }
      }
      if ((jsonObj.get("argumentText") != null && !jsonObj.get("argumentText").isJsonNull()) && !jsonObj.get("argumentText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `argumentText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("argumentText").toString()));
      }
      if (jsonObj.get("attachedGifs") != null && !jsonObj.get("attachedGifs").isJsonNull()) {
        JsonArray jsonArrayattachedGifs = jsonObj.getAsJsonArray("attachedGifs");
        if (jsonArrayattachedGifs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("attachedGifs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `attachedGifs` to be an array in the JSON string but got `%s`", jsonObj.get("attachedGifs").toString()));
          }

          // validate the optional field `attachedGifs` (array)
          for (int i = 0; i < jsonArrayattachedGifs.size(); i++) {
            AttachedGif.validateJsonElement(jsonArrayattachedGifs.get(i));
          };
        }
      }
      if (jsonObj.get("attachment") != null && !jsonObj.get("attachment").isJsonNull()) {
        JsonArray jsonArrayattachment = jsonObj.getAsJsonArray("attachment");
        if (jsonArrayattachment != null) {
          // ensure the json data is an array
          if (!jsonObj.get("attachment").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `attachment` to be an array in the JSON string but got `%s`", jsonObj.get("attachment").toString()));
          }

          // validate the optional field `attachment` (array)
          for (int i = 0; i < jsonArrayattachment.size(); i++) {
            Attachment.validateJsonElement(jsonArrayattachment.get(i));
          };
        }
      }
      if (jsonObj.get("cards") != null && !jsonObj.get("cards").isJsonNull()) {
        JsonArray jsonArraycards = jsonObj.getAsJsonArray("cards");
        if (jsonArraycards != null) {
          // ensure the json data is an array
          if (!jsonObj.get("cards").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `cards` to be an array in the JSON string but got `%s`", jsonObj.get("cards").toString()));
          }

          // validate the optional field `cards` (array)
          for (int i = 0; i < jsonArraycards.size(); i++) {
            Card.validateJsonElement(jsonArraycards.get(i));
          };
        }
      }
      if (jsonObj.get("cardsV2") != null && !jsonObj.get("cardsV2").isJsonNull()) {
        JsonArray jsonArraycardsV2 = jsonObj.getAsJsonArray("cardsV2");
        if (jsonArraycardsV2 != null) {
          // ensure the json data is an array
          if (!jsonObj.get("cardsV2").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `cardsV2` to be an array in the JSON string but got `%s`", jsonObj.get("cardsV2").toString()));
          }

          // validate the optional field `cardsV2` (array)
          for (int i = 0; i < jsonArraycardsV2.size(); i++) {
            CardWithId.validateJsonElement(jsonArraycardsV2.get(i));
          };
        }
      }
      if ((jsonObj.get("clientAssignedMessageId") != null && !jsonObj.get("clientAssignedMessageId").isJsonNull()) && !jsonObj.get("clientAssignedMessageId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clientAssignedMessageId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clientAssignedMessageId").toString()));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("deleteTime") != null && !jsonObj.get("deleteTime").isJsonNull()) && !jsonObj.get("deleteTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deleteTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deleteTime").toString()));
      }
      // validate the optional field `deletionMetadata`
      if (jsonObj.get("deletionMetadata") != null && !jsonObj.get("deletionMetadata").isJsonNull()) {
        DeletionMetadata.validateJsonElement(jsonObj.get("deletionMetadata"));
      }
      if (jsonObj.get("emojiReactionSummaries") != null && !jsonObj.get("emojiReactionSummaries").isJsonNull()) {
        JsonArray jsonArrayemojiReactionSummaries = jsonObj.getAsJsonArray("emojiReactionSummaries");
        if (jsonArrayemojiReactionSummaries != null) {
          // ensure the json data is an array
          if (!jsonObj.get("emojiReactionSummaries").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `emojiReactionSummaries` to be an array in the JSON string but got `%s`", jsonObj.get("emojiReactionSummaries").toString()));
          }

          // validate the optional field `emojiReactionSummaries` (array)
          for (int i = 0; i < jsonArrayemojiReactionSummaries.size(); i++) {
            EmojiReactionSummary.validateJsonElement(jsonArrayemojiReactionSummaries.get(i));
          };
        }
      }
      if ((jsonObj.get("fallbackText") != null && !jsonObj.get("fallbackText").isJsonNull()) && !jsonObj.get("fallbackText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fallbackText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fallbackText").toString()));
      }
      if ((jsonObj.get("formattedText") != null && !jsonObj.get("formattedText").isJsonNull()) && !jsonObj.get("formattedText").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `formattedText` to be a primitive type in the JSON string but got `%s`", jsonObj.get("formattedText").toString()));
      }
      if ((jsonObj.get("lastUpdateTime") != null && !jsonObj.get("lastUpdateTime").isJsonNull()) && !jsonObj.get("lastUpdateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastUpdateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastUpdateTime").toString()));
      }
      // validate the optional field `matchedUrl`
      if (jsonObj.get("matchedUrl") != null && !jsonObj.get("matchedUrl").isJsonNull()) {
        MatchedUrl.validateJsonElement(jsonObj.get("matchedUrl"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `privateMessageViewer`
      if (jsonObj.get("privateMessageViewer") != null && !jsonObj.get("privateMessageViewer").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("privateMessageViewer"));
      }
      // validate the optional field `quotedMessageMetadata`
      if (jsonObj.get("quotedMessageMetadata") != null && !jsonObj.get("quotedMessageMetadata").isJsonNull()) {
        QuotedMessageMetadata.validateJsonElement(jsonObj.get("quotedMessageMetadata"));
      }
      // validate the optional field `sender`
      if (jsonObj.get("sender") != null && !jsonObj.get("sender").isJsonNull()) {
        User.validateJsonElement(jsonObj.get("sender"));
      }
      // validate the optional field `slashCommand`
      if (jsonObj.get("slashCommand") != null && !jsonObj.get("slashCommand").isJsonNull()) {
        SlashCommand.validateJsonElement(jsonObj.get("slashCommand"));
      }
      // validate the optional field `space`
      if (jsonObj.get("space") != null && !jsonObj.get("space").isJsonNull()) {
        Space.validateJsonElement(jsonObj.get("space"));
      }
      if ((jsonObj.get("text") != null && !jsonObj.get("text").isJsonNull()) && !jsonObj.get("text").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `text` to be a primitive type in the JSON string but got `%s`", jsonObj.get("text").toString()));
      }
      // validate the optional field `thread`
      if (jsonObj.get("thread") != null && !jsonObj.get("thread").isJsonNull()) {
        Thread.validateJsonElement(jsonObj.get("thread"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Message.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Message' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Message> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Message.class));

       return (TypeAdapter<T>) new TypeAdapter<Message>() {
           @Override
           public void write(JsonWriter out, Message value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Message read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Message given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Message
   * @throws IOException if the JSON string is invalid with respect to Message
   */
  public static Message fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Message.class);
  }

  /**
   * Convert an instance of Message to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

