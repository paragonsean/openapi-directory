/*
 * Vertex AI Search for Retail API
 * Vertex AI Search for Retail API is made up of Retail Search, Browse and Recommendations. These discovery AI solutions help you implement personalized search, browse and recommendations, based on machine learning models, across your websites and mobile applications.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.GoogleCloudRetailV2CatalogAttributeFacetConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Catalog level attribute config for an attribute. For example, if customers want to enable/disable facet for a specific attribute.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:22.008824-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleCloudRetailV2CatalogAttribute {
  /**
   * If DYNAMIC_FACETABLE_ENABLED, attribute values are available for dynamic facet. Could only be DYNAMIC_FACETABLE_DISABLED if CatalogAttribute.indexable_option is INDEXABLE_DISABLED. Otherwise, an INVALID_ARGUMENT error is returned. Must be specified, otherwise throws INVALID_FORMAT error.
   */
  @JsonAdapter(DynamicFacetableOptionEnum.Adapter.class)
  public enum DynamicFacetableOptionEnum {
    OPTION_UNSPECIFIED("DYNAMIC_FACETABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("DYNAMIC_FACETABLE_ENABLED"),
    
    DISABLED("DYNAMIC_FACETABLE_DISABLED");

    private String value;

    DynamicFacetableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DynamicFacetableOptionEnum fromValue(String value) {
      for (DynamicFacetableOptionEnum b : DynamicFacetableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DynamicFacetableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DynamicFacetableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DynamicFacetableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DynamicFacetableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DynamicFacetableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DYNAMIC_FACETABLE_OPTION = "dynamicFacetableOption";
  @SerializedName(SERIALIZED_NAME_DYNAMIC_FACETABLE_OPTION)
  private DynamicFacetableOptionEnum dynamicFacetableOption;

  /**
   * If EXACT_SEARCHABLE_ENABLED, attribute values will be exact searchable. This property only applies to textual custom attributes and requires indexable set to enabled to enable exact-searchable. If unset, the server behavior defaults to EXACT_SEARCHABLE_DISABLED.
   */
  @JsonAdapter(ExactSearchableOptionEnum.Adapter.class)
  public enum ExactSearchableOptionEnum {
    OPTION_UNSPECIFIED("EXACT_SEARCHABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("EXACT_SEARCHABLE_ENABLED"),
    
    DISABLED("EXACT_SEARCHABLE_DISABLED");

    private String value;

    ExactSearchableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ExactSearchableOptionEnum fromValue(String value) {
      for (ExactSearchableOptionEnum b : ExactSearchableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ExactSearchableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ExactSearchableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ExactSearchableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ExactSearchableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ExactSearchableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EXACT_SEARCHABLE_OPTION = "exactSearchableOption";
  @SerializedName(SERIALIZED_NAME_EXACT_SEARCHABLE_OPTION)
  private ExactSearchableOptionEnum exactSearchableOption;

  public static final String SERIALIZED_NAME_FACET_CONFIG = "facetConfig";
  @SerializedName(SERIALIZED_NAME_FACET_CONFIG)
  private GoogleCloudRetailV2CatalogAttributeFacetConfig facetConfig;

  public static final String SERIALIZED_NAME_IN_USE = "inUse";
  @SerializedName(SERIALIZED_NAME_IN_USE)
  private Boolean inUse;

  /**
   * When AttributesConfig.attribute_config_level is CATALOG_LEVEL_ATTRIBUTE_CONFIG, if INDEXABLE_ENABLED attribute values are indexed so that it can be filtered, faceted, or boosted in SearchService.Search. Must be specified when AttributesConfig.attribute_config_level is CATALOG_LEVEL_ATTRIBUTE_CONFIG, otherwise throws INVALID_FORMAT error.
   */
  @JsonAdapter(IndexableOptionEnum.Adapter.class)
  public enum IndexableOptionEnum {
    OPTION_UNSPECIFIED("INDEXABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("INDEXABLE_ENABLED"),
    
    DISABLED("INDEXABLE_DISABLED");

    private String value;

    IndexableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IndexableOptionEnum fromValue(String value) {
      for (IndexableOptionEnum b : IndexableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IndexableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IndexableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IndexableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IndexableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      IndexableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INDEXABLE_OPTION = "indexableOption";
  @SerializedName(SERIALIZED_NAME_INDEXABLE_OPTION)
  private IndexableOptionEnum indexableOption;

  public static final String SERIALIZED_NAME_KEY = "key";
  @SerializedName(SERIALIZED_NAME_KEY)
  private String key;

  /**
   * If RETRIEVABLE_ENABLED, attribute values are retrievable in the search results. If unset, the server behavior defaults to RETRIEVABLE_DISABLED.
   */
  @JsonAdapter(RetrievableOptionEnum.Adapter.class)
  public enum RetrievableOptionEnum {
    OPTION_UNSPECIFIED("RETRIEVABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("RETRIEVABLE_ENABLED"),
    
    DISABLED("RETRIEVABLE_DISABLED");

    private String value;

    RetrievableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RetrievableOptionEnum fromValue(String value) {
      for (RetrievableOptionEnum b : RetrievableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RetrievableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RetrievableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RetrievableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RetrievableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RetrievableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RETRIEVABLE_OPTION = "retrievableOption";
  @SerializedName(SERIALIZED_NAME_RETRIEVABLE_OPTION)
  private RetrievableOptionEnum retrievableOption;

  /**
   * When AttributesConfig.attribute_config_level is CATALOG_LEVEL_ATTRIBUTE_CONFIG, if SEARCHABLE_ENABLED, attribute values are searchable by text queries in SearchService.Search. If SEARCHABLE_ENABLED but attribute type is numerical, attribute values will not be searchable by text queries in SearchService.Search, as there are no text values associated to numerical attributes. Must be specified, when AttributesConfig.attribute_config_level is CATALOG_LEVEL_ATTRIBUTE_CONFIG, otherwise throws INVALID_FORMAT error.
   */
  @JsonAdapter(SearchableOptionEnum.Adapter.class)
  public enum SearchableOptionEnum {
    OPTION_UNSPECIFIED("SEARCHABLE_OPTION_UNSPECIFIED"),
    
    ENABLED("SEARCHABLE_ENABLED"),
    
    DISABLED("SEARCHABLE_DISABLED");

    private String value;

    SearchableOptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SearchableOptionEnum fromValue(String value) {
      for (SearchableOptionEnum b : SearchableOptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SearchableOptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SearchableOptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SearchableOptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SearchableOptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SearchableOptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SEARCHABLE_OPTION = "searchableOption";
  @SerializedName(SERIALIZED_NAME_SEARCHABLE_OPTION)
  private SearchableOptionEnum searchableOption;

  /**
   * Output only. The type of this attribute. This is derived from the attribute in Product.attributes.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    UNKNOWN("UNKNOWN"),
    
    TEXTUAL("TEXTUAL"),
    
    NUMERICAL("NUMERICAL");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public GoogleCloudRetailV2CatalogAttribute() {
  }

  public GoogleCloudRetailV2CatalogAttribute(
     Boolean inUse, 
     TypeEnum type
  ) {
    this();
    this.inUse = inUse;
    this.type = type;
  }

  public GoogleCloudRetailV2CatalogAttribute dynamicFacetableOption(DynamicFacetableOptionEnum dynamicFacetableOption) {
    this.dynamicFacetableOption = dynamicFacetableOption;
    return this;
  }

  /**
   * If DYNAMIC_FACETABLE_ENABLED, attribute values are available for dynamic facet. Could only be DYNAMIC_FACETABLE_DISABLED if CatalogAttribute.indexable_option is INDEXABLE_DISABLED. Otherwise, an INVALID_ARGUMENT error is returned. Must be specified, otherwise throws INVALID_FORMAT error.
   * @return dynamicFacetableOption
   */
  @javax.annotation.Nullable
  public DynamicFacetableOptionEnum getDynamicFacetableOption() {
    return dynamicFacetableOption;
  }

  public void setDynamicFacetableOption(DynamicFacetableOptionEnum dynamicFacetableOption) {
    this.dynamicFacetableOption = dynamicFacetableOption;
  }


  public GoogleCloudRetailV2CatalogAttribute exactSearchableOption(ExactSearchableOptionEnum exactSearchableOption) {
    this.exactSearchableOption = exactSearchableOption;
    return this;
  }

  /**
   * If EXACT_SEARCHABLE_ENABLED, attribute values will be exact searchable. This property only applies to textual custom attributes and requires indexable set to enabled to enable exact-searchable. If unset, the server behavior defaults to EXACT_SEARCHABLE_DISABLED.
   * @return exactSearchableOption
   */
  @javax.annotation.Nullable
  public ExactSearchableOptionEnum getExactSearchableOption() {
    return exactSearchableOption;
  }

  public void setExactSearchableOption(ExactSearchableOptionEnum exactSearchableOption) {
    this.exactSearchableOption = exactSearchableOption;
  }


  public GoogleCloudRetailV2CatalogAttribute facetConfig(GoogleCloudRetailV2CatalogAttributeFacetConfig facetConfig) {
    this.facetConfig = facetConfig;
    return this;
  }

  /**
   * Get facetConfig
   * @return facetConfig
   */
  @javax.annotation.Nullable
  public GoogleCloudRetailV2CatalogAttributeFacetConfig getFacetConfig() {
    return facetConfig;
  }

  public void setFacetConfig(GoogleCloudRetailV2CatalogAttributeFacetConfig facetConfig) {
    this.facetConfig = facetConfig;
  }


  /**
   * Output only. Indicates whether this attribute has been used by any products. &#x60;True&#x60; if at least one Product is using this attribute in Product.attributes. Otherwise, this field is &#x60;False&#x60;. CatalogAttribute can be pre-loaded by using CatalogService.AddCatalogAttribute, CatalogService.ImportCatalogAttributes, or CatalogService.UpdateAttributesConfig APIs. This field is &#x60;False&#x60; for pre-loaded CatalogAttributes. Only pre-loaded catalog attributes that are neither in use by products nor predefined can be deleted. Catalog attributes that are either in use by products or are predefined attributes cannot be deleted; however, their configuration properties will reset to default values upon removal request. After catalog changes, it takes about 10 minutes for this field to update.
   * @return inUse
   */
  @javax.annotation.Nullable
  public Boolean getInUse() {
    return inUse;
  }



  public GoogleCloudRetailV2CatalogAttribute indexableOption(IndexableOptionEnum indexableOption) {
    this.indexableOption = indexableOption;
    return this;
  }

  /**
   * When AttributesConfig.attribute_config_level is CATALOG_LEVEL_ATTRIBUTE_CONFIG, if INDEXABLE_ENABLED attribute values are indexed so that it can be filtered, faceted, or boosted in SearchService.Search. Must be specified when AttributesConfig.attribute_config_level is CATALOG_LEVEL_ATTRIBUTE_CONFIG, otherwise throws INVALID_FORMAT error.
   * @return indexableOption
   */
  @javax.annotation.Nullable
  public IndexableOptionEnum getIndexableOption() {
    return indexableOption;
  }

  public void setIndexableOption(IndexableOptionEnum indexableOption) {
    this.indexableOption = indexableOption;
  }


  public GoogleCloudRetailV2CatalogAttribute key(String key) {
    this.key = key;
    return this;
  }

  /**
   * Required. Attribute name. For example: &#x60;color&#x60;, &#x60;brands&#x60;, &#x60;attributes.custom_attribute&#x60;, such as &#x60;attributes.xyz&#x60;. To be indexable, the attribute name can contain only alpha-numeric characters and underscores. For example, an attribute named &#x60;attributes.abc_xyz&#x60; can be indexed, but an attribute named &#x60;attributes.abc-xyz&#x60; cannot be indexed. If the attribute key starts with &#x60;attributes.&#x60;, then the attribute is a custom attribute. Attributes such as &#x60;brands&#x60;, &#x60;patterns&#x60;, and &#x60;title&#x60; are built-in and called system attributes.
   * @return key
   */
  @javax.annotation.Nullable
  public String getKey() {
    return key;
  }

  public void setKey(String key) {
    this.key = key;
  }


  public GoogleCloudRetailV2CatalogAttribute retrievableOption(RetrievableOptionEnum retrievableOption) {
    this.retrievableOption = retrievableOption;
    return this;
  }

  /**
   * If RETRIEVABLE_ENABLED, attribute values are retrievable in the search results. If unset, the server behavior defaults to RETRIEVABLE_DISABLED.
   * @return retrievableOption
   */
  @javax.annotation.Nullable
  public RetrievableOptionEnum getRetrievableOption() {
    return retrievableOption;
  }

  public void setRetrievableOption(RetrievableOptionEnum retrievableOption) {
    this.retrievableOption = retrievableOption;
  }


  public GoogleCloudRetailV2CatalogAttribute searchableOption(SearchableOptionEnum searchableOption) {
    this.searchableOption = searchableOption;
    return this;
  }

  /**
   * When AttributesConfig.attribute_config_level is CATALOG_LEVEL_ATTRIBUTE_CONFIG, if SEARCHABLE_ENABLED, attribute values are searchable by text queries in SearchService.Search. If SEARCHABLE_ENABLED but attribute type is numerical, attribute values will not be searchable by text queries in SearchService.Search, as there are no text values associated to numerical attributes. Must be specified, when AttributesConfig.attribute_config_level is CATALOG_LEVEL_ATTRIBUTE_CONFIG, otherwise throws INVALID_FORMAT error.
   * @return searchableOption
   */
  @javax.annotation.Nullable
  public SearchableOptionEnum getSearchableOption() {
    return searchableOption;
  }

  public void setSearchableOption(SearchableOptionEnum searchableOption) {
    this.searchableOption = searchableOption;
  }


  /**
   * Output only. The type of this attribute. This is derived from the attribute in Product.attributes.
   * @return type
   */
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleCloudRetailV2CatalogAttribute googleCloudRetailV2CatalogAttribute = (GoogleCloudRetailV2CatalogAttribute) o;
    return Objects.equals(this.dynamicFacetableOption, googleCloudRetailV2CatalogAttribute.dynamicFacetableOption) &&
        Objects.equals(this.exactSearchableOption, googleCloudRetailV2CatalogAttribute.exactSearchableOption) &&
        Objects.equals(this.facetConfig, googleCloudRetailV2CatalogAttribute.facetConfig) &&
        Objects.equals(this.inUse, googleCloudRetailV2CatalogAttribute.inUse) &&
        Objects.equals(this.indexableOption, googleCloudRetailV2CatalogAttribute.indexableOption) &&
        Objects.equals(this.key, googleCloudRetailV2CatalogAttribute.key) &&
        Objects.equals(this.retrievableOption, googleCloudRetailV2CatalogAttribute.retrievableOption) &&
        Objects.equals(this.searchableOption, googleCloudRetailV2CatalogAttribute.searchableOption) &&
        Objects.equals(this.type, googleCloudRetailV2CatalogAttribute.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dynamicFacetableOption, exactSearchableOption, facetConfig, inUse, indexableOption, key, retrievableOption, searchableOption, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleCloudRetailV2CatalogAttribute {\n");
    sb.append("    dynamicFacetableOption: ").append(toIndentedString(dynamicFacetableOption)).append("\n");
    sb.append("    exactSearchableOption: ").append(toIndentedString(exactSearchableOption)).append("\n");
    sb.append("    facetConfig: ").append(toIndentedString(facetConfig)).append("\n");
    sb.append("    inUse: ").append(toIndentedString(inUse)).append("\n");
    sb.append("    indexableOption: ").append(toIndentedString(indexableOption)).append("\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    retrievableOption: ").append(toIndentedString(retrievableOption)).append("\n");
    sb.append("    searchableOption: ").append(toIndentedString(searchableOption)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dynamicFacetableOption");
    openapiFields.add("exactSearchableOption");
    openapiFields.add("facetConfig");
    openapiFields.add("inUse");
    openapiFields.add("indexableOption");
    openapiFields.add("key");
    openapiFields.add("retrievableOption");
    openapiFields.add("searchableOption");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleCloudRetailV2CatalogAttribute
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleCloudRetailV2CatalogAttribute.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleCloudRetailV2CatalogAttribute is not found in the empty JSON string", GoogleCloudRetailV2CatalogAttribute.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleCloudRetailV2CatalogAttribute.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleCloudRetailV2CatalogAttribute` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("dynamicFacetableOption") != null && !jsonObj.get("dynamicFacetableOption").isJsonNull()) && !jsonObj.get("dynamicFacetableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dynamicFacetableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dynamicFacetableOption").toString()));
      }
      // validate the optional field `dynamicFacetableOption`
      if (jsonObj.get("dynamicFacetableOption") != null && !jsonObj.get("dynamicFacetableOption").isJsonNull()) {
        DynamicFacetableOptionEnum.validateJsonElement(jsonObj.get("dynamicFacetableOption"));
      }
      if ((jsonObj.get("exactSearchableOption") != null && !jsonObj.get("exactSearchableOption").isJsonNull()) && !jsonObj.get("exactSearchableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `exactSearchableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("exactSearchableOption").toString()));
      }
      // validate the optional field `exactSearchableOption`
      if (jsonObj.get("exactSearchableOption") != null && !jsonObj.get("exactSearchableOption").isJsonNull()) {
        ExactSearchableOptionEnum.validateJsonElement(jsonObj.get("exactSearchableOption"));
      }
      // validate the optional field `facetConfig`
      if (jsonObj.get("facetConfig") != null && !jsonObj.get("facetConfig").isJsonNull()) {
        GoogleCloudRetailV2CatalogAttributeFacetConfig.validateJsonElement(jsonObj.get("facetConfig"));
      }
      if ((jsonObj.get("indexableOption") != null && !jsonObj.get("indexableOption").isJsonNull()) && !jsonObj.get("indexableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `indexableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("indexableOption").toString()));
      }
      // validate the optional field `indexableOption`
      if (jsonObj.get("indexableOption") != null && !jsonObj.get("indexableOption").isJsonNull()) {
        IndexableOptionEnum.validateJsonElement(jsonObj.get("indexableOption"));
      }
      if ((jsonObj.get("key") != null && !jsonObj.get("key").isJsonNull()) && !jsonObj.get("key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key").toString()));
      }
      if ((jsonObj.get("retrievableOption") != null && !jsonObj.get("retrievableOption").isJsonNull()) && !jsonObj.get("retrievableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `retrievableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("retrievableOption").toString()));
      }
      // validate the optional field `retrievableOption`
      if (jsonObj.get("retrievableOption") != null && !jsonObj.get("retrievableOption").isJsonNull()) {
        RetrievableOptionEnum.validateJsonElement(jsonObj.get("retrievableOption"));
      }
      if ((jsonObj.get("searchableOption") != null && !jsonObj.get("searchableOption").isJsonNull()) && !jsonObj.get("searchableOption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `searchableOption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("searchableOption").toString()));
      }
      // validate the optional field `searchableOption`
      if (jsonObj.get("searchableOption") != null && !jsonObj.get("searchableOption").isJsonNull()) {
        SearchableOptionEnum.validateJsonElement(jsonObj.get("searchableOption"));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleCloudRetailV2CatalogAttribute.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleCloudRetailV2CatalogAttribute' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleCloudRetailV2CatalogAttribute> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleCloudRetailV2CatalogAttribute.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleCloudRetailV2CatalogAttribute>() {
           @Override
           public void write(JsonWriter out, GoogleCloudRetailV2CatalogAttribute value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleCloudRetailV2CatalogAttribute read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleCloudRetailV2CatalogAttribute given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleCloudRetailV2CatalogAttribute
   * @throws IOException if the JSON string is invalid with respect to GoogleCloudRetailV2CatalogAttribute
   */
  public static GoogleCloudRetailV2CatalogAttribute fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleCloudRetailV2CatalogAttribute.class);
  }

  /**
   * Convert an instance of GoogleCloudRetailV2CatalogAttribute to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

