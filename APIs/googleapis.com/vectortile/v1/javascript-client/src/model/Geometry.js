/**
 * Semantic Tile API
 * Serves vector tiles containing geospatial data. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Area from './Area';
import ExtrudedArea from './ExtrudedArea';
import Line from './Line';
import ModeledVolume from './ModeledVolume';

/**
 * The Geometry model module.
 * @module model/Geometry
 * @version v1
 */
class Geometry {
    /**
     * Constructs a new <code>Geometry</code>.
     * Represents the geometry of a feature, that is, the shape that it has on the map. The local tile coordinate system has the origin at the north-west (upper-left) corner of the tile, and is scaled to 4096 units across each edge. The height (Z) axis has the same scale factor: an extruded area with a max_z value of 4096 has the same height as the width of the tile that it is on. There is no clipping boundary, so it is possible that some coordinates will lie outside the tile boundaries.
     * @alias module:model/Geometry
     */
    constructor() { 
        
        Geometry.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Geometry</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Geometry} obj Optional instance to populate.
     * @return {module:model/Geometry} The populated <code>Geometry</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Geometry();

            if (data.hasOwnProperty('areas')) {
                obj['areas'] = ApiClient.convertToType(data['areas'], [Area]);
            }
            if (data.hasOwnProperty('extrudedAreas')) {
                obj['extrudedAreas'] = ApiClient.convertToType(data['extrudedAreas'], [ExtrudedArea]);
            }
            if (data.hasOwnProperty('lines')) {
                obj['lines'] = ApiClient.convertToType(data['lines'], [Line]);
            }
            if (data.hasOwnProperty('modeledVolumes')) {
                obj['modeledVolumes'] = ApiClient.convertToType(data['modeledVolumes'], [ModeledVolume]);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Geometry</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Geometry</code>.
     */
    static validateJSON(data) {
        if (data['areas']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['areas'])) {
                throw new Error("Expected the field `areas` to be an array in the JSON data but got " + data['areas']);
            }
            // validate the optional field `areas` (array)
            for (const item of data['areas']) {
                Area.validateJSON(item);
            };
        }
        if (data['extrudedAreas']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['extrudedAreas'])) {
                throw new Error("Expected the field `extrudedAreas` to be an array in the JSON data but got " + data['extrudedAreas']);
            }
            // validate the optional field `extrudedAreas` (array)
            for (const item of data['extrudedAreas']) {
                ExtrudedArea.validateJSON(item);
            };
        }
        if (data['lines']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['lines'])) {
                throw new Error("Expected the field `lines` to be an array in the JSON data but got " + data['lines']);
            }
            // validate the optional field `lines` (array)
            for (const item of data['lines']) {
                Line.validateJSON(item);
            };
        }
        if (data['modeledVolumes']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['modeledVolumes'])) {
                throw new Error("Expected the field `modeledVolumes` to be an array in the JSON data but got " + data['modeledVolumes']);
            }
            // validate the optional field `modeledVolumes` (array)
            for (const item of data['modeledVolumes']) {
                ModeledVolume.validateJSON(item);
            };
        }

        return true;
    }


}



/**
 * The areas present in this geometry.
 * @member {Array.<module:model/Area>} areas
 */
Geometry.prototype['areas'] = undefined;

/**
 * The extruded areas present in this geometry. Not populated if modeled_volumes are included in this geometry unless always_include_building_footprints is set in GetFeatureTileRequest, in which case the client should decide which (extruded areas or modeled volumes) should be used (they should not be rendered together).
 * @member {Array.<module:model/ExtrudedArea>} extrudedAreas
 */
Geometry.prototype['extrudedAreas'] = undefined;

/**
 * The lines present in this geometry.
 * @member {Array.<module:model/Line>} lines
 */
Geometry.prototype['lines'] = undefined;

/**
 * The modeled volumes present in this geometry. Not populated unless enable_modeled_volumes has been set in GetFeatureTileRequest.
 * @member {Array.<module:model/ModeledVolume>} modeledVolumes
 */
Geometry.prototype['modeledVolumes'] = undefined;






export default Geometry;

