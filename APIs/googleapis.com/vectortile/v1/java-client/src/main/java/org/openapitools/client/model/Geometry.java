/*
 * Semantic Tile API
 * Serves vector tiles containing geospatial data. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Area;
import org.openapitools.client.model.ExtrudedArea;
import org.openapitools.client.model.Line;
import org.openapitools.client.model.ModeledVolume;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents the geometry of a feature, that is, the shape that it has on the map. The local tile coordinate system has the origin at the north-west (upper-left) corner of the tile, and is scaled to 4096 units across each edge. The height (Z) axis has the same scale factor: an extruded area with a max_z value of 4096 has the same height as the width of the tile that it is on. There is no clipping boundary, so it is possible that some coordinates will lie outside the tile boundaries.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:42.618245-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Geometry {
  public static final String SERIALIZED_NAME_AREAS = "areas";
  @SerializedName(SERIALIZED_NAME_AREAS)
  private List<Area> areas = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXTRUDED_AREAS = "extrudedAreas";
  @SerializedName(SERIALIZED_NAME_EXTRUDED_AREAS)
  private List<ExtrudedArea> extrudedAreas = new ArrayList<>();

  public static final String SERIALIZED_NAME_LINES = "lines";
  @SerializedName(SERIALIZED_NAME_LINES)
  private List<Line> lines = new ArrayList<>();

  public static final String SERIALIZED_NAME_MODELED_VOLUMES = "modeledVolumes";
  @SerializedName(SERIALIZED_NAME_MODELED_VOLUMES)
  private List<ModeledVolume> modeledVolumes = new ArrayList<>();

  public Geometry() {
  }

  public Geometry areas(List<Area> areas) {
    this.areas = areas;
    return this;
  }

  public Geometry addAreasItem(Area areasItem) {
    if (this.areas == null) {
      this.areas = new ArrayList<>();
    }
    this.areas.add(areasItem);
    return this;
  }

  /**
   * The areas present in this geometry.
   * @return areas
   */
  @javax.annotation.Nullable
  public List<Area> getAreas() {
    return areas;
  }

  public void setAreas(List<Area> areas) {
    this.areas = areas;
  }


  public Geometry extrudedAreas(List<ExtrudedArea> extrudedAreas) {
    this.extrudedAreas = extrudedAreas;
    return this;
  }

  public Geometry addExtrudedAreasItem(ExtrudedArea extrudedAreasItem) {
    if (this.extrudedAreas == null) {
      this.extrudedAreas = new ArrayList<>();
    }
    this.extrudedAreas.add(extrudedAreasItem);
    return this;
  }

  /**
   * The extruded areas present in this geometry. Not populated if modeled_volumes are included in this geometry unless always_include_building_footprints is set in GetFeatureTileRequest, in which case the client should decide which (extruded areas or modeled volumes) should be used (they should not be rendered together).
   * @return extrudedAreas
   */
  @javax.annotation.Nullable
  public List<ExtrudedArea> getExtrudedAreas() {
    return extrudedAreas;
  }

  public void setExtrudedAreas(List<ExtrudedArea> extrudedAreas) {
    this.extrudedAreas = extrudedAreas;
  }


  public Geometry lines(List<Line> lines) {
    this.lines = lines;
    return this;
  }

  public Geometry addLinesItem(Line linesItem) {
    if (this.lines == null) {
      this.lines = new ArrayList<>();
    }
    this.lines.add(linesItem);
    return this;
  }

  /**
   * The lines present in this geometry.
   * @return lines
   */
  @javax.annotation.Nullable
  public List<Line> getLines() {
    return lines;
  }

  public void setLines(List<Line> lines) {
    this.lines = lines;
  }


  public Geometry modeledVolumes(List<ModeledVolume> modeledVolumes) {
    this.modeledVolumes = modeledVolumes;
    return this;
  }

  public Geometry addModeledVolumesItem(ModeledVolume modeledVolumesItem) {
    if (this.modeledVolumes == null) {
      this.modeledVolumes = new ArrayList<>();
    }
    this.modeledVolumes.add(modeledVolumesItem);
    return this;
  }

  /**
   * The modeled volumes present in this geometry. Not populated unless enable_modeled_volumes has been set in GetFeatureTileRequest.
   * @return modeledVolumes
   */
  @javax.annotation.Nullable
  public List<ModeledVolume> getModeledVolumes() {
    return modeledVolumes;
  }

  public void setModeledVolumes(List<ModeledVolume> modeledVolumes) {
    this.modeledVolumes = modeledVolumes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Geometry geometry = (Geometry) o;
    return Objects.equals(this.areas, geometry.areas) &&
        Objects.equals(this.extrudedAreas, geometry.extrudedAreas) &&
        Objects.equals(this.lines, geometry.lines) &&
        Objects.equals(this.modeledVolumes, geometry.modeledVolumes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(areas, extrudedAreas, lines, modeledVolumes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Geometry {\n");
    sb.append("    areas: ").append(toIndentedString(areas)).append("\n");
    sb.append("    extrudedAreas: ").append(toIndentedString(extrudedAreas)).append("\n");
    sb.append("    lines: ").append(toIndentedString(lines)).append("\n");
    sb.append("    modeledVolumes: ").append(toIndentedString(modeledVolumes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("areas");
    openapiFields.add("extrudedAreas");
    openapiFields.add("lines");
    openapiFields.add("modeledVolumes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Geometry
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Geometry.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Geometry is not found in the empty JSON string", Geometry.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Geometry.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Geometry` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("areas") != null && !jsonObj.get("areas").isJsonNull()) {
        JsonArray jsonArrayareas = jsonObj.getAsJsonArray("areas");
        if (jsonArrayareas != null) {
          // ensure the json data is an array
          if (!jsonObj.get("areas").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `areas` to be an array in the JSON string but got `%s`", jsonObj.get("areas").toString()));
          }

          // validate the optional field `areas` (array)
          for (int i = 0; i < jsonArrayareas.size(); i++) {
            Area.validateJsonElement(jsonArrayareas.get(i));
          };
        }
      }
      if (jsonObj.get("extrudedAreas") != null && !jsonObj.get("extrudedAreas").isJsonNull()) {
        JsonArray jsonArrayextrudedAreas = jsonObj.getAsJsonArray("extrudedAreas");
        if (jsonArrayextrudedAreas != null) {
          // ensure the json data is an array
          if (!jsonObj.get("extrudedAreas").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `extrudedAreas` to be an array in the JSON string but got `%s`", jsonObj.get("extrudedAreas").toString()));
          }

          // validate the optional field `extrudedAreas` (array)
          for (int i = 0; i < jsonArrayextrudedAreas.size(); i++) {
            ExtrudedArea.validateJsonElement(jsonArrayextrudedAreas.get(i));
          };
        }
      }
      if (jsonObj.get("lines") != null && !jsonObj.get("lines").isJsonNull()) {
        JsonArray jsonArraylines = jsonObj.getAsJsonArray("lines");
        if (jsonArraylines != null) {
          // ensure the json data is an array
          if (!jsonObj.get("lines").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `lines` to be an array in the JSON string but got `%s`", jsonObj.get("lines").toString()));
          }

          // validate the optional field `lines` (array)
          for (int i = 0; i < jsonArraylines.size(); i++) {
            Line.validateJsonElement(jsonArraylines.get(i));
          };
        }
      }
      if (jsonObj.get("modeledVolumes") != null && !jsonObj.get("modeledVolumes").isJsonNull()) {
        JsonArray jsonArraymodeledVolumes = jsonObj.getAsJsonArray("modeledVolumes");
        if (jsonArraymodeledVolumes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("modeledVolumes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `modeledVolumes` to be an array in the JSON string but got `%s`", jsonObj.get("modeledVolumes").toString()));
          }

          // validate the optional field `modeledVolumes` (array)
          for (int i = 0; i < jsonArraymodeledVolumes.size(); i++) {
            ModeledVolume.validateJsonElement(jsonArraymodeledVolumes.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Geometry.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Geometry' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Geometry> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Geometry.class));

       return (TypeAdapter<T>) new TypeAdapter<Geometry>() {
           @Override
           public void write(JsonWriter out, Geometry value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Geometry read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Geometry given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Geometry
   * @throws IOException if the JSON string is invalid with respect to Geometry
   */
  public static Geometry fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Geometry.class);
  }

  /**
   * Convert an instance of Geometry to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

