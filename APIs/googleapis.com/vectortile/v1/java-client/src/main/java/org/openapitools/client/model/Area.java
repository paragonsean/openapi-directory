/*
 * Semantic Tile API
 * Serves vector tiles containing geospatial data. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BasemapZOrder;
import org.openapitools.client.model.Vertex2DList;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents an area. Used to represent regions such as water, parks, etc. Next ID: 10
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:42.618245-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Area {
  public static final String SERIALIZED_NAME_BASEMAP_Z_ORDER = "basemapZOrder";
  @SerializedName(SERIALIZED_NAME_BASEMAP_Z_ORDER)
  private BasemapZOrder basemapZOrder;

  public static final String SERIALIZED_NAME_HAS_EXTERNAL_EDGES = "hasExternalEdges";
  @SerializedName(SERIALIZED_NAME_HAS_EXTERNAL_EDGES)
  private Boolean hasExternalEdges;

  public static final String SERIALIZED_NAME_INTERNAL_EDGES = "internalEdges";
  @SerializedName(SERIALIZED_NAME_INTERNAL_EDGES)
  private List<Integer> internalEdges = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOOP_BREAKS = "loopBreaks";
  @SerializedName(SERIALIZED_NAME_LOOP_BREAKS)
  private List<Integer> loopBreaks = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRIANGLE_INDICES = "triangleIndices";
  @SerializedName(SERIALIZED_NAME_TRIANGLE_INDICES)
  private List<Integer> triangleIndices = new ArrayList<>();

  /**
   * The polygon encoding type used for this area.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    TRIANGLE_FAN("TRIANGLE_FAN"),
    
    INDEXED_TRIANGLES("INDEXED_TRIANGLES"),
    
    TRIANGLE_STRIP("TRIANGLE_STRIP");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public static final String SERIALIZED_NAME_VERTEX_OFFSETS = "vertexOffsets";
  @SerializedName(SERIALIZED_NAME_VERTEX_OFFSETS)
  private Vertex2DList vertexOffsets;

  public static final String SERIALIZED_NAME_Z_ORDER = "zOrder";
  @SerializedName(SERIALIZED_NAME_Z_ORDER)
  private Integer zOrder;

  public Area() {
  }

  public Area basemapZOrder(BasemapZOrder basemapZOrder) {
    this.basemapZOrder = basemapZOrder;
    return this;
  }

  /**
   * Get basemapZOrder
   * @return basemapZOrder
   */
  @javax.annotation.Nullable
  public BasemapZOrder getBasemapZOrder() {
    return basemapZOrder;
  }

  public void setBasemapZOrder(BasemapZOrder basemapZOrder) {
    this.basemapZOrder = basemapZOrder;
  }


  public Area hasExternalEdges(Boolean hasExternalEdges) {
    this.hasExternalEdges = hasExternalEdges;
    return this;
  }

  /**
   * True if the polygon is not entirely internal to the feature that it belongs to: that is, some of the edges are bordering another feature.
   * @return hasExternalEdges
   */
  @javax.annotation.Nullable
  public Boolean getHasExternalEdges() {
    return hasExternalEdges;
  }

  public void setHasExternalEdges(Boolean hasExternalEdges) {
    this.hasExternalEdges = hasExternalEdges;
  }


  public Area internalEdges(List<Integer> internalEdges) {
    this.internalEdges = internalEdges;
    return this;
  }

  public Area addInternalEdgesItem(Integer internalEdgesItem) {
    if (this.internalEdges == null) {
      this.internalEdges = new ArrayList<>();
    }
    this.internalEdges.add(internalEdgesItem);
    return this;
  }

  /**
   * When has_external_edges is true, the polygon has some edges that border another feature. This field indicates the internal edges that do not border another feature. Each value is an index into the vertices array, and denotes the start vertex of the internal edge (the next vertex in the boundary loop is the end of the edge). If the selected vertex is the last vertex in the boundary loop, then the edge between that vertex and the starting vertex of the loop is internal. This field may be used for styling. For example, building parapets could be placed only on the external edges of a building polygon, or water could be lighter colored near the external edges of a body of water. If has_external_edges is false, all edges are internal and this field will be empty.
   * @return internalEdges
   */
  @javax.annotation.Nullable
  public List<Integer> getInternalEdges() {
    return internalEdges;
  }

  public void setInternalEdges(List<Integer> internalEdges) {
    this.internalEdges = internalEdges;
  }


  public Area loopBreaks(List<Integer> loopBreaks) {
    this.loopBreaks = loopBreaks;
    return this;
  }

  public Area addLoopBreaksItem(Integer loopBreaksItem) {
    if (this.loopBreaks == null) {
      this.loopBreaks = new ArrayList<>();
    }
    this.loopBreaks.add(loopBreaksItem);
    return this;
  }

  /**
   * Identifies the boundary loops of the polygon. Only set for INDEXED_TRIANGLE polygons. Each value is an index into the vertices array indicating the beginning of a loop. For instance, values of [2, 5] would indicate loop_data contained 3 loops with indices 0-1, 2-4, and 5-end. This may be used in conjunction with the internal_edges field for styling polygon boundaries. Note that an edge may be on a polygon boundary but still internal to the feature. For example, a feature split across multiple tiles will have an internal polygon boundary edge along the edge of the tile.
   * @return loopBreaks
   */
  @javax.annotation.Nullable
  public List<Integer> getLoopBreaks() {
    return loopBreaks;
  }

  public void setLoopBreaks(List<Integer> loopBreaks) {
    this.loopBreaks = loopBreaks;
  }


  public Area triangleIndices(List<Integer> triangleIndices) {
    this.triangleIndices = triangleIndices;
    return this;
  }

  public Area addTriangleIndicesItem(Integer triangleIndicesItem) {
    if (this.triangleIndices == null) {
      this.triangleIndices = new ArrayList<>();
    }
    this.triangleIndices.add(triangleIndicesItem);
    return this;
  }

  /**
   * When the polygon encoding is of type INDEXED_TRIANGLES, this contains the indices of the triangle vertices in the vertex_offsets field. There are 3 vertex indices per triangle.
   * @return triangleIndices
   */
  @javax.annotation.Nullable
  public List<Integer> getTriangleIndices() {
    return triangleIndices;
  }

  public void setTriangleIndices(List<Integer> triangleIndices) {
    this.triangleIndices = triangleIndices;
  }


  public Area type(TypeEnum type) {
    this.type = type;
    return this;
  }

  /**
   * The polygon encoding type used for this area.
   * @return type
   */
  @javax.annotation.Nullable
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  public Area vertexOffsets(Vertex2DList vertexOffsets) {
    this.vertexOffsets = vertexOffsets;
    return this;
  }

  /**
   * Get vertexOffsets
   * @return vertexOffsets
   */
  @javax.annotation.Nullable
  public Vertex2DList getVertexOffsets() {
    return vertexOffsets;
  }

  public void setVertexOffsets(Vertex2DList vertexOffsets) {
    this.vertexOffsets = vertexOffsets;
  }


  public Area zOrder(Integer zOrder) {
    this.zOrder = zOrder;
    return this;
  }

  /**
   * The z-ordering of this area. Areas with a lower z-order should be rendered beneath areas with a higher z-order. This z-ordering does not imply anything about the altitude of the line relative to the ground, but it can be used to prevent z-fighting during rendering on the client. This z-ordering can only be used to compare areas, and cannot be compared with the z_order field in the Line message. The z-order may be negative or zero. Prefer Area.basemap_z_order.
   * @return zOrder
   */
  @javax.annotation.Nullable
  public Integer getzOrder() {
    return zOrder;
  }

  public void setzOrder(Integer zOrder) {
    this.zOrder = zOrder;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Area area = (Area) o;
    return Objects.equals(this.basemapZOrder, area.basemapZOrder) &&
        Objects.equals(this.hasExternalEdges, area.hasExternalEdges) &&
        Objects.equals(this.internalEdges, area.internalEdges) &&
        Objects.equals(this.loopBreaks, area.loopBreaks) &&
        Objects.equals(this.triangleIndices, area.triangleIndices) &&
        Objects.equals(this.type, area.type) &&
        Objects.equals(this.vertexOffsets, area.vertexOffsets) &&
        Objects.equals(this.zOrder, area.zOrder);
  }

  @Override
  public int hashCode() {
    return Objects.hash(basemapZOrder, hasExternalEdges, internalEdges, loopBreaks, triangleIndices, type, vertexOffsets, zOrder);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Area {\n");
    sb.append("    basemapZOrder: ").append(toIndentedString(basemapZOrder)).append("\n");
    sb.append("    hasExternalEdges: ").append(toIndentedString(hasExternalEdges)).append("\n");
    sb.append("    internalEdges: ").append(toIndentedString(internalEdges)).append("\n");
    sb.append("    loopBreaks: ").append(toIndentedString(loopBreaks)).append("\n");
    sb.append("    triangleIndices: ").append(toIndentedString(triangleIndices)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    vertexOffsets: ").append(toIndentedString(vertexOffsets)).append("\n");
    sb.append("    zOrder: ").append(toIndentedString(zOrder)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("basemapZOrder");
    openapiFields.add("hasExternalEdges");
    openapiFields.add("internalEdges");
    openapiFields.add("loopBreaks");
    openapiFields.add("triangleIndices");
    openapiFields.add("type");
    openapiFields.add("vertexOffsets");
    openapiFields.add("zOrder");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Area
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Area.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Area is not found in the empty JSON string", Area.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Area.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Area` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `basemapZOrder`
      if (jsonObj.get("basemapZOrder") != null && !jsonObj.get("basemapZOrder").isJsonNull()) {
        BasemapZOrder.validateJsonElement(jsonObj.get("basemapZOrder"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("internalEdges") != null && !jsonObj.get("internalEdges").isJsonNull() && !jsonObj.get("internalEdges").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `internalEdges` to be an array in the JSON string but got `%s`", jsonObj.get("internalEdges").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("loopBreaks") != null && !jsonObj.get("loopBreaks").isJsonNull() && !jsonObj.get("loopBreaks").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `loopBreaks` to be an array in the JSON string but got `%s`", jsonObj.get("loopBreaks").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("triangleIndices") != null && !jsonObj.get("triangleIndices").isJsonNull() && !jsonObj.get("triangleIndices").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `triangleIndices` to be an array in the JSON string but got `%s`", jsonObj.get("triangleIndices").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TypeEnum.validateJsonElement(jsonObj.get("type"));
      }
      // validate the optional field `vertexOffsets`
      if (jsonObj.get("vertexOffsets") != null && !jsonObj.get("vertexOffsets").isJsonNull()) {
        Vertex2DList.validateJsonElement(jsonObj.get("vertexOffsets"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Area.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Area' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Area> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Area.class));

       return (TypeAdapter<T>) new TypeAdapter<Area>() {
           @Override
           public void write(JsonWriter out, Area value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Area read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Area given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Area
   * @throws IOException if the JSON string is invalid with respect to Area
   */
  public static Area fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Area.class);
  }

  /**
   * Convert an instance of Area to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

