/*
 * Semantic Tile API
 * Serves vector tiles containing geospatial data. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Row;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A packed representation of a 2D grid of uniformly spaced points containing elevation data. Each point within the grid represents the altitude in meters above average sea level at that location within the tile. Elevations provided are (generally) relative to the EGM96 geoid, however some areas will be relative to NAVD88. EGM96 and NAVD88 are off by no more than 2 meters. The grid is oriented north-west to south-east, as illustrated: rows[0].a[0] rows[0].a[m] +-----------------+ | | | N | | ^ | | | | | W &lt;-----&gt; E | | | | | v | | S | | | +-----------------+ rows[n].a[0] rows[n].a[m] Rather than storing the altitudes directly, we store the diffs between them as integers at some requested level of precision to take advantage of integer packing. The actual altitude values a[] can be reconstructed using the scale and each row&#39;s first_altitude and altitude_diff fields. More details in go/elevation-encoding-options-for-enduro under \&quot;Recommended implementation\&quot;.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:42.618245-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FirstDerivativeElevationGrid {
  public static final String SERIALIZED_NAME_ALTITUDE_MULTIPLIER = "altitudeMultiplier";
  @SerializedName(SERIALIZED_NAME_ALTITUDE_MULTIPLIER)
  private Float altitudeMultiplier;

  public static final String SERIALIZED_NAME_ROWS = "rows";
  @SerializedName(SERIALIZED_NAME_ROWS)
  private List<Row> rows = new ArrayList<>();

  public FirstDerivativeElevationGrid() {
  }

  public FirstDerivativeElevationGrid altitudeMultiplier(Float altitudeMultiplier) {
    this.altitudeMultiplier = altitudeMultiplier;
    return this;
  }

  /**
   * A multiplier applied to the altitude fields below to extract the actual altitudes in meters from the elevation grid.
   * @return altitudeMultiplier
   */
  @javax.annotation.Nullable
  public Float getAltitudeMultiplier() {
    return altitudeMultiplier;
  }

  public void setAltitudeMultiplier(Float altitudeMultiplier) {
    this.altitudeMultiplier = altitudeMultiplier;
  }


  public FirstDerivativeElevationGrid rows(List<Row> rows) {
    this.rows = rows;
    return this;
  }

  public FirstDerivativeElevationGrid addRowsItem(Row rowsItem) {
    if (this.rows == null) {
      this.rows = new ArrayList<>();
    }
    this.rows.add(rowsItem);
    return this;
  }

  /**
   * Rows of points containing altitude data making up the elevation grid. Each row is the same length. Rows are ordered from north to south. E.g: rows[0] is the north-most row, and rows[n] is the south-most row.
   * @return rows
   */
  @javax.annotation.Nullable
  public List<Row> getRows() {
    return rows;
  }

  public void setRows(List<Row> rows) {
    this.rows = rows;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FirstDerivativeElevationGrid firstDerivativeElevationGrid = (FirstDerivativeElevationGrid) o;
    return Objects.equals(this.altitudeMultiplier, firstDerivativeElevationGrid.altitudeMultiplier) &&
        Objects.equals(this.rows, firstDerivativeElevationGrid.rows);
  }

  @Override
  public int hashCode() {
    return Objects.hash(altitudeMultiplier, rows);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FirstDerivativeElevationGrid {\n");
    sb.append("    altitudeMultiplier: ").append(toIndentedString(altitudeMultiplier)).append("\n");
    sb.append("    rows: ").append(toIndentedString(rows)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("altitudeMultiplier");
    openapiFields.add("rows");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FirstDerivativeElevationGrid
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FirstDerivativeElevationGrid.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FirstDerivativeElevationGrid is not found in the empty JSON string", FirstDerivativeElevationGrid.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FirstDerivativeElevationGrid.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FirstDerivativeElevationGrid` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("rows") != null && !jsonObj.get("rows").isJsonNull()) {
        JsonArray jsonArrayrows = jsonObj.getAsJsonArray("rows");
        if (jsonArrayrows != null) {
          // ensure the json data is an array
          if (!jsonObj.get("rows").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `rows` to be an array in the JSON string but got `%s`", jsonObj.get("rows").toString()));
          }

          // validate the optional field `rows` (array)
          for (int i = 0; i < jsonArrayrows.size(); i++) {
            Row.validateJsonElement(jsonArrayrows.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FirstDerivativeElevationGrid.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FirstDerivativeElevationGrid' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FirstDerivativeElevationGrid> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FirstDerivativeElevationGrid.class));

       return (TypeAdapter<T>) new TypeAdapter<FirstDerivativeElevationGrid>() {
           @Override
           public void write(JsonWriter out, FirstDerivativeElevationGrid value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FirstDerivativeElevationGrid read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FirstDerivativeElevationGrid given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FirstDerivativeElevationGrid
   * @throws IOException if the JSON string is invalid with respect to FirstDerivativeElevationGrid
   */
  public static FirstDerivativeElevationGrid fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FirstDerivativeElevationGrid.class);
  }

  /**
   * Convert an instance of FirstDerivativeElevationGrid to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

