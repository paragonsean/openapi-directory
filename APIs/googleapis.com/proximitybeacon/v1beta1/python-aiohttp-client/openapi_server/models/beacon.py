# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.advertised_id import AdvertisedId
from openapi_server.models.ephemeral_id_registration import EphemeralIdRegistration
from openapi_server.models.indoor_level import IndoorLevel
from openapi_server.models.lat_lng import LatLng
from openapi_server import util


class Beacon(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, advertised_id: AdvertisedId=None, beacon_name: str=None, description: str=None, ephemeral_id_registration: EphemeralIdRegistration=None, expected_stability: str=None, indoor_level: IndoorLevel=None, lat_lng: LatLng=None, place_id: str=None, properties: Dict[str, str]=None, provisioning_key: str=None, status: str=None):
        """Beacon - a model defined in OpenAPI

        :param advertised_id: The advertised_id of this Beacon.
        :param beacon_name: The beacon_name of this Beacon.
        :param description: The description of this Beacon.
        :param ephemeral_id_registration: The ephemeral_id_registration of this Beacon.
        :param expected_stability: The expected_stability of this Beacon.
        :param indoor_level: The indoor_level of this Beacon.
        :param lat_lng: The lat_lng of this Beacon.
        :param place_id: The place_id of this Beacon.
        :param properties: The properties of this Beacon.
        :param provisioning_key: The provisioning_key of this Beacon.
        :param status: The status of this Beacon.
        """
        self.openapi_types = {
            'advertised_id': AdvertisedId,
            'beacon_name': str,
            'description': str,
            'ephemeral_id_registration': EphemeralIdRegistration,
            'expected_stability': str,
            'indoor_level': IndoorLevel,
            'lat_lng': LatLng,
            'place_id': str,
            'properties': Dict[str, str],
            'provisioning_key': str,
            'status': str
        }

        self.attribute_map = {
            'advertised_id': 'advertisedId',
            'beacon_name': 'beaconName',
            'description': 'description',
            'ephemeral_id_registration': 'ephemeralIdRegistration',
            'expected_stability': 'expectedStability',
            'indoor_level': 'indoorLevel',
            'lat_lng': 'latLng',
            'place_id': 'placeId',
            'properties': 'properties',
            'provisioning_key': 'provisioningKey',
            'status': 'status'
        }

        self._advertised_id = advertised_id
        self._beacon_name = beacon_name
        self._description = description
        self._ephemeral_id_registration = ephemeral_id_registration
        self._expected_stability = expected_stability
        self._indoor_level = indoor_level
        self._lat_lng = lat_lng
        self._place_id = place_id
        self._properties = properties
        self._provisioning_key = provisioning_key
        self._status = status

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Beacon':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Beacon of this Beacon.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def advertised_id(self):
        """Gets the advertised_id of this Beacon.


        :return: The advertised_id of this Beacon.
        :rtype: AdvertisedId
        """
        return self._advertised_id

    @advertised_id.setter
    def advertised_id(self, advertised_id):
        """Sets the advertised_id of this Beacon.


        :param advertised_id: The advertised_id of this Beacon.
        :type advertised_id: AdvertisedId
        """

        self._advertised_id = advertised_id

    @property
    def beacon_name(self):
        """Gets the beacon_name of this Beacon.

        Resource name of this beacon. A beacon name has the format \"beacons/N!beaconId\" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon's type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations.

        :return: The beacon_name of this Beacon.
        :rtype: str
        """
        return self._beacon_name

    @beacon_name.setter
    def beacon_name(self, beacon_name):
        """Sets the beacon_name of this Beacon.

        Resource name of this beacon. A beacon name has the format \"beacons/N!beaconId\" where the beaconId is the base16 ID broadcast by the beacon and N is a code for the beacon's type. Possible values are `3` for Eddystone, `1` for iBeacon, or `5` for AltBeacon. This field must be left empty when registering. After reading a beacon, clients can use the name for future operations.

        :param beacon_name: The beacon_name of this Beacon.
        :type beacon_name: str
        """

        self._beacon_name = beacon_name

    @property
    def description(self):
        """Gets the description of this Beacon.

        Free text used to identify and describe the beacon. Maximum length 140 characters. Optional.

        :return: The description of this Beacon.
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this Beacon.

        Free text used to identify and describe the beacon. Maximum length 140 characters. Optional.

        :param description: The description of this Beacon.
        :type description: str
        """

        self._description = description

    @property
    def ephemeral_id_registration(self):
        """Gets the ephemeral_id_registration of this Beacon.


        :return: The ephemeral_id_registration of this Beacon.
        :rtype: EphemeralIdRegistration
        """
        return self._ephemeral_id_registration

    @ephemeral_id_registration.setter
    def ephemeral_id_registration(self, ephemeral_id_registration):
        """Sets the ephemeral_id_registration of this Beacon.


        :param ephemeral_id_registration: The ephemeral_id_registration of this Beacon.
        :type ephemeral_id_registration: EphemeralIdRegistration
        """

        self._ephemeral_id_registration = ephemeral_id_registration

    @property
    def expected_stability(self):
        """Gets the expected_stability of this Beacon.

        Expected location stability. This is set when the beacon is registered or updated, not automatically detected in any way. Optional.

        :return: The expected_stability of this Beacon.
        :rtype: str
        """
        return self._expected_stability

    @expected_stability.setter
    def expected_stability(self, expected_stability):
        """Sets the expected_stability of this Beacon.

        Expected location stability. This is set when the beacon is registered or updated, not automatically detected in any way. Optional.

        :param expected_stability: The expected_stability of this Beacon.
        :type expected_stability: str
        """
        allowed_values = ["STABILITY_UNSPECIFIED", "STABLE", "PORTABLE", "MOBILE", "ROVING"]  # noqa: E501
        if expected_stability not in allowed_values:
            raise ValueError(
                "Invalid value for `expected_stability` ({0}), must be one of {1}"
                .format(expected_stability, allowed_values)
            )

        self._expected_stability = expected_stability

    @property
    def indoor_level(self):
        """Gets the indoor_level of this Beacon.


        :return: The indoor_level of this Beacon.
        :rtype: IndoorLevel
        """
        return self._indoor_level

    @indoor_level.setter
    def indoor_level(self, indoor_level):
        """Sets the indoor_level of this Beacon.


        :param indoor_level: The indoor_level of this Beacon.
        :type indoor_level: IndoorLevel
        """

        self._indoor_level = indoor_level

    @property
    def lat_lng(self):
        """Gets the lat_lng of this Beacon.


        :return: The lat_lng of this Beacon.
        :rtype: LatLng
        """
        return self._lat_lng

    @lat_lng.setter
    def lat_lng(self, lat_lng):
        """Sets the lat_lng of this Beacon.


        :param lat_lng: The lat_lng of this Beacon.
        :type lat_lng: LatLng
        """

        self._lat_lng = lat_lng

    @property
    def place_id(self):
        """Gets the place_id of this Beacon.

        The [Google Places API](/places/place-id) Place ID of the place where the beacon is deployed. This is given when the beacon is registered or updated, not automatically detected in any way. Optional.

        :return: The place_id of this Beacon.
        :rtype: str
        """
        return self._place_id

    @place_id.setter
    def place_id(self, place_id):
        """Sets the place_id of this Beacon.

        The [Google Places API](/places/place-id) Place ID of the place where the beacon is deployed. This is given when the beacon is registered or updated, not automatically detected in any way. Optional.

        :param place_id: The place_id of this Beacon.
        :type place_id: str
        """

        self._place_id = place_id

    @property
    def properties(self):
        """Gets the properties of this Beacon.

        Properties of the beacon device, for example battery type or firmware version. Optional.

        :return: The properties of this Beacon.
        :rtype: Dict[str, str]
        """
        return self._properties

    @properties.setter
    def properties(self, properties):
        """Sets the properties of this Beacon.

        Properties of the beacon device, for example battery type or firmware version. Optional.

        :param properties: The properties of this Beacon.
        :type properties: Dict[str, str]
        """

        self._properties = properties

    @property
    def provisioning_key(self):
        """Gets the provisioning_key of this Beacon.

        Some beacons may require a user to provide an authorization key before changing any of its configuration (e.g. broadcast frames, transmit power). This field provides a place to store and control access to that key. This field is populated in responses to `GET /v1beta1/beacons/3!beaconId` from users with write access to the given beacon. That is to say: If the user is authorized to write the beacon's confidential data in the service, the service considers them authorized to configure the beacon. Note that this key grants nothing on the service, only on the beacon itself.

        :return: The provisioning_key of this Beacon.
        :rtype: str
        """
        return self._provisioning_key

    @provisioning_key.setter
    def provisioning_key(self, provisioning_key):
        """Sets the provisioning_key of this Beacon.

        Some beacons may require a user to provide an authorization key before changing any of its configuration (e.g. broadcast frames, transmit power). This field provides a place to store and control access to that key. This field is populated in responses to `GET /v1beta1/beacons/3!beaconId` from users with write access to the given beacon. That is to say: If the user is authorized to write the beacon's confidential data in the service, the service considers them authorized to configure the beacon. Note that this key grants nothing on the service, only on the beacon itself.

        :param provisioning_key: The provisioning_key of this Beacon.
        :type provisioning_key: str
        """

        self._provisioning_key = provisioning_key

    @property
    def status(self):
        """Gets the status of this Beacon.

        Current status of the beacon. Required.

        :return: The status of this Beacon.
        :rtype: str
        """
        return self._status

    @status.setter
    def status(self, status):
        """Sets the status of this Beacon.

        Current status of the beacon. Required.

        :param status: The status of this Beacon.
        :type status: str
        """
        allowed_values = ["STATUS_UNSPECIFIED", "ACTIVE", "DECOMMISSIONED", "INACTIVE"]  # noqa: E501
        if status not in allowed_values:
            raise ValueError(
                "Invalid value for `status` ({0}), must be one of {1}"
                .format(status, allowed_values)
            )

        self._status = status
