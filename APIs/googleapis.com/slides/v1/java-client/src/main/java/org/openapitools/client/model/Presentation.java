/*
 * Google Slides API
 * Reads and writes Google Slides presentations.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Page;
import org.openapitools.client.model.Size;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Google Slides presentation.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:28.691493-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Presentation {
  public static final String SERIALIZED_NAME_LAYOUTS = "layouts";
  @SerializedName(SERIALIZED_NAME_LAYOUTS)
  private List<Page> layouts = new ArrayList<>();

  public static final String SERIALIZED_NAME_LOCALE = "locale";
  @SerializedName(SERIALIZED_NAME_LOCALE)
  private String locale;

  public static final String SERIALIZED_NAME_MASTERS = "masters";
  @SerializedName(SERIALIZED_NAME_MASTERS)
  private List<Page> masters = new ArrayList<>();

  public static final String SERIALIZED_NAME_NOTES_MASTER = "notesMaster";
  @SerializedName(SERIALIZED_NAME_NOTES_MASTER)
  private Page notesMaster;

  public static final String SERIALIZED_NAME_PAGE_SIZE = "pageSize";
  @SerializedName(SERIALIZED_NAME_PAGE_SIZE)
  private Size pageSize;

  public static final String SERIALIZED_NAME_PRESENTATION_ID = "presentationId";
  @SerializedName(SERIALIZED_NAME_PRESENTATION_ID)
  private String presentationId;

  public static final String SERIALIZED_NAME_REVISION_ID = "revisionId";
  @SerializedName(SERIALIZED_NAME_REVISION_ID)
  private String revisionId;

  public static final String SERIALIZED_NAME_SLIDES = "slides";
  @SerializedName(SERIALIZED_NAME_SLIDES)
  private List<Page> slides = new ArrayList<>();

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  private String title;

  public Presentation() {
  }

  public Presentation layouts(List<Page> layouts) {
    this.layouts = layouts;
    return this;
  }

  public Presentation addLayoutsItem(Page layoutsItem) {
    if (this.layouts == null) {
      this.layouts = new ArrayList<>();
    }
    this.layouts.add(layoutsItem);
    return this;
  }

  /**
   * The layouts in the presentation. A layout is a template that determines how content is arranged and styled on the slides that inherit from that layout.
   * @return layouts
   */
  @javax.annotation.Nullable
  public List<Page> getLayouts() {
    return layouts;
  }

  public void setLayouts(List<Page> layouts) {
    this.layouts = layouts;
  }


  public Presentation locale(String locale) {
    this.locale = locale;
    return this;
  }

  /**
   * The locale of the presentation, as an IETF BCP 47 language tag.
   * @return locale
   */
  @javax.annotation.Nullable
  public String getLocale() {
    return locale;
  }

  public void setLocale(String locale) {
    this.locale = locale;
  }


  public Presentation masters(List<Page> masters) {
    this.masters = masters;
    return this;
  }

  public Presentation addMastersItem(Page mastersItem) {
    if (this.masters == null) {
      this.masters = new ArrayList<>();
    }
    this.masters.add(mastersItem);
    return this;
  }

  /**
   * The slide masters in the presentation. A slide master contains all common page elements and the common properties for a set of layouts. They serve three purposes: - Placeholder shapes on a master contain the default text styles and shape properties of all placeholder shapes on pages that use that master. - The master page properties define the common page properties inherited by its layouts. - Any other shapes on the master slide appear on all slides using that master, regardless of their layout.
   * @return masters
   */
  @javax.annotation.Nullable
  public List<Page> getMasters() {
    return masters;
  }

  public void setMasters(List<Page> masters) {
    this.masters = masters;
  }


  public Presentation notesMaster(Page notesMaster) {
    this.notesMaster = notesMaster;
    return this;
  }

  /**
   * Get notesMaster
   * @return notesMaster
   */
  @javax.annotation.Nullable
  public Page getNotesMaster() {
    return notesMaster;
  }

  public void setNotesMaster(Page notesMaster) {
    this.notesMaster = notesMaster;
  }


  public Presentation pageSize(Size pageSize) {
    this.pageSize = pageSize;
    return this;
  }

  /**
   * Get pageSize
   * @return pageSize
   */
  @javax.annotation.Nullable
  public Size getPageSize() {
    return pageSize;
  }

  public void setPageSize(Size pageSize) {
    this.pageSize = pageSize;
  }


  public Presentation presentationId(String presentationId) {
    this.presentationId = presentationId;
    return this;
  }

  /**
   * The ID of the presentation.
   * @return presentationId
   */
  @javax.annotation.Nullable
  public String getPresentationId() {
    return presentationId;
  }

  public void setPresentationId(String presentationId) {
    this.presentationId = presentationId;
  }


  public Presentation revisionId(String revisionId) {
    this.revisionId = revisionId;
    return this;
  }

  /**
   * Output only. The revision ID of the presentation. Can be used in update requests to assert the presentation revision hasn&#39;t changed since the last read operation. Only populated if the user has edit access to the presentation. The revision ID is not a sequential number but a nebulous string. The format of the revision ID may change over time, so it should be treated opaquely. A returned revision ID is only guaranteed to be valid for 24 hours after it has been returned and cannot be shared across users. If the revision ID is unchanged between calls, then the presentation has not changed. Conversely, a changed ID (for the same presentation and user) usually means the presentation has been updated. However, a changed ID can also be due to internal factors such as ID format changes.
   * @return revisionId
   */
  @javax.annotation.Nullable
  public String getRevisionId() {
    return revisionId;
  }

  public void setRevisionId(String revisionId) {
    this.revisionId = revisionId;
  }


  public Presentation slides(List<Page> slides) {
    this.slides = slides;
    return this;
  }

  public Presentation addSlidesItem(Page slidesItem) {
    if (this.slides == null) {
      this.slides = new ArrayList<>();
    }
    this.slides.add(slidesItem);
    return this;
  }

  /**
   * The slides in the presentation. A slide inherits properties from a slide layout.
   * @return slides
   */
  @javax.annotation.Nullable
  public List<Page> getSlides() {
    return slides;
  }

  public void setSlides(List<Page> slides) {
    this.slides = slides;
  }


  public Presentation title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The title of the presentation.
   * @return title
   */
  @javax.annotation.Nullable
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Presentation presentation = (Presentation) o;
    return Objects.equals(this.layouts, presentation.layouts) &&
        Objects.equals(this.locale, presentation.locale) &&
        Objects.equals(this.masters, presentation.masters) &&
        Objects.equals(this.notesMaster, presentation.notesMaster) &&
        Objects.equals(this.pageSize, presentation.pageSize) &&
        Objects.equals(this.presentationId, presentation.presentationId) &&
        Objects.equals(this.revisionId, presentation.revisionId) &&
        Objects.equals(this.slides, presentation.slides) &&
        Objects.equals(this.title, presentation.title);
  }

  @Override
  public int hashCode() {
    return Objects.hash(layouts, locale, masters, notesMaster, pageSize, presentationId, revisionId, slides, title);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Presentation {\n");
    sb.append("    layouts: ").append(toIndentedString(layouts)).append("\n");
    sb.append("    locale: ").append(toIndentedString(locale)).append("\n");
    sb.append("    masters: ").append(toIndentedString(masters)).append("\n");
    sb.append("    notesMaster: ").append(toIndentedString(notesMaster)).append("\n");
    sb.append("    pageSize: ").append(toIndentedString(pageSize)).append("\n");
    sb.append("    presentationId: ").append(toIndentedString(presentationId)).append("\n");
    sb.append("    revisionId: ").append(toIndentedString(revisionId)).append("\n");
    sb.append("    slides: ").append(toIndentedString(slides)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("layouts");
    openapiFields.add("locale");
    openapiFields.add("masters");
    openapiFields.add("notesMaster");
    openapiFields.add("pageSize");
    openapiFields.add("presentationId");
    openapiFields.add("revisionId");
    openapiFields.add("slides");
    openapiFields.add("title");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Presentation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Presentation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Presentation is not found in the empty JSON string", Presentation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Presentation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Presentation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("layouts") != null && !jsonObj.get("layouts").isJsonNull()) {
        JsonArray jsonArraylayouts = jsonObj.getAsJsonArray("layouts");
        if (jsonArraylayouts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("layouts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `layouts` to be an array in the JSON string but got `%s`", jsonObj.get("layouts").toString()));
          }

          // validate the optional field `layouts` (array)
          for (int i = 0; i < jsonArraylayouts.size(); i++) {
            Page.validateJsonElement(jsonArraylayouts.get(i));
          };
        }
      }
      if ((jsonObj.get("locale") != null && !jsonObj.get("locale").isJsonNull()) && !jsonObj.get("locale").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `locale` to be a primitive type in the JSON string but got `%s`", jsonObj.get("locale").toString()));
      }
      if (jsonObj.get("masters") != null && !jsonObj.get("masters").isJsonNull()) {
        JsonArray jsonArraymasters = jsonObj.getAsJsonArray("masters");
        if (jsonArraymasters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("masters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `masters` to be an array in the JSON string but got `%s`", jsonObj.get("masters").toString()));
          }

          // validate the optional field `masters` (array)
          for (int i = 0; i < jsonArraymasters.size(); i++) {
            Page.validateJsonElement(jsonArraymasters.get(i));
          };
        }
      }
      // validate the optional field `notesMaster`
      if (jsonObj.get("notesMaster") != null && !jsonObj.get("notesMaster").isJsonNull()) {
        Page.validateJsonElement(jsonObj.get("notesMaster"));
      }
      // validate the optional field `pageSize`
      if (jsonObj.get("pageSize") != null && !jsonObj.get("pageSize").isJsonNull()) {
        Size.validateJsonElement(jsonObj.get("pageSize"));
      }
      if ((jsonObj.get("presentationId") != null && !jsonObj.get("presentationId").isJsonNull()) && !jsonObj.get("presentationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `presentationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("presentationId").toString()));
      }
      if ((jsonObj.get("revisionId") != null && !jsonObj.get("revisionId").isJsonNull()) && !jsonObj.get("revisionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revisionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revisionId").toString()));
      }
      if (jsonObj.get("slides") != null && !jsonObj.get("slides").isJsonNull()) {
        JsonArray jsonArrayslides = jsonObj.getAsJsonArray("slides");
        if (jsonArrayslides != null) {
          // ensure the json data is an array
          if (!jsonObj.get("slides").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `slides` to be an array in the JSON string but got `%s`", jsonObj.get("slides").toString()));
          }

          // validate the optional field `slides` (array)
          for (int i = 0; i < jsonArrayslides.size(); i++) {
            Page.validateJsonElement(jsonArrayslides.get(i));
          };
        }
      }
      if ((jsonObj.get("title") != null && !jsonObj.get("title").isJsonNull()) && !jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Presentation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Presentation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Presentation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Presentation.class));

       return (TypeAdapter<T>) new TypeAdapter<Presentation>() {
           @Override
           public void write(JsonWriter out, Presentation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Presentation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Presentation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Presentation
   * @throws IOException if the JSON string is invalid with respect to Presentation
   */
  public static Presentation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Presentation.class);
  }

  /**
   * Convert an instance of Presentation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

