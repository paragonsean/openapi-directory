/*
 * Google Slides API
 * Reads and writes Google Slides presentations.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Dimension;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Styles that apply to a whole paragraph. If this text is contained in a shape with a parent placeholder, then these paragraph styles may be inherited from the parent. Which paragraph styles are inherited depend on the nesting level of lists: * A paragraph not in a list will inherit its paragraph style from the paragraph at the 0 nesting level of the list inside the parent placeholder. * A paragraph in a list will inherit its paragraph style from the paragraph at its corresponding nesting level of the list inside the parent placeholder. Inherited paragraph styles are represented as unset fields in this message.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:28.691493-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ParagraphStyle {
  /**
   * The text alignment for this paragraph.
   */
  @JsonAdapter(AlignmentEnum.Adapter.class)
  public enum AlignmentEnum {
    ALIGNMENT_UNSPECIFIED("ALIGNMENT_UNSPECIFIED"),
    
    START("START"),
    
    CENTER("CENTER"),
    
    END("END"),
    
    JUSTIFIED("JUSTIFIED");

    private String value;

    AlignmentEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AlignmentEnum fromValue(String value) {
      for (AlignmentEnum b : AlignmentEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AlignmentEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AlignmentEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AlignmentEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AlignmentEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AlignmentEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ALIGNMENT = "alignment";
  @SerializedName(SERIALIZED_NAME_ALIGNMENT)
  private AlignmentEnum alignment;

  /**
   * The text direction of this paragraph. If unset, the value defaults to LEFT_TO_RIGHT since text direction is not inherited.
   */
  @JsonAdapter(DirectionEnum.Adapter.class)
  public enum DirectionEnum {
    TEXT_DIRECTION_UNSPECIFIED("TEXT_DIRECTION_UNSPECIFIED"),
    
    LEFT_TO_RIGHT("LEFT_TO_RIGHT"),
    
    RIGHT_TO_LEFT("RIGHT_TO_LEFT");

    private String value;

    DirectionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DirectionEnum fromValue(String value) {
      for (DirectionEnum b : DirectionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DirectionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DirectionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DirectionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DirectionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DirectionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DIRECTION = "direction";
  @SerializedName(SERIALIZED_NAME_DIRECTION)
  private DirectionEnum direction;

  public static final String SERIALIZED_NAME_INDENT_END = "indentEnd";
  @SerializedName(SERIALIZED_NAME_INDENT_END)
  private Dimension indentEnd;

  public static final String SERIALIZED_NAME_INDENT_FIRST_LINE = "indentFirstLine";
  @SerializedName(SERIALIZED_NAME_INDENT_FIRST_LINE)
  private Dimension indentFirstLine;

  public static final String SERIALIZED_NAME_INDENT_START = "indentStart";
  @SerializedName(SERIALIZED_NAME_INDENT_START)
  private Dimension indentStart;

  public static final String SERIALIZED_NAME_LINE_SPACING = "lineSpacing";
  @SerializedName(SERIALIZED_NAME_LINE_SPACING)
  private Float lineSpacing;

  public static final String SERIALIZED_NAME_SPACE_ABOVE = "spaceAbove";
  @SerializedName(SERIALIZED_NAME_SPACE_ABOVE)
  private Dimension spaceAbove;

  public static final String SERIALIZED_NAME_SPACE_BELOW = "spaceBelow";
  @SerializedName(SERIALIZED_NAME_SPACE_BELOW)
  private Dimension spaceBelow;

  /**
   * The spacing mode for the paragraph.
   */
  @JsonAdapter(SpacingModeEnum.Adapter.class)
  public enum SpacingModeEnum {
    SPACING_MODE_UNSPECIFIED("SPACING_MODE_UNSPECIFIED"),
    
    NEVER_COLLAPSE("NEVER_COLLAPSE"),
    
    COLLAPSE_LISTS("COLLAPSE_LISTS");

    private String value;

    SpacingModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SpacingModeEnum fromValue(String value) {
      for (SpacingModeEnum b : SpacingModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SpacingModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SpacingModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SpacingModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SpacingModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SpacingModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SPACING_MODE = "spacingMode";
  @SerializedName(SERIALIZED_NAME_SPACING_MODE)
  private SpacingModeEnum spacingMode;

  public ParagraphStyle() {
  }

  public ParagraphStyle alignment(AlignmentEnum alignment) {
    this.alignment = alignment;
    return this;
  }

  /**
   * The text alignment for this paragraph.
   * @return alignment
   */
  @javax.annotation.Nullable
  public AlignmentEnum getAlignment() {
    return alignment;
  }

  public void setAlignment(AlignmentEnum alignment) {
    this.alignment = alignment;
  }


  public ParagraphStyle direction(DirectionEnum direction) {
    this.direction = direction;
    return this;
  }

  /**
   * The text direction of this paragraph. If unset, the value defaults to LEFT_TO_RIGHT since text direction is not inherited.
   * @return direction
   */
  @javax.annotation.Nullable
  public DirectionEnum getDirection() {
    return direction;
  }

  public void setDirection(DirectionEnum direction) {
    this.direction = direction;
  }


  public ParagraphStyle indentEnd(Dimension indentEnd) {
    this.indentEnd = indentEnd;
    return this;
  }

  /**
   * Get indentEnd
   * @return indentEnd
   */
  @javax.annotation.Nullable
  public Dimension getIndentEnd() {
    return indentEnd;
  }

  public void setIndentEnd(Dimension indentEnd) {
    this.indentEnd = indentEnd;
  }


  public ParagraphStyle indentFirstLine(Dimension indentFirstLine) {
    this.indentFirstLine = indentFirstLine;
    return this;
  }

  /**
   * Get indentFirstLine
   * @return indentFirstLine
   */
  @javax.annotation.Nullable
  public Dimension getIndentFirstLine() {
    return indentFirstLine;
  }

  public void setIndentFirstLine(Dimension indentFirstLine) {
    this.indentFirstLine = indentFirstLine;
  }


  public ParagraphStyle indentStart(Dimension indentStart) {
    this.indentStart = indentStart;
    return this;
  }

  /**
   * Get indentStart
   * @return indentStart
   */
  @javax.annotation.Nullable
  public Dimension getIndentStart() {
    return indentStart;
  }

  public void setIndentStart(Dimension indentStart) {
    this.indentStart = indentStart;
  }


  public ParagraphStyle lineSpacing(Float lineSpacing) {
    this.lineSpacing = lineSpacing;
    return this;
  }

  /**
   * The amount of space between lines, as a percentage of normal, where normal is represented as 100.0. If unset, the value is inherited from the parent.
   * @return lineSpacing
   */
  @javax.annotation.Nullable
  public Float getLineSpacing() {
    return lineSpacing;
  }

  public void setLineSpacing(Float lineSpacing) {
    this.lineSpacing = lineSpacing;
  }


  public ParagraphStyle spaceAbove(Dimension spaceAbove) {
    this.spaceAbove = spaceAbove;
    return this;
  }

  /**
   * Get spaceAbove
   * @return spaceAbove
   */
  @javax.annotation.Nullable
  public Dimension getSpaceAbove() {
    return spaceAbove;
  }

  public void setSpaceAbove(Dimension spaceAbove) {
    this.spaceAbove = spaceAbove;
  }


  public ParagraphStyle spaceBelow(Dimension spaceBelow) {
    this.spaceBelow = spaceBelow;
    return this;
  }

  /**
   * Get spaceBelow
   * @return spaceBelow
   */
  @javax.annotation.Nullable
  public Dimension getSpaceBelow() {
    return spaceBelow;
  }

  public void setSpaceBelow(Dimension spaceBelow) {
    this.spaceBelow = spaceBelow;
  }


  public ParagraphStyle spacingMode(SpacingModeEnum spacingMode) {
    this.spacingMode = spacingMode;
    return this;
  }

  /**
   * The spacing mode for the paragraph.
   * @return spacingMode
   */
  @javax.annotation.Nullable
  public SpacingModeEnum getSpacingMode() {
    return spacingMode;
  }

  public void setSpacingMode(SpacingModeEnum spacingMode) {
    this.spacingMode = spacingMode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ParagraphStyle paragraphStyle = (ParagraphStyle) o;
    return Objects.equals(this.alignment, paragraphStyle.alignment) &&
        Objects.equals(this.direction, paragraphStyle.direction) &&
        Objects.equals(this.indentEnd, paragraphStyle.indentEnd) &&
        Objects.equals(this.indentFirstLine, paragraphStyle.indentFirstLine) &&
        Objects.equals(this.indentStart, paragraphStyle.indentStart) &&
        Objects.equals(this.lineSpacing, paragraphStyle.lineSpacing) &&
        Objects.equals(this.spaceAbove, paragraphStyle.spaceAbove) &&
        Objects.equals(this.spaceBelow, paragraphStyle.spaceBelow) &&
        Objects.equals(this.spacingMode, paragraphStyle.spacingMode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alignment, direction, indentEnd, indentFirstLine, indentStart, lineSpacing, spaceAbove, spaceBelow, spacingMode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ParagraphStyle {\n");
    sb.append("    alignment: ").append(toIndentedString(alignment)).append("\n");
    sb.append("    direction: ").append(toIndentedString(direction)).append("\n");
    sb.append("    indentEnd: ").append(toIndentedString(indentEnd)).append("\n");
    sb.append("    indentFirstLine: ").append(toIndentedString(indentFirstLine)).append("\n");
    sb.append("    indentStart: ").append(toIndentedString(indentStart)).append("\n");
    sb.append("    lineSpacing: ").append(toIndentedString(lineSpacing)).append("\n");
    sb.append("    spaceAbove: ").append(toIndentedString(spaceAbove)).append("\n");
    sb.append("    spaceBelow: ").append(toIndentedString(spaceBelow)).append("\n");
    sb.append("    spacingMode: ").append(toIndentedString(spacingMode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alignment");
    openapiFields.add("direction");
    openapiFields.add("indentEnd");
    openapiFields.add("indentFirstLine");
    openapiFields.add("indentStart");
    openapiFields.add("lineSpacing");
    openapiFields.add("spaceAbove");
    openapiFields.add("spaceBelow");
    openapiFields.add("spacingMode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ParagraphStyle
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ParagraphStyle.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ParagraphStyle is not found in the empty JSON string", ParagraphStyle.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ParagraphStyle.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ParagraphStyle` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("alignment") != null && !jsonObj.get("alignment").isJsonNull()) && !jsonObj.get("alignment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alignment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alignment").toString()));
      }
      // validate the optional field `alignment`
      if (jsonObj.get("alignment") != null && !jsonObj.get("alignment").isJsonNull()) {
        AlignmentEnum.validateJsonElement(jsonObj.get("alignment"));
      }
      if ((jsonObj.get("direction") != null && !jsonObj.get("direction").isJsonNull()) && !jsonObj.get("direction").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `direction` to be a primitive type in the JSON string but got `%s`", jsonObj.get("direction").toString()));
      }
      // validate the optional field `direction`
      if (jsonObj.get("direction") != null && !jsonObj.get("direction").isJsonNull()) {
        DirectionEnum.validateJsonElement(jsonObj.get("direction"));
      }
      // validate the optional field `indentEnd`
      if (jsonObj.get("indentEnd") != null && !jsonObj.get("indentEnd").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("indentEnd"));
      }
      // validate the optional field `indentFirstLine`
      if (jsonObj.get("indentFirstLine") != null && !jsonObj.get("indentFirstLine").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("indentFirstLine"));
      }
      // validate the optional field `indentStart`
      if (jsonObj.get("indentStart") != null && !jsonObj.get("indentStart").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("indentStart"));
      }
      // validate the optional field `spaceAbove`
      if (jsonObj.get("spaceAbove") != null && !jsonObj.get("spaceAbove").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("spaceAbove"));
      }
      // validate the optional field `spaceBelow`
      if (jsonObj.get("spaceBelow") != null && !jsonObj.get("spaceBelow").isJsonNull()) {
        Dimension.validateJsonElement(jsonObj.get("spaceBelow"));
      }
      if ((jsonObj.get("spacingMode") != null && !jsonObj.get("spacingMode").isJsonNull()) && !jsonObj.get("spacingMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `spacingMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("spacingMode").toString()));
      }
      // validate the optional field `spacingMode`
      if (jsonObj.get("spacingMode") != null && !jsonObj.get("spacingMode").isJsonNull()) {
        SpacingModeEnum.validateJsonElement(jsonObj.get("spacingMode"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ParagraphStyle.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ParagraphStyle' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ParagraphStyle> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ParagraphStyle.class));

       return (TypeAdapter<T>) new TypeAdapter<ParagraphStyle>() {
           @Override
           public void write(JsonWriter out, ParagraphStyle value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ParagraphStyle read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ParagraphStyle given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ParagraphStyle
   * @throws IOException if the JSON string is invalid with respect to ParagraphStyle
   */
  public static ParagraphStyle fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ParagraphStyle.class);
  }

  /**
   * Convert an instance of ParagraphStyle to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

