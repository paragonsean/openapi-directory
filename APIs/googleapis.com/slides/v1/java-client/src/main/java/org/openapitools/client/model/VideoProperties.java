/*
 * Google Slides API
 * Reads and writes Google Slides presentations.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Outline;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The properties of the Video.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:28.691493-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VideoProperties {
  public static final String SERIALIZED_NAME_AUTO_PLAY = "autoPlay";
  @SerializedName(SERIALIZED_NAME_AUTO_PLAY)
  private Boolean autoPlay;

  public static final String SERIALIZED_NAME_END = "end";
  @SerializedName(SERIALIZED_NAME_END)
  private Integer end;

  public static final String SERIALIZED_NAME_MUTE = "mute";
  @SerializedName(SERIALIZED_NAME_MUTE)
  private Boolean mute;

  public static final String SERIALIZED_NAME_OUTLINE = "outline";
  @SerializedName(SERIALIZED_NAME_OUTLINE)
  private Outline outline;

  public static final String SERIALIZED_NAME_START = "start";
  @SerializedName(SERIALIZED_NAME_START)
  private Integer start;

  public VideoProperties() {
  }

  public VideoProperties autoPlay(Boolean autoPlay) {
    this.autoPlay = autoPlay;
    return this;
  }

  /**
   * Whether to enable video autoplay when the page is displayed in present mode. Defaults to false.
   * @return autoPlay
   */
  @javax.annotation.Nullable
  public Boolean getAutoPlay() {
    return autoPlay;
  }

  public void setAutoPlay(Boolean autoPlay) {
    this.autoPlay = autoPlay;
  }


  public VideoProperties end(Integer end) {
    this.end = end;
    return this;
  }

  /**
   * The time at which to end playback, measured in seconds from the beginning of the video. If set, the end time should be after the start time. If not set or if you set this to a value that exceeds the video&#39;s length, the video will be played until its end.
   * @return end
   */
  @javax.annotation.Nullable
  public Integer getEnd() {
    return end;
  }

  public void setEnd(Integer end) {
    this.end = end;
  }


  public VideoProperties mute(Boolean mute) {
    this.mute = mute;
    return this;
  }

  /**
   * Whether to mute the audio during video playback. Defaults to false.
   * @return mute
   */
  @javax.annotation.Nullable
  public Boolean getMute() {
    return mute;
  }

  public void setMute(Boolean mute) {
    this.mute = mute;
  }


  public VideoProperties outline(Outline outline) {
    this.outline = outline;
    return this;
  }

  /**
   * Get outline
   * @return outline
   */
  @javax.annotation.Nullable
  public Outline getOutline() {
    return outline;
  }

  public void setOutline(Outline outline) {
    this.outline = outline;
  }


  public VideoProperties start(Integer start) {
    this.start = start;
    return this;
  }

  /**
   * The time at which to start playback, measured in seconds from the beginning of the video. If set, the start time should be before the end time. If you set this to a value that exceeds the video&#39;s length in seconds, the video will be played from the last second. If not set, the video will be played from the beginning.
   * @return start
   */
  @javax.annotation.Nullable
  public Integer getStart() {
    return start;
  }

  public void setStart(Integer start) {
    this.start = start;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoProperties videoProperties = (VideoProperties) o;
    return Objects.equals(this.autoPlay, videoProperties.autoPlay) &&
        Objects.equals(this.end, videoProperties.end) &&
        Objects.equals(this.mute, videoProperties.mute) &&
        Objects.equals(this.outline, videoProperties.outline) &&
        Objects.equals(this.start, videoProperties.start);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoPlay, end, mute, outline, start);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoProperties {\n");
    sb.append("    autoPlay: ").append(toIndentedString(autoPlay)).append("\n");
    sb.append("    end: ").append(toIndentedString(end)).append("\n");
    sb.append("    mute: ").append(toIndentedString(mute)).append("\n");
    sb.append("    outline: ").append(toIndentedString(outline)).append("\n");
    sb.append("    start: ").append(toIndentedString(start)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoPlay");
    openapiFields.add("end");
    openapiFields.add("mute");
    openapiFields.add("outline");
    openapiFields.add("start");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoProperties is not found in the empty JSON string", VideoProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VideoProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VideoProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `outline`
      if (jsonObj.get("outline") != null && !jsonObj.get("outline").isJsonNull()) {
        Outline.validateJsonElement(jsonObj.get("outline"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VideoProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VideoProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VideoProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VideoProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<VideoProperties>() {
           @Override
           public void write(JsonWriter out, VideoProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VideoProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VideoProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoProperties
   * @throws IOException if the JSON string is invalid with respect to VideoProperties
   */
  public static VideoProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoProperties.class);
  }

  /**
   * Convert an instance of VideoProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

