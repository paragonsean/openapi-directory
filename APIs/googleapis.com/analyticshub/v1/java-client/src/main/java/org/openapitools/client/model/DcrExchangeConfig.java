/*
 * Analytics Hub API
 * Exchange data and analytics assets securely and efficiently.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Data Clean Room (DCR), used for privacy-safe and secured data sharing.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:42.782579-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DcrExchangeConfig {
  public static final String SERIALIZED_NAME_SINGLE_LINKED_DATASET_PER_CLEANROOM = "singleLinkedDatasetPerCleanroom";
  @SerializedName(SERIALIZED_NAME_SINGLE_LINKED_DATASET_PER_CLEANROOM)
  private Boolean singleLinkedDatasetPerCleanroom;

  public static final String SERIALIZED_NAME_SINGLE_SELECTED_RESOURCE_SHARING_RESTRICTION = "singleSelectedResourceSharingRestriction";
  @SerializedName(SERIALIZED_NAME_SINGLE_SELECTED_RESOURCE_SHARING_RESTRICTION)
  private Boolean singleSelectedResourceSharingRestriction;

  public DcrExchangeConfig() {
  }

  public DcrExchangeConfig(
     Boolean singleLinkedDatasetPerCleanroom, 
     Boolean singleSelectedResourceSharingRestriction
  ) {
    this();
    this.singleLinkedDatasetPerCleanroom = singleLinkedDatasetPerCleanroom;
    this.singleSelectedResourceSharingRestriction = singleSelectedResourceSharingRestriction;
  }

  /**
   * Output only. If True, when subscribing to this DCR, it will create only one linked dataset containing all resources shared within the cleanroom. If False, when subscribing to this DCR, it will create 1 linked dataset per listing. This is not configurable, and by default, all new DCRs will have the restriction set to True.
   * @return singleLinkedDatasetPerCleanroom
   */
  @javax.annotation.Nullable
  public Boolean getSingleLinkedDatasetPerCleanroom() {
    return singleLinkedDatasetPerCleanroom;
  }



  /**
   * Output only. If True, this DCR restricts the contributors to sharing only a single resource in a Listing. And no two resources should have the same IDs. So if a contributor adds a view with a conflicting name, the CreateListing API will reject the request. if False, the data contributor can publish an entire dataset (as before). This is not configurable, and by default, all new DCRs will have the restriction set to True.
   * @return singleSelectedResourceSharingRestriction
   */
  @javax.annotation.Nullable
  public Boolean getSingleSelectedResourceSharingRestriction() {
    return singleSelectedResourceSharingRestriction;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DcrExchangeConfig dcrExchangeConfig = (DcrExchangeConfig) o;
    return Objects.equals(this.singleLinkedDatasetPerCleanroom, dcrExchangeConfig.singleLinkedDatasetPerCleanroom) &&
        Objects.equals(this.singleSelectedResourceSharingRestriction, dcrExchangeConfig.singleSelectedResourceSharingRestriction);
  }

  @Override
  public int hashCode() {
    return Objects.hash(singleLinkedDatasetPerCleanroom, singleSelectedResourceSharingRestriction);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DcrExchangeConfig {\n");
    sb.append("    singleLinkedDatasetPerCleanroom: ").append(toIndentedString(singleLinkedDatasetPerCleanroom)).append("\n");
    sb.append("    singleSelectedResourceSharingRestriction: ").append(toIndentedString(singleSelectedResourceSharingRestriction)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("singleLinkedDatasetPerCleanroom");
    openapiFields.add("singleSelectedResourceSharingRestriction");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DcrExchangeConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DcrExchangeConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DcrExchangeConfig is not found in the empty JSON string", DcrExchangeConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DcrExchangeConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DcrExchangeConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DcrExchangeConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DcrExchangeConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DcrExchangeConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DcrExchangeConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<DcrExchangeConfig>() {
           @Override
           public void write(JsonWriter out, DcrExchangeConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DcrExchangeConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DcrExchangeConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DcrExchangeConfig
   * @throws IOException if the JSON string is invalid with respect to DcrExchangeConfig
   */
  public static DcrExchangeConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DcrExchangeConfig.class);
  }

  /**
   * Convert an instance of DcrExchangeConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

