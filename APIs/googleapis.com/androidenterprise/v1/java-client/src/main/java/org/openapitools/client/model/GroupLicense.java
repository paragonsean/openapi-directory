/*
 * Google Play EMM API
 * Manages the deployment of apps to Android Enterprise devices.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Group license objects allow you to keep track of licenses (called entitlements) for both free and paid apps. For a free app, a group license is created when an enterprise admin first approves the product in Google Play or when the first entitlement for the product is created for a user via the API. For a paid app, a group license object is only created when an enterprise admin purchases the product in Google Play for the first time. Use the API to query group licenses. A Grouplicenses resource includes the total number of licenses purchased (paid apps only) and the total number of licenses currently in use. In other words, the total number of Entitlements that exist for the product. Only one group license object is created per product and group license objects are never deleted. If a product is unapproved, its group license remains. This allows enterprise admins to keep track of any remaining entitlements for the product.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:04.392334-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GroupLicense {
  /**
   * How this group license was acquired. \&quot;bulkPurchase\&quot; means that this Grouplicenses resource was created because the enterprise purchased licenses for this product; otherwise, the value is \&quot;free\&quot; (for free products).
   */
  @JsonAdapter(AcquisitionKindEnum.Adapter.class)
  public enum AcquisitionKindEnum {
    FREE("free"),
    
    BULK_PURCHASE("bulkPurchase");

    private String value;

    AcquisitionKindEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AcquisitionKindEnum fromValue(String value) {
      for (AcquisitionKindEnum b : AcquisitionKindEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AcquisitionKindEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AcquisitionKindEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AcquisitionKindEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AcquisitionKindEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AcquisitionKindEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ACQUISITION_KIND = "acquisitionKind";
  @SerializedName(SERIALIZED_NAME_ACQUISITION_KIND)
  private AcquisitionKindEnum acquisitionKind;

  /**
   * Whether the product to which this group license relates is currently approved by the enterprise. Products are approved when a group license is first created, but this approval may be revoked by an enterprise admin via Google Play. Unapproved products will not be visible to end users in collections, and new entitlements to them should not normally be created.
   */
  @JsonAdapter(ApprovalEnum.Adapter.class)
  public enum ApprovalEnum {
    APPROVED("approved"),
    
    UNAPPROVED("unapproved");

    private String value;

    ApprovalEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ApprovalEnum fromValue(String value) {
      for (ApprovalEnum b : ApprovalEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ApprovalEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ApprovalEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ApprovalEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ApprovalEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ApprovalEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_APPROVAL = "approval";
  @SerializedName(SERIALIZED_NAME_APPROVAL)
  private ApprovalEnum approval;

  public static final String SERIALIZED_NAME_NUM_PROVISIONED = "numProvisioned";
  @SerializedName(SERIALIZED_NAME_NUM_PROVISIONED)
  private Integer numProvisioned;

  public static final String SERIALIZED_NAME_NUM_PURCHASED = "numPurchased";
  @SerializedName(SERIALIZED_NAME_NUM_PURCHASED)
  private Integer numPurchased;

  /**
   * The permission approval status of the product. This field is only set if the product is approved. Possible states are: - \&quot;currentApproved\&quot;, the current set of permissions is approved, but additional permissions will require the administrator to reapprove the product (If the product was approved without specifying the approved permissions setting, then this is the default behavior.), - \&quot;needsReapproval\&quot;, the product has unapproved permissions. No additional product licenses can be assigned until the product is reapproved, - \&quot;allCurrentAndFutureApproved\&quot;, the current permissions are approved and any future permission updates will be automatically approved without administrator review. 
   */
  @JsonAdapter(PermissionsEnum.Adapter.class)
  public enum PermissionsEnum {
    CURRENT_APPROVED("currentApproved"),
    
    NEEDS_REAPPROVAL("needsReapproval"),
    
    ALL_CURRENT_AND_FUTURE_APPROVED("allCurrentAndFutureApproved");

    private String value;

    PermissionsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PermissionsEnum fromValue(String value) {
      for (PermissionsEnum b : PermissionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PermissionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PermissionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PermissionsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PermissionsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PermissionsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PERMISSIONS = "permissions";
  @SerializedName(SERIALIZED_NAME_PERMISSIONS)
  private PermissionsEnum permissions;

  public static final String SERIALIZED_NAME_PRODUCT_ID = "productId";
  @SerializedName(SERIALIZED_NAME_PRODUCT_ID)
  private String productId;

  public GroupLicense() {
  }

  public GroupLicense acquisitionKind(AcquisitionKindEnum acquisitionKind) {
    this.acquisitionKind = acquisitionKind;
    return this;
  }

  /**
   * How this group license was acquired. \&quot;bulkPurchase\&quot; means that this Grouplicenses resource was created because the enterprise purchased licenses for this product; otherwise, the value is \&quot;free\&quot; (for free products).
   * @return acquisitionKind
   */
  @javax.annotation.Nullable
  public AcquisitionKindEnum getAcquisitionKind() {
    return acquisitionKind;
  }

  public void setAcquisitionKind(AcquisitionKindEnum acquisitionKind) {
    this.acquisitionKind = acquisitionKind;
  }


  public GroupLicense approval(ApprovalEnum approval) {
    this.approval = approval;
    return this;
  }

  /**
   * Whether the product to which this group license relates is currently approved by the enterprise. Products are approved when a group license is first created, but this approval may be revoked by an enterprise admin via Google Play. Unapproved products will not be visible to end users in collections, and new entitlements to them should not normally be created.
   * @return approval
   */
  @javax.annotation.Nullable
  public ApprovalEnum getApproval() {
    return approval;
  }

  public void setApproval(ApprovalEnum approval) {
    this.approval = approval;
  }


  public GroupLicense numProvisioned(Integer numProvisioned) {
    this.numProvisioned = numProvisioned;
    return this;
  }

  /**
   * The total number of provisioned licenses for this product. Returned by read operations, but ignored in write operations.
   * @return numProvisioned
   */
  @javax.annotation.Nullable
  public Integer getNumProvisioned() {
    return numProvisioned;
  }

  public void setNumProvisioned(Integer numProvisioned) {
    this.numProvisioned = numProvisioned;
  }


  public GroupLicense numPurchased(Integer numPurchased) {
    this.numPurchased = numPurchased;
    return this;
  }

  /**
   * The number of purchased licenses (possibly in multiple purchases). If this field is omitted, then there is no limit on the number of licenses that can be provisioned (for example, if the acquisition kind is \&quot;free\&quot;).
   * @return numPurchased
   */
  @javax.annotation.Nullable
  public Integer getNumPurchased() {
    return numPurchased;
  }

  public void setNumPurchased(Integer numPurchased) {
    this.numPurchased = numPurchased;
  }


  public GroupLicense permissions(PermissionsEnum permissions) {
    this.permissions = permissions;
    return this;
  }

  /**
   * The permission approval status of the product. This field is only set if the product is approved. Possible states are: - \&quot;currentApproved\&quot;, the current set of permissions is approved, but additional permissions will require the administrator to reapprove the product (If the product was approved without specifying the approved permissions setting, then this is the default behavior.), - \&quot;needsReapproval\&quot;, the product has unapproved permissions. No additional product licenses can be assigned until the product is reapproved, - \&quot;allCurrentAndFutureApproved\&quot;, the current permissions are approved and any future permission updates will be automatically approved without administrator review. 
   * @return permissions
   */
  @javax.annotation.Nullable
  public PermissionsEnum getPermissions() {
    return permissions;
  }

  public void setPermissions(PermissionsEnum permissions) {
    this.permissions = permissions;
  }


  public GroupLicense productId(String productId) {
    this.productId = productId;
    return this;
  }

  /**
   * The ID of the product that the license is for. For example, \&quot;app:com.google.android.gm\&quot;.
   * @return productId
   */
  @javax.annotation.Nullable
  public String getProductId() {
    return productId;
  }

  public void setProductId(String productId) {
    this.productId = productId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GroupLicense groupLicense = (GroupLicense) o;
    return Objects.equals(this.acquisitionKind, groupLicense.acquisitionKind) &&
        Objects.equals(this.approval, groupLicense.approval) &&
        Objects.equals(this.numProvisioned, groupLicense.numProvisioned) &&
        Objects.equals(this.numPurchased, groupLicense.numPurchased) &&
        Objects.equals(this.permissions, groupLicense.permissions) &&
        Objects.equals(this.productId, groupLicense.productId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acquisitionKind, approval, numProvisioned, numPurchased, permissions, productId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GroupLicense {\n");
    sb.append("    acquisitionKind: ").append(toIndentedString(acquisitionKind)).append("\n");
    sb.append("    approval: ").append(toIndentedString(approval)).append("\n");
    sb.append("    numProvisioned: ").append(toIndentedString(numProvisioned)).append("\n");
    sb.append("    numPurchased: ").append(toIndentedString(numPurchased)).append("\n");
    sb.append("    permissions: ").append(toIndentedString(permissions)).append("\n");
    sb.append("    productId: ").append(toIndentedString(productId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acquisitionKind");
    openapiFields.add("approval");
    openapiFields.add("numProvisioned");
    openapiFields.add("numPurchased");
    openapiFields.add("permissions");
    openapiFields.add("productId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GroupLicense
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GroupLicense.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GroupLicense is not found in the empty JSON string", GroupLicense.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GroupLicense.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GroupLicense` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("acquisitionKind") != null && !jsonObj.get("acquisitionKind").isJsonNull()) && !jsonObj.get("acquisitionKind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `acquisitionKind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("acquisitionKind").toString()));
      }
      // validate the optional field `acquisitionKind`
      if (jsonObj.get("acquisitionKind") != null && !jsonObj.get("acquisitionKind").isJsonNull()) {
        AcquisitionKindEnum.validateJsonElement(jsonObj.get("acquisitionKind"));
      }
      if ((jsonObj.get("approval") != null && !jsonObj.get("approval").isJsonNull()) && !jsonObj.get("approval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `approval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("approval").toString()));
      }
      // validate the optional field `approval`
      if (jsonObj.get("approval") != null && !jsonObj.get("approval").isJsonNull()) {
        ApprovalEnum.validateJsonElement(jsonObj.get("approval"));
      }
      if ((jsonObj.get("permissions") != null && !jsonObj.get("permissions").isJsonNull()) && !jsonObj.get("permissions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `permissions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("permissions").toString()));
      }
      // validate the optional field `permissions`
      if (jsonObj.get("permissions") != null && !jsonObj.get("permissions").isJsonNull()) {
        PermissionsEnum.validateJsonElement(jsonObj.get("permissions"));
      }
      if ((jsonObj.get("productId") != null && !jsonObj.get("productId").isJsonNull()) && !jsonObj.get("productId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `productId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("productId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GroupLicense.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GroupLicense' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GroupLicense> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GroupLicense.class));

       return (TypeAdapter<T>) new TypeAdapter<GroupLicense>() {
           @Override
           public void write(JsonWriter out, GroupLicense value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GroupLicense read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GroupLicense given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GroupLicense
   * @throws IOException if the JSON string is invalid with respect to GroupLicense
   */
  public static GroupLicense fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GroupLicense.class);
  }

  /**
   * Convert an instance of GroupLicense to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

