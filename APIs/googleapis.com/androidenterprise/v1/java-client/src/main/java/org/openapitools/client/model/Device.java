/*
 * Google Play EMM API
 * Manages the deployment of apps to Android Enterprise devices.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.DeviceReport;
import org.openapitools.client.model.Policy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Devices resource represents a mobile device managed by the EMM and belonging to a specific enterprise user.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:04.392334-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Device {
  public static final String SERIALIZED_NAME_ANDROID_ID = "androidId";
  @SerializedName(SERIALIZED_NAME_ANDROID_ID)
  private String androidId;

  public static final String SERIALIZED_NAME_DEVICE = "device";
  @SerializedName(SERIALIZED_NAME_DEVICE)
  private String device;

  public static final String SERIALIZED_NAME_LATEST_BUILD_FINGERPRINT = "latestBuildFingerprint";
  @SerializedName(SERIALIZED_NAME_LATEST_BUILD_FINGERPRINT)
  private String latestBuildFingerprint;

  public static final String SERIALIZED_NAME_MAKER = "maker";
  @SerializedName(SERIALIZED_NAME_MAKER)
  private String maker;

  /**
   * Identifies the extent to which the device is controlled by a managed Google Play EMM in various deployment configurations. Possible values include: - \&quot;managedDevice\&quot;, a device that has the EMM&#39;s device policy controller (DPC) as the device owner. - \&quot;managedProfile\&quot;, a device that has a profile managed by the DPC (DPC is profile owner) in addition to a separate, personal profile that is unavailable to the DPC. - \&quot;containerApp\&quot;, no longer used (deprecated). - \&quot;unmanagedProfile\&quot;, a device that has been allowed (by the domain&#39;s admin, using the Admin Console to enable the privilege) to use managed Google Play, but the profile is itself not owned by a DPC. 
   */
  @JsonAdapter(ManagementTypeEnum.Adapter.class)
  public enum ManagementTypeEnum {
    MANAGED_DEVICE("managedDevice"),
    
    MANAGED_PROFILE("managedProfile"),
    
    CONTAINER_APP("containerApp"),
    
    UNMANAGED_PROFILE("unmanagedProfile");

    private String value;

    ManagementTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ManagementTypeEnum fromValue(String value) {
      for (ManagementTypeEnum b : ManagementTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ManagementTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ManagementTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ManagementTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ManagementTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ManagementTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MANAGEMENT_TYPE = "managementType";
  @SerializedName(SERIALIZED_NAME_MANAGEMENT_TYPE)
  private ManagementTypeEnum managementType;

  public static final String SERIALIZED_NAME_MODEL = "model";
  @SerializedName(SERIALIZED_NAME_MODEL)
  private String model;

  public static final String SERIALIZED_NAME_POLICY = "policy";
  @SerializedName(SERIALIZED_NAME_POLICY)
  private Policy policy;

  public static final String SERIALIZED_NAME_PRODUCT = "product";
  @SerializedName(SERIALIZED_NAME_PRODUCT)
  private String product;

  public static final String SERIALIZED_NAME_REPORT = "report";
  @SerializedName(SERIALIZED_NAME_REPORT)
  private DeviceReport report;

  public static final String SERIALIZED_NAME_RETAIL_BRAND = "retailBrand";
  @SerializedName(SERIALIZED_NAME_RETAIL_BRAND)
  private String retailBrand;

  public static final String SERIALIZED_NAME_SDK_VERSION = "sdkVersion";
  @SerializedName(SERIALIZED_NAME_SDK_VERSION)
  private Integer sdkVersion;

  public Device() {
  }

  public Device androidId(String androidId) {
    this.androidId = androidId;
    return this;
  }

  /**
   * The Google Play Services Android ID for the device encoded as a lowercase hex string. For example, \&quot;123456789abcdef0\&quot;.
   * @return androidId
   */
  @javax.annotation.Nullable
  public String getAndroidId() {
    return androidId;
  }

  public void setAndroidId(String androidId) {
    this.androidId = androidId;
  }


  public Device device(String device) {
    this.device = device;
    return this;
  }

  /**
   * The internal hardware codename of the device. This comes from android.os.Build.DEVICE. (field named \&quot;device\&quot; per logs/wireless/android/android_checkin.proto)
   * @return device
   */
  @javax.annotation.Nullable
  public String getDevice() {
    return device;
  }

  public void setDevice(String device) {
    this.device = device;
  }


  public Device latestBuildFingerprint(String latestBuildFingerprint) {
    this.latestBuildFingerprint = latestBuildFingerprint;
    return this;
  }

  /**
   * The build fingerprint of the device if known.
   * @return latestBuildFingerprint
   */
  @javax.annotation.Nullable
  public String getLatestBuildFingerprint() {
    return latestBuildFingerprint;
  }

  public void setLatestBuildFingerprint(String latestBuildFingerprint) {
    this.latestBuildFingerprint = latestBuildFingerprint;
  }


  public Device maker(String maker) {
    this.maker = maker;
    return this;
  }

  /**
   * The manufacturer of the device. This comes from android.os.Build.MANUFACTURER.
   * @return maker
   */
  @javax.annotation.Nullable
  public String getMaker() {
    return maker;
  }

  public void setMaker(String maker) {
    this.maker = maker;
  }


  public Device managementType(ManagementTypeEnum managementType) {
    this.managementType = managementType;
    return this;
  }

  /**
   * Identifies the extent to which the device is controlled by a managed Google Play EMM in various deployment configurations. Possible values include: - \&quot;managedDevice\&quot;, a device that has the EMM&#39;s device policy controller (DPC) as the device owner. - \&quot;managedProfile\&quot;, a device that has a profile managed by the DPC (DPC is profile owner) in addition to a separate, personal profile that is unavailable to the DPC. - \&quot;containerApp\&quot;, no longer used (deprecated). - \&quot;unmanagedProfile\&quot;, a device that has been allowed (by the domain&#39;s admin, using the Admin Console to enable the privilege) to use managed Google Play, but the profile is itself not owned by a DPC. 
   * @return managementType
   */
  @javax.annotation.Nullable
  public ManagementTypeEnum getManagementType() {
    return managementType;
  }

  public void setManagementType(ManagementTypeEnum managementType) {
    this.managementType = managementType;
  }


  public Device model(String model) {
    this.model = model;
    return this;
  }

  /**
   * The model name of the device. This comes from android.os.Build.MODEL.
   * @return model
   */
  @javax.annotation.Nullable
  public String getModel() {
    return model;
  }

  public void setModel(String model) {
    this.model = model;
  }


  public Device policy(Policy policy) {
    this.policy = policy;
    return this;
  }

  /**
   * Get policy
   * @return policy
   */
  @javax.annotation.Nullable
  public Policy getPolicy() {
    return policy;
  }

  public void setPolicy(Policy policy) {
    this.policy = policy;
  }


  public Device product(String product) {
    this.product = product;
    return this;
  }

  /**
   * The product name of the device. This comes from android.os.Build.PRODUCT.
   * @return product
   */
  @javax.annotation.Nullable
  public String getProduct() {
    return product;
  }

  public void setProduct(String product) {
    this.product = product;
  }


  public Device report(DeviceReport report) {
    this.report = report;
    return this;
  }

  /**
   * Get report
   * @return report
   */
  @javax.annotation.Nullable
  public DeviceReport getReport() {
    return report;
  }

  public void setReport(DeviceReport report) {
    this.report = report;
  }


  public Device retailBrand(String retailBrand) {
    this.retailBrand = retailBrand;
    return this;
  }

  /**
   * Retail brand for the device, if set. See android.os.Build.BRAND
   * @return retailBrand
   */
  @javax.annotation.Nullable
  public String getRetailBrand() {
    return retailBrand;
  }

  public void setRetailBrand(String retailBrand) {
    this.retailBrand = retailBrand;
  }


  public Device sdkVersion(Integer sdkVersion) {
    this.sdkVersion = sdkVersion;
    return this;
  }

  /**
   * API compatibility version.
   * @return sdkVersion
   */
  @javax.annotation.Nullable
  public Integer getSdkVersion() {
    return sdkVersion;
  }

  public void setSdkVersion(Integer sdkVersion) {
    this.sdkVersion = sdkVersion;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Device device = (Device) o;
    return Objects.equals(this.androidId, device.androidId) &&
        Objects.equals(this.device, device.device) &&
        Objects.equals(this.latestBuildFingerprint, device.latestBuildFingerprint) &&
        Objects.equals(this.maker, device.maker) &&
        Objects.equals(this.managementType, device.managementType) &&
        Objects.equals(this.model, device.model) &&
        Objects.equals(this.policy, device.policy) &&
        Objects.equals(this.product, device.product) &&
        Objects.equals(this.report, device.report) &&
        Objects.equals(this.retailBrand, device.retailBrand) &&
        Objects.equals(this.sdkVersion, device.sdkVersion);
  }

  @Override
  public int hashCode() {
    return Objects.hash(androidId, device, latestBuildFingerprint, maker, managementType, model, policy, product, report, retailBrand, sdkVersion);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Device {\n");
    sb.append("    androidId: ").append(toIndentedString(androidId)).append("\n");
    sb.append("    device: ").append(toIndentedString(device)).append("\n");
    sb.append("    latestBuildFingerprint: ").append(toIndentedString(latestBuildFingerprint)).append("\n");
    sb.append("    maker: ").append(toIndentedString(maker)).append("\n");
    sb.append("    managementType: ").append(toIndentedString(managementType)).append("\n");
    sb.append("    model: ").append(toIndentedString(model)).append("\n");
    sb.append("    policy: ").append(toIndentedString(policy)).append("\n");
    sb.append("    product: ").append(toIndentedString(product)).append("\n");
    sb.append("    report: ").append(toIndentedString(report)).append("\n");
    sb.append("    retailBrand: ").append(toIndentedString(retailBrand)).append("\n");
    sb.append("    sdkVersion: ").append(toIndentedString(sdkVersion)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("androidId");
    openapiFields.add("device");
    openapiFields.add("latestBuildFingerprint");
    openapiFields.add("maker");
    openapiFields.add("managementType");
    openapiFields.add("model");
    openapiFields.add("policy");
    openapiFields.add("product");
    openapiFields.add("report");
    openapiFields.add("retailBrand");
    openapiFields.add("sdkVersion");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Device
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Device.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Device is not found in the empty JSON string", Device.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Device.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Device` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("androidId") != null && !jsonObj.get("androidId").isJsonNull()) && !jsonObj.get("androidId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `androidId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("androidId").toString()));
      }
      if ((jsonObj.get("device") != null && !jsonObj.get("device").isJsonNull()) && !jsonObj.get("device").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `device` to be a primitive type in the JSON string but got `%s`", jsonObj.get("device").toString()));
      }
      if ((jsonObj.get("latestBuildFingerprint") != null && !jsonObj.get("latestBuildFingerprint").isJsonNull()) && !jsonObj.get("latestBuildFingerprint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `latestBuildFingerprint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("latestBuildFingerprint").toString()));
      }
      if ((jsonObj.get("maker") != null && !jsonObj.get("maker").isJsonNull()) && !jsonObj.get("maker").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maker` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maker").toString()));
      }
      if ((jsonObj.get("managementType") != null && !jsonObj.get("managementType").isJsonNull()) && !jsonObj.get("managementType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `managementType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("managementType").toString()));
      }
      // validate the optional field `managementType`
      if (jsonObj.get("managementType") != null && !jsonObj.get("managementType").isJsonNull()) {
        ManagementTypeEnum.validateJsonElement(jsonObj.get("managementType"));
      }
      if ((jsonObj.get("model") != null && !jsonObj.get("model").isJsonNull()) && !jsonObj.get("model").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `model` to be a primitive type in the JSON string but got `%s`", jsonObj.get("model").toString()));
      }
      // validate the optional field `policy`
      if (jsonObj.get("policy") != null && !jsonObj.get("policy").isJsonNull()) {
        Policy.validateJsonElement(jsonObj.get("policy"));
      }
      if ((jsonObj.get("product") != null && !jsonObj.get("product").isJsonNull()) && !jsonObj.get("product").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `product` to be a primitive type in the JSON string but got `%s`", jsonObj.get("product").toString()));
      }
      // validate the optional field `report`
      if (jsonObj.get("report") != null && !jsonObj.get("report").isJsonNull()) {
        DeviceReport.validateJsonElement(jsonObj.get("report"));
      }
      if ((jsonObj.get("retailBrand") != null && !jsonObj.get("retailBrand").isJsonNull()) && !jsonObj.get("retailBrand").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `retailBrand` to be a primitive type in the JSON string but got `%s`", jsonObj.get("retailBrand").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Device.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Device' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Device> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Device.class));

       return (TypeAdapter<T>) new TypeAdapter<Device>() {
           @Override
           public void write(JsonWriter out, Device value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Device read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Device given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Device
   * @throws IOException if the JSON string is invalid with respect to Device
   */
  public static Device fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Device.class);
  }

  /**
   * Convert an instance of Device to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

