/*
 * Google Play EMM API
 * Manages the deployment of apps to Android Enterprise devices.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.MaintenanceWindow;
import org.openapitools.client.model.ProductPolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The device policy for a given managed device.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:04.392334-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Policy {
  /**
   * Controls when automatic app updates on the device can be applied. Recommended alternative: autoUpdateMode which is set per app, provides greater flexibility around update frequency. When autoUpdateMode is set to AUTO_UPDATE_POSTPONED or AUTO_UPDATE_HIGH_PRIORITY, autoUpdatePolicy has no effect. \&quot;choiceToTheUser\&quot; allows the device&#39;s user to configure the app update policy. \&quot;always\&quot; enables auto updates. \&quot;never\&quot; disables auto updates. \&quot;wifiOnly\&quot; enables auto updates only when the device is connected to wifi.
   */
  @JsonAdapter(AutoUpdatePolicyEnum.Adapter.class)
  public enum AutoUpdatePolicyEnum {
    AUTO_UPDATE_POLICY_UNSPECIFIED("autoUpdatePolicyUnspecified"),
    
    CHOICE_TO_THE_USER("choiceToTheUser"),
    
    NEVER("never"),
    
    WIFI_ONLY("wifiOnly"),
    
    ALWAYS("always");

    private String value;

    AutoUpdatePolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AutoUpdatePolicyEnum fromValue(String value) {
      for (AutoUpdatePolicyEnum b : AutoUpdatePolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AutoUpdatePolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AutoUpdatePolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AutoUpdatePolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AutoUpdatePolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AutoUpdatePolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AUTO_UPDATE_POLICY = "autoUpdatePolicy";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_AUTO_UPDATE_POLICY)
  private AutoUpdatePolicyEnum autoUpdatePolicy;

  /**
   * Whether the device reports app states to the EMM. The default value is \&quot;deviceReportDisabled\&quot;.
   */
  @JsonAdapter(DeviceReportPolicyEnum.Adapter.class)
  public enum DeviceReportPolicyEnum {
    DEVICE_REPORT_POLICY_UNSPECIFIED("deviceReportPolicyUnspecified"),
    
    DEVICE_REPORT_DISABLED("deviceReportDisabled"),
    
    DEVICE_REPORT_ENABLED("deviceReportEnabled");

    private String value;

    DeviceReportPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DeviceReportPolicyEnum fromValue(String value) {
      for (DeviceReportPolicyEnum b : DeviceReportPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DeviceReportPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DeviceReportPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DeviceReportPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DeviceReportPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DeviceReportPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEVICE_REPORT_POLICY = "deviceReportPolicy";
  @SerializedName(SERIALIZED_NAME_DEVICE_REPORT_POLICY)
  private DeviceReportPolicyEnum deviceReportPolicy;

  public static final String SERIALIZED_NAME_MAINTENANCE_WINDOW = "maintenanceWindow";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_WINDOW)
  private MaintenanceWindow maintenanceWindow;

  /**
   * The availability granted to the device for the specified products. \&quot;all\&quot; gives the device access to all products, regardless of approval status. \&quot;all\&quot; does not enable automatic visibility of \&quot;alpha\&quot; or \&quot;beta\&quot; tracks. \&quot;whitelist\&quot; grants the device access the products specified in productPolicy[]. Only products that are approved or products that were previously approved (products with revoked approval) by the enterprise can be whitelisted. If no value is provided, the availability set at the user level is applied by default.
   */
  @JsonAdapter(ProductAvailabilityPolicyEnum.Adapter.class)
  public enum ProductAvailabilityPolicyEnum {
    PRODUCT_AVAILABILITY_POLICY_UNSPECIFIED("productAvailabilityPolicyUnspecified"),
    
    WHITELIST("whitelist"),
    
    ALL("all");

    private String value;

    ProductAvailabilityPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProductAvailabilityPolicyEnum fromValue(String value) {
      for (ProductAvailabilityPolicyEnum b : ProductAvailabilityPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProductAvailabilityPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProductAvailabilityPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProductAvailabilityPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProductAvailabilityPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProductAvailabilityPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PRODUCT_AVAILABILITY_POLICY = "productAvailabilityPolicy";
  @SerializedName(SERIALIZED_NAME_PRODUCT_AVAILABILITY_POLICY)
  private ProductAvailabilityPolicyEnum productAvailabilityPolicy;

  public static final String SERIALIZED_NAME_PRODUCT_POLICY = "productPolicy";
  @SerializedName(SERIALIZED_NAME_PRODUCT_POLICY)
  private List<ProductPolicy> productPolicy = new ArrayList<>();

  public Policy() {
  }

  @Deprecated
  public Policy autoUpdatePolicy(AutoUpdatePolicyEnum autoUpdatePolicy) {
    this.autoUpdatePolicy = autoUpdatePolicy;
    return this;
  }

  /**
   * Controls when automatic app updates on the device can be applied. Recommended alternative: autoUpdateMode which is set per app, provides greater flexibility around update frequency. When autoUpdateMode is set to AUTO_UPDATE_POSTPONED or AUTO_UPDATE_HIGH_PRIORITY, autoUpdatePolicy has no effect. \&quot;choiceToTheUser\&quot; allows the device&#39;s user to configure the app update policy. \&quot;always\&quot; enables auto updates. \&quot;never\&quot; disables auto updates. \&quot;wifiOnly\&quot; enables auto updates only when the device is connected to wifi.
   * @return autoUpdatePolicy
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public AutoUpdatePolicyEnum getAutoUpdatePolicy() {
    return autoUpdatePolicy;
  }

  @Deprecated
  public void setAutoUpdatePolicy(AutoUpdatePolicyEnum autoUpdatePolicy) {
    this.autoUpdatePolicy = autoUpdatePolicy;
  }


  public Policy deviceReportPolicy(DeviceReportPolicyEnum deviceReportPolicy) {
    this.deviceReportPolicy = deviceReportPolicy;
    return this;
  }

  /**
   * Whether the device reports app states to the EMM. The default value is \&quot;deviceReportDisabled\&quot;.
   * @return deviceReportPolicy
   */
  @javax.annotation.Nullable
  public DeviceReportPolicyEnum getDeviceReportPolicy() {
    return deviceReportPolicy;
  }

  public void setDeviceReportPolicy(DeviceReportPolicyEnum deviceReportPolicy) {
    this.deviceReportPolicy = deviceReportPolicy;
  }


  public Policy maintenanceWindow(MaintenanceWindow maintenanceWindow) {
    this.maintenanceWindow = maintenanceWindow;
    return this;
  }

  /**
   * Get maintenanceWindow
   * @return maintenanceWindow
   */
  @javax.annotation.Nullable
  public MaintenanceWindow getMaintenanceWindow() {
    return maintenanceWindow;
  }

  public void setMaintenanceWindow(MaintenanceWindow maintenanceWindow) {
    this.maintenanceWindow = maintenanceWindow;
  }


  public Policy productAvailabilityPolicy(ProductAvailabilityPolicyEnum productAvailabilityPolicy) {
    this.productAvailabilityPolicy = productAvailabilityPolicy;
    return this;
  }

  /**
   * The availability granted to the device for the specified products. \&quot;all\&quot; gives the device access to all products, regardless of approval status. \&quot;all\&quot; does not enable automatic visibility of \&quot;alpha\&quot; or \&quot;beta\&quot; tracks. \&quot;whitelist\&quot; grants the device access the products specified in productPolicy[]. Only products that are approved or products that were previously approved (products with revoked approval) by the enterprise can be whitelisted. If no value is provided, the availability set at the user level is applied by default.
   * @return productAvailabilityPolicy
   */
  @javax.annotation.Nullable
  public ProductAvailabilityPolicyEnum getProductAvailabilityPolicy() {
    return productAvailabilityPolicy;
  }

  public void setProductAvailabilityPolicy(ProductAvailabilityPolicyEnum productAvailabilityPolicy) {
    this.productAvailabilityPolicy = productAvailabilityPolicy;
  }


  public Policy productPolicy(List<ProductPolicy> productPolicy) {
    this.productPolicy = productPolicy;
    return this;
  }

  public Policy addProductPolicyItem(ProductPolicy productPolicyItem) {
    if (this.productPolicy == null) {
      this.productPolicy = new ArrayList<>();
    }
    this.productPolicy.add(productPolicyItem);
    return this;
  }

  /**
   * The list of product policies. The productAvailabilityPolicy needs to be set to WHITELIST or ALL for the product policies to be applied.
   * @return productPolicy
   */
  @javax.annotation.Nullable
  public List<ProductPolicy> getProductPolicy() {
    return productPolicy;
  }

  public void setProductPolicy(List<ProductPolicy> productPolicy) {
    this.productPolicy = productPolicy;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Policy policy = (Policy) o;
    return Objects.equals(this.autoUpdatePolicy, policy.autoUpdatePolicy) &&
        Objects.equals(this.deviceReportPolicy, policy.deviceReportPolicy) &&
        Objects.equals(this.maintenanceWindow, policy.maintenanceWindow) &&
        Objects.equals(this.productAvailabilityPolicy, policy.productAvailabilityPolicy) &&
        Objects.equals(this.productPolicy, policy.productPolicy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoUpdatePolicy, deviceReportPolicy, maintenanceWindow, productAvailabilityPolicy, productPolicy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Policy {\n");
    sb.append("    autoUpdatePolicy: ").append(toIndentedString(autoUpdatePolicy)).append("\n");
    sb.append("    deviceReportPolicy: ").append(toIndentedString(deviceReportPolicy)).append("\n");
    sb.append("    maintenanceWindow: ").append(toIndentedString(maintenanceWindow)).append("\n");
    sb.append("    productAvailabilityPolicy: ").append(toIndentedString(productAvailabilityPolicy)).append("\n");
    sb.append("    productPolicy: ").append(toIndentedString(productPolicy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoUpdatePolicy");
    openapiFields.add("deviceReportPolicy");
    openapiFields.add("maintenanceWindow");
    openapiFields.add("productAvailabilityPolicy");
    openapiFields.add("productPolicy");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Policy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Policy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Policy is not found in the empty JSON string", Policy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Policy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Policy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("autoUpdatePolicy") != null && !jsonObj.get("autoUpdatePolicy").isJsonNull()) && !jsonObj.get("autoUpdatePolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `autoUpdatePolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("autoUpdatePolicy").toString()));
      }
      // validate the optional field `autoUpdatePolicy`
      if (jsonObj.get("autoUpdatePolicy") != null && !jsonObj.get("autoUpdatePolicy").isJsonNull()) {
        AutoUpdatePolicyEnum.validateJsonElement(jsonObj.get("autoUpdatePolicy"));
      }
      if ((jsonObj.get("deviceReportPolicy") != null && !jsonObj.get("deviceReportPolicy").isJsonNull()) && !jsonObj.get("deviceReportPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceReportPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceReportPolicy").toString()));
      }
      // validate the optional field `deviceReportPolicy`
      if (jsonObj.get("deviceReportPolicy") != null && !jsonObj.get("deviceReportPolicy").isJsonNull()) {
        DeviceReportPolicyEnum.validateJsonElement(jsonObj.get("deviceReportPolicy"));
      }
      // validate the optional field `maintenanceWindow`
      if (jsonObj.get("maintenanceWindow") != null && !jsonObj.get("maintenanceWindow").isJsonNull()) {
        MaintenanceWindow.validateJsonElement(jsonObj.get("maintenanceWindow"));
      }
      if ((jsonObj.get("productAvailabilityPolicy") != null && !jsonObj.get("productAvailabilityPolicy").isJsonNull()) && !jsonObj.get("productAvailabilityPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `productAvailabilityPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("productAvailabilityPolicy").toString()));
      }
      // validate the optional field `productAvailabilityPolicy`
      if (jsonObj.get("productAvailabilityPolicy") != null && !jsonObj.get("productAvailabilityPolicy").isJsonNull()) {
        ProductAvailabilityPolicyEnum.validateJsonElement(jsonObj.get("productAvailabilityPolicy"));
      }
      if (jsonObj.get("productPolicy") != null && !jsonObj.get("productPolicy").isJsonNull()) {
        JsonArray jsonArrayproductPolicy = jsonObj.getAsJsonArray("productPolicy");
        if (jsonArrayproductPolicy != null) {
          // ensure the json data is an array
          if (!jsonObj.get("productPolicy").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `productPolicy` to be an array in the JSON string but got `%s`", jsonObj.get("productPolicy").toString()));
          }

          // validate the optional field `productPolicy` (array)
          for (int i = 0; i < jsonArrayproductPolicy.size(); i++) {
            ProductPolicy.validateJsonElement(jsonArrayproductPolicy.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Policy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Policy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Policy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Policy.class));

       return (TypeAdapter<T>) new TypeAdapter<Policy>() {
           @Override
           public void write(JsonWriter out, Policy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Policy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Policy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Policy
   * @throws IOException if the JSON string is invalid with respect to Policy
   */
  public static Policy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Policy.class);
  }

  /**
   * Convert an instance of Policy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

