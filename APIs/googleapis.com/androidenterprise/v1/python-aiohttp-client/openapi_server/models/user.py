# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server import util


class User(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, account_identifier: str=None, account_type: str=None, display_name: str=None, id: str=None, management_type: str=None, primary_email: str=None):
        """User - a model defined in OpenAPI

        :param account_identifier: The account_identifier of this User.
        :param account_type: The account_type of this User.
        :param display_name: The display_name of this User.
        :param id: The id of this User.
        :param management_type: The management_type of this User.
        :param primary_email: The primary_email of this User.
        """
        self.openapi_types = {
            'account_identifier': str,
            'account_type': str,
            'display_name': str,
            'id': str,
            'management_type': str,
            'primary_email': str
        }

        self.attribute_map = {
            'account_identifier': 'accountIdentifier',
            'account_type': 'accountType',
            'display_name': 'displayName',
            'id': 'id',
            'management_type': 'managementType',
            'primary_email': 'primaryEmail'
        }

        self._account_identifier = account_identifier
        self._account_type = account_type
        self._display_name = display_name
        self._id = id
        self._management_type = management_type
        self._primary_email = primary_email

    @classmethod
    def from_dict(cls, dikt: dict) -> 'User':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The User of this User.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def account_identifier(self):
        """Gets the account_identifier of this User.

        A unique identifier you create for this user, such as \"user342\" or \"asset#44418\". Do not use personally identifiable information (PII) for this property. Must always be set for EMM-managed users. Not set for Google-managed users.

        :return: The account_identifier of this User.
        :rtype: str
        """
        return self._account_identifier

    @account_identifier.setter
    def account_identifier(self, account_identifier):
        """Sets the account_identifier of this User.

        A unique identifier you create for this user, such as \"user342\" or \"asset#44418\". Do not use personally identifiable information (PII) for this property. Must always be set for EMM-managed users. Not set for Google-managed users.

        :param account_identifier: The account_identifier of this User.
        :type account_identifier: str
        """

        self._account_identifier = account_identifier

    @property
    def account_type(self):
        """Gets the account_type of this User.

        The type of account that this user represents. A userAccount can be installed on multiple devices, but a deviceAccount is specific to a single device. An EMM-managed user (emmManaged) can be either type (userAccount, deviceAccount), but a Google-managed user (googleManaged) is always a userAccount.

        :return: The account_type of this User.
        :rtype: str
        """
        return self._account_type

    @account_type.setter
    def account_type(self, account_type):
        """Sets the account_type of this User.

        The type of account that this user represents. A userAccount can be installed on multiple devices, but a deviceAccount is specific to a single device. An EMM-managed user (emmManaged) can be either type (userAccount, deviceAccount), but a Google-managed user (googleManaged) is always a userAccount.

        :param account_type: The account_type of this User.
        :type account_type: str
        """
        allowed_values = ["deviceAccount", "userAccount"]  # noqa: E501
        if account_type not in allowed_values:
            raise ValueError(
                "Invalid value for `account_type` ({0}), must be one of {1}"
                .format(account_type, allowed_values)
            )

        self._account_type = account_type

    @property
    def display_name(self):
        """Gets the display_name of this User.

        The name that will appear in user interfaces. Setting this property is optional when creating EMM-managed users. If you do set this property, use something generic about the organization (such as \"Example, Inc.\") or your name (as EMM). Not used for Google-managed user accounts. @mutable androidenterprise.users.update

        :return: The display_name of this User.
        :rtype: str
        """
        return self._display_name

    @display_name.setter
    def display_name(self, display_name):
        """Sets the display_name of this User.

        The name that will appear in user interfaces. Setting this property is optional when creating EMM-managed users. If you do set this property, use something generic about the organization (such as \"Example, Inc.\") or your name (as EMM). Not used for Google-managed user accounts. @mutable androidenterprise.users.update

        :param display_name: The display_name of this User.
        :type display_name: str
        """

        self._display_name = display_name

    @property
    def id(self):
        """Gets the id of this User.

        The unique ID for the user.

        :return: The id of this User.
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this User.

        The unique ID for the user.

        :param id: The id of this User.
        :type id: str
        """

        self._id = id

    @property
    def management_type(self):
        """Gets the management_type of this User.

        The entity that manages the user. With googleManaged users, the source of truth is Google so EMMs have to make sure a Google Account exists for the user. With emmManaged users, the EMM is in charge.

        :return: The management_type of this User.
        :rtype: str
        """
        return self._management_type

    @management_type.setter
    def management_type(self, management_type):
        """Sets the management_type of this User.

        The entity that manages the user. With googleManaged users, the source of truth is Google so EMMs have to make sure a Google Account exists for the user. With emmManaged users, the EMM is in charge.

        :param management_type: The management_type of this User.
        :type management_type: str
        """
        allowed_values = ["googleManaged", "emmManaged"]  # noqa: E501
        if management_type not in allowed_values:
            raise ValueError(
                "Invalid value for `management_type` ({0}), must be one of {1}"
                .format(management_type, allowed_values)
            )

        self._management_type = management_type

    @property
    def primary_email(self):
        """Gets the primary_email of this User.

        The user's primary email address, for example, \"jsmith@example.com\". Will always be set for Google managed users and not set for EMM managed users.

        :return: The primary_email of this User.
        :rtype: str
        """
        return self._primary_email

    @primary_email.setter
    def primary_email(self, primary_email):
        """Sets the primary_email of this User.

        The user's primary email address, for example, \"jsmith@example.com\". Will always be set for Google managed users and not set for EMM managed users.

        :param primary_email: The primary_email of this User.
        :type primary_email: str
        """

        self._primary_email = primary_email
