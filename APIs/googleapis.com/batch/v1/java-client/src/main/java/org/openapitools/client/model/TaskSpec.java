/*
 * Batch API
 * An API to manage the running of batch resources on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.ComputeResource;
import org.openapitools.client.model.Environment;
import org.openapitools.client.model.LifecyclePolicy;
import org.openapitools.client.model.Runnable;
import org.openapitools.client.model.Volume;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Spec of a task
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:22.956738-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TaskSpec {
  public static final String SERIALIZED_NAME_COMPUTE_RESOURCE = "computeResource";
  @SerializedName(SERIALIZED_NAME_COMPUTE_RESOURCE)
  private ComputeResource computeResource;

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private Environment environment;

  public static final String SERIALIZED_NAME_ENVIRONMENTS = "environments";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_ENVIRONMENTS)
  private Map<String, String> environments = new HashMap<>();

  public static final String SERIALIZED_NAME_LIFECYCLE_POLICIES = "lifecyclePolicies";
  @SerializedName(SERIALIZED_NAME_LIFECYCLE_POLICIES)
  private List<LifecyclePolicy> lifecyclePolicies = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAX_RETRY_COUNT = "maxRetryCount";
  @SerializedName(SERIALIZED_NAME_MAX_RETRY_COUNT)
  private Integer maxRetryCount;

  public static final String SERIALIZED_NAME_MAX_RUN_DURATION = "maxRunDuration";
  @SerializedName(SERIALIZED_NAME_MAX_RUN_DURATION)
  private String maxRunDuration;

  public static final String SERIALIZED_NAME_RUNNABLES = "runnables";
  @SerializedName(SERIALIZED_NAME_RUNNABLES)
  private List<Runnable> runnables = new ArrayList<>();

  public static final String SERIALIZED_NAME_VOLUMES = "volumes";
  @SerializedName(SERIALIZED_NAME_VOLUMES)
  private List<Volume> volumes = new ArrayList<>();

  public TaskSpec() {
  }

  public TaskSpec computeResource(ComputeResource computeResource) {
    this.computeResource = computeResource;
    return this;
  }

  /**
   * Get computeResource
   * @return computeResource
   */
  @javax.annotation.Nullable
  public ComputeResource getComputeResource() {
    return computeResource;
  }

  public void setComputeResource(ComputeResource computeResource) {
    this.computeResource = computeResource;
  }


  public TaskSpec environment(Environment environment) {
    this.environment = environment;
    return this;
  }

  /**
   * Get environment
   * @return environment
   */
  @javax.annotation.Nullable
  public Environment getEnvironment() {
    return environment;
  }

  public void setEnvironment(Environment environment) {
    this.environment = environment;
  }


  @Deprecated
  public TaskSpec environments(Map<String, String> environments) {
    this.environments = environments;
    return this;
  }

  public TaskSpec putEnvironmentsItem(String key, String environmentsItem) {
    if (this.environments == null) {
      this.environments = new HashMap<>();
    }
    this.environments.put(key, environmentsItem);
    return this;
  }

  /**
   * Deprecated: please use environment(non-plural) instead.
   * @return environments
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Map<String, String> getEnvironments() {
    return environments;
  }

  @Deprecated
  public void setEnvironments(Map<String, String> environments) {
    this.environments = environments;
  }


  public TaskSpec lifecyclePolicies(List<LifecyclePolicy> lifecyclePolicies) {
    this.lifecyclePolicies = lifecyclePolicies;
    return this;
  }

  public TaskSpec addLifecyclePoliciesItem(LifecyclePolicy lifecyclePoliciesItem) {
    if (this.lifecyclePolicies == null) {
      this.lifecyclePolicies = new ArrayList<>();
    }
    this.lifecyclePolicies.add(lifecyclePoliciesItem);
    return this;
  }

  /**
   * Lifecycle management schema when any task in a task group is failed. Currently we only support one lifecycle policy. When the lifecycle policy condition is met, the action in the policy will execute. If task execution result does not meet with the defined lifecycle policy, we consider it as the default policy. Default policy means if the exit code is 0, exit task. If task ends with non-zero exit code, retry the task with max_retry_count.
   * @return lifecyclePolicies
   */
  @javax.annotation.Nullable
  public List<LifecyclePolicy> getLifecyclePolicies() {
    return lifecyclePolicies;
  }

  public void setLifecyclePolicies(List<LifecyclePolicy> lifecyclePolicies) {
    this.lifecyclePolicies = lifecyclePolicies;
  }


  public TaskSpec maxRetryCount(Integer maxRetryCount) {
    this.maxRetryCount = maxRetryCount;
    return this;
  }

  /**
   * Maximum number of retries on failures. The default, 0, which means never retry. The valid value range is [0, 10].
   * @return maxRetryCount
   */
  @javax.annotation.Nullable
  public Integer getMaxRetryCount() {
    return maxRetryCount;
  }

  public void setMaxRetryCount(Integer maxRetryCount) {
    this.maxRetryCount = maxRetryCount;
  }


  public TaskSpec maxRunDuration(String maxRunDuration) {
    this.maxRunDuration = maxRunDuration;
    return this;
  }

  /**
   * Maximum duration the task should run. The task will be killed and marked as FAILED if over this limit.
   * @return maxRunDuration
   */
  @javax.annotation.Nullable
  public String getMaxRunDuration() {
    return maxRunDuration;
  }

  public void setMaxRunDuration(String maxRunDuration) {
    this.maxRunDuration = maxRunDuration;
  }


  public TaskSpec runnables(List<Runnable> runnables) {
    this.runnables = runnables;
    return this;
  }

  public TaskSpec addRunnablesItem(Runnable runnablesItem) {
    if (this.runnables == null) {
      this.runnables = new ArrayList<>();
    }
    this.runnables.add(runnablesItem);
    return this;
  }

  /**
   * The sequence of scripts or containers to run for this Task. Each Task using this TaskSpec executes its list of runnables in order. The Task succeeds if all of its runnables either exit with a zero status or any that exit with a non-zero status have the ignore_exit_status flag. Background runnables are killed automatically (if they have not already exited) a short time after all foreground runnables have completed. Even though this is likely to result in a non-zero exit status for the background runnable, these automatic kills are not treated as Task failures.
   * @return runnables
   */
  @javax.annotation.Nullable
  public List<Runnable> getRunnables() {
    return runnables;
  }

  public void setRunnables(List<Runnable> runnables) {
    this.runnables = runnables;
  }


  public TaskSpec volumes(List<Volume> volumes) {
    this.volumes = volumes;
    return this;
  }

  public TaskSpec addVolumesItem(Volume volumesItem) {
    if (this.volumes == null) {
      this.volumes = new ArrayList<>();
    }
    this.volumes.add(volumesItem);
    return this;
  }

  /**
   * Volumes to mount before running Tasks using this TaskSpec.
   * @return volumes
   */
  @javax.annotation.Nullable
  public List<Volume> getVolumes() {
    return volumes;
  }

  public void setVolumes(List<Volume> volumes) {
    this.volumes = volumes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TaskSpec taskSpec = (TaskSpec) o;
    return Objects.equals(this.computeResource, taskSpec.computeResource) &&
        Objects.equals(this.environment, taskSpec.environment) &&
        Objects.equals(this.environments, taskSpec.environments) &&
        Objects.equals(this.lifecyclePolicies, taskSpec.lifecyclePolicies) &&
        Objects.equals(this.maxRetryCount, taskSpec.maxRetryCount) &&
        Objects.equals(this.maxRunDuration, taskSpec.maxRunDuration) &&
        Objects.equals(this.runnables, taskSpec.runnables) &&
        Objects.equals(this.volumes, taskSpec.volumes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(computeResource, environment, environments, lifecyclePolicies, maxRetryCount, maxRunDuration, runnables, volumes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TaskSpec {\n");
    sb.append("    computeResource: ").append(toIndentedString(computeResource)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    environments: ").append(toIndentedString(environments)).append("\n");
    sb.append("    lifecyclePolicies: ").append(toIndentedString(lifecyclePolicies)).append("\n");
    sb.append("    maxRetryCount: ").append(toIndentedString(maxRetryCount)).append("\n");
    sb.append("    maxRunDuration: ").append(toIndentedString(maxRunDuration)).append("\n");
    sb.append("    runnables: ").append(toIndentedString(runnables)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("computeResource");
    openapiFields.add("environment");
    openapiFields.add("environments");
    openapiFields.add("lifecyclePolicies");
    openapiFields.add("maxRetryCount");
    openapiFields.add("maxRunDuration");
    openapiFields.add("runnables");
    openapiFields.add("volumes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TaskSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TaskSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TaskSpec is not found in the empty JSON string", TaskSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TaskSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TaskSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `computeResource`
      if (jsonObj.get("computeResource") != null && !jsonObj.get("computeResource").isJsonNull()) {
        ComputeResource.validateJsonElement(jsonObj.get("computeResource"));
      }
      // validate the optional field `environment`
      if (jsonObj.get("environment") != null && !jsonObj.get("environment").isJsonNull()) {
        Environment.validateJsonElement(jsonObj.get("environment"));
      }
      if (jsonObj.get("lifecyclePolicies") != null && !jsonObj.get("lifecyclePolicies").isJsonNull()) {
        JsonArray jsonArraylifecyclePolicies = jsonObj.getAsJsonArray("lifecyclePolicies");
        if (jsonArraylifecyclePolicies != null) {
          // ensure the json data is an array
          if (!jsonObj.get("lifecyclePolicies").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `lifecyclePolicies` to be an array in the JSON string but got `%s`", jsonObj.get("lifecyclePolicies").toString()));
          }

          // validate the optional field `lifecyclePolicies` (array)
          for (int i = 0; i < jsonArraylifecyclePolicies.size(); i++) {
            LifecyclePolicy.validateJsonElement(jsonArraylifecyclePolicies.get(i));
          };
        }
      }
      if ((jsonObj.get("maxRunDuration") != null && !jsonObj.get("maxRunDuration").isJsonNull()) && !jsonObj.get("maxRunDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxRunDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxRunDuration").toString()));
      }
      if (jsonObj.get("runnables") != null && !jsonObj.get("runnables").isJsonNull()) {
        JsonArray jsonArrayrunnables = jsonObj.getAsJsonArray("runnables");
        if (jsonArrayrunnables != null) {
          // ensure the json data is an array
          if (!jsonObj.get("runnables").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `runnables` to be an array in the JSON string but got `%s`", jsonObj.get("runnables").toString()));
          }

          // validate the optional field `runnables` (array)
          for (int i = 0; i < jsonArrayrunnables.size(); i++) {
            Runnable.validateJsonElement(jsonArrayrunnables.get(i));
          };
        }
      }
      if (jsonObj.get("volumes") != null && !jsonObj.get("volumes").isJsonNull()) {
        JsonArray jsonArrayvolumes = jsonObj.getAsJsonArray("volumes");
        if (jsonArrayvolumes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("volumes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `volumes` to be an array in the JSON string but got `%s`", jsonObj.get("volumes").toString()));
          }

          // validate the optional field `volumes` (array)
          for (int i = 0; i < jsonArrayvolumes.size(); i++) {
            Volume.validateJsonElement(jsonArrayvolumes.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TaskSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TaskSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TaskSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TaskSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<TaskSpec>() {
           @Override
           public void write(JsonWriter out, TaskSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TaskSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TaskSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TaskSpec
   * @throws IOException if the JSON string is invalid with respect to TaskSpec
   */
  public static TaskSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TaskSpec.class);
  }

  /**
   * Convert an instance of TaskSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

