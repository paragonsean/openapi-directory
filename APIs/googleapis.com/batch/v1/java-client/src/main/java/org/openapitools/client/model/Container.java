/*
 * Batch API
 * An API to manage the running of batch resources on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Container runnable.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:22.956738-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Container {
  public static final String SERIALIZED_NAME_BLOCK_EXTERNAL_NETWORK = "blockExternalNetwork";
  @SerializedName(SERIALIZED_NAME_BLOCK_EXTERNAL_NETWORK)
  private Boolean blockExternalNetwork;

  public static final String SERIALIZED_NAME_COMMANDS = "commands";
  @SerializedName(SERIALIZED_NAME_COMMANDS)
  private List<String> commands = new ArrayList<>();

  public static final String SERIALIZED_NAME_ENABLE_IMAGE_STREAMING = "enableImageStreaming";
  @SerializedName(SERIALIZED_NAME_ENABLE_IMAGE_STREAMING)
  private Boolean enableImageStreaming;

  public static final String SERIALIZED_NAME_ENTRYPOINT = "entrypoint";
  @SerializedName(SERIALIZED_NAME_ENTRYPOINT)
  private String entrypoint;

  public static final String SERIALIZED_NAME_IMAGE_URI = "imageUri";
  @SerializedName(SERIALIZED_NAME_IMAGE_URI)
  private String imageUri;

  public static final String SERIALIZED_NAME_OPTIONS = "options";
  @SerializedName(SERIALIZED_NAME_OPTIONS)
  private String options;

  public static final String SERIALIZED_NAME_PASSWORD = "password";
  @SerializedName(SERIALIZED_NAME_PASSWORD)
  private String password;

  public static final String SERIALIZED_NAME_USERNAME = "username";
  @SerializedName(SERIALIZED_NAME_USERNAME)
  private String username;

  public static final String SERIALIZED_NAME_VOLUMES = "volumes";
  @SerializedName(SERIALIZED_NAME_VOLUMES)
  private List<String> volumes = new ArrayList<>();

  public Container() {
  }

  public Container blockExternalNetwork(Boolean blockExternalNetwork) {
    this.blockExternalNetwork = blockExternalNetwork;
    return this;
  }

  /**
   * If set to true, external network access to and from container will be blocked, containers that are with block_external_network as true can still communicate with each other, network cannot be specified in the &#x60;container.options&#x60; field.
   * @return blockExternalNetwork
   */
  @javax.annotation.Nullable
  public Boolean getBlockExternalNetwork() {
    return blockExternalNetwork;
  }

  public void setBlockExternalNetwork(Boolean blockExternalNetwork) {
    this.blockExternalNetwork = blockExternalNetwork;
  }


  public Container commands(List<String> commands) {
    this.commands = commands;
    return this;
  }

  public Container addCommandsItem(String commandsItem) {
    if (this.commands == null) {
      this.commands = new ArrayList<>();
    }
    this.commands.add(commandsItem);
    return this;
  }

  /**
   * Overrides the &#x60;CMD&#x60; specified in the container. If there is an ENTRYPOINT (either in the container image or with the entrypoint field below) then commands are appended as arguments to the ENTRYPOINT.
   * @return commands
   */
  @javax.annotation.Nullable
  public List<String> getCommands() {
    return commands;
  }

  public void setCommands(List<String> commands) {
    this.commands = commands;
  }


  public Container enableImageStreaming(Boolean enableImageStreaming) {
    this.enableImageStreaming = enableImageStreaming;
    return this;
  }

  /**
   * Optional. If set to true, this container runnable uses Image streaming. Use Image streaming to allow the runnable to initialize without waiting for the entire container image to download, which can significantly reduce startup time for large container images. When &#x60;enableImageStreaming&#x60; is set to true, the container runtime is [containerd](https://containerd.io/) instead of Docker. Additionally, this container runnable only supports the following &#x60;container&#x60; subfields: &#x60;imageUri&#x60;, &#x60;commands[]&#x60;, &#x60;entrypoint&#x60;, and &#x60;volumes[]&#x60;; any other &#x60;container&#x60; subfields are ignored. For more information about the requirements and limitations for using Image streaming with Batch, see the [&#x60;image-streaming&#x60; sample on GitHub](https://github.com/GoogleCloudPlatform/batch-samples/tree/main/api-samples/image-streaming).
   * @return enableImageStreaming
   */
  @javax.annotation.Nullable
  public Boolean getEnableImageStreaming() {
    return enableImageStreaming;
  }

  public void setEnableImageStreaming(Boolean enableImageStreaming) {
    this.enableImageStreaming = enableImageStreaming;
  }


  public Container entrypoint(String entrypoint) {
    this.entrypoint = entrypoint;
    return this;
  }

  /**
   * Overrides the &#x60;ENTRYPOINT&#x60; specified in the container.
   * @return entrypoint
   */
  @javax.annotation.Nullable
  public String getEntrypoint() {
    return entrypoint;
  }

  public void setEntrypoint(String entrypoint) {
    this.entrypoint = entrypoint;
  }


  public Container imageUri(String imageUri) {
    this.imageUri = imageUri;
    return this;
  }

  /**
   * The URI to pull the container image from.
   * @return imageUri
   */
  @javax.annotation.Nullable
  public String getImageUri() {
    return imageUri;
  }

  public void setImageUri(String imageUri) {
    this.imageUri = imageUri;
  }


  public Container options(String options) {
    this.options = options;
    return this;
  }

  /**
   * Arbitrary additional options to include in the \&quot;docker run\&quot; command when running this container, e.g. \&quot;--network host\&quot;.
   * @return options
   */
  @javax.annotation.Nullable
  public String getOptions() {
    return options;
  }

  public void setOptions(String options) {
    this.options = options;
  }


  public Container password(String password) {
    this.password = password;
    return this;
  }

  /**
   * Required if the container image is from a private Docker registry. The password to login to the Docker registry that contains the image. For security, it is strongly recommended to specify an encrypted password by using a Secret Manager secret: &#x60;projects/_*_/secrets/_*_/versions/_*&#x60;. Warning: If you specify the password using plain text, you risk the password being exposed to any users who can view the job or its logs. To avoid this risk, specify a secret that contains the password instead. Learn more about [Secret Manager](https://cloud.google.com/secret-manager/docs/) and [using Secret Manager with Batch](https://cloud.google.com/batch/docs/create-run-job-secret-manager).
   * @return password
   */
  @javax.annotation.Nullable
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }


  public Container username(String username) {
    this.username = username;
    return this;
  }

  /**
   * Required if the container image is from a private Docker registry. The username to login to the Docker registry that contains the image. You can either specify the username directly by using plain text or specify an encrypted username by using a Secret Manager secret: &#x60;projects/_*_/secrets/_*_/versions/_*&#x60;. However, using a secret is recommended for enhanced security. Caution: If you specify the username using plain text, you risk the username being exposed to any users who can view the job or its logs. To avoid this risk, specify a secret that contains the username instead. Learn more about [Secret Manager](https://cloud.google.com/secret-manager/docs/) and [using Secret Manager with Batch](https://cloud.google.com/batch/docs/create-run-job-secret-manager).
   * @return username
   */
  @javax.annotation.Nullable
  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }


  public Container volumes(List<String> volumes) {
    this.volumes = volumes;
    return this;
  }

  public Container addVolumesItem(String volumesItem) {
    if (this.volumes == null) {
      this.volumes = new ArrayList<>();
    }
    this.volumes.add(volumesItem);
    return this;
  }

  /**
   * Volumes to mount (bind mount) from the host machine files or directories into the container, formatted to match docker run&#39;s --volume option, e.g. /foo:/bar, or /foo:/bar:ro If the &#x60;TaskSpec.Volumes&#x60; field is specified but this field is not, Batch will mount each volume from the host machine to the container with the same mount path by default. In this case, the default mount option for containers will be read-only (ro) for existing persistent disks and read-write (rw) for other volume types, regardless of the original mount options specified in &#x60;TaskSpec.Volumes&#x60;. If you need different mount settings, you can explicitly configure them in this field.
   * @return volumes
   */
  @javax.annotation.Nullable
  public List<String> getVolumes() {
    return volumes;
  }

  public void setVolumes(List<String> volumes) {
    this.volumes = volumes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Container container = (Container) o;
    return Objects.equals(this.blockExternalNetwork, container.blockExternalNetwork) &&
        Objects.equals(this.commands, container.commands) &&
        Objects.equals(this.enableImageStreaming, container.enableImageStreaming) &&
        Objects.equals(this.entrypoint, container.entrypoint) &&
        Objects.equals(this.imageUri, container.imageUri) &&
        Objects.equals(this.options, container.options) &&
        Objects.equals(this.password, container.password) &&
        Objects.equals(this.username, container.username) &&
        Objects.equals(this.volumes, container.volumes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(blockExternalNetwork, commands, enableImageStreaming, entrypoint, imageUri, options, password, username, volumes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Container {\n");
    sb.append("    blockExternalNetwork: ").append(toIndentedString(blockExternalNetwork)).append("\n");
    sb.append("    commands: ").append(toIndentedString(commands)).append("\n");
    sb.append("    enableImageStreaming: ").append(toIndentedString(enableImageStreaming)).append("\n");
    sb.append("    entrypoint: ").append(toIndentedString(entrypoint)).append("\n");
    sb.append("    imageUri: ").append(toIndentedString(imageUri)).append("\n");
    sb.append("    options: ").append(toIndentedString(options)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    username: ").append(toIndentedString(username)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("blockExternalNetwork");
    openapiFields.add("commands");
    openapiFields.add("enableImageStreaming");
    openapiFields.add("entrypoint");
    openapiFields.add("imageUri");
    openapiFields.add("options");
    openapiFields.add("password");
    openapiFields.add("username");
    openapiFields.add("volumes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Container
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Container.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Container is not found in the empty JSON string", Container.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Container.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Container` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("commands") != null && !jsonObj.get("commands").isJsonNull() && !jsonObj.get("commands").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `commands` to be an array in the JSON string but got `%s`", jsonObj.get("commands").toString()));
      }
      if ((jsonObj.get("entrypoint") != null && !jsonObj.get("entrypoint").isJsonNull()) && !jsonObj.get("entrypoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entrypoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entrypoint").toString()));
      }
      if ((jsonObj.get("imageUri") != null && !jsonObj.get("imageUri").isJsonNull()) && !jsonObj.get("imageUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `imageUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("imageUri").toString()));
      }
      if ((jsonObj.get("options") != null && !jsonObj.get("options").isJsonNull()) && !jsonObj.get("options").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `options` to be a primitive type in the JSON string but got `%s`", jsonObj.get("options").toString()));
      }
      if ((jsonObj.get("password") != null && !jsonObj.get("password").isJsonNull()) && !jsonObj.get("password").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `password` to be a primitive type in the JSON string but got `%s`", jsonObj.get("password").toString()));
      }
      if ((jsonObj.get("username") != null && !jsonObj.get("username").isJsonNull()) && !jsonObj.get("username").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `username` to be a primitive type in the JSON string but got `%s`", jsonObj.get("username").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("volumes") != null && !jsonObj.get("volumes").isJsonNull() && !jsonObj.get("volumes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `volumes` to be an array in the JSON string but got `%s`", jsonObj.get("volumes").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Container.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Container' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Container> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Container.class));

       return (TypeAdapter<T>) new TypeAdapter<Container>() {
           @Override
           public void write(JsonWriter out, Container value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Container read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Container given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Container
   * @throws IOException if the JSON string is invalid with respect to Container
   */
  public static Container fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Container.class);
  }

  /**
   * Convert an instance of Container to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

