/*
 * Batch API
 * An API to manage the running of batch resources on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Compute resource requirements. ComputeResource defines the amount of resources required for each task. Make sure your tasks have enough resources to successfully run. If you also define the types of resources for a job to use with the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure both fields are compatible with each other.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:22.956738-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ComputeResource {
  public static final String SERIALIZED_NAME_BOOT_DISK_MIB = "bootDiskMib";
  @SerializedName(SERIALIZED_NAME_BOOT_DISK_MIB)
  private String bootDiskMib;

  public static final String SERIALIZED_NAME_CPU_MILLI = "cpuMilli";
  @SerializedName(SERIALIZED_NAME_CPU_MILLI)
  private String cpuMilli;

  public static final String SERIALIZED_NAME_MEMORY_MIB = "memoryMib";
  @SerializedName(SERIALIZED_NAME_MEMORY_MIB)
  private String memoryMib;

  public ComputeResource() {
  }

  public ComputeResource bootDiskMib(String bootDiskMib) {
    this.bootDiskMib = bootDiskMib;
    return this;
  }

  /**
   * Extra boot disk size in MiB for each task.
   * @return bootDiskMib
   */
  @javax.annotation.Nullable
  public String getBootDiskMib() {
    return bootDiskMib;
  }

  public void setBootDiskMib(String bootDiskMib) {
    this.bootDiskMib = bootDiskMib;
  }


  public ComputeResource cpuMilli(String cpuMilli) {
    this.cpuMilli = cpuMilli;
    return this;
  }

  /**
   * The milliCPU count. &#x60;cpuMilli&#x60; defines the amount of CPU resources per task in milliCPU units. For example, &#x60;1000&#x60; corresponds to 1 vCPU per task. If undefined, the default value is &#x60;2000&#x60;. If you also define the VM&#39;s machine type using the &#x60;machineType&#x60; in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the &#x60;instanceTemplate&#x60; in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the CPU resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the &#x60;n2-standard-2&#x60; machine type, which has 2 vCPUs each, you are recommended to set &#x60;cpuMilli&#x60; no more than &#x60;2000&#x60;, or you are recommended to run two tasks on the same VM if you set &#x60;cpuMilli&#x60; to &#x60;1000&#x60; or less.
   * @return cpuMilli
   */
  @javax.annotation.Nullable
  public String getCpuMilli() {
    return cpuMilli;
  }

  public void setCpuMilli(String cpuMilli) {
    this.cpuMilli = cpuMilli;
  }


  public ComputeResource memoryMib(String memoryMib) {
    this.memoryMib = memoryMib;
    return this;
  }

  /**
   * Memory in MiB. &#x60;memoryMib&#x60; defines the amount of memory per task in MiB units. If undefined, the default value is &#x60;2000&#x60;. If you also define the VM&#39;s machine type using the &#x60;machineType&#x60; in [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy) field or inside the &#x60;instanceTemplate&#x60; in the [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate) field, make sure the memory resources for both fields are compatible with each other and with how many tasks you want to allow to run on the same VM at the same time. For example, if you specify the &#x60;n2-standard-2&#x60; machine type, which has 8 GiB each, you are recommended to set &#x60;memoryMib&#x60; to no more than &#x60;8192&#x60;, or you are recommended to run two tasks on the same VM if you set &#x60;memoryMib&#x60; to &#x60;4096&#x60; or less.
   * @return memoryMib
   */
  @javax.annotation.Nullable
  public String getMemoryMib() {
    return memoryMib;
  }

  public void setMemoryMib(String memoryMib) {
    this.memoryMib = memoryMib;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComputeResource computeResource = (ComputeResource) o;
    return Objects.equals(this.bootDiskMib, computeResource.bootDiskMib) &&
        Objects.equals(this.cpuMilli, computeResource.cpuMilli) &&
        Objects.equals(this.memoryMib, computeResource.memoryMib);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bootDiskMib, cpuMilli, memoryMib);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComputeResource {\n");
    sb.append("    bootDiskMib: ").append(toIndentedString(bootDiskMib)).append("\n");
    sb.append("    cpuMilli: ").append(toIndentedString(cpuMilli)).append("\n");
    sb.append("    memoryMib: ").append(toIndentedString(memoryMib)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bootDiskMib");
    openapiFields.add("cpuMilli");
    openapiFields.add("memoryMib");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ComputeResource
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ComputeResource.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ComputeResource is not found in the empty JSON string", ComputeResource.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ComputeResource.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ComputeResource` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("bootDiskMib") != null && !jsonObj.get("bootDiskMib").isJsonNull()) && !jsonObj.get("bootDiskMib").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bootDiskMib` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bootDiskMib").toString()));
      }
      if ((jsonObj.get("cpuMilli") != null && !jsonObj.get("cpuMilli").isJsonNull()) && !jsonObj.get("cpuMilli").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cpuMilli` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cpuMilli").toString()));
      }
      if ((jsonObj.get("memoryMib") != null && !jsonObj.get("memoryMib").isJsonNull()) && !jsonObj.get("memoryMib").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `memoryMib` to be a primitive type in the JSON string but got `%s`", jsonObj.get("memoryMib").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ComputeResource.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ComputeResource' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ComputeResource> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ComputeResource.class));

       return (TypeAdapter<T>) new TypeAdapter<ComputeResource>() {
           @Override
           public void write(JsonWriter out, ComputeResource value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ComputeResource read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ComputeResource given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ComputeResource
   * @throws IOException if the JSON string is invalid with respect to ComputeResource
   */
  public static ComputeResource fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ComputeResource.class);
  }

  /**
   * Convert an instance of ComputeResource to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

