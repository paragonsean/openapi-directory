/*
 * Google Workspace Alert Center API
 * Manages alerts on issues affecting your domain. Note: The current version of this API (v1beta1) is available to all Google Workspace customers. 
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.AlertMetadata;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An alert affecting a customer.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:29.687014-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Alert {
  public static final String SERIALIZED_NAME_ALERT_ID = "alertId";
  @SerializedName(SERIALIZED_NAME_ALERT_ID)
  private String alertId;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_CUSTOMER_ID = "customerId";
  @SerializedName(SERIALIZED_NAME_CUSTOMER_ID)
  private String customerId;

  public static final String SERIALIZED_NAME_DATA = "data";
  @SerializedName(SERIALIZED_NAME_DATA)
  private Map<String, Object> data = new HashMap<>();

  public static final String SERIALIZED_NAME_DELETED = "deleted";
  @SerializedName(SERIALIZED_NAME_DELETED)
  private Boolean deleted;

  public static final String SERIALIZED_NAME_END_TIME = "endTime";
  @SerializedName(SERIALIZED_NAME_END_TIME)
  private String endTime;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private AlertMetadata metadata;

  public static final String SERIALIZED_NAME_SECURITY_INVESTIGATION_TOOL_LINK = "securityInvestigationToolLink";
  @SerializedName(SERIALIZED_NAME_SECURITY_INVESTIGATION_TOOL_LINK)
  private String securityInvestigationToolLink;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private String source;

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private String startTime;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public Alert() {
  }

  public Alert alertId(String alertId) {
    this.alertId = alertId;
    return this;
  }

  /**
   * Output only. The unique identifier for the alert.
   * @return alertId
   */
  @javax.annotation.Nullable
  public String getAlertId() {
    return alertId;
  }

  public void setAlertId(String alertId) {
    this.alertId = alertId;
  }


  public Alert createTime(String createTime) {
    this.createTime = createTime;
    return this;
  }

  /**
   * Output only. The time this alert was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }

  public void setCreateTime(String createTime) {
    this.createTime = createTime;
  }


  public Alert customerId(String customerId) {
    this.customerId = customerId;
    return this;
  }

  /**
   * Output only. The unique identifier of the Google Workspace account of the customer.
   * @return customerId
   */
  @javax.annotation.Nullable
  public String getCustomerId() {
    return customerId;
  }

  public void setCustomerId(String customerId) {
    this.customerId = customerId;
  }


  public Alert data(Map<String, Object> data) {
    this.data = data;
    return this;
  }

  public Alert putDataItem(String key, Object dataItem) {
    if (this.data == null) {
      this.data = new HashMap<>();
    }
    this.data.put(key, dataItem);
    return this;
  }

  /**
   * Optional. The data associated with this alert, for example google.apps.alertcenter.type.DeviceCompromised.
   * @return data
   */
  @javax.annotation.Nullable
  public Map<String, Object> getData() {
    return data;
  }

  public void setData(Map<String, Object> data) {
    this.data = data;
  }


  public Alert deleted(Boolean deleted) {
    this.deleted = deleted;
    return this;
  }

  /**
   * Output only. &#x60;True&#x60; if this alert is marked for deletion.
   * @return deleted
   */
  @javax.annotation.Nullable
  public Boolean getDeleted() {
    return deleted;
  }

  public void setDeleted(Boolean deleted) {
    this.deleted = deleted;
  }


  public Alert endTime(String endTime) {
    this.endTime = endTime;
    return this;
  }

  /**
   * Optional. The time the event that caused this alert ceased being active. If provided, the end time must not be earlier than the start time. If not provided, it indicates an ongoing alert.
   * @return endTime
   */
  @javax.annotation.Nullable
  public String getEndTime() {
    return endTime;
  }

  public void setEndTime(String endTime) {
    this.endTime = endTime;
  }


  public Alert etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * Optional. &#x60;etag&#x60; is used for optimistic concurrency control as a way to help prevent simultaneous updates of an alert from overwriting each other. It is strongly suggested that systems make use of the &#x60;etag&#x60; in the read-modify-write cycle to perform alert updates in order to avoid race conditions: An &#x60;etag&#x60; is returned in the response which contains alerts, and systems are expected to put that etag in the request to update alert to ensure that their change will be applied to the same version of the alert. If no &#x60;etag&#x60; is provided in the call to update alert, then the existing alert is overwritten blindly.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public Alert metadata(AlertMetadata metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Get metadata
   * @return metadata
   */
  @javax.annotation.Nullable
  public AlertMetadata getMetadata() {
    return metadata;
  }

  public void setMetadata(AlertMetadata metadata) {
    this.metadata = metadata;
  }


  public Alert securityInvestigationToolLink(String securityInvestigationToolLink) {
    this.securityInvestigationToolLink = securityInvestigationToolLink;
    return this;
  }

  /**
   * Output only. An optional [Security Investigation Tool](https://support.google.com/a/answer/7575955) query for this alert.
   * @return securityInvestigationToolLink
   */
  @javax.annotation.Nullable
  public String getSecurityInvestigationToolLink() {
    return securityInvestigationToolLink;
  }

  public void setSecurityInvestigationToolLink(String securityInvestigationToolLink) {
    this.securityInvestigationToolLink = securityInvestigationToolLink;
  }


  public Alert source(String source) {
    this.source = source;
    return this;
  }

  /**
   * Required. A unique identifier for the system that reported the alert. This is output only after alert is created. Supported sources are any of the following: * Google Operations * Mobile device management * Gmail phishing * Data Loss Prevention * Domain wide takeout * State sponsored attack * Google identity * Apps outage
   * @return source
   */
  @javax.annotation.Nullable
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }


  public Alert startTime(String startTime) {
    this.startTime = startTime;
    return this;
  }

  /**
   * Required. The time the event that caused this alert was started or detected.
   * @return startTime
   */
  @javax.annotation.Nullable
  public String getStartTime() {
    return startTime;
  }

  public void setStartTime(String startTime) {
    this.startTime = startTime;
  }


  public Alert type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Required. The type of the alert. This is output only after alert is created. For a list of available alert types see [Google Workspace Alert types](https://developers.google.com/admin-sdk/alertcenter/reference/alert-types).
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }


  public Alert updateTime(String updateTime) {
    this.updateTime = updateTime;
    return this;
  }

  /**
   * Output only. The time this alert was last updated.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }

  public void setUpdateTime(String updateTime) {
    this.updateTime = updateTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Alert alert = (Alert) o;
    return Objects.equals(this.alertId, alert.alertId) &&
        Objects.equals(this.createTime, alert.createTime) &&
        Objects.equals(this.customerId, alert.customerId) &&
        Objects.equals(this.data, alert.data) &&
        Objects.equals(this.deleted, alert.deleted) &&
        Objects.equals(this.endTime, alert.endTime) &&
        Objects.equals(this.etag, alert.etag) &&
        Objects.equals(this.metadata, alert.metadata) &&
        Objects.equals(this.securityInvestigationToolLink, alert.securityInvestigationToolLink) &&
        Objects.equals(this.source, alert.source) &&
        Objects.equals(this.startTime, alert.startTime) &&
        Objects.equals(this.type, alert.type) &&
        Objects.equals(this.updateTime, alert.updateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alertId, createTime, customerId, data, deleted, endTime, etag, metadata, securityInvestigationToolLink, source, startTime, type, updateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Alert {\n");
    sb.append("    alertId: ").append(toIndentedString(alertId)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    customerId: ").append(toIndentedString(customerId)).append("\n");
    sb.append("    data: ").append(toIndentedString(data)).append("\n");
    sb.append("    deleted: ").append(toIndentedString(deleted)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    securityInvestigationToolLink: ").append(toIndentedString(securityInvestigationToolLink)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alertId");
    openapiFields.add("createTime");
    openapiFields.add("customerId");
    openapiFields.add("data");
    openapiFields.add("deleted");
    openapiFields.add("endTime");
    openapiFields.add("etag");
    openapiFields.add("metadata");
    openapiFields.add("securityInvestigationToolLink");
    openapiFields.add("source");
    openapiFields.add("startTime");
    openapiFields.add("type");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Alert
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Alert.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Alert is not found in the empty JSON string", Alert.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Alert.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Alert` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("alertId") != null && !jsonObj.get("alertId").isJsonNull()) && !jsonObj.get("alertId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `alertId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("alertId").toString()));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("customerId") != null && !jsonObj.get("customerId").isJsonNull()) && !jsonObj.get("customerId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customerId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customerId").toString()));
      }
      if ((jsonObj.get("endTime") != null && !jsonObj.get("endTime").isJsonNull()) && !jsonObj.get("endTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endTime").toString()));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      // validate the optional field `metadata`
      if (jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) {
        AlertMetadata.validateJsonElement(jsonObj.get("metadata"));
      }
      if ((jsonObj.get("securityInvestigationToolLink") != null && !jsonObj.get("securityInvestigationToolLink").isJsonNull()) && !jsonObj.get("securityInvestigationToolLink").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `securityInvestigationToolLink` to be a primitive type in the JSON string but got `%s`", jsonObj.get("securityInvestigationToolLink").toString()));
      }
      if ((jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull()) && !jsonObj.get("source").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `source` to be a primitive type in the JSON string but got `%s`", jsonObj.get("source").toString()));
      }
      if ((jsonObj.get("startTime") != null && !jsonObj.get("startTime").isJsonNull()) && !jsonObj.get("startTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `startTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("startTime").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Alert.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Alert' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Alert> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Alert.class));

       return (TypeAdapter<T>) new TypeAdapter<Alert>() {
           @Override
           public void write(JsonWriter out, Alert value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Alert read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Alert given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Alert
   * @throws IOException if the JSON string is invalid with respect to Alert
   */
  public static Alert fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Alert.class);
  }

  /**
   * Convert an instance of Alert to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

