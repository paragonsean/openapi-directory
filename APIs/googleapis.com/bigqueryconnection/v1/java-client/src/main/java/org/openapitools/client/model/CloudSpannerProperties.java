/*
 * BigQuery Connection API
 * Allows users to manage BigQuery connections to external data sources.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Connection properties specific to Cloud Spanner.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:36:12.015205-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CloudSpannerProperties {
  public static final String SERIALIZED_NAME_DATABASE = "database";
  @SerializedName(SERIALIZED_NAME_DATABASE)
  private String database;

  public static final String SERIALIZED_NAME_DATABASE_ROLE = "databaseRole";
  @SerializedName(SERIALIZED_NAME_DATABASE_ROLE)
  private String databaseRole;

  public static final String SERIALIZED_NAME_MAX_PARALLELISM = "maxParallelism";
  @SerializedName(SERIALIZED_NAME_MAX_PARALLELISM)
  private Integer maxParallelism;

  public static final String SERIALIZED_NAME_USE_DATA_BOOST = "useDataBoost";
  @SerializedName(SERIALIZED_NAME_USE_DATA_BOOST)
  private Boolean useDataBoost;

  public static final String SERIALIZED_NAME_USE_PARALLELISM = "useParallelism";
  @SerializedName(SERIALIZED_NAME_USE_PARALLELISM)
  private Boolean useParallelism;

  public static final String SERIALIZED_NAME_USE_SERVERLESS_ANALYTICS = "useServerlessAnalytics";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_USE_SERVERLESS_ANALYTICS)
  private Boolean useServerlessAnalytics;

  public CloudSpannerProperties() {
  }

  public CloudSpannerProperties database(String database) {
    this.database = database;
    return this;
  }

  /**
   * Cloud Spanner database in the form &#x60;project/instance/database&#39;
   * @return database
   */
  @javax.annotation.Nullable
  public String getDatabase() {
    return database;
  }

  public void setDatabase(String database) {
    this.database = database;
  }


  public CloudSpannerProperties databaseRole(String databaseRole) {
    this.databaseRole = databaseRole;
    return this;
  }

  /**
   * Optional. Cloud Spanner database role for fine-grained access control. The Cloud Spanner admin should have provisioned the database role with appropriate permissions, such as &#x60;SELECT&#x60; and &#x60;INSERT&#x60;. Other users should only use roles provided by their Cloud Spanner admins. For more details, see [About fine-grained access control] (https://cloud.google.com/spanner/docs/fgac-about). REQUIRES: The database role name must start with a letter, and can only contain letters, numbers, and underscores.
   * @return databaseRole
   */
  @javax.annotation.Nullable
  public String getDatabaseRole() {
    return databaseRole;
  }

  public void setDatabaseRole(String databaseRole) {
    this.databaseRole = databaseRole;
  }


  public CloudSpannerProperties maxParallelism(Integer maxParallelism) {
    this.maxParallelism = maxParallelism;
    return this;
  }

  /**
   * Allows setting max parallelism per query when executing on Spanner independent compute resources. If unspecified, default values of parallelism are chosen that are dependent on the Cloud Spanner instance configuration. REQUIRES: &#x60;use_parallelism&#x60; must be set. REQUIRES: &#x60;use_data_boost&#x60; must be set.
   * @return maxParallelism
   */
  @javax.annotation.Nullable
  public Integer getMaxParallelism() {
    return maxParallelism;
  }

  public void setMaxParallelism(Integer maxParallelism) {
    this.maxParallelism = maxParallelism;
  }


  public CloudSpannerProperties useDataBoost(Boolean useDataBoost) {
    this.useDataBoost = useDataBoost;
    return this;
  }

  /**
   * If set, the request will be executed via Spanner independent compute resources. REQUIRES: &#x60;use_parallelism&#x60; must be set.
   * @return useDataBoost
   */
  @javax.annotation.Nullable
  public Boolean getUseDataBoost() {
    return useDataBoost;
  }

  public void setUseDataBoost(Boolean useDataBoost) {
    this.useDataBoost = useDataBoost;
  }


  public CloudSpannerProperties useParallelism(Boolean useParallelism) {
    this.useParallelism = useParallelism;
    return this;
  }

  /**
   * If parallelism should be used when reading from Cloud Spanner
   * @return useParallelism
   */
  @javax.annotation.Nullable
  public Boolean getUseParallelism() {
    return useParallelism;
  }

  public void setUseParallelism(Boolean useParallelism) {
    this.useParallelism = useParallelism;
  }


  @Deprecated
  public CloudSpannerProperties useServerlessAnalytics(Boolean useServerlessAnalytics) {
    this.useServerlessAnalytics = useServerlessAnalytics;
    return this;
  }

  /**
   * Deprecated: prefer use_data_boost instead. If the serverless analytics service should be used to read data from Cloud Spanner. Note: &#x60;use_parallelism&#x60; must be set when using serverless analytics.
   * @return useServerlessAnalytics
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getUseServerlessAnalytics() {
    return useServerlessAnalytics;
  }

  @Deprecated
  public void setUseServerlessAnalytics(Boolean useServerlessAnalytics) {
    this.useServerlessAnalytics = useServerlessAnalytics;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CloudSpannerProperties cloudSpannerProperties = (CloudSpannerProperties) o;
    return Objects.equals(this.database, cloudSpannerProperties.database) &&
        Objects.equals(this.databaseRole, cloudSpannerProperties.databaseRole) &&
        Objects.equals(this.maxParallelism, cloudSpannerProperties.maxParallelism) &&
        Objects.equals(this.useDataBoost, cloudSpannerProperties.useDataBoost) &&
        Objects.equals(this.useParallelism, cloudSpannerProperties.useParallelism) &&
        Objects.equals(this.useServerlessAnalytics, cloudSpannerProperties.useServerlessAnalytics);
  }

  @Override
  public int hashCode() {
    return Objects.hash(database, databaseRole, maxParallelism, useDataBoost, useParallelism, useServerlessAnalytics);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CloudSpannerProperties {\n");
    sb.append("    database: ").append(toIndentedString(database)).append("\n");
    sb.append("    databaseRole: ").append(toIndentedString(databaseRole)).append("\n");
    sb.append("    maxParallelism: ").append(toIndentedString(maxParallelism)).append("\n");
    sb.append("    useDataBoost: ").append(toIndentedString(useDataBoost)).append("\n");
    sb.append("    useParallelism: ").append(toIndentedString(useParallelism)).append("\n");
    sb.append("    useServerlessAnalytics: ").append(toIndentedString(useServerlessAnalytics)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("database");
    openapiFields.add("databaseRole");
    openapiFields.add("maxParallelism");
    openapiFields.add("useDataBoost");
    openapiFields.add("useParallelism");
    openapiFields.add("useServerlessAnalytics");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CloudSpannerProperties
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CloudSpannerProperties.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CloudSpannerProperties is not found in the empty JSON string", CloudSpannerProperties.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CloudSpannerProperties.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CloudSpannerProperties` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("database") != null && !jsonObj.get("database").isJsonNull()) && !jsonObj.get("database").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `database` to be a primitive type in the JSON string but got `%s`", jsonObj.get("database").toString()));
      }
      if ((jsonObj.get("databaseRole") != null && !jsonObj.get("databaseRole").isJsonNull()) && !jsonObj.get("databaseRole").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `databaseRole` to be a primitive type in the JSON string but got `%s`", jsonObj.get("databaseRole").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CloudSpannerProperties.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CloudSpannerProperties' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CloudSpannerProperties> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CloudSpannerProperties.class));

       return (TypeAdapter<T>) new TypeAdapter<CloudSpannerProperties>() {
           @Override
           public void write(JsonWriter out, CloudSpannerProperties value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CloudSpannerProperties read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CloudSpannerProperties given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CloudSpannerProperties
   * @throws IOException if the JSON string is invalid with respect to CloudSpannerProperties
   */
  public static CloudSpannerProperties fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CloudSpannerProperties.class);
  }

  /**
   * Convert an instance of CloudSpannerProperties to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

