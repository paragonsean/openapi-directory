/**
 * Service Networking API
 * Provides automatic management of network configurations necessary for certain services.
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The Mixin model module.
 * @module model/Mixin
 * @version v1beta
 */
class Mixin {
    /**
     * Constructs a new <code>Mixin</code>.
     * Declares an API Interface to be included in this interface. The including interface must redeclare all the methods from the included interface, but documentation and options are inherited as follows: - If after comment and whitespace stripping, the documentation string of the redeclared method is empty, it will be inherited from the original method. - Each annotation belonging to the service config (http, visibility) which is not set in the redeclared method will be inherited. - If an http annotation is inherited, the path pattern will be modified as follows. Any version prefix will be replaced by the version of the including interface plus the root path if specified. Example of a simple mixin: package google.acl.v1; service AccessControl { // Get the underlying ACL object. rpc GetAcl(GetAclRequest) returns (Acl) { option (google.api.http).get &#x3D; \&quot;/v1/{resource&#x3D;**}:getAcl\&quot;; } } package google.storage.v2; service Storage { // rpc GetAcl(GetAclRequest) returns (Acl); // Get a data record. rpc GetData(GetDataRequest) returns (Data) { option (google.api.http).get &#x3D; \&quot;/v2/{resource&#x3D;**}\&quot;; } } Example of a mixin configuration: apis: - name: google.storage.v2.Storage mixins: - name: google.acl.v1.AccessControl The mixin construct implies that all methods in &#x60;AccessControl&#x60; are also declared with same name and request/response types in &#x60;Storage&#x60;. A documentation generator or annotation processor will see the effective &#x60;Storage.GetAcl&#x60; method after inherting documentation and annotations as follows: service Storage { // Get the underlying ACL object. rpc GetAcl(GetAclRequest) returns (Acl) { option (google.api.http).get &#x3D; \&quot;/v2/{resource&#x3D;**}:getAcl\&quot;; } ... } Note how the version in the path pattern changed from &#x60;v1&#x60; to &#x60;v2&#x60;. If the &#x60;root&#x60; field in the mixin is specified, it should be a relative path under which inherited HTTP paths are placed. Example: apis: - name: google.storage.v2.Storage mixins: - name: google.acl.v1.AccessControl root: acls This implies the following inherited HTTP annotation: service Storage { // Get the underlying ACL object. rpc GetAcl(GetAclRequest) returns (Acl) { option (google.api.http).get &#x3D; \&quot;/v2/acls/{resource&#x3D;**}:getAcl\&quot;; } ... }
     * @alias module:model/Mixin
     */
    constructor() { 
        
        Mixin.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Mixin</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Mixin} obj Optional instance to populate.
     * @return {module:model/Mixin} The populated <code>Mixin</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Mixin();

            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('root')) {
                obj['root'] = ApiClient.convertToType(data['root'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Mixin</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Mixin</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // ensure the json data is a string
        if (data['root'] && !(typeof data['root'] === 'string' || data['root'] instanceof String)) {
            throw new Error("Expected the field `root` to be a primitive type in the JSON string but got " + data['root']);
        }

        return true;
    }


}



/**
 * The fully qualified name of the interface which is included.
 * @member {String} name
 */
Mixin.prototype['name'] = undefined;

/**
 * If non-empty specifies a path under which inherited HTTP paths are rooted.
 * @member {String} root
 */
Mixin.prototype['root'] = undefined;






export default Mixin;

