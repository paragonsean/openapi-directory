# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.subnetwork import Subnetwork
from openapi_server import util


class RangeReservation(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, ip_prefix_length: int=None, requested_ranges: List[str]=None, secondary_range_ip_prefix_lengths: List[int]=None, subnetwork_candidates: List[Subnetwork]=None):
        """RangeReservation - a model defined in OpenAPI

        :param ip_prefix_length: The ip_prefix_length of this RangeReservation.
        :param requested_ranges: The requested_ranges of this RangeReservation.
        :param secondary_range_ip_prefix_lengths: The secondary_range_ip_prefix_lengths of this RangeReservation.
        :param subnetwork_candidates: The subnetwork_candidates of this RangeReservation.
        """
        self.openapi_types = {
            'ip_prefix_length': int,
            'requested_ranges': List[str],
            'secondary_range_ip_prefix_lengths': List[int],
            'subnetwork_candidates': List[Subnetwork]
        }

        self.attribute_map = {
            'ip_prefix_length': 'ipPrefixLength',
            'requested_ranges': 'requestedRanges',
            'secondary_range_ip_prefix_lengths': 'secondaryRangeIpPrefixLengths',
            'subnetwork_candidates': 'subnetworkCandidates'
        }

        self._ip_prefix_length = ip_prefix_length
        self._requested_ranges = requested_ranges
        self._secondary_range_ip_prefix_lengths = secondary_range_ip_prefix_lengths
        self._subnetwork_candidates = subnetwork_candidates

    @classmethod
    def from_dict(cls, dikt: dict) -> 'RangeReservation':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The RangeReservation of this RangeReservation.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def ip_prefix_length(self):
        """Gets the ip_prefix_length of this RangeReservation.

        Required. The size of the desired subnet. Use usual CIDR range notation. For example, '29' to find unused x.x.x.x/29 CIDR range. The goal is to determine if one of the allocated ranges has enough free space for a subnet of the requested size. GCE disallows subnets with prefix_length > 29

        :return: The ip_prefix_length of this RangeReservation.
        :rtype: int
        """
        return self._ip_prefix_length

    @ip_prefix_length.setter
    def ip_prefix_length(self, ip_prefix_length):
        """Sets the ip_prefix_length of this RangeReservation.

        Required. The size of the desired subnet. Use usual CIDR range notation. For example, '29' to find unused x.x.x.x/29 CIDR range. The goal is to determine if one of the allocated ranges has enough free space for a subnet of the requested size. GCE disallows subnets with prefix_length > 29

        :param ip_prefix_length: The ip_prefix_length of this RangeReservation.
        :type ip_prefix_length: int
        """

        self._ip_prefix_length = ip_prefix_length

    @property
    def requested_ranges(self):
        """Gets the requested_ranges of this RangeReservation.

        Optional. The name of one or more allocated IP address ranges associated with this private service access connection. If no range names are provided all ranges associated with this connection will be considered. If a CIDR range with the specified IP prefix length is not available within these ranges the validation fails.

        :return: The requested_ranges of this RangeReservation.
        :rtype: List[str]
        """
        return self._requested_ranges

    @requested_ranges.setter
    def requested_ranges(self, requested_ranges):
        """Sets the requested_ranges of this RangeReservation.

        Optional. The name of one or more allocated IP address ranges associated with this private service access connection. If no range names are provided all ranges associated with this connection will be considered. If a CIDR range with the specified IP prefix length is not available within these ranges the validation fails.

        :param requested_ranges: The requested_ranges of this RangeReservation.
        :type requested_ranges: List[str]
        """

        self._requested_ranges = requested_ranges

    @property
    def secondary_range_ip_prefix_lengths(self):
        """Gets the secondary_range_ip_prefix_lengths of this RangeReservation.

        Optional. The size of the desired secondary ranges for the subnet. Use usual CIDR range notation. For example, '29' to find unused x.x.x.x/29 CIDR range. The goal is to determine that the allocated ranges have enough free space for all the requested secondary ranges. GCE disallows subnets with prefix_length > 29

        :return: The secondary_range_ip_prefix_lengths of this RangeReservation.
        :rtype: List[int]
        """
        return self._secondary_range_ip_prefix_lengths

    @secondary_range_ip_prefix_lengths.setter
    def secondary_range_ip_prefix_lengths(self, secondary_range_ip_prefix_lengths):
        """Sets the secondary_range_ip_prefix_lengths of this RangeReservation.

        Optional. The size of the desired secondary ranges for the subnet. Use usual CIDR range notation. For example, '29' to find unused x.x.x.x/29 CIDR range. The goal is to determine that the allocated ranges have enough free space for all the requested secondary ranges. GCE disallows subnets with prefix_length > 29

        :param secondary_range_ip_prefix_lengths: The secondary_range_ip_prefix_lengths of this RangeReservation.
        :type secondary_range_ip_prefix_lengths: List[int]
        """

        self._secondary_range_ip_prefix_lengths = secondary_range_ip_prefix_lengths

    @property
    def subnetwork_candidates(self):
        """Gets the subnetwork_candidates of this RangeReservation.

        Optional. List of subnetwork candidates to validate. The required input fields are `name`, `network`, and `region`. Subnetworks from this list which exist will be returned in the response with the `ip_cidr_range`, `secondary_ip_cider_ranges`, and `outside_allocation` fields set.

        :return: The subnetwork_candidates of this RangeReservation.
        :rtype: List[Subnetwork]
        """
        return self._subnetwork_candidates

    @subnetwork_candidates.setter
    def subnetwork_candidates(self, subnetwork_candidates):
        """Sets the subnetwork_candidates of this RangeReservation.

        Optional. List of subnetwork candidates to validate. The required input fields are `name`, `network`, and `region`. Subnetworks from this list which exist will be returned in the response with the `ip_cidr_range`, `secondary_ip_cider_ranges`, and `outside_allocation` fields set.

        :param subnetwork_candidates: The subnetwork_candidates of this RangeReservation.
        :type subnetwork_candidates: List[Subnetwork]
        """

        self._subnetwork_candidates = subnetwork_candidates
