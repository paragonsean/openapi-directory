/*
 * Service Networking API
 * Provides automatic management of network configurations necessary for certain services.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * SecondaryIpRangeSpec
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:16.869716-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SecondaryIpRangeSpec {
  public static final String SERIALIZED_NAME_IP_PREFIX_LENGTH = "ipPrefixLength";
  @SerializedName(SERIALIZED_NAME_IP_PREFIX_LENGTH)
  private Integer ipPrefixLength;

  public static final String SERIALIZED_NAME_OUTSIDE_ALLOCATION_PUBLIC_IP_RANGE = "outsideAllocationPublicIpRange";
  @SerializedName(SERIALIZED_NAME_OUTSIDE_ALLOCATION_PUBLIC_IP_RANGE)
  private String outsideAllocationPublicIpRange;

  public static final String SERIALIZED_NAME_RANGE_NAME = "rangeName";
  @SerializedName(SERIALIZED_NAME_RANGE_NAME)
  private String rangeName;

  public static final String SERIALIZED_NAME_REQUESTED_ADDRESS = "requestedAddress";
  @SerializedName(SERIALIZED_NAME_REQUESTED_ADDRESS)
  private String requestedAddress;

  public SecondaryIpRangeSpec() {
  }

  public SecondaryIpRangeSpec ipPrefixLength(Integer ipPrefixLength) {
    this.ipPrefixLength = ipPrefixLength;
    return this;
  }

  /**
   * Required. The prefix length of the secondary IP range. Use CIDR range notation, such as &#x60;30&#x60; to provision a secondary IP range with an &#x60;x.x.x.x/30&#x60; CIDR range. The IP address range is drawn from a pool of available ranges in the service consumer&#39;s allocated range.
   * @return ipPrefixLength
   */
  @javax.annotation.Nullable
  public Integer getIpPrefixLength() {
    return ipPrefixLength;
  }

  public void setIpPrefixLength(Integer ipPrefixLength) {
    this.ipPrefixLength = ipPrefixLength;
  }


  public SecondaryIpRangeSpec outsideAllocationPublicIpRange(String outsideAllocationPublicIpRange) {
    this.outsideAllocationPublicIpRange = outsideAllocationPublicIpRange;
    return this;
  }

  /**
   * Optional. Enable outside allocation using public IP addresses. Any public IP range may be specified. If this field is provided, we will not use customer reserved ranges for this secondary IP range.
   * @return outsideAllocationPublicIpRange
   */
  @javax.annotation.Nullable
  public String getOutsideAllocationPublicIpRange() {
    return outsideAllocationPublicIpRange;
  }

  public void setOutsideAllocationPublicIpRange(String outsideAllocationPublicIpRange) {
    this.outsideAllocationPublicIpRange = outsideAllocationPublicIpRange;
  }


  public SecondaryIpRangeSpec rangeName(String rangeName) {
    this.rangeName = rangeName;
    return this;
  }

  /**
   * Required. A name for the secondary IP range. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the subnetwork.
   * @return rangeName
   */
  @javax.annotation.Nullable
  public String getRangeName() {
    return rangeName;
  }

  public void setRangeName(String rangeName) {
    this.rangeName = rangeName;
  }


  public SecondaryIpRangeSpec requestedAddress(String requestedAddress) {
    this.requestedAddress = requestedAddress;
    return this;
  }

  /**
   * Optional. The starting address of a range. The address must be a valid IPv4 address in the x.x.x.x format. This value combined with the IP prefix range is the CIDR range for the secondary IP range. The range must be within the allocated range that is assigned to the private connection. If the CIDR range isn&#39;t available, the call fails.
   * @return requestedAddress
   */
  @javax.annotation.Nullable
  public String getRequestedAddress() {
    return requestedAddress;
  }

  public void setRequestedAddress(String requestedAddress) {
    this.requestedAddress = requestedAddress;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SecondaryIpRangeSpec secondaryIpRangeSpec = (SecondaryIpRangeSpec) o;
    return Objects.equals(this.ipPrefixLength, secondaryIpRangeSpec.ipPrefixLength) &&
        Objects.equals(this.outsideAllocationPublicIpRange, secondaryIpRangeSpec.outsideAllocationPublicIpRange) &&
        Objects.equals(this.rangeName, secondaryIpRangeSpec.rangeName) &&
        Objects.equals(this.requestedAddress, secondaryIpRangeSpec.requestedAddress);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ipPrefixLength, outsideAllocationPublicIpRange, rangeName, requestedAddress);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SecondaryIpRangeSpec {\n");
    sb.append("    ipPrefixLength: ").append(toIndentedString(ipPrefixLength)).append("\n");
    sb.append("    outsideAllocationPublicIpRange: ").append(toIndentedString(outsideAllocationPublicIpRange)).append("\n");
    sb.append("    rangeName: ").append(toIndentedString(rangeName)).append("\n");
    sb.append("    requestedAddress: ").append(toIndentedString(requestedAddress)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ipPrefixLength");
    openapiFields.add("outsideAllocationPublicIpRange");
    openapiFields.add("rangeName");
    openapiFields.add("requestedAddress");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SecondaryIpRangeSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SecondaryIpRangeSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SecondaryIpRangeSpec is not found in the empty JSON string", SecondaryIpRangeSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SecondaryIpRangeSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SecondaryIpRangeSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("outsideAllocationPublicIpRange") != null && !jsonObj.get("outsideAllocationPublicIpRange").isJsonNull()) && !jsonObj.get("outsideAllocationPublicIpRange").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outsideAllocationPublicIpRange` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outsideAllocationPublicIpRange").toString()));
      }
      if ((jsonObj.get("rangeName") != null && !jsonObj.get("rangeName").isJsonNull()) && !jsonObj.get("rangeName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rangeName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rangeName").toString()));
      }
      if ((jsonObj.get("requestedAddress") != null && !jsonObj.get("requestedAddress").isJsonNull()) && !jsonObj.get("requestedAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestedAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestedAddress").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SecondaryIpRangeSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SecondaryIpRangeSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SecondaryIpRangeSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SecondaryIpRangeSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<SecondaryIpRangeSpec>() {
           @Override
           public void write(JsonWriter out, SecondaryIpRangeSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SecondaryIpRangeSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SecondaryIpRangeSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SecondaryIpRangeSpec
   * @throws IOException if the JSON string is invalid with respect to SecondaryIpRangeSpec
   */
  public static SecondaryIpRangeSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SecondaryIpRangeSpec.class);
  }

  /**
   * Convert an instance of SecondaryIpRangeSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

