/*
 * Service Networking API
 * Provides automatic management of network configurations necessary for certain services.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents a private connection resource. A private connection is implemented as a VPC Network Peering connection between a service producer&#39;s VPC network and a service consumer&#39;s VPC network.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:16.869716-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Connection {
  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_PEERING = "peering";
  @SerializedName(SERIALIZED_NAME_PEERING)
  private String peering;

  public static final String SERIALIZED_NAME_RESERVED_PEERING_RANGES = "reservedPeeringRanges";
  @SerializedName(SERIALIZED_NAME_RESERVED_PEERING_RANGES)
  private List<String> reservedPeeringRanges = new ArrayList<>();

  public static final String SERIALIZED_NAME_SERVICE = "service";
  @SerializedName(SERIALIZED_NAME_SERVICE)
  private String service;

  public Connection() {
  }

  public Connection(
     String peering, 
     String service
  ) {
    this();
    this.peering = peering;
    this.service = service;
  }

  public Connection network(String network) {
    this.network = network;
    return this;
  }

  /**
   * The name of service consumer&#39;s VPC network that&#39;s connected with service producer network, in the following format: &#x60;projects/{project}/global/networks/{network}&#x60;. &#x60;{project}&#x60; is a project number, such as in &#x60;12345&#x60; that includes the VPC service consumer&#39;s VPC network. &#x60;{network}&#x60; is the name of the service consumer&#39;s VPC network.
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  /**
   * Output only. The name of the VPC Network Peering connection that was created by the service producer.
   * @return peering
   */
  @javax.annotation.Nullable
  public String getPeering() {
    return peering;
  }



  public Connection reservedPeeringRanges(List<String> reservedPeeringRanges) {
    this.reservedPeeringRanges = reservedPeeringRanges;
    return this;
  }

  public Connection addReservedPeeringRangesItem(String reservedPeeringRangesItem) {
    if (this.reservedPeeringRanges == null) {
      this.reservedPeeringRanges = new ArrayList<>();
    }
    this.reservedPeeringRanges.add(reservedPeeringRangesItem);
    return this;
  }

  /**
   * The name of one or more allocated IP address ranges for this service producer of type &#x60;PEERING&#x60;. Note that invoking CreateConnection method with a different range when connection is already established will not modify already provisioned service producer subnetworks. If CreateConnection method is invoked repeatedly to reconnect when peering connection had been disconnected on the consumer side, leaving this field empty will restore previously allocated IP ranges.
   * @return reservedPeeringRanges
   */
  @javax.annotation.Nullable
  public List<String> getReservedPeeringRanges() {
    return reservedPeeringRanges;
  }

  public void setReservedPeeringRanges(List<String> reservedPeeringRanges) {
    this.reservedPeeringRanges = reservedPeeringRanges;
  }


  /**
   * Output only. The name of the peering service that&#39;s associated with this connection, in the following format: &#x60;services/{service name}&#x60;.
   * @return service
   */
  @javax.annotation.Nullable
  public String getService() {
    return service;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Connection connection = (Connection) o;
    return Objects.equals(this.network, connection.network) &&
        Objects.equals(this.peering, connection.peering) &&
        Objects.equals(this.reservedPeeringRanges, connection.reservedPeeringRanges) &&
        Objects.equals(this.service, connection.service);
  }

  @Override
  public int hashCode() {
    return Objects.hash(network, peering, reservedPeeringRanges, service);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Connection {\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    peering: ").append(toIndentedString(peering)).append("\n");
    sb.append("    reservedPeeringRanges: ").append(toIndentedString(reservedPeeringRanges)).append("\n");
    sb.append("    service: ").append(toIndentedString(service)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("network");
    openapiFields.add("peering");
    openapiFields.add("reservedPeeringRanges");
    openapiFields.add("service");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Connection
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Connection.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Connection is not found in the empty JSON string", Connection.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Connection.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Connection` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      if ((jsonObj.get("peering") != null && !jsonObj.get("peering").isJsonNull()) && !jsonObj.get("peering").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `peering` to be a primitive type in the JSON string but got `%s`", jsonObj.get("peering").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("reservedPeeringRanges") != null && !jsonObj.get("reservedPeeringRanges").isJsonNull() && !jsonObj.get("reservedPeeringRanges").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `reservedPeeringRanges` to be an array in the JSON string but got `%s`", jsonObj.get("reservedPeeringRanges").toString()));
      }
      if ((jsonObj.get("service") != null && !jsonObj.get("service").isJsonNull()) && !jsonObj.get("service").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `service` to be a primitive type in the JSON string but got `%s`", jsonObj.get("service").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Connection.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Connection' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Connection> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Connection.class));

       return (TypeAdapter<T>) new TypeAdapter<Connection>() {
           @Override
           public void write(JsonWriter out, Connection value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Connection read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Connection given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Connection
   * @throws IOException if the JSON string is invalid with respect to Connection
   */
  public static Connection fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Connection.class);
  }

  /**
   * Convert an instance of Connection to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

