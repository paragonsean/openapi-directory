/*
 * Service Networking API
 * Provides automatic management of network configurations necessary for certain services.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.SecondaryIpRangeSpec;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Request to create a subnetwork in a previously peered service network.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:16.869716-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AddSubnetworkRequest {
  public static final String SERIALIZED_NAME_ALLOW_SUBNET_CIDR_ROUTES_OVERLAP = "allowSubnetCidrRoutesOverlap";
  @SerializedName(SERIALIZED_NAME_ALLOW_SUBNET_CIDR_ROUTES_OVERLAP)
  private Boolean allowSubnetCidrRoutesOverlap;

  public static final String SERIALIZED_NAME_CHECK_SERVICE_NETWORKING_USE_PERMISSION = "checkServiceNetworkingUsePermission";
  @SerializedName(SERIALIZED_NAME_CHECK_SERVICE_NETWORKING_USE_PERMISSION)
  private Boolean checkServiceNetworkingUsePermission;

  public static final String SERIALIZED_NAME_COMPUTE_IDEMPOTENCY_WINDOW = "computeIdempotencyWindow";
  @SerializedName(SERIALIZED_NAME_COMPUTE_IDEMPOTENCY_WINDOW)
  private String computeIdempotencyWindow;

  public static final String SERIALIZED_NAME_CONSUMER = "consumer";
  @SerializedName(SERIALIZED_NAME_CONSUMER)
  private String consumer;

  public static final String SERIALIZED_NAME_CONSUMER_NETWORK = "consumerNetwork";
  @SerializedName(SERIALIZED_NAME_CONSUMER_NETWORK)
  private String consumerNetwork;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_INTERNAL_RANGE = "internalRange";
  @SerializedName(SERIALIZED_NAME_INTERNAL_RANGE)
  private String internalRange;

  public static final String SERIALIZED_NAME_IP_PREFIX_LENGTH = "ipPrefixLength";
  @SerializedName(SERIALIZED_NAME_IP_PREFIX_LENGTH)
  private Integer ipPrefixLength;

  public static final String SERIALIZED_NAME_OUTSIDE_ALLOCATION_PUBLIC_IP_RANGE = "outsideAllocationPublicIpRange";
  @SerializedName(SERIALIZED_NAME_OUTSIDE_ALLOCATION_PUBLIC_IP_RANGE)
  private String outsideAllocationPublicIpRange;

  public static final String SERIALIZED_NAME_PRIVATE_IPV6_GOOGLE_ACCESS = "privateIpv6GoogleAccess";
  @SerializedName(SERIALIZED_NAME_PRIVATE_IPV6_GOOGLE_ACCESS)
  private String privateIpv6GoogleAccess;

  public static final String SERIALIZED_NAME_PURPOSE = "purpose";
  @SerializedName(SERIALIZED_NAME_PURPOSE)
  private String purpose;

  public static final String SERIALIZED_NAME_REGION = "region";
  @SerializedName(SERIALIZED_NAME_REGION)
  private String region;

  public static final String SERIALIZED_NAME_REQUESTED_ADDRESS = "requestedAddress";
  @SerializedName(SERIALIZED_NAME_REQUESTED_ADDRESS)
  private String requestedAddress;

  public static final String SERIALIZED_NAME_REQUESTED_RANGES = "requestedRanges";
  @SerializedName(SERIALIZED_NAME_REQUESTED_RANGES)
  private List<String> requestedRanges = new ArrayList<>();

  public static final String SERIALIZED_NAME_ROLE = "role";
  @SerializedName(SERIALIZED_NAME_ROLE)
  private String role;

  public static final String SERIALIZED_NAME_SECONDARY_IP_RANGE_SPECS = "secondaryIpRangeSpecs";
  @SerializedName(SERIALIZED_NAME_SECONDARY_IP_RANGE_SPECS)
  private List<SecondaryIpRangeSpec> secondaryIpRangeSpecs = new ArrayList<>();

  public static final String SERIALIZED_NAME_SUBNETWORK = "subnetwork";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK)
  private String subnetwork;

  public static final String SERIALIZED_NAME_SUBNETWORK_USERS = "subnetworkUsers";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK_USERS)
  private List<String> subnetworkUsers = new ArrayList<>();

  public static final String SERIALIZED_NAME_USE_CUSTOM_COMPUTE_IDEMPOTENCY_WINDOW = "useCustomComputeIdempotencyWindow";
  @SerializedName(SERIALIZED_NAME_USE_CUSTOM_COMPUTE_IDEMPOTENCY_WINDOW)
  private Boolean useCustomComputeIdempotencyWindow;

  public AddSubnetworkRequest() {
  }

  public AddSubnetworkRequest allowSubnetCidrRoutesOverlap(Boolean allowSubnetCidrRoutesOverlap) {
    this.allowSubnetCidrRoutesOverlap = allowSubnetCidrRoutesOverlap;
    return this;
  }

  /**
   * Optional. Defines the allowSubnetCidrRoutesOverlap field of the subnet, e.g. Available in alpha and beta according to [Compute API documentation](https://cloud.google.com/compute/docs/reference/rest/beta/subnetworks/insert)
   * @return allowSubnetCidrRoutesOverlap
   */
  @javax.annotation.Nullable
  public Boolean getAllowSubnetCidrRoutesOverlap() {
    return allowSubnetCidrRoutesOverlap;
  }

  public void setAllowSubnetCidrRoutesOverlap(Boolean allowSubnetCidrRoutesOverlap) {
    this.allowSubnetCidrRoutesOverlap = allowSubnetCidrRoutesOverlap;
  }


  public AddSubnetworkRequest checkServiceNetworkingUsePermission(Boolean checkServiceNetworkingUsePermission) {
    this.checkServiceNetworkingUsePermission = checkServiceNetworkingUsePermission;
    return this;
  }

  /**
   * Optional. The IAM permission check determines whether the consumer project has &#39;servicenetworking.services.use&#39; permission or not.
   * @return checkServiceNetworkingUsePermission
   */
  @javax.annotation.Nullable
  public Boolean getCheckServiceNetworkingUsePermission() {
    return checkServiceNetworkingUsePermission;
  }

  public void setCheckServiceNetworkingUsePermission(Boolean checkServiceNetworkingUsePermission) {
    this.checkServiceNetworkingUsePermission = checkServiceNetworkingUsePermission;
  }


  public AddSubnetworkRequest computeIdempotencyWindow(String computeIdempotencyWindow) {
    this.computeIdempotencyWindow = computeIdempotencyWindow;
    return this;
  }

  /**
   * Optional. Specifies a custom time bucket for Arcus subnetwork request idempotency. If two equivalent concurrent requests are made, Arcus will know to ignore the request if it has already been completed or is in progress. Only requests with matching compute_idempotency_window have guaranteed idempotency. Changing this time window between requests results in undefined behavior. Zero (or empty) value with custom_compute_idempotency_window&#x3D;true specifies no idempotency (i.e. no request ID is provided to Arcus). Maximum value of 14 days (enforced by Arcus limit). For more information on how to use, see: go/revisit-sn-idempotency-window
   * @return computeIdempotencyWindow
   */
  @javax.annotation.Nullable
  public String getComputeIdempotencyWindow() {
    return computeIdempotencyWindow;
  }

  public void setComputeIdempotencyWindow(String computeIdempotencyWindow) {
    this.computeIdempotencyWindow = computeIdempotencyWindow;
  }


  public AddSubnetworkRequest consumer(String consumer) {
    this.consumer = consumer;
    return this;
  }

  /**
   * Required. A resource that represents the service consumer, such as &#x60;projects/123456&#x60;. The project number can be different from the value in the consumer network parameter. For example, the network might be part of a Shared VPC network. In those cases, Service Networking validates that this resource belongs to that Shared VPC.
   * @return consumer
   */
  @javax.annotation.Nullable
  public String getConsumer() {
    return consumer;
  }

  public void setConsumer(String consumer) {
    this.consumer = consumer;
  }


  public AddSubnetworkRequest consumerNetwork(String consumerNetwork) {
    this.consumerNetwork = consumerNetwork;
    return this;
  }

  /**
   * Required. The name of the service consumer&#39;s VPC network. The network must have an existing private connection that was provisioned through the connections.create method. The name must be in the following format: &#x60;projects/{project}/global/networks/{network}&#x60;, where {project} is a project number, such as &#x60;12345&#x60;. {network} is the name of a VPC network in the project.
   * @return consumerNetwork
   */
  @javax.annotation.Nullable
  public String getConsumerNetwork() {
    return consumerNetwork;
  }

  public void setConsumerNetwork(String consumerNetwork) {
    this.consumerNetwork = consumerNetwork;
  }


  public AddSubnetworkRequest description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Optional. Description of the subnet.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public AddSubnetworkRequest internalRange(String internalRange) {
    this.internalRange = internalRange;
    return this;
  }

  /**
   * Optional. The url of an Internal Range. Eg: &#x60;projects//locations/global/internalRanges/&#x60;. If specified, it means that the subnetwork cidr will be created using the combination of requested_address/ip_prefix_length. Note that the subnet cidr has to be within the cidr range of this Internal Range.
   * @return internalRange
   */
  @javax.annotation.Nullable
  public String getInternalRange() {
    return internalRange;
  }

  public void setInternalRange(String internalRange) {
    this.internalRange = internalRange;
  }


  public AddSubnetworkRequest ipPrefixLength(Integer ipPrefixLength) {
    this.ipPrefixLength = ipPrefixLength;
    return this;
  }

  /**
   * Required. The prefix length of the subnet&#39;s IP address range. Use CIDR range notation, such as &#x60;29&#x60; to provision a subnet with an &#x60;x.x.x.x/29&#x60; CIDR range. The IP address range is drawn from a pool of available ranges in the service consumer&#39;s allocated range. GCE disallows subnets with prefix_length &gt; 29
   * @return ipPrefixLength
   */
  @javax.annotation.Nullable
  public Integer getIpPrefixLength() {
    return ipPrefixLength;
  }

  public void setIpPrefixLength(Integer ipPrefixLength) {
    this.ipPrefixLength = ipPrefixLength;
  }


  public AddSubnetworkRequest outsideAllocationPublicIpRange(String outsideAllocationPublicIpRange) {
    this.outsideAllocationPublicIpRange = outsideAllocationPublicIpRange;
    return this;
  }

  /**
   * Optional. Enable outside allocation using public IP addresses. Any public IP range may be specified. If this field is provided, we will not use customer reserved ranges for this primary IP range.
   * @return outsideAllocationPublicIpRange
   */
  @javax.annotation.Nullable
  public String getOutsideAllocationPublicIpRange() {
    return outsideAllocationPublicIpRange;
  }

  public void setOutsideAllocationPublicIpRange(String outsideAllocationPublicIpRange) {
    this.outsideAllocationPublicIpRange = outsideAllocationPublicIpRange;
  }


  public AddSubnetworkRequest privateIpv6GoogleAccess(String privateIpv6GoogleAccess) {
    this.privateIpv6GoogleAccess = privateIpv6GoogleAccess;
    return this;
  }

  /**
   * Optional. The private IPv6 google access type for the VMs in this subnet. For information about the access types that can be set using this field, see [subnetwork](https://cloud.google.com/compute/docs/reference/rest/v1/subnetworks) in the Compute API documentation.
   * @return privateIpv6GoogleAccess
   */
  @javax.annotation.Nullable
  public String getPrivateIpv6GoogleAccess() {
    return privateIpv6GoogleAccess;
  }

  public void setPrivateIpv6GoogleAccess(String privateIpv6GoogleAccess) {
    this.privateIpv6GoogleAccess = privateIpv6GoogleAccess;
  }


  public AddSubnetworkRequest purpose(String purpose) {
    this.purpose = purpose;
    return this;
  }

  /**
   * Optional. Defines the purpose field of the subnet, e.g. &#39;PRIVATE_SERVICE_CONNECT&#39;. For information about the purposes that can be set using this field, see [subnetwork](https://cloud.google.com/compute/docs/reference/rest/v1/subnetworks) in the Compute API documentation.
   * @return purpose
   */
  @javax.annotation.Nullable
  public String getPurpose() {
    return purpose;
  }

  public void setPurpose(String purpose) {
    this.purpose = purpose;
  }


  public AddSubnetworkRequest region(String region) {
    this.region = region;
    return this;
  }

  /**
   * Required. The name of a [region](/compute/docs/regions-zones) for the subnet, such &#x60;europe-west1&#x60;.
   * @return region
   */
  @javax.annotation.Nullable
  public String getRegion() {
    return region;
  }

  public void setRegion(String region) {
    this.region = region;
  }


  public AddSubnetworkRequest requestedAddress(String requestedAddress) {
    this.requestedAddress = requestedAddress;
    return this;
  }

  /**
   * Optional. The starting address of a range. The address must be a valid IPv4 address in the x.x.x.x format. This value combined with the IP prefix range is the CIDR range for the subnet. The range must be within the allocated range that is assigned to the private connection. If the CIDR range isn&#39;t available, the call fails.
   * @return requestedAddress
   */
  @javax.annotation.Nullable
  public String getRequestedAddress() {
    return requestedAddress;
  }

  public void setRequestedAddress(String requestedAddress) {
    this.requestedAddress = requestedAddress;
  }


  public AddSubnetworkRequest requestedRanges(List<String> requestedRanges) {
    this.requestedRanges = requestedRanges;
    return this;
  }

  public AddSubnetworkRequest addRequestedRangesItem(String requestedRangesItem) {
    if (this.requestedRanges == null) {
      this.requestedRanges = new ArrayList<>();
    }
    this.requestedRanges.add(requestedRangesItem);
    return this;
  }

  /**
   * Optional. The name of one or more allocated IP address ranges associated with this private service access connection. If no range names are provided all ranges associated with this connection will be considered. If a CIDR range with the specified IP prefix length is not available within these ranges, the call fails.
   * @return requestedRanges
   */
  @javax.annotation.Nullable
  public List<String> getRequestedRanges() {
    return requestedRanges;
  }

  public void setRequestedRanges(List<String> requestedRanges) {
    this.requestedRanges = requestedRanges;
  }


  public AddSubnetworkRequest role(String role) {
    this.role = role;
    return this;
  }

  /**
   * Optional. Defines the role field of the subnet, e.g. &#39;ACTIVE&#39;. For information about the roles that can be set using this field, see [subnetwork](https://cloud.google.com/compute/docs/reference/rest/v1/subnetworks) in the Compute API documentation.
   * @return role
   */
  @javax.annotation.Nullable
  public String getRole() {
    return role;
  }

  public void setRole(String role) {
    this.role = role;
  }


  public AddSubnetworkRequest secondaryIpRangeSpecs(List<SecondaryIpRangeSpec> secondaryIpRangeSpecs) {
    this.secondaryIpRangeSpecs = secondaryIpRangeSpecs;
    return this;
  }

  public AddSubnetworkRequest addSecondaryIpRangeSpecsItem(SecondaryIpRangeSpec secondaryIpRangeSpecsItem) {
    if (this.secondaryIpRangeSpecs == null) {
      this.secondaryIpRangeSpecs = new ArrayList<>();
    }
    this.secondaryIpRangeSpecs.add(secondaryIpRangeSpecsItem);
    return this;
  }

  /**
   * Optional. A list of secondary IP ranges to be created within the new subnetwork.
   * @return secondaryIpRangeSpecs
   */
  @javax.annotation.Nullable
  public List<SecondaryIpRangeSpec> getSecondaryIpRangeSpecs() {
    return secondaryIpRangeSpecs;
  }

  public void setSecondaryIpRangeSpecs(List<SecondaryIpRangeSpec> secondaryIpRangeSpecs) {
    this.secondaryIpRangeSpecs = secondaryIpRangeSpecs;
  }


  public AddSubnetworkRequest subnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
    return this;
  }

  /**
   * Required. A name for the new subnet. For information about the naming requirements, see [subnetwork](/compute/docs/reference/rest/v1/subnetworks) in the Compute API documentation.
   * @return subnetwork
   */
  @javax.annotation.Nullable
  public String getSubnetwork() {
    return subnetwork;
  }

  public void setSubnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
  }


  public AddSubnetworkRequest subnetworkUsers(List<String> subnetworkUsers) {
    this.subnetworkUsers = subnetworkUsers;
    return this;
  }

  public AddSubnetworkRequest addSubnetworkUsersItem(String subnetworkUsersItem) {
    if (this.subnetworkUsers == null) {
      this.subnetworkUsers = new ArrayList<>();
    }
    this.subnetworkUsers.add(subnetworkUsersItem);
    return this;
  }

  /**
   * A list of members that are granted the &#x60;roles/servicenetworking.subnetworkAdmin&#x60; role on the subnet.
   * @return subnetworkUsers
   */
  @javax.annotation.Nullable
  public List<String> getSubnetworkUsers() {
    return subnetworkUsers;
  }

  public void setSubnetworkUsers(List<String> subnetworkUsers) {
    this.subnetworkUsers = subnetworkUsers;
  }


  public AddSubnetworkRequest useCustomComputeIdempotencyWindow(Boolean useCustomComputeIdempotencyWindow) {
    this.useCustomComputeIdempotencyWindow = useCustomComputeIdempotencyWindow;
    return this;
  }

  /**
   * Optional. Specifies if Service Networking should use a custom time bucket for Arcus idempotency. If false, Service Networking uses a 300 second (5 minute) Arcus idempotency window. If true, Service Networking uses a custom idempotency window provided by the user in field compute_idempotency_window. For more information on how to use, see: go/revisit-sn-idempotency-window
   * @return useCustomComputeIdempotencyWindow
   */
  @javax.annotation.Nullable
  public Boolean getUseCustomComputeIdempotencyWindow() {
    return useCustomComputeIdempotencyWindow;
  }

  public void setUseCustomComputeIdempotencyWindow(Boolean useCustomComputeIdempotencyWindow) {
    this.useCustomComputeIdempotencyWindow = useCustomComputeIdempotencyWindow;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AddSubnetworkRequest addSubnetworkRequest = (AddSubnetworkRequest) o;
    return Objects.equals(this.allowSubnetCidrRoutesOverlap, addSubnetworkRequest.allowSubnetCidrRoutesOverlap) &&
        Objects.equals(this.checkServiceNetworkingUsePermission, addSubnetworkRequest.checkServiceNetworkingUsePermission) &&
        Objects.equals(this.computeIdempotencyWindow, addSubnetworkRequest.computeIdempotencyWindow) &&
        Objects.equals(this.consumer, addSubnetworkRequest.consumer) &&
        Objects.equals(this.consumerNetwork, addSubnetworkRequest.consumerNetwork) &&
        Objects.equals(this.description, addSubnetworkRequest.description) &&
        Objects.equals(this.internalRange, addSubnetworkRequest.internalRange) &&
        Objects.equals(this.ipPrefixLength, addSubnetworkRequest.ipPrefixLength) &&
        Objects.equals(this.outsideAllocationPublicIpRange, addSubnetworkRequest.outsideAllocationPublicIpRange) &&
        Objects.equals(this.privateIpv6GoogleAccess, addSubnetworkRequest.privateIpv6GoogleAccess) &&
        Objects.equals(this.purpose, addSubnetworkRequest.purpose) &&
        Objects.equals(this.region, addSubnetworkRequest.region) &&
        Objects.equals(this.requestedAddress, addSubnetworkRequest.requestedAddress) &&
        Objects.equals(this.requestedRanges, addSubnetworkRequest.requestedRanges) &&
        Objects.equals(this.role, addSubnetworkRequest.role) &&
        Objects.equals(this.secondaryIpRangeSpecs, addSubnetworkRequest.secondaryIpRangeSpecs) &&
        Objects.equals(this.subnetwork, addSubnetworkRequest.subnetwork) &&
        Objects.equals(this.subnetworkUsers, addSubnetworkRequest.subnetworkUsers) &&
        Objects.equals(this.useCustomComputeIdempotencyWindow, addSubnetworkRequest.useCustomComputeIdempotencyWindow);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowSubnetCidrRoutesOverlap, checkServiceNetworkingUsePermission, computeIdempotencyWindow, consumer, consumerNetwork, description, internalRange, ipPrefixLength, outsideAllocationPublicIpRange, privateIpv6GoogleAccess, purpose, region, requestedAddress, requestedRanges, role, secondaryIpRangeSpecs, subnetwork, subnetworkUsers, useCustomComputeIdempotencyWindow);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AddSubnetworkRequest {\n");
    sb.append("    allowSubnetCidrRoutesOverlap: ").append(toIndentedString(allowSubnetCidrRoutesOverlap)).append("\n");
    sb.append("    checkServiceNetworkingUsePermission: ").append(toIndentedString(checkServiceNetworkingUsePermission)).append("\n");
    sb.append("    computeIdempotencyWindow: ").append(toIndentedString(computeIdempotencyWindow)).append("\n");
    sb.append("    consumer: ").append(toIndentedString(consumer)).append("\n");
    sb.append("    consumerNetwork: ").append(toIndentedString(consumerNetwork)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    internalRange: ").append(toIndentedString(internalRange)).append("\n");
    sb.append("    ipPrefixLength: ").append(toIndentedString(ipPrefixLength)).append("\n");
    sb.append("    outsideAllocationPublicIpRange: ").append(toIndentedString(outsideAllocationPublicIpRange)).append("\n");
    sb.append("    privateIpv6GoogleAccess: ").append(toIndentedString(privateIpv6GoogleAccess)).append("\n");
    sb.append("    purpose: ").append(toIndentedString(purpose)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    requestedAddress: ").append(toIndentedString(requestedAddress)).append("\n");
    sb.append("    requestedRanges: ").append(toIndentedString(requestedRanges)).append("\n");
    sb.append("    role: ").append(toIndentedString(role)).append("\n");
    sb.append("    secondaryIpRangeSpecs: ").append(toIndentedString(secondaryIpRangeSpecs)).append("\n");
    sb.append("    subnetwork: ").append(toIndentedString(subnetwork)).append("\n");
    sb.append("    subnetworkUsers: ").append(toIndentedString(subnetworkUsers)).append("\n");
    sb.append("    useCustomComputeIdempotencyWindow: ").append(toIndentedString(useCustomComputeIdempotencyWindow)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowSubnetCidrRoutesOverlap");
    openapiFields.add("checkServiceNetworkingUsePermission");
    openapiFields.add("computeIdempotencyWindow");
    openapiFields.add("consumer");
    openapiFields.add("consumerNetwork");
    openapiFields.add("description");
    openapiFields.add("internalRange");
    openapiFields.add("ipPrefixLength");
    openapiFields.add("outsideAllocationPublicIpRange");
    openapiFields.add("privateIpv6GoogleAccess");
    openapiFields.add("purpose");
    openapiFields.add("region");
    openapiFields.add("requestedAddress");
    openapiFields.add("requestedRanges");
    openapiFields.add("role");
    openapiFields.add("secondaryIpRangeSpecs");
    openapiFields.add("subnetwork");
    openapiFields.add("subnetworkUsers");
    openapiFields.add("useCustomComputeIdempotencyWindow");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AddSubnetworkRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AddSubnetworkRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AddSubnetworkRequest is not found in the empty JSON string", AddSubnetworkRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AddSubnetworkRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AddSubnetworkRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("computeIdempotencyWindow") != null && !jsonObj.get("computeIdempotencyWindow").isJsonNull()) && !jsonObj.get("computeIdempotencyWindow").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `computeIdempotencyWindow` to be a primitive type in the JSON string but got `%s`", jsonObj.get("computeIdempotencyWindow").toString()));
      }
      if ((jsonObj.get("consumer") != null && !jsonObj.get("consumer").isJsonNull()) && !jsonObj.get("consumer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `consumer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("consumer").toString()));
      }
      if ((jsonObj.get("consumerNetwork") != null && !jsonObj.get("consumerNetwork").isJsonNull()) && !jsonObj.get("consumerNetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `consumerNetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("consumerNetwork").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("internalRange") != null && !jsonObj.get("internalRange").isJsonNull()) && !jsonObj.get("internalRange").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `internalRange` to be a primitive type in the JSON string but got `%s`", jsonObj.get("internalRange").toString()));
      }
      if ((jsonObj.get("outsideAllocationPublicIpRange") != null && !jsonObj.get("outsideAllocationPublicIpRange").isJsonNull()) && !jsonObj.get("outsideAllocationPublicIpRange").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outsideAllocationPublicIpRange` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outsideAllocationPublicIpRange").toString()));
      }
      if ((jsonObj.get("privateIpv6GoogleAccess") != null && !jsonObj.get("privateIpv6GoogleAccess").isJsonNull()) && !jsonObj.get("privateIpv6GoogleAccess").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `privateIpv6GoogleAccess` to be a primitive type in the JSON string but got `%s`", jsonObj.get("privateIpv6GoogleAccess").toString()));
      }
      if ((jsonObj.get("purpose") != null && !jsonObj.get("purpose").isJsonNull()) && !jsonObj.get("purpose").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `purpose` to be a primitive type in the JSON string but got `%s`", jsonObj.get("purpose").toString()));
      }
      if ((jsonObj.get("region") != null && !jsonObj.get("region").isJsonNull()) && !jsonObj.get("region").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `region` to be a primitive type in the JSON string but got `%s`", jsonObj.get("region").toString()));
      }
      if ((jsonObj.get("requestedAddress") != null && !jsonObj.get("requestedAddress").isJsonNull()) && !jsonObj.get("requestedAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestedAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("requestedAddress").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("requestedRanges") != null && !jsonObj.get("requestedRanges").isJsonNull() && !jsonObj.get("requestedRanges").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `requestedRanges` to be an array in the JSON string but got `%s`", jsonObj.get("requestedRanges").toString()));
      }
      if ((jsonObj.get("role") != null && !jsonObj.get("role").isJsonNull()) && !jsonObj.get("role").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `role` to be a primitive type in the JSON string but got `%s`", jsonObj.get("role").toString()));
      }
      if (jsonObj.get("secondaryIpRangeSpecs") != null && !jsonObj.get("secondaryIpRangeSpecs").isJsonNull()) {
        JsonArray jsonArraysecondaryIpRangeSpecs = jsonObj.getAsJsonArray("secondaryIpRangeSpecs");
        if (jsonArraysecondaryIpRangeSpecs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("secondaryIpRangeSpecs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `secondaryIpRangeSpecs` to be an array in the JSON string but got `%s`", jsonObj.get("secondaryIpRangeSpecs").toString()));
          }

          // validate the optional field `secondaryIpRangeSpecs` (array)
          for (int i = 0; i < jsonArraysecondaryIpRangeSpecs.size(); i++) {
            SecondaryIpRangeSpec.validateJsonElement(jsonArraysecondaryIpRangeSpecs.get(i));
          };
        }
      }
      if ((jsonObj.get("subnetwork") != null && !jsonObj.get("subnetwork").isJsonNull()) && !jsonObj.get("subnetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetwork").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("subnetworkUsers") != null && !jsonObj.get("subnetworkUsers").isJsonNull() && !jsonObj.get("subnetworkUsers").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetworkUsers` to be an array in the JSON string but got `%s`", jsonObj.get("subnetworkUsers").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AddSubnetworkRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AddSubnetworkRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AddSubnetworkRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AddSubnetworkRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<AddSubnetworkRequest>() {
           @Override
           public void write(JsonWriter out, AddSubnetworkRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AddSubnetworkRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AddSubnetworkRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AddSubnetworkRequest
   * @throws IOException if the JSON string is invalid with respect to AddSubnetworkRequest
   */
  public static AddSubnetworkRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AddSubnetworkRequest.class);
  }

  /**
   * Convert an instance of AddSubnetworkRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

