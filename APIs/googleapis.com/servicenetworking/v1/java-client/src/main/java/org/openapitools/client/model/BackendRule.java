/*
 * Service Networking API
 * Provides automatic management of network configurations necessary for certain services.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A backend rule provides configuration for an individual API element.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:30:16.869716-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BackendRule {
  public static final String SERIALIZED_NAME_ADDRESS = "address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  private String address;

  public static final String SERIALIZED_NAME_DEADLINE = "deadline";
  @SerializedName(SERIALIZED_NAME_DEADLINE)
  private Double deadline;

  public static final String SERIALIZED_NAME_DISABLE_AUTH = "disableAuth";
  @SerializedName(SERIALIZED_NAME_DISABLE_AUTH)
  private Boolean disableAuth;

  public static final String SERIALIZED_NAME_JWT_AUDIENCE = "jwtAudience";
  @SerializedName(SERIALIZED_NAME_JWT_AUDIENCE)
  private String jwtAudience;

  public static final String SERIALIZED_NAME_MIN_DEADLINE = "minDeadline";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_MIN_DEADLINE)
  private Double minDeadline;

  public static final String SERIALIZED_NAME_OPERATION_DEADLINE = "operationDeadline";
  @SerializedName(SERIALIZED_NAME_OPERATION_DEADLINE)
  private Double operationDeadline;

  public static final String SERIALIZED_NAME_OVERRIDES_BY_REQUEST_PROTOCOL = "overridesByRequestProtocol";
  @SerializedName(SERIALIZED_NAME_OVERRIDES_BY_REQUEST_PROTOCOL)
  private Map<String, BackendRule> overridesByRequestProtocol = new HashMap<>();

  /**
   * Gets or Sets pathTranslation
   */
  @JsonAdapter(PathTranslationEnum.Adapter.class)
  public enum PathTranslationEnum {
    PATH_TRANSLATION_UNSPECIFIED("PATH_TRANSLATION_UNSPECIFIED"),
    
    CONSTANT_ADDRESS("CONSTANT_ADDRESS"),
    
    APPEND_PATH_TO_ADDRESS("APPEND_PATH_TO_ADDRESS");

    private String value;

    PathTranslationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PathTranslationEnum fromValue(String value) {
      for (PathTranslationEnum b : PathTranslationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PathTranslationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PathTranslationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PathTranslationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PathTranslationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PathTranslationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PATH_TRANSLATION = "pathTranslation";
  @SerializedName(SERIALIZED_NAME_PATH_TRANSLATION)
  private PathTranslationEnum pathTranslation;

  public static final String SERIALIZED_NAME_PROTOCOL = "protocol";
  @SerializedName(SERIALIZED_NAME_PROTOCOL)
  private String protocol;

  public static final String SERIALIZED_NAME_SELECTOR = "selector";
  @SerializedName(SERIALIZED_NAME_SELECTOR)
  private String selector;

  public BackendRule() {
  }

  public BackendRule address(String address) {
    this.address = address;
    return this;
  }

  /**
   * The address of the API backend. The scheme is used to determine the backend protocol and security. The following schemes are accepted: SCHEME PROTOCOL SECURITY http:// HTTP None https:// HTTP TLS grpc:// gRPC None grpcs:// gRPC TLS It is recommended to explicitly include a scheme. Leaving out the scheme may cause constrasting behaviors across platforms. If the port is unspecified, the default is: - 80 for schemes without TLS - 443 for schemes with TLS For HTTP backends, use protocol to specify the protocol version.
   * @return address
   */
  @javax.annotation.Nullable
  public String getAddress() {
    return address;
  }

  public void setAddress(String address) {
    this.address = address;
  }


  public BackendRule deadline(Double deadline) {
    this.deadline = deadline;
    return this;
  }

  /**
   * The number of seconds to wait for a response from a request. The default varies based on the request protocol and deployment environment.
   * @return deadline
   */
  @javax.annotation.Nullable
  public Double getDeadline() {
    return deadline;
  }

  public void setDeadline(Double deadline) {
    this.deadline = deadline;
  }


  public BackendRule disableAuth(Boolean disableAuth) {
    this.disableAuth = disableAuth;
    return this;
  }

  /**
   * When disable_auth is true, a JWT ID token won&#39;t be generated and the original \&quot;Authorization\&quot; HTTP header will be preserved. If the header is used to carry the original token and is expected by the backend, this field must be set to true to preserve the header.
   * @return disableAuth
   */
  @javax.annotation.Nullable
  public Boolean getDisableAuth() {
    return disableAuth;
  }

  public void setDisableAuth(Boolean disableAuth) {
    this.disableAuth = disableAuth;
  }


  public BackendRule jwtAudience(String jwtAudience) {
    this.jwtAudience = jwtAudience;
    return this;
  }

  /**
   * The JWT audience is used when generating a JWT ID token for the backend. This ID token will be added in the HTTP \&quot;authorization\&quot; header, and sent to the backend.
   * @return jwtAudience
   */
  @javax.annotation.Nullable
  public String getJwtAudience() {
    return jwtAudience;
  }

  public void setJwtAudience(String jwtAudience) {
    this.jwtAudience = jwtAudience;
  }


  @Deprecated
  public BackendRule minDeadline(Double minDeadline) {
    this.minDeadline = minDeadline;
    return this;
  }

  /**
   * Deprecated, do not use.
   * @return minDeadline
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Double getMinDeadline() {
    return minDeadline;
  }

  @Deprecated
  public void setMinDeadline(Double minDeadline) {
    this.minDeadline = minDeadline;
  }


  public BackendRule operationDeadline(Double operationDeadline) {
    this.operationDeadline = operationDeadline;
    return this;
  }

  /**
   * The number of seconds to wait for the completion of a long running operation. The default is no deadline.
   * @return operationDeadline
   */
  @javax.annotation.Nullable
  public Double getOperationDeadline() {
    return operationDeadline;
  }

  public void setOperationDeadline(Double operationDeadline) {
    this.operationDeadline = operationDeadline;
  }


  public BackendRule overridesByRequestProtocol(Map<String, BackendRule> overridesByRequestProtocol) {
    this.overridesByRequestProtocol = overridesByRequestProtocol;
    return this;
  }

  public BackendRule putOverridesByRequestProtocolItem(String key, BackendRule overridesByRequestProtocolItem) {
    if (this.overridesByRequestProtocol == null) {
      this.overridesByRequestProtocol = new HashMap<>();
    }
    this.overridesByRequestProtocol.put(key, overridesByRequestProtocolItem);
    return this;
  }

  /**
   * The map between request protocol and the backend address.
   * @return overridesByRequestProtocol
   */
  @javax.annotation.Nullable
  public Map<String, BackendRule> getOverridesByRequestProtocol() {
    return overridesByRequestProtocol;
  }

  public void setOverridesByRequestProtocol(Map<String, BackendRule> overridesByRequestProtocol) {
    this.overridesByRequestProtocol = overridesByRequestProtocol;
  }


  public BackendRule pathTranslation(PathTranslationEnum pathTranslation) {
    this.pathTranslation = pathTranslation;
    return this;
  }

  /**
   * Get pathTranslation
   * @return pathTranslation
   */
  @javax.annotation.Nullable
  public PathTranslationEnum getPathTranslation() {
    return pathTranslation;
  }

  public void setPathTranslation(PathTranslationEnum pathTranslation) {
    this.pathTranslation = pathTranslation;
  }


  public BackendRule protocol(String protocol) {
    this.protocol = protocol;
    return this;
  }

  /**
   * The protocol used for sending a request to the backend. The supported values are \&quot;http/1.1\&quot; and \&quot;h2\&quot;. The default value is inferred from the scheme in the address field: SCHEME PROTOCOL http:// http/1.1 https:// http/1.1 grpc:// h2 grpcs:// h2 For secure HTTP backends (https://) that support HTTP/2, set this field to \&quot;h2\&quot; for improved performance. Configuring this field to non-default values is only supported for secure HTTP backends. This field will be ignored for all other backends. See https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids for more details on the supported values.
   * @return protocol
   */
  @javax.annotation.Nullable
  public String getProtocol() {
    return protocol;
  }

  public void setProtocol(String protocol) {
    this.protocol = protocol;
  }


  public BackendRule selector(String selector) {
    this.selector = selector;
    return this;
  }

  /**
   * Selects the methods to which this rule applies. Refer to selector for syntax details.
   * @return selector
   */
  @javax.annotation.Nullable
  public String getSelector() {
    return selector;
  }

  public void setSelector(String selector) {
    this.selector = selector;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BackendRule backendRule = (BackendRule) o;
    return Objects.equals(this.address, backendRule.address) &&
        Objects.equals(this.deadline, backendRule.deadline) &&
        Objects.equals(this.disableAuth, backendRule.disableAuth) &&
        Objects.equals(this.jwtAudience, backendRule.jwtAudience) &&
        Objects.equals(this.minDeadline, backendRule.minDeadline) &&
        Objects.equals(this.operationDeadline, backendRule.operationDeadline) &&
        Objects.equals(this.overridesByRequestProtocol, backendRule.overridesByRequestProtocol) &&
        Objects.equals(this.pathTranslation, backendRule.pathTranslation) &&
        Objects.equals(this.protocol, backendRule.protocol) &&
        Objects.equals(this.selector, backendRule.selector);
  }

  @Override
  public int hashCode() {
    return Objects.hash(address, deadline, disableAuth, jwtAudience, minDeadline, operationDeadline, overridesByRequestProtocol, pathTranslation, protocol, selector);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BackendRule {\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    deadline: ").append(toIndentedString(deadline)).append("\n");
    sb.append("    disableAuth: ").append(toIndentedString(disableAuth)).append("\n");
    sb.append("    jwtAudience: ").append(toIndentedString(jwtAudience)).append("\n");
    sb.append("    minDeadline: ").append(toIndentedString(minDeadline)).append("\n");
    sb.append("    operationDeadline: ").append(toIndentedString(operationDeadline)).append("\n");
    sb.append("    overridesByRequestProtocol: ").append(toIndentedString(overridesByRequestProtocol)).append("\n");
    sb.append("    pathTranslation: ").append(toIndentedString(pathTranslation)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    selector: ").append(toIndentedString(selector)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("address");
    openapiFields.add("deadline");
    openapiFields.add("disableAuth");
    openapiFields.add("jwtAudience");
    openapiFields.add("minDeadline");
    openapiFields.add("operationDeadline");
    openapiFields.add("overridesByRequestProtocol");
    openapiFields.add("pathTranslation");
    openapiFields.add("protocol");
    openapiFields.add("selector");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BackendRule
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BackendRule.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BackendRule is not found in the empty JSON string", BackendRule.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BackendRule.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BackendRule` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("address") != null && !jsonObj.get("address").isJsonNull()) && !jsonObj.get("address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("address").toString()));
      }
      if ((jsonObj.get("jwtAudience") != null && !jsonObj.get("jwtAudience").isJsonNull()) && !jsonObj.get("jwtAudience").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `jwtAudience` to be a primitive type in the JSON string but got `%s`", jsonObj.get("jwtAudience").toString()));
      }
      if ((jsonObj.get("pathTranslation") != null && !jsonObj.get("pathTranslation").isJsonNull()) && !jsonObj.get("pathTranslation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pathTranslation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pathTranslation").toString()));
      }
      // validate the optional field `pathTranslation`
      if (jsonObj.get("pathTranslation") != null && !jsonObj.get("pathTranslation").isJsonNull()) {
        PathTranslationEnum.validateJsonElement(jsonObj.get("pathTranslation"));
      }
      if ((jsonObj.get("protocol") != null && !jsonObj.get("protocol").isJsonNull()) && !jsonObj.get("protocol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `protocol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("protocol").toString()));
      }
      if ((jsonObj.get("selector") != null && !jsonObj.get("selector").isJsonNull()) && !jsonObj.get("selector").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selector` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selector").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BackendRule.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BackendRule' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BackendRule> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BackendRule.class));

       return (TypeAdapter<T>) new TypeAdapter<BackendRule>() {
           @Override
           public void write(JsonWriter out, BackendRule value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BackendRule read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BackendRule given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BackendRule
   * @throws IOException if the JSON string is invalid with respect to BackendRule
   */
  public static BackendRule fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BackendRule.class);
  }

  /**
   * Convert an instance of BackendRule to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

