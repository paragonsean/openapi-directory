/*
 * Display & Video 360 API
 * Display & Video 360 API allows users to automate complex Display & Video 360 workflows, such as creating insertion orders and setting targeting options for individual line items.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Settings that control the number of times a user may be shown with the same ad during a given time period.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:00.456843-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FrequencyCap {
  public static final String SERIALIZED_NAME_MAX_IMPRESSIONS = "maxImpressions";
  @SerializedName(SERIALIZED_NAME_MAX_IMPRESSIONS)
  private Integer maxImpressions;

  public static final String SERIALIZED_NAME_MAX_VIEWS = "maxViews";
  @SerializedName(SERIALIZED_NAME_MAX_VIEWS)
  private Integer maxViews;

  /**
   * The time unit in which the frequency cap will be applied. Required when unlimited is &#x60;false&#x60;.
   */
  @JsonAdapter(TimeUnitEnum.Adapter.class)
  public enum TimeUnitEnum {
    UNSPECIFIED("TIME_UNIT_UNSPECIFIED"),
    
    LIFETIME("TIME_UNIT_LIFETIME"),
    
    MONTHS("TIME_UNIT_MONTHS"),
    
    WEEKS("TIME_UNIT_WEEKS"),
    
    DAYS("TIME_UNIT_DAYS"),
    
    HOURS("TIME_UNIT_HOURS"),
    
    MINUTES("TIME_UNIT_MINUTES");

    private String value;

    TimeUnitEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TimeUnitEnum fromValue(String value) {
      for (TimeUnitEnum b : TimeUnitEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TimeUnitEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TimeUnitEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TimeUnitEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TimeUnitEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TimeUnitEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TIME_UNIT = "timeUnit";
  @SerializedName(SERIALIZED_NAME_TIME_UNIT)
  private TimeUnitEnum timeUnit;

  public static final String SERIALIZED_NAME_TIME_UNIT_COUNT = "timeUnitCount";
  @SerializedName(SERIALIZED_NAME_TIME_UNIT_COUNT)
  private Integer timeUnitCount;

  public static final String SERIALIZED_NAME_UNLIMITED = "unlimited";
  @SerializedName(SERIALIZED_NAME_UNLIMITED)
  private Boolean unlimited;

  public FrequencyCap() {
  }

  public FrequencyCap maxImpressions(Integer maxImpressions) {
    this.maxImpressions = maxImpressions;
    return this;
  }

  /**
   * The maximum number of times a user may be shown the same ad during this period. Must be greater than 0. Required when unlimited is &#x60;false&#x60; and max_views is not set.
   * @return maxImpressions
   */
  @javax.annotation.Nullable
  public Integer getMaxImpressions() {
    return maxImpressions;
  }

  public void setMaxImpressions(Integer maxImpressions) {
    this.maxImpressions = maxImpressions;
  }


  public FrequencyCap maxViews(Integer maxViews) {
    this.maxViews = maxViews;
    return this;
  }

  /**
   * Optional. The maximum number of times a user may click-through or fully view an ad during this period until it is no longer served to them. Must be greater than 0. Only applicable to YouTube and Partners resources. Required when unlimited is &#x60;false&#x60; and max_impressions is not set.
   * @return maxViews
   */
  @javax.annotation.Nullable
  public Integer getMaxViews() {
    return maxViews;
  }

  public void setMaxViews(Integer maxViews) {
    this.maxViews = maxViews;
  }


  public FrequencyCap timeUnit(TimeUnitEnum timeUnit) {
    this.timeUnit = timeUnit;
    return this;
  }

  /**
   * The time unit in which the frequency cap will be applied. Required when unlimited is &#x60;false&#x60;.
   * @return timeUnit
   */
  @javax.annotation.Nullable
  public TimeUnitEnum getTimeUnit() {
    return timeUnit;
  }

  public void setTimeUnit(TimeUnitEnum timeUnit) {
    this.timeUnit = timeUnit;
  }


  public FrequencyCap timeUnitCount(Integer timeUnitCount) {
    this.timeUnitCount = timeUnitCount;
    return this;
  }

  /**
   * The number of time_unit the frequency cap will last. Required when unlimited is &#x60;false&#x60;. The following restrictions apply based on the value of time_unit: * &#x60;TIME_UNIT_LIFETIME&#x60; - this field is output only and will default to 1 * &#x60;TIME_UNIT_MONTHS&#x60; - must be between 1 and 2 * &#x60;TIME_UNIT_WEEKS&#x60; - must be between 1 and 4 * &#x60;TIME_UNIT_DAYS&#x60; - must be between 1 and 6 * &#x60;TIME_UNIT_HOURS&#x60; - must be between 1 and 23 * &#x60;TIME_UNIT_MINUTES&#x60; - must be between 1 and 59
   * @return timeUnitCount
   */
  @javax.annotation.Nullable
  public Integer getTimeUnitCount() {
    return timeUnitCount;
  }

  public void setTimeUnitCount(Integer timeUnitCount) {
    this.timeUnitCount = timeUnitCount;
  }


  public FrequencyCap unlimited(Boolean unlimited) {
    this.unlimited = unlimited;
    return this;
  }

  /**
   * Whether unlimited frequency capping is applied. When this field is set to &#x60;true&#x60;, the remaining frequency cap fields are not applicable.
   * @return unlimited
   */
  @javax.annotation.Nullable
  public Boolean getUnlimited() {
    return unlimited;
  }

  public void setUnlimited(Boolean unlimited) {
    this.unlimited = unlimited;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FrequencyCap frequencyCap = (FrequencyCap) o;
    return Objects.equals(this.maxImpressions, frequencyCap.maxImpressions) &&
        Objects.equals(this.maxViews, frequencyCap.maxViews) &&
        Objects.equals(this.timeUnit, frequencyCap.timeUnit) &&
        Objects.equals(this.timeUnitCount, frequencyCap.timeUnitCount) &&
        Objects.equals(this.unlimited, frequencyCap.unlimited);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxImpressions, maxViews, timeUnit, timeUnitCount, unlimited);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FrequencyCap {\n");
    sb.append("    maxImpressions: ").append(toIndentedString(maxImpressions)).append("\n");
    sb.append("    maxViews: ").append(toIndentedString(maxViews)).append("\n");
    sb.append("    timeUnit: ").append(toIndentedString(timeUnit)).append("\n");
    sb.append("    timeUnitCount: ").append(toIndentedString(timeUnitCount)).append("\n");
    sb.append("    unlimited: ").append(toIndentedString(unlimited)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("maxImpressions");
    openapiFields.add("maxViews");
    openapiFields.add("timeUnit");
    openapiFields.add("timeUnitCount");
    openapiFields.add("unlimited");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FrequencyCap
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FrequencyCap.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FrequencyCap is not found in the empty JSON string", FrequencyCap.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FrequencyCap.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FrequencyCap` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("timeUnit") != null && !jsonObj.get("timeUnit").isJsonNull()) && !jsonObj.get("timeUnit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeUnit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeUnit").toString()));
      }
      // validate the optional field `timeUnit`
      if (jsonObj.get("timeUnit") != null && !jsonObj.get("timeUnit").isJsonNull()) {
        TimeUnitEnum.validateJsonElement(jsonObj.get("timeUnit"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FrequencyCap.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FrequencyCap' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FrequencyCap> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FrequencyCap.class));

       return (TypeAdapter<T>) new TypeAdapter<FrequencyCap>() {
           @Override
           public void write(JsonWriter out, FrequencyCap value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FrequencyCap read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FrequencyCap given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FrequencyCap
   * @throws IOException if the JSON string is invalid with respect to FrequencyCap
   */
  public static FrequencyCap fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FrequencyCap.class);
  }

  /**
   * Convert an instance of FrequencyCap to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

