/*
 * Display & Video 360 API
 * Display & Video 360 API allows users to automate complex Display & Video 360 workflows, such as creating insertion orders and setting targeting options for individual line items.
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.ActiveViewVideoViewabilityMetricConfig;
import org.openapitools.client.model.LookbackWindow;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A single Floodlight group.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:00.456843-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class FloodlightGroup {
  public static final String SERIALIZED_NAME_ACTIVE_VIEW_CONFIG = "activeViewConfig";
  @SerializedName(SERIALIZED_NAME_ACTIVE_VIEW_CONFIG)
  private ActiveViewVideoViewabilityMetricConfig activeViewConfig;

  public static final String SERIALIZED_NAME_CUSTOM_VARIABLES = "customVariables";
  @SerializedName(SERIALIZED_NAME_CUSTOM_VARIABLES)
  private Map<String, Object> customVariables = new HashMap<>();

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_FLOODLIGHT_GROUP_ID = "floodlightGroupId";
  @SerializedName(SERIALIZED_NAME_FLOODLIGHT_GROUP_ID)
  private String floodlightGroupId;

  public static final String SERIALIZED_NAME_LOOKBACK_WINDOW = "lookbackWindow";
  @SerializedName(SERIALIZED_NAME_LOOKBACK_WINDOW)
  private LookbackWindow lookbackWindow;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  /**
   * Required. The web tag type enabled for the Floodlight group.
   */
  @JsonAdapter(WebTagTypeEnum.Adapter.class)
  public enum WebTagTypeEnum {
    UNSPECIFIED("WEB_TAG_TYPE_UNSPECIFIED"),
    
    NONE("WEB_TAG_TYPE_NONE"),
    
    IMAGE("WEB_TAG_TYPE_IMAGE"),
    
    DYNAMIC("WEB_TAG_TYPE_DYNAMIC");

    private String value;

    WebTagTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static WebTagTypeEnum fromValue(String value) {
      for (WebTagTypeEnum b : WebTagTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<WebTagTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final WebTagTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public WebTagTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return WebTagTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      WebTagTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_WEB_TAG_TYPE = "webTagType";
  @SerializedName(SERIALIZED_NAME_WEB_TAG_TYPE)
  private WebTagTypeEnum webTagType;

  public FloodlightGroup() {
  }

  public FloodlightGroup(
     String floodlightGroupId, 
     String name
  ) {
    this();
    this.floodlightGroupId = floodlightGroupId;
    this.name = name;
  }

  public FloodlightGroup activeViewConfig(ActiveViewVideoViewabilityMetricConfig activeViewConfig) {
    this.activeViewConfig = activeViewConfig;
    return this;
  }

  /**
   * Get activeViewConfig
   * @return activeViewConfig
   */
  @javax.annotation.Nullable
  public ActiveViewVideoViewabilityMetricConfig getActiveViewConfig() {
    return activeViewConfig;
  }

  public void setActiveViewConfig(ActiveViewVideoViewabilityMetricConfig activeViewConfig) {
    this.activeViewConfig = activeViewConfig;
  }


  public FloodlightGroup customVariables(Map<String, Object> customVariables) {
    this.customVariables = customVariables;
    return this;
  }

  public FloodlightGroup putCustomVariablesItem(String key, Object customVariablesItem) {
    if (this.customVariables == null) {
      this.customVariables = new HashMap<>();
    }
    this.customVariables.put(key, customVariablesItem);
    return this;
  }

  /**
   * User-defined custom variables owned by the Floodlight group. Use custom Floodlight variables to create reporting data that is tailored to your unique business needs. Custom Floodlight variables use the keys &#x60;U1&#x3D;&#x60;, &#x60;U2&#x3D;&#x60;, and so on, and can take any values that you choose to pass to them. You can use them to track virtually any type of data that you collect about your customers, such as the genre of movie that a customer purchases, the country to which the item is shipped, and so on. Custom Floodlight variables may not be used to pass any data that could be used or recognized as personally identifiable information (PII). Example: &#x60;custom_variables { fields { \&quot;U1\&quot;: value { number_value: 123.4 }, \&quot;U2\&quot;: value { string_value: \&quot;MyVariable2\&quot; }, \&quot;U3\&quot;: value { string_value: \&quot;MyVariable3\&quot; } } }&#x60; Acceptable values for keys are \&quot;U1\&quot; through \&quot;U100\&quot;, inclusive. String values must be less than 64 characters long, and cannot contain the following characters: &#x60;\&quot;&lt;&gt;&#x60;.
   * @return customVariables
   */
  @javax.annotation.Nullable
  public Map<String, Object> getCustomVariables() {
    return customVariables;
  }

  public void setCustomVariables(Map<String, Object> customVariables) {
    this.customVariables = customVariables;
  }


  public FloodlightGroup displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Required. The display name of the Floodlight group.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  /**
   * Output only. The unique ID of the Floodlight group. Assigned by the system.
   * @return floodlightGroupId
   */
  @javax.annotation.Nullable
  public String getFloodlightGroupId() {
    return floodlightGroupId;
  }



  public FloodlightGroup lookbackWindow(LookbackWindow lookbackWindow) {
    this.lookbackWindow = lookbackWindow;
    return this;
  }

  /**
   * Get lookbackWindow
   * @return lookbackWindow
   */
  @javax.annotation.Nullable
  public LookbackWindow getLookbackWindow() {
    return lookbackWindow;
  }

  public void setLookbackWindow(LookbackWindow lookbackWindow) {
    this.lookbackWindow = lookbackWindow;
  }


  /**
   * Output only. The resource name of the Floodlight group.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  public FloodlightGroup webTagType(WebTagTypeEnum webTagType) {
    this.webTagType = webTagType;
    return this;
  }

  /**
   * Required. The web tag type enabled for the Floodlight group.
   * @return webTagType
   */
  @javax.annotation.Nullable
  public WebTagTypeEnum getWebTagType() {
    return webTagType;
  }

  public void setWebTagType(WebTagTypeEnum webTagType) {
    this.webTagType = webTagType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FloodlightGroup floodlightGroup = (FloodlightGroup) o;
    return Objects.equals(this.activeViewConfig, floodlightGroup.activeViewConfig) &&
        Objects.equals(this.customVariables, floodlightGroup.customVariables) &&
        Objects.equals(this.displayName, floodlightGroup.displayName) &&
        Objects.equals(this.floodlightGroupId, floodlightGroup.floodlightGroupId) &&
        Objects.equals(this.lookbackWindow, floodlightGroup.lookbackWindow) &&
        Objects.equals(this.name, floodlightGroup.name) &&
        Objects.equals(this.webTagType, floodlightGroup.webTagType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activeViewConfig, customVariables, displayName, floodlightGroupId, lookbackWindow, name, webTagType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FloodlightGroup {\n");
    sb.append("    activeViewConfig: ").append(toIndentedString(activeViewConfig)).append("\n");
    sb.append("    customVariables: ").append(toIndentedString(customVariables)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    floodlightGroupId: ").append(toIndentedString(floodlightGroupId)).append("\n");
    sb.append("    lookbackWindow: ").append(toIndentedString(lookbackWindow)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    webTagType: ").append(toIndentedString(webTagType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activeViewConfig");
    openapiFields.add("customVariables");
    openapiFields.add("displayName");
    openapiFields.add("floodlightGroupId");
    openapiFields.add("lookbackWindow");
    openapiFields.add("name");
    openapiFields.add("webTagType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FloodlightGroup
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FloodlightGroup.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FloodlightGroup is not found in the empty JSON string", FloodlightGroup.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FloodlightGroup.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FloodlightGroup` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `activeViewConfig`
      if (jsonObj.get("activeViewConfig") != null && !jsonObj.get("activeViewConfig").isJsonNull()) {
        ActiveViewVideoViewabilityMetricConfig.validateJsonElement(jsonObj.get("activeViewConfig"));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("floodlightGroupId") != null && !jsonObj.get("floodlightGroupId").isJsonNull()) && !jsonObj.get("floodlightGroupId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `floodlightGroupId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("floodlightGroupId").toString()));
      }
      // validate the optional field `lookbackWindow`
      if (jsonObj.get("lookbackWindow") != null && !jsonObj.get("lookbackWindow").isJsonNull()) {
        LookbackWindow.validateJsonElement(jsonObj.get("lookbackWindow"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("webTagType") != null && !jsonObj.get("webTagType").isJsonNull()) && !jsonObj.get("webTagType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `webTagType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("webTagType").toString()));
      }
      // validate the optional field `webTagType`
      if (jsonObj.get("webTagType") != null && !jsonObj.get("webTagType").isJsonNull()) {
        WebTagTypeEnum.validateJsonElement(jsonObj.get("webTagType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FloodlightGroup.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FloodlightGroup' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FloodlightGroup> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FloodlightGroup.class));

       return (TypeAdapter<T>) new TypeAdapter<FloodlightGroup>() {
           @Override
           public void write(JsonWriter out, FloodlightGroup value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FloodlightGroup read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FloodlightGroup given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FloodlightGroup
   * @throws IOException if the JSON string is invalid with respect to FloodlightGroup
   */
  public static FloodlightGroup fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FloodlightGroup.class);
  }

  /**
   * Convert an instance of FloodlightGroup to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

