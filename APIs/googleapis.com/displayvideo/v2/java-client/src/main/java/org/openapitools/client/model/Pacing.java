/*
 * Display & Video 360 API
 * Display & Video 360 API allows users to automate complex Display & Video 360 workflows, such as creating insertion orders and setting targeting options for individual line items.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Settings that control the rate at which a budget is spent.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:45:09.670881-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Pacing {
  public static final String SERIALIZED_NAME_DAILY_MAX_IMPRESSIONS = "dailyMaxImpressions";
  @SerializedName(SERIALIZED_NAME_DAILY_MAX_IMPRESSIONS)
  private String dailyMaxImpressions;

  public static final String SERIALIZED_NAME_DAILY_MAX_MICROS = "dailyMaxMicros";
  @SerializedName(SERIALIZED_NAME_DAILY_MAX_MICROS)
  private String dailyMaxMicros;

  /**
   * Required. The time period in which the pacing budget will be spent. When automatic budget allocation is enabled at the insertion order via automationType, this field is output only and defaults to &#x60;PACING_PERIOD_FLIGHT&#x60;.
   */
  @JsonAdapter(PacingPeriodEnum.Adapter.class)
  public enum PacingPeriodEnum {
    UNSPECIFIED("PACING_PERIOD_UNSPECIFIED"),
    
    DAILY("PACING_PERIOD_DAILY"),
    
    FLIGHT("PACING_PERIOD_FLIGHT");

    private String value;

    PacingPeriodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PacingPeriodEnum fromValue(String value) {
      for (PacingPeriodEnum b : PacingPeriodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PacingPeriodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PacingPeriodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PacingPeriodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PacingPeriodEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PacingPeriodEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PACING_PERIOD = "pacingPeriod";
  @SerializedName(SERIALIZED_NAME_PACING_PERIOD)
  private PacingPeriodEnum pacingPeriod;

  /**
   * Required. The type of pacing that defines how the budget amount will be spent across the pacing_period.
   */
  @JsonAdapter(PacingTypeEnum.Adapter.class)
  public enum PacingTypeEnum {
    UNSPECIFIED("PACING_TYPE_UNSPECIFIED"),
    
    AHEAD("PACING_TYPE_AHEAD"),
    
    ASAP("PACING_TYPE_ASAP"),
    
    EVEN("PACING_TYPE_EVEN");

    private String value;

    PacingTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PacingTypeEnum fromValue(String value) {
      for (PacingTypeEnum b : PacingTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PacingTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PacingTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PacingTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PacingTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PacingTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PACING_TYPE = "pacingType";
  @SerializedName(SERIALIZED_NAME_PACING_TYPE)
  private PacingTypeEnum pacingType;

  public Pacing() {
  }

  public Pacing dailyMaxImpressions(String dailyMaxImpressions) {
    this.dailyMaxImpressions = dailyMaxImpressions;
    return this;
  }

  /**
   * Maximum number of impressions to serve every day. Applicable when the budget is impression based. Must be greater than 0.
   * @return dailyMaxImpressions
   */
  @javax.annotation.Nullable
  public String getDailyMaxImpressions() {
    return dailyMaxImpressions;
  }

  public void setDailyMaxImpressions(String dailyMaxImpressions) {
    this.dailyMaxImpressions = dailyMaxImpressions;
  }


  public Pacing dailyMaxMicros(String dailyMaxMicros) {
    this.dailyMaxMicros = dailyMaxMicros;
    return this;
  }

  /**
   * Maximum currency amount to spend every day in micros of advertiser&#39;s currency. Applicable when the budget is currency based. Must be greater than 0. For example, for 1.5 standard unit of the currency, set this field to 1500000. The value assigned will be rounded to whole billable units for the relevant currency by the following rules: any positive value less than a single billable unit will be rounded up to one billable unit and any value larger than a single billable unit will be rounded down to the nearest billable value. For example, if the currency&#39;s billable unit is 0.01, and this field is set to 10257770, it will round down to 10250000, a value of 10.25. If set to 505, it will round up to 10000, a value of 0.01.
   * @return dailyMaxMicros
   */
  @javax.annotation.Nullable
  public String getDailyMaxMicros() {
    return dailyMaxMicros;
  }

  public void setDailyMaxMicros(String dailyMaxMicros) {
    this.dailyMaxMicros = dailyMaxMicros;
  }


  public Pacing pacingPeriod(PacingPeriodEnum pacingPeriod) {
    this.pacingPeriod = pacingPeriod;
    return this;
  }

  /**
   * Required. The time period in which the pacing budget will be spent. When automatic budget allocation is enabled at the insertion order via automationType, this field is output only and defaults to &#x60;PACING_PERIOD_FLIGHT&#x60;.
   * @return pacingPeriod
   */
  @javax.annotation.Nullable
  public PacingPeriodEnum getPacingPeriod() {
    return pacingPeriod;
  }

  public void setPacingPeriod(PacingPeriodEnum pacingPeriod) {
    this.pacingPeriod = pacingPeriod;
  }


  public Pacing pacingType(PacingTypeEnum pacingType) {
    this.pacingType = pacingType;
    return this;
  }

  /**
   * Required. The type of pacing that defines how the budget amount will be spent across the pacing_period.
   * @return pacingType
   */
  @javax.annotation.Nullable
  public PacingTypeEnum getPacingType() {
    return pacingType;
  }

  public void setPacingType(PacingTypeEnum pacingType) {
    this.pacingType = pacingType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Pacing pacing = (Pacing) o;
    return Objects.equals(this.dailyMaxImpressions, pacing.dailyMaxImpressions) &&
        Objects.equals(this.dailyMaxMicros, pacing.dailyMaxMicros) &&
        Objects.equals(this.pacingPeriod, pacing.pacingPeriod) &&
        Objects.equals(this.pacingType, pacing.pacingType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dailyMaxImpressions, dailyMaxMicros, pacingPeriod, pacingType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Pacing {\n");
    sb.append("    dailyMaxImpressions: ").append(toIndentedString(dailyMaxImpressions)).append("\n");
    sb.append("    dailyMaxMicros: ").append(toIndentedString(dailyMaxMicros)).append("\n");
    sb.append("    pacingPeriod: ").append(toIndentedString(pacingPeriod)).append("\n");
    sb.append("    pacingType: ").append(toIndentedString(pacingType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dailyMaxImpressions");
    openapiFields.add("dailyMaxMicros");
    openapiFields.add("pacingPeriod");
    openapiFields.add("pacingType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Pacing
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Pacing.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Pacing is not found in the empty JSON string", Pacing.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Pacing.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Pacing` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("dailyMaxImpressions") != null && !jsonObj.get("dailyMaxImpressions").isJsonNull()) && !jsonObj.get("dailyMaxImpressions").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dailyMaxImpressions` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dailyMaxImpressions").toString()));
      }
      if ((jsonObj.get("dailyMaxMicros") != null && !jsonObj.get("dailyMaxMicros").isJsonNull()) && !jsonObj.get("dailyMaxMicros").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dailyMaxMicros` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dailyMaxMicros").toString()));
      }
      if ((jsonObj.get("pacingPeriod") != null && !jsonObj.get("pacingPeriod").isJsonNull()) && !jsonObj.get("pacingPeriod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pacingPeriod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pacingPeriod").toString()));
      }
      // validate the optional field `pacingPeriod`
      if (jsonObj.get("pacingPeriod") != null && !jsonObj.get("pacingPeriod").isJsonNull()) {
        PacingPeriodEnum.validateJsonElement(jsonObj.get("pacingPeriod"));
      }
      if ((jsonObj.get("pacingType") != null && !jsonObj.get("pacingType").isJsonNull()) && !jsonObj.get("pacingType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pacingType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pacingType").toString()));
      }
      // validate the optional field `pacingType`
      if (jsonObj.get("pacingType") != null && !jsonObj.get("pacingType").isJsonNull()) {
        PacingTypeEnum.validateJsonElement(jsonObj.get("pacingType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Pacing.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Pacing' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Pacing> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Pacing.class));

       return (TypeAdapter<T>) new TypeAdapter<Pacing>() {
           @Override
           public void write(JsonWriter out, Pacing value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Pacing read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Pacing given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Pacing
   * @throws IOException if the JSON string is invalid with respect to Pacing
   */
  public static Pacing fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Pacing.class);
  }

  /**
   * Convert an instance of Pacing to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

