# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.assigned_targeting_option import AssignedTargetingOption
from openapi_server import util


class CreateAssignedTargetingOptionsRequest(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, assigned_targeting_options: List[AssignedTargetingOption]=None, targeting_type: str=None):
        """CreateAssignedTargetingOptionsRequest - a model defined in OpenAPI

        :param assigned_targeting_options: The assigned_targeting_options of this CreateAssignedTargetingOptionsRequest.
        :param targeting_type: The targeting_type of this CreateAssignedTargetingOptionsRequest.
        """
        self.openapi_types = {
            'assigned_targeting_options': List[AssignedTargetingOption],
            'targeting_type': str
        }

        self.attribute_map = {
            'assigned_targeting_options': 'assignedTargetingOptions',
            'targeting_type': 'targetingType'
        }

        self._assigned_targeting_options = assigned_targeting_options
        self._targeting_type = targeting_type

    @classmethod
    def from_dict(cls, dikt: dict) -> 'CreateAssignedTargetingOptionsRequest':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The CreateAssignedTargetingOptionsRequest of this CreateAssignedTargetingOptionsRequest.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def assigned_targeting_options(self):
        """Gets the assigned_targeting_options of this CreateAssignedTargetingOptionsRequest.

        Required. The assigned targeting options to create and add.

        :return: The assigned_targeting_options of this CreateAssignedTargetingOptionsRequest.
        :rtype: List[AssignedTargetingOption]
        """
        return self._assigned_targeting_options

    @assigned_targeting_options.setter
    def assigned_targeting_options(self, assigned_targeting_options):
        """Sets the assigned_targeting_options of this CreateAssignedTargetingOptionsRequest.

        Required. The assigned targeting options to create and add.

        :param assigned_targeting_options: The assigned_targeting_options of this CreateAssignedTargetingOptionsRequest.
        :type assigned_targeting_options: List[AssignedTargetingOption]
        """

        self._assigned_targeting_options = assigned_targeting_options

    @property
    def targeting_type(self):
        """Gets the targeting_type of this CreateAssignedTargetingOptionsRequest.

        Required. Identifies the type of this assigned targeting option.

        :return: The targeting_type of this CreateAssignedTargetingOptionsRequest.
        :rtype: str
        """
        return self._targeting_type

    @targeting_type.setter
    def targeting_type(self, targeting_type):
        """Sets the targeting_type of this CreateAssignedTargetingOptionsRequest.

        Required. Identifies the type of this assigned targeting option.

        :param targeting_type: The targeting_type of this CreateAssignedTargetingOptionsRequest.
        :type targeting_type: str
        """
        allowed_values = ["TARGETING_TYPE_UNSPECIFIED", "TARGETING_TYPE_CHANNEL", "TARGETING_TYPE_APP_CATEGORY", "TARGETING_TYPE_APP", "TARGETING_TYPE_URL", "TARGETING_TYPE_DAY_AND_TIME", "TARGETING_TYPE_AGE_RANGE", "TARGETING_TYPE_REGIONAL_LOCATION_LIST", "TARGETING_TYPE_PROXIMITY_LOCATION_LIST", "TARGETING_TYPE_GENDER", "TARGETING_TYPE_VIDEO_PLAYER_SIZE", "TARGETING_TYPE_USER_REWARDED_CONTENT", "TARGETING_TYPE_PARENTAL_STATUS", "TARGETING_TYPE_CONTENT_INSTREAM_POSITION", "TARGETING_TYPE_CONTENT_OUTSTREAM_POSITION", "TARGETING_TYPE_DEVICE_TYPE", "TARGETING_TYPE_AUDIENCE_GROUP", "TARGETING_TYPE_BROWSER", "TARGETING_TYPE_HOUSEHOLD_INCOME", "TARGETING_TYPE_ON_SCREEN_POSITION", "TARGETING_TYPE_THIRD_PARTY_VERIFIER", "TARGETING_TYPE_DIGITAL_CONTENT_LABEL_EXCLUSION", "TARGETING_TYPE_SENSITIVE_CATEGORY_EXCLUSION", "TARGETING_TYPE_ENVIRONMENT", "TARGETING_TYPE_CARRIER_AND_ISP", "TARGETING_TYPE_OPERATING_SYSTEM", "TARGETING_TYPE_DEVICE_MAKE_MODEL", "TARGETING_TYPE_KEYWORD", "TARGETING_TYPE_NEGATIVE_KEYWORD_LIST", "TARGETING_TYPE_VIEWABILITY", "TARGETING_TYPE_CATEGORY", "TARGETING_TYPE_INVENTORY_SOURCE", "TARGETING_TYPE_LANGUAGE", "TARGETING_TYPE_AUTHORIZED_SELLER_STATUS", "TARGETING_TYPE_GEO_REGION", "TARGETING_TYPE_INVENTORY_SOURCE_GROUP", "TARGETING_TYPE_EXCHANGE", "TARGETING_TYPE_SUB_EXCHANGE", "TARGETING_TYPE_POI", "TARGETING_TYPE_BUSINESS_CHAIN", "TARGETING_TYPE_CONTENT_DURATION", "TARGETING_TYPE_CONTENT_STREAM_TYPE", "TARGETING_TYPE_NATIVE_CONTENT_POSITION", "TARGETING_TYPE_OMID", "TARGETING_TYPE_AUDIO_CONTENT_TYPE", "TARGETING_TYPE_CONTENT_GENRE", "TARGETING_TYPE_YOUTUBE_VIDEO", "TARGETING_TYPE_YOUTUBE_CHANNEL", "TARGETING_TYPE_SESSION_POSITION"]  # noqa: E501
        if targeting_type not in allowed_values:
            raise ValueError(
                "Invalid value for `targeting_type` ({0}), must be one of {1}"
                .format(targeting_type, allowed_values)
            )

        self._targeting_type = targeting_type
