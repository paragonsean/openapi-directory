/*
 * Apigee Registry API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A top-level description of an API. Produced by producers and are commitments to provide services.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:53.311920-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Api {
  public static final String SERIALIZED_NAME_ANNOTATIONS = "annotations";
  @SerializedName(SERIALIZED_NAME_ANNOTATIONS)
  private Map<String, String> annotations = new HashMap<>();

  public static final String SERIALIZED_NAME_AVAILABILITY = "availability";
  @SerializedName(SERIALIZED_NAME_AVAILABILITY)
  private String availability;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_RECOMMENDED_DEPLOYMENT = "recommendedDeployment";
  @SerializedName(SERIALIZED_NAME_RECOMMENDED_DEPLOYMENT)
  private String recommendedDeployment;

  public static final String SERIALIZED_NAME_RECOMMENDED_VERSION = "recommendedVersion";
  @SerializedName(SERIALIZED_NAME_RECOMMENDED_VERSION)
  private String recommendedVersion;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public Api() {
  }

  public Api(
     String createTime, 
     String updateTime
  ) {
    this();
    this.createTime = createTime;
    this.updateTime = updateTime;
  }

  public Api annotations(Map<String, String> annotations) {
    this.annotations = annotations;
    return this;
  }

  public Api putAnnotationsItem(String key, String annotationsItem) {
    if (this.annotations == null) {
      this.annotations = new HashMap<>();
    }
    this.annotations.put(key, annotationsItem);
    return this;
  }

  /**
   * Annotations attach non-identifying metadata to resources. Annotation keys and values are less restricted than those of labels, but should be generally used for small values of broad interest. Larger, topic- specific metadata should be stored in Artifacts.
   * @return annotations
   */
  @javax.annotation.Nullable
  public Map<String, String> getAnnotations() {
    return annotations;
  }

  public void setAnnotations(Map<String, String> annotations) {
    this.annotations = annotations;
  }


  public Api availability(String availability) {
    this.availability = availability;
    return this;
  }

  /**
   * A user-definable description of the availability of this service. Format: free-form, but we expect single words that describe availability, e.g., \&quot;NONE\&quot;, \&quot;TESTING\&quot;, \&quot;PREVIEW\&quot;, \&quot;GENERAL\&quot;, \&quot;DEPRECATED\&quot;, \&quot;SHUTDOWN\&quot;.
   * @return availability
   */
  @javax.annotation.Nullable
  public String getAvailability() {
    return availability;
  }

  public void setAvailability(String availability) {
    this.availability = availability;
  }


  /**
   * Output only. Creation timestamp.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  public Api description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A detailed description.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public Api displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Human-meaningful name.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public Api labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Api putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels attach identifying metadata to resources. Identifying metadata can be used to filter list operations. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores, and dashes. International characters are allowed. No more than 64 user labels can be associated with one resource (System labels are excluded). See https://goo.gl/xmQnxf for more information and examples of labels. System reserved label keys are prefixed with &#x60;apigeeregistry.googleapis.com/&#x60; and cannot be changed.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public Api name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Resource name.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Api recommendedDeployment(String recommendedDeployment) {
    this.recommendedDeployment = recommendedDeployment;
    return this;
  }

  /**
   * The recommended deployment of the API. Format: &#x60;projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}&#x60;
   * @return recommendedDeployment
   */
  @javax.annotation.Nullable
  public String getRecommendedDeployment() {
    return recommendedDeployment;
  }

  public void setRecommendedDeployment(String recommendedDeployment) {
    this.recommendedDeployment = recommendedDeployment;
  }


  public Api recommendedVersion(String recommendedVersion) {
    this.recommendedVersion = recommendedVersion;
    return this;
  }

  /**
   * The recommended version of the API. Format: &#x60;projects/{project}/locations/{location}/apis/{api}/versions/{version}&#x60;
   * @return recommendedVersion
   */
  @javax.annotation.Nullable
  public String getRecommendedVersion() {
    return recommendedVersion;
  }

  public void setRecommendedVersion(String recommendedVersion) {
    this.recommendedVersion = recommendedVersion;
  }


  /**
   * Output only. Last update timestamp.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Api api = (Api) o;
    return Objects.equals(this.annotations, api.annotations) &&
        Objects.equals(this.availability, api.availability) &&
        Objects.equals(this.createTime, api.createTime) &&
        Objects.equals(this.description, api.description) &&
        Objects.equals(this.displayName, api.displayName) &&
        Objects.equals(this.labels, api.labels) &&
        Objects.equals(this.name, api.name) &&
        Objects.equals(this.recommendedDeployment, api.recommendedDeployment) &&
        Objects.equals(this.recommendedVersion, api.recommendedVersion) &&
        Objects.equals(this.updateTime, api.updateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotations, availability, createTime, description, displayName, labels, name, recommendedDeployment, recommendedVersion, updateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Api {\n");
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    availability: ").append(toIndentedString(availability)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    recommendedDeployment: ").append(toIndentedString(recommendedDeployment)).append("\n");
    sb.append("    recommendedVersion: ").append(toIndentedString(recommendedVersion)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotations");
    openapiFields.add("availability");
    openapiFields.add("createTime");
    openapiFields.add("description");
    openapiFields.add("displayName");
    openapiFields.add("labels");
    openapiFields.add("name");
    openapiFields.add("recommendedDeployment");
    openapiFields.add("recommendedVersion");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Api
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Api.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Api is not found in the empty JSON string", Api.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Api.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Api` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("availability") != null && !jsonObj.get("availability").isJsonNull()) && !jsonObj.get("availability").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availability` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availability").toString()));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("recommendedDeployment") != null && !jsonObj.get("recommendedDeployment").isJsonNull()) && !jsonObj.get("recommendedDeployment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recommendedDeployment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recommendedDeployment").toString()));
      }
      if ((jsonObj.get("recommendedVersion") != null && !jsonObj.get("recommendedVersion").isJsonNull()) && !jsonObj.get("recommendedVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `recommendedVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recommendedVersion").toString()));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Api.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Api' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Api> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Api.class));

       return (TypeAdapter<T>) new TypeAdapter<Api>() {
           @Override
           public void write(JsonWriter out, Api value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Api read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Api given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Api
   * @throws IOException if the JSON string is invalid with respect to Api
   */
  public static Api fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Api.class);
  }

  /**
   * Convert an instance of Api to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

