/*
 * Apigee Registry API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes a version of an API in a structured way. ApiSpecs provide formal descriptions that consumers can use to use a version. ApiSpec resources are intended to be fully-resolved descriptions of an ApiVersion. When specs consist of multiple files, these should be bundled together (e.g., in a zip archive) and stored as a unit. Multiple specs can exist to provide representations in different API description formats. Synchronization of these representations would be provided by tooling and background services.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:53.311920-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ApiSpec {
  public static final String SERIALIZED_NAME_ANNOTATIONS = "annotations";
  @SerializedName(SERIALIZED_NAME_ANNOTATIONS)
  private Map<String, String> annotations = new HashMap<>();

  public static final String SERIALIZED_NAME_CONTENTS = "contents";
  @SerializedName(SERIALIZED_NAME_CONTENTS)
  private byte[] contents;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_FILENAME = "filename";
  @SerializedName(SERIALIZED_NAME_FILENAME)
  private String filename;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  private String hash;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MIME_TYPE = "mimeType";
  @SerializedName(SERIALIZED_NAME_MIME_TYPE)
  private String mimeType;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_REVISION_CREATE_TIME = "revisionCreateTime";
  @SerializedName(SERIALIZED_NAME_REVISION_CREATE_TIME)
  private String revisionCreateTime;

  public static final String SERIALIZED_NAME_REVISION_ID = "revisionId";
  @SerializedName(SERIALIZED_NAME_REVISION_ID)
  private String revisionId;

  public static final String SERIALIZED_NAME_REVISION_UPDATE_TIME = "revisionUpdateTime";
  @SerializedName(SERIALIZED_NAME_REVISION_UPDATE_TIME)
  private String revisionUpdateTime;

  public static final String SERIALIZED_NAME_SIZE_BYTES = "sizeBytes";
  @SerializedName(SERIALIZED_NAME_SIZE_BYTES)
  private Integer sizeBytes;

  public static final String SERIALIZED_NAME_SOURCE_URI = "sourceUri";
  @SerializedName(SERIALIZED_NAME_SOURCE_URI)
  private String sourceUri;

  public ApiSpec() {
  }

  public ApiSpec(
     String createTime, 
     String hash, 
     String revisionCreateTime, 
     String revisionId, 
     String revisionUpdateTime, 
     Integer sizeBytes
  ) {
    this();
    this.createTime = createTime;
    this.hash = hash;
    this.revisionCreateTime = revisionCreateTime;
    this.revisionId = revisionId;
    this.revisionUpdateTime = revisionUpdateTime;
    this.sizeBytes = sizeBytes;
  }

  public ApiSpec annotations(Map<String, String> annotations) {
    this.annotations = annotations;
    return this;
  }

  public ApiSpec putAnnotationsItem(String key, String annotationsItem) {
    if (this.annotations == null) {
      this.annotations = new HashMap<>();
    }
    this.annotations.put(key, annotationsItem);
    return this;
  }

  /**
   * Annotations attach non-identifying metadata to resources. Annotation keys and values are less restricted than those of labels, but should be generally used for small values of broad interest. Larger, topic- specific metadata should be stored in Artifacts.
   * @return annotations
   */
  @javax.annotation.Nullable
  public Map<String, String> getAnnotations() {
    return annotations;
  }

  public void setAnnotations(Map<String, String> annotations) {
    this.annotations = annotations;
  }


  public ApiSpec contents(byte[] contents) {
    this.contents = contents;
    return this;
  }

  /**
   * Input only. The contents of the spec. Provided by API callers when specs are created or updated. To access the contents of a spec, use GetApiSpecContents.
   * @return contents
   */
  @javax.annotation.Nullable
  public byte[] getContents() {
    return contents;
  }

  public void setContents(byte[] contents) {
    this.contents = contents;
  }


  /**
   * Output only. Creation timestamp; when the spec resource was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  public ApiSpec description(String description) {
    this.description = description;
    return this;
  }

  /**
   * A detailed description.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public ApiSpec filename(String filename) {
    this.filename = filename;
    return this;
  }

  /**
   * A possibly-hierarchical name used to refer to the spec from other specs.
   * @return filename
   */
  @javax.annotation.Nullable
  public String getFilename() {
    return filename;
  }

  public void setFilename(String filename) {
    this.filename = filename;
  }


  /**
   * Output only. A SHA-256 hash of the spec&#39;s contents. If the spec is gzipped, this is the hash of the uncompressed spec.
   * @return hash
   */
  @javax.annotation.Nullable
  public String getHash() {
    return hash;
  }



  public ApiSpec labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public ApiSpec putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels attach identifying metadata to resources. Identifying metadata can be used to filter list operations. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one resource (System labels are excluded). See https://goo.gl/xmQnxf for more information and examples of labels. System reserved label keys are prefixed with &#x60;apigeeregistry.googleapis.com/&#x60; and cannot be changed.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public ApiSpec mimeType(String mimeType) {
    this.mimeType = mimeType;
    return this;
  }

  /**
   * A style (format) descriptor for this spec that is specified as a [Media Type](https://en.wikipedia.org/wiki/Media_type). Possible values include &#x60;application/vnd.apigee.proto&#x60;, &#x60;application/vnd.apigee.openapi&#x60;, and &#x60;application/vnd.apigee.graphql&#x60;, with possible suffixes representing compression types. These hypothetical names are defined in the vendor tree defined in RFC6838 (https://tools.ietf.org/html/rfc6838) and are not final. Content types can specify compression. Currently only GZip compression is supported (indicated with \&quot;+gzip\&quot;).
   * @return mimeType
   */
  @javax.annotation.Nullable
  public String getMimeType() {
    return mimeType;
  }

  public void setMimeType(String mimeType) {
    this.mimeType = mimeType;
  }


  public ApiSpec name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Resource name.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  /**
   * Output only. Revision creation timestamp; when the represented revision was created.
   * @return revisionCreateTime
   */
  @javax.annotation.Nullable
  public String getRevisionCreateTime() {
    return revisionCreateTime;
  }



  /**
   * Output only. Immutable. The revision ID of the spec. A new revision is committed whenever the spec contents are changed. The format is an 8-character hexadecimal string.
   * @return revisionId
   */
  @javax.annotation.Nullable
  public String getRevisionId() {
    return revisionId;
  }



  /**
   * Output only. Last update timestamp: when the represented revision was last modified.
   * @return revisionUpdateTime
   */
  @javax.annotation.Nullable
  public String getRevisionUpdateTime() {
    return revisionUpdateTime;
  }



  /**
   * Output only. The size of the spec file in bytes. If the spec is gzipped, this is the size of the uncompressed spec.
   * @return sizeBytes
   */
  @javax.annotation.Nullable
  public Integer getSizeBytes() {
    return sizeBytes;
  }



  public ApiSpec sourceUri(String sourceUri) {
    this.sourceUri = sourceUri;
    return this;
  }

  /**
   * The original source URI of the spec (if one exists). This is an external location that can be used for reference purposes but which may not be authoritative since this external resource may change after the spec is retrieved.
   * @return sourceUri
   */
  @javax.annotation.Nullable
  public String getSourceUri() {
    return sourceUri;
  }

  public void setSourceUri(String sourceUri) {
    this.sourceUri = sourceUri;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApiSpec apiSpec = (ApiSpec) o;
    return Objects.equals(this.annotations, apiSpec.annotations) &&
        Arrays.equals(this.contents, apiSpec.contents) &&
        Objects.equals(this.createTime, apiSpec.createTime) &&
        Objects.equals(this.description, apiSpec.description) &&
        Objects.equals(this.filename, apiSpec.filename) &&
        Objects.equals(this.hash, apiSpec.hash) &&
        Objects.equals(this.labels, apiSpec.labels) &&
        Objects.equals(this.mimeType, apiSpec.mimeType) &&
        Objects.equals(this.name, apiSpec.name) &&
        Objects.equals(this.revisionCreateTime, apiSpec.revisionCreateTime) &&
        Objects.equals(this.revisionId, apiSpec.revisionId) &&
        Objects.equals(this.revisionUpdateTime, apiSpec.revisionUpdateTime) &&
        Objects.equals(this.sizeBytes, apiSpec.sizeBytes) &&
        Objects.equals(this.sourceUri, apiSpec.sourceUri);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotations, Arrays.hashCode(contents), createTime, description, filename, hash, labels, mimeType, name, revisionCreateTime, revisionId, revisionUpdateTime, sizeBytes, sourceUri);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApiSpec {\n");
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    contents: ").append(toIndentedString(contents)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    filename: ").append(toIndentedString(filename)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    mimeType: ").append(toIndentedString(mimeType)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    revisionCreateTime: ").append(toIndentedString(revisionCreateTime)).append("\n");
    sb.append("    revisionId: ").append(toIndentedString(revisionId)).append("\n");
    sb.append("    revisionUpdateTime: ").append(toIndentedString(revisionUpdateTime)).append("\n");
    sb.append("    sizeBytes: ").append(toIndentedString(sizeBytes)).append("\n");
    sb.append("    sourceUri: ").append(toIndentedString(sourceUri)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotations");
    openapiFields.add("contents");
    openapiFields.add("createTime");
    openapiFields.add("description");
    openapiFields.add("filename");
    openapiFields.add("hash");
    openapiFields.add("labels");
    openapiFields.add("mimeType");
    openapiFields.add("name");
    openapiFields.add("revisionCreateTime");
    openapiFields.add("revisionId");
    openapiFields.add("revisionUpdateTime");
    openapiFields.add("sizeBytes");
    openapiFields.add("sourceUri");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ApiSpec
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ApiSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ApiSpec is not found in the empty JSON string", ApiSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ApiSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ApiSpec` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("filename") != null && !jsonObj.get("filename").isJsonNull()) && !jsonObj.get("filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filename").toString()));
      }
      if ((jsonObj.get("hash") != null && !jsonObj.get("hash").isJsonNull()) && !jsonObj.get("hash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hash").toString()));
      }
      if ((jsonObj.get("mimeType") != null && !jsonObj.get("mimeType").isJsonNull()) && !jsonObj.get("mimeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mimeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mimeType").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("revisionCreateTime") != null && !jsonObj.get("revisionCreateTime").isJsonNull()) && !jsonObj.get("revisionCreateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revisionCreateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revisionCreateTime").toString()));
      }
      if ((jsonObj.get("revisionId") != null && !jsonObj.get("revisionId").isJsonNull()) && !jsonObj.get("revisionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revisionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revisionId").toString()));
      }
      if ((jsonObj.get("revisionUpdateTime") != null && !jsonObj.get("revisionUpdateTime").isJsonNull()) && !jsonObj.get("revisionUpdateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `revisionUpdateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("revisionUpdateTime").toString()));
      }
      if ((jsonObj.get("sourceUri") != null && !jsonObj.get("sourceUri").isJsonNull()) && !jsonObj.get("sourceUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceUri").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ApiSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ApiSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ApiSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ApiSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<ApiSpec>() {
           @Override
           public void write(JsonWriter out, ApiSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ApiSpec read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ApiSpec given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ApiSpec
   * @throws IOException if the JSON string is invalid with respect to ApiSpec
   */
  public static ApiSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ApiSpec.class);
  }

  /**
   * Convert an instance of ApiSpec to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

