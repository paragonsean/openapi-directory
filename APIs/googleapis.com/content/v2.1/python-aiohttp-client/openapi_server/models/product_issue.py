# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.action import Action
from openapi_server.models.product_issue_impact import ProductIssueImpact
from openapi_server import util


class ProductIssue(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, actions: List[Action]=None, impact: ProductIssueImpact=None, prerendered_content: str=None, title: str=None):
        """ProductIssue - a model defined in OpenAPI

        :param actions: The actions of this ProductIssue.
        :param impact: The impact of this ProductIssue.
        :param prerendered_content: The prerendered_content of this ProductIssue.
        :param title: The title of this ProductIssue.
        """
        self.openapi_types = {
            'actions': List[Action],
            'impact': ProductIssueImpact,
            'prerendered_content': str,
            'title': str
        }

        self.attribute_map = {
            'actions': 'actions',
            'impact': 'impact',
            'prerendered_content': 'prerenderedContent',
            'title': 'title'
        }

        self._actions = actions
        self._impact = impact
        self._prerendered_content = prerendered_content
        self._title = title

    @classmethod
    def from_dict(cls, dikt: dict) -> 'ProductIssue':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The ProductIssue of this ProductIssue.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def actions(self):
        """Gets the actions of this ProductIssue.

        A list of actionable steps that can be executed to solve the issue. An example is requesting a re-review or providing arguments when merchant disagrees with the issue. Actions that are supported in (your) third-party application can be rendered as buttons and should be available to merchant when they expand the issue.

        :return: The actions of this ProductIssue.
        :rtype: List[Action]
        """
        return self._actions

    @actions.setter
    def actions(self, actions):
        """Sets the actions of this ProductIssue.

        A list of actionable steps that can be executed to solve the issue. An example is requesting a re-review or providing arguments when merchant disagrees with the issue. Actions that are supported in (your) third-party application can be rendered as buttons and should be available to merchant when they expand the issue.

        :param actions: The actions of this ProductIssue.
        :type actions: List[Action]
        """

        self._actions = actions

    @property
    def impact(self):
        """Gets the impact of this ProductIssue.


        :return: The impact of this ProductIssue.
        :rtype: ProductIssueImpact
        """
        return self._impact

    @impact.setter
    def impact(self, impact):
        """Sets the impact of this ProductIssue.


        :param impact: The impact of this ProductIssue.
        :type impact: ProductIssueImpact
        """

        self._impact = impact

    @property
    def prerendered_content(self):
        """Gets the prerendered_content of this ProductIssue.

        Details of the issue as a pre-rendered HTML. HTML elements contain CSS classes that can be used to customize the style of the content. Always sanitize the HTML before embedding it directly to your application. The sanitizer needs to allow basic HTML tags, such as: `div`, `span`, `p`, `a`, `ul`, `li`, `table`, `tr`, `td`. For example, you can use [DOMPurify](https://www.npmjs.com/package/dompurify). CSS classes: * `issue-detail` - top level container for the detail of the issue * `callout-banners` - section of the `issue-detail` with callout banners * `callout-banner` - single callout banner, inside `callout-banners` * `callout-banner-info` - callout with important information (default) * `callout-banner-warning` - callout with a warning * `callout-banner-error` - callout informing about an error (most severe) * `issue-content` - section of the `issue-detail`, contains multiple `content-element` * `content-element` - content element such as a list, link or paragraph, inside `issue-content` * `root-causes` - unordered list with items describing root causes of the issue, inside `issue-content` * `root-causes-intro` - intro text before the `root-causes` list, inside `issue-content` * `segment` - section of the text, `span` inside paragraph * `segment-attribute` - section of the text that represents a product attribute, for example 'image\\_link' * `segment-literal` - section of the text that contains a special value, for example '0-1000 kg' * `segment-bold` - section of the text that should be rendered as bold * `segment-italic` - section of the text that should be rendered as italic * `tooltip` - used on paragraphs that should be rendered with a tooltip. A section of the text in such a paragraph will have a class `tooltip-text` and is intended to be shown in a mouse over dialog. If the style is not used, the `tooltip-text` section would be shown on a new line, after the main part of the text. * `tooltip-text` - marks a section of the text within a `tooltip`, that is intended to be shown in a mouse over dialog. * `tooltip-icon` - marks a section of the text within a `tooltip`, that can be replaced with a tooltip icon, for example '?' or 'i'. By default, this section contains a `br` tag, that is separating the main text and the tooltip text when the style is not used. * `tooltip-style-question` - the tooltip shows helpful information, can use the '?' as an icon. * `tooltip-style-info` - the tooltip adds additional information fitting to the context, can use the 'i' as an icon. * `content-moderation` - marks the paragraph that explains how the issue was identified. * `new-element` - Present for new elements added to the pre-rendered content in the future. To make sure that a new content element does not break your style, you can hide everything with this class.

        :return: The prerendered_content of this ProductIssue.
        :rtype: str
        """
        return self._prerendered_content

    @prerendered_content.setter
    def prerendered_content(self, prerendered_content):
        """Sets the prerendered_content of this ProductIssue.

        Details of the issue as a pre-rendered HTML. HTML elements contain CSS classes that can be used to customize the style of the content. Always sanitize the HTML before embedding it directly to your application. The sanitizer needs to allow basic HTML tags, such as: `div`, `span`, `p`, `a`, `ul`, `li`, `table`, `tr`, `td`. For example, you can use [DOMPurify](https://www.npmjs.com/package/dompurify). CSS classes: * `issue-detail` - top level container for the detail of the issue * `callout-banners` - section of the `issue-detail` with callout banners * `callout-banner` - single callout banner, inside `callout-banners` * `callout-banner-info` - callout with important information (default) * `callout-banner-warning` - callout with a warning * `callout-banner-error` - callout informing about an error (most severe) * `issue-content` - section of the `issue-detail`, contains multiple `content-element` * `content-element` - content element such as a list, link or paragraph, inside `issue-content` * `root-causes` - unordered list with items describing root causes of the issue, inside `issue-content` * `root-causes-intro` - intro text before the `root-causes` list, inside `issue-content` * `segment` - section of the text, `span` inside paragraph * `segment-attribute` - section of the text that represents a product attribute, for example 'image\\_link' * `segment-literal` - section of the text that contains a special value, for example '0-1000 kg' * `segment-bold` - section of the text that should be rendered as bold * `segment-italic` - section of the text that should be rendered as italic * `tooltip` - used on paragraphs that should be rendered with a tooltip. A section of the text in such a paragraph will have a class `tooltip-text` and is intended to be shown in a mouse over dialog. If the style is not used, the `tooltip-text` section would be shown on a new line, after the main part of the text. * `tooltip-text` - marks a section of the text within a `tooltip`, that is intended to be shown in a mouse over dialog. * `tooltip-icon` - marks a section of the text within a `tooltip`, that can be replaced with a tooltip icon, for example '?' or 'i'. By default, this section contains a `br` tag, that is separating the main text and the tooltip text when the style is not used. * `tooltip-style-question` - the tooltip shows helpful information, can use the '?' as an icon. * `tooltip-style-info` - the tooltip adds additional information fitting to the context, can use the 'i' as an icon. * `content-moderation` - marks the paragraph that explains how the issue was identified. * `new-element` - Present for new elements added to the pre-rendered content in the future. To make sure that a new content element does not break your style, you can hide everything with this class.

        :param prerendered_content: The prerendered_content of this ProductIssue.
        :type prerendered_content: str
        """

        self._prerendered_content = prerendered_content

    @property
    def title(self):
        """Gets the title of this ProductIssue.

        Title of the issue.

        :return: The title of this ProductIssue.
        :rtype: str
        """
        return self._title

    @title.setter
    def title(self, title):
        """Sets the title of this ProductIssue.

        Title of the issue.

        :param title: The title of this ProductIssue.
        :type title: str
        """

        self._title = title
