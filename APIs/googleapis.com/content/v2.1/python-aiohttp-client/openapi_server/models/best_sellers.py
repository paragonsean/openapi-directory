# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.model_date import ModelDate
from openapi_server import util


class BestSellers(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, category_id: str=None, country_code: str=None, previous_rank: str=None, previous_relative_demand: str=None, rank: str=None, relative_demand: str=None, relative_demand_change: str=None, report_date: ModelDate=None, report_granularity: str=None):
        """BestSellers - a model defined in OpenAPI

        :param category_id: The category_id of this BestSellers.
        :param country_code: The country_code of this BestSellers.
        :param previous_rank: The previous_rank of this BestSellers.
        :param previous_relative_demand: The previous_relative_demand of this BestSellers.
        :param rank: The rank of this BestSellers.
        :param relative_demand: The relative_demand of this BestSellers.
        :param relative_demand_change: The relative_demand_change of this BestSellers.
        :param report_date: The report_date of this BestSellers.
        :param report_granularity: The report_granularity of this BestSellers.
        """
        self.openapi_types = {
            'category_id': str,
            'country_code': str,
            'previous_rank': str,
            'previous_relative_demand': str,
            'rank': str,
            'relative_demand': str,
            'relative_demand_change': str,
            'report_date': ModelDate,
            'report_granularity': str
        }

        self.attribute_map = {
            'category_id': 'categoryId',
            'country_code': 'countryCode',
            'previous_rank': 'previousRank',
            'previous_relative_demand': 'previousRelativeDemand',
            'rank': 'rank',
            'relative_demand': 'relativeDemand',
            'relative_demand_change': 'relativeDemandChange',
            'report_date': 'reportDate',
            'report_granularity': 'reportGranularity'
        }

        self._category_id = category_id
        self._country_code = country_code
        self._previous_rank = previous_rank
        self._previous_relative_demand = previous_relative_demand
        self._rank = rank
        self._relative_demand = relative_demand
        self._relative_demand_change = relative_demand_change
        self._report_date = report_date
        self._report_granularity = report_granularity

    @classmethod
    def from_dict(cls, dikt: dict) -> 'BestSellers':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The BestSellers of this BestSellers.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def category_id(self):
        """Gets the category_id of this BestSellers.

        Google product category ID to calculate the ranking for, represented in [Google's product taxonomy](https://support.google.com/merchants/answer/6324436). If a `WHERE` condition on `best_sellers.category_id` is not specified in the query, rankings for all top-level categories are returned.

        :return: The category_id of this BestSellers.
        :rtype: str
        """
        return self._category_id

    @category_id.setter
    def category_id(self, category_id):
        """Sets the category_id of this BestSellers.

        Google product category ID to calculate the ranking for, represented in [Google's product taxonomy](https://support.google.com/merchants/answer/6324436). If a `WHERE` condition on `best_sellers.category_id` is not specified in the query, rankings for all top-level categories are returned.

        :param category_id: The category_id of this BestSellers.
        :type category_id: str
        """

        self._category_id = category_id

    @property
    def country_code(self):
        """Gets the country_code of this BestSellers.

        Country where the ranking is calculated. A `WHERE` condition on `best_sellers.country_code` is required in the query.

        :return: The country_code of this BestSellers.
        :rtype: str
        """
        return self._country_code

    @country_code.setter
    def country_code(self, country_code):
        """Sets the country_code of this BestSellers.

        Country where the ranking is calculated. A `WHERE` condition on `best_sellers.country_code` is required in the query.

        :param country_code: The country_code of this BestSellers.
        :type country_code: str
        """

        self._country_code = country_code

    @property
    def previous_rank(self):
        """Gets the previous_rank of this BestSellers.

        Popularity rank in the previous week or month.

        :return: The previous_rank of this BestSellers.
        :rtype: str
        """
        return self._previous_rank

    @previous_rank.setter
    def previous_rank(self, previous_rank):
        """Sets the previous_rank of this BestSellers.

        Popularity rank in the previous week or month.

        :param previous_rank: The previous_rank of this BestSellers.
        :type previous_rank: str
        """

        self._previous_rank = previous_rank

    @property
    def previous_relative_demand(self):
        """Gets the previous_relative_demand of this BestSellers.

        Estimated demand in relation to the item with the highest popularity rank in the same category and country in the previous week or month.

        :return: The previous_relative_demand of this BestSellers.
        :rtype: str
        """
        return self._previous_relative_demand

    @previous_relative_demand.setter
    def previous_relative_demand(self, previous_relative_demand):
        """Sets the previous_relative_demand of this BestSellers.

        Estimated demand in relation to the item with the highest popularity rank in the same category and country in the previous week or month.

        :param previous_relative_demand: The previous_relative_demand of this BestSellers.
        :type previous_relative_demand: str
        """
        allowed_values = ["RELATIVE_DEMAND_UNSPECIFIED", "VERY_LOW", "LOW", "MEDIUM", "HIGH", "VERY_HIGH"]  # noqa: E501
        if previous_relative_demand not in allowed_values:
            raise ValueError(
                "Invalid value for `previous_relative_demand` ({0}), must be one of {1}"
                .format(previous_relative_demand, allowed_values)
            )

        self._previous_relative_demand = previous_relative_demand

    @property
    def rank(self):
        """Gets the rank of this BestSellers.

        Popularity on Shopping ads and free listings, in the selected category and country, based on the estimated number of units sold.

        :return: The rank of this BestSellers.
        :rtype: str
        """
        return self._rank

    @rank.setter
    def rank(self, rank):
        """Sets the rank of this BestSellers.

        Popularity on Shopping ads and free listings, in the selected category and country, based on the estimated number of units sold.

        :param rank: The rank of this BestSellers.
        :type rank: str
        """

        self._rank = rank

    @property
    def relative_demand(self):
        """Gets the relative_demand of this BestSellers.

        Estimated demand in relation to the item with the highest popularity rank in the same category and country.

        :return: The relative_demand of this BestSellers.
        :rtype: str
        """
        return self._relative_demand

    @relative_demand.setter
    def relative_demand(self, relative_demand):
        """Sets the relative_demand of this BestSellers.

        Estimated demand in relation to the item with the highest popularity rank in the same category and country.

        :param relative_demand: The relative_demand of this BestSellers.
        :type relative_demand: str
        """
        allowed_values = ["RELATIVE_DEMAND_UNSPECIFIED", "VERY_LOW", "LOW", "MEDIUM", "HIGH", "VERY_HIGH"]  # noqa: E501
        if relative_demand not in allowed_values:
            raise ValueError(
                "Invalid value for `relative_demand` ({0}), must be one of {1}"
                .format(relative_demand, allowed_values)
            )

        self._relative_demand = relative_demand

    @property
    def relative_demand_change(self):
        """Gets the relative_demand_change of this BestSellers.

        Change in the estimated demand. Whether it rose, sank or remained flat.

        :return: The relative_demand_change of this BestSellers.
        :rtype: str
        """
        return self._relative_demand_change

    @relative_demand_change.setter
    def relative_demand_change(self, relative_demand_change):
        """Sets the relative_demand_change of this BestSellers.

        Change in the estimated demand. Whether it rose, sank or remained flat.

        :param relative_demand_change: The relative_demand_change of this BestSellers.
        :type relative_demand_change: str
        """
        allowed_values = ["RELATIVE_DEMAND_CHANGE_TYPE_UNSPECIFIED", "SINKER", "FLAT", "RISER"]  # noqa: E501
        if relative_demand_change not in allowed_values:
            raise ValueError(
                "Invalid value for `relative_demand_change` ({0}), must be one of {1}"
                .format(relative_demand_change, allowed_values)
            )

        self._relative_demand_change = relative_demand_change

    @property
    def report_date(self):
        """Gets the report_date of this BestSellers.


        :return: The report_date of this BestSellers.
        :rtype: ModelDate
        """
        return self._report_date

    @report_date.setter
    def report_date(self, report_date):
        """Sets the report_date of this BestSellers.


        :param report_date: The report_date of this BestSellers.
        :type report_date: ModelDate
        """

        self._report_date = report_date

    @property
    def report_granularity(self):
        """Gets the report_granularity of this BestSellers.

        Granularity of the report. The ranking can be done over a week or a month timeframe. A `WHERE` condition on `best_sellers.report_granularity` is required in the query.

        :return: The report_granularity of this BestSellers.
        :rtype: str
        """
        return self._report_granularity

    @report_granularity.setter
    def report_granularity(self, report_granularity):
        """Sets the report_granularity of this BestSellers.

        Granularity of the report. The ranking can be done over a week or a month timeframe. A `WHERE` condition on `best_sellers.report_granularity` is required in the query.

        :param report_granularity: The report_granularity of this BestSellers.
        :type report_granularity: str
        """
        allowed_values = ["REPORT_GRANULARITY_UNSPECIFIED", "WEEKLY", "MONTHLY"]  # noqa: E501
        if report_granularity not in allowed_values:
            raise ValueError(
                "Invalid value for `report_granularity` ({0}), must be one of {1}"
                .format(report_granularity, allowed_values)
            )

        self._report_granularity = report_granularity
