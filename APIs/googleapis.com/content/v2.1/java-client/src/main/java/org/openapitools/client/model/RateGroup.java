/*
 * Content API for Shopping
 * Manage your product listings and accounts for Google Shopping
 *
 * The version of the OpenAPI document: v2.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CarrierRate;
import org.openapitools.client.model.Table;
import org.openapitools.client.model.Value;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * RateGroup
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:51:00.560037-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RateGroup {
  public static final String SERIALIZED_NAME_APPLICABLE_SHIPPING_LABELS = "applicableShippingLabels";
  @SerializedName(SERIALIZED_NAME_APPLICABLE_SHIPPING_LABELS)
  private List<String> applicableShippingLabels = new ArrayList<>();

  public static final String SERIALIZED_NAME_CARRIER_RATES = "carrierRates";
  @SerializedName(SERIALIZED_NAME_CARRIER_RATES)
  private List<CarrierRate> carrierRates = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAIN_TABLE = "mainTable";
  @SerializedName(SERIALIZED_NAME_MAIN_TABLE)
  private Table mainTable;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SINGLE_VALUE = "singleValue";
  @SerializedName(SERIALIZED_NAME_SINGLE_VALUE)
  private Value singleValue;

  public static final String SERIALIZED_NAME_SUBTABLES = "subtables";
  @SerializedName(SERIALIZED_NAME_SUBTABLES)
  private List<Table> subtables = new ArrayList<>();

  public RateGroup() {
  }

  public RateGroup applicableShippingLabels(List<String> applicableShippingLabels) {
    this.applicableShippingLabels = applicableShippingLabels;
    return this;
  }

  public RateGroup addApplicableShippingLabelsItem(String applicableShippingLabelsItem) {
    if (this.applicableShippingLabels == null) {
      this.applicableShippingLabels = new ArrayList<>();
    }
    this.applicableShippingLabels.add(applicableShippingLabelsItem);
    return this;
  }

  /**
   * A list of shipping labels defining the products to which this rate group applies to. This is a disjunction: only one of the labels has to match for the rate group to apply. May only be empty for the last rate group of a service. Required.
   * @return applicableShippingLabels
   */
  @javax.annotation.Nullable
  public List<String> getApplicableShippingLabels() {
    return applicableShippingLabels;
  }

  public void setApplicableShippingLabels(List<String> applicableShippingLabels) {
    this.applicableShippingLabels = applicableShippingLabels;
  }


  public RateGroup carrierRates(List<CarrierRate> carrierRates) {
    this.carrierRates = carrierRates;
    return this;
  }

  public RateGroup addCarrierRatesItem(CarrierRate carrierRatesItem) {
    if (this.carrierRates == null) {
      this.carrierRates = new ArrayList<>();
    }
    this.carrierRates.add(carrierRatesItem);
    return this;
  }

  /**
   * A list of carrier rates that can be referred to by &#x60;mainTable&#x60; or &#x60;singleValue&#x60;.
   * @return carrierRates
   */
  @javax.annotation.Nullable
  public List<CarrierRate> getCarrierRates() {
    return carrierRates;
  }

  public void setCarrierRates(List<CarrierRate> carrierRates) {
    this.carrierRates = carrierRates;
  }


  public RateGroup mainTable(Table mainTable) {
    this.mainTable = mainTable;
    return this;
  }

  /**
   * Get mainTable
   * @return mainTable
   */
  @javax.annotation.Nullable
  public Table getMainTable() {
    return mainTable;
  }

  public void setMainTable(Table mainTable) {
    this.mainTable = mainTable;
  }


  public RateGroup name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of the rate group. Optional. If set has to be unique within shipping service.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public RateGroup singleValue(Value singleValue) {
    this.singleValue = singleValue;
    return this;
  }

  /**
   * Get singleValue
   * @return singleValue
   */
  @javax.annotation.Nullable
  public Value getSingleValue() {
    return singleValue;
  }

  public void setSingleValue(Value singleValue) {
    this.singleValue = singleValue;
  }


  public RateGroup subtables(List<Table> subtables) {
    this.subtables = subtables;
    return this;
  }

  public RateGroup addSubtablesItem(Table subtablesItem) {
    if (this.subtables == null) {
      this.subtables = new ArrayList<>();
    }
    this.subtables.add(subtablesItem);
    return this;
  }

  /**
   * A list of subtables referred to by &#x60;mainTable&#x60;. Can only be set if &#x60;mainTable&#x60; is set.
   * @return subtables
   */
  @javax.annotation.Nullable
  public List<Table> getSubtables() {
    return subtables;
  }

  public void setSubtables(List<Table> subtables) {
    this.subtables = subtables;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RateGroup rateGroup = (RateGroup) o;
    return Objects.equals(this.applicableShippingLabels, rateGroup.applicableShippingLabels) &&
        Objects.equals(this.carrierRates, rateGroup.carrierRates) &&
        Objects.equals(this.mainTable, rateGroup.mainTable) &&
        Objects.equals(this.name, rateGroup.name) &&
        Objects.equals(this.singleValue, rateGroup.singleValue) &&
        Objects.equals(this.subtables, rateGroup.subtables);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicableShippingLabels, carrierRates, mainTable, name, singleValue, subtables);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RateGroup {\n");
    sb.append("    applicableShippingLabels: ").append(toIndentedString(applicableShippingLabels)).append("\n");
    sb.append("    carrierRates: ").append(toIndentedString(carrierRates)).append("\n");
    sb.append("    mainTable: ").append(toIndentedString(mainTable)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    singleValue: ").append(toIndentedString(singleValue)).append("\n");
    sb.append("    subtables: ").append(toIndentedString(subtables)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("applicableShippingLabels");
    openapiFields.add("carrierRates");
    openapiFields.add("mainTable");
    openapiFields.add("name");
    openapiFields.add("singleValue");
    openapiFields.add("subtables");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RateGroup
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RateGroup.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RateGroup is not found in the empty JSON string", RateGroup.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RateGroup.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RateGroup` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("applicableShippingLabels") != null && !jsonObj.get("applicableShippingLabels").isJsonNull() && !jsonObj.get("applicableShippingLabels").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `applicableShippingLabels` to be an array in the JSON string but got `%s`", jsonObj.get("applicableShippingLabels").toString()));
      }
      if (jsonObj.get("carrierRates") != null && !jsonObj.get("carrierRates").isJsonNull()) {
        JsonArray jsonArraycarrierRates = jsonObj.getAsJsonArray("carrierRates");
        if (jsonArraycarrierRates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("carrierRates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `carrierRates` to be an array in the JSON string but got `%s`", jsonObj.get("carrierRates").toString()));
          }

          // validate the optional field `carrierRates` (array)
          for (int i = 0; i < jsonArraycarrierRates.size(); i++) {
            CarrierRate.validateJsonElement(jsonArraycarrierRates.get(i));
          };
        }
      }
      // validate the optional field `mainTable`
      if (jsonObj.get("mainTable") != null && !jsonObj.get("mainTable").isJsonNull()) {
        Table.validateJsonElement(jsonObj.get("mainTable"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `singleValue`
      if (jsonObj.get("singleValue") != null && !jsonObj.get("singleValue").isJsonNull()) {
        Value.validateJsonElement(jsonObj.get("singleValue"));
      }
      if (jsonObj.get("subtables") != null && !jsonObj.get("subtables").isJsonNull()) {
        JsonArray jsonArraysubtables = jsonObj.getAsJsonArray("subtables");
        if (jsonArraysubtables != null) {
          // ensure the json data is an array
          if (!jsonObj.get("subtables").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `subtables` to be an array in the JSON string but got `%s`", jsonObj.get("subtables").toString()));
          }

          // validate the optional field `subtables` (array)
          for (int i = 0; i < jsonArraysubtables.size(); i++) {
            Table.validateJsonElement(jsonArraysubtables.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RateGroup.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RateGroup' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RateGroup> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RateGroup.class));

       return (TypeAdapter<T>) new TypeAdapter<RateGroup>() {
           @Override
           public void write(JsonWriter out, RateGroup value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RateGroup read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RateGroup given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RateGroup
   * @throws IOException if the JSON string is invalid with respect to RateGroup
   */
  public static RateGroup fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RateGroup.class);
  }

  /**
   * Convert an instance of RateGroup to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

