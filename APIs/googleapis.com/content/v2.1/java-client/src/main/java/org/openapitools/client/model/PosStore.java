/*
 * Content API for Shopping
 * Manage your product listings and accounts for Google Shopping
 *
 * The version of the OpenAPI document: v2.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Store resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:51:00.560037-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PosStore {
  public static final String SERIALIZED_NAME_GCID_CATEGORY = "gcidCategory";
  @SerializedName(SERIALIZED_NAME_GCID_CATEGORY)
  private List<String> gcidCategory = new ArrayList<>();

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_MATCHING_STATUS = "matchingStatus";
  @SerializedName(SERIALIZED_NAME_MATCHING_STATUS)
  private String matchingStatus;

  public static final String SERIALIZED_NAME_MATCHING_STATUS_HINT = "matchingStatusHint";
  @SerializedName(SERIALIZED_NAME_MATCHING_STATUS_HINT)
  private String matchingStatusHint;

  public static final String SERIALIZED_NAME_PHONE_NUMBER = "phoneNumber";
  @SerializedName(SERIALIZED_NAME_PHONE_NUMBER)
  private String phoneNumber;

  public static final String SERIALIZED_NAME_PLACE_ID = "placeId";
  @SerializedName(SERIALIZED_NAME_PLACE_ID)
  private String placeId;

  public static final String SERIALIZED_NAME_STORE_ADDRESS = "storeAddress";
  @SerializedName(SERIALIZED_NAME_STORE_ADDRESS)
  private String storeAddress;

  public static final String SERIALIZED_NAME_STORE_CODE = "storeCode";
  @SerializedName(SERIALIZED_NAME_STORE_CODE)
  private String storeCode;

  public static final String SERIALIZED_NAME_STORE_NAME = "storeName";
  @SerializedName(SERIALIZED_NAME_STORE_NAME)
  private String storeName;

  public static final String SERIALIZED_NAME_WEBSITE_URL = "websiteUrl";
  @SerializedName(SERIALIZED_NAME_WEBSITE_URL)
  private String websiteUrl;

  public PosStore() {
  }

  public PosStore(
     String matchingStatus, 
     String matchingStatusHint
  ) {
    this();
    this.matchingStatus = matchingStatus;
    this.matchingStatusHint = matchingStatusHint;
  }

  public PosStore gcidCategory(List<String> gcidCategory) {
    this.gcidCategory = gcidCategory;
    return this;
  }

  public PosStore addGcidCategoryItem(String gcidCategoryItem) {
    if (this.gcidCategory == null) {
      this.gcidCategory = new ArrayList<>();
    }
    this.gcidCategory.add(gcidCategoryItem);
    return this;
  }

  /**
   * The business type of the store.
   * @return gcidCategory
   */
  @javax.annotation.Nullable
  public List<String> getGcidCategory() {
    return gcidCategory;
  }

  public void setGcidCategory(List<String> gcidCategory) {
    this.gcidCategory = gcidCategory;
  }


  public PosStore kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Identifies what kind of resource this is. Value: the fixed string \&quot;&#x60;content#posStore&#x60;\&quot;
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  /**
   * Output only. The matching status of POS store and Google Business Profile store. Possible values are: - \&quot;&#x60;matched&#x60;\&quot;: The POS store is successfully matched with the Google Business Profile store. - \&quot;&#x60;failed&#x60;\&quot;: The POS store is not matched with the Google Business Profile store. See matching_status_hint for further details. Note that there is up to 48 hours propagation delay for changes in Merchant Center (e.g. creation of new account, accounts linking) and Google Business Profile (e.g. store address update) which may affect the matching status. In such cases, after a delay call [pos.list](https://developers.google.com/shopping-content/reference/rest/v2.1/pos/list) to retrieve the updated matching status. 
   * @return matchingStatus
   */
  @javax.annotation.Nullable
  public String getMatchingStatus() {
    return matchingStatus;
  }



  /**
   * Output only. The hint of why the matching has failed. This is only set when matching_status&#x3D;failed. Possible values are: - \&quot;&#x60;linked-store-not-found&#x60;\&quot;: There aren&#39;t any Google Business Profile stores available for matching. Connect your Merchant Center account with the Google Business Profile account. Or add a new Google Business Profile store corresponding to the POS store. - \&quot;&#x60;store-match-not-found&#x60;\&quot;: The provided POS store couldn&#39;t be matched to any of the connected Google Business Profile stores. Merchant Center account is connected correctly and stores are available on Google Business Profile, but POS store location address does not match with Google Business Profile stores&#39; addresses. Update POS store address or Google Business Profile store address to match correctly. - \&quot;&#x60;store-match-unverified&#x60;\&quot;: The provided POS store couldn&#39;t be matched to any of the connected Google Business Profile stores, as the matched Google Business Profile store is unverified. Go through the Google Business Profile verification process to match correctly. 
   * @return matchingStatusHint
   */
  @javax.annotation.Nullable
  public String getMatchingStatusHint() {
    return matchingStatusHint;
  }



  public PosStore phoneNumber(String phoneNumber) {
    this.phoneNumber = phoneNumber;
    return this;
  }

  /**
   * The store phone number.
   * @return phoneNumber
   */
  @javax.annotation.Nullable
  public String getPhoneNumber() {
    return phoneNumber;
  }

  public void setPhoneNumber(String phoneNumber) {
    this.phoneNumber = phoneNumber;
  }


  public PosStore placeId(String placeId) {
    this.placeId = placeId;
    return this;
  }

  /**
   * The Google Place Id of the store location.
   * @return placeId
   */
  @javax.annotation.Nullable
  public String getPlaceId() {
    return placeId;
  }

  public void setPlaceId(String placeId) {
    this.placeId = placeId;
  }


  public PosStore storeAddress(String storeAddress) {
    this.storeAddress = storeAddress;
    return this;
  }

  /**
   * Required. The street address of the store.
   * @return storeAddress
   */
  @javax.annotation.Nullable
  public String getStoreAddress() {
    return storeAddress;
  }

  public void setStoreAddress(String storeAddress) {
    this.storeAddress = storeAddress;
  }


  public PosStore storeCode(String storeCode) {
    this.storeCode = storeCode;
    return this;
  }

  /**
   * Required. A store identifier that is unique for the given merchant.
   * @return storeCode
   */
  @javax.annotation.Nullable
  public String getStoreCode() {
    return storeCode;
  }

  public void setStoreCode(String storeCode) {
    this.storeCode = storeCode;
  }


  public PosStore storeName(String storeName) {
    this.storeName = storeName;
    return this;
  }

  /**
   * The merchant or store name.
   * @return storeName
   */
  @javax.annotation.Nullable
  public String getStoreName() {
    return storeName;
  }

  public void setStoreName(String storeName) {
    this.storeName = storeName;
  }


  public PosStore websiteUrl(String websiteUrl) {
    this.websiteUrl = websiteUrl;
    return this;
  }

  /**
   * The website url for the store or merchant.
   * @return websiteUrl
   */
  @javax.annotation.Nullable
  public String getWebsiteUrl() {
    return websiteUrl;
  }

  public void setWebsiteUrl(String websiteUrl) {
    this.websiteUrl = websiteUrl;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PosStore posStore = (PosStore) o;
    return Objects.equals(this.gcidCategory, posStore.gcidCategory) &&
        Objects.equals(this.kind, posStore.kind) &&
        Objects.equals(this.matchingStatus, posStore.matchingStatus) &&
        Objects.equals(this.matchingStatusHint, posStore.matchingStatusHint) &&
        Objects.equals(this.phoneNumber, posStore.phoneNumber) &&
        Objects.equals(this.placeId, posStore.placeId) &&
        Objects.equals(this.storeAddress, posStore.storeAddress) &&
        Objects.equals(this.storeCode, posStore.storeCode) &&
        Objects.equals(this.storeName, posStore.storeName) &&
        Objects.equals(this.websiteUrl, posStore.websiteUrl);
  }

  @Override
  public int hashCode() {
    return Objects.hash(gcidCategory, kind, matchingStatus, matchingStatusHint, phoneNumber, placeId, storeAddress, storeCode, storeName, websiteUrl);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PosStore {\n");
    sb.append("    gcidCategory: ").append(toIndentedString(gcidCategory)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    matchingStatus: ").append(toIndentedString(matchingStatus)).append("\n");
    sb.append("    matchingStatusHint: ").append(toIndentedString(matchingStatusHint)).append("\n");
    sb.append("    phoneNumber: ").append(toIndentedString(phoneNumber)).append("\n");
    sb.append("    placeId: ").append(toIndentedString(placeId)).append("\n");
    sb.append("    storeAddress: ").append(toIndentedString(storeAddress)).append("\n");
    sb.append("    storeCode: ").append(toIndentedString(storeCode)).append("\n");
    sb.append("    storeName: ").append(toIndentedString(storeName)).append("\n");
    sb.append("    websiteUrl: ").append(toIndentedString(websiteUrl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("gcidCategory");
    openapiFields.add("kind");
    openapiFields.add("matchingStatus");
    openapiFields.add("matchingStatusHint");
    openapiFields.add("phoneNumber");
    openapiFields.add("placeId");
    openapiFields.add("storeAddress");
    openapiFields.add("storeCode");
    openapiFields.add("storeName");
    openapiFields.add("websiteUrl");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PosStore
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PosStore.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PosStore is not found in the empty JSON string", PosStore.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PosStore.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PosStore` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("gcidCategory") != null && !jsonObj.get("gcidCategory").isJsonNull() && !jsonObj.get("gcidCategory").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `gcidCategory` to be an array in the JSON string but got `%s`", jsonObj.get("gcidCategory").toString()));
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if ((jsonObj.get("matchingStatus") != null && !jsonObj.get("matchingStatus").isJsonNull()) && !jsonObj.get("matchingStatus").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchingStatus` to be a primitive type in the JSON string but got `%s`", jsonObj.get("matchingStatus").toString()));
      }
      if ((jsonObj.get("matchingStatusHint") != null && !jsonObj.get("matchingStatusHint").isJsonNull()) && !jsonObj.get("matchingStatusHint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `matchingStatusHint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("matchingStatusHint").toString()));
      }
      if ((jsonObj.get("phoneNumber") != null && !jsonObj.get("phoneNumber").isJsonNull()) && !jsonObj.get("phoneNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `phoneNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("phoneNumber").toString()));
      }
      if ((jsonObj.get("placeId") != null && !jsonObj.get("placeId").isJsonNull()) && !jsonObj.get("placeId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `placeId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("placeId").toString()));
      }
      if ((jsonObj.get("storeAddress") != null && !jsonObj.get("storeAddress").isJsonNull()) && !jsonObj.get("storeAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storeAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storeAddress").toString()));
      }
      if ((jsonObj.get("storeCode") != null && !jsonObj.get("storeCode").isJsonNull()) && !jsonObj.get("storeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storeCode").toString()));
      }
      if ((jsonObj.get("storeName") != null && !jsonObj.get("storeName").isJsonNull()) && !jsonObj.get("storeName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storeName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storeName").toString()));
      }
      if ((jsonObj.get("websiteUrl") != null && !jsonObj.get("websiteUrl").isJsonNull()) && !jsonObj.get("websiteUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `websiteUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("websiteUrl").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PosStore.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PosStore' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PosStore> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PosStore.class));

       return (TypeAdapter<T>) new TypeAdapter<PosStore>() {
           @Override
           public void write(JsonWriter out, PosStore value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PosStore read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PosStore given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PosStore
   * @throws IOException if the JSON string is invalid with respect to PosStore
   */
  public static PosStore fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PosStore.class);
  }

  /**
   * Convert an instance of PosStore to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

