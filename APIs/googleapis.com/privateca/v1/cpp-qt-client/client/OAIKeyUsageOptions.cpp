/**
 * Certificate Authority API
 * The Certificate Authority Service API is a highly-available, scalable service that enables you to simplify and automate the management of private certificate authorities (CAs) while staying in control of your private keys. 
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIKeyUsageOptions.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIKeyUsageOptions::OAIKeyUsageOptions(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIKeyUsageOptions::OAIKeyUsageOptions() {
    this->initializeModel();
}

OAIKeyUsageOptions::~OAIKeyUsageOptions() {}

void OAIKeyUsageOptions::initializeModel() {

    m_cert_sign_isSet = false;
    m_cert_sign_isValid = false;

    m_content_commitment_isSet = false;
    m_content_commitment_isValid = false;

    m_crl_sign_isSet = false;
    m_crl_sign_isValid = false;

    m_data_encipherment_isSet = false;
    m_data_encipherment_isValid = false;

    m_decipher_only_isSet = false;
    m_decipher_only_isValid = false;

    m_digital_signature_isSet = false;
    m_digital_signature_isValid = false;

    m_encipher_only_isSet = false;
    m_encipher_only_isValid = false;

    m_key_agreement_isSet = false;
    m_key_agreement_isValid = false;

    m_key_encipherment_isSet = false;
    m_key_encipherment_isValid = false;
}

void OAIKeyUsageOptions::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIKeyUsageOptions::fromJsonObject(QJsonObject json) {

    m_cert_sign_isValid = ::OpenAPI::fromJsonValue(m_cert_sign, json[QString("certSign")]);
    m_cert_sign_isSet = !json[QString("certSign")].isNull() && m_cert_sign_isValid;

    m_content_commitment_isValid = ::OpenAPI::fromJsonValue(m_content_commitment, json[QString("contentCommitment")]);
    m_content_commitment_isSet = !json[QString("contentCommitment")].isNull() && m_content_commitment_isValid;

    m_crl_sign_isValid = ::OpenAPI::fromJsonValue(m_crl_sign, json[QString("crlSign")]);
    m_crl_sign_isSet = !json[QString("crlSign")].isNull() && m_crl_sign_isValid;

    m_data_encipherment_isValid = ::OpenAPI::fromJsonValue(m_data_encipherment, json[QString("dataEncipherment")]);
    m_data_encipherment_isSet = !json[QString("dataEncipherment")].isNull() && m_data_encipherment_isValid;

    m_decipher_only_isValid = ::OpenAPI::fromJsonValue(m_decipher_only, json[QString("decipherOnly")]);
    m_decipher_only_isSet = !json[QString("decipherOnly")].isNull() && m_decipher_only_isValid;

    m_digital_signature_isValid = ::OpenAPI::fromJsonValue(m_digital_signature, json[QString("digitalSignature")]);
    m_digital_signature_isSet = !json[QString("digitalSignature")].isNull() && m_digital_signature_isValid;

    m_encipher_only_isValid = ::OpenAPI::fromJsonValue(m_encipher_only, json[QString("encipherOnly")]);
    m_encipher_only_isSet = !json[QString("encipherOnly")].isNull() && m_encipher_only_isValid;

    m_key_agreement_isValid = ::OpenAPI::fromJsonValue(m_key_agreement, json[QString("keyAgreement")]);
    m_key_agreement_isSet = !json[QString("keyAgreement")].isNull() && m_key_agreement_isValid;

    m_key_encipherment_isValid = ::OpenAPI::fromJsonValue(m_key_encipherment, json[QString("keyEncipherment")]);
    m_key_encipherment_isSet = !json[QString("keyEncipherment")].isNull() && m_key_encipherment_isValid;
}

QString OAIKeyUsageOptions::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIKeyUsageOptions::asJsonObject() const {
    QJsonObject obj;
    if (m_cert_sign_isSet) {
        obj.insert(QString("certSign"), ::OpenAPI::toJsonValue(m_cert_sign));
    }
    if (m_content_commitment_isSet) {
        obj.insert(QString("contentCommitment"), ::OpenAPI::toJsonValue(m_content_commitment));
    }
    if (m_crl_sign_isSet) {
        obj.insert(QString("crlSign"), ::OpenAPI::toJsonValue(m_crl_sign));
    }
    if (m_data_encipherment_isSet) {
        obj.insert(QString("dataEncipherment"), ::OpenAPI::toJsonValue(m_data_encipherment));
    }
    if (m_decipher_only_isSet) {
        obj.insert(QString("decipherOnly"), ::OpenAPI::toJsonValue(m_decipher_only));
    }
    if (m_digital_signature_isSet) {
        obj.insert(QString("digitalSignature"), ::OpenAPI::toJsonValue(m_digital_signature));
    }
    if (m_encipher_only_isSet) {
        obj.insert(QString("encipherOnly"), ::OpenAPI::toJsonValue(m_encipher_only));
    }
    if (m_key_agreement_isSet) {
        obj.insert(QString("keyAgreement"), ::OpenAPI::toJsonValue(m_key_agreement));
    }
    if (m_key_encipherment_isSet) {
        obj.insert(QString("keyEncipherment"), ::OpenAPI::toJsonValue(m_key_encipherment));
    }
    return obj;
}

bool OAIKeyUsageOptions::isCertSign() const {
    return m_cert_sign;
}
void OAIKeyUsageOptions::setCertSign(const bool &cert_sign) {
    m_cert_sign = cert_sign;
    m_cert_sign_isSet = true;
}

bool OAIKeyUsageOptions::is_cert_sign_Set() const{
    return m_cert_sign_isSet;
}

bool OAIKeyUsageOptions::is_cert_sign_Valid() const{
    return m_cert_sign_isValid;
}

bool OAIKeyUsageOptions::isContentCommitment() const {
    return m_content_commitment;
}
void OAIKeyUsageOptions::setContentCommitment(const bool &content_commitment) {
    m_content_commitment = content_commitment;
    m_content_commitment_isSet = true;
}

bool OAIKeyUsageOptions::is_content_commitment_Set() const{
    return m_content_commitment_isSet;
}

bool OAIKeyUsageOptions::is_content_commitment_Valid() const{
    return m_content_commitment_isValid;
}

bool OAIKeyUsageOptions::isCrlSign() const {
    return m_crl_sign;
}
void OAIKeyUsageOptions::setCrlSign(const bool &crl_sign) {
    m_crl_sign = crl_sign;
    m_crl_sign_isSet = true;
}

bool OAIKeyUsageOptions::is_crl_sign_Set() const{
    return m_crl_sign_isSet;
}

bool OAIKeyUsageOptions::is_crl_sign_Valid() const{
    return m_crl_sign_isValid;
}

bool OAIKeyUsageOptions::isDataEncipherment() const {
    return m_data_encipherment;
}
void OAIKeyUsageOptions::setDataEncipherment(const bool &data_encipherment) {
    m_data_encipherment = data_encipherment;
    m_data_encipherment_isSet = true;
}

bool OAIKeyUsageOptions::is_data_encipherment_Set() const{
    return m_data_encipherment_isSet;
}

bool OAIKeyUsageOptions::is_data_encipherment_Valid() const{
    return m_data_encipherment_isValid;
}

bool OAIKeyUsageOptions::isDecipherOnly() const {
    return m_decipher_only;
}
void OAIKeyUsageOptions::setDecipherOnly(const bool &decipher_only) {
    m_decipher_only = decipher_only;
    m_decipher_only_isSet = true;
}

bool OAIKeyUsageOptions::is_decipher_only_Set() const{
    return m_decipher_only_isSet;
}

bool OAIKeyUsageOptions::is_decipher_only_Valid() const{
    return m_decipher_only_isValid;
}

bool OAIKeyUsageOptions::isDigitalSignature() const {
    return m_digital_signature;
}
void OAIKeyUsageOptions::setDigitalSignature(const bool &digital_signature) {
    m_digital_signature = digital_signature;
    m_digital_signature_isSet = true;
}

bool OAIKeyUsageOptions::is_digital_signature_Set() const{
    return m_digital_signature_isSet;
}

bool OAIKeyUsageOptions::is_digital_signature_Valid() const{
    return m_digital_signature_isValid;
}

bool OAIKeyUsageOptions::isEncipherOnly() const {
    return m_encipher_only;
}
void OAIKeyUsageOptions::setEncipherOnly(const bool &encipher_only) {
    m_encipher_only = encipher_only;
    m_encipher_only_isSet = true;
}

bool OAIKeyUsageOptions::is_encipher_only_Set() const{
    return m_encipher_only_isSet;
}

bool OAIKeyUsageOptions::is_encipher_only_Valid() const{
    return m_encipher_only_isValid;
}

bool OAIKeyUsageOptions::isKeyAgreement() const {
    return m_key_agreement;
}
void OAIKeyUsageOptions::setKeyAgreement(const bool &key_agreement) {
    m_key_agreement = key_agreement;
    m_key_agreement_isSet = true;
}

bool OAIKeyUsageOptions::is_key_agreement_Set() const{
    return m_key_agreement_isSet;
}

bool OAIKeyUsageOptions::is_key_agreement_Valid() const{
    return m_key_agreement_isValid;
}

bool OAIKeyUsageOptions::isKeyEncipherment() const {
    return m_key_encipherment;
}
void OAIKeyUsageOptions::setKeyEncipherment(const bool &key_encipherment) {
    m_key_encipherment = key_encipherment;
    m_key_encipherment_isSet = true;
}

bool OAIKeyUsageOptions::is_key_encipherment_Set() const{
    return m_key_encipherment_isSet;
}

bool OAIKeyUsageOptions::is_key_encipherment_Valid() const{
    return m_key_encipherment_isValid;
}

bool OAIKeyUsageOptions::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cert_sign_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_content_commitment_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_crl_sign_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_data_encipherment_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_decipher_only_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_digital_signature_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_encipher_only_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_key_agreement_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_key_encipherment_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIKeyUsageOptions::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
