/*
 * Certificate Authority API
 * The Certificate Authority Service API is a highly-available, scalable service that enables you to simplify and automate the management of private certificate authorities (CAs) while staying in control of your private keys. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.CertificateConfig;
import org.openapitools.client.model.CertificateDescription;
import org.openapitools.client.model.RevocationDetails;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Certificate corresponds to a signed X.509 certificate issued by a CertificateAuthority.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:16.257139-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Certificate {
  public static final String SERIALIZED_NAME_CERTIFICATE_DESCRIPTION = "certificateDescription";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_DESCRIPTION)
  private CertificateDescription certificateDescription;

  public static final String SERIALIZED_NAME_CERTIFICATE_TEMPLATE = "certificateTemplate";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_TEMPLATE)
  private String certificateTemplate;

  public static final String SERIALIZED_NAME_CONFIG = "config";
  @SerializedName(SERIALIZED_NAME_CONFIG)
  private CertificateConfig config;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_ISSUER_CERTIFICATE_AUTHORITY = "issuerCertificateAuthority";
  @SerializedName(SERIALIZED_NAME_ISSUER_CERTIFICATE_AUTHORITY)
  private String issuerCertificateAuthority;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LIFETIME = "lifetime";
  @SerializedName(SERIALIZED_NAME_LIFETIME)
  private String lifetime;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PEM_CERTIFICATE = "pemCertificate";
  @SerializedName(SERIALIZED_NAME_PEM_CERTIFICATE)
  private String pemCertificate;

  public static final String SERIALIZED_NAME_PEM_CERTIFICATE_CHAIN = "pemCertificateChain";
  @SerializedName(SERIALIZED_NAME_PEM_CERTIFICATE_CHAIN)
  private List<String> pemCertificateChain = new ArrayList<>();

  public static final String SERIALIZED_NAME_PEM_CSR = "pemCsr";
  @SerializedName(SERIALIZED_NAME_PEM_CSR)
  private String pemCsr;

  public static final String SERIALIZED_NAME_REVOCATION_DETAILS = "revocationDetails";
  @SerializedName(SERIALIZED_NAME_REVOCATION_DETAILS)
  private RevocationDetails revocationDetails;

  /**
   * Immutable. Specifies how the Certificate&#39;s identity fields are to be decided. If this is omitted, the &#x60;DEFAULT&#x60; subject mode will be used.
   */
  @JsonAdapter(SubjectModeEnum.Adapter.class)
  public enum SubjectModeEnum {
    SUBJECT_REQUEST_MODE_UNSPECIFIED("SUBJECT_REQUEST_MODE_UNSPECIFIED"),
    
    DEFAULT("DEFAULT"),
    
    REFLECTED_SPIFFE("REFLECTED_SPIFFE");

    private String value;

    SubjectModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SubjectModeEnum fromValue(String value) {
      for (SubjectModeEnum b : SubjectModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SubjectModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SubjectModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SubjectModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SubjectModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SubjectModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SUBJECT_MODE = "subjectMode";
  @SerializedName(SERIALIZED_NAME_SUBJECT_MODE)
  private SubjectModeEnum subjectMode;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public Certificate() {
  }

  public Certificate(
     String createTime, 
     String issuerCertificateAuthority, 
     String name, 
     String pemCertificate, 
     List<String> pemCertificateChain, 
     String updateTime
  ) {
    this();
    this.createTime = createTime;
    this.issuerCertificateAuthority = issuerCertificateAuthority;
    this.name = name;
    this.pemCertificate = pemCertificate;
    this.pemCertificateChain = pemCertificateChain;
    this.updateTime = updateTime;
  }

  public Certificate certificateDescription(CertificateDescription certificateDescription) {
    this.certificateDescription = certificateDescription;
    return this;
  }

  /**
   * Get certificateDescription
   * @return certificateDescription
   */
  @javax.annotation.Nullable
  public CertificateDescription getCertificateDescription() {
    return certificateDescription;
  }

  public void setCertificateDescription(CertificateDescription certificateDescription) {
    this.certificateDescription = certificateDescription;
  }


  public Certificate certificateTemplate(String certificateTemplate) {
    this.certificateTemplate = certificateTemplate;
    return this;
  }

  /**
   * Immutable. The resource name for a CertificateTemplate used to issue this certificate, in the format &#x60;projects/_*_/locations/_*_/certificateTemplates/_*&#x60;. If this is specified, the caller must have the necessary permission to use this template. If this is omitted, no template will be used. This template must be in the same location as the Certificate.
   * @return certificateTemplate
   */
  @javax.annotation.Nullable
  public String getCertificateTemplate() {
    return certificateTemplate;
  }

  public void setCertificateTemplate(String certificateTemplate) {
    this.certificateTemplate = certificateTemplate;
  }


  public Certificate config(CertificateConfig config) {
    this.config = config;
    return this;
  }

  /**
   * Get config
   * @return config
   */
  @javax.annotation.Nullable
  public CertificateConfig getConfig() {
    return config;
  }

  public void setConfig(CertificateConfig config) {
    this.config = config;
  }


  /**
   * Output only. The time at which this Certificate was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  /**
   * Output only. The resource name of the issuing CertificateAuthority in the format &#x60;projects/_*_/locations/_*_/caPools/_*_/certificateAuthorities/_*&#x60;.
   * @return issuerCertificateAuthority
   */
  @javax.annotation.Nullable
  public String getIssuerCertificateAuthority() {
    return issuerCertificateAuthority;
  }



  public Certificate labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Certificate putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Optional. Labels with user-defined metadata.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public Certificate lifetime(String lifetime) {
    this.lifetime = lifetime;
    return this;
  }

  /**
   * Required. Immutable. The desired lifetime of a certificate. Used to create the \&quot;not_before_time\&quot; and \&quot;not_after_time\&quot; fields inside an X.509 certificate. Note that the lifetime may be truncated if it would extend past the life of any certificate authority in the issuing chain.
   * @return lifetime
   */
  @javax.annotation.Nullable
  public String getLifetime() {
    return lifetime;
  }

  public void setLifetime(String lifetime) {
    this.lifetime = lifetime;
  }


  /**
   * Output only. The resource name for this Certificate in the format &#x60;projects/_*_/locations/_*_/caPools/_*_/certificates/_*&#x60;.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  /**
   * Output only. The pem-encoded, signed X.509 certificate.
   * @return pemCertificate
   */
  @javax.annotation.Nullable
  public String getPemCertificate() {
    return pemCertificate;
  }



  /**
   * Output only. The chain that may be used to verify the X.509 certificate. Expected to be in issuer-to-root order according to RFC 5246.
   * @return pemCertificateChain
   */
  @javax.annotation.Nullable
  public List<String> getPemCertificateChain() {
    return pemCertificateChain;
  }



  public Certificate pemCsr(String pemCsr) {
    this.pemCsr = pemCsr;
    return this;
  }

  /**
   * Immutable. A pem-encoded X.509 certificate signing request (CSR).
   * @return pemCsr
   */
  @javax.annotation.Nullable
  public String getPemCsr() {
    return pemCsr;
  }

  public void setPemCsr(String pemCsr) {
    this.pemCsr = pemCsr;
  }


  public Certificate revocationDetails(RevocationDetails revocationDetails) {
    this.revocationDetails = revocationDetails;
    return this;
  }

  /**
   * Get revocationDetails
   * @return revocationDetails
   */
  @javax.annotation.Nullable
  public RevocationDetails getRevocationDetails() {
    return revocationDetails;
  }

  public void setRevocationDetails(RevocationDetails revocationDetails) {
    this.revocationDetails = revocationDetails;
  }


  public Certificate subjectMode(SubjectModeEnum subjectMode) {
    this.subjectMode = subjectMode;
    return this;
  }

  /**
   * Immutable. Specifies how the Certificate&#39;s identity fields are to be decided. If this is omitted, the &#x60;DEFAULT&#x60; subject mode will be used.
   * @return subjectMode
   */
  @javax.annotation.Nullable
  public SubjectModeEnum getSubjectMode() {
    return subjectMode;
  }

  public void setSubjectMode(SubjectModeEnum subjectMode) {
    this.subjectMode = subjectMode;
  }


  /**
   * Output only. The time at which this Certificate was updated.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Certificate certificate = (Certificate) o;
    return Objects.equals(this.certificateDescription, certificate.certificateDescription) &&
        Objects.equals(this.certificateTemplate, certificate.certificateTemplate) &&
        Objects.equals(this.config, certificate.config) &&
        Objects.equals(this.createTime, certificate.createTime) &&
        Objects.equals(this.issuerCertificateAuthority, certificate.issuerCertificateAuthority) &&
        Objects.equals(this.labels, certificate.labels) &&
        Objects.equals(this.lifetime, certificate.lifetime) &&
        Objects.equals(this.name, certificate.name) &&
        Objects.equals(this.pemCertificate, certificate.pemCertificate) &&
        Objects.equals(this.pemCertificateChain, certificate.pemCertificateChain) &&
        Objects.equals(this.pemCsr, certificate.pemCsr) &&
        Objects.equals(this.revocationDetails, certificate.revocationDetails) &&
        Objects.equals(this.subjectMode, certificate.subjectMode) &&
        Objects.equals(this.updateTime, certificate.updateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(certificateDescription, certificateTemplate, config, createTime, issuerCertificateAuthority, labels, lifetime, name, pemCertificate, pemCertificateChain, pemCsr, revocationDetails, subjectMode, updateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Certificate {\n");
    sb.append("    certificateDescription: ").append(toIndentedString(certificateDescription)).append("\n");
    sb.append("    certificateTemplate: ").append(toIndentedString(certificateTemplate)).append("\n");
    sb.append("    config: ").append(toIndentedString(config)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    issuerCertificateAuthority: ").append(toIndentedString(issuerCertificateAuthority)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    lifetime: ").append(toIndentedString(lifetime)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    pemCertificate: ").append(toIndentedString(pemCertificate)).append("\n");
    sb.append("    pemCertificateChain: ").append(toIndentedString(pemCertificateChain)).append("\n");
    sb.append("    pemCsr: ").append(toIndentedString(pemCsr)).append("\n");
    sb.append("    revocationDetails: ").append(toIndentedString(revocationDetails)).append("\n");
    sb.append("    subjectMode: ").append(toIndentedString(subjectMode)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("certificateDescription");
    openapiFields.add("certificateTemplate");
    openapiFields.add("config");
    openapiFields.add("createTime");
    openapiFields.add("issuerCertificateAuthority");
    openapiFields.add("labels");
    openapiFields.add("lifetime");
    openapiFields.add("name");
    openapiFields.add("pemCertificate");
    openapiFields.add("pemCertificateChain");
    openapiFields.add("pemCsr");
    openapiFields.add("revocationDetails");
    openapiFields.add("subjectMode");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Certificate
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Certificate.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Certificate is not found in the empty JSON string", Certificate.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Certificate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Certificate` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `certificateDescription`
      if (jsonObj.get("certificateDescription") != null && !jsonObj.get("certificateDescription").isJsonNull()) {
        CertificateDescription.validateJsonElement(jsonObj.get("certificateDescription"));
      }
      if ((jsonObj.get("certificateTemplate") != null && !jsonObj.get("certificateTemplate").isJsonNull()) && !jsonObj.get("certificateTemplate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `certificateTemplate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("certificateTemplate").toString()));
      }
      // validate the optional field `config`
      if (jsonObj.get("config") != null && !jsonObj.get("config").isJsonNull()) {
        CertificateConfig.validateJsonElement(jsonObj.get("config"));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("issuerCertificateAuthority") != null && !jsonObj.get("issuerCertificateAuthority").isJsonNull()) && !jsonObj.get("issuerCertificateAuthority").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `issuerCertificateAuthority` to be a primitive type in the JSON string but got `%s`", jsonObj.get("issuerCertificateAuthority").toString()));
      }
      if ((jsonObj.get("lifetime") != null && !jsonObj.get("lifetime").isJsonNull()) && !jsonObj.get("lifetime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lifetime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lifetime").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("pemCertificate") != null && !jsonObj.get("pemCertificate").isJsonNull()) && !jsonObj.get("pemCertificate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pemCertificate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pemCertificate").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("pemCertificateChain") != null && !jsonObj.get("pemCertificateChain").isJsonNull() && !jsonObj.get("pemCertificateChain").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `pemCertificateChain` to be an array in the JSON string but got `%s`", jsonObj.get("pemCertificateChain").toString()));
      }
      if ((jsonObj.get("pemCsr") != null && !jsonObj.get("pemCsr").isJsonNull()) && !jsonObj.get("pemCsr").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pemCsr` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pemCsr").toString()));
      }
      // validate the optional field `revocationDetails`
      if (jsonObj.get("revocationDetails") != null && !jsonObj.get("revocationDetails").isJsonNull()) {
        RevocationDetails.validateJsonElement(jsonObj.get("revocationDetails"));
      }
      if ((jsonObj.get("subjectMode") != null && !jsonObj.get("subjectMode").isJsonNull()) && !jsonObj.get("subjectMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subjectMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subjectMode").toString()));
      }
      // validate the optional field `subjectMode`
      if (jsonObj.get("subjectMode") != null && !jsonObj.get("subjectMode").isJsonNull()) {
        SubjectModeEnum.validateJsonElement(jsonObj.get("subjectMode"));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Certificate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Certificate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Certificate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Certificate.class));

       return (TypeAdapter<T>) new TypeAdapter<Certificate>() {
           @Override
           public void write(JsonWriter out, Certificate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Certificate read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Certificate given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Certificate
   * @throws IOException if the JSON string is invalid with respect to Certificate
   */
  public static Certificate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Certificate.class);
  }

  /**
   * Convert an instance of Certificate to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

