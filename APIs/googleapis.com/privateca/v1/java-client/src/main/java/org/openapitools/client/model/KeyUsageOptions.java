/*
 * Certificate Authority API
 * The Certificate Authority Service API is a highly-available, scalable service that enables you to simplify and automate the management of private certificate authorities (CAs) while staying in control of your private keys. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * KeyUsage.KeyUsageOptions corresponds to the key usage values described in https://tools.ietf.org/html/rfc5280#section-4.2.1.3.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:16.257139-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class KeyUsageOptions {
  public static final String SERIALIZED_NAME_CERT_SIGN = "certSign";
  @SerializedName(SERIALIZED_NAME_CERT_SIGN)
  private Boolean certSign;

  public static final String SERIALIZED_NAME_CONTENT_COMMITMENT = "contentCommitment";
  @SerializedName(SERIALIZED_NAME_CONTENT_COMMITMENT)
  private Boolean contentCommitment;

  public static final String SERIALIZED_NAME_CRL_SIGN = "crlSign";
  @SerializedName(SERIALIZED_NAME_CRL_SIGN)
  private Boolean crlSign;

  public static final String SERIALIZED_NAME_DATA_ENCIPHERMENT = "dataEncipherment";
  @SerializedName(SERIALIZED_NAME_DATA_ENCIPHERMENT)
  private Boolean dataEncipherment;

  public static final String SERIALIZED_NAME_DECIPHER_ONLY = "decipherOnly";
  @SerializedName(SERIALIZED_NAME_DECIPHER_ONLY)
  private Boolean decipherOnly;

  public static final String SERIALIZED_NAME_DIGITAL_SIGNATURE = "digitalSignature";
  @SerializedName(SERIALIZED_NAME_DIGITAL_SIGNATURE)
  private Boolean digitalSignature;

  public static final String SERIALIZED_NAME_ENCIPHER_ONLY = "encipherOnly";
  @SerializedName(SERIALIZED_NAME_ENCIPHER_ONLY)
  private Boolean encipherOnly;

  public static final String SERIALIZED_NAME_KEY_AGREEMENT = "keyAgreement";
  @SerializedName(SERIALIZED_NAME_KEY_AGREEMENT)
  private Boolean keyAgreement;

  public static final String SERIALIZED_NAME_KEY_ENCIPHERMENT = "keyEncipherment";
  @SerializedName(SERIALIZED_NAME_KEY_ENCIPHERMENT)
  private Boolean keyEncipherment;

  public KeyUsageOptions() {
  }

  public KeyUsageOptions certSign(Boolean certSign) {
    this.certSign = certSign;
    return this;
  }

  /**
   * The key may be used to sign certificates.
   * @return certSign
   */
  @javax.annotation.Nullable
  public Boolean getCertSign() {
    return certSign;
  }

  public void setCertSign(Boolean certSign) {
    this.certSign = certSign;
  }


  public KeyUsageOptions contentCommitment(Boolean contentCommitment) {
    this.contentCommitment = contentCommitment;
    return this;
  }

  /**
   * The key may be used for cryptographic commitments. Note that this may also be referred to as \&quot;non-repudiation\&quot;.
   * @return contentCommitment
   */
  @javax.annotation.Nullable
  public Boolean getContentCommitment() {
    return contentCommitment;
  }

  public void setContentCommitment(Boolean contentCommitment) {
    this.contentCommitment = contentCommitment;
  }


  public KeyUsageOptions crlSign(Boolean crlSign) {
    this.crlSign = crlSign;
    return this;
  }

  /**
   * The key may be used sign certificate revocation lists.
   * @return crlSign
   */
  @javax.annotation.Nullable
  public Boolean getCrlSign() {
    return crlSign;
  }

  public void setCrlSign(Boolean crlSign) {
    this.crlSign = crlSign;
  }


  public KeyUsageOptions dataEncipherment(Boolean dataEncipherment) {
    this.dataEncipherment = dataEncipherment;
    return this;
  }

  /**
   * The key may be used to encipher data.
   * @return dataEncipherment
   */
  @javax.annotation.Nullable
  public Boolean getDataEncipherment() {
    return dataEncipherment;
  }

  public void setDataEncipherment(Boolean dataEncipherment) {
    this.dataEncipherment = dataEncipherment;
  }


  public KeyUsageOptions decipherOnly(Boolean decipherOnly) {
    this.decipherOnly = decipherOnly;
    return this;
  }

  /**
   * The key may be used to decipher only.
   * @return decipherOnly
   */
  @javax.annotation.Nullable
  public Boolean getDecipherOnly() {
    return decipherOnly;
  }

  public void setDecipherOnly(Boolean decipherOnly) {
    this.decipherOnly = decipherOnly;
  }


  public KeyUsageOptions digitalSignature(Boolean digitalSignature) {
    this.digitalSignature = digitalSignature;
    return this;
  }

  /**
   * The key may be used for digital signatures.
   * @return digitalSignature
   */
  @javax.annotation.Nullable
  public Boolean getDigitalSignature() {
    return digitalSignature;
  }

  public void setDigitalSignature(Boolean digitalSignature) {
    this.digitalSignature = digitalSignature;
  }


  public KeyUsageOptions encipherOnly(Boolean encipherOnly) {
    this.encipherOnly = encipherOnly;
    return this;
  }

  /**
   * The key may be used to encipher only.
   * @return encipherOnly
   */
  @javax.annotation.Nullable
  public Boolean getEncipherOnly() {
    return encipherOnly;
  }

  public void setEncipherOnly(Boolean encipherOnly) {
    this.encipherOnly = encipherOnly;
  }


  public KeyUsageOptions keyAgreement(Boolean keyAgreement) {
    this.keyAgreement = keyAgreement;
    return this;
  }

  /**
   * The key may be used in a key agreement protocol.
   * @return keyAgreement
   */
  @javax.annotation.Nullable
  public Boolean getKeyAgreement() {
    return keyAgreement;
  }

  public void setKeyAgreement(Boolean keyAgreement) {
    this.keyAgreement = keyAgreement;
  }


  public KeyUsageOptions keyEncipherment(Boolean keyEncipherment) {
    this.keyEncipherment = keyEncipherment;
    return this;
  }

  /**
   * The key may be used to encipher other keys.
   * @return keyEncipherment
   */
  @javax.annotation.Nullable
  public Boolean getKeyEncipherment() {
    return keyEncipherment;
  }

  public void setKeyEncipherment(Boolean keyEncipherment) {
    this.keyEncipherment = keyEncipherment;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KeyUsageOptions keyUsageOptions = (KeyUsageOptions) o;
    return Objects.equals(this.certSign, keyUsageOptions.certSign) &&
        Objects.equals(this.contentCommitment, keyUsageOptions.contentCommitment) &&
        Objects.equals(this.crlSign, keyUsageOptions.crlSign) &&
        Objects.equals(this.dataEncipherment, keyUsageOptions.dataEncipherment) &&
        Objects.equals(this.decipherOnly, keyUsageOptions.decipherOnly) &&
        Objects.equals(this.digitalSignature, keyUsageOptions.digitalSignature) &&
        Objects.equals(this.encipherOnly, keyUsageOptions.encipherOnly) &&
        Objects.equals(this.keyAgreement, keyUsageOptions.keyAgreement) &&
        Objects.equals(this.keyEncipherment, keyUsageOptions.keyEncipherment);
  }

  @Override
  public int hashCode() {
    return Objects.hash(certSign, contentCommitment, crlSign, dataEncipherment, decipherOnly, digitalSignature, encipherOnly, keyAgreement, keyEncipherment);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KeyUsageOptions {\n");
    sb.append("    certSign: ").append(toIndentedString(certSign)).append("\n");
    sb.append("    contentCommitment: ").append(toIndentedString(contentCommitment)).append("\n");
    sb.append("    crlSign: ").append(toIndentedString(crlSign)).append("\n");
    sb.append("    dataEncipherment: ").append(toIndentedString(dataEncipherment)).append("\n");
    sb.append("    decipherOnly: ").append(toIndentedString(decipherOnly)).append("\n");
    sb.append("    digitalSignature: ").append(toIndentedString(digitalSignature)).append("\n");
    sb.append("    encipherOnly: ").append(toIndentedString(encipherOnly)).append("\n");
    sb.append("    keyAgreement: ").append(toIndentedString(keyAgreement)).append("\n");
    sb.append("    keyEncipherment: ").append(toIndentedString(keyEncipherment)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("certSign");
    openapiFields.add("contentCommitment");
    openapiFields.add("crlSign");
    openapiFields.add("dataEncipherment");
    openapiFields.add("decipherOnly");
    openapiFields.add("digitalSignature");
    openapiFields.add("encipherOnly");
    openapiFields.add("keyAgreement");
    openapiFields.add("keyEncipherment");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to KeyUsageOptions
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!KeyUsageOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in KeyUsageOptions is not found in the empty JSON string", KeyUsageOptions.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!KeyUsageOptions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `KeyUsageOptions` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!KeyUsageOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'KeyUsageOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<KeyUsageOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(KeyUsageOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<KeyUsageOptions>() {
           @Override
           public void write(JsonWriter out, KeyUsageOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public KeyUsageOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of KeyUsageOptions given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of KeyUsageOptions
   * @throws IOException if the JSON string is invalid with respect to KeyUsageOptions
   */
  public static KeyUsageOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, KeyUsageOptions.class);
  }

  /**
   * Convert an instance of KeyUsageOptions to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

