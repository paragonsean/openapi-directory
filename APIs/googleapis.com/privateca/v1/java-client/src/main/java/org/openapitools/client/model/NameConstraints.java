/*
 * Certificate Authority API
 * The Certificate Authority Service API is a highly-available, scalable service that enables you to simplify and automate the management of private certificate authorities (CAs) while staying in control of your private keys. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes the X.509 name constraints extension, per https://tools.ietf.org/html/rfc5280#section-4.2.1.10
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:47:16.257139-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class NameConstraints {
  public static final String SERIALIZED_NAME_CRITICAL = "critical";
  @SerializedName(SERIALIZED_NAME_CRITICAL)
  private Boolean critical;

  public static final String SERIALIZED_NAME_EXCLUDED_DNS_NAMES = "excludedDnsNames";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_DNS_NAMES)
  private List<String> excludedDnsNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXCLUDED_EMAIL_ADDRESSES = "excludedEmailAddresses";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_EMAIL_ADDRESSES)
  private List<String> excludedEmailAddresses = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXCLUDED_IP_RANGES = "excludedIpRanges";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_IP_RANGES)
  private List<String> excludedIpRanges = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXCLUDED_URIS = "excludedUris";
  @SerializedName(SERIALIZED_NAME_EXCLUDED_URIS)
  private List<String> excludedUris = new ArrayList<>();

  public static final String SERIALIZED_NAME_PERMITTED_DNS_NAMES = "permittedDnsNames";
  @SerializedName(SERIALIZED_NAME_PERMITTED_DNS_NAMES)
  private List<String> permittedDnsNames = new ArrayList<>();

  public static final String SERIALIZED_NAME_PERMITTED_EMAIL_ADDRESSES = "permittedEmailAddresses";
  @SerializedName(SERIALIZED_NAME_PERMITTED_EMAIL_ADDRESSES)
  private List<String> permittedEmailAddresses = new ArrayList<>();

  public static final String SERIALIZED_NAME_PERMITTED_IP_RANGES = "permittedIpRanges";
  @SerializedName(SERIALIZED_NAME_PERMITTED_IP_RANGES)
  private List<String> permittedIpRanges = new ArrayList<>();

  public static final String SERIALIZED_NAME_PERMITTED_URIS = "permittedUris";
  @SerializedName(SERIALIZED_NAME_PERMITTED_URIS)
  private List<String> permittedUris = new ArrayList<>();

  public NameConstraints() {
  }

  public NameConstraints critical(Boolean critical) {
    this.critical = critical;
    return this;
  }

  /**
   * Indicates whether or not the name constraints are marked critical.
   * @return critical
   */
  @javax.annotation.Nullable
  public Boolean getCritical() {
    return critical;
  }

  public void setCritical(Boolean critical) {
    this.critical = critical;
  }


  public NameConstraints excludedDnsNames(List<String> excludedDnsNames) {
    this.excludedDnsNames = excludedDnsNames;
    return this;
  }

  public NameConstraints addExcludedDnsNamesItem(String excludedDnsNamesItem) {
    if (this.excludedDnsNames == null) {
      this.excludedDnsNames = new ArrayList<>();
    }
    this.excludedDnsNames.add(excludedDnsNamesItem);
    return this;
  }

  /**
   * Contains excluded DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, &#x60;example.com&#x60;, &#x60;www.example.com&#x60;, &#x60;www.sub.example.com&#x60; would satisfy &#x60;example.com&#x60; while &#x60;example1.com&#x60; does not.
   * @return excludedDnsNames
   */
  @javax.annotation.Nullable
  public List<String> getExcludedDnsNames() {
    return excludedDnsNames;
  }

  public void setExcludedDnsNames(List<String> excludedDnsNames) {
    this.excludedDnsNames = excludedDnsNames;
  }


  public NameConstraints excludedEmailAddresses(List<String> excludedEmailAddresses) {
    this.excludedEmailAddresses = excludedEmailAddresses;
    return this;
  }

  public NameConstraints addExcludedEmailAddressesItem(String excludedEmailAddressesItem) {
    if (this.excludedEmailAddresses == null) {
      this.excludedEmailAddresses = new ArrayList<>();
    }
    this.excludedEmailAddresses.add(excludedEmailAddressesItem);
    return this;
  }

  /**
   * Contains the excluded email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. &#x60;.example.com&#x60;) to indicate all email addresses in that domain.
   * @return excludedEmailAddresses
   */
  @javax.annotation.Nullable
  public List<String> getExcludedEmailAddresses() {
    return excludedEmailAddresses;
  }

  public void setExcludedEmailAddresses(List<String> excludedEmailAddresses) {
    this.excludedEmailAddresses = excludedEmailAddresses;
  }


  public NameConstraints excludedIpRanges(List<String> excludedIpRanges) {
    this.excludedIpRanges = excludedIpRanges;
    return this;
  }

  public NameConstraints addExcludedIpRangesItem(String excludedIpRangesItem) {
    if (this.excludedIpRanges == null) {
      this.excludedIpRanges = new ArrayList<>();
    }
    this.excludedIpRanges.add(excludedIpRangesItem);
    return this;
  }

  /**
   * Contains the excluded IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   * @return excludedIpRanges
   */
  @javax.annotation.Nullable
  public List<String> getExcludedIpRanges() {
    return excludedIpRanges;
  }

  public void setExcludedIpRanges(List<String> excludedIpRanges) {
    this.excludedIpRanges = excludedIpRanges;
  }


  public NameConstraints excludedUris(List<String> excludedUris) {
    this.excludedUris = excludedUris;
    return this;
  }

  public NameConstraints addExcludedUrisItem(String excludedUrisItem) {
    if (this.excludedUris == null) {
      this.excludedUris = new ArrayList<>();
    }
    this.excludedUris.add(excludedUrisItem);
    return this;
  }

  /**
   * Contains the excluded URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like &#x60;.example.com&#x60;)
   * @return excludedUris
   */
  @javax.annotation.Nullable
  public List<String> getExcludedUris() {
    return excludedUris;
  }

  public void setExcludedUris(List<String> excludedUris) {
    this.excludedUris = excludedUris;
  }


  public NameConstraints permittedDnsNames(List<String> permittedDnsNames) {
    this.permittedDnsNames = permittedDnsNames;
    return this;
  }

  public NameConstraints addPermittedDnsNamesItem(String permittedDnsNamesItem) {
    if (this.permittedDnsNames == null) {
      this.permittedDnsNames = new ArrayList<>();
    }
    this.permittedDnsNames.add(permittedDnsNamesItem);
    return this;
  }

  /**
   * Contains permitted DNS names. Any DNS name that can be constructed by simply adding zero or more labels to the left-hand side of the name satisfies the name constraint. For example, &#x60;example.com&#x60;, &#x60;www.example.com&#x60;, &#x60;www.sub.example.com&#x60; would satisfy &#x60;example.com&#x60; while &#x60;example1.com&#x60; does not.
   * @return permittedDnsNames
   */
  @javax.annotation.Nullable
  public List<String> getPermittedDnsNames() {
    return permittedDnsNames;
  }

  public void setPermittedDnsNames(List<String> permittedDnsNames) {
    this.permittedDnsNames = permittedDnsNames;
  }


  public NameConstraints permittedEmailAddresses(List<String> permittedEmailAddresses) {
    this.permittedEmailAddresses = permittedEmailAddresses;
    return this;
  }

  public NameConstraints addPermittedEmailAddressesItem(String permittedEmailAddressesItem) {
    if (this.permittedEmailAddresses == null) {
      this.permittedEmailAddresses = new ArrayList<>();
    }
    this.permittedEmailAddresses.add(permittedEmailAddressesItem);
    return this;
  }

  /**
   * Contains the permitted email addresses. The value can be a particular email address, a hostname to indicate all email addresses on that host or a domain with a leading period (e.g. &#x60;.example.com&#x60;) to indicate all email addresses in that domain.
   * @return permittedEmailAddresses
   */
  @javax.annotation.Nullable
  public List<String> getPermittedEmailAddresses() {
    return permittedEmailAddresses;
  }

  public void setPermittedEmailAddresses(List<String> permittedEmailAddresses) {
    this.permittedEmailAddresses = permittedEmailAddresses;
  }


  public NameConstraints permittedIpRanges(List<String> permittedIpRanges) {
    this.permittedIpRanges = permittedIpRanges;
    return this;
  }

  public NameConstraints addPermittedIpRangesItem(String permittedIpRangesItem) {
    if (this.permittedIpRanges == null) {
      this.permittedIpRanges = new ArrayList<>();
    }
    this.permittedIpRanges.add(permittedIpRangesItem);
    return this;
  }

  /**
   * Contains the permitted IP ranges. For IPv4 addresses, the ranges are expressed using CIDR notation as specified in RFC 4632. For IPv6 addresses, the ranges are expressed in similar encoding as IPv4 addresses.
   * @return permittedIpRanges
   */
  @javax.annotation.Nullable
  public List<String> getPermittedIpRanges() {
    return permittedIpRanges;
  }

  public void setPermittedIpRanges(List<String> permittedIpRanges) {
    this.permittedIpRanges = permittedIpRanges;
  }


  public NameConstraints permittedUris(List<String> permittedUris) {
    this.permittedUris = permittedUris;
    return this;
  }

  public NameConstraints addPermittedUrisItem(String permittedUrisItem) {
    if (this.permittedUris == null) {
      this.permittedUris = new ArrayList<>();
    }
    this.permittedUris.add(permittedUrisItem);
    return this;
  }

  /**
   * Contains the permitted URIs that apply to the host part of the name. The value can be a hostname or a domain with a leading period (like &#x60;.example.com&#x60;)
   * @return permittedUris
   */
  @javax.annotation.Nullable
  public List<String> getPermittedUris() {
    return permittedUris;
  }

  public void setPermittedUris(List<String> permittedUris) {
    this.permittedUris = permittedUris;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NameConstraints nameConstraints = (NameConstraints) o;
    return Objects.equals(this.critical, nameConstraints.critical) &&
        Objects.equals(this.excludedDnsNames, nameConstraints.excludedDnsNames) &&
        Objects.equals(this.excludedEmailAddresses, nameConstraints.excludedEmailAddresses) &&
        Objects.equals(this.excludedIpRanges, nameConstraints.excludedIpRanges) &&
        Objects.equals(this.excludedUris, nameConstraints.excludedUris) &&
        Objects.equals(this.permittedDnsNames, nameConstraints.permittedDnsNames) &&
        Objects.equals(this.permittedEmailAddresses, nameConstraints.permittedEmailAddresses) &&
        Objects.equals(this.permittedIpRanges, nameConstraints.permittedIpRanges) &&
        Objects.equals(this.permittedUris, nameConstraints.permittedUris);
  }

  @Override
  public int hashCode() {
    return Objects.hash(critical, excludedDnsNames, excludedEmailAddresses, excludedIpRanges, excludedUris, permittedDnsNames, permittedEmailAddresses, permittedIpRanges, permittedUris);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NameConstraints {\n");
    sb.append("    critical: ").append(toIndentedString(critical)).append("\n");
    sb.append("    excludedDnsNames: ").append(toIndentedString(excludedDnsNames)).append("\n");
    sb.append("    excludedEmailAddresses: ").append(toIndentedString(excludedEmailAddresses)).append("\n");
    sb.append("    excludedIpRanges: ").append(toIndentedString(excludedIpRanges)).append("\n");
    sb.append("    excludedUris: ").append(toIndentedString(excludedUris)).append("\n");
    sb.append("    permittedDnsNames: ").append(toIndentedString(permittedDnsNames)).append("\n");
    sb.append("    permittedEmailAddresses: ").append(toIndentedString(permittedEmailAddresses)).append("\n");
    sb.append("    permittedIpRanges: ").append(toIndentedString(permittedIpRanges)).append("\n");
    sb.append("    permittedUris: ").append(toIndentedString(permittedUris)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("critical");
    openapiFields.add("excludedDnsNames");
    openapiFields.add("excludedEmailAddresses");
    openapiFields.add("excludedIpRanges");
    openapiFields.add("excludedUris");
    openapiFields.add("permittedDnsNames");
    openapiFields.add("permittedEmailAddresses");
    openapiFields.add("permittedIpRanges");
    openapiFields.add("permittedUris");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to NameConstraints
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!NameConstraints.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in NameConstraints is not found in the empty JSON string", NameConstraints.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!NameConstraints.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `NameConstraints` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedDnsNames") != null && !jsonObj.get("excludedDnsNames").isJsonNull() && !jsonObj.get("excludedDnsNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedDnsNames` to be an array in the JSON string but got `%s`", jsonObj.get("excludedDnsNames").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedEmailAddresses") != null && !jsonObj.get("excludedEmailAddresses").isJsonNull() && !jsonObj.get("excludedEmailAddresses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedEmailAddresses` to be an array in the JSON string but got `%s`", jsonObj.get("excludedEmailAddresses").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedIpRanges") != null && !jsonObj.get("excludedIpRanges").isJsonNull() && !jsonObj.get("excludedIpRanges").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedIpRanges` to be an array in the JSON string but got `%s`", jsonObj.get("excludedIpRanges").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("excludedUris") != null && !jsonObj.get("excludedUris").isJsonNull() && !jsonObj.get("excludedUris").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `excludedUris` to be an array in the JSON string but got `%s`", jsonObj.get("excludedUris").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("permittedDnsNames") != null && !jsonObj.get("permittedDnsNames").isJsonNull() && !jsonObj.get("permittedDnsNames").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `permittedDnsNames` to be an array in the JSON string but got `%s`", jsonObj.get("permittedDnsNames").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("permittedEmailAddresses") != null && !jsonObj.get("permittedEmailAddresses").isJsonNull() && !jsonObj.get("permittedEmailAddresses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `permittedEmailAddresses` to be an array in the JSON string but got `%s`", jsonObj.get("permittedEmailAddresses").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("permittedIpRanges") != null && !jsonObj.get("permittedIpRanges").isJsonNull() && !jsonObj.get("permittedIpRanges").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `permittedIpRanges` to be an array in the JSON string but got `%s`", jsonObj.get("permittedIpRanges").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("permittedUris") != null && !jsonObj.get("permittedUris").isJsonNull() && !jsonObj.get("permittedUris").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `permittedUris` to be an array in the JSON string but got `%s`", jsonObj.get("permittedUris").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!NameConstraints.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'NameConstraints' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<NameConstraints> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(NameConstraints.class));

       return (TypeAdapter<T>) new TypeAdapter<NameConstraints>() {
           @Override
           public void write(JsonWriter out, NameConstraints value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public NameConstraints read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of NameConstraints given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of NameConstraints
   * @throws IOException if the JSON string is invalid with respect to NameConstraints
   */
  public static NameConstraints fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, NameConstraints.class);
  }

  /**
   * Convert an instance of NameConstraints to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

