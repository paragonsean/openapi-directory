/*
 * Chrome Verified Access API
 * API for Verified Access chrome extension to provide credential verification for chrome devices connecting to an enterprise network
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CrowdStrikeAgent;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The device signals as reported by Chrome. Unless otherwise specified, signals are available on all platforms.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:43:00.193721-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class DeviceSignals {
  public static final String SERIALIZED_NAME_ALLOW_SCREEN_LOCK = "allowScreenLock";
  @SerializedName(SERIALIZED_NAME_ALLOW_SCREEN_LOCK)
  private Boolean allowScreenLock;

  public static final String SERIALIZED_NAME_BROWSER_VERSION = "browserVersion";
  @SerializedName(SERIALIZED_NAME_BROWSER_VERSION)
  private String browserVersion;

  public static final String SERIALIZED_NAME_BUILT_IN_DNS_CLIENT_ENABLED = "builtInDnsClientEnabled";
  @SerializedName(SERIALIZED_NAME_BUILT_IN_DNS_CLIENT_ENABLED)
  private Boolean builtInDnsClientEnabled;

  public static final String SERIALIZED_NAME_CHROME_REMOTE_DESKTOP_APP_BLOCKED = "chromeRemoteDesktopAppBlocked";
  @SerializedName(SERIALIZED_NAME_CHROME_REMOTE_DESKTOP_APP_BLOCKED)
  private Boolean chromeRemoteDesktopAppBlocked;

  public static final String SERIALIZED_NAME_CROWD_STRIKE_AGENT = "crowdStrikeAgent";
  @SerializedName(SERIALIZED_NAME_CROWD_STRIKE_AGENT)
  private CrowdStrikeAgent crowdStrikeAgent;

  public static final String SERIALIZED_NAME_DEVICE_AFFILIATION_IDS = "deviceAffiliationIds";
  @SerializedName(SERIALIZED_NAME_DEVICE_AFFILIATION_IDS)
  private List<String> deviceAffiliationIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_DEVICE_ENROLLMENT_DOMAIN = "deviceEnrollmentDomain";
  @SerializedName(SERIALIZED_NAME_DEVICE_ENROLLMENT_DOMAIN)
  private String deviceEnrollmentDomain;

  public static final String SERIALIZED_NAME_DEVICE_MANUFACTURER = "deviceManufacturer";
  @SerializedName(SERIALIZED_NAME_DEVICE_MANUFACTURER)
  private String deviceManufacturer;

  public static final String SERIALIZED_NAME_DEVICE_MODEL = "deviceModel";
  @SerializedName(SERIALIZED_NAME_DEVICE_MODEL)
  private String deviceModel;

  /**
   * The encryption state of the disk. On ChromeOS, the main disk is always ENCRYPTED.
   */
  @JsonAdapter(DiskEncryptionEnum.Adapter.class)
  public enum DiskEncryptionEnum {
    UNSPECIFIED("DISK_ENCRYPTION_UNSPECIFIED"),
    
    UNKNOWN("DISK_ENCRYPTION_UNKNOWN"),
    
    DISABLED("DISK_ENCRYPTION_DISABLED"),
    
    ENCRYPTED("DISK_ENCRYPTION_ENCRYPTED");

    private String value;

    DiskEncryptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DiskEncryptionEnum fromValue(String value) {
      for (DiskEncryptionEnum b : DiskEncryptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DiskEncryptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DiskEncryptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DiskEncryptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DiskEncryptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DiskEncryptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DISK_ENCRYPTION = "diskEncryption";
  @SerializedName(SERIALIZED_NAME_DISK_ENCRYPTION)
  private DiskEncryptionEnum diskEncryption;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_HOSTNAME = "hostname";
  @SerializedName(SERIALIZED_NAME_HOSTNAME)
  private String hostname;

  public static final String SERIALIZED_NAME_IMEI = "imei";
  @SerializedName(SERIALIZED_NAME_IMEI)
  private List<String> imei = new ArrayList<>();

  public static final String SERIALIZED_NAME_MAC_ADDRESSES = "macAddresses";
  @SerializedName(SERIALIZED_NAME_MAC_ADDRESSES)
  private List<String> macAddresses = new ArrayList<>();

  public static final String SERIALIZED_NAME_MEID = "meid";
  @SerializedName(SERIALIZED_NAME_MEID)
  private List<String> meid = new ArrayList<>();

  /**
   * The type of the Operating System currently running on the device.
   */
  @JsonAdapter(OperatingSystemEnum.Adapter.class)
  public enum OperatingSystemEnum {
    OPERATING_SYSTEM_UNSPECIFIED("OPERATING_SYSTEM_UNSPECIFIED"),
    
    CHROME_OS("CHROME_OS"),
    
    CHROMIUM_OS("CHROMIUM_OS"),
    
    WINDOWS("WINDOWS"),
    
    MAC_OS_X("MAC_OS_X"),
    
    LINUX("LINUX");

    private String value;

    OperatingSystemEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OperatingSystemEnum fromValue(String value) {
      for (OperatingSystemEnum b : OperatingSystemEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OperatingSystemEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OperatingSystemEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OperatingSystemEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OperatingSystemEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OperatingSystemEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OPERATING_SYSTEM = "operatingSystem";
  @SerializedName(SERIALIZED_NAME_OPERATING_SYSTEM)
  private OperatingSystemEnum operatingSystem;

  /**
   * The state of the OS level firewall. On ChromeOS, the value will always be ENABLED on regular devices and UNKNOWN on devices in developer mode.
   */
  @JsonAdapter(OsFirewallEnum.Adapter.class)
  public enum OsFirewallEnum {
    UNSPECIFIED("OS_FIREWALL_UNSPECIFIED"),
    
    UNKNOWN("OS_FIREWALL_UNKNOWN"),
    
    DISABLED("OS_FIREWALL_DISABLED"),
    
    ENABLED("OS_FIREWALL_ENABLED");

    private String value;

    OsFirewallEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OsFirewallEnum fromValue(String value) {
      for (OsFirewallEnum b : OsFirewallEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OsFirewallEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OsFirewallEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OsFirewallEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OsFirewallEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OsFirewallEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OS_FIREWALL = "osFirewall";
  @SerializedName(SERIALIZED_NAME_OS_FIREWALL)
  private OsFirewallEnum osFirewall;

  public static final String SERIALIZED_NAME_OS_VERSION = "osVersion";
  @SerializedName(SERIALIZED_NAME_OS_VERSION)
  private String osVersion;

  /**
   * Whether the Password Protection Warning feature is enabled or not. Password protection alerts users when they reuse their protected password on potentially suspicious sites. This setting is controlled by an enterprise policy: https://chromeenterprise.google/policies/#PasswordProtectionWarningTrigger. Note that the policy unset does not have the same effects as having the policy explicitly set to &#x60;PASSWORD_PROTECTION_OFF&#x60;.
   */
  @JsonAdapter(PasswordProtectionWarningTriggerEnum.Adapter.class)
  public enum PasswordProtectionWarningTriggerEnum {
    PASSWORD_PROTECTION_WARNING_TRIGGER_UNSPECIFIED("PASSWORD_PROTECTION_WARNING_TRIGGER_UNSPECIFIED"),
    
    POLICY_UNSET("POLICY_UNSET"),
    
    PASSWORD_PROTECTION_OFF("PASSWORD_PROTECTION_OFF"),
    
    PASSWORD_REUSE("PASSWORD_REUSE"),
    
    PHISHING_REUSE("PHISHING_REUSE");

    private String value;

    PasswordProtectionWarningTriggerEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PasswordProtectionWarningTriggerEnum fromValue(String value) {
      for (PasswordProtectionWarningTriggerEnum b : PasswordProtectionWarningTriggerEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PasswordProtectionWarningTriggerEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PasswordProtectionWarningTriggerEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PasswordProtectionWarningTriggerEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PasswordProtectionWarningTriggerEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PasswordProtectionWarningTriggerEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PASSWORD_PROTECTION_WARNING_TRIGGER = "passwordProtectionWarningTrigger";
  @SerializedName(SERIALIZED_NAME_PASSWORD_PROTECTION_WARNING_TRIGGER)
  private PasswordProtectionWarningTriggerEnum passwordProtectionWarningTrigger;

  public static final String SERIALIZED_NAME_PROFILE_AFFILIATION_IDS = "profileAffiliationIds";
  @SerializedName(SERIALIZED_NAME_PROFILE_AFFILIATION_IDS)
  private List<String> profileAffiliationIds = new ArrayList<>();

  /**
   * Whether Enterprise-grade (i.e. custom) unsafe URL scanning is enabled or not. This setting may be controlled by an enterprise policy: https://chromeenterprise.google/policies/#EnterpriseRealTimeUrlCheckMode
   */
  @JsonAdapter(RealtimeUrlCheckModeEnum.Adapter.class)
  public enum RealtimeUrlCheckModeEnum {
    UNSPECIFIED("REALTIME_URL_CHECK_MODE_UNSPECIFIED"),
    
    DISABLED("REALTIME_URL_CHECK_MODE_DISABLED"),
    
    ENABLED_MAIN_FRAME("REALTIME_URL_CHECK_MODE_ENABLED_MAIN_FRAME");

    private String value;

    RealtimeUrlCheckModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RealtimeUrlCheckModeEnum fromValue(String value) {
      for (RealtimeUrlCheckModeEnum b : RealtimeUrlCheckModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RealtimeUrlCheckModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RealtimeUrlCheckModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RealtimeUrlCheckModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RealtimeUrlCheckModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RealtimeUrlCheckModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_REALTIME_URL_CHECK_MODE = "realtimeUrlCheckMode";
  @SerializedName(SERIALIZED_NAME_REALTIME_URL_CHECK_MODE)
  private RealtimeUrlCheckModeEnum realtimeUrlCheckMode;

  /**
   * Safe Browsing Protection Level. That setting may be controlled by an enterprise policy: https://chromeenterprise.google/policies/#SafeBrowsingProtectionLevel.
   */
  @JsonAdapter(SafeBrowsingProtectionLevelEnum.Adapter.class)
  public enum SafeBrowsingProtectionLevelEnum {
    SAFE_BROWSING_PROTECTION_LEVEL_UNSPECIFIED("SAFE_BROWSING_PROTECTION_LEVEL_UNSPECIFIED"),
    
    INACTIVE("INACTIVE"),
    
    STANDARD("STANDARD"),
    
    ENHANCED("ENHANCED");

    private String value;

    SafeBrowsingProtectionLevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SafeBrowsingProtectionLevelEnum fromValue(String value) {
      for (SafeBrowsingProtectionLevelEnum b : SafeBrowsingProtectionLevelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SafeBrowsingProtectionLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SafeBrowsingProtectionLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SafeBrowsingProtectionLevelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SafeBrowsingProtectionLevelEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SafeBrowsingProtectionLevelEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SAFE_BROWSING_PROTECTION_LEVEL = "safeBrowsingProtectionLevel";
  @SerializedName(SERIALIZED_NAME_SAFE_BROWSING_PROTECTION_LEVEL)
  private SafeBrowsingProtectionLevelEnum safeBrowsingProtectionLevel;

  /**
   * The state of the Screen Lock password protection. On ChromeOS, this value will always be ENABLED as there is not way to disable requiring a password or pin when unlocking the device.
   */
  @JsonAdapter(ScreenLockSecuredEnum.Adapter.class)
  public enum ScreenLockSecuredEnum {
    UNSPECIFIED("SCREEN_LOCK_SECURED_UNSPECIFIED"),
    
    UNKNOWN("SCREEN_LOCK_SECURED_UNKNOWN"),
    
    DISABLED("SCREEN_LOCK_SECURED_DISABLED"),
    
    ENABLED("SCREEN_LOCK_SECURED_ENABLED");

    private String value;

    ScreenLockSecuredEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ScreenLockSecuredEnum fromValue(String value) {
      for (ScreenLockSecuredEnum b : ScreenLockSecuredEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ScreenLockSecuredEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ScreenLockSecuredEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ScreenLockSecuredEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ScreenLockSecuredEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ScreenLockSecuredEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SCREEN_LOCK_SECURED = "screenLockSecured";
  @SerializedName(SERIALIZED_NAME_SCREEN_LOCK_SECURED)
  private ScreenLockSecuredEnum screenLockSecured;

  /**
   * Whether the device&#39;s startup software has its Secure Boot feature enabled. Available on Windows only.
   */
  @JsonAdapter(SecureBootModeEnum.Adapter.class)
  public enum SecureBootModeEnum {
    UNSPECIFIED("SECURE_BOOT_MODE_UNSPECIFIED"),
    
    UNKNOWN("SECURE_BOOT_MODE_UNKNOWN"),
    
    DISABLED("SECURE_BOOT_MODE_DISABLED"),
    
    ENABLED("SECURE_BOOT_MODE_ENABLED");

    private String value;

    SecureBootModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SecureBootModeEnum fromValue(String value) {
      for (SecureBootModeEnum b : SecureBootModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SecureBootModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SecureBootModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SecureBootModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SecureBootModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SecureBootModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SECURE_BOOT_MODE = "secureBootMode";
  @SerializedName(SERIALIZED_NAME_SECURE_BOOT_MODE)
  private SecureBootModeEnum secureBootMode;

  public static final String SERIALIZED_NAME_SERIAL_NUMBER = "serialNumber";
  @SerializedName(SERIALIZED_NAME_SERIAL_NUMBER)
  private String serialNumber;

  public static final String SERIALIZED_NAME_SITE_ISOLATION_ENABLED = "siteIsolationEnabled";
  @SerializedName(SERIALIZED_NAME_SITE_ISOLATION_ENABLED)
  private Boolean siteIsolationEnabled;

  public static final String SERIALIZED_NAME_SYSTEM_DNS_SERVERS = "systemDnsServers";
  @SerializedName(SERIALIZED_NAME_SYSTEM_DNS_SERVERS)
  private List<String> systemDnsServers = new ArrayList<>();

  public static final String SERIALIZED_NAME_THIRD_PARTY_BLOCKING_ENABLED = "thirdPartyBlockingEnabled";
  @SerializedName(SERIALIZED_NAME_THIRD_PARTY_BLOCKING_ENABLED)
  private Boolean thirdPartyBlockingEnabled;

  /**
   * The trigger which generated this set of signals.
   */
  @JsonAdapter(TriggerEnum.Adapter.class)
  public enum TriggerEnum {
    UNSPECIFIED("TRIGGER_UNSPECIFIED"),
    
    BROWSER_NAVIGATION("TRIGGER_BROWSER_NAVIGATION"),
    
    LOGIN_SCREEN("TRIGGER_LOGIN_SCREEN");

    private String value;

    TriggerEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TriggerEnum fromValue(String value) {
      for (TriggerEnum b : TriggerEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TriggerEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TriggerEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TriggerEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TriggerEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      TriggerEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_TRIGGER = "trigger";
  @SerializedName(SERIALIZED_NAME_TRIGGER)
  private TriggerEnum trigger;

  public static final String SERIALIZED_NAME_WINDOWS_MACHINE_DOMAIN = "windowsMachineDomain";
  @SerializedName(SERIALIZED_NAME_WINDOWS_MACHINE_DOMAIN)
  private String windowsMachineDomain;

  public static final String SERIALIZED_NAME_WINDOWS_USER_DOMAIN = "windowsUserDomain";
  @SerializedName(SERIALIZED_NAME_WINDOWS_USER_DOMAIN)
  private String windowsUserDomain;

  public DeviceSignals() {
  }

  public DeviceSignals allowScreenLock(Boolean allowScreenLock) {
    this.allowScreenLock = allowScreenLock;
    return this;
  }

  /**
   * Value of the AllowScreenLock policy on the device. See https://chromeenterprise.google/policies/?policy&#x3D;AllowScreenLock for more details. Available on ChromeOS only.
   * @return allowScreenLock
   */
  @javax.annotation.Nullable
  public Boolean getAllowScreenLock() {
    return allowScreenLock;
  }

  public void setAllowScreenLock(Boolean allowScreenLock) {
    this.allowScreenLock = allowScreenLock;
  }


  public DeviceSignals browserVersion(String browserVersion) {
    this.browserVersion = browserVersion;
    return this;
  }

  /**
   * Current version of the Chrome browser which generated this set of signals. Example value: \&quot;107.0.5286.0\&quot;.
   * @return browserVersion
   */
  @javax.annotation.Nullable
  public String getBrowserVersion() {
    return browserVersion;
  }

  public void setBrowserVersion(String browserVersion) {
    this.browserVersion = browserVersion;
  }


  public DeviceSignals builtInDnsClientEnabled(Boolean builtInDnsClientEnabled) {
    this.builtInDnsClientEnabled = builtInDnsClientEnabled;
    return this;
  }

  /**
   * Whether Chrome&#39;s built-in DNS client is used. The OS DNS client is otherwise used. This value may be controlled by an enterprise policy: https://chromeenterprise.google/policies/#BuiltInDnsClientEnabled.
   * @return builtInDnsClientEnabled
   */
  @javax.annotation.Nullable
  public Boolean getBuiltInDnsClientEnabled() {
    return builtInDnsClientEnabled;
  }

  public void setBuiltInDnsClientEnabled(Boolean builtInDnsClientEnabled) {
    this.builtInDnsClientEnabled = builtInDnsClientEnabled;
  }


  public DeviceSignals chromeRemoteDesktopAppBlocked(Boolean chromeRemoteDesktopAppBlocked) {
    this.chromeRemoteDesktopAppBlocked = chromeRemoteDesktopAppBlocked;
    return this;
  }

  /**
   * Whether access to the Chrome Remote Desktop application is blocked via a policy.
   * @return chromeRemoteDesktopAppBlocked
   */
  @javax.annotation.Nullable
  public Boolean getChromeRemoteDesktopAppBlocked() {
    return chromeRemoteDesktopAppBlocked;
  }

  public void setChromeRemoteDesktopAppBlocked(Boolean chromeRemoteDesktopAppBlocked) {
    this.chromeRemoteDesktopAppBlocked = chromeRemoteDesktopAppBlocked;
  }


  public DeviceSignals crowdStrikeAgent(CrowdStrikeAgent crowdStrikeAgent) {
    this.crowdStrikeAgent = crowdStrikeAgent;
    return this;
  }

  /**
   * Get crowdStrikeAgent
   * @return crowdStrikeAgent
   */
  @javax.annotation.Nullable
  public CrowdStrikeAgent getCrowdStrikeAgent() {
    return crowdStrikeAgent;
  }

  public void setCrowdStrikeAgent(CrowdStrikeAgent crowdStrikeAgent) {
    this.crowdStrikeAgent = crowdStrikeAgent;
  }


  public DeviceSignals deviceAffiliationIds(List<String> deviceAffiliationIds) {
    this.deviceAffiliationIds = deviceAffiliationIds;
    return this;
  }

  public DeviceSignals addDeviceAffiliationIdsItem(String deviceAffiliationIdsItem) {
    if (this.deviceAffiliationIds == null) {
      this.deviceAffiliationIds = new ArrayList<>();
    }
    this.deviceAffiliationIds.add(deviceAffiliationIdsItem);
    return this;
  }

  /**
   * Affiliation IDs of the organizations that are affiliated with the organization that is currently managing the device. When the sets of device and profile affiliation IDs overlap, it means that the organizations managing the device and user are affiliated. To learn more about user affiliation, visit https://support.google.com/chrome/a/answer/12801245?ref_topic&#x3D;9027936.
   * @return deviceAffiliationIds
   */
  @javax.annotation.Nullable
  public List<String> getDeviceAffiliationIds() {
    return deviceAffiliationIds;
  }

  public void setDeviceAffiliationIds(List<String> deviceAffiliationIds) {
    this.deviceAffiliationIds = deviceAffiliationIds;
  }


  public DeviceSignals deviceEnrollmentDomain(String deviceEnrollmentDomain) {
    this.deviceEnrollmentDomain = deviceEnrollmentDomain;
    return this;
  }

  /**
   * Enrollment domain of the customer which is currently managing the device.
   * @return deviceEnrollmentDomain
   */
  @javax.annotation.Nullable
  public String getDeviceEnrollmentDomain() {
    return deviceEnrollmentDomain;
  }

  public void setDeviceEnrollmentDomain(String deviceEnrollmentDomain) {
    this.deviceEnrollmentDomain = deviceEnrollmentDomain;
  }


  public DeviceSignals deviceManufacturer(String deviceManufacturer) {
    this.deviceManufacturer = deviceManufacturer;
    return this;
  }

  /**
   * The name of the device&#39;s manufacturer.
   * @return deviceManufacturer
   */
  @javax.annotation.Nullable
  public String getDeviceManufacturer() {
    return deviceManufacturer;
  }

  public void setDeviceManufacturer(String deviceManufacturer) {
    this.deviceManufacturer = deviceManufacturer;
  }


  public DeviceSignals deviceModel(String deviceModel) {
    this.deviceModel = deviceModel;
    return this;
  }

  /**
   * The name of the device&#39;s model.
   * @return deviceModel
   */
  @javax.annotation.Nullable
  public String getDeviceModel() {
    return deviceModel;
  }

  public void setDeviceModel(String deviceModel) {
    this.deviceModel = deviceModel;
  }


  public DeviceSignals diskEncryption(DiskEncryptionEnum diskEncryption) {
    this.diskEncryption = diskEncryption;
    return this;
  }

  /**
   * The encryption state of the disk. On ChromeOS, the main disk is always ENCRYPTED.
   * @return diskEncryption
   */
  @javax.annotation.Nullable
  public DiskEncryptionEnum getDiskEncryption() {
    return diskEncryption;
  }

  public void setDiskEncryption(DiskEncryptionEnum diskEncryption) {
    this.diskEncryption = diskEncryption;
  }


  public DeviceSignals displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * The display name of the device, as defined by the user.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public DeviceSignals hostname(String hostname) {
    this.hostname = hostname;
    return this;
  }

  /**
   * Hostname of the device.
   * @return hostname
   */
  @javax.annotation.Nullable
  public String getHostname() {
    return hostname;
  }

  public void setHostname(String hostname) {
    this.hostname = hostname;
  }


  public DeviceSignals imei(List<String> imei) {
    this.imei = imei;
    return this;
  }

  public DeviceSignals addImeiItem(String imeiItem) {
    if (this.imei == null) {
      this.imei = new ArrayList<>();
    }
    this.imei.add(imeiItem);
    return this;
  }

  /**
   * International Mobile Equipment Identity (IMEI) of the device. Available on ChromeOS only.
   * @return imei
   */
  @javax.annotation.Nullable
  public List<String> getImei() {
    return imei;
  }

  public void setImei(List<String> imei) {
    this.imei = imei;
  }


  public DeviceSignals macAddresses(List<String> macAddresses) {
    this.macAddresses = macAddresses;
    return this;
  }

  public DeviceSignals addMacAddressesItem(String macAddressesItem) {
    if (this.macAddresses == null) {
      this.macAddresses = new ArrayList<>();
    }
    this.macAddresses.add(macAddressesItem);
    return this;
  }

  /**
   * MAC addresses of the device.
   * @return macAddresses
   */
  @javax.annotation.Nullable
  public List<String> getMacAddresses() {
    return macAddresses;
  }

  public void setMacAddresses(List<String> macAddresses) {
    this.macAddresses = macAddresses;
  }


  public DeviceSignals meid(List<String> meid) {
    this.meid = meid;
    return this;
  }

  public DeviceSignals addMeidItem(String meidItem) {
    if (this.meid == null) {
      this.meid = new ArrayList<>();
    }
    this.meid.add(meidItem);
    return this;
  }

  /**
   * Mobile Equipment Identifier (MEID) of the device. Available on ChromeOS only.
   * @return meid
   */
  @javax.annotation.Nullable
  public List<String> getMeid() {
    return meid;
  }

  public void setMeid(List<String> meid) {
    this.meid = meid;
  }


  public DeviceSignals operatingSystem(OperatingSystemEnum operatingSystem) {
    this.operatingSystem = operatingSystem;
    return this;
  }

  /**
   * The type of the Operating System currently running on the device.
   * @return operatingSystem
   */
  @javax.annotation.Nullable
  public OperatingSystemEnum getOperatingSystem() {
    return operatingSystem;
  }

  public void setOperatingSystem(OperatingSystemEnum operatingSystem) {
    this.operatingSystem = operatingSystem;
  }


  public DeviceSignals osFirewall(OsFirewallEnum osFirewall) {
    this.osFirewall = osFirewall;
    return this;
  }

  /**
   * The state of the OS level firewall. On ChromeOS, the value will always be ENABLED on regular devices and UNKNOWN on devices in developer mode.
   * @return osFirewall
   */
  @javax.annotation.Nullable
  public OsFirewallEnum getOsFirewall() {
    return osFirewall;
  }

  public void setOsFirewall(OsFirewallEnum osFirewall) {
    this.osFirewall = osFirewall;
  }


  public DeviceSignals osVersion(String osVersion) {
    this.osVersion = osVersion;
    return this;
  }

  /**
   * The current version of the Operating System. On Windows and linux, the value will also include the security patch information.
   * @return osVersion
   */
  @javax.annotation.Nullable
  public String getOsVersion() {
    return osVersion;
  }

  public void setOsVersion(String osVersion) {
    this.osVersion = osVersion;
  }


  public DeviceSignals passwordProtectionWarningTrigger(PasswordProtectionWarningTriggerEnum passwordProtectionWarningTrigger) {
    this.passwordProtectionWarningTrigger = passwordProtectionWarningTrigger;
    return this;
  }

  /**
   * Whether the Password Protection Warning feature is enabled or not. Password protection alerts users when they reuse their protected password on potentially suspicious sites. This setting is controlled by an enterprise policy: https://chromeenterprise.google/policies/#PasswordProtectionWarningTrigger. Note that the policy unset does not have the same effects as having the policy explicitly set to &#x60;PASSWORD_PROTECTION_OFF&#x60;.
   * @return passwordProtectionWarningTrigger
   */
  @javax.annotation.Nullable
  public PasswordProtectionWarningTriggerEnum getPasswordProtectionWarningTrigger() {
    return passwordProtectionWarningTrigger;
  }

  public void setPasswordProtectionWarningTrigger(PasswordProtectionWarningTriggerEnum passwordProtectionWarningTrigger) {
    this.passwordProtectionWarningTrigger = passwordProtectionWarningTrigger;
  }


  public DeviceSignals profileAffiliationIds(List<String> profileAffiliationIds) {
    this.profileAffiliationIds = profileAffiliationIds;
    return this;
  }

  public DeviceSignals addProfileAffiliationIdsItem(String profileAffiliationIdsItem) {
    if (this.profileAffiliationIds == null) {
      this.profileAffiliationIds = new ArrayList<>();
    }
    this.profileAffiliationIds.add(profileAffiliationIdsItem);
    return this;
  }

  /**
   * Affiliation IDs of the organizations that are affiliated with the organization that is currently managing the Chrome Profileâ€™s user or ChromeOS user.
   * @return profileAffiliationIds
   */
  @javax.annotation.Nullable
  public List<String> getProfileAffiliationIds() {
    return profileAffiliationIds;
  }

  public void setProfileAffiliationIds(List<String> profileAffiliationIds) {
    this.profileAffiliationIds = profileAffiliationIds;
  }


  public DeviceSignals realtimeUrlCheckMode(RealtimeUrlCheckModeEnum realtimeUrlCheckMode) {
    this.realtimeUrlCheckMode = realtimeUrlCheckMode;
    return this;
  }

  /**
   * Whether Enterprise-grade (i.e. custom) unsafe URL scanning is enabled or not. This setting may be controlled by an enterprise policy: https://chromeenterprise.google/policies/#EnterpriseRealTimeUrlCheckMode
   * @return realtimeUrlCheckMode
   */
  @javax.annotation.Nullable
  public RealtimeUrlCheckModeEnum getRealtimeUrlCheckMode() {
    return realtimeUrlCheckMode;
  }

  public void setRealtimeUrlCheckMode(RealtimeUrlCheckModeEnum realtimeUrlCheckMode) {
    this.realtimeUrlCheckMode = realtimeUrlCheckMode;
  }


  public DeviceSignals safeBrowsingProtectionLevel(SafeBrowsingProtectionLevelEnum safeBrowsingProtectionLevel) {
    this.safeBrowsingProtectionLevel = safeBrowsingProtectionLevel;
    return this;
  }

  /**
   * Safe Browsing Protection Level. That setting may be controlled by an enterprise policy: https://chromeenterprise.google/policies/#SafeBrowsingProtectionLevel.
   * @return safeBrowsingProtectionLevel
   */
  @javax.annotation.Nullable
  public SafeBrowsingProtectionLevelEnum getSafeBrowsingProtectionLevel() {
    return safeBrowsingProtectionLevel;
  }

  public void setSafeBrowsingProtectionLevel(SafeBrowsingProtectionLevelEnum safeBrowsingProtectionLevel) {
    this.safeBrowsingProtectionLevel = safeBrowsingProtectionLevel;
  }


  public DeviceSignals screenLockSecured(ScreenLockSecuredEnum screenLockSecured) {
    this.screenLockSecured = screenLockSecured;
    return this;
  }

  /**
   * The state of the Screen Lock password protection. On ChromeOS, this value will always be ENABLED as there is not way to disable requiring a password or pin when unlocking the device.
   * @return screenLockSecured
   */
  @javax.annotation.Nullable
  public ScreenLockSecuredEnum getScreenLockSecured() {
    return screenLockSecured;
  }

  public void setScreenLockSecured(ScreenLockSecuredEnum screenLockSecured) {
    this.screenLockSecured = screenLockSecured;
  }


  public DeviceSignals secureBootMode(SecureBootModeEnum secureBootMode) {
    this.secureBootMode = secureBootMode;
    return this;
  }

  /**
   * Whether the device&#39;s startup software has its Secure Boot feature enabled. Available on Windows only.
   * @return secureBootMode
   */
  @javax.annotation.Nullable
  public SecureBootModeEnum getSecureBootMode() {
    return secureBootMode;
  }

  public void setSecureBootMode(SecureBootModeEnum secureBootMode) {
    this.secureBootMode = secureBootMode;
  }


  public DeviceSignals serialNumber(String serialNumber) {
    this.serialNumber = serialNumber;
    return this;
  }

  /**
   * The serial number of the device. On Windows, this represents the BIOS&#39;s serial number. Not available on most Linux distributions.
   * @return serialNumber
   */
  @javax.annotation.Nullable
  public String getSerialNumber() {
    return serialNumber;
  }

  public void setSerialNumber(String serialNumber) {
    this.serialNumber = serialNumber;
  }


  public DeviceSignals siteIsolationEnabled(Boolean siteIsolationEnabled) {
    this.siteIsolationEnabled = siteIsolationEnabled;
    return this;
  }

  /**
   * Whether the Site Isolation (a.k.a Site Per Process) setting is enabled. That setting may be controlled by an enterprise policy: https://chromeenterprise.google/policies/#SitePerProcess
   * @return siteIsolationEnabled
   */
  @javax.annotation.Nullable
  public Boolean getSiteIsolationEnabled() {
    return siteIsolationEnabled;
  }

  public void setSiteIsolationEnabled(Boolean siteIsolationEnabled) {
    this.siteIsolationEnabled = siteIsolationEnabled;
  }


  public DeviceSignals systemDnsServers(List<String> systemDnsServers) {
    this.systemDnsServers = systemDnsServers;
    return this;
  }

  public DeviceSignals addSystemDnsServersItem(String systemDnsServersItem) {
    if (this.systemDnsServers == null) {
      this.systemDnsServers = new ArrayList<>();
    }
    this.systemDnsServers.add(systemDnsServersItem);
    return this;
  }

  /**
   * List of the addesses of all OS level DNS servers configured in the device&#39;s network settings.
   * @return systemDnsServers
   */
  @javax.annotation.Nullable
  public List<String> getSystemDnsServers() {
    return systemDnsServers;
  }

  public void setSystemDnsServers(List<String> systemDnsServers) {
    this.systemDnsServers = systemDnsServers;
  }


  public DeviceSignals thirdPartyBlockingEnabled(Boolean thirdPartyBlockingEnabled) {
    this.thirdPartyBlockingEnabled = thirdPartyBlockingEnabled;
    return this;
  }

  /**
   * Whether Chrome is blocking third-party software injection or not. This setting may be controlled by an enterprise policy: https://chromeenterprise.google/policies/?policy&#x3D;ThirdPartyBlockingEnabled. Available on Windows only.
   * @return thirdPartyBlockingEnabled
   */
  @javax.annotation.Nullable
  public Boolean getThirdPartyBlockingEnabled() {
    return thirdPartyBlockingEnabled;
  }

  public void setThirdPartyBlockingEnabled(Boolean thirdPartyBlockingEnabled) {
    this.thirdPartyBlockingEnabled = thirdPartyBlockingEnabled;
  }


  public DeviceSignals trigger(TriggerEnum trigger) {
    this.trigger = trigger;
    return this;
  }

  /**
   * The trigger which generated this set of signals.
   * @return trigger
   */
  @javax.annotation.Nullable
  public TriggerEnum getTrigger() {
    return trigger;
  }

  public void setTrigger(TriggerEnum trigger) {
    this.trigger = trigger;
  }


  public DeviceSignals windowsMachineDomain(String windowsMachineDomain) {
    this.windowsMachineDomain = windowsMachineDomain;
    return this;
  }

  /**
   * Windows domain that the current machine has joined. Available on Windows only.
   * @return windowsMachineDomain
   */
  @javax.annotation.Nullable
  public String getWindowsMachineDomain() {
    return windowsMachineDomain;
  }

  public void setWindowsMachineDomain(String windowsMachineDomain) {
    this.windowsMachineDomain = windowsMachineDomain;
  }


  public DeviceSignals windowsUserDomain(String windowsUserDomain) {
    this.windowsUserDomain = windowsUserDomain;
    return this;
  }

  /**
   * Windows domain for the current OS user. Available on Windows only.
   * @return windowsUserDomain
   */
  @javax.annotation.Nullable
  public String getWindowsUserDomain() {
    return windowsUserDomain;
  }

  public void setWindowsUserDomain(String windowsUserDomain) {
    this.windowsUserDomain = windowsUserDomain;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DeviceSignals deviceSignals = (DeviceSignals) o;
    return Objects.equals(this.allowScreenLock, deviceSignals.allowScreenLock) &&
        Objects.equals(this.browserVersion, deviceSignals.browserVersion) &&
        Objects.equals(this.builtInDnsClientEnabled, deviceSignals.builtInDnsClientEnabled) &&
        Objects.equals(this.chromeRemoteDesktopAppBlocked, deviceSignals.chromeRemoteDesktopAppBlocked) &&
        Objects.equals(this.crowdStrikeAgent, deviceSignals.crowdStrikeAgent) &&
        Objects.equals(this.deviceAffiliationIds, deviceSignals.deviceAffiliationIds) &&
        Objects.equals(this.deviceEnrollmentDomain, deviceSignals.deviceEnrollmentDomain) &&
        Objects.equals(this.deviceManufacturer, deviceSignals.deviceManufacturer) &&
        Objects.equals(this.deviceModel, deviceSignals.deviceModel) &&
        Objects.equals(this.diskEncryption, deviceSignals.diskEncryption) &&
        Objects.equals(this.displayName, deviceSignals.displayName) &&
        Objects.equals(this.hostname, deviceSignals.hostname) &&
        Objects.equals(this.imei, deviceSignals.imei) &&
        Objects.equals(this.macAddresses, deviceSignals.macAddresses) &&
        Objects.equals(this.meid, deviceSignals.meid) &&
        Objects.equals(this.operatingSystem, deviceSignals.operatingSystem) &&
        Objects.equals(this.osFirewall, deviceSignals.osFirewall) &&
        Objects.equals(this.osVersion, deviceSignals.osVersion) &&
        Objects.equals(this.passwordProtectionWarningTrigger, deviceSignals.passwordProtectionWarningTrigger) &&
        Objects.equals(this.profileAffiliationIds, deviceSignals.profileAffiliationIds) &&
        Objects.equals(this.realtimeUrlCheckMode, deviceSignals.realtimeUrlCheckMode) &&
        Objects.equals(this.safeBrowsingProtectionLevel, deviceSignals.safeBrowsingProtectionLevel) &&
        Objects.equals(this.screenLockSecured, deviceSignals.screenLockSecured) &&
        Objects.equals(this.secureBootMode, deviceSignals.secureBootMode) &&
        Objects.equals(this.serialNumber, deviceSignals.serialNumber) &&
        Objects.equals(this.siteIsolationEnabled, deviceSignals.siteIsolationEnabled) &&
        Objects.equals(this.systemDnsServers, deviceSignals.systemDnsServers) &&
        Objects.equals(this.thirdPartyBlockingEnabled, deviceSignals.thirdPartyBlockingEnabled) &&
        Objects.equals(this.trigger, deviceSignals.trigger) &&
        Objects.equals(this.windowsMachineDomain, deviceSignals.windowsMachineDomain) &&
        Objects.equals(this.windowsUserDomain, deviceSignals.windowsUserDomain);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowScreenLock, browserVersion, builtInDnsClientEnabled, chromeRemoteDesktopAppBlocked, crowdStrikeAgent, deviceAffiliationIds, deviceEnrollmentDomain, deviceManufacturer, deviceModel, diskEncryption, displayName, hostname, imei, macAddresses, meid, operatingSystem, osFirewall, osVersion, passwordProtectionWarningTrigger, profileAffiliationIds, realtimeUrlCheckMode, safeBrowsingProtectionLevel, screenLockSecured, secureBootMode, serialNumber, siteIsolationEnabled, systemDnsServers, thirdPartyBlockingEnabled, trigger, windowsMachineDomain, windowsUserDomain);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DeviceSignals {\n");
    sb.append("    allowScreenLock: ").append(toIndentedString(allowScreenLock)).append("\n");
    sb.append("    browserVersion: ").append(toIndentedString(browserVersion)).append("\n");
    sb.append("    builtInDnsClientEnabled: ").append(toIndentedString(builtInDnsClientEnabled)).append("\n");
    sb.append("    chromeRemoteDesktopAppBlocked: ").append(toIndentedString(chromeRemoteDesktopAppBlocked)).append("\n");
    sb.append("    crowdStrikeAgent: ").append(toIndentedString(crowdStrikeAgent)).append("\n");
    sb.append("    deviceAffiliationIds: ").append(toIndentedString(deviceAffiliationIds)).append("\n");
    sb.append("    deviceEnrollmentDomain: ").append(toIndentedString(deviceEnrollmentDomain)).append("\n");
    sb.append("    deviceManufacturer: ").append(toIndentedString(deviceManufacturer)).append("\n");
    sb.append("    deviceModel: ").append(toIndentedString(deviceModel)).append("\n");
    sb.append("    diskEncryption: ").append(toIndentedString(diskEncryption)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    hostname: ").append(toIndentedString(hostname)).append("\n");
    sb.append("    imei: ").append(toIndentedString(imei)).append("\n");
    sb.append("    macAddresses: ").append(toIndentedString(macAddresses)).append("\n");
    sb.append("    meid: ").append(toIndentedString(meid)).append("\n");
    sb.append("    operatingSystem: ").append(toIndentedString(operatingSystem)).append("\n");
    sb.append("    osFirewall: ").append(toIndentedString(osFirewall)).append("\n");
    sb.append("    osVersion: ").append(toIndentedString(osVersion)).append("\n");
    sb.append("    passwordProtectionWarningTrigger: ").append(toIndentedString(passwordProtectionWarningTrigger)).append("\n");
    sb.append("    profileAffiliationIds: ").append(toIndentedString(profileAffiliationIds)).append("\n");
    sb.append("    realtimeUrlCheckMode: ").append(toIndentedString(realtimeUrlCheckMode)).append("\n");
    sb.append("    safeBrowsingProtectionLevel: ").append(toIndentedString(safeBrowsingProtectionLevel)).append("\n");
    sb.append("    screenLockSecured: ").append(toIndentedString(screenLockSecured)).append("\n");
    sb.append("    secureBootMode: ").append(toIndentedString(secureBootMode)).append("\n");
    sb.append("    serialNumber: ").append(toIndentedString(serialNumber)).append("\n");
    sb.append("    siteIsolationEnabled: ").append(toIndentedString(siteIsolationEnabled)).append("\n");
    sb.append("    systemDnsServers: ").append(toIndentedString(systemDnsServers)).append("\n");
    sb.append("    thirdPartyBlockingEnabled: ").append(toIndentedString(thirdPartyBlockingEnabled)).append("\n");
    sb.append("    trigger: ").append(toIndentedString(trigger)).append("\n");
    sb.append("    windowsMachineDomain: ").append(toIndentedString(windowsMachineDomain)).append("\n");
    sb.append("    windowsUserDomain: ").append(toIndentedString(windowsUserDomain)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowScreenLock");
    openapiFields.add("browserVersion");
    openapiFields.add("builtInDnsClientEnabled");
    openapiFields.add("chromeRemoteDesktopAppBlocked");
    openapiFields.add("crowdStrikeAgent");
    openapiFields.add("deviceAffiliationIds");
    openapiFields.add("deviceEnrollmentDomain");
    openapiFields.add("deviceManufacturer");
    openapiFields.add("deviceModel");
    openapiFields.add("diskEncryption");
    openapiFields.add("displayName");
    openapiFields.add("hostname");
    openapiFields.add("imei");
    openapiFields.add("macAddresses");
    openapiFields.add("meid");
    openapiFields.add("operatingSystem");
    openapiFields.add("osFirewall");
    openapiFields.add("osVersion");
    openapiFields.add("passwordProtectionWarningTrigger");
    openapiFields.add("profileAffiliationIds");
    openapiFields.add("realtimeUrlCheckMode");
    openapiFields.add("safeBrowsingProtectionLevel");
    openapiFields.add("screenLockSecured");
    openapiFields.add("secureBootMode");
    openapiFields.add("serialNumber");
    openapiFields.add("siteIsolationEnabled");
    openapiFields.add("systemDnsServers");
    openapiFields.add("thirdPartyBlockingEnabled");
    openapiFields.add("trigger");
    openapiFields.add("windowsMachineDomain");
    openapiFields.add("windowsUserDomain");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DeviceSignals
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DeviceSignals.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DeviceSignals is not found in the empty JSON string", DeviceSignals.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DeviceSignals.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DeviceSignals` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("browserVersion") != null && !jsonObj.get("browserVersion").isJsonNull()) && !jsonObj.get("browserVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `browserVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("browserVersion").toString()));
      }
      // validate the optional field `crowdStrikeAgent`
      if (jsonObj.get("crowdStrikeAgent") != null && !jsonObj.get("crowdStrikeAgent").isJsonNull()) {
        CrowdStrikeAgent.validateJsonElement(jsonObj.get("crowdStrikeAgent"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("deviceAffiliationIds") != null && !jsonObj.get("deviceAffiliationIds").isJsonNull() && !jsonObj.get("deviceAffiliationIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceAffiliationIds` to be an array in the JSON string but got `%s`", jsonObj.get("deviceAffiliationIds").toString()));
      }
      if ((jsonObj.get("deviceEnrollmentDomain") != null && !jsonObj.get("deviceEnrollmentDomain").isJsonNull()) && !jsonObj.get("deviceEnrollmentDomain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceEnrollmentDomain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceEnrollmentDomain").toString()));
      }
      if ((jsonObj.get("deviceManufacturer") != null && !jsonObj.get("deviceManufacturer").isJsonNull()) && !jsonObj.get("deviceManufacturer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceManufacturer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceManufacturer").toString()));
      }
      if ((jsonObj.get("deviceModel") != null && !jsonObj.get("deviceModel").isJsonNull()) && !jsonObj.get("deviceModel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deviceModel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deviceModel").toString()));
      }
      if ((jsonObj.get("diskEncryption") != null && !jsonObj.get("diskEncryption").isJsonNull()) && !jsonObj.get("diskEncryption").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `diskEncryption` to be a primitive type in the JSON string but got `%s`", jsonObj.get("diskEncryption").toString()));
      }
      // validate the optional field `diskEncryption`
      if (jsonObj.get("diskEncryption") != null && !jsonObj.get("diskEncryption").isJsonNull()) {
        DiskEncryptionEnum.validateJsonElement(jsonObj.get("diskEncryption"));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("hostname") != null && !jsonObj.get("hostname").isJsonNull()) && !jsonObj.get("hostname").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("imei") != null && !jsonObj.get("imei").isJsonNull() && !jsonObj.get("imei").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `imei` to be an array in the JSON string but got `%s`", jsonObj.get("imei").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("macAddresses") != null && !jsonObj.get("macAddresses").isJsonNull() && !jsonObj.get("macAddresses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `macAddresses` to be an array in the JSON string but got `%s`", jsonObj.get("macAddresses").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("meid") != null && !jsonObj.get("meid").isJsonNull() && !jsonObj.get("meid").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `meid` to be an array in the JSON string but got `%s`", jsonObj.get("meid").toString()));
      }
      if ((jsonObj.get("operatingSystem") != null && !jsonObj.get("operatingSystem").isJsonNull()) && !jsonObj.get("operatingSystem").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `operatingSystem` to be a primitive type in the JSON string but got `%s`", jsonObj.get("operatingSystem").toString()));
      }
      // validate the optional field `operatingSystem`
      if (jsonObj.get("operatingSystem") != null && !jsonObj.get("operatingSystem").isJsonNull()) {
        OperatingSystemEnum.validateJsonElement(jsonObj.get("operatingSystem"));
      }
      if ((jsonObj.get("osFirewall") != null && !jsonObj.get("osFirewall").isJsonNull()) && !jsonObj.get("osFirewall").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `osFirewall` to be a primitive type in the JSON string but got `%s`", jsonObj.get("osFirewall").toString()));
      }
      // validate the optional field `osFirewall`
      if (jsonObj.get("osFirewall") != null && !jsonObj.get("osFirewall").isJsonNull()) {
        OsFirewallEnum.validateJsonElement(jsonObj.get("osFirewall"));
      }
      if ((jsonObj.get("osVersion") != null && !jsonObj.get("osVersion").isJsonNull()) && !jsonObj.get("osVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `osVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("osVersion").toString()));
      }
      if ((jsonObj.get("passwordProtectionWarningTrigger") != null && !jsonObj.get("passwordProtectionWarningTrigger").isJsonNull()) && !jsonObj.get("passwordProtectionWarningTrigger").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `passwordProtectionWarningTrigger` to be a primitive type in the JSON string but got `%s`", jsonObj.get("passwordProtectionWarningTrigger").toString()));
      }
      // validate the optional field `passwordProtectionWarningTrigger`
      if (jsonObj.get("passwordProtectionWarningTrigger") != null && !jsonObj.get("passwordProtectionWarningTrigger").isJsonNull()) {
        PasswordProtectionWarningTriggerEnum.validateJsonElement(jsonObj.get("passwordProtectionWarningTrigger"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("profileAffiliationIds") != null && !jsonObj.get("profileAffiliationIds").isJsonNull() && !jsonObj.get("profileAffiliationIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `profileAffiliationIds` to be an array in the JSON string but got `%s`", jsonObj.get("profileAffiliationIds").toString()));
      }
      if ((jsonObj.get("realtimeUrlCheckMode") != null && !jsonObj.get("realtimeUrlCheckMode").isJsonNull()) && !jsonObj.get("realtimeUrlCheckMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `realtimeUrlCheckMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("realtimeUrlCheckMode").toString()));
      }
      // validate the optional field `realtimeUrlCheckMode`
      if (jsonObj.get("realtimeUrlCheckMode") != null && !jsonObj.get("realtimeUrlCheckMode").isJsonNull()) {
        RealtimeUrlCheckModeEnum.validateJsonElement(jsonObj.get("realtimeUrlCheckMode"));
      }
      if ((jsonObj.get("safeBrowsingProtectionLevel") != null && !jsonObj.get("safeBrowsingProtectionLevel").isJsonNull()) && !jsonObj.get("safeBrowsingProtectionLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `safeBrowsingProtectionLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("safeBrowsingProtectionLevel").toString()));
      }
      // validate the optional field `safeBrowsingProtectionLevel`
      if (jsonObj.get("safeBrowsingProtectionLevel") != null && !jsonObj.get("safeBrowsingProtectionLevel").isJsonNull()) {
        SafeBrowsingProtectionLevelEnum.validateJsonElement(jsonObj.get("safeBrowsingProtectionLevel"));
      }
      if ((jsonObj.get("screenLockSecured") != null && !jsonObj.get("screenLockSecured").isJsonNull()) && !jsonObj.get("screenLockSecured").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `screenLockSecured` to be a primitive type in the JSON string but got `%s`", jsonObj.get("screenLockSecured").toString()));
      }
      // validate the optional field `screenLockSecured`
      if (jsonObj.get("screenLockSecured") != null && !jsonObj.get("screenLockSecured").isJsonNull()) {
        ScreenLockSecuredEnum.validateJsonElement(jsonObj.get("screenLockSecured"));
      }
      if ((jsonObj.get("secureBootMode") != null && !jsonObj.get("secureBootMode").isJsonNull()) && !jsonObj.get("secureBootMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secureBootMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secureBootMode").toString()));
      }
      // validate the optional field `secureBootMode`
      if (jsonObj.get("secureBootMode") != null && !jsonObj.get("secureBootMode").isJsonNull()) {
        SecureBootModeEnum.validateJsonElement(jsonObj.get("secureBootMode"));
      }
      if ((jsonObj.get("serialNumber") != null && !jsonObj.get("serialNumber").isJsonNull()) && !jsonObj.get("serialNumber").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serialNumber` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serialNumber").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("systemDnsServers") != null && !jsonObj.get("systemDnsServers").isJsonNull() && !jsonObj.get("systemDnsServers").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `systemDnsServers` to be an array in the JSON string but got `%s`", jsonObj.get("systemDnsServers").toString()));
      }
      if ((jsonObj.get("trigger") != null && !jsonObj.get("trigger").isJsonNull()) && !jsonObj.get("trigger").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trigger` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trigger").toString()));
      }
      // validate the optional field `trigger`
      if (jsonObj.get("trigger") != null && !jsonObj.get("trigger").isJsonNull()) {
        TriggerEnum.validateJsonElement(jsonObj.get("trigger"));
      }
      if ((jsonObj.get("windowsMachineDomain") != null && !jsonObj.get("windowsMachineDomain").isJsonNull()) && !jsonObj.get("windowsMachineDomain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `windowsMachineDomain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("windowsMachineDomain").toString()));
      }
      if ((jsonObj.get("windowsUserDomain") != null && !jsonObj.get("windowsUserDomain").isJsonNull()) && !jsonObj.get("windowsUserDomain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `windowsUserDomain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("windowsUserDomain").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DeviceSignals.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DeviceSignals' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DeviceSignals> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DeviceSignals.class));

       return (TypeAdapter<T>) new TypeAdapter<DeviceSignals>() {
           @Override
           public void write(JsonWriter out, DeviceSignals value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DeviceSignals read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DeviceSignals given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DeviceSignals
   * @throws IOException if the JSON string is invalid with respect to DeviceSignals
   */
  public static DeviceSignals fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DeviceSignals.class);
  }

  /**
   * Convert an instance of DeviceSignals to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

