/**
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIAnnotationPayload.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIAnnotationPayload::OAIAnnotationPayload(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIAnnotationPayload::OAIAnnotationPayload() {
    this->initializeModel();
}

OAIAnnotationPayload::~OAIAnnotationPayload() {}

void OAIAnnotationPayload::initializeModel() {

    m_annotation_spec_id_isSet = false;
    m_annotation_spec_id_isValid = false;

    m_classification_isSet = false;
    m_classification_isValid = false;

    m_display_name_isSet = false;
    m_display_name_isValid = false;

    m_image_object_detection_isSet = false;
    m_image_object_detection_isValid = false;

    m_tables_isSet = false;
    m_tables_isValid = false;

    m_text_extraction_isSet = false;
    m_text_extraction_isValid = false;

    m_text_sentiment_isSet = false;
    m_text_sentiment_isValid = false;

    m_translation_isSet = false;
    m_translation_isValid = false;

    m_video_classification_isSet = false;
    m_video_classification_isValid = false;

    m_video_object_tracking_isSet = false;
    m_video_object_tracking_isValid = false;
}

void OAIAnnotationPayload::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIAnnotationPayload::fromJsonObject(QJsonObject json) {

    m_annotation_spec_id_isValid = ::OpenAPI::fromJsonValue(m_annotation_spec_id, json[QString("annotationSpecId")]);
    m_annotation_spec_id_isSet = !json[QString("annotationSpecId")].isNull() && m_annotation_spec_id_isValid;

    m_classification_isValid = ::OpenAPI::fromJsonValue(m_classification, json[QString("classification")]);
    m_classification_isSet = !json[QString("classification")].isNull() && m_classification_isValid;

    m_display_name_isValid = ::OpenAPI::fromJsonValue(m_display_name, json[QString("displayName")]);
    m_display_name_isSet = !json[QString("displayName")].isNull() && m_display_name_isValid;

    m_image_object_detection_isValid = ::OpenAPI::fromJsonValue(m_image_object_detection, json[QString("imageObjectDetection")]);
    m_image_object_detection_isSet = !json[QString("imageObjectDetection")].isNull() && m_image_object_detection_isValid;

    m_tables_isValid = ::OpenAPI::fromJsonValue(m_tables, json[QString("tables")]);
    m_tables_isSet = !json[QString("tables")].isNull() && m_tables_isValid;

    m_text_extraction_isValid = ::OpenAPI::fromJsonValue(m_text_extraction, json[QString("textExtraction")]);
    m_text_extraction_isSet = !json[QString("textExtraction")].isNull() && m_text_extraction_isValid;

    m_text_sentiment_isValid = ::OpenAPI::fromJsonValue(m_text_sentiment, json[QString("textSentiment")]);
    m_text_sentiment_isSet = !json[QString("textSentiment")].isNull() && m_text_sentiment_isValid;

    m_translation_isValid = ::OpenAPI::fromJsonValue(m_translation, json[QString("translation")]);
    m_translation_isSet = !json[QString("translation")].isNull() && m_translation_isValid;

    m_video_classification_isValid = ::OpenAPI::fromJsonValue(m_video_classification, json[QString("videoClassification")]);
    m_video_classification_isSet = !json[QString("videoClassification")].isNull() && m_video_classification_isValid;

    m_video_object_tracking_isValid = ::OpenAPI::fromJsonValue(m_video_object_tracking, json[QString("videoObjectTracking")]);
    m_video_object_tracking_isSet = !json[QString("videoObjectTracking")].isNull() && m_video_object_tracking_isValid;
}

QString OAIAnnotationPayload::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIAnnotationPayload::asJsonObject() const {
    QJsonObject obj;
    if (m_annotation_spec_id_isSet) {
        obj.insert(QString("annotationSpecId"), ::OpenAPI::toJsonValue(m_annotation_spec_id));
    }
    if (m_classification.isSet()) {
        obj.insert(QString("classification"), ::OpenAPI::toJsonValue(m_classification));
    }
    if (m_display_name_isSet) {
        obj.insert(QString("displayName"), ::OpenAPI::toJsonValue(m_display_name));
    }
    if (m_image_object_detection.isSet()) {
        obj.insert(QString("imageObjectDetection"), ::OpenAPI::toJsonValue(m_image_object_detection));
    }
    if (m_tables.isSet()) {
        obj.insert(QString("tables"), ::OpenAPI::toJsonValue(m_tables));
    }
    if (m_text_extraction.isSet()) {
        obj.insert(QString("textExtraction"), ::OpenAPI::toJsonValue(m_text_extraction));
    }
    if (m_text_sentiment.isSet()) {
        obj.insert(QString("textSentiment"), ::OpenAPI::toJsonValue(m_text_sentiment));
    }
    if (m_translation.isSet()) {
        obj.insert(QString("translation"), ::OpenAPI::toJsonValue(m_translation));
    }
    if (m_video_classification.isSet()) {
        obj.insert(QString("videoClassification"), ::OpenAPI::toJsonValue(m_video_classification));
    }
    if (m_video_object_tracking.isSet()) {
        obj.insert(QString("videoObjectTracking"), ::OpenAPI::toJsonValue(m_video_object_tracking));
    }
    return obj;
}

QString OAIAnnotationPayload::getAnnotationSpecId() const {
    return m_annotation_spec_id;
}
void OAIAnnotationPayload::setAnnotationSpecId(const QString &annotation_spec_id) {
    m_annotation_spec_id = annotation_spec_id;
    m_annotation_spec_id_isSet = true;
}

bool OAIAnnotationPayload::is_annotation_spec_id_Set() const{
    return m_annotation_spec_id_isSet;
}

bool OAIAnnotationPayload::is_annotation_spec_id_Valid() const{
    return m_annotation_spec_id_isValid;
}

OAIClassificationAnnotation OAIAnnotationPayload::getClassification() const {
    return m_classification;
}
void OAIAnnotationPayload::setClassification(const OAIClassificationAnnotation &classification) {
    m_classification = classification;
    m_classification_isSet = true;
}

bool OAIAnnotationPayload::is_classification_Set() const{
    return m_classification_isSet;
}

bool OAIAnnotationPayload::is_classification_Valid() const{
    return m_classification_isValid;
}

QString OAIAnnotationPayload::getDisplayName() const {
    return m_display_name;
}
void OAIAnnotationPayload::setDisplayName(const QString &display_name) {
    m_display_name = display_name;
    m_display_name_isSet = true;
}

bool OAIAnnotationPayload::is_display_name_Set() const{
    return m_display_name_isSet;
}

bool OAIAnnotationPayload::is_display_name_Valid() const{
    return m_display_name_isValid;
}

OAIImageObjectDetectionAnnotation OAIAnnotationPayload::getImageObjectDetection() const {
    return m_image_object_detection;
}
void OAIAnnotationPayload::setImageObjectDetection(const OAIImageObjectDetectionAnnotation &image_object_detection) {
    m_image_object_detection = image_object_detection;
    m_image_object_detection_isSet = true;
}

bool OAIAnnotationPayload::is_image_object_detection_Set() const{
    return m_image_object_detection_isSet;
}

bool OAIAnnotationPayload::is_image_object_detection_Valid() const{
    return m_image_object_detection_isValid;
}

OAITablesAnnotation OAIAnnotationPayload::getTables() const {
    return m_tables;
}
void OAIAnnotationPayload::setTables(const OAITablesAnnotation &tables) {
    m_tables = tables;
    m_tables_isSet = true;
}

bool OAIAnnotationPayload::is_tables_Set() const{
    return m_tables_isSet;
}

bool OAIAnnotationPayload::is_tables_Valid() const{
    return m_tables_isValid;
}

OAITextExtractionAnnotation OAIAnnotationPayload::getTextExtraction() const {
    return m_text_extraction;
}
void OAIAnnotationPayload::setTextExtraction(const OAITextExtractionAnnotation &text_extraction) {
    m_text_extraction = text_extraction;
    m_text_extraction_isSet = true;
}

bool OAIAnnotationPayload::is_text_extraction_Set() const{
    return m_text_extraction_isSet;
}

bool OAIAnnotationPayload::is_text_extraction_Valid() const{
    return m_text_extraction_isValid;
}

OAITextSentimentAnnotation OAIAnnotationPayload::getTextSentiment() const {
    return m_text_sentiment;
}
void OAIAnnotationPayload::setTextSentiment(const OAITextSentimentAnnotation &text_sentiment) {
    m_text_sentiment = text_sentiment;
    m_text_sentiment_isSet = true;
}

bool OAIAnnotationPayload::is_text_sentiment_Set() const{
    return m_text_sentiment_isSet;
}

bool OAIAnnotationPayload::is_text_sentiment_Valid() const{
    return m_text_sentiment_isValid;
}

OAITranslationAnnotation OAIAnnotationPayload::getTranslation() const {
    return m_translation;
}
void OAIAnnotationPayload::setTranslation(const OAITranslationAnnotation &translation) {
    m_translation = translation;
    m_translation_isSet = true;
}

bool OAIAnnotationPayload::is_translation_Set() const{
    return m_translation_isSet;
}

bool OAIAnnotationPayload::is_translation_Valid() const{
    return m_translation_isValid;
}

OAIVideoClassificationAnnotation OAIAnnotationPayload::getVideoClassification() const {
    return m_video_classification;
}
void OAIAnnotationPayload::setVideoClassification(const OAIVideoClassificationAnnotation &video_classification) {
    m_video_classification = video_classification;
    m_video_classification_isSet = true;
}

bool OAIAnnotationPayload::is_video_classification_Set() const{
    return m_video_classification_isSet;
}

bool OAIAnnotationPayload::is_video_classification_Valid() const{
    return m_video_classification_isValid;
}

OAIVideoObjectTrackingAnnotation OAIAnnotationPayload::getVideoObjectTracking() const {
    return m_video_object_tracking;
}
void OAIAnnotationPayload::setVideoObjectTracking(const OAIVideoObjectTrackingAnnotation &video_object_tracking) {
    m_video_object_tracking = video_object_tracking;
    m_video_object_tracking_isSet = true;
}

bool OAIAnnotationPayload::is_video_object_tracking_Set() const{
    return m_video_object_tracking_isSet;
}

bool OAIAnnotationPayload::is_video_object_tracking_Valid() const{
    return m_video_object_tracking_isValid;
}

bool OAIAnnotationPayload::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_annotation_spec_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_classification.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_image_object_detection.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tables.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_text_extraction.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_text_sentiment.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_translation.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_video_classification.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_video_object_tracking.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIAnnotationPayload::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
