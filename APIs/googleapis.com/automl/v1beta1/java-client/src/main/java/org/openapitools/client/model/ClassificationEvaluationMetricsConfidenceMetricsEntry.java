/*
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Metrics for a single confidence threshold.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:50.092187-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ClassificationEvaluationMetricsConfidenceMetricsEntry {
  public static final String SERIALIZED_NAME_CONFIDENCE_THRESHOLD = "confidenceThreshold";
  @SerializedName(SERIALIZED_NAME_CONFIDENCE_THRESHOLD)
  private Float confidenceThreshold;

  public static final String SERIALIZED_NAME_F1_SCORE = "f1Score";
  @SerializedName(SERIALIZED_NAME_F1_SCORE)
  private Float f1Score;

  public static final String SERIALIZED_NAME_F1_SCORE_AT1 = "f1ScoreAt1";
  @SerializedName(SERIALIZED_NAME_F1_SCORE_AT1)
  private Float f1ScoreAt1;

  public static final String SERIALIZED_NAME_FALSE_NEGATIVE_COUNT = "falseNegativeCount";
  @SerializedName(SERIALIZED_NAME_FALSE_NEGATIVE_COUNT)
  private String falseNegativeCount;

  public static final String SERIALIZED_NAME_FALSE_POSITIVE_COUNT = "falsePositiveCount";
  @SerializedName(SERIALIZED_NAME_FALSE_POSITIVE_COUNT)
  private String falsePositiveCount;

  public static final String SERIALIZED_NAME_FALSE_POSITIVE_RATE = "falsePositiveRate";
  @SerializedName(SERIALIZED_NAME_FALSE_POSITIVE_RATE)
  private Float falsePositiveRate;

  public static final String SERIALIZED_NAME_FALSE_POSITIVE_RATE_AT1 = "falsePositiveRateAt1";
  @SerializedName(SERIALIZED_NAME_FALSE_POSITIVE_RATE_AT1)
  private Float falsePositiveRateAt1;

  public static final String SERIALIZED_NAME_POSITION_THRESHOLD = "positionThreshold";
  @SerializedName(SERIALIZED_NAME_POSITION_THRESHOLD)
  private Integer positionThreshold;

  public static final String SERIALIZED_NAME_PRECISION = "precision";
  @SerializedName(SERIALIZED_NAME_PRECISION)
  private Float precision;

  public static final String SERIALIZED_NAME_PRECISION_AT1 = "precisionAt1";
  @SerializedName(SERIALIZED_NAME_PRECISION_AT1)
  private Float precisionAt1;

  public static final String SERIALIZED_NAME_RECALL = "recall";
  @SerializedName(SERIALIZED_NAME_RECALL)
  private Float recall;

  public static final String SERIALIZED_NAME_RECALL_AT1 = "recallAt1";
  @SerializedName(SERIALIZED_NAME_RECALL_AT1)
  private Float recallAt1;

  public static final String SERIALIZED_NAME_TRUE_NEGATIVE_COUNT = "trueNegativeCount";
  @SerializedName(SERIALIZED_NAME_TRUE_NEGATIVE_COUNT)
  private String trueNegativeCount;

  public static final String SERIALIZED_NAME_TRUE_POSITIVE_COUNT = "truePositiveCount";
  @SerializedName(SERIALIZED_NAME_TRUE_POSITIVE_COUNT)
  private String truePositiveCount;

  public ClassificationEvaluationMetricsConfidenceMetricsEntry() {
  }

  public ClassificationEvaluationMetricsConfidenceMetricsEntry confidenceThreshold(Float confidenceThreshold) {
    this.confidenceThreshold = confidenceThreshold;
    return this;
  }

  /**
   * Output only. Metrics are computed with an assumption that the model never returns predictions with score lower than this value.
   * @return confidenceThreshold
   */
  @javax.annotation.Nullable
  public Float getConfidenceThreshold() {
    return confidenceThreshold;
  }

  public void setConfidenceThreshold(Float confidenceThreshold) {
    this.confidenceThreshold = confidenceThreshold;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry f1Score(Float f1Score) {
    this.f1Score = f1Score;
    return this;
  }

  /**
   * Output only. The harmonic mean of recall and precision.
   * @return f1Score
   */
  @javax.annotation.Nullable
  public Float getF1Score() {
    return f1Score;
  }

  public void setF1Score(Float f1Score) {
    this.f1Score = f1Score;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry f1ScoreAt1(Float f1ScoreAt1) {
    this.f1ScoreAt1 = f1ScoreAt1;
    return this;
  }

  /**
   * Output only. The harmonic mean of recall_at1 and precision_at1.
   * @return f1ScoreAt1
   */
  @javax.annotation.Nullable
  public Float getF1ScoreAt1() {
    return f1ScoreAt1;
  }

  public void setF1ScoreAt1(Float f1ScoreAt1) {
    this.f1ScoreAt1 = f1ScoreAt1;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry falseNegativeCount(String falseNegativeCount) {
    this.falseNegativeCount = falseNegativeCount;
    return this;
  }

  /**
   * Output only. The number of ground truth labels that are not matched by a model created label.
   * @return falseNegativeCount
   */
  @javax.annotation.Nullable
  public String getFalseNegativeCount() {
    return falseNegativeCount;
  }

  public void setFalseNegativeCount(String falseNegativeCount) {
    this.falseNegativeCount = falseNegativeCount;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry falsePositiveCount(String falsePositiveCount) {
    this.falsePositiveCount = falsePositiveCount;
    return this;
  }

  /**
   * Output only. The number of model created labels that do not match a ground truth label.
   * @return falsePositiveCount
   */
  @javax.annotation.Nullable
  public String getFalsePositiveCount() {
    return falsePositiveCount;
  }

  public void setFalsePositiveCount(String falsePositiveCount) {
    this.falsePositiveCount = falsePositiveCount;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry falsePositiveRate(Float falsePositiveRate) {
    this.falsePositiveRate = falsePositiveRate;
    return this;
  }

  /**
   * Output only. False Positive Rate for the given confidence threshold.
   * @return falsePositiveRate
   */
  @javax.annotation.Nullable
  public Float getFalsePositiveRate() {
    return falsePositiveRate;
  }

  public void setFalsePositiveRate(Float falsePositiveRate) {
    this.falsePositiveRate = falsePositiveRate;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry falsePositiveRateAt1(Float falsePositiveRateAt1) {
    this.falsePositiveRateAt1 = falsePositiveRateAt1;
    return this;
  }

  /**
   * Output only. The False Positive Rate when only considering the label that has the highest prediction score and not below the confidence threshold for each example.
   * @return falsePositiveRateAt1
   */
  @javax.annotation.Nullable
  public Float getFalsePositiveRateAt1() {
    return falsePositiveRateAt1;
  }

  public void setFalsePositiveRateAt1(Float falsePositiveRateAt1) {
    this.falsePositiveRateAt1 = falsePositiveRateAt1;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry positionThreshold(Integer positionThreshold) {
    this.positionThreshold = positionThreshold;
    return this;
  }

  /**
   * Output only. Metrics are computed with an assumption that the model always returns at most this many predictions (ordered by their score, descendingly), but they all still need to meet the confidence_threshold.
   * @return positionThreshold
   */
  @javax.annotation.Nullable
  public Integer getPositionThreshold() {
    return positionThreshold;
  }

  public void setPositionThreshold(Integer positionThreshold) {
    this.positionThreshold = positionThreshold;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry precision(Float precision) {
    this.precision = precision;
    return this;
  }

  /**
   * Output only. Precision for the given confidence threshold.
   * @return precision
   */
  @javax.annotation.Nullable
  public Float getPrecision() {
    return precision;
  }

  public void setPrecision(Float precision) {
    this.precision = precision;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry precisionAt1(Float precisionAt1) {
    this.precisionAt1 = precisionAt1;
    return this;
  }

  /**
   * Output only. The precision when only considering the label that has the highest prediction score and not below the confidence threshold for each example.
   * @return precisionAt1
   */
  @javax.annotation.Nullable
  public Float getPrecisionAt1() {
    return precisionAt1;
  }

  public void setPrecisionAt1(Float precisionAt1) {
    this.precisionAt1 = precisionAt1;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry recall(Float recall) {
    this.recall = recall;
    return this;
  }

  /**
   * Output only. Recall (True Positive Rate) for the given confidence threshold.
   * @return recall
   */
  @javax.annotation.Nullable
  public Float getRecall() {
    return recall;
  }

  public void setRecall(Float recall) {
    this.recall = recall;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry recallAt1(Float recallAt1) {
    this.recallAt1 = recallAt1;
    return this;
  }

  /**
   * Output only. The Recall (True Positive Rate) when only considering the label that has the highest prediction score and not below the confidence threshold for each example.
   * @return recallAt1
   */
  @javax.annotation.Nullable
  public Float getRecallAt1() {
    return recallAt1;
  }

  public void setRecallAt1(Float recallAt1) {
    this.recallAt1 = recallAt1;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry trueNegativeCount(String trueNegativeCount) {
    this.trueNegativeCount = trueNegativeCount;
    return this;
  }

  /**
   * Output only. The number of labels that were not created by the model, but if they would, they would not match a ground truth label.
   * @return trueNegativeCount
   */
  @javax.annotation.Nullable
  public String getTrueNegativeCount() {
    return trueNegativeCount;
  }

  public void setTrueNegativeCount(String trueNegativeCount) {
    this.trueNegativeCount = trueNegativeCount;
  }


  public ClassificationEvaluationMetricsConfidenceMetricsEntry truePositiveCount(String truePositiveCount) {
    this.truePositiveCount = truePositiveCount;
    return this;
  }

  /**
   * Output only. The number of model created labels that match a ground truth label.
   * @return truePositiveCount
   */
  @javax.annotation.Nullable
  public String getTruePositiveCount() {
    return truePositiveCount;
  }

  public void setTruePositiveCount(String truePositiveCount) {
    this.truePositiveCount = truePositiveCount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ClassificationEvaluationMetricsConfidenceMetricsEntry classificationEvaluationMetricsConfidenceMetricsEntry = (ClassificationEvaluationMetricsConfidenceMetricsEntry) o;
    return Objects.equals(this.confidenceThreshold, classificationEvaluationMetricsConfidenceMetricsEntry.confidenceThreshold) &&
        Objects.equals(this.f1Score, classificationEvaluationMetricsConfidenceMetricsEntry.f1Score) &&
        Objects.equals(this.f1ScoreAt1, classificationEvaluationMetricsConfidenceMetricsEntry.f1ScoreAt1) &&
        Objects.equals(this.falseNegativeCount, classificationEvaluationMetricsConfidenceMetricsEntry.falseNegativeCount) &&
        Objects.equals(this.falsePositiveCount, classificationEvaluationMetricsConfidenceMetricsEntry.falsePositiveCount) &&
        Objects.equals(this.falsePositiveRate, classificationEvaluationMetricsConfidenceMetricsEntry.falsePositiveRate) &&
        Objects.equals(this.falsePositiveRateAt1, classificationEvaluationMetricsConfidenceMetricsEntry.falsePositiveRateAt1) &&
        Objects.equals(this.positionThreshold, classificationEvaluationMetricsConfidenceMetricsEntry.positionThreshold) &&
        Objects.equals(this.precision, classificationEvaluationMetricsConfidenceMetricsEntry.precision) &&
        Objects.equals(this.precisionAt1, classificationEvaluationMetricsConfidenceMetricsEntry.precisionAt1) &&
        Objects.equals(this.recall, classificationEvaluationMetricsConfidenceMetricsEntry.recall) &&
        Objects.equals(this.recallAt1, classificationEvaluationMetricsConfidenceMetricsEntry.recallAt1) &&
        Objects.equals(this.trueNegativeCount, classificationEvaluationMetricsConfidenceMetricsEntry.trueNegativeCount) &&
        Objects.equals(this.truePositiveCount, classificationEvaluationMetricsConfidenceMetricsEntry.truePositiveCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(confidenceThreshold, f1Score, f1ScoreAt1, falseNegativeCount, falsePositiveCount, falsePositiveRate, falsePositiveRateAt1, positionThreshold, precision, precisionAt1, recall, recallAt1, trueNegativeCount, truePositiveCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ClassificationEvaluationMetricsConfidenceMetricsEntry {\n");
    sb.append("    confidenceThreshold: ").append(toIndentedString(confidenceThreshold)).append("\n");
    sb.append("    f1Score: ").append(toIndentedString(f1Score)).append("\n");
    sb.append("    f1ScoreAt1: ").append(toIndentedString(f1ScoreAt1)).append("\n");
    sb.append("    falseNegativeCount: ").append(toIndentedString(falseNegativeCount)).append("\n");
    sb.append("    falsePositiveCount: ").append(toIndentedString(falsePositiveCount)).append("\n");
    sb.append("    falsePositiveRate: ").append(toIndentedString(falsePositiveRate)).append("\n");
    sb.append("    falsePositiveRateAt1: ").append(toIndentedString(falsePositiveRateAt1)).append("\n");
    sb.append("    positionThreshold: ").append(toIndentedString(positionThreshold)).append("\n");
    sb.append("    precision: ").append(toIndentedString(precision)).append("\n");
    sb.append("    precisionAt1: ").append(toIndentedString(precisionAt1)).append("\n");
    sb.append("    recall: ").append(toIndentedString(recall)).append("\n");
    sb.append("    recallAt1: ").append(toIndentedString(recallAt1)).append("\n");
    sb.append("    trueNegativeCount: ").append(toIndentedString(trueNegativeCount)).append("\n");
    sb.append("    truePositiveCount: ").append(toIndentedString(truePositiveCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("confidenceThreshold");
    openapiFields.add("f1Score");
    openapiFields.add("f1ScoreAt1");
    openapiFields.add("falseNegativeCount");
    openapiFields.add("falsePositiveCount");
    openapiFields.add("falsePositiveRate");
    openapiFields.add("falsePositiveRateAt1");
    openapiFields.add("positionThreshold");
    openapiFields.add("precision");
    openapiFields.add("precisionAt1");
    openapiFields.add("recall");
    openapiFields.add("recallAt1");
    openapiFields.add("trueNegativeCount");
    openapiFields.add("truePositiveCount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ClassificationEvaluationMetricsConfidenceMetricsEntry
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ClassificationEvaluationMetricsConfidenceMetricsEntry.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ClassificationEvaluationMetricsConfidenceMetricsEntry is not found in the empty JSON string", ClassificationEvaluationMetricsConfidenceMetricsEntry.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ClassificationEvaluationMetricsConfidenceMetricsEntry.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ClassificationEvaluationMetricsConfidenceMetricsEntry` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("falseNegativeCount") != null && !jsonObj.get("falseNegativeCount").isJsonNull()) && !jsonObj.get("falseNegativeCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `falseNegativeCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("falseNegativeCount").toString()));
      }
      if ((jsonObj.get("falsePositiveCount") != null && !jsonObj.get("falsePositiveCount").isJsonNull()) && !jsonObj.get("falsePositiveCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `falsePositiveCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("falsePositiveCount").toString()));
      }
      if ((jsonObj.get("trueNegativeCount") != null && !jsonObj.get("trueNegativeCount").isJsonNull()) && !jsonObj.get("trueNegativeCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trueNegativeCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trueNegativeCount").toString()));
      }
      if ((jsonObj.get("truePositiveCount") != null && !jsonObj.get("truePositiveCount").isJsonNull()) && !jsonObj.get("truePositiveCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `truePositiveCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("truePositiveCount").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ClassificationEvaluationMetricsConfidenceMetricsEntry.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ClassificationEvaluationMetricsConfidenceMetricsEntry' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ClassificationEvaluationMetricsConfidenceMetricsEntry> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ClassificationEvaluationMetricsConfidenceMetricsEntry.class));

       return (TypeAdapter<T>) new TypeAdapter<ClassificationEvaluationMetricsConfidenceMetricsEntry>() {
           @Override
           public void write(JsonWriter out, ClassificationEvaluationMetricsConfidenceMetricsEntry value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ClassificationEvaluationMetricsConfidenceMetricsEntry read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ClassificationEvaluationMetricsConfidenceMetricsEntry given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ClassificationEvaluationMetricsConfidenceMetricsEntry
   * @throws IOException if the JSON string is invalid with respect to ClassificationEvaluationMetricsConfidenceMetricsEntry
   */
  public static ClassificationEvaluationMetricsConfidenceMetricsEntry fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ClassificationEvaluationMetricsConfidenceMetricsEntry.class);
  }

  /**
   * Convert an instance of ClassificationEvaluationMetricsConfidenceMetricsEntry to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

