/*
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.BoundingPoly;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Annotation details for video object tracking.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:50.092187-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VideoObjectTrackingAnnotation {
  public static final String SERIALIZED_NAME_BOUNDING_BOX = "boundingBox";
  @SerializedName(SERIALIZED_NAME_BOUNDING_BOX)
  private BoundingPoly boundingBox;

  public static final String SERIALIZED_NAME_INSTANCE_ID = "instanceId";
  @SerializedName(SERIALIZED_NAME_INSTANCE_ID)
  private String instanceId;

  public static final String SERIALIZED_NAME_SCORE = "score";
  @SerializedName(SERIALIZED_NAME_SCORE)
  private Float score;

  public static final String SERIALIZED_NAME_TIME_OFFSET = "timeOffset";
  @SerializedName(SERIALIZED_NAME_TIME_OFFSET)
  private String timeOffset;

  public VideoObjectTrackingAnnotation() {
  }

  public VideoObjectTrackingAnnotation boundingBox(BoundingPoly boundingBox) {
    this.boundingBox = boundingBox;
    return this;
  }

  /**
   * Get boundingBox
   * @return boundingBox
   */
  @javax.annotation.Nullable
  public BoundingPoly getBoundingBox() {
    return boundingBox;
  }

  public void setBoundingBox(BoundingPoly boundingBox) {
    this.boundingBox = boundingBox;
  }


  public VideoObjectTrackingAnnotation instanceId(String instanceId) {
    this.instanceId = instanceId;
    return this;
  }

  /**
   * Optional. The instance of the object, expressed as a positive integer. Used to tell apart objects of the same type (i.e. AnnotationSpec) when multiple are present on a single example. NOTE: Instance ID prediction quality is not a part of model evaluation and is done as best effort. Especially in cases when an entity goes off-screen for a longer time (minutes), when it comes back it may be given a new instance ID.
   * @return instanceId
   */
  @javax.annotation.Nullable
  public String getInstanceId() {
    return instanceId;
  }

  public void setInstanceId(String instanceId) {
    this.instanceId = instanceId;
  }


  public VideoObjectTrackingAnnotation score(Float score) {
    this.score = score;
    return this;
  }

  /**
   * Output only. The confidence that this annotation is positive for the video at the time_offset, value in [0, 1], higher means higher positivity confidence. For annotations created by the user the score is 1. When user approves an annotation, the original float score is kept (and not changed to 1).
   * @return score
   */
  @javax.annotation.Nullable
  public Float getScore() {
    return score;
  }

  public void setScore(Float score) {
    this.score = score;
  }


  public VideoObjectTrackingAnnotation timeOffset(String timeOffset) {
    this.timeOffset = timeOffset;
    return this;
  }

  /**
   * Required. A time (frame) of a video to which this annotation pertains. Represented as the duration since the video&#39;s start.
   * @return timeOffset
   */
  @javax.annotation.Nullable
  public String getTimeOffset() {
    return timeOffset;
  }

  public void setTimeOffset(String timeOffset) {
    this.timeOffset = timeOffset;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoObjectTrackingAnnotation videoObjectTrackingAnnotation = (VideoObjectTrackingAnnotation) o;
    return Objects.equals(this.boundingBox, videoObjectTrackingAnnotation.boundingBox) &&
        Objects.equals(this.instanceId, videoObjectTrackingAnnotation.instanceId) &&
        Objects.equals(this.score, videoObjectTrackingAnnotation.score) &&
        Objects.equals(this.timeOffset, videoObjectTrackingAnnotation.timeOffset);
  }

  @Override
  public int hashCode() {
    return Objects.hash(boundingBox, instanceId, score, timeOffset);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoObjectTrackingAnnotation {\n");
    sb.append("    boundingBox: ").append(toIndentedString(boundingBox)).append("\n");
    sb.append("    instanceId: ").append(toIndentedString(instanceId)).append("\n");
    sb.append("    score: ").append(toIndentedString(score)).append("\n");
    sb.append("    timeOffset: ").append(toIndentedString(timeOffset)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("boundingBox");
    openapiFields.add("instanceId");
    openapiFields.add("score");
    openapiFields.add("timeOffset");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoObjectTrackingAnnotation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoObjectTrackingAnnotation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoObjectTrackingAnnotation is not found in the empty JSON string", VideoObjectTrackingAnnotation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VideoObjectTrackingAnnotation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VideoObjectTrackingAnnotation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `boundingBox`
      if (jsonObj.get("boundingBox") != null && !jsonObj.get("boundingBox").isJsonNull()) {
        BoundingPoly.validateJsonElement(jsonObj.get("boundingBox"));
      }
      if ((jsonObj.get("instanceId") != null && !jsonObj.get("instanceId").isJsonNull()) && !jsonObj.get("instanceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `instanceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("instanceId").toString()));
      }
      if ((jsonObj.get("timeOffset") != null && !jsonObj.get("timeOffset").isJsonNull()) && !jsonObj.get("timeOffset").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeOffset` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeOffset").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VideoObjectTrackingAnnotation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VideoObjectTrackingAnnotation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VideoObjectTrackingAnnotation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VideoObjectTrackingAnnotation.class));

       return (TypeAdapter<T>) new TypeAdapter<VideoObjectTrackingAnnotation>() {
           @Override
           public void write(JsonWriter out, VideoObjectTrackingAnnotation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VideoObjectTrackingAnnotation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VideoObjectTrackingAnnotation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoObjectTrackingAnnotation
   * @throws IOException if the JSON string is invalid with respect to VideoObjectTrackingAnnotation
   */
  public static VideoObjectTrackingAnnotation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoObjectTrackingAnnotation.class);
  }

  /**
   * Convert an instance of VideoObjectTrackingAnnotation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

