/*
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ClassificationAnnotation;
import org.openapitools.client.model.TimeSegment;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains annotation details specific to video classification.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:50.092187-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VideoClassificationAnnotation {
  public static final String SERIALIZED_NAME_CLASSIFICATION_ANNOTATION = "classificationAnnotation";
  @SerializedName(SERIALIZED_NAME_CLASSIFICATION_ANNOTATION)
  private ClassificationAnnotation classificationAnnotation;

  public static final String SERIALIZED_NAME_TIME_SEGMENT = "timeSegment";
  @SerializedName(SERIALIZED_NAME_TIME_SEGMENT)
  private TimeSegment timeSegment;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public VideoClassificationAnnotation() {
  }

  public VideoClassificationAnnotation classificationAnnotation(ClassificationAnnotation classificationAnnotation) {
    this.classificationAnnotation = classificationAnnotation;
    return this;
  }

  /**
   * Get classificationAnnotation
   * @return classificationAnnotation
   */
  @javax.annotation.Nullable
  public ClassificationAnnotation getClassificationAnnotation() {
    return classificationAnnotation;
  }

  public void setClassificationAnnotation(ClassificationAnnotation classificationAnnotation) {
    this.classificationAnnotation = classificationAnnotation;
  }


  public VideoClassificationAnnotation timeSegment(TimeSegment timeSegment) {
    this.timeSegment = timeSegment;
    return this;
  }

  /**
   * Get timeSegment
   * @return timeSegment
   */
  @javax.annotation.Nullable
  public TimeSegment getTimeSegment() {
    return timeSegment;
  }

  public void setTimeSegment(TimeSegment timeSegment) {
    this.timeSegment = timeSegment;
  }


  public VideoClassificationAnnotation type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Output only. Expresses the type of video classification. Possible values: * &#x60;segment&#x60; - Classification done on a specified by user time segment of a video. AnnotationSpec is answered to be present in that time segment, if it is present in any part of it. The video ML model evaluations are done only for this type of classification. * &#x60;shot&#x60;- Shot-level classification. AutoML Video Intelligence determines the boundaries for each camera shot in the entire segment of the video that user specified in the request configuration. AutoML Video Intelligence then returns labels and their confidence scores for each detected shot, along with the start and end time of the shot. WARNING: Model evaluation is not done for this classification type, the quality of it depends on training data, but there are no metrics provided to describe that quality. * &#x60;1s_interval&#x60; - AutoML Video Intelligence returns labels and their confidence scores for each second of the entire segment of the video that user specified in the request configuration. WARNING: Model evaluation is not done for this classification type, the quality of it depends on training data, but there are no metrics provided to describe that quality.
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoClassificationAnnotation videoClassificationAnnotation = (VideoClassificationAnnotation) o;
    return Objects.equals(this.classificationAnnotation, videoClassificationAnnotation.classificationAnnotation) &&
        Objects.equals(this.timeSegment, videoClassificationAnnotation.timeSegment) &&
        Objects.equals(this.type, videoClassificationAnnotation.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(classificationAnnotation, timeSegment, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoClassificationAnnotation {\n");
    sb.append("    classificationAnnotation: ").append(toIndentedString(classificationAnnotation)).append("\n");
    sb.append("    timeSegment: ").append(toIndentedString(timeSegment)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("classificationAnnotation");
    openapiFields.add("timeSegment");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoClassificationAnnotation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoClassificationAnnotation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoClassificationAnnotation is not found in the empty JSON string", VideoClassificationAnnotation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VideoClassificationAnnotation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VideoClassificationAnnotation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `classificationAnnotation`
      if (jsonObj.get("classificationAnnotation") != null && !jsonObj.get("classificationAnnotation").isJsonNull()) {
        ClassificationAnnotation.validateJsonElement(jsonObj.get("classificationAnnotation"));
      }
      // validate the optional field `timeSegment`
      if (jsonObj.get("timeSegment") != null && !jsonObj.get("timeSegment").isJsonNull()) {
        TimeSegment.validateJsonElement(jsonObj.get("timeSegment"));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VideoClassificationAnnotation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VideoClassificationAnnotation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VideoClassificationAnnotation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VideoClassificationAnnotation.class));

       return (TypeAdapter<T>) new TypeAdapter<VideoClassificationAnnotation>() {
           @Override
           public void write(JsonWriter out, VideoClassificationAnnotation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VideoClassificationAnnotation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VideoClassificationAnnotation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoClassificationAnnotation
   * @throws IOException if the JSON string is invalid with respect to VideoClassificationAnnotation
   */
  public static VideoClassificationAnnotation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoClassificationAnnotation.class);
  }

  /**
   * Convert an instance of VideoClassificationAnnotation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

