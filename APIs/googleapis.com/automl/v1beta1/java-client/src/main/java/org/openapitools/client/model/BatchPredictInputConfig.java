/*
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.BigQuerySource;
import org.openapitools.client.model.GcsSource;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Input configuration for BatchPredict Action. The format of input depends on the ML problem of the model used for prediction. As input source the gcs_source is expected, unless specified otherwise. The formats are represented in EBNF with commas being literal and with non-terminal symbols defined near the end of this comment. The formats are: * For Image Classification: CSV file(s) with each line having just a single column: GCS_FILE_PATH which leads to image of up to 30MB in size. Supported extensions: .JPEG, .GIF, .PNG. This path is treated as the ID in the Batch predict output. Three sample rows: gs://folder/image1.jpeg gs://folder/image2.gif gs://folder/image3.png * For Image Object Detection: CSV file(s) with each line having just a single column: GCS_FILE_PATH which leads to image of up to 30MB in size. Supported extensions: .JPEG, .GIF, .PNG. This path is treated as the ID in the Batch predict output. Three sample rows: gs://folder/image1.jpeg gs://folder/image2.gif gs://folder/image3.png * For Video Classification: CSV file(s) with each line in format: GCS_FILE_PATH,TIME_SEGMENT_START,TIME_SEGMENT_END GCS_FILE_PATH leads to video of up to 50GB in size and up to 3h duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI. TIME_SEGMENT_START and TIME_SEGMENT_END must be within the length of the video, and end has to be after the start. Three sample rows: gs://folder/video1.mp4,10,40 gs://folder/video1.mp4,20,60 gs://folder/vid2.mov,0,inf * For Video Object Tracking: CSV file(s) with each line in format: GCS_FILE_PATH,TIME_SEGMENT_START,TIME_SEGMENT_END GCS_FILE_PATH leads to video of up to 50GB in size and up to 3h duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI. TIME_SEGMENT_START and TIME_SEGMENT_END must be within the length of the video, and end has to be after the start. Three sample rows: gs://folder/video1.mp4,10,240 gs://folder/video1.mp4,300,360 gs://folder/vid2.mov,0,inf * For Text Classification: CSV file(s) with each line having just a single column: GCS_FILE_PATH | TEXT_SNIPPET Any given text file can have size upto 128kB. Any given text snippet content must have 60,000 characters or less. Three sample rows: gs://folder/text1.txt \&quot;Some text content to predict\&quot; gs://folder/text3.pdf Supported file extensions: .txt, .pdf * For Text Sentiment: CSV file(s) with each line having just a single column: GCS_FILE_PATH | TEXT_SNIPPET Any given text file can have size upto 128kB. Any given text snippet content must have 500 characters or less. Three sample rows: gs://folder/text1.txt \&quot;Some text content to predict\&quot; gs://folder/text3.pdf Supported file extensions: .txt, .pdf * For Text Extraction .JSONL (i.e. JSON Lines) file(s) which either provide text in-line or as documents (for a single BatchPredict call only one of the these formats may be used). The in-line .JSONL file(s) contain per line a proto that wraps a temporary user-assigned TextSnippet ID (string up to 2000 characters long) called \&quot;id\&quot;, a TextSnippet proto (in json representation) and zero or more TextFeature protos. Any given text snippet content must have 30,000 characters or less, and also be UTF-8 NFC encoded (ASCII already is). The IDs provided should be unique. The document .JSONL file(s) contain, per line, a proto that wraps a Document proto with input_config set. Only PDF documents are supported now, and each document must be up to 2MB large. Any given .JSONL file must be 100MB or smaller, and no more than 20 files may be given. Sample in-line JSON Lines file (presented here with artificial line breaks, but the only actual line break is denoted by \\n): { \&quot;id\&quot;: \&quot;my_first_id\&quot;, \&quot;text_snippet\&quot;: { \&quot;content\&quot;: \&quot;dog car cat\&quot;}, \&quot;text_features\&quot;: [ { \&quot;text_segment\&quot;: {\&quot;start_offset\&quot;: 4, \&quot;end_offset\&quot;: 6}, \&quot;structural_type\&quot;: PARAGRAPH, \&quot;bounding_poly\&quot;: { \&quot;normalized_vertices\&quot;: [ {\&quot;x\&quot;: 0.1, \&quot;y\&quot;: 0.1}, {\&quot;x\&quot;: 0.1, \&quot;y\&quot;: 0.3}, {\&quot;x\&quot;: 0.3, \&quot;y\&quot;: 0.3}, {\&quot;x\&quot;: 0.3, \&quot;y\&quot;: 0.1}, ] }, } ], }\\n { \&quot;id\&quot;: \&quot;2\&quot;, \&quot;text_snippet\&quot;: { \&quot;content\&quot;: \&quot;An elaborate content\&quot;, \&quot;mime_type\&quot;: \&quot;text/plain\&quot; } } Sample document JSON Lines file (presented here with artificial line breaks, but the only actual line break is denoted by \\n).: { \&quot;document\&quot;: { \&quot;input_config\&quot;: { \&quot;gcs_source\&quot;: { \&quot;input_uris\&quot;: [ \&quot;gs://folder/document1.pdf\&quot; ] } } } }\\n { \&quot;document\&quot;: { \&quot;input_config\&quot;: { \&quot;gcs_source\&quot;: { \&quot;input_uris\&quot;: [ \&quot;gs://folder/document2.pdf\&quot; ] } } } } * For Tables: Either gcs_source or bigquery_source. GCS case: CSV file(s), each by itself 10GB or smaller and total size must be 100GB or smaller, where first file must have a header containing column names. If the first row of a subsequent file is the same as the header, then it is also treated as a header. All other rows contain values for the corresponding columns. The column names must contain the model&#39;s input_feature_column_specs&#39; display_name-s (order doesn&#39;t matter). The columns corresponding to the model&#39;s input feature column specs must contain values compatible with the column spec&#39;s data types. Prediction on all the rows, i.e. the CSV lines, will be attempted. For FORECASTING prediction_type: all columns having TIME_SERIES_AVAILABLE_PAST_ONLY type will be ignored. First three sample rows of a CSV file: \&quot;First Name\&quot;,\&quot;Last Name\&quot;,\&quot;Dob\&quot;,\&quot;Addresses\&quot; \&quot;John\&quot;,\&quot;Doe\&quot;,\&quot;1968-01-22\&quot;,\&quot;[{\&quot;status\&quot;:\&quot;current\&quot;,\&quot;address\&quot;:\&quot;123_First_Avenue\&quot;,\&quot;city\&quot;:\&quot;Seattle\&quot;,\&quot;state\&quot;:\&quot;WA\&quot;,\&quot;zip\&quot;:\&quot;11111\&quot;,\&quot;numberOfYears\&quot;:\&quot;1\&quot;},{\&quot;status\&quot;:\&quot;previous\&quot;,\&quot;address\&quot;:\&quot;456_Main_Street\&quot;,\&quot;city\&quot;:\&quot;Portland\&quot;,\&quot;state\&quot;:\&quot;OR\&quot;,\&quot;zip\&quot;:\&quot;22222\&quot;,\&quot;numberOfYears\&quot;:\&quot;5\&quot;}]\&quot; \&quot;Jane\&quot;,\&quot;Doe\&quot;,\&quot;1980-10-16\&quot;,\&quot;[{\&quot;status\&quot;:\&quot;current\&quot;,\&quot;address\&quot;:\&quot;789_Any_Avenue\&quot;,\&quot;city\&quot;:\&quot;Albany\&quot;,\&quot;state\&quot;:\&quot;NY\&quot;,\&quot;zip\&quot;:\&quot;33333\&quot;,\&quot;numberOfYears\&quot;:\&quot;2\&quot;},{\&quot;status\&quot;:\&quot;previous\&quot;,\&quot;address\&quot;:\&quot;321_Main_Street\&quot;,\&quot;city\&quot;:\&quot;Hoboken\&quot;,\&quot;state\&quot;:\&quot;NJ\&quot;,\&quot;zip\&quot;:\&quot;44444\&quot;,\&quot;numberOfYears\&quot;:\&quot;3\&quot;}]} BigQuery case: An URI of a BigQuery table. The user data size of the BigQuery table must be 100GB or smaller. The column names must contain the model&#39;s input_feature_column_specs&#39; display_name-s (order doesn&#39;t matter). The columns corresponding to the model&#39;s input feature column specs must contain values compatible with the column spec&#39;s data types. Prediction on all the rows of the table will be attempted. For FORECASTING prediction_type: all columns having TIME_SERIES_AVAILABLE_PAST_ONLY type will be ignored. Definitions: GCS_FILE_PATH &#x3D; A path to file on GCS, e.g. \&quot;gs://folder/video.avi\&quot;. TEXT_SNIPPET &#x3D; A content of a text snippet, UTF-8 encoded, enclosed within double quotes (\&quot;\&quot;) TIME_SEGMENT_START &#x3D; TIME_OFFSET Expresses a beginning, inclusive, of a time segment within an example that has a time dimension (e.g. video). TIME_SEGMENT_END &#x3D; TIME_OFFSET Expresses an end, exclusive, of a time segment within an example that has a time dimension (e.g. video). TIME_OFFSET &#x3D; A number of seconds as measured from the start of an example (e.g. video). Fractions are allowed, up to a microsecond precision. \&quot;inf\&quot; is allowed and it means the end of the example. Errors: If any of the provided CSV files can&#39;t be parsed or if more than certain percent of CSV rows cannot be processed then the operation fails and prediction does not happen. Regardless of overall success or failure the per-row failures, up to a certain count cap, will be listed in Operation.metadata.partial_failures.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:50.092187-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BatchPredictInputConfig {
  public static final String SERIALIZED_NAME_BIGQUERY_SOURCE = "bigquerySource";
  @SerializedName(SERIALIZED_NAME_BIGQUERY_SOURCE)
  private BigQuerySource bigquerySource;

  public static final String SERIALIZED_NAME_GCS_SOURCE = "gcsSource";
  @SerializedName(SERIALIZED_NAME_GCS_SOURCE)
  private GcsSource gcsSource;

  public BatchPredictInputConfig() {
  }

  public BatchPredictInputConfig bigquerySource(BigQuerySource bigquerySource) {
    this.bigquerySource = bigquerySource;
    return this;
  }

  /**
   * Get bigquerySource
   * @return bigquerySource
   */
  @javax.annotation.Nullable
  public BigQuerySource getBigquerySource() {
    return bigquerySource;
  }

  public void setBigquerySource(BigQuerySource bigquerySource) {
    this.bigquerySource = bigquerySource;
  }


  public BatchPredictInputConfig gcsSource(GcsSource gcsSource) {
    this.gcsSource = gcsSource;
    return this;
  }

  /**
   * Get gcsSource
   * @return gcsSource
   */
  @javax.annotation.Nullable
  public GcsSource getGcsSource() {
    return gcsSource;
  }

  public void setGcsSource(GcsSource gcsSource) {
    this.gcsSource = gcsSource;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BatchPredictInputConfig batchPredictInputConfig = (BatchPredictInputConfig) o;
    return Objects.equals(this.bigquerySource, batchPredictInputConfig.bigquerySource) &&
        Objects.equals(this.gcsSource, batchPredictInputConfig.gcsSource);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bigquerySource, gcsSource);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BatchPredictInputConfig {\n");
    sb.append("    bigquerySource: ").append(toIndentedString(bigquerySource)).append("\n");
    sb.append("    gcsSource: ").append(toIndentedString(gcsSource)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bigquerySource");
    openapiFields.add("gcsSource");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BatchPredictInputConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BatchPredictInputConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BatchPredictInputConfig is not found in the empty JSON string", BatchPredictInputConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BatchPredictInputConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BatchPredictInputConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `bigquerySource`
      if (jsonObj.get("bigquerySource") != null && !jsonObj.get("bigquerySource").isJsonNull()) {
        BigQuerySource.validateJsonElement(jsonObj.get("bigquerySource"));
      }
      // validate the optional field `gcsSource`
      if (jsonObj.get("gcsSource") != null && !jsonObj.get("gcsSource").isJsonNull()) {
        GcsSource.validateJsonElement(jsonObj.get("gcsSource"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BatchPredictInputConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BatchPredictInputConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BatchPredictInputConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BatchPredictInputConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<BatchPredictInputConfig>() {
           @Override
           public void write(JsonWriter out, BatchPredictInputConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BatchPredictInputConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BatchPredictInputConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BatchPredictInputConfig
   * @throws IOException if the JSON string is invalid with respect to BatchPredictInputConfig
   */
  public static BatchPredictInputConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BatchPredictInputConfig.class);
  }

  /**
   * Convert an instance of BatchPredictInputConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

