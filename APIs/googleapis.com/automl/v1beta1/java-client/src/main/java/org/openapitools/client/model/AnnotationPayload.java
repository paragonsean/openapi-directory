/*
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ClassificationAnnotation;
import org.openapitools.client.model.ImageObjectDetectionAnnotation;
import org.openapitools.client.model.TablesAnnotation;
import org.openapitools.client.model.TextExtractionAnnotation;
import org.openapitools.client.model.TextSentimentAnnotation;
import org.openapitools.client.model.TranslationAnnotation;
import org.openapitools.client.model.VideoClassificationAnnotation;
import org.openapitools.client.model.VideoObjectTrackingAnnotation;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains annotation information that is relevant to AutoML.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:50.092187-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AnnotationPayload {
  public static final String SERIALIZED_NAME_ANNOTATION_SPEC_ID = "annotationSpecId";
  @SerializedName(SERIALIZED_NAME_ANNOTATION_SPEC_ID)
  private String annotationSpecId;

  public static final String SERIALIZED_NAME_CLASSIFICATION = "classification";
  @SerializedName(SERIALIZED_NAME_CLASSIFICATION)
  private ClassificationAnnotation classification;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_IMAGE_OBJECT_DETECTION = "imageObjectDetection";
  @SerializedName(SERIALIZED_NAME_IMAGE_OBJECT_DETECTION)
  private ImageObjectDetectionAnnotation imageObjectDetection;

  public static final String SERIALIZED_NAME_TABLES = "tables";
  @SerializedName(SERIALIZED_NAME_TABLES)
  private TablesAnnotation tables;

  public static final String SERIALIZED_NAME_TEXT_EXTRACTION = "textExtraction";
  @SerializedName(SERIALIZED_NAME_TEXT_EXTRACTION)
  private TextExtractionAnnotation textExtraction;

  public static final String SERIALIZED_NAME_TEXT_SENTIMENT = "textSentiment";
  @SerializedName(SERIALIZED_NAME_TEXT_SENTIMENT)
  private TextSentimentAnnotation textSentiment;

  public static final String SERIALIZED_NAME_TRANSLATION = "translation";
  @SerializedName(SERIALIZED_NAME_TRANSLATION)
  private TranslationAnnotation translation;

  public static final String SERIALIZED_NAME_VIDEO_CLASSIFICATION = "videoClassification";
  @SerializedName(SERIALIZED_NAME_VIDEO_CLASSIFICATION)
  private VideoClassificationAnnotation videoClassification;

  public static final String SERIALIZED_NAME_VIDEO_OBJECT_TRACKING = "videoObjectTracking";
  @SerializedName(SERIALIZED_NAME_VIDEO_OBJECT_TRACKING)
  private VideoObjectTrackingAnnotation videoObjectTracking;

  public AnnotationPayload() {
  }

  public AnnotationPayload annotationSpecId(String annotationSpecId) {
    this.annotationSpecId = annotationSpecId;
    return this;
  }

  /**
   * Output only . The resource ID of the annotation spec that this annotation pertains to. The annotation spec comes from either an ancestor dataset, or the dataset that was used to train the model in use.
   * @return annotationSpecId
   */
  @javax.annotation.Nullable
  public String getAnnotationSpecId() {
    return annotationSpecId;
  }

  public void setAnnotationSpecId(String annotationSpecId) {
    this.annotationSpecId = annotationSpecId;
  }


  public AnnotationPayload classification(ClassificationAnnotation classification) {
    this.classification = classification;
    return this;
  }

  /**
   * Get classification
   * @return classification
   */
  @javax.annotation.Nullable
  public ClassificationAnnotation getClassification() {
    return classification;
  }

  public void setClassification(ClassificationAnnotation classification) {
    this.classification = classification;
  }


  public AnnotationPayload displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Output only. The value of display_name when the model was trained. Because this field returns a value at model training time, for different models trained using the same dataset, the returned value could be different as model owner could update the &#x60;display_name&#x60; between any two model training.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public AnnotationPayload imageObjectDetection(ImageObjectDetectionAnnotation imageObjectDetection) {
    this.imageObjectDetection = imageObjectDetection;
    return this;
  }

  /**
   * Get imageObjectDetection
   * @return imageObjectDetection
   */
  @javax.annotation.Nullable
  public ImageObjectDetectionAnnotation getImageObjectDetection() {
    return imageObjectDetection;
  }

  public void setImageObjectDetection(ImageObjectDetectionAnnotation imageObjectDetection) {
    this.imageObjectDetection = imageObjectDetection;
  }


  public AnnotationPayload tables(TablesAnnotation tables) {
    this.tables = tables;
    return this;
  }

  /**
   * Get tables
   * @return tables
   */
  @javax.annotation.Nullable
  public TablesAnnotation getTables() {
    return tables;
  }

  public void setTables(TablesAnnotation tables) {
    this.tables = tables;
  }


  public AnnotationPayload textExtraction(TextExtractionAnnotation textExtraction) {
    this.textExtraction = textExtraction;
    return this;
  }

  /**
   * Get textExtraction
   * @return textExtraction
   */
  @javax.annotation.Nullable
  public TextExtractionAnnotation getTextExtraction() {
    return textExtraction;
  }

  public void setTextExtraction(TextExtractionAnnotation textExtraction) {
    this.textExtraction = textExtraction;
  }


  public AnnotationPayload textSentiment(TextSentimentAnnotation textSentiment) {
    this.textSentiment = textSentiment;
    return this;
  }

  /**
   * Get textSentiment
   * @return textSentiment
   */
  @javax.annotation.Nullable
  public TextSentimentAnnotation getTextSentiment() {
    return textSentiment;
  }

  public void setTextSentiment(TextSentimentAnnotation textSentiment) {
    this.textSentiment = textSentiment;
  }


  public AnnotationPayload translation(TranslationAnnotation translation) {
    this.translation = translation;
    return this;
  }

  /**
   * Get translation
   * @return translation
   */
  @javax.annotation.Nullable
  public TranslationAnnotation getTranslation() {
    return translation;
  }

  public void setTranslation(TranslationAnnotation translation) {
    this.translation = translation;
  }


  public AnnotationPayload videoClassification(VideoClassificationAnnotation videoClassification) {
    this.videoClassification = videoClassification;
    return this;
  }

  /**
   * Get videoClassification
   * @return videoClassification
   */
  @javax.annotation.Nullable
  public VideoClassificationAnnotation getVideoClassification() {
    return videoClassification;
  }

  public void setVideoClassification(VideoClassificationAnnotation videoClassification) {
    this.videoClassification = videoClassification;
  }


  public AnnotationPayload videoObjectTracking(VideoObjectTrackingAnnotation videoObjectTracking) {
    this.videoObjectTracking = videoObjectTracking;
    return this;
  }

  /**
   * Get videoObjectTracking
   * @return videoObjectTracking
   */
  @javax.annotation.Nullable
  public VideoObjectTrackingAnnotation getVideoObjectTracking() {
    return videoObjectTracking;
  }

  public void setVideoObjectTracking(VideoObjectTrackingAnnotation videoObjectTracking) {
    this.videoObjectTracking = videoObjectTracking;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AnnotationPayload annotationPayload = (AnnotationPayload) o;
    return Objects.equals(this.annotationSpecId, annotationPayload.annotationSpecId) &&
        Objects.equals(this.classification, annotationPayload.classification) &&
        Objects.equals(this.displayName, annotationPayload.displayName) &&
        Objects.equals(this.imageObjectDetection, annotationPayload.imageObjectDetection) &&
        Objects.equals(this.tables, annotationPayload.tables) &&
        Objects.equals(this.textExtraction, annotationPayload.textExtraction) &&
        Objects.equals(this.textSentiment, annotationPayload.textSentiment) &&
        Objects.equals(this.translation, annotationPayload.translation) &&
        Objects.equals(this.videoClassification, annotationPayload.videoClassification) &&
        Objects.equals(this.videoObjectTracking, annotationPayload.videoObjectTracking);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotationSpecId, classification, displayName, imageObjectDetection, tables, textExtraction, textSentiment, translation, videoClassification, videoObjectTracking);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AnnotationPayload {\n");
    sb.append("    annotationSpecId: ").append(toIndentedString(annotationSpecId)).append("\n");
    sb.append("    classification: ").append(toIndentedString(classification)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    imageObjectDetection: ").append(toIndentedString(imageObjectDetection)).append("\n");
    sb.append("    tables: ").append(toIndentedString(tables)).append("\n");
    sb.append("    textExtraction: ").append(toIndentedString(textExtraction)).append("\n");
    sb.append("    textSentiment: ").append(toIndentedString(textSentiment)).append("\n");
    sb.append("    translation: ").append(toIndentedString(translation)).append("\n");
    sb.append("    videoClassification: ").append(toIndentedString(videoClassification)).append("\n");
    sb.append("    videoObjectTracking: ").append(toIndentedString(videoObjectTracking)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotationSpecId");
    openapiFields.add("classification");
    openapiFields.add("displayName");
    openapiFields.add("imageObjectDetection");
    openapiFields.add("tables");
    openapiFields.add("textExtraction");
    openapiFields.add("textSentiment");
    openapiFields.add("translation");
    openapiFields.add("videoClassification");
    openapiFields.add("videoObjectTracking");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AnnotationPayload
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AnnotationPayload.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AnnotationPayload is not found in the empty JSON string", AnnotationPayload.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AnnotationPayload.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AnnotationPayload` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("annotationSpecId") != null && !jsonObj.get("annotationSpecId").isJsonNull()) && !jsonObj.get("annotationSpecId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `annotationSpecId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("annotationSpecId").toString()));
      }
      // validate the optional field `classification`
      if (jsonObj.get("classification") != null && !jsonObj.get("classification").isJsonNull()) {
        ClassificationAnnotation.validateJsonElement(jsonObj.get("classification"));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      // validate the optional field `imageObjectDetection`
      if (jsonObj.get("imageObjectDetection") != null && !jsonObj.get("imageObjectDetection").isJsonNull()) {
        ImageObjectDetectionAnnotation.validateJsonElement(jsonObj.get("imageObjectDetection"));
      }
      // validate the optional field `tables`
      if (jsonObj.get("tables") != null && !jsonObj.get("tables").isJsonNull()) {
        TablesAnnotation.validateJsonElement(jsonObj.get("tables"));
      }
      // validate the optional field `textExtraction`
      if (jsonObj.get("textExtraction") != null && !jsonObj.get("textExtraction").isJsonNull()) {
        TextExtractionAnnotation.validateJsonElement(jsonObj.get("textExtraction"));
      }
      // validate the optional field `textSentiment`
      if (jsonObj.get("textSentiment") != null && !jsonObj.get("textSentiment").isJsonNull()) {
        TextSentimentAnnotation.validateJsonElement(jsonObj.get("textSentiment"));
      }
      // validate the optional field `translation`
      if (jsonObj.get("translation") != null && !jsonObj.get("translation").isJsonNull()) {
        TranslationAnnotation.validateJsonElement(jsonObj.get("translation"));
      }
      // validate the optional field `videoClassification`
      if (jsonObj.get("videoClassification") != null && !jsonObj.get("videoClassification").isJsonNull()) {
        VideoClassificationAnnotation.validateJsonElement(jsonObj.get("videoClassification"));
      }
      // validate the optional field `videoObjectTracking`
      if (jsonObj.get("videoObjectTracking") != null && !jsonObj.get("videoObjectTracking").isJsonNull()) {
        VideoObjectTrackingAnnotation.validateJsonElement(jsonObj.get("videoObjectTracking"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AnnotationPayload.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AnnotationPayload' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AnnotationPayload> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AnnotationPayload.class));

       return (TypeAdapter<T>) new TypeAdapter<AnnotationPayload>() {
           @Override
           public void write(JsonWriter out, AnnotationPayload value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AnnotationPayload read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AnnotationPayload given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AnnotationPayload
   * @throws IOException if the JSON string is invalid with respect to AnnotationPayload
   */
  public static AnnotationPayload fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AnnotationPayload.class);
  }

  /**
   * Convert an instance of AnnotationPayload to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

