/*
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ClassificationEvaluationMetrics;
import org.openapitools.client.model.ImageObjectDetectionEvaluationMetrics;
import org.openapitools.client.model.RegressionEvaluationMetrics;
import org.openapitools.client.model.TextExtractionEvaluationMetrics;
import org.openapitools.client.model.TextSentimentEvaluationMetrics;
import org.openapitools.client.model.TranslationEvaluationMetrics;
import org.openapitools.client.model.VideoObjectTrackingEvaluationMetrics;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Evaluation results of a model.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:50.092187-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ModelEvaluation {
  public static final String SERIALIZED_NAME_ANNOTATION_SPEC_ID = "annotationSpecId";
  @SerializedName(SERIALIZED_NAME_ANNOTATION_SPEC_ID)
  private String annotationSpecId;

  public static final String SERIALIZED_NAME_CLASSIFICATION_EVALUATION_METRICS = "classificationEvaluationMetrics";
  @SerializedName(SERIALIZED_NAME_CLASSIFICATION_EVALUATION_METRICS)
  private ClassificationEvaluationMetrics classificationEvaluationMetrics;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_EVALUATED_EXAMPLE_COUNT = "evaluatedExampleCount";
  @SerializedName(SERIALIZED_NAME_EVALUATED_EXAMPLE_COUNT)
  private Integer evaluatedExampleCount;

  public static final String SERIALIZED_NAME_IMAGE_OBJECT_DETECTION_EVALUATION_METRICS = "imageObjectDetectionEvaluationMetrics";
  @SerializedName(SERIALIZED_NAME_IMAGE_OBJECT_DETECTION_EVALUATION_METRICS)
  private ImageObjectDetectionEvaluationMetrics imageObjectDetectionEvaluationMetrics;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_REGRESSION_EVALUATION_METRICS = "regressionEvaluationMetrics";
  @SerializedName(SERIALIZED_NAME_REGRESSION_EVALUATION_METRICS)
  private RegressionEvaluationMetrics regressionEvaluationMetrics;

  public static final String SERIALIZED_NAME_TEXT_EXTRACTION_EVALUATION_METRICS = "textExtractionEvaluationMetrics";
  @SerializedName(SERIALIZED_NAME_TEXT_EXTRACTION_EVALUATION_METRICS)
  private TextExtractionEvaluationMetrics textExtractionEvaluationMetrics;

  public static final String SERIALIZED_NAME_TEXT_SENTIMENT_EVALUATION_METRICS = "textSentimentEvaluationMetrics";
  @SerializedName(SERIALIZED_NAME_TEXT_SENTIMENT_EVALUATION_METRICS)
  private TextSentimentEvaluationMetrics textSentimentEvaluationMetrics;

  public static final String SERIALIZED_NAME_TRANSLATION_EVALUATION_METRICS = "translationEvaluationMetrics";
  @SerializedName(SERIALIZED_NAME_TRANSLATION_EVALUATION_METRICS)
  private TranslationEvaluationMetrics translationEvaluationMetrics;

  public static final String SERIALIZED_NAME_VIDEO_OBJECT_TRACKING_EVALUATION_METRICS = "videoObjectTrackingEvaluationMetrics";
  @SerializedName(SERIALIZED_NAME_VIDEO_OBJECT_TRACKING_EVALUATION_METRICS)
  private VideoObjectTrackingEvaluationMetrics videoObjectTrackingEvaluationMetrics;

  public ModelEvaluation() {
  }

  public ModelEvaluation annotationSpecId(String annotationSpecId) {
    this.annotationSpecId = annotationSpecId;
    return this;
  }

  /**
   * Output only. The ID of the annotation spec that the model evaluation applies to. The The ID is empty for the overall model evaluation. For Tables annotation specs in the dataset do not exist and this ID is always not set, but for CLASSIFICATION prediction_type-s the display_name field is used.
   * @return annotationSpecId
   */
  @javax.annotation.Nullable
  public String getAnnotationSpecId() {
    return annotationSpecId;
  }

  public void setAnnotationSpecId(String annotationSpecId) {
    this.annotationSpecId = annotationSpecId;
  }


  public ModelEvaluation classificationEvaluationMetrics(ClassificationEvaluationMetrics classificationEvaluationMetrics) {
    this.classificationEvaluationMetrics = classificationEvaluationMetrics;
    return this;
  }

  /**
   * Get classificationEvaluationMetrics
   * @return classificationEvaluationMetrics
   */
  @javax.annotation.Nullable
  public ClassificationEvaluationMetrics getClassificationEvaluationMetrics() {
    return classificationEvaluationMetrics;
  }

  public void setClassificationEvaluationMetrics(ClassificationEvaluationMetrics classificationEvaluationMetrics) {
    this.classificationEvaluationMetrics = classificationEvaluationMetrics;
  }


  public ModelEvaluation createTime(String createTime) {
    this.createTime = createTime;
    return this;
  }

  /**
   * Output only. Timestamp when this model evaluation was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }

  public void setCreateTime(String createTime) {
    this.createTime = createTime;
  }


  public ModelEvaluation displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Output only. The value of display_name at the moment when the model was trained. Because this field returns a value at model training time, for different models trained from the same dataset, the values may differ, since display names could had been changed between the two model&#39;s trainings. For Tables CLASSIFICATION prediction_type-s distinct values of the target column at the moment of the model evaluation are populated here. The display_name is empty for the overall model evaluation.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public ModelEvaluation evaluatedExampleCount(Integer evaluatedExampleCount) {
    this.evaluatedExampleCount = evaluatedExampleCount;
    return this;
  }

  /**
   * Output only. The number of examples used for model evaluation, i.e. for which ground truth from time of model creation is compared against the predicted annotations created by the model. For overall ModelEvaluation (i.e. with annotation_spec_id not set) this is the total number of all examples used for evaluation. Otherwise, this is the count of examples that according to the ground truth were annotated by the annotation_spec_id.
   * @return evaluatedExampleCount
   */
  @javax.annotation.Nullable
  public Integer getEvaluatedExampleCount() {
    return evaluatedExampleCount;
  }

  public void setEvaluatedExampleCount(Integer evaluatedExampleCount) {
    this.evaluatedExampleCount = evaluatedExampleCount;
  }


  public ModelEvaluation imageObjectDetectionEvaluationMetrics(ImageObjectDetectionEvaluationMetrics imageObjectDetectionEvaluationMetrics) {
    this.imageObjectDetectionEvaluationMetrics = imageObjectDetectionEvaluationMetrics;
    return this;
  }

  /**
   * Get imageObjectDetectionEvaluationMetrics
   * @return imageObjectDetectionEvaluationMetrics
   */
  @javax.annotation.Nullable
  public ImageObjectDetectionEvaluationMetrics getImageObjectDetectionEvaluationMetrics() {
    return imageObjectDetectionEvaluationMetrics;
  }

  public void setImageObjectDetectionEvaluationMetrics(ImageObjectDetectionEvaluationMetrics imageObjectDetectionEvaluationMetrics) {
    this.imageObjectDetectionEvaluationMetrics = imageObjectDetectionEvaluationMetrics;
  }


  public ModelEvaluation name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Output only. Resource name of the model evaluation. Format: &#x60;projects/{project_id}/locations/{location_id}/models/{model_id}/modelEvaluations/{model_evaluation_id}&#x60;
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public ModelEvaluation regressionEvaluationMetrics(RegressionEvaluationMetrics regressionEvaluationMetrics) {
    this.regressionEvaluationMetrics = regressionEvaluationMetrics;
    return this;
  }

  /**
   * Get regressionEvaluationMetrics
   * @return regressionEvaluationMetrics
   */
  @javax.annotation.Nullable
  public RegressionEvaluationMetrics getRegressionEvaluationMetrics() {
    return regressionEvaluationMetrics;
  }

  public void setRegressionEvaluationMetrics(RegressionEvaluationMetrics regressionEvaluationMetrics) {
    this.regressionEvaluationMetrics = regressionEvaluationMetrics;
  }


  public ModelEvaluation textExtractionEvaluationMetrics(TextExtractionEvaluationMetrics textExtractionEvaluationMetrics) {
    this.textExtractionEvaluationMetrics = textExtractionEvaluationMetrics;
    return this;
  }

  /**
   * Get textExtractionEvaluationMetrics
   * @return textExtractionEvaluationMetrics
   */
  @javax.annotation.Nullable
  public TextExtractionEvaluationMetrics getTextExtractionEvaluationMetrics() {
    return textExtractionEvaluationMetrics;
  }

  public void setTextExtractionEvaluationMetrics(TextExtractionEvaluationMetrics textExtractionEvaluationMetrics) {
    this.textExtractionEvaluationMetrics = textExtractionEvaluationMetrics;
  }


  public ModelEvaluation textSentimentEvaluationMetrics(TextSentimentEvaluationMetrics textSentimentEvaluationMetrics) {
    this.textSentimentEvaluationMetrics = textSentimentEvaluationMetrics;
    return this;
  }

  /**
   * Get textSentimentEvaluationMetrics
   * @return textSentimentEvaluationMetrics
   */
  @javax.annotation.Nullable
  public TextSentimentEvaluationMetrics getTextSentimentEvaluationMetrics() {
    return textSentimentEvaluationMetrics;
  }

  public void setTextSentimentEvaluationMetrics(TextSentimentEvaluationMetrics textSentimentEvaluationMetrics) {
    this.textSentimentEvaluationMetrics = textSentimentEvaluationMetrics;
  }


  public ModelEvaluation translationEvaluationMetrics(TranslationEvaluationMetrics translationEvaluationMetrics) {
    this.translationEvaluationMetrics = translationEvaluationMetrics;
    return this;
  }

  /**
   * Get translationEvaluationMetrics
   * @return translationEvaluationMetrics
   */
  @javax.annotation.Nullable
  public TranslationEvaluationMetrics getTranslationEvaluationMetrics() {
    return translationEvaluationMetrics;
  }

  public void setTranslationEvaluationMetrics(TranslationEvaluationMetrics translationEvaluationMetrics) {
    this.translationEvaluationMetrics = translationEvaluationMetrics;
  }


  public ModelEvaluation videoObjectTrackingEvaluationMetrics(VideoObjectTrackingEvaluationMetrics videoObjectTrackingEvaluationMetrics) {
    this.videoObjectTrackingEvaluationMetrics = videoObjectTrackingEvaluationMetrics;
    return this;
  }

  /**
   * Get videoObjectTrackingEvaluationMetrics
   * @return videoObjectTrackingEvaluationMetrics
   */
  @javax.annotation.Nullable
  public VideoObjectTrackingEvaluationMetrics getVideoObjectTrackingEvaluationMetrics() {
    return videoObjectTrackingEvaluationMetrics;
  }

  public void setVideoObjectTrackingEvaluationMetrics(VideoObjectTrackingEvaluationMetrics videoObjectTrackingEvaluationMetrics) {
    this.videoObjectTrackingEvaluationMetrics = videoObjectTrackingEvaluationMetrics;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ModelEvaluation modelEvaluation = (ModelEvaluation) o;
    return Objects.equals(this.annotationSpecId, modelEvaluation.annotationSpecId) &&
        Objects.equals(this.classificationEvaluationMetrics, modelEvaluation.classificationEvaluationMetrics) &&
        Objects.equals(this.createTime, modelEvaluation.createTime) &&
        Objects.equals(this.displayName, modelEvaluation.displayName) &&
        Objects.equals(this.evaluatedExampleCount, modelEvaluation.evaluatedExampleCount) &&
        Objects.equals(this.imageObjectDetectionEvaluationMetrics, modelEvaluation.imageObjectDetectionEvaluationMetrics) &&
        Objects.equals(this.name, modelEvaluation.name) &&
        Objects.equals(this.regressionEvaluationMetrics, modelEvaluation.regressionEvaluationMetrics) &&
        Objects.equals(this.textExtractionEvaluationMetrics, modelEvaluation.textExtractionEvaluationMetrics) &&
        Objects.equals(this.textSentimentEvaluationMetrics, modelEvaluation.textSentimentEvaluationMetrics) &&
        Objects.equals(this.translationEvaluationMetrics, modelEvaluation.translationEvaluationMetrics) &&
        Objects.equals(this.videoObjectTrackingEvaluationMetrics, modelEvaluation.videoObjectTrackingEvaluationMetrics);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotationSpecId, classificationEvaluationMetrics, createTime, displayName, evaluatedExampleCount, imageObjectDetectionEvaluationMetrics, name, regressionEvaluationMetrics, textExtractionEvaluationMetrics, textSentimentEvaluationMetrics, translationEvaluationMetrics, videoObjectTrackingEvaluationMetrics);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ModelEvaluation {\n");
    sb.append("    annotationSpecId: ").append(toIndentedString(annotationSpecId)).append("\n");
    sb.append("    classificationEvaluationMetrics: ").append(toIndentedString(classificationEvaluationMetrics)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    evaluatedExampleCount: ").append(toIndentedString(evaluatedExampleCount)).append("\n");
    sb.append("    imageObjectDetectionEvaluationMetrics: ").append(toIndentedString(imageObjectDetectionEvaluationMetrics)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    regressionEvaluationMetrics: ").append(toIndentedString(regressionEvaluationMetrics)).append("\n");
    sb.append("    textExtractionEvaluationMetrics: ").append(toIndentedString(textExtractionEvaluationMetrics)).append("\n");
    sb.append("    textSentimentEvaluationMetrics: ").append(toIndentedString(textSentimentEvaluationMetrics)).append("\n");
    sb.append("    translationEvaluationMetrics: ").append(toIndentedString(translationEvaluationMetrics)).append("\n");
    sb.append("    videoObjectTrackingEvaluationMetrics: ").append(toIndentedString(videoObjectTrackingEvaluationMetrics)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotationSpecId");
    openapiFields.add("classificationEvaluationMetrics");
    openapiFields.add("createTime");
    openapiFields.add("displayName");
    openapiFields.add("evaluatedExampleCount");
    openapiFields.add("imageObjectDetectionEvaluationMetrics");
    openapiFields.add("name");
    openapiFields.add("regressionEvaluationMetrics");
    openapiFields.add("textExtractionEvaluationMetrics");
    openapiFields.add("textSentimentEvaluationMetrics");
    openapiFields.add("translationEvaluationMetrics");
    openapiFields.add("videoObjectTrackingEvaluationMetrics");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ModelEvaluation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ModelEvaluation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ModelEvaluation is not found in the empty JSON string", ModelEvaluation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ModelEvaluation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ModelEvaluation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("annotationSpecId") != null && !jsonObj.get("annotationSpecId").isJsonNull()) && !jsonObj.get("annotationSpecId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `annotationSpecId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("annotationSpecId").toString()));
      }
      // validate the optional field `classificationEvaluationMetrics`
      if (jsonObj.get("classificationEvaluationMetrics") != null && !jsonObj.get("classificationEvaluationMetrics").isJsonNull()) {
        ClassificationEvaluationMetrics.validateJsonElement(jsonObj.get("classificationEvaluationMetrics"));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      // validate the optional field `imageObjectDetectionEvaluationMetrics`
      if (jsonObj.get("imageObjectDetectionEvaluationMetrics") != null && !jsonObj.get("imageObjectDetectionEvaluationMetrics").isJsonNull()) {
        ImageObjectDetectionEvaluationMetrics.validateJsonElement(jsonObj.get("imageObjectDetectionEvaluationMetrics"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `regressionEvaluationMetrics`
      if (jsonObj.get("regressionEvaluationMetrics") != null && !jsonObj.get("regressionEvaluationMetrics").isJsonNull()) {
        RegressionEvaluationMetrics.validateJsonElement(jsonObj.get("regressionEvaluationMetrics"));
      }
      // validate the optional field `textExtractionEvaluationMetrics`
      if (jsonObj.get("textExtractionEvaluationMetrics") != null && !jsonObj.get("textExtractionEvaluationMetrics").isJsonNull()) {
        TextExtractionEvaluationMetrics.validateJsonElement(jsonObj.get("textExtractionEvaluationMetrics"));
      }
      // validate the optional field `textSentimentEvaluationMetrics`
      if (jsonObj.get("textSentimentEvaluationMetrics") != null && !jsonObj.get("textSentimentEvaluationMetrics").isJsonNull()) {
        TextSentimentEvaluationMetrics.validateJsonElement(jsonObj.get("textSentimentEvaluationMetrics"));
      }
      // validate the optional field `translationEvaluationMetrics`
      if (jsonObj.get("translationEvaluationMetrics") != null && !jsonObj.get("translationEvaluationMetrics").isJsonNull()) {
        TranslationEvaluationMetrics.validateJsonElement(jsonObj.get("translationEvaluationMetrics"));
      }
      // validate the optional field `videoObjectTrackingEvaluationMetrics`
      if (jsonObj.get("videoObjectTrackingEvaluationMetrics") != null && !jsonObj.get("videoObjectTrackingEvaluationMetrics").isJsonNull()) {
        VideoObjectTrackingEvaluationMetrics.validateJsonElement(jsonObj.get("videoObjectTrackingEvaluationMetrics"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ModelEvaluation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ModelEvaluation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ModelEvaluation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ModelEvaluation.class));

       return (TypeAdapter<T>) new TypeAdapter<ModelEvaluation>() {
           @Override
           public void write(JsonWriter out, ModelEvaluation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ModelEvaluation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ModelEvaluation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ModelEvaluation
   * @throws IOException if the JSON string is invalid with respect to ModelEvaluation
   */
  public static ModelEvaluation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ModelEvaluation.class);
  }

  /**
   * Convert an instance of ModelEvaluation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

