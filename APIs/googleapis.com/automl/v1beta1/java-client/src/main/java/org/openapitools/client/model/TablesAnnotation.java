/*
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DoubleRange;
import org.openapitools.client.model.TablesModelColumnInfo;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains annotation details specific to Tables.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:50.092187-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TablesAnnotation {
  public static final String SERIALIZED_NAME_BASELINE_SCORE = "baselineScore";
  @SerializedName(SERIALIZED_NAME_BASELINE_SCORE)
  private Float baselineScore;

  public static final String SERIALIZED_NAME_PREDICTION_INTERVAL = "predictionInterval";
  @SerializedName(SERIALIZED_NAME_PREDICTION_INTERVAL)
  private DoubleRange predictionInterval;

  public static final String SERIALIZED_NAME_SCORE = "score";
  @SerializedName(SERIALIZED_NAME_SCORE)
  private Float score;

  public static final String SERIALIZED_NAME_TABLES_MODEL_COLUMN_INFO = "tablesModelColumnInfo";
  @SerializedName(SERIALIZED_NAME_TABLES_MODEL_COLUMN_INFO)
  private List<TablesModelColumnInfo> tablesModelColumnInfo = new ArrayList<>();

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  private Object value = null;

  public TablesAnnotation() {
  }

  public TablesAnnotation baselineScore(Float baselineScore) {
    this.baselineScore = baselineScore;
    return this;
  }

  /**
   * Output only. Stores the prediction score for the baseline example, which is defined as the example with all values set to their baseline values. This is used as part of the Sampled Shapley explanation of the model&#39;s prediction. This field is populated only when feature importance is requested. For regression models, this holds the baseline prediction for the baseline example. For classification models, this holds the baseline prediction for the baseline example for the argmax class.
   * @return baselineScore
   */
  @javax.annotation.Nullable
  public Float getBaselineScore() {
    return baselineScore;
  }

  public void setBaselineScore(Float baselineScore) {
    this.baselineScore = baselineScore;
  }


  public TablesAnnotation predictionInterval(DoubleRange predictionInterval) {
    this.predictionInterval = predictionInterval;
    return this;
  }

  /**
   * Get predictionInterval
   * @return predictionInterval
   */
  @javax.annotation.Nullable
  public DoubleRange getPredictionInterval() {
    return predictionInterval;
  }

  public void setPredictionInterval(DoubleRange predictionInterval) {
    this.predictionInterval = predictionInterval;
  }


  public TablesAnnotation score(Float score) {
    this.score = score;
    return this;
  }

  /**
   * Output only. A confidence estimate between 0.0 and 1.0, inclusive. A higher value means greater confidence in the returned value. For target_column_spec of FLOAT64 data type the score is not populated.
   * @return score
   */
  @javax.annotation.Nullable
  public Float getScore() {
    return score;
  }

  public void setScore(Float score) {
    this.score = score;
  }


  public TablesAnnotation tablesModelColumnInfo(List<TablesModelColumnInfo> tablesModelColumnInfo) {
    this.tablesModelColumnInfo = tablesModelColumnInfo;
    return this;
  }

  public TablesAnnotation addTablesModelColumnInfoItem(TablesModelColumnInfo tablesModelColumnInfoItem) {
    if (this.tablesModelColumnInfo == null) {
      this.tablesModelColumnInfo = new ArrayList<>();
    }
    this.tablesModelColumnInfo.add(tablesModelColumnInfoItem);
    return this;
  }

  /**
   * Output only. Auxiliary information for each of the model&#39;s input_feature_column_specs with respect to this particular prediction. If no other fields than column_spec_name and column_display_name would be populated, then this whole field is not.
   * @return tablesModelColumnInfo
   */
  @javax.annotation.Nullable
  public List<TablesModelColumnInfo> getTablesModelColumnInfo() {
    return tablesModelColumnInfo;
  }

  public void setTablesModelColumnInfo(List<TablesModelColumnInfo> tablesModelColumnInfo) {
    this.tablesModelColumnInfo = tablesModelColumnInfo;
  }


  public TablesAnnotation value(Object value) {
    this.value = value;
    return this;
  }

  /**
   * The predicted value of the row&#39;s target_column. The value depends on the column&#39;s DataType: * CATEGORY - the predicted (with the above confidence &#x60;score&#x60;) CATEGORY value. * FLOAT64 - the predicted (with above &#x60;prediction_interval&#x60;) FLOAT64 value.
   * @return value
   */
  @javax.annotation.Nullable
  public Object getValue() {
    return value;
  }

  public void setValue(Object value) {
    this.value = value;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TablesAnnotation tablesAnnotation = (TablesAnnotation) o;
    return Objects.equals(this.baselineScore, tablesAnnotation.baselineScore) &&
        Objects.equals(this.predictionInterval, tablesAnnotation.predictionInterval) &&
        Objects.equals(this.score, tablesAnnotation.score) &&
        Objects.equals(this.tablesModelColumnInfo, tablesAnnotation.tablesModelColumnInfo) &&
        Objects.equals(this.value, tablesAnnotation.value);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(baselineScore, predictionInterval, score, tablesModelColumnInfo, value);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TablesAnnotation {\n");
    sb.append("    baselineScore: ").append(toIndentedString(baselineScore)).append("\n");
    sb.append("    predictionInterval: ").append(toIndentedString(predictionInterval)).append("\n");
    sb.append("    score: ").append(toIndentedString(score)).append("\n");
    sb.append("    tablesModelColumnInfo: ").append(toIndentedString(tablesModelColumnInfo)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("baselineScore");
    openapiFields.add("predictionInterval");
    openapiFields.add("score");
    openapiFields.add("tablesModelColumnInfo");
    openapiFields.add("value");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TablesAnnotation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TablesAnnotation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TablesAnnotation is not found in the empty JSON string", TablesAnnotation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TablesAnnotation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TablesAnnotation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `predictionInterval`
      if (jsonObj.get("predictionInterval") != null && !jsonObj.get("predictionInterval").isJsonNull()) {
        DoubleRange.validateJsonElement(jsonObj.get("predictionInterval"));
      }
      if (jsonObj.get("tablesModelColumnInfo") != null && !jsonObj.get("tablesModelColumnInfo").isJsonNull()) {
        JsonArray jsonArraytablesModelColumnInfo = jsonObj.getAsJsonArray("tablesModelColumnInfo");
        if (jsonArraytablesModelColumnInfo != null) {
          // ensure the json data is an array
          if (!jsonObj.get("tablesModelColumnInfo").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `tablesModelColumnInfo` to be an array in the JSON string but got `%s`", jsonObj.get("tablesModelColumnInfo").toString()));
          }

          // validate the optional field `tablesModelColumnInfo` (array)
          for (int i = 0; i < jsonArraytablesModelColumnInfo.size(); i++) {
            TablesModelColumnInfo.validateJsonElement(jsonArraytablesModelColumnInfo.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TablesAnnotation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TablesAnnotation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TablesAnnotation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TablesAnnotation.class));

       return (TypeAdapter<T>) new TypeAdapter<TablesAnnotation>() {
           @Override
           public void write(JsonWriter out, TablesAnnotation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TablesAnnotation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TablesAnnotation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TablesAnnotation
   * @throws IOException if the JSON string is invalid with respect to TablesAnnotation
   */
  public static TablesAnnotation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TablesAnnotation.class);
  }

  /**
   * Convert an instance of TablesAnnotation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

