/*
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.BatchPredictInputConfig;
import org.openapitools.client.model.BatchPredictOutputConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Request message for PredictionService.BatchPredict.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:50.092187-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BatchPredictRequest {
  public static final String SERIALIZED_NAME_INPUT_CONFIG = "inputConfig";
  @SerializedName(SERIALIZED_NAME_INPUT_CONFIG)
  private BatchPredictInputConfig inputConfig;

  public static final String SERIALIZED_NAME_OUTPUT_CONFIG = "outputConfig";
  @SerializedName(SERIALIZED_NAME_OUTPUT_CONFIG)
  private BatchPredictOutputConfig outputConfig;

  public static final String SERIALIZED_NAME_PARAMS = "params";
  @SerializedName(SERIALIZED_NAME_PARAMS)
  private Map<String, String> params = new HashMap<>();

  public BatchPredictRequest() {
  }

  public BatchPredictRequest inputConfig(BatchPredictInputConfig inputConfig) {
    this.inputConfig = inputConfig;
    return this;
  }

  /**
   * Get inputConfig
   * @return inputConfig
   */
  @javax.annotation.Nullable
  public BatchPredictInputConfig getInputConfig() {
    return inputConfig;
  }

  public void setInputConfig(BatchPredictInputConfig inputConfig) {
    this.inputConfig = inputConfig;
  }


  public BatchPredictRequest outputConfig(BatchPredictOutputConfig outputConfig) {
    this.outputConfig = outputConfig;
    return this;
  }

  /**
   * Get outputConfig
   * @return outputConfig
   */
  @javax.annotation.Nullable
  public BatchPredictOutputConfig getOutputConfig() {
    return outputConfig;
  }

  public void setOutputConfig(BatchPredictOutputConfig outputConfig) {
    this.outputConfig = outputConfig;
  }


  public BatchPredictRequest params(Map<String, String> params) {
    this.params = params;
    return this;
  }

  public BatchPredictRequest putParamsItem(String key, String paramsItem) {
    if (this.params == null) {
      this.params = new HashMap<>();
    }
    this.params.put(key, paramsItem);
    return this;
  }

  /**
   * Required. Additional domain-specific parameters for the predictions, any string must be up to 25000 characters long. * For Text Classification: &#x60;score_threshold&#x60; - (float) A value from 0.0 to 1.0. When the model makes predictions for a text snippet, it will only produce results that have at least this confidence score. The default is 0.5. * For Image Classification: &#x60;score_threshold&#x60; - (float) A value from 0.0 to 1.0. When the model makes predictions for an image, it will only produce results that have at least this confidence score. The default is 0.5. * For Image Object Detection: &#x60;score_threshold&#x60; - (float) When Model detects objects on the image, it will only produce bounding boxes which have at least this confidence score. Value in 0 to 1 range, default is 0.5. &#x60;max_bounding_box_count&#x60; - (int64) No more than this number of bounding boxes will be produced per image. Default is 100, the requested value may be limited by server. * For Video Classification : &#x60;score_threshold&#x60; - (float) A value from 0.0 to 1.0. When the model makes predictions for a video, it will only produce results that have at least this confidence score. The default is 0.5. &#x60;segment_classification&#x60; - (boolean) Set to true to request segment-level classification. AutoML Video Intelligence returns labels and their confidence scores for the entire segment of the video that user specified in the request configuration. The default is \&quot;true\&quot;. &#x60;shot_classification&#x60; - (boolean) Set to true to request shot-level classification. AutoML Video Intelligence determines the boundaries for each camera shot in the entire segment of the video that user specified in the request configuration. AutoML Video Intelligence then returns labels and their confidence scores for each detected shot, along with the start and end time of the shot. WARNING: Model evaluation is not done for this classification type, the quality of it depends on training data, but there are no metrics provided to describe that quality. The default is \&quot;false\&quot;. &#x60;1s_interval_classification&#x60; - (boolean) Set to true to request classification for a video at one-second intervals. AutoML Video Intelligence returns labels and their confidence scores for each second of the entire segment of the video that user specified in the request configuration. WARNING: Model evaluation is not done for this classification type, the quality of it depends on training data, but there are no metrics provided to describe that quality. The default is \&quot;false\&quot;. * For Tables: feature_importance - (boolean) Whether feature importance should be populated in the returned TablesAnnotations. The default is false. * For Video Object Tracking: &#x60;score_threshold&#x60; - (float) When Model detects objects on video frames, it will only produce bounding boxes which have at least this confidence score. Value in 0 to 1 range, default is 0.5. &#x60;max_bounding_box_count&#x60; - (int64) No more than this number of bounding boxes will be returned per frame. Default is 100, the requested value may be limited by server. &#x60;min_bounding_box_size&#x60; - (float) Only bounding boxes with shortest edge at least that long as a relative value of video frame size will be returned. Value in 0 to 1 range. Default is 0.
   * @return params
   */
  @javax.annotation.Nullable
  public Map<String, String> getParams() {
    return params;
  }

  public void setParams(Map<String, String> params) {
    this.params = params;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BatchPredictRequest batchPredictRequest = (BatchPredictRequest) o;
    return Objects.equals(this.inputConfig, batchPredictRequest.inputConfig) &&
        Objects.equals(this.outputConfig, batchPredictRequest.outputConfig) &&
        Objects.equals(this.params, batchPredictRequest.params);
  }

  @Override
  public int hashCode() {
    return Objects.hash(inputConfig, outputConfig, params);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BatchPredictRequest {\n");
    sb.append("    inputConfig: ").append(toIndentedString(inputConfig)).append("\n");
    sb.append("    outputConfig: ").append(toIndentedString(outputConfig)).append("\n");
    sb.append("    params: ").append(toIndentedString(params)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("inputConfig");
    openapiFields.add("outputConfig");
    openapiFields.add("params");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BatchPredictRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BatchPredictRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BatchPredictRequest is not found in the empty JSON string", BatchPredictRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BatchPredictRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BatchPredictRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `inputConfig`
      if (jsonObj.get("inputConfig") != null && !jsonObj.get("inputConfig").isJsonNull()) {
        BatchPredictInputConfig.validateJsonElement(jsonObj.get("inputConfig"));
      }
      // validate the optional field `outputConfig`
      if (jsonObj.get("outputConfig") != null && !jsonObj.get("outputConfig").isJsonNull()) {
        BatchPredictOutputConfig.validateJsonElement(jsonObj.get("outputConfig"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BatchPredictRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BatchPredictRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BatchPredictRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BatchPredictRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<BatchPredictRequest>() {
           @Override
           public void write(JsonWriter out, BatchPredictRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BatchPredictRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BatchPredictRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BatchPredictRequest
   * @throws IOException if the JSON string is invalid with respect to BatchPredictRequest
   */
  public static BatchPredictRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BatchPredictRequest.class);
  }

  /**
   * Convert an instance of BatchPredictRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

