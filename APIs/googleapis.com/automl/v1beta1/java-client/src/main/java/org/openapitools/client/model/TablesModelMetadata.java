/*
 * Cloud AutoML API
 * Train high-quality custom machine learning models with minimum effort and machine learning expertise.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ColumnSpec;
import org.openapitools.client.model.TablesModelColumnInfo;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Model metadata specific to AutoML Tables.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:50.092187-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TablesModelMetadata {
  public static final String SERIALIZED_NAME_DISABLE_EARLY_STOPPING = "disableEarlyStopping";
  @SerializedName(SERIALIZED_NAME_DISABLE_EARLY_STOPPING)
  private Boolean disableEarlyStopping;

  public static final String SERIALIZED_NAME_INPUT_FEATURE_COLUMN_SPECS = "inputFeatureColumnSpecs";
  @SerializedName(SERIALIZED_NAME_INPUT_FEATURE_COLUMN_SPECS)
  private List<ColumnSpec> inputFeatureColumnSpecs = new ArrayList<>();

  public static final String SERIALIZED_NAME_OPTIMIZATION_OBJECTIVE = "optimizationObjective";
  @SerializedName(SERIALIZED_NAME_OPTIMIZATION_OBJECTIVE)
  private String optimizationObjective;

  public static final String SERIALIZED_NAME_OPTIMIZATION_OBJECTIVE_PRECISION_VALUE = "optimizationObjectivePrecisionValue";
  @SerializedName(SERIALIZED_NAME_OPTIMIZATION_OBJECTIVE_PRECISION_VALUE)
  private Float optimizationObjectivePrecisionValue;

  public static final String SERIALIZED_NAME_OPTIMIZATION_OBJECTIVE_RECALL_VALUE = "optimizationObjectiveRecallValue";
  @SerializedName(SERIALIZED_NAME_OPTIMIZATION_OBJECTIVE_RECALL_VALUE)
  private Float optimizationObjectiveRecallValue;

  public static final String SERIALIZED_NAME_TABLES_MODEL_COLUMN_INFO = "tablesModelColumnInfo";
  @SerializedName(SERIALIZED_NAME_TABLES_MODEL_COLUMN_INFO)
  private List<TablesModelColumnInfo> tablesModelColumnInfo = new ArrayList<>();

  public static final String SERIALIZED_NAME_TARGET_COLUMN_SPEC = "targetColumnSpec";
  @SerializedName(SERIALIZED_NAME_TARGET_COLUMN_SPEC)
  private ColumnSpec targetColumnSpec;

  public static final String SERIALIZED_NAME_TRAIN_BUDGET_MILLI_NODE_HOURS = "trainBudgetMilliNodeHours";
  @SerializedName(SERIALIZED_NAME_TRAIN_BUDGET_MILLI_NODE_HOURS)
  private String trainBudgetMilliNodeHours;

  public static final String SERIALIZED_NAME_TRAIN_COST_MILLI_NODE_HOURS = "trainCostMilliNodeHours";
  @SerializedName(SERIALIZED_NAME_TRAIN_COST_MILLI_NODE_HOURS)
  private String trainCostMilliNodeHours;

  public TablesModelMetadata() {
  }

  public TablesModelMetadata disableEarlyStopping(Boolean disableEarlyStopping) {
    this.disableEarlyStopping = disableEarlyStopping;
    return this;
  }

  /**
   * Use the entire training budget. This disables the early stopping feature. By default, the early stopping feature is enabled, which means that AutoML Tables might stop training before the entire training budget has been used.
   * @return disableEarlyStopping
   */
  @javax.annotation.Nullable
  public Boolean getDisableEarlyStopping() {
    return disableEarlyStopping;
  }

  public void setDisableEarlyStopping(Boolean disableEarlyStopping) {
    this.disableEarlyStopping = disableEarlyStopping;
  }


  public TablesModelMetadata inputFeatureColumnSpecs(List<ColumnSpec> inputFeatureColumnSpecs) {
    this.inputFeatureColumnSpecs = inputFeatureColumnSpecs;
    return this;
  }

  public TablesModelMetadata addInputFeatureColumnSpecsItem(ColumnSpec inputFeatureColumnSpecsItem) {
    if (this.inputFeatureColumnSpecs == null) {
      this.inputFeatureColumnSpecs = new ArrayList<>();
    }
    this.inputFeatureColumnSpecs.add(inputFeatureColumnSpecsItem);
    return this;
  }

  /**
   * Column specs of the dataset&#39;s primary table&#39;s columns, on which the model is trained and which are used as the input for predictions. The target_column as well as, according to dataset&#39;s state upon model creation, weight_column, and ml_use_column must never be included here. Only 3 fields are used: * name - May be set on CreateModel, if set only the columns specified are used, otherwise all primary table&#39;s columns (except the ones listed above) are used for the training and prediction input. * display_name - Output only. * data_type - Output only.
   * @return inputFeatureColumnSpecs
   */
  @javax.annotation.Nullable
  public List<ColumnSpec> getInputFeatureColumnSpecs() {
    return inputFeatureColumnSpecs;
  }

  public void setInputFeatureColumnSpecs(List<ColumnSpec> inputFeatureColumnSpecs) {
    this.inputFeatureColumnSpecs = inputFeatureColumnSpecs;
  }


  public TablesModelMetadata optimizationObjective(String optimizationObjective) {
    this.optimizationObjective = optimizationObjective;
    return this;
  }

  /**
   * Objective function the model is optimizing towards. The training process creates a model that maximizes/minimizes the value of the objective function over the validation set. The supported optimization objectives depend on the prediction type. If the field is not set, a default objective function is used. CLASSIFICATION_BINARY: \&quot;MAXIMIZE_AU_ROC\&quot; (default) - Maximize the area under the receiver operating characteristic (ROC) curve. \&quot;MINIMIZE_LOG_LOSS\&quot; - Minimize log loss. \&quot;MAXIMIZE_AU_PRC\&quot; - Maximize the area under the precision-recall curve. \&quot;MAXIMIZE_PRECISION_AT_RECALL\&quot; - Maximize precision for a specified recall value. \&quot;MAXIMIZE_RECALL_AT_PRECISION\&quot; - Maximize recall for a specified precision value. CLASSIFICATION_MULTI_CLASS : \&quot;MINIMIZE_LOG_LOSS\&quot; (default) - Minimize log loss. REGRESSION: \&quot;MINIMIZE_RMSE\&quot; (default) - Minimize root-mean-squared error (RMSE). \&quot;MINIMIZE_MAE\&quot; - Minimize mean-absolute error (MAE). \&quot;MINIMIZE_RMSLE\&quot; - Minimize root-mean-squared log error (RMSLE).
   * @return optimizationObjective
   */
  @javax.annotation.Nullable
  public String getOptimizationObjective() {
    return optimizationObjective;
  }

  public void setOptimizationObjective(String optimizationObjective) {
    this.optimizationObjective = optimizationObjective;
  }


  public TablesModelMetadata optimizationObjectivePrecisionValue(Float optimizationObjectivePrecisionValue) {
    this.optimizationObjectivePrecisionValue = optimizationObjectivePrecisionValue;
    return this;
  }

  /**
   * Required when optimization_objective is \&quot;MAXIMIZE_RECALL_AT_PRECISION\&quot;. Must be between 0 and 1, inclusive.
   * @return optimizationObjectivePrecisionValue
   */
  @javax.annotation.Nullable
  public Float getOptimizationObjectivePrecisionValue() {
    return optimizationObjectivePrecisionValue;
  }

  public void setOptimizationObjectivePrecisionValue(Float optimizationObjectivePrecisionValue) {
    this.optimizationObjectivePrecisionValue = optimizationObjectivePrecisionValue;
  }


  public TablesModelMetadata optimizationObjectiveRecallValue(Float optimizationObjectiveRecallValue) {
    this.optimizationObjectiveRecallValue = optimizationObjectiveRecallValue;
    return this;
  }

  /**
   * Required when optimization_objective is \&quot;MAXIMIZE_PRECISION_AT_RECALL\&quot;. Must be between 0 and 1, inclusive.
   * @return optimizationObjectiveRecallValue
   */
  @javax.annotation.Nullable
  public Float getOptimizationObjectiveRecallValue() {
    return optimizationObjectiveRecallValue;
  }

  public void setOptimizationObjectiveRecallValue(Float optimizationObjectiveRecallValue) {
    this.optimizationObjectiveRecallValue = optimizationObjectiveRecallValue;
  }


  public TablesModelMetadata tablesModelColumnInfo(List<TablesModelColumnInfo> tablesModelColumnInfo) {
    this.tablesModelColumnInfo = tablesModelColumnInfo;
    return this;
  }

  public TablesModelMetadata addTablesModelColumnInfoItem(TablesModelColumnInfo tablesModelColumnInfoItem) {
    if (this.tablesModelColumnInfo == null) {
      this.tablesModelColumnInfo = new ArrayList<>();
    }
    this.tablesModelColumnInfo.add(tablesModelColumnInfoItem);
    return this;
  }

  /**
   * Output only. Auxiliary information for each of the input_feature_column_specs with respect to this particular model.
   * @return tablesModelColumnInfo
   */
  @javax.annotation.Nullable
  public List<TablesModelColumnInfo> getTablesModelColumnInfo() {
    return tablesModelColumnInfo;
  }

  public void setTablesModelColumnInfo(List<TablesModelColumnInfo> tablesModelColumnInfo) {
    this.tablesModelColumnInfo = tablesModelColumnInfo;
  }


  public TablesModelMetadata targetColumnSpec(ColumnSpec targetColumnSpec) {
    this.targetColumnSpec = targetColumnSpec;
    return this;
  }

  /**
   * Get targetColumnSpec
   * @return targetColumnSpec
   */
  @javax.annotation.Nullable
  public ColumnSpec getTargetColumnSpec() {
    return targetColumnSpec;
  }

  public void setTargetColumnSpec(ColumnSpec targetColumnSpec) {
    this.targetColumnSpec = targetColumnSpec;
  }


  public TablesModelMetadata trainBudgetMilliNodeHours(String trainBudgetMilliNodeHours) {
    this.trainBudgetMilliNodeHours = trainBudgetMilliNodeHours;
    return this;
  }

  /**
   * Required. The train budget of creating this model, expressed in milli node hours i.e. 1,000 value in this field means 1 node hour. The training cost of the model will not exceed this budget. The final cost will be attempted to be close to the budget, though may end up being (even) noticeably smaller - at the backend&#39;s discretion. This especially may happen when further model training ceases to provide any improvements. If the budget is set to a value known to be insufficient to train a model for the given dataset, the training won&#39;t be attempted and will error. The train budget must be between 1,000 and 72,000 milli node hours, inclusive.
   * @return trainBudgetMilliNodeHours
   */
  @javax.annotation.Nullable
  public String getTrainBudgetMilliNodeHours() {
    return trainBudgetMilliNodeHours;
  }

  public void setTrainBudgetMilliNodeHours(String trainBudgetMilliNodeHours) {
    this.trainBudgetMilliNodeHours = trainBudgetMilliNodeHours;
  }


  public TablesModelMetadata trainCostMilliNodeHours(String trainCostMilliNodeHours) {
    this.trainCostMilliNodeHours = trainCostMilliNodeHours;
    return this;
  }

  /**
   * Output only. The actual training cost of the model, expressed in milli node hours, i.e. 1,000 value in this field means 1 node hour. Guaranteed to not exceed the train budget.
   * @return trainCostMilliNodeHours
   */
  @javax.annotation.Nullable
  public String getTrainCostMilliNodeHours() {
    return trainCostMilliNodeHours;
  }

  public void setTrainCostMilliNodeHours(String trainCostMilliNodeHours) {
    this.trainCostMilliNodeHours = trainCostMilliNodeHours;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TablesModelMetadata tablesModelMetadata = (TablesModelMetadata) o;
    return Objects.equals(this.disableEarlyStopping, tablesModelMetadata.disableEarlyStopping) &&
        Objects.equals(this.inputFeatureColumnSpecs, tablesModelMetadata.inputFeatureColumnSpecs) &&
        Objects.equals(this.optimizationObjective, tablesModelMetadata.optimizationObjective) &&
        Objects.equals(this.optimizationObjectivePrecisionValue, tablesModelMetadata.optimizationObjectivePrecisionValue) &&
        Objects.equals(this.optimizationObjectiveRecallValue, tablesModelMetadata.optimizationObjectiveRecallValue) &&
        Objects.equals(this.tablesModelColumnInfo, tablesModelMetadata.tablesModelColumnInfo) &&
        Objects.equals(this.targetColumnSpec, tablesModelMetadata.targetColumnSpec) &&
        Objects.equals(this.trainBudgetMilliNodeHours, tablesModelMetadata.trainBudgetMilliNodeHours) &&
        Objects.equals(this.trainCostMilliNodeHours, tablesModelMetadata.trainCostMilliNodeHours);
  }

  @Override
  public int hashCode() {
    return Objects.hash(disableEarlyStopping, inputFeatureColumnSpecs, optimizationObjective, optimizationObjectivePrecisionValue, optimizationObjectiveRecallValue, tablesModelColumnInfo, targetColumnSpec, trainBudgetMilliNodeHours, trainCostMilliNodeHours);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TablesModelMetadata {\n");
    sb.append("    disableEarlyStopping: ").append(toIndentedString(disableEarlyStopping)).append("\n");
    sb.append("    inputFeatureColumnSpecs: ").append(toIndentedString(inputFeatureColumnSpecs)).append("\n");
    sb.append("    optimizationObjective: ").append(toIndentedString(optimizationObjective)).append("\n");
    sb.append("    optimizationObjectivePrecisionValue: ").append(toIndentedString(optimizationObjectivePrecisionValue)).append("\n");
    sb.append("    optimizationObjectiveRecallValue: ").append(toIndentedString(optimizationObjectiveRecallValue)).append("\n");
    sb.append("    tablesModelColumnInfo: ").append(toIndentedString(tablesModelColumnInfo)).append("\n");
    sb.append("    targetColumnSpec: ").append(toIndentedString(targetColumnSpec)).append("\n");
    sb.append("    trainBudgetMilliNodeHours: ").append(toIndentedString(trainBudgetMilliNodeHours)).append("\n");
    sb.append("    trainCostMilliNodeHours: ").append(toIndentedString(trainCostMilliNodeHours)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("disableEarlyStopping");
    openapiFields.add("inputFeatureColumnSpecs");
    openapiFields.add("optimizationObjective");
    openapiFields.add("optimizationObjectivePrecisionValue");
    openapiFields.add("optimizationObjectiveRecallValue");
    openapiFields.add("tablesModelColumnInfo");
    openapiFields.add("targetColumnSpec");
    openapiFields.add("trainBudgetMilliNodeHours");
    openapiFields.add("trainCostMilliNodeHours");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TablesModelMetadata
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TablesModelMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TablesModelMetadata is not found in the empty JSON string", TablesModelMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TablesModelMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TablesModelMetadata` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("inputFeatureColumnSpecs") != null && !jsonObj.get("inputFeatureColumnSpecs").isJsonNull()) {
        JsonArray jsonArrayinputFeatureColumnSpecs = jsonObj.getAsJsonArray("inputFeatureColumnSpecs");
        if (jsonArrayinputFeatureColumnSpecs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("inputFeatureColumnSpecs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `inputFeatureColumnSpecs` to be an array in the JSON string but got `%s`", jsonObj.get("inputFeatureColumnSpecs").toString()));
          }

          // validate the optional field `inputFeatureColumnSpecs` (array)
          for (int i = 0; i < jsonArrayinputFeatureColumnSpecs.size(); i++) {
            ColumnSpec.validateJsonElement(jsonArrayinputFeatureColumnSpecs.get(i));
          };
        }
      }
      if ((jsonObj.get("optimizationObjective") != null && !jsonObj.get("optimizationObjective").isJsonNull()) && !jsonObj.get("optimizationObjective").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `optimizationObjective` to be a primitive type in the JSON string but got `%s`", jsonObj.get("optimizationObjective").toString()));
      }
      if (jsonObj.get("tablesModelColumnInfo") != null && !jsonObj.get("tablesModelColumnInfo").isJsonNull()) {
        JsonArray jsonArraytablesModelColumnInfo = jsonObj.getAsJsonArray("tablesModelColumnInfo");
        if (jsonArraytablesModelColumnInfo != null) {
          // ensure the json data is an array
          if (!jsonObj.get("tablesModelColumnInfo").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `tablesModelColumnInfo` to be an array in the JSON string but got `%s`", jsonObj.get("tablesModelColumnInfo").toString()));
          }

          // validate the optional field `tablesModelColumnInfo` (array)
          for (int i = 0; i < jsonArraytablesModelColumnInfo.size(); i++) {
            TablesModelColumnInfo.validateJsonElement(jsonArraytablesModelColumnInfo.get(i));
          };
        }
      }
      // validate the optional field `targetColumnSpec`
      if (jsonObj.get("targetColumnSpec") != null && !jsonObj.get("targetColumnSpec").isJsonNull()) {
        ColumnSpec.validateJsonElement(jsonObj.get("targetColumnSpec"));
      }
      if ((jsonObj.get("trainBudgetMilliNodeHours") != null && !jsonObj.get("trainBudgetMilliNodeHours").isJsonNull()) && !jsonObj.get("trainBudgetMilliNodeHours").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trainBudgetMilliNodeHours` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trainBudgetMilliNodeHours").toString()));
      }
      if ((jsonObj.get("trainCostMilliNodeHours") != null && !jsonObj.get("trainCostMilliNodeHours").isJsonNull()) && !jsonObj.get("trainCostMilliNodeHours").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trainCostMilliNodeHours` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trainCostMilliNodeHours").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TablesModelMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TablesModelMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TablesModelMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TablesModelMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<TablesModelMetadata>() {
           @Override
           public void write(JsonWriter out, TablesModelMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TablesModelMetadata read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TablesModelMetadata given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TablesModelMetadata
   * @throws IOException if the JSON string is invalid with respect to TablesModelMetadata
   */
  public static TablesModelMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TablesModelMetadata.class);
  }

  /**
   * Convert an instance of TablesModelMetadata to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

