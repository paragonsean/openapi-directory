/*
 * AlloyDB API
 * AlloyDB for PostgreSQL is an open source-compatible database service that provides a powerful option for migrating, modernizing, or building commercial-grade applications. It offers full compatibility with standard PostgreSQL, and is more than 4x faster for transactional workloads and up to 100x faster for analytical queries than standard PostgreSQL in our performance tests. AlloyDB for PostgreSQL offers a 99.99 percent availability SLA inclusive of maintenance. AlloyDB is optimized for the most demanding use cases, allowing you to build new applications that require high transaction throughput, large database sizes, or multiple read resources; scale existing PostgreSQL workloads with no application changes; and modernize legacy proprietary databases. 
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.IntegerRestrictions;
import org.openapitools.client.model.StringRestrictions;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * SupportedDatabaseFlag gives general information about a database flag, like type and allowed values. This is a static value that is defined on the server side, and it cannot be modified by callers. To set the Database flags on a particular Instance, a caller should modify the Instance.database_flags field.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:06.887241-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class SupportedDatabaseFlag {
  public static final String SERIALIZED_NAME_ACCEPTS_MULTIPLE_VALUES = "acceptsMultipleValues";
  @SerializedName(SERIALIZED_NAME_ACCEPTS_MULTIPLE_VALUES)
  private Boolean acceptsMultipleValues;

  public static final String SERIALIZED_NAME_FLAG_NAME = "flagName";
  @SerializedName(SERIALIZED_NAME_FLAG_NAME)
  private String flagName;

  public static final String SERIALIZED_NAME_INTEGER_RESTRICTIONS = "integerRestrictions";
  @SerializedName(SERIALIZED_NAME_INTEGER_RESTRICTIONS)
  private IntegerRestrictions integerRestrictions;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_REQUIRES_DB_RESTART = "requiresDbRestart";
  @SerializedName(SERIALIZED_NAME_REQUIRES_DB_RESTART)
  private Boolean requiresDbRestart;

  public static final String SERIALIZED_NAME_STRING_RESTRICTIONS = "stringRestrictions";
  @SerializedName(SERIALIZED_NAME_STRING_RESTRICTIONS)
  private StringRestrictions stringRestrictions;

  /**
   * Gets or Sets supportedDbVersions
   */
  @JsonAdapter(SupportedDbVersionsEnum.Adapter.class)
  public enum SupportedDbVersionsEnum {
    DATABASE_VERSION_UNSPECIFIED("DATABASE_VERSION_UNSPECIFIED"),
    
    POSTGRES_13("POSTGRES_13"),
    
    POSTGRES_14("POSTGRES_14"),
    
    POSTGRES_15("POSTGRES_15");

    private String value;

    SupportedDbVersionsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SupportedDbVersionsEnum fromValue(String value) {
      for (SupportedDbVersionsEnum b : SupportedDbVersionsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SupportedDbVersionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SupportedDbVersionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SupportedDbVersionsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SupportedDbVersionsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SupportedDbVersionsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SUPPORTED_DB_VERSIONS = "supportedDbVersions";
  @SerializedName(SERIALIZED_NAME_SUPPORTED_DB_VERSIONS)
  private List<SupportedDbVersionsEnum> supportedDbVersions = new ArrayList<>();

  /**
   * Gets or Sets valueType
   */
  @JsonAdapter(ValueTypeEnum.Adapter.class)
  public enum ValueTypeEnum {
    VALUE_TYPE_UNSPECIFIED("VALUE_TYPE_UNSPECIFIED"),
    
    STRING("STRING"),
    
    INTEGER("INTEGER"),
    
    FLOAT("FLOAT"),
    
    NONE("NONE");

    private String value;

    ValueTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ValueTypeEnum fromValue(String value) {
      for (ValueTypeEnum b : ValueTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ValueTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ValueTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ValueTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ValueTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ValueTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VALUE_TYPE = "valueType";
  @SerializedName(SERIALIZED_NAME_VALUE_TYPE)
  private ValueTypeEnum valueType;

  public SupportedDatabaseFlag() {
  }

  public SupportedDatabaseFlag acceptsMultipleValues(Boolean acceptsMultipleValues) {
    this.acceptsMultipleValues = acceptsMultipleValues;
    return this;
  }

  /**
   * Whether the database flag accepts multiple values. If true, a comma-separated list of stringified values may be specified.
   * @return acceptsMultipleValues
   */
  @javax.annotation.Nullable
  public Boolean getAcceptsMultipleValues() {
    return acceptsMultipleValues;
  }

  public void setAcceptsMultipleValues(Boolean acceptsMultipleValues) {
    this.acceptsMultipleValues = acceptsMultipleValues;
  }


  public SupportedDatabaseFlag flagName(String flagName) {
    this.flagName = flagName;
    return this;
  }

  /**
   * The name of the database flag, e.g. \&quot;max_allowed_packets\&quot;. The is a possibly key for the Instance.database_flags map field.
   * @return flagName
   */
  @javax.annotation.Nullable
  public String getFlagName() {
    return flagName;
  }

  public void setFlagName(String flagName) {
    this.flagName = flagName;
  }


  public SupportedDatabaseFlag integerRestrictions(IntegerRestrictions integerRestrictions) {
    this.integerRestrictions = integerRestrictions;
    return this;
  }

  /**
   * Get integerRestrictions
   * @return integerRestrictions
   */
  @javax.annotation.Nullable
  public IntegerRestrictions getIntegerRestrictions() {
    return integerRestrictions;
  }

  public void setIntegerRestrictions(IntegerRestrictions integerRestrictions) {
    this.integerRestrictions = integerRestrictions;
  }


  public SupportedDatabaseFlag name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the flag resource, following Google Cloud conventions, e.g.: * projects/{project}/locations/{location}/flags/{flag} This field currently has no semantic meaning.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public SupportedDatabaseFlag requiresDbRestart(Boolean requiresDbRestart) {
    this.requiresDbRestart = requiresDbRestart;
    return this;
  }

  /**
   * Whether setting or updating this flag on an Instance requires a database restart. If a flag that requires database restart is set, the backend will automatically restart the database (making sure to satisfy any availability SLO&#39;s).
   * @return requiresDbRestart
   */
  @javax.annotation.Nullable
  public Boolean getRequiresDbRestart() {
    return requiresDbRestart;
  }

  public void setRequiresDbRestart(Boolean requiresDbRestart) {
    this.requiresDbRestart = requiresDbRestart;
  }


  public SupportedDatabaseFlag stringRestrictions(StringRestrictions stringRestrictions) {
    this.stringRestrictions = stringRestrictions;
    return this;
  }

  /**
   * Get stringRestrictions
   * @return stringRestrictions
   */
  @javax.annotation.Nullable
  public StringRestrictions getStringRestrictions() {
    return stringRestrictions;
  }

  public void setStringRestrictions(StringRestrictions stringRestrictions) {
    this.stringRestrictions = stringRestrictions;
  }


  public SupportedDatabaseFlag supportedDbVersions(List<SupportedDbVersionsEnum> supportedDbVersions) {
    this.supportedDbVersions = supportedDbVersions;
    return this;
  }

  public SupportedDatabaseFlag addSupportedDbVersionsItem(SupportedDbVersionsEnum supportedDbVersionsItem) {
    if (this.supportedDbVersions == null) {
      this.supportedDbVersions = new ArrayList<>();
    }
    this.supportedDbVersions.add(supportedDbVersionsItem);
    return this;
  }

  /**
   * Major database engine versions for which this flag is supported.
   * @return supportedDbVersions
   */
  @javax.annotation.Nullable
  public List<SupportedDbVersionsEnum> getSupportedDbVersions() {
    return supportedDbVersions;
  }

  public void setSupportedDbVersions(List<SupportedDbVersionsEnum> supportedDbVersions) {
    this.supportedDbVersions = supportedDbVersions;
  }


  public SupportedDatabaseFlag valueType(ValueTypeEnum valueType) {
    this.valueType = valueType;
    return this;
  }

  /**
   * Get valueType
   * @return valueType
   */
  @javax.annotation.Nullable
  public ValueTypeEnum getValueType() {
    return valueType;
  }

  public void setValueType(ValueTypeEnum valueType) {
    this.valueType = valueType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SupportedDatabaseFlag supportedDatabaseFlag = (SupportedDatabaseFlag) o;
    return Objects.equals(this.acceptsMultipleValues, supportedDatabaseFlag.acceptsMultipleValues) &&
        Objects.equals(this.flagName, supportedDatabaseFlag.flagName) &&
        Objects.equals(this.integerRestrictions, supportedDatabaseFlag.integerRestrictions) &&
        Objects.equals(this.name, supportedDatabaseFlag.name) &&
        Objects.equals(this.requiresDbRestart, supportedDatabaseFlag.requiresDbRestart) &&
        Objects.equals(this.stringRestrictions, supportedDatabaseFlag.stringRestrictions) &&
        Objects.equals(this.supportedDbVersions, supportedDatabaseFlag.supportedDbVersions) &&
        Objects.equals(this.valueType, supportedDatabaseFlag.valueType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceptsMultipleValues, flagName, integerRestrictions, name, requiresDbRestart, stringRestrictions, supportedDbVersions, valueType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SupportedDatabaseFlag {\n");
    sb.append("    acceptsMultipleValues: ").append(toIndentedString(acceptsMultipleValues)).append("\n");
    sb.append("    flagName: ").append(toIndentedString(flagName)).append("\n");
    sb.append("    integerRestrictions: ").append(toIndentedString(integerRestrictions)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    requiresDbRestart: ").append(toIndentedString(requiresDbRestart)).append("\n");
    sb.append("    stringRestrictions: ").append(toIndentedString(stringRestrictions)).append("\n");
    sb.append("    supportedDbVersions: ").append(toIndentedString(supportedDbVersions)).append("\n");
    sb.append("    valueType: ").append(toIndentedString(valueType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acceptsMultipleValues");
    openapiFields.add("flagName");
    openapiFields.add("integerRestrictions");
    openapiFields.add("name");
    openapiFields.add("requiresDbRestart");
    openapiFields.add("stringRestrictions");
    openapiFields.add("supportedDbVersions");
    openapiFields.add("valueType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SupportedDatabaseFlag
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SupportedDatabaseFlag.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SupportedDatabaseFlag is not found in the empty JSON string", SupportedDatabaseFlag.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SupportedDatabaseFlag.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SupportedDatabaseFlag` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("flagName") != null && !jsonObj.get("flagName").isJsonNull()) && !jsonObj.get("flagName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `flagName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("flagName").toString()));
      }
      // validate the optional field `integerRestrictions`
      if (jsonObj.get("integerRestrictions") != null && !jsonObj.get("integerRestrictions").isJsonNull()) {
        IntegerRestrictions.validateJsonElement(jsonObj.get("integerRestrictions"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `stringRestrictions`
      if (jsonObj.get("stringRestrictions") != null && !jsonObj.get("stringRestrictions").isJsonNull()) {
        StringRestrictions.validateJsonElement(jsonObj.get("stringRestrictions"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("supportedDbVersions") != null && !jsonObj.get("supportedDbVersions").isJsonNull() && !jsonObj.get("supportedDbVersions").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `supportedDbVersions` to be an array in the JSON string but got `%s`", jsonObj.get("supportedDbVersions").toString()));
      }
      if ((jsonObj.get("valueType") != null && !jsonObj.get("valueType").isJsonNull()) && !jsonObj.get("valueType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `valueType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valueType").toString()));
      }
      // validate the optional field `valueType`
      if (jsonObj.get("valueType") != null && !jsonObj.get("valueType").isJsonNull()) {
        ValueTypeEnum.validateJsonElement(jsonObj.get("valueType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SupportedDatabaseFlag.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SupportedDatabaseFlag' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SupportedDatabaseFlag> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SupportedDatabaseFlag.class));

       return (TypeAdapter<T>) new TypeAdapter<SupportedDatabaseFlag>() {
           @Override
           public void write(JsonWriter out, SupportedDatabaseFlag value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SupportedDatabaseFlag read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SupportedDatabaseFlag given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SupportedDatabaseFlag
   * @throws IOException if the JSON string is invalid with respect to SupportedDatabaseFlag
   */
  public static SupportedDatabaseFlag fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SupportedDatabaseFlag.class);
  }

  /**
   * Convert an instance of SupportedDatabaseFlag to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

