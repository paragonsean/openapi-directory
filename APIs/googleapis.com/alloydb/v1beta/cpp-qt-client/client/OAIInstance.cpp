/**
 * AlloyDB API
 * AlloyDB for PostgreSQL is an open source-compatible database service that provides a powerful option for migrating, modernizing, or building commercial-grade applications. It offers full compatibility with standard PostgreSQL, and is more than 4x faster for transactional workloads and up to 100x faster for analytical queries than standard PostgreSQL in our performance tests. AlloyDB for PostgreSQL offers a 99.99 percent availability SLA inclusive of maintenance. AlloyDB is optimized for the most demanding use cases, allowing you to build new applications that require high transaction throughput, large database sizes, or multiple read resources; scale existing PostgreSQL workloads with no application changes; and modernize legacy proprietary databases. 
 *
 * The version of the OpenAPI document: v1beta
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIInstance.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIInstance::OAIInstance(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIInstance::OAIInstance() {
    this->initializeModel();
}

OAIInstance::~OAIInstance() {}

void OAIInstance::initializeModel() {

    m_annotations_isSet = false;
    m_annotations_isValid = false;

    m_availability_type_isSet = false;
    m_availability_type_isValid = false;

    m_client_connection_config_isSet = false;
    m_client_connection_config_isValid = false;

    m_create_time_isSet = false;
    m_create_time_isValid = false;

    m_database_flags_isSet = false;
    m_database_flags_isValid = false;

    m_delete_time_isSet = false;
    m_delete_time_isValid = false;

    m_display_name_isSet = false;
    m_display_name_isValid = false;

    m_etag_isSet = false;
    m_etag_isValid = false;

    m_gce_zone_isSet = false;
    m_gce_zone_isValid = false;

    m_instance_type_isSet = false;
    m_instance_type_isValid = false;

    m_ip_address_isSet = false;
    m_ip_address_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_machine_config_isSet = false;
    m_machine_config_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_network_config_isSet = false;
    m_network_config_isValid = false;

    m_nodes_isSet = false;
    m_nodes_isValid = false;

    m_psc_instance_config_isSet = false;
    m_psc_instance_config_isValid = false;

    m_public_ip_address_isSet = false;
    m_public_ip_address_isValid = false;

    m_query_insights_config_isSet = false;
    m_query_insights_config_isValid = false;

    m_read_pool_config_isSet = false;
    m_read_pool_config_isValid = false;

    m_reconciling_isSet = false;
    m_reconciling_isValid = false;

    m_satisfies_pzs_isSet = false;
    m_satisfies_pzs_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_uid_isSet = false;
    m_uid_isValid = false;

    m_update_policy_isSet = false;
    m_update_policy_isValid = false;

    m_update_time_isSet = false;
    m_update_time_isValid = false;

    m_writable_node_isSet = false;
    m_writable_node_isValid = false;
}

void OAIInstance::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIInstance::fromJsonObject(QJsonObject json) {

    m_annotations_isValid = ::OpenAPI::fromJsonValue(m_annotations, json[QString("annotations")]);
    m_annotations_isSet = !json[QString("annotations")].isNull() && m_annotations_isValid;

    m_availability_type_isValid = ::OpenAPI::fromJsonValue(m_availability_type, json[QString("availabilityType")]);
    m_availability_type_isSet = !json[QString("availabilityType")].isNull() && m_availability_type_isValid;

    m_client_connection_config_isValid = ::OpenAPI::fromJsonValue(m_client_connection_config, json[QString("clientConnectionConfig")]);
    m_client_connection_config_isSet = !json[QString("clientConnectionConfig")].isNull() && m_client_connection_config_isValid;

    m_create_time_isValid = ::OpenAPI::fromJsonValue(m_create_time, json[QString("createTime")]);
    m_create_time_isSet = !json[QString("createTime")].isNull() && m_create_time_isValid;

    m_database_flags_isValid = ::OpenAPI::fromJsonValue(m_database_flags, json[QString("databaseFlags")]);
    m_database_flags_isSet = !json[QString("databaseFlags")].isNull() && m_database_flags_isValid;

    m_delete_time_isValid = ::OpenAPI::fromJsonValue(m_delete_time, json[QString("deleteTime")]);
    m_delete_time_isSet = !json[QString("deleteTime")].isNull() && m_delete_time_isValid;

    m_display_name_isValid = ::OpenAPI::fromJsonValue(m_display_name, json[QString("displayName")]);
    m_display_name_isSet = !json[QString("displayName")].isNull() && m_display_name_isValid;

    m_etag_isValid = ::OpenAPI::fromJsonValue(m_etag, json[QString("etag")]);
    m_etag_isSet = !json[QString("etag")].isNull() && m_etag_isValid;

    m_gce_zone_isValid = ::OpenAPI::fromJsonValue(m_gce_zone, json[QString("gceZone")]);
    m_gce_zone_isSet = !json[QString("gceZone")].isNull() && m_gce_zone_isValid;

    m_instance_type_isValid = ::OpenAPI::fromJsonValue(m_instance_type, json[QString("instanceType")]);
    m_instance_type_isSet = !json[QString("instanceType")].isNull() && m_instance_type_isValid;

    m_ip_address_isValid = ::OpenAPI::fromJsonValue(m_ip_address, json[QString("ipAddress")]);
    m_ip_address_isSet = !json[QString("ipAddress")].isNull() && m_ip_address_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_machine_config_isValid = ::OpenAPI::fromJsonValue(m_machine_config, json[QString("machineConfig")]);
    m_machine_config_isSet = !json[QString("machineConfig")].isNull() && m_machine_config_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_network_config_isValid = ::OpenAPI::fromJsonValue(m_network_config, json[QString("networkConfig")]);
    m_network_config_isSet = !json[QString("networkConfig")].isNull() && m_network_config_isValid;

    m_nodes_isValid = ::OpenAPI::fromJsonValue(m_nodes, json[QString("nodes")]);
    m_nodes_isSet = !json[QString("nodes")].isNull() && m_nodes_isValid;

    m_psc_instance_config_isValid = ::OpenAPI::fromJsonValue(m_psc_instance_config, json[QString("pscInstanceConfig")]);
    m_psc_instance_config_isSet = !json[QString("pscInstanceConfig")].isNull() && m_psc_instance_config_isValid;

    m_public_ip_address_isValid = ::OpenAPI::fromJsonValue(m_public_ip_address, json[QString("publicIpAddress")]);
    m_public_ip_address_isSet = !json[QString("publicIpAddress")].isNull() && m_public_ip_address_isValid;

    m_query_insights_config_isValid = ::OpenAPI::fromJsonValue(m_query_insights_config, json[QString("queryInsightsConfig")]);
    m_query_insights_config_isSet = !json[QString("queryInsightsConfig")].isNull() && m_query_insights_config_isValid;

    m_read_pool_config_isValid = ::OpenAPI::fromJsonValue(m_read_pool_config, json[QString("readPoolConfig")]);
    m_read_pool_config_isSet = !json[QString("readPoolConfig")].isNull() && m_read_pool_config_isValid;

    m_reconciling_isValid = ::OpenAPI::fromJsonValue(m_reconciling, json[QString("reconciling")]);
    m_reconciling_isSet = !json[QString("reconciling")].isNull() && m_reconciling_isValid;

    m_satisfies_pzs_isValid = ::OpenAPI::fromJsonValue(m_satisfies_pzs, json[QString("satisfiesPzs")]);
    m_satisfies_pzs_isSet = !json[QString("satisfiesPzs")].isNull() && m_satisfies_pzs_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("state")]);
    m_state_isSet = !json[QString("state")].isNull() && m_state_isValid;

    m_uid_isValid = ::OpenAPI::fromJsonValue(m_uid, json[QString("uid")]);
    m_uid_isSet = !json[QString("uid")].isNull() && m_uid_isValid;

    m_update_policy_isValid = ::OpenAPI::fromJsonValue(m_update_policy, json[QString("updatePolicy")]);
    m_update_policy_isSet = !json[QString("updatePolicy")].isNull() && m_update_policy_isValid;

    m_update_time_isValid = ::OpenAPI::fromJsonValue(m_update_time, json[QString("updateTime")]);
    m_update_time_isSet = !json[QString("updateTime")].isNull() && m_update_time_isValid;

    m_writable_node_isValid = ::OpenAPI::fromJsonValue(m_writable_node, json[QString("writableNode")]);
    m_writable_node_isSet = !json[QString("writableNode")].isNull() && m_writable_node_isValid;
}

QString OAIInstance::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIInstance::asJsonObject() const {
    QJsonObject obj;
    if (m_annotations.size() > 0) {
        obj.insert(QString("annotations"), ::OpenAPI::toJsonValue(m_annotations));
    }
    if (m_availability_type_isSet) {
        obj.insert(QString("availabilityType"), ::OpenAPI::toJsonValue(m_availability_type));
    }
    if (m_client_connection_config.isSet()) {
        obj.insert(QString("clientConnectionConfig"), ::OpenAPI::toJsonValue(m_client_connection_config));
    }
    if (m_create_time_isSet) {
        obj.insert(QString("createTime"), ::OpenAPI::toJsonValue(m_create_time));
    }
    if (m_database_flags.size() > 0) {
        obj.insert(QString("databaseFlags"), ::OpenAPI::toJsonValue(m_database_flags));
    }
    if (m_delete_time_isSet) {
        obj.insert(QString("deleteTime"), ::OpenAPI::toJsonValue(m_delete_time));
    }
    if (m_display_name_isSet) {
        obj.insert(QString("displayName"), ::OpenAPI::toJsonValue(m_display_name));
    }
    if (m_etag_isSet) {
        obj.insert(QString("etag"), ::OpenAPI::toJsonValue(m_etag));
    }
    if (m_gce_zone_isSet) {
        obj.insert(QString("gceZone"), ::OpenAPI::toJsonValue(m_gce_zone));
    }
    if (m_instance_type_isSet) {
        obj.insert(QString("instanceType"), ::OpenAPI::toJsonValue(m_instance_type));
    }
    if (m_ip_address_isSet) {
        obj.insert(QString("ipAddress"), ::OpenAPI::toJsonValue(m_ip_address));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_machine_config.isSet()) {
        obj.insert(QString("machineConfig"), ::OpenAPI::toJsonValue(m_machine_config));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_network_config.isSet()) {
        obj.insert(QString("networkConfig"), ::OpenAPI::toJsonValue(m_network_config));
    }
    if (m_nodes.size() > 0) {
        obj.insert(QString("nodes"), ::OpenAPI::toJsonValue(m_nodes));
    }
    if (m_psc_instance_config.isSet()) {
        obj.insert(QString("pscInstanceConfig"), ::OpenAPI::toJsonValue(m_psc_instance_config));
    }
    if (m_public_ip_address_isSet) {
        obj.insert(QString("publicIpAddress"), ::OpenAPI::toJsonValue(m_public_ip_address));
    }
    if (m_query_insights_config.isSet()) {
        obj.insert(QString("queryInsightsConfig"), ::OpenAPI::toJsonValue(m_query_insights_config));
    }
    if (m_read_pool_config.isSet()) {
        obj.insert(QString("readPoolConfig"), ::OpenAPI::toJsonValue(m_read_pool_config));
    }
    if (m_reconciling_isSet) {
        obj.insert(QString("reconciling"), ::OpenAPI::toJsonValue(m_reconciling));
    }
    if (m_satisfies_pzs_isSet) {
        obj.insert(QString("satisfiesPzs"), ::OpenAPI::toJsonValue(m_satisfies_pzs));
    }
    if (m_state_isSet) {
        obj.insert(QString("state"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_uid_isSet) {
        obj.insert(QString("uid"), ::OpenAPI::toJsonValue(m_uid));
    }
    if (m_update_policy.isSet()) {
        obj.insert(QString("updatePolicy"), ::OpenAPI::toJsonValue(m_update_policy));
    }
    if (m_update_time_isSet) {
        obj.insert(QString("updateTime"), ::OpenAPI::toJsonValue(m_update_time));
    }
    if (m_writable_node.isSet()) {
        obj.insert(QString("writableNode"), ::OpenAPI::toJsonValue(m_writable_node));
    }
    return obj;
}

QMap<QString, QString> OAIInstance::getAnnotations() const {
    return m_annotations;
}
void OAIInstance::setAnnotations(const QMap<QString, QString> &annotations) {
    m_annotations = annotations;
    m_annotations_isSet = true;
}

bool OAIInstance::is_annotations_Set() const{
    return m_annotations_isSet;
}

bool OAIInstance::is_annotations_Valid() const{
    return m_annotations_isValid;
}

QString OAIInstance::getAvailabilityType() const {
    return m_availability_type;
}
void OAIInstance::setAvailabilityType(const QString &availability_type) {
    m_availability_type = availability_type;
    m_availability_type_isSet = true;
}

bool OAIInstance::is_availability_type_Set() const{
    return m_availability_type_isSet;
}

bool OAIInstance::is_availability_type_Valid() const{
    return m_availability_type_isValid;
}

OAIClientConnectionConfig OAIInstance::getClientConnectionConfig() const {
    return m_client_connection_config;
}
void OAIInstance::setClientConnectionConfig(const OAIClientConnectionConfig &client_connection_config) {
    m_client_connection_config = client_connection_config;
    m_client_connection_config_isSet = true;
}

bool OAIInstance::is_client_connection_config_Set() const{
    return m_client_connection_config_isSet;
}

bool OAIInstance::is_client_connection_config_Valid() const{
    return m_client_connection_config_isValid;
}

QString OAIInstance::getCreateTime() const {
    return m_create_time;
}
void OAIInstance::setCreateTime(const QString &create_time) {
    m_create_time = create_time;
    m_create_time_isSet = true;
}

bool OAIInstance::is_create_time_Set() const{
    return m_create_time_isSet;
}

bool OAIInstance::is_create_time_Valid() const{
    return m_create_time_isValid;
}

QMap<QString, QString> OAIInstance::getDatabaseFlags() const {
    return m_database_flags;
}
void OAIInstance::setDatabaseFlags(const QMap<QString, QString> &database_flags) {
    m_database_flags = database_flags;
    m_database_flags_isSet = true;
}

bool OAIInstance::is_database_flags_Set() const{
    return m_database_flags_isSet;
}

bool OAIInstance::is_database_flags_Valid() const{
    return m_database_flags_isValid;
}

QString OAIInstance::getDeleteTime() const {
    return m_delete_time;
}
void OAIInstance::setDeleteTime(const QString &delete_time) {
    m_delete_time = delete_time;
    m_delete_time_isSet = true;
}

bool OAIInstance::is_delete_time_Set() const{
    return m_delete_time_isSet;
}

bool OAIInstance::is_delete_time_Valid() const{
    return m_delete_time_isValid;
}

QString OAIInstance::getDisplayName() const {
    return m_display_name;
}
void OAIInstance::setDisplayName(const QString &display_name) {
    m_display_name = display_name;
    m_display_name_isSet = true;
}

bool OAIInstance::is_display_name_Set() const{
    return m_display_name_isSet;
}

bool OAIInstance::is_display_name_Valid() const{
    return m_display_name_isValid;
}

QString OAIInstance::getEtag() const {
    return m_etag;
}
void OAIInstance::setEtag(const QString &etag) {
    m_etag = etag;
    m_etag_isSet = true;
}

bool OAIInstance::is_etag_Set() const{
    return m_etag_isSet;
}

bool OAIInstance::is_etag_Valid() const{
    return m_etag_isValid;
}

QString OAIInstance::getGceZone() const {
    return m_gce_zone;
}
void OAIInstance::setGceZone(const QString &gce_zone) {
    m_gce_zone = gce_zone;
    m_gce_zone_isSet = true;
}

bool OAIInstance::is_gce_zone_Set() const{
    return m_gce_zone_isSet;
}

bool OAIInstance::is_gce_zone_Valid() const{
    return m_gce_zone_isValid;
}

QString OAIInstance::getInstanceType() const {
    return m_instance_type;
}
void OAIInstance::setInstanceType(const QString &instance_type) {
    m_instance_type = instance_type;
    m_instance_type_isSet = true;
}

bool OAIInstance::is_instance_type_Set() const{
    return m_instance_type_isSet;
}

bool OAIInstance::is_instance_type_Valid() const{
    return m_instance_type_isValid;
}

QString OAIInstance::getIpAddress() const {
    return m_ip_address;
}
void OAIInstance::setIpAddress(const QString &ip_address) {
    m_ip_address = ip_address;
    m_ip_address_isSet = true;
}

bool OAIInstance::is_ip_address_Set() const{
    return m_ip_address_isSet;
}

bool OAIInstance::is_ip_address_Valid() const{
    return m_ip_address_isValid;
}

QMap<QString, QString> OAIInstance::getLabels() const {
    return m_labels;
}
void OAIInstance::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAIInstance::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAIInstance::is_labels_Valid() const{
    return m_labels_isValid;
}

OAIMachineConfig OAIInstance::getMachineConfig() const {
    return m_machine_config;
}
void OAIInstance::setMachineConfig(const OAIMachineConfig &machine_config) {
    m_machine_config = machine_config;
    m_machine_config_isSet = true;
}

bool OAIInstance::is_machine_config_Set() const{
    return m_machine_config_isSet;
}

bool OAIInstance::is_machine_config_Valid() const{
    return m_machine_config_isValid;
}

QString OAIInstance::getName() const {
    return m_name;
}
void OAIInstance::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAIInstance::is_name_Set() const{
    return m_name_isSet;
}

bool OAIInstance::is_name_Valid() const{
    return m_name_isValid;
}

OAIInstanceNetworkConfig OAIInstance::getNetworkConfig() const {
    return m_network_config;
}
void OAIInstance::setNetworkConfig(const OAIInstanceNetworkConfig &network_config) {
    m_network_config = network_config;
    m_network_config_isSet = true;
}

bool OAIInstance::is_network_config_Set() const{
    return m_network_config_isSet;
}

bool OAIInstance::is_network_config_Valid() const{
    return m_network_config_isValid;
}

QList<OAINode> OAIInstance::getNodes() const {
    return m_nodes;
}
void OAIInstance::setNodes(const QList<OAINode> &nodes) {
    m_nodes = nodes;
    m_nodes_isSet = true;
}

bool OAIInstance::is_nodes_Set() const{
    return m_nodes_isSet;
}

bool OAIInstance::is_nodes_Valid() const{
    return m_nodes_isValid;
}

OAIPscInstanceConfig OAIInstance::getPscInstanceConfig() const {
    return m_psc_instance_config;
}
void OAIInstance::setPscInstanceConfig(const OAIPscInstanceConfig &psc_instance_config) {
    m_psc_instance_config = psc_instance_config;
    m_psc_instance_config_isSet = true;
}

bool OAIInstance::is_psc_instance_config_Set() const{
    return m_psc_instance_config_isSet;
}

bool OAIInstance::is_psc_instance_config_Valid() const{
    return m_psc_instance_config_isValid;
}

QString OAIInstance::getPublicIpAddress() const {
    return m_public_ip_address;
}
void OAIInstance::setPublicIpAddress(const QString &public_ip_address) {
    m_public_ip_address = public_ip_address;
    m_public_ip_address_isSet = true;
}

bool OAIInstance::is_public_ip_address_Set() const{
    return m_public_ip_address_isSet;
}

bool OAIInstance::is_public_ip_address_Valid() const{
    return m_public_ip_address_isValid;
}

OAIQueryInsightsInstanceConfig OAIInstance::getQueryInsightsConfig() const {
    return m_query_insights_config;
}
void OAIInstance::setQueryInsightsConfig(const OAIQueryInsightsInstanceConfig &query_insights_config) {
    m_query_insights_config = query_insights_config;
    m_query_insights_config_isSet = true;
}

bool OAIInstance::is_query_insights_config_Set() const{
    return m_query_insights_config_isSet;
}

bool OAIInstance::is_query_insights_config_Valid() const{
    return m_query_insights_config_isValid;
}

OAIReadPoolConfig OAIInstance::getReadPoolConfig() const {
    return m_read_pool_config;
}
void OAIInstance::setReadPoolConfig(const OAIReadPoolConfig &read_pool_config) {
    m_read_pool_config = read_pool_config;
    m_read_pool_config_isSet = true;
}

bool OAIInstance::is_read_pool_config_Set() const{
    return m_read_pool_config_isSet;
}

bool OAIInstance::is_read_pool_config_Valid() const{
    return m_read_pool_config_isValid;
}

bool OAIInstance::isReconciling() const {
    return m_reconciling;
}
void OAIInstance::setReconciling(const bool &reconciling) {
    m_reconciling = reconciling;
    m_reconciling_isSet = true;
}

bool OAIInstance::is_reconciling_Set() const{
    return m_reconciling_isSet;
}

bool OAIInstance::is_reconciling_Valid() const{
    return m_reconciling_isValid;
}

bool OAIInstance::isSatisfiesPzs() const {
    return m_satisfies_pzs;
}
void OAIInstance::setSatisfiesPzs(const bool &satisfies_pzs) {
    m_satisfies_pzs = satisfies_pzs;
    m_satisfies_pzs_isSet = true;
}

bool OAIInstance::is_satisfies_pzs_Set() const{
    return m_satisfies_pzs_isSet;
}

bool OAIInstance::is_satisfies_pzs_Valid() const{
    return m_satisfies_pzs_isValid;
}

QString OAIInstance::getState() const {
    return m_state;
}
void OAIInstance::setState(const QString &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAIInstance::is_state_Set() const{
    return m_state_isSet;
}

bool OAIInstance::is_state_Valid() const{
    return m_state_isValid;
}

QString OAIInstance::getUid() const {
    return m_uid;
}
void OAIInstance::setUid(const QString &uid) {
    m_uid = uid;
    m_uid_isSet = true;
}

bool OAIInstance::is_uid_Set() const{
    return m_uid_isSet;
}

bool OAIInstance::is_uid_Valid() const{
    return m_uid_isValid;
}

OAIUpdatePolicy OAIInstance::getUpdatePolicy() const {
    return m_update_policy;
}
void OAIInstance::setUpdatePolicy(const OAIUpdatePolicy &update_policy) {
    m_update_policy = update_policy;
    m_update_policy_isSet = true;
}

bool OAIInstance::is_update_policy_Set() const{
    return m_update_policy_isSet;
}

bool OAIInstance::is_update_policy_Valid() const{
    return m_update_policy_isValid;
}

QString OAIInstance::getUpdateTime() const {
    return m_update_time;
}
void OAIInstance::setUpdateTime(const QString &update_time) {
    m_update_time = update_time;
    m_update_time_isSet = true;
}

bool OAIInstance::is_update_time_Set() const{
    return m_update_time_isSet;
}

bool OAIInstance::is_update_time_Valid() const{
    return m_update_time_isValid;
}

OAINode OAIInstance::getWritableNode() const {
    return m_writable_node;
}
void OAIInstance::setWritableNode(const OAINode &writable_node) {
    m_writable_node = writable_node;
    m_writable_node_isSet = true;
}

bool OAIInstance::is_writable_node_Set() const{
    return m_writable_node_isSet;
}

bool OAIInstance::is_writable_node_Valid() const{
    return m_writable_node_isValid;
}

bool OAIInstance::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_annotations.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_availability_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_client_connection_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_create_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_database_flags.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_delete_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_etag_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gce_zone_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_instance_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ip_address_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_machine_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_nodes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_psc_instance_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_public_ip_address_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_query_insights_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_read_pool_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_reconciling_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_satisfies_pzs_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_uid_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_update_policy.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_update_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_writable_node.isSet()) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIInstance::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
