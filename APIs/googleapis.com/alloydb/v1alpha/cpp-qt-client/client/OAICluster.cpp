/**
 * AlloyDB API
 * AlloyDB for PostgreSQL is an open source-compatible database service that provides a powerful option for migrating, modernizing, or building commercial-grade applications. It offers full compatibility with standard PostgreSQL, and is more than 4x faster for transactional workloads and up to 100x faster for analytical queries than standard PostgreSQL in our performance tests. AlloyDB for PostgreSQL offers a 99.99 percent availability SLA inclusive of maintenance. AlloyDB is optimized for the most demanding use cases, allowing you to build new applications that require high transaction throughput, large database sizes, or multiple read resources; scale existing PostgreSQL workloads with no application changes; and modernize legacy proprietary databases. 
 *
 * The version of the OpenAPI document: v1alpha
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAICluster.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAICluster::OAICluster(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAICluster::OAICluster() {
    this->initializeModel();
}

OAICluster::~OAICluster() {}

void OAICluster::initializeModel() {

    m_annotations_isSet = false;
    m_annotations_isValid = false;

    m_automated_backup_policy_isSet = false;
    m_automated_backup_policy_isValid = false;

    m_backup_source_isSet = false;
    m_backup_source_isValid = false;

    m_cluster_type_isSet = false;
    m_cluster_type_isValid = false;

    m_continuous_backup_config_isSet = false;
    m_continuous_backup_config_isValid = false;

    m_continuous_backup_info_isSet = false;
    m_continuous_backup_info_isValid = false;

    m_create_time_isSet = false;
    m_create_time_isValid = false;

    m_database_version_isSet = false;
    m_database_version_isValid = false;

    m_delete_time_isSet = false;
    m_delete_time_isValid = false;

    m_display_name_isSet = false;
    m_display_name_isValid = false;

    m_encryption_config_isSet = false;
    m_encryption_config_isValid = false;

    m_encryption_info_isSet = false;
    m_encryption_info_isValid = false;

    m_etag_isSet = false;
    m_etag_isValid = false;

    m_initial_user_isSet = false;
    m_initial_user_isValid = false;

    m_labels_isSet = false;
    m_labels_isValid = false;

    m_migration_source_isSet = false;
    m_migration_source_isValid = false;

    m_name_isSet = false;
    m_name_isValid = false;

    m_network_isSet = false;
    m_network_isValid = false;

    m_network_config_isSet = false;
    m_network_config_isValid = false;

    m_primary_config_isSet = false;
    m_primary_config_isValid = false;

    m_psc_config_isSet = false;
    m_psc_config_isValid = false;

    m_reconciling_isSet = false;
    m_reconciling_isValid = false;

    m_satisfies_pzi_isSet = false;
    m_satisfies_pzi_isValid = false;

    m_satisfies_pzs_isSet = false;
    m_satisfies_pzs_isValid = false;

    m_secondary_config_isSet = false;
    m_secondary_config_isValid = false;

    m_ssl_config_isSet = false;
    m_ssl_config_isValid = false;

    m_state_isSet = false;
    m_state_isValid = false;

    m_uid_isSet = false;
    m_uid_isValid = false;

    m_update_time_isSet = false;
    m_update_time_isValid = false;
}

void OAICluster::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAICluster::fromJsonObject(QJsonObject json) {

    m_annotations_isValid = ::OpenAPI::fromJsonValue(m_annotations, json[QString("annotations")]);
    m_annotations_isSet = !json[QString("annotations")].isNull() && m_annotations_isValid;

    m_automated_backup_policy_isValid = ::OpenAPI::fromJsonValue(m_automated_backup_policy, json[QString("automatedBackupPolicy")]);
    m_automated_backup_policy_isSet = !json[QString("automatedBackupPolicy")].isNull() && m_automated_backup_policy_isValid;

    m_backup_source_isValid = ::OpenAPI::fromJsonValue(m_backup_source, json[QString("backupSource")]);
    m_backup_source_isSet = !json[QString("backupSource")].isNull() && m_backup_source_isValid;

    m_cluster_type_isValid = ::OpenAPI::fromJsonValue(m_cluster_type, json[QString("clusterType")]);
    m_cluster_type_isSet = !json[QString("clusterType")].isNull() && m_cluster_type_isValid;

    m_continuous_backup_config_isValid = ::OpenAPI::fromJsonValue(m_continuous_backup_config, json[QString("continuousBackupConfig")]);
    m_continuous_backup_config_isSet = !json[QString("continuousBackupConfig")].isNull() && m_continuous_backup_config_isValid;

    m_continuous_backup_info_isValid = ::OpenAPI::fromJsonValue(m_continuous_backup_info, json[QString("continuousBackupInfo")]);
    m_continuous_backup_info_isSet = !json[QString("continuousBackupInfo")].isNull() && m_continuous_backup_info_isValid;

    m_create_time_isValid = ::OpenAPI::fromJsonValue(m_create_time, json[QString("createTime")]);
    m_create_time_isSet = !json[QString("createTime")].isNull() && m_create_time_isValid;

    m_database_version_isValid = ::OpenAPI::fromJsonValue(m_database_version, json[QString("databaseVersion")]);
    m_database_version_isSet = !json[QString("databaseVersion")].isNull() && m_database_version_isValid;

    m_delete_time_isValid = ::OpenAPI::fromJsonValue(m_delete_time, json[QString("deleteTime")]);
    m_delete_time_isSet = !json[QString("deleteTime")].isNull() && m_delete_time_isValid;

    m_display_name_isValid = ::OpenAPI::fromJsonValue(m_display_name, json[QString("displayName")]);
    m_display_name_isSet = !json[QString("displayName")].isNull() && m_display_name_isValid;

    m_encryption_config_isValid = ::OpenAPI::fromJsonValue(m_encryption_config, json[QString("encryptionConfig")]);
    m_encryption_config_isSet = !json[QString("encryptionConfig")].isNull() && m_encryption_config_isValid;

    m_encryption_info_isValid = ::OpenAPI::fromJsonValue(m_encryption_info, json[QString("encryptionInfo")]);
    m_encryption_info_isSet = !json[QString("encryptionInfo")].isNull() && m_encryption_info_isValid;

    m_etag_isValid = ::OpenAPI::fromJsonValue(m_etag, json[QString("etag")]);
    m_etag_isSet = !json[QString("etag")].isNull() && m_etag_isValid;

    m_initial_user_isValid = ::OpenAPI::fromJsonValue(m_initial_user, json[QString("initialUser")]);
    m_initial_user_isSet = !json[QString("initialUser")].isNull() && m_initial_user_isValid;

    m_labels_isValid = ::OpenAPI::fromJsonValue(m_labels, json[QString("labels")]);
    m_labels_isSet = !json[QString("labels")].isNull() && m_labels_isValid;

    m_migration_source_isValid = ::OpenAPI::fromJsonValue(m_migration_source, json[QString("migrationSource")]);
    m_migration_source_isSet = !json[QString("migrationSource")].isNull() && m_migration_source_isValid;

    m_name_isValid = ::OpenAPI::fromJsonValue(m_name, json[QString("name")]);
    m_name_isSet = !json[QString("name")].isNull() && m_name_isValid;

    m_network_isValid = ::OpenAPI::fromJsonValue(m_network, json[QString("network")]);
    m_network_isSet = !json[QString("network")].isNull() && m_network_isValid;

    m_network_config_isValid = ::OpenAPI::fromJsonValue(m_network_config, json[QString("networkConfig")]);
    m_network_config_isSet = !json[QString("networkConfig")].isNull() && m_network_config_isValid;

    m_primary_config_isValid = ::OpenAPI::fromJsonValue(m_primary_config, json[QString("primaryConfig")]);
    m_primary_config_isSet = !json[QString("primaryConfig")].isNull() && m_primary_config_isValid;

    m_psc_config_isValid = ::OpenAPI::fromJsonValue(m_psc_config, json[QString("pscConfig")]);
    m_psc_config_isSet = !json[QString("pscConfig")].isNull() && m_psc_config_isValid;

    m_reconciling_isValid = ::OpenAPI::fromJsonValue(m_reconciling, json[QString("reconciling")]);
    m_reconciling_isSet = !json[QString("reconciling")].isNull() && m_reconciling_isValid;

    m_satisfies_pzi_isValid = ::OpenAPI::fromJsonValue(m_satisfies_pzi, json[QString("satisfiesPzi")]);
    m_satisfies_pzi_isSet = !json[QString("satisfiesPzi")].isNull() && m_satisfies_pzi_isValid;

    m_satisfies_pzs_isValid = ::OpenAPI::fromJsonValue(m_satisfies_pzs, json[QString("satisfiesPzs")]);
    m_satisfies_pzs_isSet = !json[QString("satisfiesPzs")].isNull() && m_satisfies_pzs_isValid;

    m_secondary_config_isValid = ::OpenAPI::fromJsonValue(m_secondary_config, json[QString("secondaryConfig")]);
    m_secondary_config_isSet = !json[QString("secondaryConfig")].isNull() && m_secondary_config_isValid;

    m_ssl_config_isValid = ::OpenAPI::fromJsonValue(m_ssl_config, json[QString("sslConfig")]);
    m_ssl_config_isSet = !json[QString("sslConfig")].isNull() && m_ssl_config_isValid;

    m_state_isValid = ::OpenAPI::fromJsonValue(m_state, json[QString("state")]);
    m_state_isSet = !json[QString("state")].isNull() && m_state_isValid;

    m_uid_isValid = ::OpenAPI::fromJsonValue(m_uid, json[QString("uid")]);
    m_uid_isSet = !json[QString("uid")].isNull() && m_uid_isValid;

    m_update_time_isValid = ::OpenAPI::fromJsonValue(m_update_time, json[QString("updateTime")]);
    m_update_time_isSet = !json[QString("updateTime")].isNull() && m_update_time_isValid;
}

QString OAICluster::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAICluster::asJsonObject() const {
    QJsonObject obj;
    if (m_annotations.size() > 0) {
        obj.insert(QString("annotations"), ::OpenAPI::toJsonValue(m_annotations));
    }
    if (m_automated_backup_policy.isSet()) {
        obj.insert(QString("automatedBackupPolicy"), ::OpenAPI::toJsonValue(m_automated_backup_policy));
    }
    if (m_backup_source.isSet()) {
        obj.insert(QString("backupSource"), ::OpenAPI::toJsonValue(m_backup_source));
    }
    if (m_cluster_type_isSet) {
        obj.insert(QString("clusterType"), ::OpenAPI::toJsonValue(m_cluster_type));
    }
    if (m_continuous_backup_config.isSet()) {
        obj.insert(QString("continuousBackupConfig"), ::OpenAPI::toJsonValue(m_continuous_backup_config));
    }
    if (m_continuous_backup_info.isSet()) {
        obj.insert(QString("continuousBackupInfo"), ::OpenAPI::toJsonValue(m_continuous_backup_info));
    }
    if (m_create_time_isSet) {
        obj.insert(QString("createTime"), ::OpenAPI::toJsonValue(m_create_time));
    }
    if (m_database_version_isSet) {
        obj.insert(QString("databaseVersion"), ::OpenAPI::toJsonValue(m_database_version));
    }
    if (m_delete_time_isSet) {
        obj.insert(QString("deleteTime"), ::OpenAPI::toJsonValue(m_delete_time));
    }
    if (m_display_name_isSet) {
        obj.insert(QString("displayName"), ::OpenAPI::toJsonValue(m_display_name));
    }
    if (m_encryption_config.isSet()) {
        obj.insert(QString("encryptionConfig"), ::OpenAPI::toJsonValue(m_encryption_config));
    }
    if (m_encryption_info.isSet()) {
        obj.insert(QString("encryptionInfo"), ::OpenAPI::toJsonValue(m_encryption_info));
    }
    if (m_etag_isSet) {
        obj.insert(QString("etag"), ::OpenAPI::toJsonValue(m_etag));
    }
    if (m_initial_user.isSet()) {
        obj.insert(QString("initialUser"), ::OpenAPI::toJsonValue(m_initial_user));
    }
    if (m_labels.size() > 0) {
        obj.insert(QString("labels"), ::OpenAPI::toJsonValue(m_labels));
    }
    if (m_migration_source.isSet()) {
        obj.insert(QString("migrationSource"), ::OpenAPI::toJsonValue(m_migration_source));
    }
    if (m_name_isSet) {
        obj.insert(QString("name"), ::OpenAPI::toJsonValue(m_name));
    }
    if (m_network_isSet) {
        obj.insert(QString("network"), ::OpenAPI::toJsonValue(m_network));
    }
    if (m_network_config.isSet()) {
        obj.insert(QString("networkConfig"), ::OpenAPI::toJsonValue(m_network_config));
    }
    if (m_primary_config.isSet()) {
        obj.insert(QString("primaryConfig"), ::OpenAPI::toJsonValue(m_primary_config));
    }
    if (m_psc_config.isSet()) {
        obj.insert(QString("pscConfig"), ::OpenAPI::toJsonValue(m_psc_config));
    }
    if (m_reconciling_isSet) {
        obj.insert(QString("reconciling"), ::OpenAPI::toJsonValue(m_reconciling));
    }
    if (m_satisfies_pzi_isSet) {
        obj.insert(QString("satisfiesPzi"), ::OpenAPI::toJsonValue(m_satisfies_pzi));
    }
    if (m_satisfies_pzs_isSet) {
        obj.insert(QString("satisfiesPzs"), ::OpenAPI::toJsonValue(m_satisfies_pzs));
    }
    if (m_secondary_config.isSet()) {
        obj.insert(QString("secondaryConfig"), ::OpenAPI::toJsonValue(m_secondary_config));
    }
    if (m_ssl_config.isSet()) {
        obj.insert(QString("sslConfig"), ::OpenAPI::toJsonValue(m_ssl_config));
    }
    if (m_state_isSet) {
        obj.insert(QString("state"), ::OpenAPI::toJsonValue(m_state));
    }
    if (m_uid_isSet) {
        obj.insert(QString("uid"), ::OpenAPI::toJsonValue(m_uid));
    }
    if (m_update_time_isSet) {
        obj.insert(QString("updateTime"), ::OpenAPI::toJsonValue(m_update_time));
    }
    return obj;
}

QMap<QString, QString> OAICluster::getAnnotations() const {
    return m_annotations;
}
void OAICluster::setAnnotations(const QMap<QString, QString> &annotations) {
    m_annotations = annotations;
    m_annotations_isSet = true;
}

bool OAICluster::is_annotations_Set() const{
    return m_annotations_isSet;
}

bool OAICluster::is_annotations_Valid() const{
    return m_annotations_isValid;
}

OAIAutomatedBackupPolicy OAICluster::getAutomatedBackupPolicy() const {
    return m_automated_backup_policy;
}
void OAICluster::setAutomatedBackupPolicy(const OAIAutomatedBackupPolicy &automated_backup_policy) {
    m_automated_backup_policy = automated_backup_policy;
    m_automated_backup_policy_isSet = true;
}

bool OAICluster::is_automated_backup_policy_Set() const{
    return m_automated_backup_policy_isSet;
}

bool OAICluster::is_automated_backup_policy_Valid() const{
    return m_automated_backup_policy_isValid;
}

OAIBackupSource OAICluster::getBackupSource() const {
    return m_backup_source;
}
void OAICluster::setBackupSource(const OAIBackupSource &backup_source) {
    m_backup_source = backup_source;
    m_backup_source_isSet = true;
}

bool OAICluster::is_backup_source_Set() const{
    return m_backup_source_isSet;
}

bool OAICluster::is_backup_source_Valid() const{
    return m_backup_source_isValid;
}

QString OAICluster::getClusterType() const {
    return m_cluster_type;
}
void OAICluster::setClusterType(const QString &cluster_type) {
    m_cluster_type = cluster_type;
    m_cluster_type_isSet = true;
}

bool OAICluster::is_cluster_type_Set() const{
    return m_cluster_type_isSet;
}

bool OAICluster::is_cluster_type_Valid() const{
    return m_cluster_type_isValid;
}

OAIContinuousBackupConfig OAICluster::getContinuousBackupConfig() const {
    return m_continuous_backup_config;
}
void OAICluster::setContinuousBackupConfig(const OAIContinuousBackupConfig &continuous_backup_config) {
    m_continuous_backup_config = continuous_backup_config;
    m_continuous_backup_config_isSet = true;
}

bool OAICluster::is_continuous_backup_config_Set() const{
    return m_continuous_backup_config_isSet;
}

bool OAICluster::is_continuous_backup_config_Valid() const{
    return m_continuous_backup_config_isValid;
}

OAIContinuousBackupInfo OAICluster::getContinuousBackupInfo() const {
    return m_continuous_backup_info;
}
void OAICluster::setContinuousBackupInfo(const OAIContinuousBackupInfo &continuous_backup_info) {
    m_continuous_backup_info = continuous_backup_info;
    m_continuous_backup_info_isSet = true;
}

bool OAICluster::is_continuous_backup_info_Set() const{
    return m_continuous_backup_info_isSet;
}

bool OAICluster::is_continuous_backup_info_Valid() const{
    return m_continuous_backup_info_isValid;
}

QString OAICluster::getCreateTime() const {
    return m_create_time;
}
void OAICluster::setCreateTime(const QString &create_time) {
    m_create_time = create_time;
    m_create_time_isSet = true;
}

bool OAICluster::is_create_time_Set() const{
    return m_create_time_isSet;
}

bool OAICluster::is_create_time_Valid() const{
    return m_create_time_isValid;
}

QString OAICluster::getDatabaseVersion() const {
    return m_database_version;
}
void OAICluster::setDatabaseVersion(const QString &database_version) {
    m_database_version = database_version;
    m_database_version_isSet = true;
}

bool OAICluster::is_database_version_Set() const{
    return m_database_version_isSet;
}

bool OAICluster::is_database_version_Valid() const{
    return m_database_version_isValid;
}

QString OAICluster::getDeleteTime() const {
    return m_delete_time;
}
void OAICluster::setDeleteTime(const QString &delete_time) {
    m_delete_time = delete_time;
    m_delete_time_isSet = true;
}

bool OAICluster::is_delete_time_Set() const{
    return m_delete_time_isSet;
}

bool OAICluster::is_delete_time_Valid() const{
    return m_delete_time_isValid;
}

QString OAICluster::getDisplayName() const {
    return m_display_name;
}
void OAICluster::setDisplayName(const QString &display_name) {
    m_display_name = display_name;
    m_display_name_isSet = true;
}

bool OAICluster::is_display_name_Set() const{
    return m_display_name_isSet;
}

bool OAICluster::is_display_name_Valid() const{
    return m_display_name_isValid;
}

OAIEncryptionConfig OAICluster::getEncryptionConfig() const {
    return m_encryption_config;
}
void OAICluster::setEncryptionConfig(const OAIEncryptionConfig &encryption_config) {
    m_encryption_config = encryption_config;
    m_encryption_config_isSet = true;
}

bool OAICluster::is_encryption_config_Set() const{
    return m_encryption_config_isSet;
}

bool OAICluster::is_encryption_config_Valid() const{
    return m_encryption_config_isValid;
}

OAIEncryptionInfo OAICluster::getEncryptionInfo() const {
    return m_encryption_info;
}
void OAICluster::setEncryptionInfo(const OAIEncryptionInfo &encryption_info) {
    m_encryption_info = encryption_info;
    m_encryption_info_isSet = true;
}

bool OAICluster::is_encryption_info_Set() const{
    return m_encryption_info_isSet;
}

bool OAICluster::is_encryption_info_Valid() const{
    return m_encryption_info_isValid;
}

QString OAICluster::getEtag() const {
    return m_etag;
}
void OAICluster::setEtag(const QString &etag) {
    m_etag = etag;
    m_etag_isSet = true;
}

bool OAICluster::is_etag_Set() const{
    return m_etag_isSet;
}

bool OAICluster::is_etag_Valid() const{
    return m_etag_isValid;
}

OAIUserPassword OAICluster::getInitialUser() const {
    return m_initial_user;
}
void OAICluster::setInitialUser(const OAIUserPassword &initial_user) {
    m_initial_user = initial_user;
    m_initial_user_isSet = true;
}

bool OAICluster::is_initial_user_Set() const{
    return m_initial_user_isSet;
}

bool OAICluster::is_initial_user_Valid() const{
    return m_initial_user_isValid;
}

QMap<QString, QString> OAICluster::getLabels() const {
    return m_labels;
}
void OAICluster::setLabels(const QMap<QString, QString> &labels) {
    m_labels = labels;
    m_labels_isSet = true;
}

bool OAICluster::is_labels_Set() const{
    return m_labels_isSet;
}

bool OAICluster::is_labels_Valid() const{
    return m_labels_isValid;
}

OAIMigrationSource OAICluster::getMigrationSource() const {
    return m_migration_source;
}
void OAICluster::setMigrationSource(const OAIMigrationSource &migration_source) {
    m_migration_source = migration_source;
    m_migration_source_isSet = true;
}

bool OAICluster::is_migration_source_Set() const{
    return m_migration_source_isSet;
}

bool OAICluster::is_migration_source_Valid() const{
    return m_migration_source_isValid;
}

QString OAICluster::getName() const {
    return m_name;
}
void OAICluster::setName(const QString &name) {
    m_name = name;
    m_name_isSet = true;
}

bool OAICluster::is_name_Set() const{
    return m_name_isSet;
}

bool OAICluster::is_name_Valid() const{
    return m_name_isValid;
}

QString OAICluster::getNetwork() const {
    return m_network;
}
void OAICluster::setNetwork(const QString &network) {
    m_network = network;
    m_network_isSet = true;
}

bool OAICluster::is_network_Set() const{
    return m_network_isSet;
}

bool OAICluster::is_network_Valid() const{
    return m_network_isValid;
}

OAINetworkConfig OAICluster::getNetworkConfig() const {
    return m_network_config;
}
void OAICluster::setNetworkConfig(const OAINetworkConfig &network_config) {
    m_network_config = network_config;
    m_network_config_isSet = true;
}

bool OAICluster::is_network_config_Set() const{
    return m_network_config_isSet;
}

bool OAICluster::is_network_config_Valid() const{
    return m_network_config_isValid;
}

OAIPrimaryConfig OAICluster::getPrimaryConfig() const {
    return m_primary_config;
}
void OAICluster::setPrimaryConfig(const OAIPrimaryConfig &primary_config) {
    m_primary_config = primary_config;
    m_primary_config_isSet = true;
}

bool OAICluster::is_primary_config_Set() const{
    return m_primary_config_isSet;
}

bool OAICluster::is_primary_config_Valid() const{
    return m_primary_config_isValid;
}

OAIPscConfig OAICluster::getPscConfig() const {
    return m_psc_config;
}
void OAICluster::setPscConfig(const OAIPscConfig &psc_config) {
    m_psc_config = psc_config;
    m_psc_config_isSet = true;
}

bool OAICluster::is_psc_config_Set() const{
    return m_psc_config_isSet;
}

bool OAICluster::is_psc_config_Valid() const{
    return m_psc_config_isValid;
}

bool OAICluster::isReconciling() const {
    return m_reconciling;
}
void OAICluster::setReconciling(const bool &reconciling) {
    m_reconciling = reconciling;
    m_reconciling_isSet = true;
}

bool OAICluster::is_reconciling_Set() const{
    return m_reconciling_isSet;
}

bool OAICluster::is_reconciling_Valid() const{
    return m_reconciling_isValid;
}

bool OAICluster::isSatisfiesPzi() const {
    return m_satisfies_pzi;
}
void OAICluster::setSatisfiesPzi(const bool &satisfies_pzi) {
    m_satisfies_pzi = satisfies_pzi;
    m_satisfies_pzi_isSet = true;
}

bool OAICluster::is_satisfies_pzi_Set() const{
    return m_satisfies_pzi_isSet;
}

bool OAICluster::is_satisfies_pzi_Valid() const{
    return m_satisfies_pzi_isValid;
}

bool OAICluster::isSatisfiesPzs() const {
    return m_satisfies_pzs;
}
void OAICluster::setSatisfiesPzs(const bool &satisfies_pzs) {
    m_satisfies_pzs = satisfies_pzs;
    m_satisfies_pzs_isSet = true;
}

bool OAICluster::is_satisfies_pzs_Set() const{
    return m_satisfies_pzs_isSet;
}

bool OAICluster::is_satisfies_pzs_Valid() const{
    return m_satisfies_pzs_isValid;
}

OAISecondaryConfig OAICluster::getSecondaryConfig() const {
    return m_secondary_config;
}
void OAICluster::setSecondaryConfig(const OAISecondaryConfig &secondary_config) {
    m_secondary_config = secondary_config;
    m_secondary_config_isSet = true;
}

bool OAICluster::is_secondary_config_Set() const{
    return m_secondary_config_isSet;
}

bool OAICluster::is_secondary_config_Valid() const{
    return m_secondary_config_isValid;
}

OAISslConfig OAICluster::getSslConfig() const {
    return m_ssl_config;
}
void OAICluster::setSslConfig(const OAISslConfig &ssl_config) {
    m_ssl_config = ssl_config;
    m_ssl_config_isSet = true;
}

bool OAICluster::is_ssl_config_Set() const{
    return m_ssl_config_isSet;
}

bool OAICluster::is_ssl_config_Valid() const{
    return m_ssl_config_isValid;
}

QString OAICluster::getState() const {
    return m_state;
}
void OAICluster::setState(const QString &state) {
    m_state = state;
    m_state_isSet = true;
}

bool OAICluster::is_state_Set() const{
    return m_state_isSet;
}

bool OAICluster::is_state_Valid() const{
    return m_state_isValid;
}

QString OAICluster::getUid() const {
    return m_uid;
}
void OAICluster::setUid(const QString &uid) {
    m_uid = uid;
    m_uid_isSet = true;
}

bool OAICluster::is_uid_Set() const{
    return m_uid_isSet;
}

bool OAICluster::is_uid_Valid() const{
    return m_uid_isValid;
}

QString OAICluster::getUpdateTime() const {
    return m_update_time;
}
void OAICluster::setUpdateTime(const QString &update_time) {
    m_update_time = update_time;
    m_update_time_isSet = true;
}

bool OAICluster::is_update_time_Set() const{
    return m_update_time_isSet;
}

bool OAICluster::is_update_time_Valid() const{
    return m_update_time_isValid;
}

bool OAICluster::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_annotations.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_automated_backup_policy.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_backup_source.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_cluster_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_continuous_backup_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_continuous_backup_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_create_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_database_version_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_delete_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_display_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_encryption_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_encryption_info.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_etag_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_initial_user.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_labels.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_migration_source.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_name_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_network_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_primary_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_psc_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_reconciling_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_satisfies_pzi_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_satisfies_pzs_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_secondary_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_ssl_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_uid_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_update_time_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAICluster::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
