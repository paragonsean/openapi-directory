/*
 * AlloyDB API
 * AlloyDB for PostgreSQL is an open source-compatible database service that provides a powerful option for migrating, modernizing, or building commercial-grade applications. It offers full compatibility with standard PostgreSQL, and is more than 4x faster for transactional workloads and up to 100x faster for analytical queries than standard PostgreSQL in our performance tests. AlloyDB for PostgreSQL offers a 99.99 percent availability SLA inclusive of maintenance. AlloyDB is optimized for the most demanding use cases, allowing you to build new applications that require high transaction throughput, large database sizes, or multiple read resources; scale existing PostgreSQL workloads with no application changes; and modernize legacy proprietary databases. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.EncryptionConfig;
import org.openapitools.client.model.QuantityBasedRetention;
import org.openapitools.client.model.TimeBasedRetention;
import org.openapitools.client.model.WeeklySchedule;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Message describing the user-specified automated backup policy. All fields in the automated backup policy are optional. Defaults for each field are provided if they are not set.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:04.527212-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AutomatedBackupPolicy {
  public static final String SERIALIZED_NAME_BACKUP_WINDOW = "backupWindow";
  @SerializedName(SERIALIZED_NAME_BACKUP_WINDOW)
  private String backupWindow;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_ENCRYPTION_CONFIG = "encryptionConfig";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_CONFIG)
  private EncryptionConfig encryptionConfig;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LOCATION = "location";
  @SerializedName(SERIALIZED_NAME_LOCATION)
  private String location;

  public static final String SERIALIZED_NAME_QUANTITY_BASED_RETENTION = "quantityBasedRetention";
  @SerializedName(SERIALIZED_NAME_QUANTITY_BASED_RETENTION)
  private QuantityBasedRetention quantityBasedRetention;

  public static final String SERIALIZED_NAME_TIME_BASED_RETENTION = "timeBasedRetention";
  @SerializedName(SERIALIZED_NAME_TIME_BASED_RETENTION)
  private TimeBasedRetention timeBasedRetention;

  public static final String SERIALIZED_NAME_WEEKLY_SCHEDULE = "weeklySchedule";
  @SerializedName(SERIALIZED_NAME_WEEKLY_SCHEDULE)
  private WeeklySchedule weeklySchedule;

  public AutomatedBackupPolicy() {
  }

  public AutomatedBackupPolicy backupWindow(String backupWindow) {
    this.backupWindow = backupWindow;
    return this;
  }

  /**
   * The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed. The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it defaults to 1 hour.
   * @return backupWindow
   */
  @javax.annotation.Nullable
  public String getBackupWindow() {
    return backupWindow;
  }

  public void setBackupWindow(String backupWindow) {
    this.backupWindow = backupWindow;
  }


  public AutomatedBackupPolicy enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * Whether automated automated backups are enabled. If not set, defaults to true.
   * @return enabled
   */
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public AutomatedBackupPolicy encryptionConfig(EncryptionConfig encryptionConfig) {
    this.encryptionConfig = encryptionConfig;
    return this;
  }

  /**
   * Get encryptionConfig
   * @return encryptionConfig
   */
  @javax.annotation.Nullable
  public EncryptionConfig getEncryptionConfig() {
    return encryptionConfig;
  }

  public void setEncryptionConfig(EncryptionConfig encryptionConfig) {
    this.encryptionConfig = encryptionConfig;
  }


  public AutomatedBackupPolicy labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public AutomatedBackupPolicy putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels to apply to backups created using this configuration.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public AutomatedBackupPolicy location(String location) {
    this.location = location;
    return this;
  }

  /**
   * The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster. If empty, defaults to the region of the cluster.
   * @return location
   */
  @javax.annotation.Nullable
  public String getLocation() {
    return location;
  }

  public void setLocation(String location) {
    this.location = location;
  }


  public AutomatedBackupPolicy quantityBasedRetention(QuantityBasedRetention quantityBasedRetention) {
    this.quantityBasedRetention = quantityBasedRetention;
    return this;
  }

  /**
   * Get quantityBasedRetention
   * @return quantityBasedRetention
   */
  @javax.annotation.Nullable
  public QuantityBasedRetention getQuantityBasedRetention() {
    return quantityBasedRetention;
  }

  public void setQuantityBasedRetention(QuantityBasedRetention quantityBasedRetention) {
    this.quantityBasedRetention = quantityBasedRetention;
  }


  public AutomatedBackupPolicy timeBasedRetention(TimeBasedRetention timeBasedRetention) {
    this.timeBasedRetention = timeBasedRetention;
    return this;
  }

  /**
   * Get timeBasedRetention
   * @return timeBasedRetention
   */
  @javax.annotation.Nullable
  public TimeBasedRetention getTimeBasedRetention() {
    return timeBasedRetention;
  }

  public void setTimeBasedRetention(TimeBasedRetention timeBasedRetention) {
    this.timeBasedRetention = timeBasedRetention;
  }


  public AutomatedBackupPolicy weeklySchedule(WeeklySchedule weeklySchedule) {
    this.weeklySchedule = weeklySchedule;
    return this;
  }

  /**
   * Get weeklySchedule
   * @return weeklySchedule
   */
  @javax.annotation.Nullable
  public WeeklySchedule getWeeklySchedule() {
    return weeklySchedule;
  }

  public void setWeeklySchedule(WeeklySchedule weeklySchedule) {
    this.weeklySchedule = weeklySchedule;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AutomatedBackupPolicy automatedBackupPolicy = (AutomatedBackupPolicy) o;
    return Objects.equals(this.backupWindow, automatedBackupPolicy.backupWindow) &&
        Objects.equals(this.enabled, automatedBackupPolicy.enabled) &&
        Objects.equals(this.encryptionConfig, automatedBackupPolicy.encryptionConfig) &&
        Objects.equals(this.labels, automatedBackupPolicy.labels) &&
        Objects.equals(this.location, automatedBackupPolicy.location) &&
        Objects.equals(this.quantityBasedRetention, automatedBackupPolicy.quantityBasedRetention) &&
        Objects.equals(this.timeBasedRetention, automatedBackupPolicy.timeBasedRetention) &&
        Objects.equals(this.weeklySchedule, automatedBackupPolicy.weeklySchedule);
  }

  @Override
  public int hashCode() {
    return Objects.hash(backupWindow, enabled, encryptionConfig, labels, location, quantityBasedRetention, timeBasedRetention, weeklySchedule);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AutomatedBackupPolicy {\n");
    sb.append("    backupWindow: ").append(toIndentedString(backupWindow)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    encryptionConfig: ").append(toIndentedString(encryptionConfig)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    quantityBasedRetention: ").append(toIndentedString(quantityBasedRetention)).append("\n");
    sb.append("    timeBasedRetention: ").append(toIndentedString(timeBasedRetention)).append("\n");
    sb.append("    weeklySchedule: ").append(toIndentedString(weeklySchedule)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("backupWindow");
    openapiFields.add("enabled");
    openapiFields.add("encryptionConfig");
    openapiFields.add("labels");
    openapiFields.add("location");
    openapiFields.add("quantityBasedRetention");
    openapiFields.add("timeBasedRetention");
    openapiFields.add("weeklySchedule");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AutomatedBackupPolicy
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AutomatedBackupPolicy.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AutomatedBackupPolicy is not found in the empty JSON string", AutomatedBackupPolicy.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AutomatedBackupPolicy.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AutomatedBackupPolicy` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("backupWindow") != null && !jsonObj.get("backupWindow").isJsonNull()) && !jsonObj.get("backupWindow").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `backupWindow` to be a primitive type in the JSON string but got `%s`", jsonObj.get("backupWindow").toString()));
      }
      // validate the optional field `encryptionConfig`
      if (jsonObj.get("encryptionConfig") != null && !jsonObj.get("encryptionConfig").isJsonNull()) {
        EncryptionConfig.validateJsonElement(jsonObj.get("encryptionConfig"));
      }
      if ((jsonObj.get("location") != null && !jsonObj.get("location").isJsonNull()) && !jsonObj.get("location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("location").toString()));
      }
      // validate the optional field `quantityBasedRetention`
      if (jsonObj.get("quantityBasedRetention") != null && !jsonObj.get("quantityBasedRetention").isJsonNull()) {
        QuantityBasedRetention.validateJsonElement(jsonObj.get("quantityBasedRetention"));
      }
      // validate the optional field `timeBasedRetention`
      if (jsonObj.get("timeBasedRetention") != null && !jsonObj.get("timeBasedRetention").isJsonNull()) {
        TimeBasedRetention.validateJsonElement(jsonObj.get("timeBasedRetention"));
      }
      // validate the optional field `weeklySchedule`
      if (jsonObj.get("weeklySchedule") != null && !jsonObj.get("weeklySchedule").isJsonNull()) {
        WeeklySchedule.validateJsonElement(jsonObj.get("weeklySchedule"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AutomatedBackupPolicy.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AutomatedBackupPolicy' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AutomatedBackupPolicy> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AutomatedBackupPolicy.class));

       return (TypeAdapter<T>) new TypeAdapter<AutomatedBackupPolicy>() {
           @Override
           public void write(JsonWriter out, AutomatedBackupPolicy value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AutomatedBackupPolicy read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AutomatedBackupPolicy given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AutomatedBackupPolicy
   * @throws IOException if the JSON string is invalid with respect to AutomatedBackupPolicy
   */
  public static AutomatedBackupPolicy fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AutomatedBackupPolicy.class);
  }

  /**
   * Convert an instance of AutomatedBackupPolicy to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

