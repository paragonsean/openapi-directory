/*
 * Cloud Logging API
 * Writes log entries and manages your Cloud Logging configuration.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BigQueryOptions;
import org.openapitools.client.model.LogExclusion;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes a sink used to export log entries to one of the following destinations: a Cloud Logging log bucket, a Cloud Storage bucket, a BigQuery dataset, a Pub/Sub topic, a Cloud project.A logs filter controls which log entries are exported. The sink must be created within a project, organization, billing account, or folder.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:26.064361-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LogSink {
  public static final String SERIALIZED_NAME_BIGQUERY_OPTIONS = "bigqueryOptions";
  @SerializedName(SERIALIZED_NAME_BIGQUERY_OPTIONS)
  private BigQueryOptions bigqueryOptions;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DESTINATION = "destination";
  @SerializedName(SERIALIZED_NAME_DESTINATION)
  private String destination;

  public static final String SERIALIZED_NAME_DISABLED = "disabled";
  @SerializedName(SERIALIZED_NAME_DISABLED)
  private Boolean disabled;

  public static final String SERIALIZED_NAME_EXCLUSIONS = "exclusions";
  @SerializedName(SERIALIZED_NAME_EXCLUSIONS)
  private List<LogExclusion> exclusions = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILTER = "filter";
  @SerializedName(SERIALIZED_NAME_FILTER)
  private String filter;

  public static final String SERIALIZED_NAME_INCLUDE_CHILDREN = "includeChildren";
  @SerializedName(SERIALIZED_NAME_INCLUDE_CHILDREN)
  private Boolean includeChildren;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  /**
   * Deprecated. This field is unused.
   */
  @JsonAdapter(OutputVersionFormatEnum.Adapter.class)
  public enum OutputVersionFormatEnum {
    VERSION_FORMAT_UNSPECIFIED("VERSION_FORMAT_UNSPECIFIED"),
    
    V2("V2"),
    
    V1("V1");

    private String value;

    OutputVersionFormatEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OutputVersionFormatEnum fromValue(String value) {
      for (OutputVersionFormatEnum b : OutputVersionFormatEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OutputVersionFormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OutputVersionFormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OutputVersionFormatEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OutputVersionFormatEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OutputVersionFormatEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OUTPUT_VERSION_FORMAT = "outputVersionFormat";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_OUTPUT_VERSION_FORMAT)
  private OutputVersionFormatEnum outputVersionFormat;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public static final String SERIALIZED_NAME_WRITER_IDENTITY = "writerIdentity";
  @SerializedName(SERIALIZED_NAME_WRITER_IDENTITY)
  private String writerIdentity;

  public LogSink() {
  }

  public LogSink(
     String createTime, 
     String name, 
     String updateTime, 
     String writerIdentity
  ) {
    this();
    this.createTime = createTime;
    this.name = name;
    this.updateTime = updateTime;
    this.writerIdentity = writerIdentity;
  }

  public LogSink bigqueryOptions(BigQueryOptions bigqueryOptions) {
    this.bigqueryOptions = bigqueryOptions;
    return this;
  }

  /**
   * Get bigqueryOptions
   * @return bigqueryOptions
   */
  @javax.annotation.Nullable
  public BigQueryOptions getBigqueryOptions() {
    return bigqueryOptions;
  }

  public void setBigqueryOptions(BigQueryOptions bigqueryOptions) {
    this.bigqueryOptions = bigqueryOptions;
  }


  /**
   * Output only. The creation timestamp of the sink.This field may not be present for older sinks.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  public LogSink description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Optional. A description of this sink.The maximum length of the description is 8000 characters.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public LogSink destination(String destination) {
    this.destination = destination;
    return this;
  }

  /**
   * Required. The export destination: \&quot;storage.googleapis.com/[GCS_BUCKET]\&quot; \&quot;bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET]\&quot; \&quot;pubsub.googleapis.com/projects/[PROJECT_ID]/topics/[TOPIC_ID]\&quot; \&quot;logging.googleapis.com/projects/[PROJECT_ID]\&quot; \&quot;logging.googleapis.com/projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]\&quot; The sink&#39;s writer_identity, set when the sink is created, must have permission to write to the destination or else the log entries are not exported. For more information, see Exporting Logs with Sinks (https://cloud.google.com/logging/docs/api/tasks/exporting-logs).
   * @return destination
   */
  @javax.annotation.Nullable
  public String getDestination() {
    return destination;
  }

  public void setDestination(String destination) {
    this.destination = destination;
  }


  public LogSink disabled(Boolean disabled) {
    this.disabled = disabled;
    return this;
  }

  /**
   * Optional. If set to true, then this sink is disabled and it does not export any log entries.
   * @return disabled
   */
  @javax.annotation.Nullable
  public Boolean getDisabled() {
    return disabled;
  }

  public void setDisabled(Boolean disabled) {
    this.disabled = disabled;
  }


  public LogSink exclusions(List<LogExclusion> exclusions) {
    this.exclusions = exclusions;
    return this;
  }

  public LogSink addExclusionsItem(LogExclusion exclusionsItem) {
    if (this.exclusions == null) {
      this.exclusions = new ArrayList<>();
    }
    this.exclusions.add(exclusionsItem);
    return this;
  }

  /**
   * Optional. Log entries that match any of these exclusion filters will not be exported.If a log entry is matched by both filter and one of exclusion_filters it will not be exported.
   * @return exclusions
   */
  @javax.annotation.Nullable
  public List<LogExclusion> getExclusions() {
    return exclusions;
  }

  public void setExclusions(List<LogExclusion> exclusions) {
    this.exclusions = exclusions;
  }


  public LogSink filter(String filter) {
    this.filter = filter;
    return this;
  }

  /**
   * Optional. An advanced logs filter (https://cloud.google.com/logging/docs/view/advanced-queries). The only exported log entries are those that are in the resource owning the sink and that match the filter.For example:logName&#x3D;\&quot;projects/[PROJECT_ID]/logs/[LOG_ID]\&quot; AND severity&gt;&#x3D;ERROR
   * @return filter
   */
  @javax.annotation.Nullable
  public String getFilter() {
    return filter;
  }

  public void setFilter(String filter) {
    this.filter = filter;
  }


  public LogSink includeChildren(Boolean includeChildren) {
    this.includeChildren = includeChildren;
    return this;
  }

  /**
   * Optional. This field applies only to sinks owned by organizations and folders. If the field is false, the default, only the logs owned by the sink&#39;s parent resource are available for export. If the field is true, then log entries from all the projects, folders, and billing accounts contained in the sink&#39;s parent resource are also available for export. Whether a particular log entry from the children is exported depends on the sink&#39;s filter expression.For example, if this field is true, then the filter resource.type&#x3D;gce_instance would export all Compute Engine VM instance log entries from all projects in the sink&#39;s parent.To only export entries from certain child projects, filter on the project part of the log name:logName:(\&quot;projects/test-project1/\&quot; OR \&quot;projects/test-project2/\&quot;) AND resource.type&#x3D;gce_instance
   * @return includeChildren
   */
  @javax.annotation.Nullable
  public Boolean getIncludeChildren() {
    return includeChildren;
  }

  public void setIncludeChildren(Boolean includeChildren) {
    this.includeChildren = includeChildren;
  }


  /**
   * Output only. The client-assigned sink identifier, unique within the project.For example: \&quot;my-syslog-errors-to-pubsub\&quot;.Sink identifiers are limited to 100 characters and can include only the following characters: upper and lower-case alphanumeric characters, underscores, hyphens, periods.First character has to be alphanumeric.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  @Deprecated
  public LogSink outputVersionFormat(OutputVersionFormatEnum outputVersionFormat) {
    this.outputVersionFormat = outputVersionFormat;
    return this;
  }

  /**
   * Deprecated. This field is unused.
   * @return outputVersionFormat
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public OutputVersionFormatEnum getOutputVersionFormat() {
    return outputVersionFormat;
  }

  @Deprecated
  public void setOutputVersionFormat(OutputVersionFormatEnum outputVersionFormat) {
    this.outputVersionFormat = outputVersionFormat;
  }


  /**
   * Output only. The last update timestamp of the sink.This field may not be present for older sinks.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }



  /**
   * Output only. An IAM identity—a service account or group—under which Cloud Logging writes the exported log entries to the sink&#39;s destination. This field is either set by specifying custom_writer_identity or set automatically by sinks.create and sinks.update based on the value of unique_writer_identity in those methods.Until you grant this identity write-access to the destination, log entry exports from this sink will fail. For more information, see Granting Access for a Resource (https://cloud.google.com/iam/docs/granting-roles-to-service-accounts#granting_access_to_a_service_account_for_a_resource). Consult the destination service&#39;s documentation to determine the appropriate IAM roles to assign to the identity.Sinks that have a destination that is a log bucket in the same project as the sink cannot have a writer_identity and no additional permissions are required.
   * @return writerIdentity
   */
  @javax.annotation.Nullable
  public String getWriterIdentity() {
    return writerIdentity;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LogSink logSink = (LogSink) o;
    return Objects.equals(this.bigqueryOptions, logSink.bigqueryOptions) &&
        Objects.equals(this.createTime, logSink.createTime) &&
        Objects.equals(this.description, logSink.description) &&
        Objects.equals(this.destination, logSink.destination) &&
        Objects.equals(this.disabled, logSink.disabled) &&
        Objects.equals(this.exclusions, logSink.exclusions) &&
        Objects.equals(this.filter, logSink.filter) &&
        Objects.equals(this.includeChildren, logSink.includeChildren) &&
        Objects.equals(this.name, logSink.name) &&
        Objects.equals(this.outputVersionFormat, logSink.outputVersionFormat) &&
        Objects.equals(this.updateTime, logSink.updateTime) &&
        Objects.equals(this.writerIdentity, logSink.writerIdentity);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bigqueryOptions, createTime, description, destination, disabled, exclusions, filter, includeChildren, name, outputVersionFormat, updateTime, writerIdentity);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LogSink {\n");
    sb.append("    bigqueryOptions: ").append(toIndentedString(bigqueryOptions)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    destination: ").append(toIndentedString(destination)).append("\n");
    sb.append("    disabled: ").append(toIndentedString(disabled)).append("\n");
    sb.append("    exclusions: ").append(toIndentedString(exclusions)).append("\n");
    sb.append("    filter: ").append(toIndentedString(filter)).append("\n");
    sb.append("    includeChildren: ").append(toIndentedString(includeChildren)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    outputVersionFormat: ").append(toIndentedString(outputVersionFormat)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("    writerIdentity: ").append(toIndentedString(writerIdentity)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("bigqueryOptions");
    openapiFields.add("createTime");
    openapiFields.add("description");
    openapiFields.add("destination");
    openapiFields.add("disabled");
    openapiFields.add("exclusions");
    openapiFields.add("filter");
    openapiFields.add("includeChildren");
    openapiFields.add("name");
    openapiFields.add("outputVersionFormat");
    openapiFields.add("updateTime");
    openapiFields.add("writerIdentity");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LogSink
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LogSink.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LogSink is not found in the empty JSON string", LogSink.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LogSink.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LogSink` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `bigqueryOptions`
      if (jsonObj.get("bigqueryOptions") != null && !jsonObj.get("bigqueryOptions").isJsonNull()) {
        BigQueryOptions.validateJsonElement(jsonObj.get("bigqueryOptions"));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("destination") != null && !jsonObj.get("destination").isJsonNull()) && !jsonObj.get("destination").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destination` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destination").toString()));
      }
      if (jsonObj.get("exclusions") != null && !jsonObj.get("exclusions").isJsonNull()) {
        JsonArray jsonArrayexclusions = jsonObj.getAsJsonArray("exclusions");
        if (jsonArrayexclusions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("exclusions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `exclusions` to be an array in the JSON string but got `%s`", jsonObj.get("exclusions").toString()));
          }

          // validate the optional field `exclusions` (array)
          for (int i = 0; i < jsonArrayexclusions.size(); i++) {
            LogExclusion.validateJsonElement(jsonArrayexclusions.get(i));
          };
        }
      }
      if ((jsonObj.get("filter") != null && !jsonObj.get("filter").isJsonNull()) && !jsonObj.get("filter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("outputVersionFormat") != null && !jsonObj.get("outputVersionFormat").isJsonNull()) && !jsonObj.get("outputVersionFormat").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outputVersionFormat` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outputVersionFormat").toString()));
      }
      // validate the optional field `outputVersionFormat`
      if (jsonObj.get("outputVersionFormat") != null && !jsonObj.get("outputVersionFormat").isJsonNull()) {
        OutputVersionFormatEnum.validateJsonElement(jsonObj.get("outputVersionFormat"));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
      if ((jsonObj.get("writerIdentity") != null && !jsonObj.get("writerIdentity").isJsonNull()) && !jsonObj.get("writerIdentity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `writerIdentity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("writerIdentity").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LogSink.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LogSink' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LogSink> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LogSink.class));

       return (TypeAdapter<T>) new TypeAdapter<LogSink>() {
           @Override
           public void write(JsonWriter out, LogSink value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LogSink read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LogSink given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LogSink
   * @throws IOException if the JSON string is invalid with respect to LogSink
   */
  public static LogSink fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LogSink.class);
  }

  /**
   * Convert an instance of LogSink to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

