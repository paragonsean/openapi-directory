/*
 * Cloud Logging API
 * Writes log entries and manages your Cloud Logging configuration.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.SummaryField;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Describes a Cloud Logging query that can be run in Logs Explorer UI or via the logging API.In addition to the query itself, additional information may be stored to capture the display configuration and other UI state used in association with analysis of query results.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:26.064361-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LoggingQuery {
  public static final String SERIALIZED_NAME_FILTER = "filter";
  @SerializedName(SERIALIZED_NAME_FILTER)
  private String filter;

  public static final String SERIALIZED_NAME_SUMMARY_FIELD_END = "summaryFieldEnd";
  @SerializedName(SERIALIZED_NAME_SUMMARY_FIELD_END)
  private Integer summaryFieldEnd;

  public static final String SERIALIZED_NAME_SUMMARY_FIELD_START = "summaryFieldStart";
  @SerializedName(SERIALIZED_NAME_SUMMARY_FIELD_START)
  private Integer summaryFieldStart;

  public static final String SERIALIZED_NAME_SUMMARY_FIELDS = "summaryFields";
  @SerializedName(SERIALIZED_NAME_SUMMARY_FIELDS)
  private List<SummaryField> summaryFields = new ArrayList<>();

  public LoggingQuery() {
  }

  public LoggingQuery filter(String filter) {
    this.filter = filter;
    return this;
  }

  /**
   * Required. An advanced query using the Logging Query Language (https://cloud.google.com/logging/docs/view/logging-query-language). The maximum length of the filter is 20000 characters.
   * @return filter
   */
  @javax.annotation.Nullable
  public String getFilter() {
    return filter;
  }

  public void setFilter(String filter) {
    this.filter = filter;
  }


  public LoggingQuery summaryFieldEnd(Integer summaryFieldEnd) {
    this.summaryFieldEnd = summaryFieldEnd;
    return this;
  }

  /**
   * Characters will be counted from the end of the string.
   * @return summaryFieldEnd
   */
  @javax.annotation.Nullable
  public Integer getSummaryFieldEnd() {
    return summaryFieldEnd;
  }

  public void setSummaryFieldEnd(Integer summaryFieldEnd) {
    this.summaryFieldEnd = summaryFieldEnd;
  }


  public LoggingQuery summaryFieldStart(Integer summaryFieldStart) {
    this.summaryFieldStart = summaryFieldStart;
    return this;
  }

  /**
   * Characters will be counted from the start of the string.
   * @return summaryFieldStart
   */
  @javax.annotation.Nullable
  public Integer getSummaryFieldStart() {
    return summaryFieldStart;
  }

  public void setSummaryFieldStart(Integer summaryFieldStart) {
    this.summaryFieldStart = summaryFieldStart;
  }


  public LoggingQuery summaryFields(List<SummaryField> summaryFields) {
    this.summaryFields = summaryFields;
    return this;
  }

  public LoggingQuery addSummaryFieldsItem(SummaryField summaryFieldsItem) {
    if (this.summaryFields == null) {
      this.summaryFields = new ArrayList<>();
    }
    this.summaryFields.add(summaryFieldsItem);
    return this;
  }

  /**
   * Optional. The set of summary fields to display for this saved query.
   * @return summaryFields
   */
  @javax.annotation.Nullable
  public List<SummaryField> getSummaryFields() {
    return summaryFields;
  }

  public void setSummaryFields(List<SummaryField> summaryFields) {
    this.summaryFields = summaryFields;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LoggingQuery loggingQuery = (LoggingQuery) o;
    return Objects.equals(this.filter, loggingQuery.filter) &&
        Objects.equals(this.summaryFieldEnd, loggingQuery.summaryFieldEnd) &&
        Objects.equals(this.summaryFieldStart, loggingQuery.summaryFieldStart) &&
        Objects.equals(this.summaryFields, loggingQuery.summaryFields);
  }

  @Override
  public int hashCode() {
    return Objects.hash(filter, summaryFieldEnd, summaryFieldStart, summaryFields);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LoggingQuery {\n");
    sb.append("    filter: ").append(toIndentedString(filter)).append("\n");
    sb.append("    summaryFieldEnd: ").append(toIndentedString(summaryFieldEnd)).append("\n");
    sb.append("    summaryFieldStart: ").append(toIndentedString(summaryFieldStart)).append("\n");
    sb.append("    summaryFields: ").append(toIndentedString(summaryFields)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("filter");
    openapiFields.add("summaryFieldEnd");
    openapiFields.add("summaryFieldStart");
    openapiFields.add("summaryFields");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LoggingQuery
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LoggingQuery.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LoggingQuery is not found in the empty JSON string", LoggingQuery.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LoggingQuery.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LoggingQuery` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("filter") != null && !jsonObj.get("filter").isJsonNull()) && !jsonObj.get("filter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter").toString()));
      }
      if (jsonObj.get("summaryFields") != null && !jsonObj.get("summaryFields").isJsonNull()) {
        JsonArray jsonArraysummaryFields = jsonObj.getAsJsonArray("summaryFields");
        if (jsonArraysummaryFields != null) {
          // ensure the json data is an array
          if (!jsonObj.get("summaryFields").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `summaryFields` to be an array in the JSON string but got `%s`", jsonObj.get("summaryFields").toString()));
          }

          // validate the optional field `summaryFields` (array)
          for (int i = 0; i < jsonArraysummaryFields.size(); i++) {
            SummaryField.validateJsonElement(jsonArraysummaryFields.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LoggingQuery.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LoggingQuery' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LoggingQuery> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LoggingQuery.class));

       return (TypeAdapter<T>) new TypeAdapter<LoggingQuery>() {
           @Override
           public void write(JsonWriter out, LoggingQuery value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LoggingQuery read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LoggingQuery given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LoggingQuery
   * @throws IOException if the JSON string is invalid with respect to LoggingQuery
   */
  public static LoggingQuery fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LoggingQuery.class);
  }

  /**
   * Convert an instance of LoggingQuery to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

