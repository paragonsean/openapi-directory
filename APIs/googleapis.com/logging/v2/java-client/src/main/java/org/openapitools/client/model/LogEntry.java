/*
 * Cloud Logging API
 * Writes log entries and manages your Cloud Logging configuration.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.HttpRequest;
import org.openapitools.client.model.LogEntryOperation;
import org.openapitools.client.model.LogEntrySourceLocation;
import org.openapitools.client.model.LogErrorGroup;
import org.openapitools.client.model.LogSplit;
import org.openapitools.client.model.MonitoredResource;
import org.openapitools.client.model.MonitoredResourceMetadata;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An individual entry in a log.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:38:26.064361-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LogEntry {
  public static final String SERIALIZED_NAME_ERROR_GROUPS = "errorGroups";
  @SerializedName(SERIALIZED_NAME_ERROR_GROUPS)
  private List<LogErrorGroup> errorGroups = new ArrayList<>();

  public static final String SERIALIZED_NAME_HTTP_REQUEST = "httpRequest";
  @SerializedName(SERIALIZED_NAME_HTTP_REQUEST)
  private HttpRequest httpRequest;

  public static final String SERIALIZED_NAME_INSERT_ID = "insertId";
  @SerializedName(SERIALIZED_NAME_INSERT_ID)
  private String insertId;

  public static final String SERIALIZED_NAME_JSON_PAYLOAD = "jsonPayload";
  @SerializedName(SERIALIZED_NAME_JSON_PAYLOAD)
  private Map<String, Object> jsonPayload = new HashMap<>();

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LOG_NAME = "logName";
  @SerializedName(SERIALIZED_NAME_LOG_NAME)
  private String logName;

  public static final String SERIALIZED_NAME_METADATA = "metadata";
  @SerializedName(SERIALIZED_NAME_METADATA)
  private MonitoredResourceMetadata metadata;

  public static final String SERIALIZED_NAME_OPERATION = "operation";
  @SerializedName(SERIALIZED_NAME_OPERATION)
  private LogEntryOperation operation;

  public static final String SERIALIZED_NAME_PROTO_PAYLOAD = "protoPayload";
  @SerializedName(SERIALIZED_NAME_PROTO_PAYLOAD)
  private Map<String, Object> protoPayload = new HashMap<>();

  public static final String SERIALIZED_NAME_RECEIVE_TIMESTAMP = "receiveTimestamp";
  @SerializedName(SERIALIZED_NAME_RECEIVE_TIMESTAMP)
  private String receiveTimestamp;

  public static final String SERIALIZED_NAME_RESOURCE = "resource";
  @SerializedName(SERIALIZED_NAME_RESOURCE)
  private MonitoredResource resource;

  /**
   * Optional. The severity of the log entry. The default value is LogSeverity.DEFAULT.
   */
  @JsonAdapter(SeverityEnum.Adapter.class)
  public enum SeverityEnum {
    DEFAULT("DEFAULT"),
    
    DEBUG("DEBUG"),
    
    INFO("INFO"),
    
    NOTICE("NOTICE"),
    
    WARNING("WARNING"),
    
    ERROR("ERROR"),
    
    CRITICAL("CRITICAL"),
    
    ALERT("ALERT"),
    
    EMERGENCY("EMERGENCY");

    private String value;

    SeverityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SeverityEnum fromValue(String value) {
      for (SeverityEnum b : SeverityEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SeverityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SeverityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SeverityEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SeverityEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SeverityEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SEVERITY = "severity";
  @SerializedName(SERIALIZED_NAME_SEVERITY)
  private SeverityEnum severity;

  public static final String SERIALIZED_NAME_SOURCE_LOCATION = "sourceLocation";
  @SerializedName(SERIALIZED_NAME_SOURCE_LOCATION)
  private LogEntrySourceLocation sourceLocation;

  public static final String SERIALIZED_NAME_SPAN_ID = "spanId";
  @SerializedName(SERIALIZED_NAME_SPAN_ID)
  private String spanId;

  public static final String SERIALIZED_NAME_SPLIT = "split";
  @SerializedName(SERIALIZED_NAME_SPLIT)
  private LogSplit split;

  public static final String SERIALIZED_NAME_TEXT_PAYLOAD = "textPayload";
  @SerializedName(SERIALIZED_NAME_TEXT_PAYLOAD)
  private String textPayload;

  public static final String SERIALIZED_NAME_TIMESTAMP = "timestamp";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP)
  private String timestamp;

  public static final String SERIALIZED_NAME_TRACE = "trace";
  @SerializedName(SERIALIZED_NAME_TRACE)
  private String trace;

  public static final String SERIALIZED_NAME_TRACE_SAMPLED = "traceSampled";
  @SerializedName(SERIALIZED_NAME_TRACE_SAMPLED)
  private Boolean traceSampled;

  public LogEntry() {
  }

  public LogEntry(
     List<LogErrorGroup> errorGroups, 
     String receiveTimestamp
  ) {
    this();
    this.errorGroups = errorGroups;
    this.receiveTimestamp = receiveTimestamp;
  }

  /**
   * Output only. The Error Reporting (https://cloud.google.com/error-reporting) error groups associated with this LogEntry. Error Reporting sets the values for this field during error group creation.For more information, see View error details( https://cloud.google.com/error-reporting/docs/viewing-errors#view_error_details)This field isn&#39;t available during log routing (https://cloud.google.com/logging/docs/routing/overview)
   * @return errorGroups
   */
  @javax.annotation.Nullable
  public List<LogErrorGroup> getErrorGroups() {
    return errorGroups;
  }



  public LogEntry httpRequest(HttpRequest httpRequest) {
    this.httpRequest = httpRequest;
    return this;
  }

  /**
   * Get httpRequest
   * @return httpRequest
   */
  @javax.annotation.Nullable
  public HttpRequest getHttpRequest() {
    return httpRequest;
  }

  public void setHttpRequest(HttpRequest httpRequest) {
    this.httpRequest = httpRequest;
  }


  public LogEntry insertId(String insertId) {
    this.insertId = insertId;
    return this;
  }

  /**
   * Optional. A unique identifier for the log entry. If you provide a value, then Logging considers other log entries in the same project, with the same timestamp, and with the same insert_id to be duplicates which are removed in a single query result. However, there are no guarantees of de-duplication in the export of logs.If the insert_id is omitted when writing a log entry, the Logging API assigns its own unique identifier in this field.In queries, the insert_id is also used to order log entries that have the same log_name and timestamp values.
   * @return insertId
   */
  @javax.annotation.Nullable
  public String getInsertId() {
    return insertId;
  }

  public void setInsertId(String insertId) {
    this.insertId = insertId;
  }


  public LogEntry jsonPayload(Map<String, Object> jsonPayload) {
    this.jsonPayload = jsonPayload;
    return this;
  }

  public LogEntry putJsonPayloadItem(String key, Object jsonPayloadItem) {
    if (this.jsonPayload == null) {
      this.jsonPayload = new HashMap<>();
    }
    this.jsonPayload.put(key, jsonPayloadItem);
    return this;
  }

  /**
   * The log entry payload, represented as a structure that is expressed as a JSON object.
   * @return jsonPayload
   */
  @javax.annotation.Nullable
  public Map<String, Object> getJsonPayload() {
    return jsonPayload;
  }

  public void setJsonPayload(Map<String, Object> jsonPayload) {
    this.jsonPayload = jsonPayload;
  }


  public LogEntry labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public LogEntry putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Optional. A map of key, value pairs that provides additional information about the log entry. The labels can be user-defined or system-defined.User-defined labels are arbitrary key, value pairs that you can use to classify logs.System-defined labels are defined by GCP services for platform logs. They have two components - a service namespace component and the attribute name. For example: compute.googleapis.com/resource_name.Cloud Logging truncates label keys that exceed 512 B and label values that exceed 64 KB upon their associated log entry being written. The truncation is indicated by an ellipsis at the end of the character string.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public LogEntry logName(String logName) {
    this.logName = logName;
    return this;
  }

  /**
   * Required. The resource name of the log to which this log entry belongs: \&quot;projects/[PROJECT_ID]/logs/[LOG_ID]\&quot; \&quot;organizations/[ORGANIZATION_ID]/logs/[LOG_ID]\&quot; \&quot;billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]\&quot; \&quot;folders/[FOLDER_ID]/logs/[LOG_ID]\&quot; A project number may be used in place of PROJECT_ID. The project number is translated to its corresponding PROJECT_ID internally and the log_name field will contain PROJECT_ID in queries and exports.[LOG_ID] must be URL-encoded within log_name. Example: \&quot;organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity\&quot;.[LOG_ID] must be less than 512 characters long and can only include the following characters: upper and lower case alphanumeric characters, forward-slash, underscore, hyphen, and period.For backward compatibility, if log_name begins with a forward-slash, such as /projects/..., then the log entry is processed as usual, but the forward-slash is removed. Listing the log entry will not show the leading slash and filtering for a log name with a leading slash will never return any results.
   * @return logName
   */
  @javax.annotation.Nullable
  public String getLogName() {
    return logName;
  }

  public void setLogName(String logName) {
    this.logName = logName;
  }


  public LogEntry metadata(MonitoredResourceMetadata metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Get metadata
   * @return metadata
   */
  @javax.annotation.Nullable
  public MonitoredResourceMetadata getMetadata() {
    return metadata;
  }

  public void setMetadata(MonitoredResourceMetadata metadata) {
    this.metadata = metadata;
  }


  public LogEntry operation(LogEntryOperation operation) {
    this.operation = operation;
    return this;
  }

  /**
   * Get operation
   * @return operation
   */
  @javax.annotation.Nullable
  public LogEntryOperation getOperation() {
    return operation;
  }

  public void setOperation(LogEntryOperation operation) {
    this.operation = operation;
  }


  public LogEntry protoPayload(Map<String, Object> protoPayload) {
    this.protoPayload = protoPayload;
    return this;
  }

  public LogEntry putProtoPayloadItem(String key, Object protoPayloadItem) {
    if (this.protoPayload == null) {
      this.protoPayload = new HashMap<>();
    }
    this.protoPayload.put(key, protoPayloadItem);
    return this;
  }

  /**
   * The log entry payload, represented as a protocol buffer. Some Google Cloud Platform services use this field for their log entry payloads.The following protocol buffer types are supported; user-defined types are not supported:\&quot;type.googleapis.com/google.cloud.audit.AuditLog\&quot; \&quot;type.googleapis.com/google.appengine.logging.v1.RequestLog\&quot;
   * @return protoPayload
   */
  @javax.annotation.Nullable
  public Map<String, Object> getProtoPayload() {
    return protoPayload;
  }

  public void setProtoPayload(Map<String, Object> protoPayload) {
    this.protoPayload = protoPayload;
  }


  /**
   * Output only. The time the log entry was received by Logging.
   * @return receiveTimestamp
   */
  @javax.annotation.Nullable
  public String getReceiveTimestamp() {
    return receiveTimestamp;
  }



  public LogEntry resource(MonitoredResource resource) {
    this.resource = resource;
    return this;
  }

  /**
   * Get resource
   * @return resource
   */
  @javax.annotation.Nullable
  public MonitoredResource getResource() {
    return resource;
  }

  public void setResource(MonitoredResource resource) {
    this.resource = resource;
  }


  public LogEntry severity(SeverityEnum severity) {
    this.severity = severity;
    return this;
  }

  /**
   * Optional. The severity of the log entry. The default value is LogSeverity.DEFAULT.
   * @return severity
   */
  @javax.annotation.Nullable
  public SeverityEnum getSeverity() {
    return severity;
  }

  public void setSeverity(SeverityEnum severity) {
    this.severity = severity;
  }


  public LogEntry sourceLocation(LogEntrySourceLocation sourceLocation) {
    this.sourceLocation = sourceLocation;
    return this;
  }

  /**
   * Get sourceLocation
   * @return sourceLocation
   */
  @javax.annotation.Nullable
  public LogEntrySourceLocation getSourceLocation() {
    return sourceLocation;
  }

  public void setSourceLocation(LogEntrySourceLocation sourceLocation) {
    this.sourceLocation = sourceLocation;
  }


  public LogEntry spanId(String spanId) {
    this.spanId = spanId;
    return this;
  }

  /**
   * Optional. The ID of the Cloud Trace (https://cloud.google.com/trace) span associated with the current operation in which the log is being written. For example, if a span has the REST resource name of \&quot;projects/some-project/traces/some-trace/spans/some-span-id\&quot;, then the span_id field is \&quot;some-span-id\&quot;.A Span (https://cloud.google.com/trace/docs/reference/v2/rest/v2/projects.traces/batchWrite#Span) represents a single operation within a trace. Whereas a trace may involve multiple different microservices running on multiple different machines, a span generally corresponds to a single logical operation being performed in a single instance of a microservice on one specific machine. Spans are the nodes within the tree that is a trace.Applications that are instrumented for tracing (https://cloud.google.com/trace/docs/setup) will generally assign a new, unique span ID on each incoming request. It is also common to create and record additional spans corresponding to internal processing elements as well as issuing requests to dependencies.The span ID is expected to be a 16-character, hexadecimal encoding of an 8-byte array and should not be zero. It should be unique within the trace and should, ideally, be generated in a manner that is uniformly random.Example values: 000000000000004a 7a2190356c3fc94b 0000f00300090021 d39223e101960076
   * @return spanId
   */
  @javax.annotation.Nullable
  public String getSpanId() {
    return spanId;
  }

  public void setSpanId(String spanId) {
    this.spanId = spanId;
  }


  public LogEntry split(LogSplit split) {
    this.split = split;
    return this;
  }

  /**
   * Get split
   * @return split
   */
  @javax.annotation.Nullable
  public LogSplit getSplit() {
    return split;
  }

  public void setSplit(LogSplit split) {
    this.split = split;
  }


  public LogEntry textPayload(String textPayload) {
    this.textPayload = textPayload;
    return this;
  }

  /**
   * The log entry payload, represented as a Unicode string (UTF-8).
   * @return textPayload
   */
  @javax.annotation.Nullable
  public String getTextPayload() {
    return textPayload;
  }

  public void setTextPayload(String textPayload) {
    this.textPayload = textPayload;
  }


  public LogEntry timestamp(String timestamp) {
    this.timestamp = timestamp;
    return this;
  }

  /**
   * Optional. The time the event described by the log entry occurred. This time is used to compute the log entry&#39;s age and to enforce the logs retention period. If this field is omitted in a new log entry, then Logging assigns it the current time. Timestamps have nanosecond accuracy, but trailing zeros in the fractional seconds might be omitted when the timestamp is displayed.Incoming log entries must have timestamps that don&#39;t exceed the logs retention period (https://cloud.google.com/logging/quotas#logs_retention_periods) in the past, and that don&#39;t exceed 24 hours in the future. Log entries outside those time boundaries are rejected by Logging.
   * @return timestamp
   */
  @javax.annotation.Nullable
  public String getTimestamp() {
    return timestamp;
  }

  public void setTimestamp(String timestamp) {
    this.timestamp = timestamp;
  }


  public LogEntry trace(String trace) {
    this.trace = trace;
    return this;
  }

  /**
   * Optional. The REST resource name of the trace being written to Cloud Trace (https://cloud.google.com/trace) in association with this log entry. For example, if your trace data is stored in the Cloud project \&quot;my-trace-project\&quot; and if the service that is creating the log entry receives a trace header that includes the trace ID \&quot;12345\&quot;, then the service should use \&quot;projects/my-trace-project/traces/12345\&quot;.The trace field provides the link between logs and traces. By using this field, you can navigate from a log entry to a trace.
   * @return trace
   */
  @javax.annotation.Nullable
  public String getTrace() {
    return trace;
  }

  public void setTrace(String trace) {
    this.trace = trace;
  }


  public LogEntry traceSampled(Boolean traceSampled) {
    this.traceSampled = traceSampled;
    return this;
  }

  /**
   * Optional. The sampling decision of the span associated with the log entry at the time the log entry was created. This field corresponds to the sampled flag in the W3C trace-context specification (https://www.w3.org/TR/trace-context/#sampled-flag). A non-sampled trace value is still useful as a request correlation identifier. The default is False.
   * @return traceSampled
   */
  @javax.annotation.Nullable
  public Boolean getTraceSampled() {
    return traceSampled;
  }

  public void setTraceSampled(Boolean traceSampled) {
    this.traceSampled = traceSampled;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LogEntry logEntry = (LogEntry) o;
    return Objects.equals(this.errorGroups, logEntry.errorGroups) &&
        Objects.equals(this.httpRequest, logEntry.httpRequest) &&
        Objects.equals(this.insertId, logEntry.insertId) &&
        Objects.equals(this.jsonPayload, logEntry.jsonPayload) &&
        Objects.equals(this.labels, logEntry.labels) &&
        Objects.equals(this.logName, logEntry.logName) &&
        Objects.equals(this.metadata, logEntry.metadata) &&
        Objects.equals(this.operation, logEntry.operation) &&
        Objects.equals(this.protoPayload, logEntry.protoPayload) &&
        Objects.equals(this.receiveTimestamp, logEntry.receiveTimestamp) &&
        Objects.equals(this.resource, logEntry.resource) &&
        Objects.equals(this.severity, logEntry.severity) &&
        Objects.equals(this.sourceLocation, logEntry.sourceLocation) &&
        Objects.equals(this.spanId, logEntry.spanId) &&
        Objects.equals(this.split, logEntry.split) &&
        Objects.equals(this.textPayload, logEntry.textPayload) &&
        Objects.equals(this.timestamp, logEntry.timestamp) &&
        Objects.equals(this.trace, logEntry.trace) &&
        Objects.equals(this.traceSampled, logEntry.traceSampled);
  }

  @Override
  public int hashCode() {
    return Objects.hash(errorGroups, httpRequest, insertId, jsonPayload, labels, logName, metadata, operation, protoPayload, receiveTimestamp, resource, severity, sourceLocation, spanId, split, textPayload, timestamp, trace, traceSampled);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LogEntry {\n");
    sb.append("    errorGroups: ").append(toIndentedString(errorGroups)).append("\n");
    sb.append("    httpRequest: ").append(toIndentedString(httpRequest)).append("\n");
    sb.append("    insertId: ").append(toIndentedString(insertId)).append("\n");
    sb.append("    jsonPayload: ").append(toIndentedString(jsonPayload)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    logName: ").append(toIndentedString(logName)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    operation: ").append(toIndentedString(operation)).append("\n");
    sb.append("    protoPayload: ").append(toIndentedString(protoPayload)).append("\n");
    sb.append("    receiveTimestamp: ").append(toIndentedString(receiveTimestamp)).append("\n");
    sb.append("    resource: ").append(toIndentedString(resource)).append("\n");
    sb.append("    severity: ").append(toIndentedString(severity)).append("\n");
    sb.append("    sourceLocation: ").append(toIndentedString(sourceLocation)).append("\n");
    sb.append("    spanId: ").append(toIndentedString(spanId)).append("\n");
    sb.append("    split: ").append(toIndentedString(split)).append("\n");
    sb.append("    textPayload: ").append(toIndentedString(textPayload)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("    trace: ").append(toIndentedString(trace)).append("\n");
    sb.append("    traceSampled: ").append(toIndentedString(traceSampled)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("errorGroups");
    openapiFields.add("httpRequest");
    openapiFields.add("insertId");
    openapiFields.add("jsonPayload");
    openapiFields.add("labels");
    openapiFields.add("logName");
    openapiFields.add("metadata");
    openapiFields.add("operation");
    openapiFields.add("protoPayload");
    openapiFields.add("receiveTimestamp");
    openapiFields.add("resource");
    openapiFields.add("severity");
    openapiFields.add("sourceLocation");
    openapiFields.add("spanId");
    openapiFields.add("split");
    openapiFields.add("textPayload");
    openapiFields.add("timestamp");
    openapiFields.add("trace");
    openapiFields.add("traceSampled");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LogEntry
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LogEntry.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LogEntry is not found in the empty JSON string", LogEntry.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LogEntry.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LogEntry` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("errorGroups") != null && !jsonObj.get("errorGroups").isJsonNull()) {
        JsonArray jsonArrayerrorGroups = jsonObj.getAsJsonArray("errorGroups");
        if (jsonArrayerrorGroups != null) {
          // ensure the json data is an array
          if (!jsonObj.get("errorGroups").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `errorGroups` to be an array in the JSON string but got `%s`", jsonObj.get("errorGroups").toString()));
          }

          // validate the optional field `errorGroups` (array)
          for (int i = 0; i < jsonArrayerrorGroups.size(); i++) {
            LogErrorGroup.validateJsonElement(jsonArrayerrorGroups.get(i));
          };
        }
      }
      // validate the optional field `httpRequest`
      if (jsonObj.get("httpRequest") != null && !jsonObj.get("httpRequest").isJsonNull()) {
        HttpRequest.validateJsonElement(jsonObj.get("httpRequest"));
      }
      if ((jsonObj.get("insertId") != null && !jsonObj.get("insertId").isJsonNull()) && !jsonObj.get("insertId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `insertId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("insertId").toString()));
      }
      if ((jsonObj.get("logName") != null && !jsonObj.get("logName").isJsonNull()) && !jsonObj.get("logName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logName").toString()));
      }
      // validate the optional field `metadata`
      if (jsonObj.get("metadata") != null && !jsonObj.get("metadata").isJsonNull()) {
        MonitoredResourceMetadata.validateJsonElement(jsonObj.get("metadata"));
      }
      // validate the optional field `operation`
      if (jsonObj.get("operation") != null && !jsonObj.get("operation").isJsonNull()) {
        LogEntryOperation.validateJsonElement(jsonObj.get("operation"));
      }
      if ((jsonObj.get("receiveTimestamp") != null && !jsonObj.get("receiveTimestamp").isJsonNull()) && !jsonObj.get("receiveTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `receiveTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("receiveTimestamp").toString()));
      }
      // validate the optional field `resource`
      if (jsonObj.get("resource") != null && !jsonObj.get("resource").isJsonNull()) {
        MonitoredResource.validateJsonElement(jsonObj.get("resource"));
      }
      if ((jsonObj.get("severity") != null && !jsonObj.get("severity").isJsonNull()) && !jsonObj.get("severity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `severity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("severity").toString()));
      }
      // validate the optional field `severity`
      if (jsonObj.get("severity") != null && !jsonObj.get("severity").isJsonNull()) {
        SeverityEnum.validateJsonElement(jsonObj.get("severity"));
      }
      // validate the optional field `sourceLocation`
      if (jsonObj.get("sourceLocation") != null && !jsonObj.get("sourceLocation").isJsonNull()) {
        LogEntrySourceLocation.validateJsonElement(jsonObj.get("sourceLocation"));
      }
      if ((jsonObj.get("spanId") != null && !jsonObj.get("spanId").isJsonNull()) && !jsonObj.get("spanId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `spanId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("spanId").toString()));
      }
      // validate the optional field `split`
      if (jsonObj.get("split") != null && !jsonObj.get("split").isJsonNull()) {
        LogSplit.validateJsonElement(jsonObj.get("split"));
      }
      if ((jsonObj.get("textPayload") != null && !jsonObj.get("textPayload").isJsonNull()) && !jsonObj.get("textPayload").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `textPayload` to be a primitive type in the JSON string but got `%s`", jsonObj.get("textPayload").toString()));
      }
      if ((jsonObj.get("timestamp") != null && !jsonObj.get("timestamp").isJsonNull()) && !jsonObj.get("timestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timestamp").toString()));
      }
      if ((jsonObj.get("trace") != null && !jsonObj.get("trace").isJsonNull()) && !jsonObj.get("trace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `trace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trace").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LogEntry.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LogEntry' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LogEntry> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LogEntry.class));

       return (TypeAdapter<T>) new TypeAdapter<LogEntry>() {
           @Override
           public void write(JsonWriter out, LogEntry value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LogEntry read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LogEntry given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LogEntry
   * @throws IOException if the JSON string is invalid with respect to LogEntry
   */
  public static LogEntry fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LogEntry.class);
  }

  /**
   * Convert an instance of LogEntry to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

