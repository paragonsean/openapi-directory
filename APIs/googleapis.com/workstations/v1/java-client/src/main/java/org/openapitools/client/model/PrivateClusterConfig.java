/*
 * Cloud Workstations API
 * Allows administrators to create managed developer environments in the cloud. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Configuration options for private workstation clusters.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:17.375207-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PrivateClusterConfig {
  public static final String SERIALIZED_NAME_ALLOWED_PROJECTS = "allowedProjects";
  @SerializedName(SERIALIZED_NAME_ALLOWED_PROJECTS)
  private List<String> allowedProjects = new ArrayList<>();

  public static final String SERIALIZED_NAME_CLUSTER_HOSTNAME = "clusterHostname";
  @SerializedName(SERIALIZED_NAME_CLUSTER_HOSTNAME)
  private String clusterHostname;

  public static final String SERIALIZED_NAME_ENABLE_PRIVATE_ENDPOINT = "enablePrivateEndpoint";
  @SerializedName(SERIALIZED_NAME_ENABLE_PRIVATE_ENDPOINT)
  private Boolean enablePrivateEndpoint;

  public static final String SERIALIZED_NAME_SERVICE_ATTACHMENT_URI = "serviceAttachmentUri";
  @SerializedName(SERIALIZED_NAME_SERVICE_ATTACHMENT_URI)
  private String serviceAttachmentUri;

  public PrivateClusterConfig() {
  }

  public PrivateClusterConfig(
     String clusterHostname, 
     String serviceAttachmentUri
  ) {
    this();
    this.clusterHostname = clusterHostname;
    this.serviceAttachmentUri = serviceAttachmentUri;
  }

  public PrivateClusterConfig allowedProjects(List<String> allowedProjects) {
    this.allowedProjects = allowedProjects;
    return this;
  }

  public PrivateClusterConfig addAllowedProjectsItem(String allowedProjectsItem) {
    if (this.allowedProjects == null) {
      this.allowedProjects = new ArrayList<>();
    }
    this.allowedProjects.add(allowedProjectsItem);
    return this;
  }

  /**
   * Optional. Additional projects that are allowed to attach to the workstation cluster&#39;s service attachment. By default, the workstation cluster&#39;s project and the VPC host project (if different) are allowed.
   * @return allowedProjects
   */
  @javax.annotation.Nullable
  public List<String> getAllowedProjects() {
    return allowedProjects;
  }

  public void setAllowedProjects(List<String> allowedProjects) {
    this.allowedProjects = allowedProjects;
  }


  /**
   * Output only. Hostname for the workstation cluster. This field will be populated only when private endpoint is enabled. To access workstations in the workstation cluster, create a new DNS zone mapping this domain name to an internal IP address and a forwarding rule mapping that address to the service attachment.
   * @return clusterHostname
   */
  @javax.annotation.Nullable
  public String getClusterHostname() {
    return clusterHostname;
  }



  public PrivateClusterConfig enablePrivateEndpoint(Boolean enablePrivateEndpoint) {
    this.enablePrivateEndpoint = enablePrivateEndpoint;
    return this;
  }

  /**
   * Immutable. Whether Workstations endpoint is private.
   * @return enablePrivateEndpoint
   */
  @javax.annotation.Nullable
  public Boolean getEnablePrivateEndpoint() {
    return enablePrivateEndpoint;
  }

  public void setEnablePrivateEndpoint(Boolean enablePrivateEndpoint) {
    this.enablePrivateEndpoint = enablePrivateEndpoint;
  }


  /**
   * Output only. Service attachment URI for the workstation cluster. The service attachemnt is created when private endpoint is enabled. To access workstations in the workstation cluster, configure access to the managed service using [Private Service Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-services).
   * @return serviceAttachmentUri
   */
  @javax.annotation.Nullable
  public String getServiceAttachmentUri() {
    return serviceAttachmentUri;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PrivateClusterConfig privateClusterConfig = (PrivateClusterConfig) o;
    return Objects.equals(this.allowedProjects, privateClusterConfig.allowedProjects) &&
        Objects.equals(this.clusterHostname, privateClusterConfig.clusterHostname) &&
        Objects.equals(this.enablePrivateEndpoint, privateClusterConfig.enablePrivateEndpoint) &&
        Objects.equals(this.serviceAttachmentUri, privateClusterConfig.serviceAttachmentUri);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowedProjects, clusterHostname, enablePrivateEndpoint, serviceAttachmentUri);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PrivateClusterConfig {\n");
    sb.append("    allowedProjects: ").append(toIndentedString(allowedProjects)).append("\n");
    sb.append("    clusterHostname: ").append(toIndentedString(clusterHostname)).append("\n");
    sb.append("    enablePrivateEndpoint: ").append(toIndentedString(enablePrivateEndpoint)).append("\n");
    sb.append("    serviceAttachmentUri: ").append(toIndentedString(serviceAttachmentUri)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowedProjects");
    openapiFields.add("clusterHostname");
    openapiFields.add("enablePrivateEndpoint");
    openapiFields.add("serviceAttachmentUri");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PrivateClusterConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PrivateClusterConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PrivateClusterConfig is not found in the empty JSON string", PrivateClusterConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PrivateClusterConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PrivateClusterConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("allowedProjects") != null && !jsonObj.get("allowedProjects").isJsonNull() && !jsonObj.get("allowedProjects").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `allowedProjects` to be an array in the JSON string but got `%s`", jsonObj.get("allowedProjects").toString()));
      }
      if ((jsonObj.get("clusterHostname") != null && !jsonObj.get("clusterHostname").isJsonNull()) && !jsonObj.get("clusterHostname").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterHostname` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterHostname").toString()));
      }
      if ((jsonObj.get("serviceAttachmentUri") != null && !jsonObj.get("serviceAttachmentUri").isJsonNull()) && !jsonObj.get("serviceAttachmentUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAttachmentUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAttachmentUri").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PrivateClusterConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PrivateClusterConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PrivateClusterConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PrivateClusterConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<PrivateClusterConfig>() {
           @Override
           public void write(JsonWriter out, PrivateClusterConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PrivateClusterConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PrivateClusterConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PrivateClusterConfig
   * @throws IOException if the JSON string is invalid with respect to PrivateClusterConfig
   */
  public static PrivateClusterConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PrivateClusterConfig.class);
  }

  /**
   * Convert an instance of PrivateClusterConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

