/**
 * Cloud Workstations API
 * Allows administrators to create managed developer environments in the cloud. 
 *
 * The version of the OpenAPI document: v1beta
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIGceInstance.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIGceInstance::OAIGceInstance(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIGceInstance::OAIGceInstance() {
    this->initializeModel();
}

OAIGceInstance::~OAIGceInstance() {}

void OAIGceInstance::initializeModel() {

    m_accelerators_isSet = false;
    m_accelerators_isValid = false;

    m_boot_disk_size_gb_isSet = false;
    m_boot_disk_size_gb_isValid = false;

    m_confidential_instance_config_isSet = false;
    m_confidential_instance_config_isValid = false;

    m_disable_public_ip_addresses_isSet = false;
    m_disable_public_ip_addresses_isValid = false;

    m_disable_ssh_isSet = false;
    m_disable_ssh_isValid = false;

    m_enable_nested_virtualization_isSet = false;
    m_enable_nested_virtualization_isValid = false;

    m_machine_type_isSet = false;
    m_machine_type_isValid = false;

    m_pool_size_isSet = false;
    m_pool_size_isValid = false;

    m_pooled_instances_isSet = false;
    m_pooled_instances_isValid = false;

    m_service_account_isSet = false;
    m_service_account_isValid = false;

    m_service_account_scopes_isSet = false;
    m_service_account_scopes_isValid = false;

    m_shielded_instance_config_isSet = false;
    m_shielded_instance_config_isValid = false;

    m_tags_isSet = false;
    m_tags_isValid = false;
}

void OAIGceInstance::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIGceInstance::fromJsonObject(QJsonObject json) {

    m_accelerators_isValid = ::OpenAPI::fromJsonValue(m_accelerators, json[QString("accelerators")]);
    m_accelerators_isSet = !json[QString("accelerators")].isNull() && m_accelerators_isValid;

    m_boot_disk_size_gb_isValid = ::OpenAPI::fromJsonValue(m_boot_disk_size_gb, json[QString("bootDiskSizeGb")]);
    m_boot_disk_size_gb_isSet = !json[QString("bootDiskSizeGb")].isNull() && m_boot_disk_size_gb_isValid;

    m_confidential_instance_config_isValid = ::OpenAPI::fromJsonValue(m_confidential_instance_config, json[QString("confidentialInstanceConfig")]);
    m_confidential_instance_config_isSet = !json[QString("confidentialInstanceConfig")].isNull() && m_confidential_instance_config_isValid;

    m_disable_public_ip_addresses_isValid = ::OpenAPI::fromJsonValue(m_disable_public_ip_addresses, json[QString("disablePublicIpAddresses")]);
    m_disable_public_ip_addresses_isSet = !json[QString("disablePublicIpAddresses")].isNull() && m_disable_public_ip_addresses_isValid;

    m_disable_ssh_isValid = ::OpenAPI::fromJsonValue(m_disable_ssh, json[QString("disableSsh")]);
    m_disable_ssh_isSet = !json[QString("disableSsh")].isNull() && m_disable_ssh_isValid;

    m_enable_nested_virtualization_isValid = ::OpenAPI::fromJsonValue(m_enable_nested_virtualization, json[QString("enableNestedVirtualization")]);
    m_enable_nested_virtualization_isSet = !json[QString("enableNestedVirtualization")].isNull() && m_enable_nested_virtualization_isValid;

    m_machine_type_isValid = ::OpenAPI::fromJsonValue(m_machine_type, json[QString("machineType")]);
    m_machine_type_isSet = !json[QString("machineType")].isNull() && m_machine_type_isValid;

    m_pool_size_isValid = ::OpenAPI::fromJsonValue(m_pool_size, json[QString("poolSize")]);
    m_pool_size_isSet = !json[QString("poolSize")].isNull() && m_pool_size_isValid;

    m_pooled_instances_isValid = ::OpenAPI::fromJsonValue(m_pooled_instances, json[QString("pooledInstances")]);
    m_pooled_instances_isSet = !json[QString("pooledInstances")].isNull() && m_pooled_instances_isValid;

    m_service_account_isValid = ::OpenAPI::fromJsonValue(m_service_account, json[QString("serviceAccount")]);
    m_service_account_isSet = !json[QString("serviceAccount")].isNull() && m_service_account_isValid;

    m_service_account_scopes_isValid = ::OpenAPI::fromJsonValue(m_service_account_scopes, json[QString("serviceAccountScopes")]);
    m_service_account_scopes_isSet = !json[QString("serviceAccountScopes")].isNull() && m_service_account_scopes_isValid;

    m_shielded_instance_config_isValid = ::OpenAPI::fromJsonValue(m_shielded_instance_config, json[QString("shieldedInstanceConfig")]);
    m_shielded_instance_config_isSet = !json[QString("shieldedInstanceConfig")].isNull() && m_shielded_instance_config_isValid;

    m_tags_isValid = ::OpenAPI::fromJsonValue(m_tags, json[QString("tags")]);
    m_tags_isSet = !json[QString("tags")].isNull() && m_tags_isValid;
}

QString OAIGceInstance::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIGceInstance::asJsonObject() const {
    QJsonObject obj;
    if (m_accelerators.size() > 0) {
        obj.insert(QString("accelerators"), ::OpenAPI::toJsonValue(m_accelerators));
    }
    if (m_boot_disk_size_gb_isSet) {
        obj.insert(QString("bootDiskSizeGb"), ::OpenAPI::toJsonValue(m_boot_disk_size_gb));
    }
    if (m_confidential_instance_config.isSet()) {
        obj.insert(QString("confidentialInstanceConfig"), ::OpenAPI::toJsonValue(m_confidential_instance_config));
    }
    if (m_disable_public_ip_addresses_isSet) {
        obj.insert(QString("disablePublicIpAddresses"), ::OpenAPI::toJsonValue(m_disable_public_ip_addresses));
    }
    if (m_disable_ssh_isSet) {
        obj.insert(QString("disableSsh"), ::OpenAPI::toJsonValue(m_disable_ssh));
    }
    if (m_enable_nested_virtualization_isSet) {
        obj.insert(QString("enableNestedVirtualization"), ::OpenAPI::toJsonValue(m_enable_nested_virtualization));
    }
    if (m_machine_type_isSet) {
        obj.insert(QString("machineType"), ::OpenAPI::toJsonValue(m_machine_type));
    }
    if (m_pool_size_isSet) {
        obj.insert(QString("poolSize"), ::OpenAPI::toJsonValue(m_pool_size));
    }
    if (m_pooled_instances_isSet) {
        obj.insert(QString("pooledInstances"), ::OpenAPI::toJsonValue(m_pooled_instances));
    }
    if (m_service_account_isSet) {
        obj.insert(QString("serviceAccount"), ::OpenAPI::toJsonValue(m_service_account));
    }
    if (m_service_account_scopes.size() > 0) {
        obj.insert(QString("serviceAccountScopes"), ::OpenAPI::toJsonValue(m_service_account_scopes));
    }
    if (m_shielded_instance_config.isSet()) {
        obj.insert(QString("shieldedInstanceConfig"), ::OpenAPI::toJsonValue(m_shielded_instance_config));
    }
    if (m_tags.size() > 0) {
        obj.insert(QString("tags"), ::OpenAPI::toJsonValue(m_tags));
    }
    return obj;
}

QList<OAIAccelerator> OAIGceInstance::getAccelerators() const {
    return m_accelerators;
}
void OAIGceInstance::setAccelerators(const QList<OAIAccelerator> &accelerators) {
    m_accelerators = accelerators;
    m_accelerators_isSet = true;
}

bool OAIGceInstance::is_accelerators_Set() const{
    return m_accelerators_isSet;
}

bool OAIGceInstance::is_accelerators_Valid() const{
    return m_accelerators_isValid;
}

qint32 OAIGceInstance::getBootDiskSizeGb() const {
    return m_boot_disk_size_gb;
}
void OAIGceInstance::setBootDiskSizeGb(const qint32 &boot_disk_size_gb) {
    m_boot_disk_size_gb = boot_disk_size_gb;
    m_boot_disk_size_gb_isSet = true;
}

bool OAIGceInstance::is_boot_disk_size_gb_Set() const{
    return m_boot_disk_size_gb_isSet;
}

bool OAIGceInstance::is_boot_disk_size_gb_Valid() const{
    return m_boot_disk_size_gb_isValid;
}

OAIGceConfidentialInstanceConfig OAIGceInstance::getConfidentialInstanceConfig() const {
    return m_confidential_instance_config;
}
void OAIGceInstance::setConfidentialInstanceConfig(const OAIGceConfidentialInstanceConfig &confidential_instance_config) {
    m_confidential_instance_config = confidential_instance_config;
    m_confidential_instance_config_isSet = true;
}

bool OAIGceInstance::is_confidential_instance_config_Set() const{
    return m_confidential_instance_config_isSet;
}

bool OAIGceInstance::is_confidential_instance_config_Valid() const{
    return m_confidential_instance_config_isValid;
}

bool OAIGceInstance::isDisablePublicIpAddresses() const {
    return m_disable_public_ip_addresses;
}
void OAIGceInstance::setDisablePublicIpAddresses(const bool &disable_public_ip_addresses) {
    m_disable_public_ip_addresses = disable_public_ip_addresses;
    m_disable_public_ip_addresses_isSet = true;
}

bool OAIGceInstance::is_disable_public_ip_addresses_Set() const{
    return m_disable_public_ip_addresses_isSet;
}

bool OAIGceInstance::is_disable_public_ip_addresses_Valid() const{
    return m_disable_public_ip_addresses_isValid;
}

bool OAIGceInstance::isDisableSsh() const {
    return m_disable_ssh;
}
void OAIGceInstance::setDisableSsh(const bool &disable_ssh) {
    m_disable_ssh = disable_ssh;
    m_disable_ssh_isSet = true;
}

bool OAIGceInstance::is_disable_ssh_Set() const{
    return m_disable_ssh_isSet;
}

bool OAIGceInstance::is_disable_ssh_Valid() const{
    return m_disable_ssh_isValid;
}

bool OAIGceInstance::isEnableNestedVirtualization() const {
    return m_enable_nested_virtualization;
}
void OAIGceInstance::setEnableNestedVirtualization(const bool &enable_nested_virtualization) {
    m_enable_nested_virtualization = enable_nested_virtualization;
    m_enable_nested_virtualization_isSet = true;
}

bool OAIGceInstance::is_enable_nested_virtualization_Set() const{
    return m_enable_nested_virtualization_isSet;
}

bool OAIGceInstance::is_enable_nested_virtualization_Valid() const{
    return m_enable_nested_virtualization_isValid;
}

QString OAIGceInstance::getMachineType() const {
    return m_machine_type;
}
void OAIGceInstance::setMachineType(const QString &machine_type) {
    m_machine_type = machine_type;
    m_machine_type_isSet = true;
}

bool OAIGceInstance::is_machine_type_Set() const{
    return m_machine_type_isSet;
}

bool OAIGceInstance::is_machine_type_Valid() const{
    return m_machine_type_isValid;
}

qint32 OAIGceInstance::getPoolSize() const {
    return m_pool_size;
}
void OAIGceInstance::setPoolSize(const qint32 &pool_size) {
    m_pool_size = pool_size;
    m_pool_size_isSet = true;
}

bool OAIGceInstance::is_pool_size_Set() const{
    return m_pool_size_isSet;
}

bool OAIGceInstance::is_pool_size_Valid() const{
    return m_pool_size_isValid;
}

qint32 OAIGceInstance::getPooledInstances() const {
    return m_pooled_instances;
}
void OAIGceInstance::setPooledInstances(const qint32 &pooled_instances) {
    m_pooled_instances = pooled_instances;
    m_pooled_instances_isSet = true;
}

bool OAIGceInstance::is_pooled_instances_Set() const{
    return m_pooled_instances_isSet;
}

bool OAIGceInstance::is_pooled_instances_Valid() const{
    return m_pooled_instances_isValid;
}

QString OAIGceInstance::getServiceAccount() const {
    return m_service_account;
}
void OAIGceInstance::setServiceAccount(const QString &service_account) {
    m_service_account = service_account;
    m_service_account_isSet = true;
}

bool OAIGceInstance::is_service_account_Set() const{
    return m_service_account_isSet;
}

bool OAIGceInstance::is_service_account_Valid() const{
    return m_service_account_isValid;
}

QList<QString> OAIGceInstance::getServiceAccountScopes() const {
    return m_service_account_scopes;
}
void OAIGceInstance::setServiceAccountScopes(const QList<QString> &service_account_scopes) {
    m_service_account_scopes = service_account_scopes;
    m_service_account_scopes_isSet = true;
}

bool OAIGceInstance::is_service_account_scopes_Set() const{
    return m_service_account_scopes_isSet;
}

bool OAIGceInstance::is_service_account_scopes_Valid() const{
    return m_service_account_scopes_isValid;
}

OAIGceShieldedInstanceConfig OAIGceInstance::getShieldedInstanceConfig() const {
    return m_shielded_instance_config;
}
void OAIGceInstance::setShieldedInstanceConfig(const OAIGceShieldedInstanceConfig &shielded_instance_config) {
    m_shielded_instance_config = shielded_instance_config;
    m_shielded_instance_config_isSet = true;
}

bool OAIGceInstance::is_shielded_instance_config_Set() const{
    return m_shielded_instance_config_isSet;
}

bool OAIGceInstance::is_shielded_instance_config_Valid() const{
    return m_shielded_instance_config_isValid;
}

QList<QString> OAIGceInstance::getTags() const {
    return m_tags;
}
void OAIGceInstance::setTags(const QList<QString> &tags) {
    m_tags = tags;
    m_tags_isSet = true;
}

bool OAIGceInstance::is_tags_Set() const{
    return m_tags_isSet;
}

bool OAIGceInstance::is_tags_Valid() const{
    return m_tags_isValid;
}

bool OAIGceInstance::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accelerators.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_boot_disk_size_gb_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_confidential_instance_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_disable_public_ip_addresses_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_disable_ssh_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_enable_nested_virtualization_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_machine_type_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pool_size_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_pooled_instances_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_account_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_service_account_scopes.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_shielded_instance_config.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_tags.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIGceInstance::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
