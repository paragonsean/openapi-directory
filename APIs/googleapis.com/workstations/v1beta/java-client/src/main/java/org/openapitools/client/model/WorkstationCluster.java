/*
 * Cloud Workstations API
 * Allows administrators to create managed developer environments in the cloud. 
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.DomainConfig;
import org.openapitools.client.model.PrivateClusterConfig;
import org.openapitools.client.model.Status;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A workstation cluster resource in the Cloud Workstations API. Defines a group of workstations in a particular region and the VPC network they&#39;re attached to.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:14.615319-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class WorkstationCluster {
  public static final String SERIALIZED_NAME_ANNOTATIONS = "annotations";
  @SerializedName(SERIALIZED_NAME_ANNOTATIONS)
  private Map<String, String> annotations = new HashMap<>();

  public static final String SERIALIZED_NAME_CONDITIONS = "conditions";
  @SerializedName(SERIALIZED_NAME_CONDITIONS)
  private List<Status> conditions = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONTROL_PLANE_IP = "controlPlaneIp";
  @SerializedName(SERIALIZED_NAME_CONTROL_PLANE_IP)
  private String controlPlaneIp;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DEGRADED = "degraded";
  @SerializedName(SERIALIZED_NAME_DEGRADED)
  private Boolean degraded;

  public static final String SERIALIZED_NAME_DELETE_TIME = "deleteTime";
  @SerializedName(SERIALIZED_NAME_DELETE_TIME)
  private String deleteTime;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_DOMAIN_CONFIG = "domainConfig";
  @SerializedName(SERIALIZED_NAME_DOMAIN_CONFIG)
  private DomainConfig domainConfig;

  public static final String SERIALIZED_NAME_ETAG = "etag";
  @SerializedName(SERIALIZED_NAME_ETAG)
  private String etag;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_PRIVATE_CLUSTER_CONFIG = "privateClusterConfig";
  @SerializedName(SERIALIZED_NAME_PRIVATE_CLUSTER_CONFIG)
  private PrivateClusterConfig privateClusterConfig;

  public static final String SERIALIZED_NAME_RECONCILING = "reconciling";
  @SerializedName(SERIALIZED_NAME_RECONCILING)
  private Boolean reconciling;

  public static final String SERIALIZED_NAME_SUBNETWORK = "subnetwork";
  @SerializedName(SERIALIZED_NAME_SUBNETWORK)
  private String subnetwork;

  public static final String SERIALIZED_NAME_UID = "uid";
  @SerializedName(SERIALIZED_NAME_UID)
  private String uid;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public WorkstationCluster() {
  }

  public WorkstationCluster(
     List<Status> conditions, 
     String controlPlaneIp, 
     String createTime, 
     Boolean degraded, 
     String deleteTime, 
     Boolean reconciling, 
     String uid, 
     String updateTime
  ) {
    this();
    this.conditions = conditions;
    this.controlPlaneIp = controlPlaneIp;
    this.createTime = createTime;
    this.degraded = degraded;
    this.deleteTime = deleteTime;
    this.reconciling = reconciling;
    this.uid = uid;
    this.updateTime = updateTime;
  }

  public WorkstationCluster annotations(Map<String, String> annotations) {
    this.annotations = annotations;
    return this;
  }

  public WorkstationCluster putAnnotationsItem(String key, String annotationsItem) {
    if (this.annotations == null) {
      this.annotations = new HashMap<>();
    }
    this.annotations.put(key, annotationsItem);
    return this;
  }

  /**
   * Optional. Client-specified annotations.
   * @return annotations
   */
  @javax.annotation.Nullable
  public Map<String, String> getAnnotations() {
    return annotations;
  }

  public void setAnnotations(Map<String, String> annotations) {
    this.annotations = annotations;
  }


  /**
   * Output only. Status conditions describing the workstation cluster&#39;s current state.
   * @return conditions
   */
  @javax.annotation.Nullable
  public List<Status> getConditions() {
    return conditions;
  }



  /**
   * Output only. The private IP address of the control plane for this workstation cluster. Workstation VMs need access to this IP address to work with the service, so make sure that your firewall rules allow egress from the workstation VMs to this address.
   * @return controlPlaneIp
   */
  @javax.annotation.Nullable
  public String getControlPlaneIp() {
    return controlPlaneIp;
  }



  /**
   * Output only. Time when this workstation cluster was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  /**
   * Output only. Whether this workstation cluster is in degraded mode, in which case it may require user action to restore full functionality. Details can be found in conditions.
   * @return degraded
   */
  @javax.annotation.Nullable
  public Boolean getDegraded() {
    return degraded;
  }



  /**
   * Output only. Time when this workstation cluster was soft-deleted.
   * @return deleteTime
   */
  @javax.annotation.Nullable
  public String getDeleteTime() {
    return deleteTime;
  }



  public WorkstationCluster displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Optional. Human-readable name for this workstation cluster.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public WorkstationCluster domainConfig(DomainConfig domainConfig) {
    this.domainConfig = domainConfig;
    return this;
  }

  /**
   * Get domainConfig
   * @return domainConfig
   */
  @javax.annotation.Nullable
  public DomainConfig getDomainConfig() {
    return domainConfig;
  }

  public void setDomainConfig(DomainConfig domainConfig) {
    this.domainConfig = domainConfig;
  }


  public WorkstationCluster etag(String etag) {
    this.etag = etag;
    return this;
  }

  /**
   * Optional. Checksum computed by the server. May be sent on update and delete requests to make sure that the client has an up-to-date value before proceeding.
   * @return etag
   */
  @javax.annotation.Nullable
  public String getEtag() {
    return etag;
  }

  public void setEtag(String etag) {
    this.etag = etag;
  }


  public WorkstationCluster labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public WorkstationCluster putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Optional. [Labels](https://cloud.google.com/workstations/docs/label-resources) that are applied to the workstation cluster and that are also propagated to the underlying Compute Engine resources.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public WorkstationCluster name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Identifier. Full name of this workstation cluster.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public WorkstationCluster network(String network) {
    this.network = network;
    return this;
  }

  /**
   * Immutable. Name of the Compute Engine network in which instances associated with this workstation cluster will be created.
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public WorkstationCluster privateClusterConfig(PrivateClusterConfig privateClusterConfig) {
    this.privateClusterConfig = privateClusterConfig;
    return this;
  }

  /**
   * Get privateClusterConfig
   * @return privateClusterConfig
   */
  @javax.annotation.Nullable
  public PrivateClusterConfig getPrivateClusterConfig() {
    return privateClusterConfig;
  }

  public void setPrivateClusterConfig(PrivateClusterConfig privateClusterConfig) {
    this.privateClusterConfig = privateClusterConfig;
  }


  /**
   * Output only. Indicates whether this workstation cluster is currently being updated to match its intended state.
   * @return reconciling
   */
  @javax.annotation.Nullable
  public Boolean getReconciling() {
    return reconciling;
  }



  public WorkstationCluster subnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
    return this;
  }

  /**
   * Immutable. Name of the Compute Engine subnetwork in which instances associated with this workstation cluster will be created. Must be part of the subnetwork specified for this workstation cluster.
   * @return subnetwork
   */
  @javax.annotation.Nullable
  public String getSubnetwork() {
    return subnetwork;
  }

  public void setSubnetwork(String subnetwork) {
    this.subnetwork = subnetwork;
  }


  /**
   * Output only. A system-assigned unique identifier for this workstation cluster.
   * @return uid
   */
  @javax.annotation.Nullable
  public String getUid() {
    return uid;
  }



  /**
   * Output only. Time when this workstation cluster was most recently updated.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WorkstationCluster workstationCluster = (WorkstationCluster) o;
    return Objects.equals(this.annotations, workstationCluster.annotations) &&
        Objects.equals(this.conditions, workstationCluster.conditions) &&
        Objects.equals(this.controlPlaneIp, workstationCluster.controlPlaneIp) &&
        Objects.equals(this.createTime, workstationCluster.createTime) &&
        Objects.equals(this.degraded, workstationCluster.degraded) &&
        Objects.equals(this.deleteTime, workstationCluster.deleteTime) &&
        Objects.equals(this.displayName, workstationCluster.displayName) &&
        Objects.equals(this.domainConfig, workstationCluster.domainConfig) &&
        Objects.equals(this.etag, workstationCluster.etag) &&
        Objects.equals(this.labels, workstationCluster.labels) &&
        Objects.equals(this.name, workstationCluster.name) &&
        Objects.equals(this.network, workstationCluster.network) &&
        Objects.equals(this.privateClusterConfig, workstationCluster.privateClusterConfig) &&
        Objects.equals(this.reconciling, workstationCluster.reconciling) &&
        Objects.equals(this.subnetwork, workstationCluster.subnetwork) &&
        Objects.equals(this.uid, workstationCluster.uid) &&
        Objects.equals(this.updateTime, workstationCluster.updateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotations, conditions, controlPlaneIp, createTime, degraded, deleteTime, displayName, domainConfig, etag, labels, name, network, privateClusterConfig, reconciling, subnetwork, uid, updateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WorkstationCluster {\n");
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    controlPlaneIp: ").append(toIndentedString(controlPlaneIp)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    degraded: ").append(toIndentedString(degraded)).append("\n");
    sb.append("    deleteTime: ").append(toIndentedString(deleteTime)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    domainConfig: ").append(toIndentedString(domainConfig)).append("\n");
    sb.append("    etag: ").append(toIndentedString(etag)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    privateClusterConfig: ").append(toIndentedString(privateClusterConfig)).append("\n");
    sb.append("    reconciling: ").append(toIndentedString(reconciling)).append("\n");
    sb.append("    subnetwork: ").append(toIndentedString(subnetwork)).append("\n");
    sb.append("    uid: ").append(toIndentedString(uid)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotations");
    openapiFields.add("conditions");
    openapiFields.add("controlPlaneIp");
    openapiFields.add("createTime");
    openapiFields.add("degraded");
    openapiFields.add("deleteTime");
    openapiFields.add("displayName");
    openapiFields.add("domainConfig");
    openapiFields.add("etag");
    openapiFields.add("labels");
    openapiFields.add("name");
    openapiFields.add("network");
    openapiFields.add("privateClusterConfig");
    openapiFields.add("reconciling");
    openapiFields.add("subnetwork");
    openapiFields.add("uid");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to WorkstationCluster
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!WorkstationCluster.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WorkstationCluster is not found in the empty JSON string", WorkstationCluster.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!WorkstationCluster.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `WorkstationCluster` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("conditions") != null && !jsonObj.get("conditions").isJsonNull()) {
        JsonArray jsonArrayconditions = jsonObj.getAsJsonArray("conditions");
        if (jsonArrayconditions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("conditions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `conditions` to be an array in the JSON string but got `%s`", jsonObj.get("conditions").toString()));
          }

          // validate the optional field `conditions` (array)
          for (int i = 0; i < jsonArrayconditions.size(); i++) {
            Status.validateJsonElement(jsonArrayconditions.get(i));
          };
        }
      }
      if ((jsonObj.get("controlPlaneIp") != null && !jsonObj.get("controlPlaneIp").isJsonNull()) && !jsonObj.get("controlPlaneIp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `controlPlaneIp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("controlPlaneIp").toString()));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("deleteTime") != null && !jsonObj.get("deleteTime").isJsonNull()) && !jsonObj.get("deleteTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deleteTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deleteTime").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      // validate the optional field `domainConfig`
      if (jsonObj.get("domainConfig") != null && !jsonObj.get("domainConfig").isJsonNull()) {
        DomainConfig.validateJsonElement(jsonObj.get("domainConfig"));
      }
      if ((jsonObj.get("etag") != null && !jsonObj.get("etag").isJsonNull()) && !jsonObj.get("etag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `etag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("etag").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      // validate the optional field `privateClusterConfig`
      if (jsonObj.get("privateClusterConfig") != null && !jsonObj.get("privateClusterConfig").isJsonNull()) {
        PrivateClusterConfig.validateJsonElement(jsonObj.get("privateClusterConfig"));
      }
      if ((jsonObj.get("subnetwork") != null && !jsonObj.get("subnetwork").isJsonNull()) && !jsonObj.get("subnetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnetwork").toString()));
      }
      if ((jsonObj.get("uid") != null && !jsonObj.get("uid").isJsonNull()) && !jsonObj.get("uid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uid").toString()));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WorkstationCluster.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WorkstationCluster' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WorkstationCluster> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WorkstationCluster.class));

       return (TypeAdapter<T>) new TypeAdapter<WorkstationCluster>() {
           @Override
           public void write(JsonWriter out, WorkstationCluster value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WorkstationCluster read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of WorkstationCluster given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of WorkstationCluster
   * @throws IOException if the JSON string is invalid with respect to WorkstationCluster
   */
  public static WorkstationCluster fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WorkstationCluster.class);
  }

  /**
   * Convert an instance of WorkstationCluster to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

