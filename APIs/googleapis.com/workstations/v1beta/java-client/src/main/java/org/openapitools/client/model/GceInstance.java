/*
 * Cloud Workstations API
 * Allows administrators to create managed developer environments in the cloud. 
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Accelerator;
import org.openapitools.client.model.GceConfidentialInstanceConfig;
import org.openapitools.client.model.GceShieldedInstanceConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A runtime using a Compute Engine instance.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:14.615319-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GceInstance {
  public static final String SERIALIZED_NAME_ACCELERATORS = "accelerators";
  @SerializedName(SERIALIZED_NAME_ACCELERATORS)
  private List<Accelerator> accelerators = new ArrayList<>();

  public static final String SERIALIZED_NAME_BOOT_DISK_SIZE_GB = "bootDiskSizeGb";
  @SerializedName(SERIALIZED_NAME_BOOT_DISK_SIZE_GB)
  private Integer bootDiskSizeGb;

  public static final String SERIALIZED_NAME_CONFIDENTIAL_INSTANCE_CONFIG = "confidentialInstanceConfig";
  @SerializedName(SERIALIZED_NAME_CONFIDENTIAL_INSTANCE_CONFIG)
  private GceConfidentialInstanceConfig confidentialInstanceConfig;

  public static final String SERIALIZED_NAME_DISABLE_PUBLIC_IP_ADDRESSES = "disablePublicIpAddresses";
  @SerializedName(SERIALIZED_NAME_DISABLE_PUBLIC_IP_ADDRESSES)
  private Boolean disablePublicIpAddresses;

  public static final String SERIALIZED_NAME_DISABLE_SSH = "disableSsh";
  @SerializedName(SERIALIZED_NAME_DISABLE_SSH)
  private Boolean disableSsh;

  public static final String SERIALIZED_NAME_ENABLE_NESTED_VIRTUALIZATION = "enableNestedVirtualization";
  @SerializedName(SERIALIZED_NAME_ENABLE_NESTED_VIRTUALIZATION)
  private Boolean enableNestedVirtualization;

  public static final String SERIALIZED_NAME_MACHINE_TYPE = "machineType";
  @SerializedName(SERIALIZED_NAME_MACHINE_TYPE)
  private String machineType;

  public static final String SERIALIZED_NAME_POOL_SIZE = "poolSize";
  @SerializedName(SERIALIZED_NAME_POOL_SIZE)
  private Integer poolSize;

  public static final String SERIALIZED_NAME_POOLED_INSTANCES = "pooledInstances";
  @SerializedName(SERIALIZED_NAME_POOLED_INSTANCES)
  private Integer pooledInstances;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private String serviceAccount;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_SCOPES = "serviceAccountScopes";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_SCOPES)
  private List<String> serviceAccountScopes = new ArrayList<>();

  public static final String SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG = "shieldedInstanceConfig";
  @SerializedName(SERIALIZED_NAME_SHIELDED_INSTANCE_CONFIG)
  private GceShieldedInstanceConfig shieldedInstanceConfig;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  private List<String> tags = new ArrayList<>();

  public GceInstance() {
  }

  public GceInstance(
     Integer pooledInstances
  ) {
    this();
    this.pooledInstances = pooledInstances;
  }

  public GceInstance accelerators(List<Accelerator> accelerators) {
    this.accelerators = accelerators;
    return this;
  }

  public GceInstance addAcceleratorsItem(Accelerator acceleratorsItem) {
    if (this.accelerators == null) {
      this.accelerators = new ArrayList<>();
    }
    this.accelerators.add(acceleratorsItem);
    return this;
  }

  /**
   * Optional. A list of the type and count of accelerator cards attached to the instance.
   * @return accelerators
   */
  @javax.annotation.Nullable
  public List<Accelerator> getAccelerators() {
    return accelerators;
  }

  public void setAccelerators(List<Accelerator> accelerators) {
    this.accelerators = accelerators;
  }


  public GceInstance bootDiskSizeGb(Integer bootDiskSizeGb) {
    this.bootDiskSizeGb = bootDiskSizeGb;
    return this;
  }

  /**
   * Optional. The size of the boot disk for the VM in gigabytes (GB). The minimum boot disk size is &#x60;30&#x60; GB. Defaults to &#x60;50&#x60; GB.
   * @return bootDiskSizeGb
   */
  @javax.annotation.Nullable
  public Integer getBootDiskSizeGb() {
    return bootDiskSizeGb;
  }

  public void setBootDiskSizeGb(Integer bootDiskSizeGb) {
    this.bootDiskSizeGb = bootDiskSizeGb;
  }


  public GceInstance confidentialInstanceConfig(GceConfidentialInstanceConfig confidentialInstanceConfig) {
    this.confidentialInstanceConfig = confidentialInstanceConfig;
    return this;
  }

  /**
   * Get confidentialInstanceConfig
   * @return confidentialInstanceConfig
   */
  @javax.annotation.Nullable
  public GceConfidentialInstanceConfig getConfidentialInstanceConfig() {
    return confidentialInstanceConfig;
  }

  public void setConfidentialInstanceConfig(GceConfidentialInstanceConfig confidentialInstanceConfig) {
    this.confidentialInstanceConfig = confidentialInstanceConfig;
  }


  public GceInstance disablePublicIpAddresses(Boolean disablePublicIpAddresses) {
    this.disablePublicIpAddresses = disablePublicIpAddresses;
    return this;
  }

  /**
   * Optional. When set to true, disables public IP addresses for VMs. If you disable public IP addresses, you must set up Private Google Access or Cloud NAT on your network. If you use Private Google Access and you use &#x60;private.googleapis.com&#x60; or &#x60;restricted.googleapis.com&#x60; for Container Registry and Artifact Registry, make sure that you set up DNS records for domains &#x60;*.gcr.io&#x60; and &#x60;*.pkg.dev&#x60;. Defaults to false (VMs have public IP addresses).
   * @return disablePublicIpAddresses
   */
  @javax.annotation.Nullable
  public Boolean getDisablePublicIpAddresses() {
    return disablePublicIpAddresses;
  }

  public void setDisablePublicIpAddresses(Boolean disablePublicIpAddresses) {
    this.disablePublicIpAddresses = disablePublicIpAddresses;
  }


  public GceInstance disableSsh(Boolean disableSsh) {
    this.disableSsh = disableSsh;
    return this;
  }

  /**
   * Optional. Whether to disable SSH access to the VM.
   * @return disableSsh
   */
  @javax.annotation.Nullable
  public Boolean getDisableSsh() {
    return disableSsh;
  }

  public void setDisableSsh(Boolean disableSsh) {
    this.disableSsh = disableSsh;
  }


  public GceInstance enableNestedVirtualization(Boolean enableNestedVirtualization) {
    this.enableNestedVirtualization = enableNestedVirtualization;
    return this;
  }

  /**
   * Optional. Whether to enable nested virtualization on Cloud Workstations VMs created under this workstation configuration. Nested virtualization lets you run virtual machine (VM) instances inside your workstation. Before enabling nested virtualization, consider the following important considerations. Cloud Workstations instances are subject to the [same restrictions as Compute Engine instances](https://cloud.google.com/compute/docs/instances/nested-virtualization/overview#restrictions): * **Organization policy**: projects, folders, or organizations may be restricted from creating nested VMs if the **Disable VM nested virtualization** constraint is enforced in the organization policy. For more information, see the Compute Engine section, [Checking whether nested virtualization is allowed](https://cloud.google.com/compute/docs/instances/nested-virtualization/managing-constraint#checking_whether_nested_virtualization_is_allowed). * **Performance**: nested VMs might experience a 10% or greater decrease in performance for workloads that are CPU-bound and possibly greater than a 10% decrease for workloads that are input/output bound. * **Machine Type**: nested virtualization can only be enabled on workstation configurations that specify a machine_type in the N1 or N2 machine series. * **GPUs**: nested virtualization may not be enabled on workstation configurations with accelerators. * **Operating System**: Because [Container-Optimized OS](https://cloud.google.com/compute/docs/images/os-details#container-optimized_os_cos) does not support nested virtualization, when nested virtualization is enabled, the underlying Compute Engine VM instances boot from an [Ubuntu LTS](https://cloud.google.com/compute/docs/images/os-details#ubuntu_lts) image.
   * @return enableNestedVirtualization
   */
  @javax.annotation.Nullable
  public Boolean getEnableNestedVirtualization() {
    return enableNestedVirtualization;
  }

  public void setEnableNestedVirtualization(Boolean enableNestedVirtualization) {
    this.enableNestedVirtualization = enableNestedVirtualization;
  }


  public GceInstance machineType(String machineType) {
    this.machineType = machineType;
    return this;
  }

  /**
   * Optional. The type of machine to use for VM instancesâ€”for example, &#x60;\&quot;e2-standard-4\&quot;&#x60;. For more information about machine types that Cloud Workstations supports, see the list of [available machine types](https://cloud.google.com/workstations/docs/available-machine-types).
   * @return machineType
   */
  @javax.annotation.Nullable
  public String getMachineType() {
    return machineType;
  }

  public void setMachineType(String machineType) {
    this.machineType = machineType;
  }


  public GceInstance poolSize(Integer poolSize) {
    this.poolSize = poolSize;
    return this;
  }

  /**
   * Optional. The number of VMs that the system should keep idle so that new workstations can be started quickly for new users. Defaults to &#x60;0&#x60; in the API.
   * @return poolSize
   */
  @javax.annotation.Nullable
  public Integer getPoolSize() {
    return poolSize;
  }

  public void setPoolSize(Integer poolSize) {
    this.poolSize = poolSize;
  }


  /**
   * Output only. Number of instances currently available in the pool for faster workstation startup.
   * @return pooledInstances
   */
  @javax.annotation.Nullable
  public Integer getPooledInstances() {
    return pooledInstances;
  }



  public GceInstance serviceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * Optional. The email address of the service account for Cloud Workstations VMs created with this configuration. When specified, be sure that the service account has &#x60;logginglogEntries.create&#x60; permission on the project so it can write logs out to Cloud Logging. If using a custom container image, the service account must have [Artifact Registry Reader](https://cloud.google.com/artifact-registry/docs/access-control#roles) permission to pull the specified image. If you as the administrator want to be able to &#x60;ssh&#x60; into the underlying VM, you need to set this value to a service account for which you have the &#x60;iam.serviceAccounts.actAs&#x60; permission. Conversely, if you don&#39;t want anyone to be able to &#x60;ssh&#x60; into the underlying VM, use a service account where no one has that permission. If not set, VMs run with a service account provided by the Cloud Workstations service, and the image must be publicly accessible.
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public String getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(String serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public GceInstance serviceAccountScopes(List<String> serviceAccountScopes) {
    this.serviceAccountScopes = serviceAccountScopes;
    return this;
  }

  public GceInstance addServiceAccountScopesItem(String serviceAccountScopesItem) {
    if (this.serviceAccountScopes == null) {
      this.serviceAccountScopes = new ArrayList<>();
    }
    this.serviceAccountScopes.add(serviceAccountScopesItem);
    return this;
  }

  /**
   * Optional. Scopes to grant to the service_account. Various scopes are automatically added based on feature usage. When specified, users of workstations under this configuration must have &#x60;iam.serviceAccounts.actAs&#x60; on the service account.
   * @return serviceAccountScopes
   */
  @javax.annotation.Nullable
  public List<String> getServiceAccountScopes() {
    return serviceAccountScopes;
  }

  public void setServiceAccountScopes(List<String> serviceAccountScopes) {
    this.serviceAccountScopes = serviceAccountScopes;
  }


  public GceInstance shieldedInstanceConfig(GceShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
    return this;
  }

  /**
   * Get shieldedInstanceConfig
   * @return shieldedInstanceConfig
   */
  @javax.annotation.Nullable
  public GceShieldedInstanceConfig getShieldedInstanceConfig() {
    return shieldedInstanceConfig;
  }

  public void setShieldedInstanceConfig(GceShieldedInstanceConfig shieldedInstanceConfig) {
    this.shieldedInstanceConfig = shieldedInstanceConfig;
  }


  public GceInstance tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public GceInstance addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * Optional. Network tags to add to the Compute Engine VMs backing the workstations. This option applies [network tags](https://cloud.google.com/vpc/docs/add-remove-network-tags) to VMs created with this configuration. These network tags enable the creation of [firewall rules](https://cloud.google.com/workstations/docs/configure-firewall-rules).
   * @return tags
   */
  @javax.annotation.Nullable
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GceInstance gceInstance = (GceInstance) o;
    return Objects.equals(this.accelerators, gceInstance.accelerators) &&
        Objects.equals(this.bootDiskSizeGb, gceInstance.bootDiskSizeGb) &&
        Objects.equals(this.confidentialInstanceConfig, gceInstance.confidentialInstanceConfig) &&
        Objects.equals(this.disablePublicIpAddresses, gceInstance.disablePublicIpAddresses) &&
        Objects.equals(this.disableSsh, gceInstance.disableSsh) &&
        Objects.equals(this.enableNestedVirtualization, gceInstance.enableNestedVirtualization) &&
        Objects.equals(this.machineType, gceInstance.machineType) &&
        Objects.equals(this.poolSize, gceInstance.poolSize) &&
        Objects.equals(this.pooledInstances, gceInstance.pooledInstances) &&
        Objects.equals(this.serviceAccount, gceInstance.serviceAccount) &&
        Objects.equals(this.serviceAccountScopes, gceInstance.serviceAccountScopes) &&
        Objects.equals(this.shieldedInstanceConfig, gceInstance.shieldedInstanceConfig) &&
        Objects.equals(this.tags, gceInstance.tags);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accelerators, bootDiskSizeGb, confidentialInstanceConfig, disablePublicIpAddresses, disableSsh, enableNestedVirtualization, machineType, poolSize, pooledInstances, serviceAccount, serviceAccountScopes, shieldedInstanceConfig, tags);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GceInstance {\n");
    sb.append("    accelerators: ").append(toIndentedString(accelerators)).append("\n");
    sb.append("    bootDiskSizeGb: ").append(toIndentedString(bootDiskSizeGb)).append("\n");
    sb.append("    confidentialInstanceConfig: ").append(toIndentedString(confidentialInstanceConfig)).append("\n");
    sb.append("    disablePublicIpAddresses: ").append(toIndentedString(disablePublicIpAddresses)).append("\n");
    sb.append("    disableSsh: ").append(toIndentedString(disableSsh)).append("\n");
    sb.append("    enableNestedVirtualization: ").append(toIndentedString(enableNestedVirtualization)).append("\n");
    sb.append("    machineType: ").append(toIndentedString(machineType)).append("\n");
    sb.append("    poolSize: ").append(toIndentedString(poolSize)).append("\n");
    sb.append("    pooledInstances: ").append(toIndentedString(pooledInstances)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    serviceAccountScopes: ").append(toIndentedString(serviceAccountScopes)).append("\n");
    sb.append("    shieldedInstanceConfig: ").append(toIndentedString(shieldedInstanceConfig)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accelerators");
    openapiFields.add("bootDiskSizeGb");
    openapiFields.add("confidentialInstanceConfig");
    openapiFields.add("disablePublicIpAddresses");
    openapiFields.add("disableSsh");
    openapiFields.add("enableNestedVirtualization");
    openapiFields.add("machineType");
    openapiFields.add("poolSize");
    openapiFields.add("pooledInstances");
    openapiFields.add("serviceAccount");
    openapiFields.add("serviceAccountScopes");
    openapiFields.add("shieldedInstanceConfig");
    openapiFields.add("tags");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GceInstance
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GceInstance.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GceInstance is not found in the empty JSON string", GceInstance.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GceInstance.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GceInstance` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("accelerators") != null && !jsonObj.get("accelerators").isJsonNull()) {
        JsonArray jsonArrayaccelerators = jsonObj.getAsJsonArray("accelerators");
        if (jsonArrayaccelerators != null) {
          // ensure the json data is an array
          if (!jsonObj.get("accelerators").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `accelerators` to be an array in the JSON string but got `%s`", jsonObj.get("accelerators").toString()));
          }

          // validate the optional field `accelerators` (array)
          for (int i = 0; i < jsonArrayaccelerators.size(); i++) {
            Accelerator.validateJsonElement(jsonArrayaccelerators.get(i));
          };
        }
      }
      // validate the optional field `confidentialInstanceConfig`
      if (jsonObj.get("confidentialInstanceConfig") != null && !jsonObj.get("confidentialInstanceConfig").isJsonNull()) {
        GceConfidentialInstanceConfig.validateJsonElement(jsonObj.get("confidentialInstanceConfig"));
      }
      if ((jsonObj.get("machineType") != null && !jsonObj.get("machineType").isJsonNull()) && !jsonObj.get("machineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machineType").toString()));
      }
      if ((jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) && !jsonObj.get("serviceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccount").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("serviceAccountScopes") != null && !jsonObj.get("serviceAccountScopes").isJsonNull() && !jsonObj.get("serviceAccountScopes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountScopes` to be an array in the JSON string but got `%s`", jsonObj.get("serviceAccountScopes").toString()));
      }
      // validate the optional field `shieldedInstanceConfig`
      if (jsonObj.get("shieldedInstanceConfig") != null && !jsonObj.get("shieldedInstanceConfig").isJsonNull()) {
        GceShieldedInstanceConfig.validateJsonElement(jsonObj.get("shieldedInstanceConfig"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull() && !jsonObj.get("tags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GceInstance.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GceInstance' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GceInstance> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GceInstance.class));

       return (TypeAdapter<T>) new TypeAdapter<GceInstance>() {
           @Override
           public void write(JsonWriter out, GceInstance value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GceInstance read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GceInstance given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GceInstance
   * @throws IOException if the JSON string is invalid with respect to GceInstance
   */
  public static GceInstance fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GceInstance.class);
  }

  /**
   * Convert an instance of GceInstance to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

