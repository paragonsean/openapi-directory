/*
 * Cloud Workstations API
 * Allows administrators to create managed developer environments in the cloud. 
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A customer-managed encryption key (CMEK) for the Compute Engine resources of the associated workstation configuration. Specify the name of your Cloud KMS encryption key and the default service account. We recommend that you use a separate service account and follow [Cloud KMS best practices](https://cloud.google.com/kms/docs/separation-of-duties).
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:14.615319-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CustomerEncryptionKey {
  public static final String SERIALIZED_NAME_KMS_KEY = "kmsKey";
  @SerializedName(SERIALIZED_NAME_KMS_KEY)
  private String kmsKey;

  public static final String SERIALIZED_NAME_KMS_KEY_SERVICE_ACCOUNT = "kmsKeyServiceAccount";
  @SerializedName(SERIALIZED_NAME_KMS_KEY_SERVICE_ACCOUNT)
  private String kmsKeyServiceAccount;

  public CustomerEncryptionKey() {
  }

  public CustomerEncryptionKey kmsKey(String kmsKey) {
    this.kmsKey = kmsKey;
    return this;
  }

  /**
   * Immutable. The name of the Google Cloud KMS encryption key. For example, &#x60;\&quot;projects/PROJECT_ID/locations/REGION/keyRings/KEY_RING/cryptoKeys/KEY_NAME\&quot;&#x60;. The key must be in the same region as the workstation configuration.
   * @return kmsKey
   */
  @javax.annotation.Nullable
  public String getKmsKey() {
    return kmsKey;
  }

  public void setKmsKey(String kmsKey) {
    this.kmsKey = kmsKey;
  }


  public CustomerEncryptionKey kmsKeyServiceAccount(String kmsKeyServiceAccount) {
    this.kmsKeyServiceAccount = kmsKeyServiceAccount;
    return this;
  }

  /**
   * Immutable. The service account to use with the specified KMS key. We recommend that you use a separate service account and follow KMS best practices. For more information, see [Separation of duties](https://cloud.google.com/kms/docs/separation-of-duties) and &#x60;gcloud kms keys add-iam-policy-binding&#x60; [&#x60;--member&#x60;](https://cloud.google.com/sdk/gcloud/reference/kms/keys/add-iam-policy-binding#--member).
   * @return kmsKeyServiceAccount
   */
  @javax.annotation.Nullable
  public String getKmsKeyServiceAccount() {
    return kmsKeyServiceAccount;
  }

  public void setKmsKeyServiceAccount(String kmsKeyServiceAccount) {
    this.kmsKeyServiceAccount = kmsKeyServiceAccount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CustomerEncryptionKey customerEncryptionKey = (CustomerEncryptionKey) o;
    return Objects.equals(this.kmsKey, customerEncryptionKey.kmsKey) &&
        Objects.equals(this.kmsKeyServiceAccount, customerEncryptionKey.kmsKeyServiceAccount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(kmsKey, kmsKeyServiceAccount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CustomerEncryptionKey {\n");
    sb.append("    kmsKey: ").append(toIndentedString(kmsKey)).append("\n");
    sb.append("    kmsKeyServiceAccount: ").append(toIndentedString(kmsKeyServiceAccount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("kmsKey");
    openapiFields.add("kmsKeyServiceAccount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CustomerEncryptionKey
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CustomerEncryptionKey.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CustomerEncryptionKey is not found in the empty JSON string", CustomerEncryptionKey.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CustomerEncryptionKey.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CustomerEncryptionKey` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("kmsKey") != null && !jsonObj.get("kmsKey").isJsonNull()) && !jsonObj.get("kmsKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmsKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmsKey").toString()));
      }
      if ((jsonObj.get("kmsKeyServiceAccount") != null && !jsonObj.get("kmsKeyServiceAccount").isJsonNull()) && !jsonObj.get("kmsKeyServiceAccount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kmsKeyServiceAccount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kmsKeyServiceAccount").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CustomerEncryptionKey.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CustomerEncryptionKey' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CustomerEncryptionKey> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CustomerEncryptionKey.class));

       return (TypeAdapter<T>) new TypeAdapter<CustomerEncryptionKey>() {
           @Override
           public void write(JsonWriter out, CustomerEncryptionKey value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CustomerEncryptionKey read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CustomerEncryptionKey given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CustomerEncryptionKey
   * @throws IOException if the JSON string is invalid with respect to CustomerEncryptionKey
   */
  public static CustomerEncryptionKey fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CustomerEncryptionKey.class);
  }

  /**
   * Convert an instance of CustomerEncryptionKey to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

