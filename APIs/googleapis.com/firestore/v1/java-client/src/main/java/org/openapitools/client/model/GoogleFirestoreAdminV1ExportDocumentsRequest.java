/*
 * Cloud Firestore API
 * Accesses the NoSQL document database built for automatic scaling, high performance, and ease of application development. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The request for FirestoreAdmin.ExportDocuments.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:23.167853-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class GoogleFirestoreAdminV1ExportDocumentsRequest {
  public static final String SERIALIZED_NAME_COLLECTION_IDS = "collectionIds";
  @SerializedName(SERIALIZED_NAME_COLLECTION_IDS)
  private List<String> collectionIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_NAMESPACE_IDS = "namespaceIds";
  @SerializedName(SERIALIZED_NAME_NAMESPACE_IDS)
  private List<String> namespaceIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_OUTPUT_URI_PREFIX = "outputUriPrefix";
  @SerializedName(SERIALIZED_NAME_OUTPUT_URI_PREFIX)
  private String outputUriPrefix;

  public static final String SERIALIZED_NAME_SNAPSHOT_TIME = "snapshotTime";
  @SerializedName(SERIALIZED_NAME_SNAPSHOT_TIME)
  private String snapshotTime;

  public GoogleFirestoreAdminV1ExportDocumentsRequest() {
  }

  public GoogleFirestoreAdminV1ExportDocumentsRequest collectionIds(List<String> collectionIds) {
    this.collectionIds = collectionIds;
    return this;
  }

  public GoogleFirestoreAdminV1ExportDocumentsRequest addCollectionIdsItem(String collectionIdsItem) {
    if (this.collectionIds == null) {
      this.collectionIds = new ArrayList<>();
    }
    this.collectionIds.add(collectionIdsItem);
    return this;
  }

  /**
   * Which collection ids to export. Unspecified means all collections.
   * @return collectionIds
   */
  @javax.annotation.Nullable
  public List<String> getCollectionIds() {
    return collectionIds;
  }

  public void setCollectionIds(List<String> collectionIds) {
    this.collectionIds = collectionIds;
  }


  public GoogleFirestoreAdminV1ExportDocumentsRequest namespaceIds(List<String> namespaceIds) {
    this.namespaceIds = namespaceIds;
    return this;
  }

  public GoogleFirestoreAdminV1ExportDocumentsRequest addNamespaceIdsItem(String namespaceIdsItem) {
    if (this.namespaceIds == null) {
      this.namespaceIds = new ArrayList<>();
    }
    this.namespaceIds.add(namespaceIdsItem);
    return this;
  }

  /**
   * An empty list represents all namespaces. This is the preferred usage for databases that don&#39;t use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn&#39;t want to include them. Each namespace in this list must be unique.
   * @return namespaceIds
   */
  @javax.annotation.Nullable
  public List<String> getNamespaceIds() {
    return namespaceIds;
  }

  public void setNamespaceIds(List<String> namespaceIds) {
    this.namespaceIds = namespaceIds;
  }


  public GoogleFirestoreAdminV1ExportDocumentsRequest outputUriPrefix(String outputUriPrefix) {
    this.outputUriPrefix = outputUriPrefix;
    return this;
  }

  /**
   * The output URI. Currently only supports Google Cloud Storage URIs of the form: &#x60;gs://BUCKET_NAME[/NAMESPACE_PATH]&#x60;, where &#x60;BUCKET_NAME&#x60; is the name of the Google Cloud Storage bucket and &#x60;NAMESPACE_PATH&#x60; is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time.
   * @return outputUriPrefix
   */
  @javax.annotation.Nullable
  public String getOutputUriPrefix() {
    return outputUriPrefix;
  }

  public void setOutputUriPrefix(String outputUriPrefix) {
    this.outputUriPrefix = outputUriPrefix;
  }


  public GoogleFirestoreAdminV1ExportDocumentsRequest snapshotTime(String snapshotTime) {
    this.snapshotTime = snapshotTime;
    return this;
  }

  /**
   * The timestamp that corresponds to the version of the database to be exported. The timestamp must be in the past, rounded to the minute and not older than earliestVersionTime. If specified, then the exported documents will represent a consistent view of the database at the provided time. Otherwise, there are no guarantees about the consistency of the exported documents.
   * @return snapshotTime
   */
  @javax.annotation.Nullable
  public String getSnapshotTime() {
    return snapshotTime;
  }

  public void setSnapshotTime(String snapshotTime) {
    this.snapshotTime = snapshotTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GoogleFirestoreAdminV1ExportDocumentsRequest googleFirestoreAdminV1ExportDocumentsRequest = (GoogleFirestoreAdminV1ExportDocumentsRequest) o;
    return Objects.equals(this.collectionIds, googleFirestoreAdminV1ExportDocumentsRequest.collectionIds) &&
        Objects.equals(this.namespaceIds, googleFirestoreAdminV1ExportDocumentsRequest.namespaceIds) &&
        Objects.equals(this.outputUriPrefix, googleFirestoreAdminV1ExportDocumentsRequest.outputUriPrefix) &&
        Objects.equals(this.snapshotTime, googleFirestoreAdminV1ExportDocumentsRequest.snapshotTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(collectionIds, namespaceIds, outputUriPrefix, snapshotTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GoogleFirestoreAdminV1ExportDocumentsRequest {\n");
    sb.append("    collectionIds: ").append(toIndentedString(collectionIds)).append("\n");
    sb.append("    namespaceIds: ").append(toIndentedString(namespaceIds)).append("\n");
    sb.append("    outputUriPrefix: ").append(toIndentedString(outputUriPrefix)).append("\n");
    sb.append("    snapshotTime: ").append(toIndentedString(snapshotTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("collectionIds");
    openapiFields.add("namespaceIds");
    openapiFields.add("outputUriPrefix");
    openapiFields.add("snapshotTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to GoogleFirestoreAdminV1ExportDocumentsRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GoogleFirestoreAdminV1ExportDocumentsRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GoogleFirestoreAdminV1ExportDocumentsRequest is not found in the empty JSON string", GoogleFirestoreAdminV1ExportDocumentsRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GoogleFirestoreAdminV1ExportDocumentsRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GoogleFirestoreAdminV1ExportDocumentsRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("collectionIds") != null && !jsonObj.get("collectionIds").isJsonNull() && !jsonObj.get("collectionIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `collectionIds` to be an array in the JSON string but got `%s`", jsonObj.get("collectionIds").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("namespaceIds") != null && !jsonObj.get("namespaceIds").isJsonNull() && !jsonObj.get("namespaceIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `namespaceIds` to be an array in the JSON string but got `%s`", jsonObj.get("namespaceIds").toString()));
      }
      if ((jsonObj.get("outputUriPrefix") != null && !jsonObj.get("outputUriPrefix").isJsonNull()) && !jsonObj.get("outputUriPrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outputUriPrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outputUriPrefix").toString()));
      }
      if ((jsonObj.get("snapshotTime") != null && !jsonObj.get("snapshotTime").isJsonNull()) && !jsonObj.get("snapshotTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `snapshotTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("snapshotTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GoogleFirestoreAdminV1ExportDocumentsRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GoogleFirestoreAdminV1ExportDocumentsRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GoogleFirestoreAdminV1ExportDocumentsRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GoogleFirestoreAdminV1ExportDocumentsRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<GoogleFirestoreAdminV1ExportDocumentsRequest>() {
           @Override
           public void write(JsonWriter out, GoogleFirestoreAdminV1ExportDocumentsRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GoogleFirestoreAdminV1ExportDocumentsRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of GoogleFirestoreAdminV1ExportDocumentsRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of GoogleFirestoreAdminV1ExportDocumentsRequest
   * @throws IOException if the JSON string is invalid with respect to GoogleFirestoreAdminV1ExportDocumentsRequest
   */
  public static GoogleFirestoreAdminV1ExportDocumentsRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GoogleFirestoreAdminV1ExportDocumentsRequest.class);
  }

  /**
   * Convert an instance of GoogleFirestoreAdminV1ExportDocumentsRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

