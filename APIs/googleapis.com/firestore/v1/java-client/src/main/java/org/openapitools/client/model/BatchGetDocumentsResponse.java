/*
 * Cloud Firestore API
 * Accesses the NoSQL document database built for automatic scaling, high performance, and ease of application development. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Document;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The streamed response for Firestore.BatchGetDocuments.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:23.167853-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class BatchGetDocumentsResponse {
  public static final String SERIALIZED_NAME_FOUND = "found";
  @SerializedName(SERIALIZED_NAME_FOUND)
  private Document found;

  public static final String SERIALIZED_NAME_MISSING = "missing";
  @SerializedName(SERIALIZED_NAME_MISSING)
  private String missing;

  public static final String SERIALIZED_NAME_READ_TIME = "readTime";
  @SerializedName(SERIALIZED_NAME_READ_TIME)
  private String readTime;

  public static final String SERIALIZED_NAME_TRANSACTION = "transaction";
  @SerializedName(SERIALIZED_NAME_TRANSACTION)
  private byte[] transaction;

  public BatchGetDocumentsResponse() {
  }

  public BatchGetDocumentsResponse found(Document found) {
    this.found = found;
    return this;
  }

  /**
   * Get found
   * @return found
   */
  @javax.annotation.Nullable
  public Document getFound() {
    return found;
  }

  public void setFound(Document found) {
    this.found = found;
  }


  public BatchGetDocumentsResponse missing(String missing) {
    this.missing = missing;
    return this;
  }

  /**
   * A document name that was requested but does not exist. In the format: &#x60;projects/{project_id}/databases/{database_id}/documents/{document_path}&#x60;.
   * @return missing
   */
  @javax.annotation.Nullable
  public String getMissing() {
    return missing;
  }

  public void setMissing(String missing) {
    this.missing = missing;
  }


  public BatchGetDocumentsResponse readTime(String readTime) {
    this.readTime = readTime;
    return this;
  }

  /**
   * The time at which the document was read. This may be monotically increasing, in this case the previous documents in the result stream are guaranteed not to have changed between their read_time and this one.
   * @return readTime
   */
  @javax.annotation.Nullable
  public String getReadTime() {
    return readTime;
  }

  public void setReadTime(String readTime) {
    this.readTime = readTime;
  }


  public BatchGetDocumentsResponse transaction(byte[] transaction) {
    this.transaction = transaction;
    return this;
  }

  /**
   * The transaction that was started as part of this request. Will only be set in the first response, and only if BatchGetDocumentsRequest.new_transaction was set in the request.
   * @return transaction
   */
  @javax.annotation.Nullable
  public byte[] getTransaction() {
    return transaction;
  }

  public void setTransaction(byte[] transaction) {
    this.transaction = transaction;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BatchGetDocumentsResponse batchGetDocumentsResponse = (BatchGetDocumentsResponse) o;
    return Objects.equals(this.found, batchGetDocumentsResponse.found) &&
        Objects.equals(this.missing, batchGetDocumentsResponse.missing) &&
        Objects.equals(this.readTime, batchGetDocumentsResponse.readTime) &&
        Arrays.equals(this.transaction, batchGetDocumentsResponse.transaction);
  }

  @Override
  public int hashCode() {
    return Objects.hash(found, missing, readTime, Arrays.hashCode(transaction));
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BatchGetDocumentsResponse {\n");
    sb.append("    found: ").append(toIndentedString(found)).append("\n");
    sb.append("    missing: ").append(toIndentedString(missing)).append("\n");
    sb.append("    readTime: ").append(toIndentedString(readTime)).append("\n");
    sb.append("    transaction: ").append(toIndentedString(transaction)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("found");
    openapiFields.add("missing");
    openapiFields.add("readTime");
    openapiFields.add("transaction");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BatchGetDocumentsResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BatchGetDocumentsResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BatchGetDocumentsResponse is not found in the empty JSON string", BatchGetDocumentsResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BatchGetDocumentsResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BatchGetDocumentsResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `found`
      if (jsonObj.get("found") != null && !jsonObj.get("found").isJsonNull()) {
        Document.validateJsonElement(jsonObj.get("found"));
      }
      if ((jsonObj.get("missing") != null && !jsonObj.get("missing").isJsonNull()) && !jsonObj.get("missing").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `missing` to be a primitive type in the JSON string but got `%s`", jsonObj.get("missing").toString()));
      }
      if ((jsonObj.get("readTime") != null && !jsonObj.get("readTime").isJsonNull()) && !jsonObj.get("readTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `readTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("readTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BatchGetDocumentsResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BatchGetDocumentsResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BatchGetDocumentsResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BatchGetDocumentsResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<BatchGetDocumentsResponse>() {
           @Override
           public void write(JsonWriter out, BatchGetDocumentsResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BatchGetDocumentsResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BatchGetDocumentsResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BatchGetDocumentsResponse
   * @throws IOException if the JSON string is invalid with respect to BatchGetDocumentsResponse
   */
  public static BatchGetDocumentsResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BatchGetDocumentsResponse.class);
  }

  /**
   * Convert an instance of BatchGetDocumentsResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

