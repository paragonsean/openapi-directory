/**
 * Cloud Firestore API
 * Accesses the NoSQL document database built for automatic scaling, high performance, and ease of application development. 
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import CollectionSelector from './CollectionSelector';
import Cursor from './Cursor';
import Filter from './Filter';
import Order from './Order';
import Projection from './Projection';

/**
 * The StructuredQuery model module.
 * @module model/StructuredQuery
 * @version v1beta1
 */
class StructuredQuery {
    /**
     * Constructs a new <code>StructuredQuery</code>.
     * A Firestore query. The query stages are executed in the following order: 1. from 2. where 3. select 4. order_by + start_at + end_at 5. offset 6. limit
     * @alias module:model/StructuredQuery
     */
    constructor() { 
        
        StructuredQuery.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>StructuredQuery</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/StructuredQuery} obj Optional instance to populate.
     * @return {module:model/StructuredQuery} The populated <code>StructuredQuery</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new StructuredQuery();

            if (data.hasOwnProperty('endAt')) {
                obj['endAt'] = Cursor.constructFromObject(data['endAt']);
            }
            if (data.hasOwnProperty('from')) {
                obj['from'] = ApiClient.convertToType(data['from'], [CollectionSelector]);
            }
            if (data.hasOwnProperty('limit')) {
                obj['limit'] = ApiClient.convertToType(data['limit'], 'Number');
            }
            if (data.hasOwnProperty('offset')) {
                obj['offset'] = ApiClient.convertToType(data['offset'], 'Number');
            }
            if (data.hasOwnProperty('orderBy')) {
                obj['orderBy'] = ApiClient.convertToType(data['orderBy'], [Order]);
            }
            if (data.hasOwnProperty('select')) {
                obj['select'] = Projection.constructFromObject(data['select']);
            }
            if (data.hasOwnProperty('startAt')) {
                obj['startAt'] = Cursor.constructFromObject(data['startAt']);
            }
            if (data.hasOwnProperty('where')) {
                obj['where'] = Filter.constructFromObject(data['where']);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>StructuredQuery</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>StructuredQuery</code>.
     */
    static validateJSON(data) {
        // validate the optional field `endAt`
        if (data['endAt']) { // data not null
          Cursor.validateJSON(data['endAt']);
        }
        if (data['from']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['from'])) {
                throw new Error("Expected the field `from` to be an array in the JSON data but got " + data['from']);
            }
            // validate the optional field `from` (array)
            for (const item of data['from']) {
                CollectionSelector.validateJSON(item);
            };
        }
        if (data['orderBy']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['orderBy'])) {
                throw new Error("Expected the field `orderBy` to be an array in the JSON data but got " + data['orderBy']);
            }
            // validate the optional field `orderBy` (array)
            for (const item of data['orderBy']) {
                Order.validateJSON(item);
            };
        }
        // validate the optional field `select`
        if (data['select']) { // data not null
          Projection.validateJSON(data['select']);
        }
        // validate the optional field `startAt`
        if (data['startAt']) { // data not null
          Cursor.validateJSON(data['startAt']);
        }
        // validate the optional field `where`
        if (data['where']) { // data not null
          Filter.validateJSON(data['where']);
        }

        return true;
    }


}



/**
 * @member {module:model/Cursor} endAt
 */
StructuredQuery.prototype['endAt'] = undefined;

/**
 * The collections to query.
 * @member {Array.<module:model/CollectionSelector>} from
 */
StructuredQuery.prototype['from'] = undefined;

/**
 * The maximum number of results to return. Applies after all other constraints. Requires: * The value must be greater than or equal to zero if specified.
 * @member {Number} limit
 */
StructuredQuery.prototype['limit'] = undefined;

/**
 * The number of documents to skip before returning the first result. This applies after the constraints specified by the `WHERE`, `START AT`, & `END AT` but before the `LIMIT` clause. Requires: * The value must be greater than or equal to zero if specified.
 * @member {Number} offset
 */
StructuredQuery.prototype['offset'] = undefined;

/**
 * The order to apply to the query results. Firestore allows callers to provide a full ordering, a partial ordering, or no ordering at all. In all cases, Firestore guarantees a stable ordering through the following rules: * The `order_by` is required to reference all fields used with an inequality filter. * All fields that are required to be in the `order_by` but are not already present are appended in lexicographical ordering of the field name. * If an order on `__name__` is not specified, it is appended by default. Fields are appended with the same sort direction as the last order specified, or 'ASCENDING' if no order was specified. For example: * `ORDER BY a` becomes `ORDER BY a ASC, __name__ ASC` * `ORDER BY a DESC` becomes `ORDER BY a DESC, __name__ DESC` * `WHERE a > 1` becomes `WHERE a > 1 ORDER BY a ASC, __name__ ASC` * `WHERE __name__ > ... AND a > 1` becomes `WHERE __name__ > ... AND a > 1 ORDER BY a ASC, __name__ ASC`
 * @member {Array.<module:model/Order>} orderBy
 */
StructuredQuery.prototype['orderBy'] = undefined;

/**
 * @member {module:model/Projection} select
 */
StructuredQuery.prototype['select'] = undefined;

/**
 * @member {module:model/Cursor} startAt
 */
StructuredQuery.prototype['startAt'] = undefined;

/**
 * @member {module:model/Filter} where
 */
StructuredQuery.prototype['where'] = undefined;






export default StructuredQuery;

