/*
 * BigQuery Reservation API
 * A service to modify your BigQuery flat-rate reservations.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Status;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Capacity commitment is a way to purchase compute capacity for BigQuery jobs (in the form of slots) with some committed period of usage. Annual commitments renew by default. Commitments can be removed after their commitment end time passes. In order to remove annual commitment, its plan needs to be changed to monthly or flex first. A capacity commitment resource exists as a child resource of the admin project.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:05.740947-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CapacityCommitment {
  public static final String SERIALIZED_NAME_COMMITMENT_END_TIME = "commitmentEndTime";
  @SerializedName(SERIALIZED_NAME_COMMITMENT_END_TIME)
  private String commitmentEndTime;

  public static final String SERIALIZED_NAME_COMMITMENT_START_TIME = "commitmentStartTime";
  @SerializedName(SERIALIZED_NAME_COMMITMENT_START_TIME)
  private String commitmentStartTime;

  public static final String SERIALIZED_NAME_FAILURE_STATUS = "failureStatus";
  @SerializedName(SERIALIZED_NAME_FAILURE_STATUS)
  private Status failureStatus;

  public static final String SERIALIZED_NAME_MULTI_REGION_AUXILIARY = "multiRegionAuxiliary";
  @SerializedName(SERIALIZED_NAME_MULTI_REGION_AUXILIARY)
  private Boolean multiRegionAuxiliary;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  /**
   * Capacity commitment commitment plan.
   */
  @JsonAdapter(PlanEnum.Adapter.class)
  public enum PlanEnum {
    COMMITMENT_PLAN_UNSPECIFIED("COMMITMENT_PLAN_UNSPECIFIED"),
    
    FLEX("FLEX"),
    
    TRIAL("TRIAL"),
    
    MONTHLY("MONTHLY"),
    
    ANNUAL("ANNUAL");

    private String value;

    PlanEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PlanEnum fromValue(String value) {
      for (PlanEnum b : PlanEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PlanEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PlanEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PlanEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PlanEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PlanEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PLAN = "plan";
  @SerializedName(SERIALIZED_NAME_PLAN)
  private PlanEnum plan;

  /**
   * The plan this capacity commitment is converted to after commitment_end_time passes. Once the plan is changed, committed period is extended according to commitment plan. Only applicable for ANNUAL commitments.
   */
  @JsonAdapter(RenewalPlanEnum.Adapter.class)
  public enum RenewalPlanEnum {
    COMMITMENT_PLAN_UNSPECIFIED("COMMITMENT_PLAN_UNSPECIFIED"),
    
    FLEX("FLEX"),
    
    TRIAL("TRIAL"),
    
    MONTHLY("MONTHLY"),
    
    ANNUAL("ANNUAL");

    private String value;

    RenewalPlanEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RenewalPlanEnum fromValue(String value) {
      for (RenewalPlanEnum b : RenewalPlanEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RenewalPlanEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RenewalPlanEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RenewalPlanEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RenewalPlanEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RenewalPlanEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RENEWAL_PLAN = "renewalPlan";
  @SerializedName(SERIALIZED_NAME_RENEWAL_PLAN)
  private RenewalPlanEnum renewalPlan;

  public static final String SERIALIZED_NAME_SLOT_COUNT = "slotCount";
  @SerializedName(SERIALIZED_NAME_SLOT_COUNT)
  private String slotCount;

  /**
   * Output only. State of the commitment.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    PENDING("PENDING"),
    
    ACTIVE("ACTIVE"),
    
    FAILED("FAILED");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public CapacityCommitment() {
  }

  public CapacityCommitment(
     String commitmentEndTime, 
     String commitmentStartTime, 
     String name, 
     StateEnum state
  ) {
    this();
    this.commitmentEndTime = commitmentEndTime;
    this.commitmentStartTime = commitmentStartTime;
    this.name = name;
    this.state = state;
  }

  /**
   * Output only. The end of the current commitment period. It is applicable only for ACTIVE capacity commitments.
   * @return commitmentEndTime
   */
  @javax.annotation.Nullable
  public String getCommitmentEndTime() {
    return commitmentEndTime;
  }



  /**
   * Output only. The start of the current commitment period. It is applicable only for ACTIVE capacity commitments.
   * @return commitmentStartTime
   */
  @javax.annotation.Nullable
  public String getCommitmentStartTime() {
    return commitmentStartTime;
  }



  public CapacityCommitment failureStatus(Status failureStatus) {
    this.failureStatus = failureStatus;
    return this;
  }

  /**
   * Get failureStatus
   * @return failureStatus
   */
  @javax.annotation.Nullable
  public Status getFailureStatus() {
    return failureStatus;
  }

  public void setFailureStatus(Status failureStatus) {
    this.failureStatus = failureStatus;
  }


  public CapacityCommitment multiRegionAuxiliary(Boolean multiRegionAuxiliary) {
    this.multiRegionAuxiliary = multiRegionAuxiliary;
    return this;
  }

  /**
   * Applicable only for commitments located within one of the BigQuery multi-regions (US or EU). If set to true, this commitment is placed in the organization&#39;s secondary region which is designated for disaster recovery purposes. If false, this commitment is placed in the organization&#39;s default region.
   * @return multiRegionAuxiliary
   */
  @javax.annotation.Nullable
  public Boolean getMultiRegionAuxiliary() {
    return multiRegionAuxiliary;
  }

  public void setMultiRegionAuxiliary(Boolean multiRegionAuxiliary) {
    this.multiRegionAuxiliary = multiRegionAuxiliary;
  }


  /**
   * Output only. The resource name of the capacity commitment, e.g., &#x60;projects/myproject/locations/US/capacityCommitments/123&#x60; The commitment_id must only contain lower case alphanumeric characters or dashes. It must start with a letter and must not end with a dash. Its maximum length is 64 characters.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  public CapacityCommitment plan(PlanEnum plan) {
    this.plan = plan;
    return this;
  }

  /**
   * Capacity commitment commitment plan.
   * @return plan
   */
  @javax.annotation.Nullable
  public PlanEnum getPlan() {
    return plan;
  }

  public void setPlan(PlanEnum plan) {
    this.plan = plan;
  }


  public CapacityCommitment renewalPlan(RenewalPlanEnum renewalPlan) {
    this.renewalPlan = renewalPlan;
    return this;
  }

  /**
   * The plan this capacity commitment is converted to after commitment_end_time passes. Once the plan is changed, committed period is extended according to commitment plan. Only applicable for ANNUAL commitments.
   * @return renewalPlan
   */
  @javax.annotation.Nullable
  public RenewalPlanEnum getRenewalPlan() {
    return renewalPlan;
  }

  public void setRenewalPlan(RenewalPlanEnum renewalPlan) {
    this.renewalPlan = renewalPlan;
  }


  public CapacityCommitment slotCount(String slotCount) {
    this.slotCount = slotCount;
    return this;
  }

  /**
   * Number of slots in this commitment.
   * @return slotCount
   */
  @javax.annotation.Nullable
  public String getSlotCount() {
    return slotCount;
  }

  public void setSlotCount(String slotCount) {
    this.slotCount = slotCount;
  }


  /**
   * Output only. State of the commitment.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CapacityCommitment capacityCommitment = (CapacityCommitment) o;
    return Objects.equals(this.commitmentEndTime, capacityCommitment.commitmentEndTime) &&
        Objects.equals(this.commitmentStartTime, capacityCommitment.commitmentStartTime) &&
        Objects.equals(this.failureStatus, capacityCommitment.failureStatus) &&
        Objects.equals(this.multiRegionAuxiliary, capacityCommitment.multiRegionAuxiliary) &&
        Objects.equals(this.name, capacityCommitment.name) &&
        Objects.equals(this.plan, capacityCommitment.plan) &&
        Objects.equals(this.renewalPlan, capacityCommitment.renewalPlan) &&
        Objects.equals(this.slotCount, capacityCommitment.slotCount) &&
        Objects.equals(this.state, capacityCommitment.state);
  }

  @Override
  public int hashCode() {
    return Objects.hash(commitmentEndTime, commitmentStartTime, failureStatus, multiRegionAuxiliary, name, plan, renewalPlan, slotCount, state);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CapacityCommitment {\n");
    sb.append("    commitmentEndTime: ").append(toIndentedString(commitmentEndTime)).append("\n");
    sb.append("    commitmentStartTime: ").append(toIndentedString(commitmentStartTime)).append("\n");
    sb.append("    failureStatus: ").append(toIndentedString(failureStatus)).append("\n");
    sb.append("    multiRegionAuxiliary: ").append(toIndentedString(multiRegionAuxiliary)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    plan: ").append(toIndentedString(plan)).append("\n");
    sb.append("    renewalPlan: ").append(toIndentedString(renewalPlan)).append("\n");
    sb.append("    slotCount: ").append(toIndentedString(slotCount)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("commitmentEndTime");
    openapiFields.add("commitmentStartTime");
    openapiFields.add("failureStatus");
    openapiFields.add("multiRegionAuxiliary");
    openapiFields.add("name");
    openapiFields.add("plan");
    openapiFields.add("renewalPlan");
    openapiFields.add("slotCount");
    openapiFields.add("state");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CapacityCommitment
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CapacityCommitment.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CapacityCommitment is not found in the empty JSON string", CapacityCommitment.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CapacityCommitment.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CapacityCommitment` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("commitmentEndTime") != null && !jsonObj.get("commitmentEndTime").isJsonNull()) && !jsonObj.get("commitmentEndTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `commitmentEndTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("commitmentEndTime").toString()));
      }
      if ((jsonObj.get("commitmentStartTime") != null && !jsonObj.get("commitmentStartTime").isJsonNull()) && !jsonObj.get("commitmentStartTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `commitmentStartTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("commitmentStartTime").toString()));
      }
      // validate the optional field `failureStatus`
      if (jsonObj.get("failureStatus") != null && !jsonObj.get("failureStatus").isJsonNull()) {
        Status.validateJsonElement(jsonObj.get("failureStatus"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("plan") != null && !jsonObj.get("plan").isJsonNull()) && !jsonObj.get("plan").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `plan` to be a primitive type in the JSON string but got `%s`", jsonObj.get("plan").toString()));
      }
      // validate the optional field `plan`
      if (jsonObj.get("plan") != null && !jsonObj.get("plan").isJsonNull()) {
        PlanEnum.validateJsonElement(jsonObj.get("plan"));
      }
      if ((jsonObj.get("renewalPlan") != null && !jsonObj.get("renewalPlan").isJsonNull()) && !jsonObj.get("renewalPlan").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `renewalPlan` to be a primitive type in the JSON string but got `%s`", jsonObj.get("renewalPlan").toString()));
      }
      // validate the optional field `renewalPlan`
      if (jsonObj.get("renewalPlan") != null && !jsonObj.get("renewalPlan").isJsonNull()) {
        RenewalPlanEnum.validateJsonElement(jsonObj.get("renewalPlan"));
      }
      if ((jsonObj.get("slotCount") != null && !jsonObj.get("slotCount").isJsonNull()) && !jsonObj.get("slotCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `slotCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("slotCount").toString()));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CapacityCommitment.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CapacityCommitment' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CapacityCommitment> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CapacityCommitment.class));

       return (TypeAdapter<T>) new TypeAdapter<CapacityCommitment>() {
           @Override
           public void write(JsonWriter out, CapacityCommitment value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CapacityCommitment read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CapacityCommitment given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CapacityCommitment
   * @throws IOException if the JSON string is invalid with respect to CapacityCommitment
   */
  public static CapacityCommitment fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CapacityCommitment.class);
  }

  /**
   * Convert an instance of CapacityCommitment to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

