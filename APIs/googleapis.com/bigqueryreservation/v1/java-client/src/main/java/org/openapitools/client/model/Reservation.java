/*
 * BigQuery Reservation API
 * A service to modify your BigQuery flat-rate reservations.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.Autoscale;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A reservation is a mechanism used to guarantee slots to users.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:04.502860-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Reservation {
  public static final String SERIALIZED_NAME_AUTOSCALE = "autoscale";
  @SerializedName(SERIALIZED_NAME_AUTOSCALE)
  private Autoscale autoscale;

  public static final String SERIALIZED_NAME_CONCURRENCY = "concurrency";
  @SerializedName(SERIALIZED_NAME_CONCURRENCY)
  private String concurrency;

  public static final String SERIALIZED_NAME_CREATION_TIME = "creationTime";
  @SerializedName(SERIALIZED_NAME_CREATION_TIME)
  private String creationTime;

  /**
   * Edition of the reservation.
   */
  @JsonAdapter(EditionEnum.Adapter.class)
  public enum EditionEnum {
    EDITION_UNSPECIFIED("EDITION_UNSPECIFIED"),
    
    STANDARD("STANDARD"),
    
    ENTERPRISE("ENTERPRISE"),
    
    ENTERPRISE_PLUS("ENTERPRISE_PLUS");

    private String value;

    EditionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EditionEnum fromValue(String value) {
      for (EditionEnum b : EditionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EditionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EditionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EditionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EditionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EditionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EDITION = "edition";
  @SerializedName(SERIALIZED_NAME_EDITION)
  private EditionEnum edition;

  public static final String SERIALIZED_NAME_IGNORE_IDLE_SLOTS = "ignoreIdleSlots";
  @SerializedName(SERIALIZED_NAME_IGNORE_IDLE_SLOTS)
  private Boolean ignoreIdleSlots;

  public static final String SERIALIZED_NAME_MULTI_REGION_AUXILIARY = "multiRegionAuxiliary";
  @SerializedName(SERIALIZED_NAME_MULTI_REGION_AUXILIARY)
  private Boolean multiRegionAuxiliary;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SLOT_CAPACITY = "slotCapacity";
  @SerializedName(SERIALIZED_NAME_SLOT_CAPACITY)
  private String slotCapacity;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public Reservation() {
  }

  public Reservation(
     String creationTime, 
     String updateTime
  ) {
    this();
    this.creationTime = creationTime;
    this.updateTime = updateTime;
  }

  public Reservation autoscale(Autoscale autoscale) {
    this.autoscale = autoscale;
    return this;
  }

  /**
   * Get autoscale
   * @return autoscale
   */
  @javax.annotation.Nullable
  public Autoscale getAutoscale() {
    return autoscale;
  }

  public void setAutoscale(Autoscale autoscale) {
    this.autoscale = autoscale;
  }


  public Reservation concurrency(String concurrency) {
    this.concurrency = concurrency;
    return this;
  }

  /**
   * Job concurrency target which sets a soft upper bound on the number of jobs that can run concurrently in this reservation. This is a soft target due to asynchronous nature of the system and various optimizations for small queries. Default value is 0 which means that concurrency target will be automatically computed by the system. NOTE: this field is exposed as &#x60;target_job_concurrency&#x60; in the Information Schema, DDL and BQ CLI.
   * @return concurrency
   */
  @javax.annotation.Nullable
  public String getConcurrency() {
    return concurrency;
  }

  public void setConcurrency(String concurrency) {
    this.concurrency = concurrency;
  }


  /**
   * Output only. Creation time of the reservation.
   * @return creationTime
   */
  @javax.annotation.Nullable
  public String getCreationTime() {
    return creationTime;
  }



  public Reservation edition(EditionEnum edition) {
    this.edition = edition;
    return this;
  }

  /**
   * Edition of the reservation.
   * @return edition
   */
  @javax.annotation.Nullable
  public EditionEnum getEdition() {
    return edition;
  }

  public void setEdition(EditionEnum edition) {
    this.edition = edition;
  }


  public Reservation ignoreIdleSlots(Boolean ignoreIdleSlots) {
    this.ignoreIdleSlots = ignoreIdleSlots;
    return this;
  }

  /**
   * If false, any query or pipeline job using this reservation will use idle slots from other reservations within the same admin project. If true, a query or pipeline job using this reservation will execute with the slot capacity specified in the slot_capacity field at most.
   * @return ignoreIdleSlots
   */
  @javax.annotation.Nullable
  public Boolean getIgnoreIdleSlots() {
    return ignoreIdleSlots;
  }

  public void setIgnoreIdleSlots(Boolean ignoreIdleSlots) {
    this.ignoreIdleSlots = ignoreIdleSlots;
  }


  public Reservation multiRegionAuxiliary(Boolean multiRegionAuxiliary) {
    this.multiRegionAuxiliary = multiRegionAuxiliary;
    return this;
  }

  /**
   * Applicable only for reservations located within one of the BigQuery multi-regions (US or EU). If set to true, this reservation is placed in the organization&#39;s secondary region which is designated for disaster recovery purposes. If false, this reservation is placed in the organization&#39;s default region. NOTE: this is a preview feature. Project must be allow-listed in order to set this field.
   * @return multiRegionAuxiliary
   */
  @javax.annotation.Nullable
  public Boolean getMultiRegionAuxiliary() {
    return multiRegionAuxiliary;
  }

  public void setMultiRegionAuxiliary(Boolean multiRegionAuxiliary) {
    this.multiRegionAuxiliary = multiRegionAuxiliary;
  }


  public Reservation name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The resource name of the reservation, e.g., &#x60;projects/_*_/locations/_*_/reservations/team1-prod&#x60;. The reservation_id must only contain lower case alphanumeric characters or dashes. It must start with a letter and must not end with a dash. Its maximum length is 64 characters.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Reservation slotCapacity(String slotCapacity) {
    this.slotCapacity = slotCapacity;
    return this;
  }

  /**
   * Baseline slots available to this reservation. A slot is a unit of computational power in BigQuery, and serves as the unit of parallelism. Queries using this reservation might use more slots during runtime if ignore_idle_slots is set to false, or autoscaling is enabled. If edition is EDITION_UNSPECIFIED and total slot_capacity of the reservation and its siblings exceeds the total slot_count of all capacity commitments, the request will fail with &#x60;google.rpc.Code.RESOURCE_EXHAUSTED&#x60;. If edition is any value but EDITION_UNSPECIFIED, then the above requirement is not needed. The total slot_capacity of the reservation and its siblings may exceed the total slot_count of capacity commitments. In that case, the exceeding slots will be charged with the autoscale SKU. You can increase the number of baseline slots in a reservation every few minutes. If you want to decrease your baseline slots, you are limited to once an hour if you have recently changed your baseline slot capacity and your baseline slots exceed your committed slots. Otherwise, you can decrease your baseline slots every few minutes.
   * @return slotCapacity
   */
  @javax.annotation.Nullable
  public String getSlotCapacity() {
    return slotCapacity;
  }

  public void setSlotCapacity(String slotCapacity) {
    this.slotCapacity = slotCapacity;
  }


  /**
   * Output only. Last update time of the reservation.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Reservation reservation = (Reservation) o;
    return Objects.equals(this.autoscale, reservation.autoscale) &&
        Objects.equals(this.concurrency, reservation.concurrency) &&
        Objects.equals(this.creationTime, reservation.creationTime) &&
        Objects.equals(this.edition, reservation.edition) &&
        Objects.equals(this.ignoreIdleSlots, reservation.ignoreIdleSlots) &&
        Objects.equals(this.multiRegionAuxiliary, reservation.multiRegionAuxiliary) &&
        Objects.equals(this.name, reservation.name) &&
        Objects.equals(this.slotCapacity, reservation.slotCapacity) &&
        Objects.equals(this.updateTime, reservation.updateTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(autoscale, concurrency, creationTime, edition, ignoreIdleSlots, multiRegionAuxiliary, name, slotCapacity, updateTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Reservation {\n");
    sb.append("    autoscale: ").append(toIndentedString(autoscale)).append("\n");
    sb.append("    concurrency: ").append(toIndentedString(concurrency)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("    edition: ").append(toIndentedString(edition)).append("\n");
    sb.append("    ignoreIdleSlots: ").append(toIndentedString(ignoreIdleSlots)).append("\n");
    sb.append("    multiRegionAuxiliary: ").append(toIndentedString(multiRegionAuxiliary)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    slotCapacity: ").append(toIndentedString(slotCapacity)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("autoscale");
    openapiFields.add("concurrency");
    openapiFields.add("creationTime");
    openapiFields.add("edition");
    openapiFields.add("ignoreIdleSlots");
    openapiFields.add("multiRegionAuxiliary");
    openapiFields.add("name");
    openapiFields.add("slotCapacity");
    openapiFields.add("updateTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Reservation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Reservation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Reservation is not found in the empty JSON string", Reservation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Reservation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Reservation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `autoscale`
      if (jsonObj.get("autoscale") != null && !jsonObj.get("autoscale").isJsonNull()) {
        Autoscale.validateJsonElement(jsonObj.get("autoscale"));
      }
      if ((jsonObj.get("concurrency") != null && !jsonObj.get("concurrency").isJsonNull()) && !jsonObj.get("concurrency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `concurrency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("concurrency").toString()));
      }
      if ((jsonObj.get("creationTime") != null && !jsonObj.get("creationTime").isJsonNull()) && !jsonObj.get("creationTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `creationTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("creationTime").toString()));
      }
      if ((jsonObj.get("edition") != null && !jsonObj.get("edition").isJsonNull()) && !jsonObj.get("edition").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `edition` to be a primitive type in the JSON string but got `%s`", jsonObj.get("edition").toString()));
      }
      // validate the optional field `edition`
      if (jsonObj.get("edition") != null && !jsonObj.get("edition").isJsonNull()) {
        EditionEnum.validateJsonElement(jsonObj.get("edition"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("slotCapacity") != null && !jsonObj.get("slotCapacity").isJsonNull()) && !jsonObj.get("slotCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `slotCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("slotCapacity").toString()));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Reservation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Reservation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Reservation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Reservation.class));

       return (TypeAdapter<T>) new TypeAdapter<Reservation>() {
           @Override
           public void write(JsonWriter out, Reservation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Reservation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Reservation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Reservation
   * @throws IOException if the JSON string is invalid with respect to Reservation
   */
  public static Reservation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Reservation.class);
  }

  /**
   * Convert an instance of Reservation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

