# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.replica_info import ReplicaInfo
from openapi_server import util


class InstanceConfig(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, base_config: str=None, config_type: str=None, display_name: str=None, etag: str=None, free_instance_availability: str=None, labels: Dict[str, str]=None, leader_options: List[str]=None, name: str=None, optional_replicas: List[ReplicaInfo]=None, reconciling: bool=None, replicas: List[ReplicaInfo]=None, state: str=None, storage_limit_per_processing_unit: str=None):
        """InstanceConfig - a model defined in OpenAPI

        :param base_config: The base_config of this InstanceConfig.
        :param config_type: The config_type of this InstanceConfig.
        :param display_name: The display_name of this InstanceConfig.
        :param etag: The etag of this InstanceConfig.
        :param free_instance_availability: The free_instance_availability of this InstanceConfig.
        :param labels: The labels of this InstanceConfig.
        :param leader_options: The leader_options of this InstanceConfig.
        :param name: The name of this InstanceConfig.
        :param optional_replicas: The optional_replicas of this InstanceConfig.
        :param reconciling: The reconciling of this InstanceConfig.
        :param replicas: The replicas of this InstanceConfig.
        :param state: The state of this InstanceConfig.
        :param storage_limit_per_processing_unit: The storage_limit_per_processing_unit of this InstanceConfig.
        """
        self.openapi_types = {
            'base_config': str,
            'config_type': str,
            'display_name': str,
            'etag': str,
            'free_instance_availability': str,
            'labels': Dict[str, str],
            'leader_options': List[str],
            'name': str,
            'optional_replicas': List[ReplicaInfo],
            'reconciling': bool,
            'replicas': List[ReplicaInfo],
            'state': str,
            'storage_limit_per_processing_unit': str
        }

        self.attribute_map = {
            'base_config': 'baseConfig',
            'config_type': 'configType',
            'display_name': 'displayName',
            'etag': 'etag',
            'free_instance_availability': 'freeInstanceAvailability',
            'labels': 'labels',
            'leader_options': 'leaderOptions',
            'name': 'name',
            'optional_replicas': 'optionalReplicas',
            'reconciling': 'reconciling',
            'replicas': 'replicas',
            'state': 'state',
            'storage_limit_per_processing_unit': 'storageLimitPerProcessingUnit'
        }

        self._base_config = base_config
        self._config_type = config_type
        self._display_name = display_name
        self._etag = etag
        self._free_instance_availability = free_instance_availability
        self._labels = labels
        self._leader_options = leader_options
        self._name = name
        self._optional_replicas = optional_replicas
        self._reconciling = reconciling
        self._replicas = replicas
        self._state = state
        self._storage_limit_per_processing_unit = storage_limit_per_processing_unit

    @classmethod
    def from_dict(cls, dikt: dict) -> 'InstanceConfig':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The InstanceConfig of this InstanceConfig.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def base_config(self):
        """Gets the base_config of this InstanceConfig.

        Base configuration name, e.g. projects//instanceConfigs/nam3, based on which this configuration is created. Only set for user managed configurations. `base_config` must refer to a configuration of type GOOGLE_MANAGED in the same project as this configuration.

        :return: The base_config of this InstanceConfig.
        :rtype: str
        """
        return self._base_config

    @base_config.setter
    def base_config(self, base_config):
        """Sets the base_config of this InstanceConfig.

        Base configuration name, e.g. projects//instanceConfigs/nam3, based on which this configuration is created. Only set for user managed configurations. `base_config` must refer to a configuration of type GOOGLE_MANAGED in the same project as this configuration.

        :param base_config: The base_config of this InstanceConfig.
        :type base_config: str
        """

        self._base_config = base_config

    @property
    def config_type(self):
        """Gets the config_type of this InstanceConfig.

        Output only. Whether this instance config is a Google or User Managed Configuration.

        :return: The config_type of this InstanceConfig.
        :rtype: str
        """
        return self._config_type

    @config_type.setter
    def config_type(self, config_type):
        """Sets the config_type of this InstanceConfig.

        Output only. Whether this instance config is a Google or User Managed Configuration.

        :param config_type: The config_type of this InstanceConfig.
        :type config_type: str
        """
        allowed_values = ["TYPE_UNSPECIFIED", "GOOGLE_MANAGED", "USER_MANAGED"]  # noqa: E501
        if config_type not in allowed_values:
            raise ValueError(
                "Invalid value for `config_type` ({0}), must be one of {1}"
                .format(config_type, allowed_values)
            )

        self._config_type = config_type

    @property
    def display_name(self):
        """Gets the display_name of this InstanceConfig.

        The name of this instance configuration as it appears in UIs.

        :return: The display_name of this InstanceConfig.
        :rtype: str
        """
        return self._display_name

    @display_name.setter
    def display_name(self, display_name):
        """Sets the display_name of this InstanceConfig.

        The name of this instance configuration as it appears in UIs.

        :param display_name: The display_name of this InstanceConfig.
        :type display_name: str
        """

        self._display_name = display_name

    @property
    def etag(self):
        """Gets the etag of this InstanceConfig.

        etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a instance config from overwriting each other. It is strongly suggested that systems make use of the etag in the read-modify-write cycle to perform instance config updates in order to avoid race conditions: An etag is returned in the response which contains instance configs, and systems are expected to put that etag in the request to update instance config to ensure that their change will be applied to the same version of the instance config. If no etag is provided in the call to update instance config, then the existing instance config is overwritten blindly.

        :return: The etag of this InstanceConfig.
        :rtype: str
        """
        return self._etag

    @etag.setter
    def etag(self, etag):
        """Sets the etag of this InstanceConfig.

        etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a instance config from overwriting each other. It is strongly suggested that systems make use of the etag in the read-modify-write cycle to perform instance config updates in order to avoid race conditions: An etag is returned in the response which contains instance configs, and systems are expected to put that etag in the request to update instance config to ensure that their change will be applied to the same version of the instance config. If no etag is provided in the call to update instance config, then the existing instance config is overwritten blindly.

        :param etag: The etag of this InstanceConfig.
        :type etag: str
        """

        self._etag = etag

    @property
    def free_instance_availability(self):
        """Gets the free_instance_availability of this InstanceConfig.

        Output only. Describes whether free instances are available to be created in this instance config.

        :return: The free_instance_availability of this InstanceConfig.
        :rtype: str
        """
        return self._free_instance_availability

    @free_instance_availability.setter
    def free_instance_availability(self, free_instance_availability):
        """Sets the free_instance_availability of this InstanceConfig.

        Output only. Describes whether free instances are available to be created in this instance config.

        :param free_instance_availability: The free_instance_availability of this InstanceConfig.
        :type free_instance_availability: str
        """
        allowed_values = ["FREE_INSTANCE_AVAILABILITY_UNSPECIFIED", "AVAILABLE", "UNSUPPORTED", "DISABLED", "QUOTA_EXCEEDED"]  # noqa: E501
        if free_instance_availability not in allowed_values:
            raise ValueError(
                "Invalid value for `free_instance_availability` ({0}), must be one of {1}"
                .format(free_instance_availability, allowed_values)
            )

        self._free_instance_availability = free_instance_availability

    @property
    def labels(self):
        """Gets the labels of this InstanceConfig.

        Cloud Labels are a flexible and lightweight mechanism for organizing cloud resources into groups that reflect a customer's organizational needs and deployment strategies. Cloud Labels can be used to filter collections of resources. They can be used to control how resource metrics are aggregated. And they can be used as arguments to policy management rules (e.g. route, firewall, load balancing, etc.). * Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z{0,62}`. * Label values must be between 0 and 63 characters long and must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64 labels can be associated with a given resource. See https://goo.gl/xmQnxf for more information on and examples of labels. If you plan to use labels in your own code, please note that additional characters may be allowed in the future. Therefore, you are advised to use an internal label representation, such as JSON, which doesn't rely upon specific characters being disallowed. For example, representing labels as the string: name + \"_\" + value would prove problematic if we were to allow \"_\" in a future release.

        :return: The labels of this InstanceConfig.
        :rtype: Dict[str, str]
        """
        return self._labels

    @labels.setter
    def labels(self, labels):
        """Sets the labels of this InstanceConfig.

        Cloud Labels are a flexible and lightweight mechanism for organizing cloud resources into groups that reflect a customer's organizational needs and deployment strategies. Cloud Labels can be used to filter collections of resources. They can be used to control how resource metrics are aggregated. And they can be used as arguments to policy management rules (e.g. route, firewall, load balancing, etc.). * Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z{0,62}`. * Label values must be between 0 and 63 characters long and must conform to the regular expression `[a-z0-9_-]{0,63}`. * No more than 64 labels can be associated with a given resource. See https://goo.gl/xmQnxf for more information on and examples of labels. If you plan to use labels in your own code, please note that additional characters may be allowed in the future. Therefore, you are advised to use an internal label representation, such as JSON, which doesn't rely upon specific characters being disallowed. For example, representing labels as the string: name + \"_\" + value would prove problematic if we were to allow \"_\" in a future release.

        :param labels: The labels of this InstanceConfig.
        :type labels: Dict[str, str]
        """

        self._labels = labels

    @property
    def leader_options(self):
        """Gets the leader_options of this InstanceConfig.

        Allowed values of the \"default_leader\" schema option for databases in instances that use this instance configuration.

        :return: The leader_options of this InstanceConfig.
        :rtype: List[str]
        """
        return self._leader_options

    @leader_options.setter
    def leader_options(self, leader_options):
        """Sets the leader_options of this InstanceConfig.

        Allowed values of the \"default_leader\" schema option for databases in instances that use this instance configuration.

        :param leader_options: The leader_options of this InstanceConfig.
        :type leader_options: List[str]
        """

        self._leader_options = leader_options

    @property
    def name(self):
        """Gets the name of this InstanceConfig.

        A unique identifier for the instance configuration. Values are of the form `projects//instanceConfigs/a-z*`.

        :return: The name of this InstanceConfig.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this InstanceConfig.

        A unique identifier for the instance configuration. Values are of the form `projects//instanceConfigs/a-z*`.

        :param name: The name of this InstanceConfig.
        :type name: str
        """

        self._name = name

    @property
    def optional_replicas(self):
        """Gets the optional_replicas of this InstanceConfig.

        Output only. The available optional replicas to choose from for user managed configurations. Populated for Google managed configurations.

        :return: The optional_replicas of this InstanceConfig.
        :rtype: List[ReplicaInfo]
        """
        return self._optional_replicas

    @optional_replicas.setter
    def optional_replicas(self, optional_replicas):
        """Sets the optional_replicas of this InstanceConfig.

        Output only. The available optional replicas to choose from for user managed configurations. Populated for Google managed configurations.

        :param optional_replicas: The optional_replicas of this InstanceConfig.
        :type optional_replicas: List[ReplicaInfo]
        """

        self._optional_replicas = optional_replicas

    @property
    def reconciling(self):
        """Gets the reconciling of this InstanceConfig.

        Output only. If true, the instance config is being created or updated. If false, there are no ongoing operations for the instance config.

        :return: The reconciling of this InstanceConfig.
        :rtype: bool
        """
        return self._reconciling

    @reconciling.setter
    def reconciling(self, reconciling):
        """Sets the reconciling of this InstanceConfig.

        Output only. If true, the instance config is being created or updated. If false, there are no ongoing operations for the instance config.

        :param reconciling: The reconciling of this InstanceConfig.
        :type reconciling: bool
        """

        self._reconciling = reconciling

    @property
    def replicas(self):
        """Gets the replicas of this InstanceConfig.

        The geographic placement of nodes in this instance configuration and their replication properties.

        :return: The replicas of this InstanceConfig.
        :rtype: List[ReplicaInfo]
        """
        return self._replicas

    @replicas.setter
    def replicas(self, replicas):
        """Sets the replicas of this InstanceConfig.

        The geographic placement of nodes in this instance configuration and their replication properties.

        :param replicas: The replicas of this InstanceConfig.
        :type replicas: List[ReplicaInfo]
        """

        self._replicas = replicas

    @property
    def state(self):
        """Gets the state of this InstanceConfig.

        Output only. The current instance config state. Applicable only for USER_MANAGED configs.

        :return: The state of this InstanceConfig.
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this InstanceConfig.

        Output only. The current instance config state. Applicable only for USER_MANAGED configs.

        :param state: The state of this InstanceConfig.
        :type state: str
        """
        allowed_values = ["STATE_UNSPECIFIED", "CREATING", "READY"]  # noqa: E501
        if state not in allowed_values:
            raise ValueError(
                "Invalid value for `state` ({0}), must be one of {1}"
                .format(state, allowed_values)
            )

        self._state = state

    @property
    def storage_limit_per_processing_unit(self):
        """Gets the storage_limit_per_processing_unit of this InstanceConfig.

        Output only. The storage limit in bytes per processing unit.

        :return: The storage_limit_per_processing_unit of this InstanceConfig.
        :rtype: str
        """
        return self._storage_limit_per_processing_unit

    @storage_limit_per_processing_unit.setter
    def storage_limit_per_processing_unit(self, storage_limit_per_processing_unit):
        """Sets the storage_limit_per_processing_unit of this InstanceConfig.

        Output only. The storage limit in bytes per processing unit.

        :param storage_limit_per_processing_unit: The storage_limit_per_processing_unit of this InstanceConfig.
        :type storage_limit_per_processing_unit: str
        """

        self._storage_limit_per_processing_unit = storage_limit_per_processing_unit
