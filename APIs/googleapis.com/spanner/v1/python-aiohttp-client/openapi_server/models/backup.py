# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.encryption_info import EncryptionInfo
from openapi_server import util


class Backup(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, create_time: str=None, database: str=None, database_dialect: str=None, encryption_info: EncryptionInfo=None, expire_time: str=None, max_expire_time: str=None, name: str=None, referencing_backups: List[str]=None, referencing_databases: List[str]=None, size_bytes: str=None, state: str=None, version_time: str=None):
        """Backup - a model defined in OpenAPI

        :param create_time: The create_time of this Backup.
        :param database: The database of this Backup.
        :param database_dialect: The database_dialect of this Backup.
        :param encryption_info: The encryption_info of this Backup.
        :param expire_time: The expire_time of this Backup.
        :param max_expire_time: The max_expire_time of this Backup.
        :param name: The name of this Backup.
        :param referencing_backups: The referencing_backups of this Backup.
        :param referencing_databases: The referencing_databases of this Backup.
        :param size_bytes: The size_bytes of this Backup.
        :param state: The state of this Backup.
        :param version_time: The version_time of this Backup.
        """
        self.openapi_types = {
            'create_time': str,
            'database': str,
            'database_dialect': str,
            'encryption_info': EncryptionInfo,
            'expire_time': str,
            'max_expire_time': str,
            'name': str,
            'referencing_backups': List[str],
            'referencing_databases': List[str],
            'size_bytes': str,
            'state': str,
            'version_time': str
        }

        self.attribute_map = {
            'create_time': 'createTime',
            'database': 'database',
            'database_dialect': 'databaseDialect',
            'encryption_info': 'encryptionInfo',
            'expire_time': 'expireTime',
            'max_expire_time': 'maxExpireTime',
            'name': 'name',
            'referencing_backups': 'referencingBackups',
            'referencing_databases': 'referencingDatabases',
            'size_bytes': 'sizeBytes',
            'state': 'state',
            'version_time': 'versionTime'
        }

        self._create_time = create_time
        self._database = database
        self._database_dialect = database_dialect
        self._encryption_info = encryption_info
        self._expire_time = expire_time
        self._max_expire_time = max_expire_time
        self._name = name
        self._referencing_backups = referencing_backups
        self._referencing_databases = referencing_databases
        self._size_bytes = size_bytes
        self._state = state
        self._version_time = version_time

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Backup':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Backup of this Backup.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def create_time(self):
        """Gets the create_time of this Backup.

        Output only. The time the CreateBackup request is received. If the request does not specify `version_time`, the `version_time` of the backup will be equivalent to the `create_time`.

        :return: The create_time of this Backup.
        :rtype: str
        """
        return self._create_time

    @create_time.setter
    def create_time(self, create_time):
        """Sets the create_time of this Backup.

        Output only. The time the CreateBackup request is received. If the request does not specify `version_time`, the `version_time` of the backup will be equivalent to the `create_time`.

        :param create_time: The create_time of this Backup.
        :type create_time: str
        """

        self._create_time = create_time

    @property
    def database(self):
        """Gets the database of this Backup.

        Required for the CreateBackup operation. Name of the database from which this backup was created. This needs to be in the same instance as the backup. Values are of the form `projects//instances//databases/`.

        :return: The database of this Backup.
        :rtype: str
        """
        return self._database

    @database.setter
    def database(self, database):
        """Sets the database of this Backup.

        Required for the CreateBackup operation. Name of the database from which this backup was created. This needs to be in the same instance as the backup. Values are of the form `projects//instances//databases/`.

        :param database: The database of this Backup.
        :type database: str
        """

        self._database = database

    @property
    def database_dialect(self):
        """Gets the database_dialect of this Backup.

        Output only. The database dialect information for the backup.

        :return: The database_dialect of this Backup.
        :rtype: str
        """
        return self._database_dialect

    @database_dialect.setter
    def database_dialect(self, database_dialect):
        """Sets the database_dialect of this Backup.

        Output only. The database dialect information for the backup.

        :param database_dialect: The database_dialect of this Backup.
        :type database_dialect: str
        """
        allowed_values = ["DATABASE_DIALECT_UNSPECIFIED", "GOOGLE_STANDARD_SQL", "POSTGRESQL"]  # noqa: E501
        if database_dialect not in allowed_values:
            raise ValueError(
                "Invalid value for `database_dialect` ({0}), must be one of {1}"
                .format(database_dialect, allowed_values)
            )

        self._database_dialect = database_dialect

    @property
    def encryption_info(self):
        """Gets the encryption_info of this Backup.


        :return: The encryption_info of this Backup.
        :rtype: EncryptionInfo
        """
        return self._encryption_info

    @encryption_info.setter
    def encryption_info(self, encryption_info):
        """Sets the encryption_info of this Backup.


        :param encryption_info: The encryption_info of this Backup.
        :type encryption_info: EncryptionInfo
        """

        self._encryption_info = encryption_info

    @property
    def expire_time(self):
        """Gets the expire_time of this Backup.

        Required for the CreateBackup operation. The expiration time of the backup, with microseconds granularity that must be at least 6 hours and at most 366 days from the time the CreateBackup request is processed. Once the `expire_time` has passed, the backup is eligible to be automatically deleted by Cloud Spanner to free the resources used by the backup.

        :return: The expire_time of this Backup.
        :rtype: str
        """
        return self._expire_time

    @expire_time.setter
    def expire_time(self, expire_time):
        """Sets the expire_time of this Backup.

        Required for the CreateBackup operation. The expiration time of the backup, with microseconds granularity that must be at least 6 hours and at most 366 days from the time the CreateBackup request is processed. Once the `expire_time` has passed, the backup is eligible to be automatically deleted by Cloud Spanner to free the resources used by the backup.

        :param expire_time: The expire_time of this Backup.
        :type expire_time: str
        """

        self._expire_time = expire_time

    @property
    def max_expire_time(self):
        """Gets the max_expire_time of this Backup.

        Output only. The max allowed expiration time of the backup, with microseconds granularity. A backup's expiration time can be configured in multiple APIs: CreateBackup, UpdateBackup, CopyBackup. When updating or copying an existing backup, the expiration time specified must be less than `Backup.max_expire_time`.

        :return: The max_expire_time of this Backup.
        :rtype: str
        """
        return self._max_expire_time

    @max_expire_time.setter
    def max_expire_time(self, max_expire_time):
        """Sets the max_expire_time of this Backup.

        Output only. The max allowed expiration time of the backup, with microseconds granularity. A backup's expiration time can be configured in multiple APIs: CreateBackup, UpdateBackup, CopyBackup. When updating or copying an existing backup, the expiration time specified must be less than `Backup.max_expire_time`.

        :param max_expire_time: The max_expire_time of this Backup.
        :type max_expire_time: str
        """

        self._max_expire_time = max_expire_time

    @property
    def name(self):
        """Gets the name of this Backup.

        Output only for the CreateBackup operation. Required for the UpdateBackup operation. A globally unique identifier for the backup which cannot be changed. Values are of the form `projects//instances//backups/a-z*[a-z0-9]` The final segment of the name must be between 2 and 60 characters in length. The backup is stored in the location(s) specified in the instance configuration of the instance containing the backup, identified by the prefix of the backup name of the form `projects//instances/`.

        :return: The name of this Backup.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Backup.

        Output only for the CreateBackup operation. Required for the UpdateBackup operation. A globally unique identifier for the backup which cannot be changed. Values are of the form `projects//instances//backups/a-z*[a-z0-9]` The final segment of the name must be between 2 and 60 characters in length. The backup is stored in the location(s) specified in the instance configuration of the instance containing the backup, identified by the prefix of the backup name of the form `projects//instances/`.

        :param name: The name of this Backup.
        :type name: str
        """

        self._name = name

    @property
    def referencing_backups(self):
        """Gets the referencing_backups of this Backup.

        Output only. The names of the destination backups being created by copying this source backup. The backup names are of the form `projects//instances//backups/`. Referencing backups may exist in different instances. The existence of any referencing backup prevents the backup from being deleted. When the copy operation is done (either successfully completed or cancelled or the destination backup is deleted), the reference to the backup is removed.

        :return: The referencing_backups of this Backup.
        :rtype: List[str]
        """
        return self._referencing_backups

    @referencing_backups.setter
    def referencing_backups(self, referencing_backups):
        """Sets the referencing_backups of this Backup.

        Output only. The names of the destination backups being created by copying this source backup. The backup names are of the form `projects//instances//backups/`. Referencing backups may exist in different instances. The existence of any referencing backup prevents the backup from being deleted. When the copy operation is done (either successfully completed or cancelled or the destination backup is deleted), the reference to the backup is removed.

        :param referencing_backups: The referencing_backups of this Backup.
        :type referencing_backups: List[str]
        """

        self._referencing_backups = referencing_backups

    @property
    def referencing_databases(self):
        """Gets the referencing_databases of this Backup.

        Output only. The names of the restored databases that reference the backup. The database names are of the form `projects//instances//databases/`. Referencing databases may exist in different instances. The existence of any referencing database prevents the backup from being deleted. When a restored database from the backup enters the `READY` state, the reference to the backup is removed.

        :return: The referencing_databases of this Backup.
        :rtype: List[str]
        """
        return self._referencing_databases

    @referencing_databases.setter
    def referencing_databases(self, referencing_databases):
        """Sets the referencing_databases of this Backup.

        Output only. The names of the restored databases that reference the backup. The database names are of the form `projects//instances//databases/`. Referencing databases may exist in different instances. The existence of any referencing database prevents the backup from being deleted. When a restored database from the backup enters the `READY` state, the reference to the backup is removed.

        :param referencing_databases: The referencing_databases of this Backup.
        :type referencing_databases: List[str]
        """

        self._referencing_databases = referencing_databases

    @property
    def size_bytes(self):
        """Gets the size_bytes of this Backup.

        Output only. Size of the backup in bytes.

        :return: The size_bytes of this Backup.
        :rtype: str
        """
        return self._size_bytes

    @size_bytes.setter
    def size_bytes(self, size_bytes):
        """Sets the size_bytes of this Backup.

        Output only. Size of the backup in bytes.

        :param size_bytes: The size_bytes of this Backup.
        :type size_bytes: str
        """

        self._size_bytes = size_bytes

    @property
    def state(self):
        """Gets the state of this Backup.

        Output only. The current state of the backup.

        :return: The state of this Backup.
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this Backup.

        Output only. The current state of the backup.

        :param state: The state of this Backup.
        :type state: str
        """
        allowed_values = ["STATE_UNSPECIFIED", "CREATING", "READY"]  # noqa: E501
        if state not in allowed_values:
            raise ValueError(
                "Invalid value for `state` ({0}), must be one of {1}"
                .format(state, allowed_values)
            )

        self._state = state

    @property
    def version_time(self):
        """Gets the version_time of this Backup.

        The backup will contain an externally consistent copy of the database at the timestamp specified by `version_time`. If `version_time` is not specified, the system will set `version_time` to the `create_time` of the backup.

        :return: The version_time of this Backup.
        :rtype: str
        """
        return self._version_time

    @version_time.setter
    def version_time(self, version_time):
        """Sets the version_time of this Backup.

        The backup will contain an externally consistent copy of the database at the timestamp specified by `version_time`. If `version_time` is not specified, the system will set `version_time` to the `create_time` of the backup.

        :param version_time: The version_time of this Backup.
        :type version_time: str
        """

        self._version_time = version_time
