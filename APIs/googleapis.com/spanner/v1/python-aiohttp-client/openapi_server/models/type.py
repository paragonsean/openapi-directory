# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.struct_type import StructType
from openapi_server import util


class Type(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, array_element_type: Type=None, code: str=None, proto_type_fqn: str=None, struct_type: StructType=None, type_annotation: str=None):
        """Type - a model defined in OpenAPI

        :param array_element_type: The array_element_type of this Type.
        :param code: The code of this Type.
        :param proto_type_fqn: The proto_type_fqn of this Type.
        :param struct_type: The struct_type of this Type.
        :param type_annotation: The type_annotation of this Type.
        """
        self.openapi_types = {
            'array_element_type': Type,
            'code': str,
            'proto_type_fqn': str,
            'struct_type': StructType,
            'type_annotation': str
        }

        self.attribute_map = {
            'array_element_type': 'arrayElementType',
            'code': 'code',
            'proto_type_fqn': 'protoTypeFqn',
            'struct_type': 'structType',
            'type_annotation': 'typeAnnotation'
        }

        self._array_element_type = array_element_type
        self._code = code
        self._proto_type_fqn = proto_type_fqn
        self._struct_type = struct_type
        self._type_annotation = type_annotation

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Type':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Type of this Type.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def array_element_type(self):
        """Gets the array_element_type of this Type.


        :return: The array_element_type of this Type.
        :rtype: Type
        """
        return self._array_element_type

    @array_element_type.setter
    def array_element_type(self, array_element_type):
        """Sets the array_element_type of this Type.


        :param array_element_type: The array_element_type of this Type.
        :type array_element_type: Type
        """

        self._array_element_type = array_element_type

    @property
    def code(self):
        """Gets the code of this Type.

        Required. The TypeCode for this type.

        :return: The code of this Type.
        :rtype: str
        """
        return self._code

    @code.setter
    def code(self, code):
        """Sets the code of this Type.

        Required. The TypeCode for this type.

        :param code: The code of this Type.
        :type code: str
        """
        allowed_values = ["TYPE_CODE_UNSPECIFIED", "BOOL", "INT64", "FLOAT64", "FLOAT32", "TIMESTAMP", "DATE", "STRING", "BYTES", "ARRAY", "STRUCT", "NUMERIC", "JSON", "PROTO", "ENUM"]  # noqa: E501
        if code not in allowed_values:
            raise ValueError(
                "Invalid value for `code` ({0}), must be one of {1}"
                .format(code, allowed_values)
            )

        self._code = code

    @property
    def proto_type_fqn(self):
        """Gets the proto_type_fqn of this Type.

        If code == PROTO or code == ENUM, then `proto_type_fqn` is the fully qualified name of the proto type representing the proto/enum definition.

        :return: The proto_type_fqn of this Type.
        :rtype: str
        """
        return self._proto_type_fqn

    @proto_type_fqn.setter
    def proto_type_fqn(self, proto_type_fqn):
        """Sets the proto_type_fqn of this Type.

        If code == PROTO or code == ENUM, then `proto_type_fqn` is the fully qualified name of the proto type representing the proto/enum definition.

        :param proto_type_fqn: The proto_type_fqn of this Type.
        :type proto_type_fqn: str
        """

        self._proto_type_fqn = proto_type_fqn

    @property
    def struct_type(self):
        """Gets the struct_type of this Type.


        :return: The struct_type of this Type.
        :rtype: StructType
        """
        return self._struct_type

    @struct_type.setter
    def struct_type(self, struct_type):
        """Sets the struct_type of this Type.


        :param struct_type: The struct_type of this Type.
        :type struct_type: StructType
        """

        self._struct_type = struct_type

    @property
    def type_annotation(self):
        """Gets the type_annotation of this Type.

        The TypeAnnotationCode that disambiguates SQL type that Spanner will use to represent values of this type during query processing. This is necessary for some type codes because a single TypeCode can be mapped to different SQL types depending on the SQL dialect. type_annotation typically is not needed to process the content of a value (it doesn't affect serialization) and clients can ignore it on the read path.

        :return: The type_annotation of this Type.
        :rtype: str
        """
        return self._type_annotation

    @type_annotation.setter
    def type_annotation(self, type_annotation):
        """Sets the type_annotation of this Type.

        The TypeAnnotationCode that disambiguates SQL type that Spanner will use to represent values of this type during query processing. This is necessary for some type codes because a single TypeCode can be mapped to different SQL types depending on the SQL dialect. type_annotation typically is not needed to process the content of a value (it doesn't affect serialization) and clients can ignore it on the read path.

        :param type_annotation: The type_annotation of this Type.
        :type type_annotation: str
        """
        allowed_values = ["TYPE_ANNOTATION_CODE_UNSPECIFIED", "PG_NUMERIC", "PG_JSONB"]  # noqa: E501
        if type_annotation not in allowed_values:
            raise ValueError(
                "Invalid value for `type_annotation` ({0}), must be one of {1}"
                .format(type_annotation, allowed_values)
            )

        self._type_annotation = type_annotation
