/**
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The ReadOnly model module.
 * @module model/ReadOnly
 * @version v1
 */
class ReadOnly {
    /**
     * Constructs a new <code>ReadOnly</code>.
     * Message type to initiate a read-only transaction.
     * @alias module:model/ReadOnly
     */
    constructor() { 
        
        ReadOnly.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>ReadOnly</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ReadOnly} obj Optional instance to populate.
     * @return {module:model/ReadOnly} The populated <code>ReadOnly</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ReadOnly();

            if (data.hasOwnProperty('exactStaleness')) {
                obj['exactStaleness'] = ApiClient.convertToType(data['exactStaleness'], 'String');
            }
            if (data.hasOwnProperty('maxStaleness')) {
                obj['maxStaleness'] = ApiClient.convertToType(data['maxStaleness'], 'String');
            }
            if (data.hasOwnProperty('minReadTimestamp')) {
                obj['minReadTimestamp'] = ApiClient.convertToType(data['minReadTimestamp'], 'String');
            }
            if (data.hasOwnProperty('readTimestamp')) {
                obj['readTimestamp'] = ApiClient.convertToType(data['readTimestamp'], 'String');
            }
            if (data.hasOwnProperty('returnReadTimestamp')) {
                obj['returnReadTimestamp'] = ApiClient.convertToType(data['returnReadTimestamp'], 'Boolean');
            }
            if (data.hasOwnProperty('strong')) {
                obj['strong'] = ApiClient.convertToType(data['strong'], 'Boolean');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ReadOnly</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ReadOnly</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['exactStaleness'] && !(typeof data['exactStaleness'] === 'string' || data['exactStaleness'] instanceof String)) {
            throw new Error("Expected the field `exactStaleness` to be a primitive type in the JSON string but got " + data['exactStaleness']);
        }
        // ensure the json data is a string
        if (data['maxStaleness'] && !(typeof data['maxStaleness'] === 'string' || data['maxStaleness'] instanceof String)) {
            throw new Error("Expected the field `maxStaleness` to be a primitive type in the JSON string but got " + data['maxStaleness']);
        }
        // ensure the json data is a string
        if (data['minReadTimestamp'] && !(typeof data['minReadTimestamp'] === 'string' || data['minReadTimestamp'] instanceof String)) {
            throw new Error("Expected the field `minReadTimestamp` to be a primitive type in the JSON string but got " + data['minReadTimestamp']);
        }
        // ensure the json data is a string
        if (data['readTimestamp'] && !(typeof data['readTimestamp'] === 'string' || data['readTimestamp'] instanceof String)) {
            throw new Error("Expected the field `readTimestamp` to be a primitive type in the JSON string but got " + data['readTimestamp']);
        }

        return true;
    }


}



/**
 * Executes all reads at a timestamp that is `exact_staleness` old. The timestamp is chosen soon after the read is started. Guarantees that all writes that have committed more than the specified number of seconds ago are visible. Because Cloud Spanner chooses the exact timestamp, this mode works even if the client's local clock is substantially skewed from Cloud Spanner commit timestamps. Useful for reading at nearby replicas without the distributed timestamp negotiation overhead of `max_staleness`.
 * @member {String} exactStaleness
 */
ReadOnly.prototype['exactStaleness'] = undefined;

/**
 * Read data at a timestamp >= `NOW - max_staleness` seconds. Guarantees that all writes that have committed more than the specified number of seconds ago are visible. Because Cloud Spanner chooses the exact timestamp, this mode works even if the client's local clock is substantially skewed from Cloud Spanner commit timestamps. Useful for reading the freshest data available at a nearby replica, while bounding the possible staleness if the local replica has fallen behind. Note that this option can only be used in single-use transactions.
 * @member {String} maxStaleness
 */
ReadOnly.prototype['maxStaleness'] = undefined;

/**
 * Executes all reads at a timestamp >= `min_read_timestamp`. This is useful for requesting fresher data than some previous read, or data that is fresh enough to observe the effects of some previously committed transaction whose timestamp is known. Note that this option can only be used in single-use transactions. A timestamp in RFC3339 UTC \\\"Zulu\\\" format, accurate to nanoseconds. Example: `\"2014-10-02T15:01:23.045123456Z\"`.
 * @member {String} minReadTimestamp
 */
ReadOnly.prototype['minReadTimestamp'] = undefined;

/**
 * Executes all reads at the given timestamp. Unlike other modes, reads at a specific timestamp are repeatable; the same read at the same timestamp always returns the same data. If the timestamp is in the future, the read will block until the specified timestamp, modulo the read's deadline. Useful for large scale consistent reads such as mapreduces, or for coordinating many reads against a consistent snapshot of the data. A timestamp in RFC3339 UTC \\\"Zulu\\\" format, accurate to nanoseconds. Example: `\"2014-10-02T15:01:23.045123456Z\"`.
 * @member {String} readTimestamp
 */
ReadOnly.prototype['readTimestamp'] = undefined;

/**
 * If true, the Cloud Spanner-selected read timestamp is included in the Transaction message that describes the transaction.
 * @member {Boolean} returnReadTimestamp
 */
ReadOnly.prototype['returnReadTimestamp'] = undefined;

/**
 * Read at a timestamp where all previously committed transactions are visible.
 * @member {Boolean} strong
 */
ReadOnly.prototype['strong'] = undefined;






export default ReadOnly;

