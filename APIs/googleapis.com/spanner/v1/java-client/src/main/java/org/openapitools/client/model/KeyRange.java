/*
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * KeyRange represents a range of rows in a table or index. A range has a start key and an end key. These keys can be open or closed, indicating if the range includes rows with that key. Keys are represented by lists, where the ith value in the list corresponds to the ith component of the table or index primary key. Individual values are encoded as described here. For example, consider the following table definition: CREATE TABLE UserEvents ( UserName STRING(MAX), EventDate STRING(10) ) PRIMARY KEY(UserName, EventDate); The following keys name rows in this table: \&quot;Bob\&quot;, \&quot;2014-09-23\&quot; Since the &#x60;UserEvents&#x60; table&#39;s &#x60;PRIMARY KEY&#x60; clause names two columns, each &#x60;UserEvents&#x60; key has two elements; the first is the &#x60;UserName&#x60;, and the second is the &#x60;EventDate&#x60;. Key ranges with multiple components are interpreted lexicographically by component using the table or index key&#39;s declared sort order. For example, the following range returns all events for user &#x60;\&quot;Bob\&quot;&#x60; that occurred in the year 2015: \&quot;start_closed\&quot;: [\&quot;Bob\&quot;, \&quot;2015-01-01\&quot;] \&quot;end_closed\&quot;: [\&quot;Bob\&quot;, \&quot;2015-12-31\&quot;] Start and end keys can omit trailing key components. This affects the inclusion and exclusion of rows that exactly match the provided key components: if the key is closed, then rows that exactly match the provided components are included; if the key is open, then rows that exactly match are not included. For example, the following range includes all events for &#x60;\&quot;Bob\&quot;&#x60; that occurred during and after the year 2000: \&quot;start_closed\&quot;: [\&quot;Bob\&quot;, \&quot;2000-01-01\&quot;] \&quot;end_closed\&quot;: [\&quot;Bob\&quot;] The next example retrieves all events for &#x60;\&quot;Bob\&quot;&#x60;: \&quot;start_closed\&quot;: [\&quot;Bob\&quot;] \&quot;end_closed\&quot;: [\&quot;Bob\&quot;] To retrieve events before the year 2000: \&quot;start_closed\&quot;: [\&quot;Bob\&quot;] \&quot;end_open\&quot;: [\&quot;Bob\&quot;, \&quot;2000-01-01\&quot;] The following range includes all rows in the table: \&quot;start_closed\&quot;: [] \&quot;end_closed\&quot;: [] This range returns all users whose &#x60;UserName&#x60; begins with any character from A to C: \&quot;start_closed\&quot;: [\&quot;A\&quot;] \&quot;end_open\&quot;: [\&quot;D\&quot;] This range returns all users whose &#x60;UserName&#x60; begins with B: \&quot;start_closed\&quot;: [\&quot;B\&quot;] \&quot;end_open\&quot;: [\&quot;C\&quot;] Key ranges honor column sort order. For example, suppose a table is defined as follows: CREATE TABLE DescendingSortedTable { Key INT64, ... ) PRIMARY KEY(Key DESC); The following range retrieves all rows with key values between 1 and 100 inclusive: \&quot;start_closed\&quot;: [\&quot;100\&quot;] \&quot;end_closed\&quot;: [\&quot;1\&quot;] Note that 100 is passed as the start, and 1 is passed as the end, because &#x60;Key&#x60; is a descending column in the schema.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:23.689684-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class KeyRange {
  public static final String SERIALIZED_NAME_END_CLOSED = "endClosed";
  @SerializedName(SERIALIZED_NAME_END_CLOSED)
  private List<Object> endClosed = new ArrayList<>();

  public static final String SERIALIZED_NAME_END_OPEN = "endOpen";
  @SerializedName(SERIALIZED_NAME_END_OPEN)
  private List<Object> endOpen = new ArrayList<>();

  public static final String SERIALIZED_NAME_START_CLOSED = "startClosed";
  @SerializedName(SERIALIZED_NAME_START_CLOSED)
  private List<Object> startClosed = new ArrayList<>();

  public static final String SERIALIZED_NAME_START_OPEN = "startOpen";
  @SerializedName(SERIALIZED_NAME_START_OPEN)
  private List<Object> startOpen = new ArrayList<>();

  public KeyRange() {
  }

  public KeyRange endClosed(List<Object> endClosed) {
    this.endClosed = endClosed;
    return this;
  }

  public KeyRange addEndClosedItem(Object endClosedItem) {
    if (this.endClosed == null) {
      this.endClosed = new ArrayList<>();
    }
    this.endClosed.add(endClosedItem);
    return this;
  }

  /**
   * If the end is closed, then the range includes all rows whose first &#x60;len(end_closed)&#x60; key columns exactly match &#x60;end_closed&#x60;.
   * @return endClosed
   */
  @javax.annotation.Nullable
  public List<Object> getEndClosed() {
    return endClosed;
  }

  public void setEndClosed(List<Object> endClosed) {
    this.endClosed = endClosed;
  }


  public KeyRange endOpen(List<Object> endOpen) {
    this.endOpen = endOpen;
    return this;
  }

  public KeyRange addEndOpenItem(Object endOpenItem) {
    if (this.endOpen == null) {
      this.endOpen = new ArrayList<>();
    }
    this.endOpen.add(endOpenItem);
    return this;
  }

  /**
   * If the end is open, then the range excludes rows whose first &#x60;len(end_open)&#x60; key columns exactly match &#x60;end_open&#x60;.
   * @return endOpen
   */
  @javax.annotation.Nullable
  public List<Object> getEndOpen() {
    return endOpen;
  }

  public void setEndOpen(List<Object> endOpen) {
    this.endOpen = endOpen;
  }


  public KeyRange startClosed(List<Object> startClosed) {
    this.startClosed = startClosed;
    return this;
  }

  public KeyRange addStartClosedItem(Object startClosedItem) {
    if (this.startClosed == null) {
      this.startClosed = new ArrayList<>();
    }
    this.startClosed.add(startClosedItem);
    return this;
  }

  /**
   * If the start is closed, then the range includes all rows whose first &#x60;len(start_closed)&#x60; key columns exactly match &#x60;start_closed&#x60;.
   * @return startClosed
   */
  @javax.annotation.Nullable
  public List<Object> getStartClosed() {
    return startClosed;
  }

  public void setStartClosed(List<Object> startClosed) {
    this.startClosed = startClosed;
  }


  public KeyRange startOpen(List<Object> startOpen) {
    this.startOpen = startOpen;
    return this;
  }

  public KeyRange addStartOpenItem(Object startOpenItem) {
    if (this.startOpen == null) {
      this.startOpen = new ArrayList<>();
    }
    this.startOpen.add(startOpenItem);
    return this;
  }

  /**
   * If the start is open, then the range excludes rows whose first &#x60;len(start_open)&#x60; key columns exactly match &#x60;start_open&#x60;.
   * @return startOpen
   */
  @javax.annotation.Nullable
  public List<Object> getStartOpen() {
    return startOpen;
  }

  public void setStartOpen(List<Object> startOpen) {
    this.startOpen = startOpen;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KeyRange keyRange = (KeyRange) o;
    return Objects.equals(this.endClosed, keyRange.endClosed) &&
        Objects.equals(this.endOpen, keyRange.endOpen) &&
        Objects.equals(this.startClosed, keyRange.startClosed) &&
        Objects.equals(this.startOpen, keyRange.startOpen);
  }

  @Override
  public int hashCode() {
    return Objects.hash(endClosed, endOpen, startClosed, startOpen);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KeyRange {\n");
    sb.append("    endClosed: ").append(toIndentedString(endClosed)).append("\n");
    sb.append("    endOpen: ").append(toIndentedString(endOpen)).append("\n");
    sb.append("    startClosed: ").append(toIndentedString(startClosed)).append("\n");
    sb.append("    startOpen: ").append(toIndentedString(startOpen)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("endClosed");
    openapiFields.add("endOpen");
    openapiFields.add("startClosed");
    openapiFields.add("startOpen");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to KeyRange
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!KeyRange.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in KeyRange is not found in the empty JSON string", KeyRange.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!KeyRange.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `KeyRange` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("endClosed") != null && !jsonObj.get("endClosed").isJsonNull() && !jsonObj.get("endClosed").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `endClosed` to be an array in the JSON string but got `%s`", jsonObj.get("endClosed").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("endOpen") != null && !jsonObj.get("endOpen").isJsonNull() && !jsonObj.get("endOpen").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `endOpen` to be an array in the JSON string but got `%s`", jsonObj.get("endOpen").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("startClosed") != null && !jsonObj.get("startClosed").isJsonNull() && !jsonObj.get("startClosed").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `startClosed` to be an array in the JSON string but got `%s`", jsonObj.get("startClosed").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("startOpen") != null && !jsonObj.get("startOpen").isJsonNull() && !jsonObj.get("startOpen").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `startOpen` to be an array in the JSON string but got `%s`", jsonObj.get("startOpen").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!KeyRange.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'KeyRange' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<KeyRange> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(KeyRange.class));

       return (TypeAdapter<T>) new TypeAdapter<KeyRange>() {
           @Override
           public void write(JsonWriter out, KeyRange value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public KeyRange read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of KeyRange given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of KeyRange
   * @throws IOException if the JSON string is invalid with respect to KeyRange
   */
  public static KeyRange fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, KeyRange.class);
  }

  /**
   * Convert an instance of KeyRange to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

