/*
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.KeyRange;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &#x60;KeySet&#x60; defines a collection of Cloud Spanner keys and/or key ranges. All the keys are expected to be in the same table or index. The keys need not be sorted in any particular way. If the same key is specified multiple times in the set (for example if two ranges, two keys, or a key and a range overlap), Cloud Spanner behaves as if the key were only specified once.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:23.689684-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class KeySet {
  public static final String SERIALIZED_NAME_ALL = "all";
  @SerializedName(SERIALIZED_NAME_ALL)
  private Boolean all;

  public static final String SERIALIZED_NAME_KEYS = "keys";
  @SerializedName(SERIALIZED_NAME_KEYS)
  private List<List<Object>> keys = new ArrayList<>();

  public static final String SERIALIZED_NAME_RANGES = "ranges";
  @SerializedName(SERIALIZED_NAME_RANGES)
  private List<KeyRange> ranges = new ArrayList<>();

  public KeySet() {
  }

  public KeySet all(Boolean all) {
    this.all = all;
    return this;
  }

  /**
   * For convenience &#x60;all&#x60; can be set to &#x60;true&#x60; to indicate that this &#x60;KeySet&#x60; matches all keys in the table or index. Note that any keys specified in &#x60;keys&#x60; or &#x60;ranges&#x60; are only yielded once.
   * @return all
   */
  @javax.annotation.Nullable
  public Boolean getAll() {
    return all;
  }

  public void setAll(Boolean all) {
    this.all = all;
  }


  public KeySet keys(List<List<Object>> keys) {
    this.keys = keys;
    return this;
  }

  public KeySet addKeysItem(List<Object> keysItem) {
    if (this.keys == null) {
      this.keys = new ArrayList<>();
    }
    this.keys.add(keysItem);
    return this;
  }

  /**
   * A list of specific keys. Entries in &#x60;keys&#x60; should have exactly as many elements as there are columns in the primary or index key with which this &#x60;KeySet&#x60; is used. Individual key values are encoded as described here.
   * @return keys
   */
  @javax.annotation.Nullable
  public List<List<Object>> getKeys() {
    return keys;
  }

  public void setKeys(List<List<Object>> keys) {
    this.keys = keys;
  }


  public KeySet ranges(List<KeyRange> ranges) {
    this.ranges = ranges;
    return this;
  }

  public KeySet addRangesItem(KeyRange rangesItem) {
    if (this.ranges == null) {
      this.ranges = new ArrayList<>();
    }
    this.ranges.add(rangesItem);
    return this;
  }

  /**
   * A list of key ranges. See KeyRange for more information about key range specifications.
   * @return ranges
   */
  @javax.annotation.Nullable
  public List<KeyRange> getRanges() {
    return ranges;
  }

  public void setRanges(List<KeyRange> ranges) {
    this.ranges = ranges;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KeySet keySet = (KeySet) o;
    return Objects.equals(this.all, keySet.all) &&
        Objects.equals(this.keys, keySet.keys) &&
        Objects.equals(this.ranges, keySet.ranges);
  }

  @Override
  public int hashCode() {
    return Objects.hash(all, keys, ranges);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KeySet {\n");
    sb.append("    all: ").append(toIndentedString(all)).append("\n");
    sb.append("    keys: ").append(toIndentedString(keys)).append("\n");
    sb.append("    ranges: ").append(toIndentedString(ranges)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("all");
    openapiFields.add("keys");
    openapiFields.add("ranges");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to KeySet
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!KeySet.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in KeySet is not found in the empty JSON string", KeySet.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!KeySet.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `KeySet` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("keys") != null && !jsonObj.get("keys").isJsonNull() && !jsonObj.get("keys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `keys` to be an array in the JSON string but got `%s`", jsonObj.get("keys").toString()));
      }
      if (jsonObj.get("ranges") != null && !jsonObj.get("ranges").isJsonNull()) {
        JsonArray jsonArrayranges = jsonObj.getAsJsonArray("ranges");
        if (jsonArrayranges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ranges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ranges` to be an array in the JSON string but got `%s`", jsonObj.get("ranges").toString()));
          }

          // validate the optional field `ranges` (array)
          for (int i = 0; i < jsonArrayranges.size(); i++) {
            KeyRange.validateJsonElement(jsonArrayranges.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!KeySet.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'KeySet' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<KeySet> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(KeySet.class));

       return (TypeAdapter<T>) new TypeAdapter<KeySet>() {
           @Override
           public void write(JsonWriter out, KeySet value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public KeySet read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of KeySet given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of KeySet
   * @throws IOException if the JSON string is invalid with respect to KeySet
   */
  public static KeySet fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, KeySet.class);
  }

  /**
   * Convert an instance of KeySet to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

