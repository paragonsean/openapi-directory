/*
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.EncryptionConfig;
import org.openapitools.client.model.EncryptionInfo;
import org.openapitools.client.model.RestoreInfo;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Cloud Spanner database.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:23.689684-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Database {
  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  /**
   * Output only. The dialect of the Cloud Spanner Database.
   */
  @JsonAdapter(DatabaseDialectEnum.Adapter.class)
  public enum DatabaseDialectEnum {
    DATABASE_DIALECT_UNSPECIFIED("DATABASE_DIALECT_UNSPECIFIED"),
    
    GOOGLE_STANDARD_SQL("GOOGLE_STANDARD_SQL"),
    
    POSTGRESQL("POSTGRESQL");

    private String value;

    DatabaseDialectEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DatabaseDialectEnum fromValue(String value) {
      for (DatabaseDialectEnum b : DatabaseDialectEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DatabaseDialectEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DatabaseDialectEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DatabaseDialectEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DatabaseDialectEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DatabaseDialectEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATABASE_DIALECT = "databaseDialect";
  @SerializedName(SERIALIZED_NAME_DATABASE_DIALECT)
  private DatabaseDialectEnum databaseDialect;

  public static final String SERIALIZED_NAME_DEFAULT_LEADER = "defaultLeader";
  @SerializedName(SERIALIZED_NAME_DEFAULT_LEADER)
  private String defaultLeader;

  public static final String SERIALIZED_NAME_EARLIEST_VERSION_TIME = "earliestVersionTime";
  @SerializedName(SERIALIZED_NAME_EARLIEST_VERSION_TIME)
  private String earliestVersionTime;

  public static final String SERIALIZED_NAME_ENABLE_DROP_PROTECTION = "enableDropProtection";
  @SerializedName(SERIALIZED_NAME_ENABLE_DROP_PROTECTION)
  private Boolean enableDropProtection;

  public static final String SERIALIZED_NAME_ENCRYPTION_CONFIG = "encryptionConfig";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_CONFIG)
  private EncryptionConfig encryptionConfig;

  public static final String SERIALIZED_NAME_ENCRYPTION_INFO = "encryptionInfo";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_INFO)
  private List<EncryptionInfo> encryptionInfo = new ArrayList<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_RECONCILING = "reconciling";
  @SerializedName(SERIALIZED_NAME_RECONCILING)
  private Boolean reconciling;

  public static final String SERIALIZED_NAME_RESTORE_INFO = "restoreInfo";
  @SerializedName(SERIALIZED_NAME_RESTORE_INFO)
  private RestoreInfo restoreInfo;

  /**
   * Output only. The current database state.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    CREATING("CREATING"),
    
    READY("READY"),
    
    READY_OPTIMIZING("READY_OPTIMIZING");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_VERSION_RETENTION_PERIOD = "versionRetentionPeriod";
  @SerializedName(SERIALIZED_NAME_VERSION_RETENTION_PERIOD)
  private String versionRetentionPeriod;

  public Database() {
  }

  public Database(
     String createTime, 
     DatabaseDialectEnum databaseDialect, 
     String defaultLeader, 
     String earliestVersionTime, 
     List<EncryptionInfo> encryptionInfo, 
     Boolean reconciling, 
     StateEnum state, 
     String versionRetentionPeriod
  ) {
    this();
    this.createTime = createTime;
    this.databaseDialect = databaseDialect;
    this.defaultLeader = defaultLeader;
    this.earliestVersionTime = earliestVersionTime;
    this.encryptionInfo = encryptionInfo;
    this.reconciling = reconciling;
    this.state = state;
    this.versionRetentionPeriod = versionRetentionPeriod;
  }

  /**
   * Output only. If exists, the time at which the database creation started.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  /**
   * Output only. The dialect of the Cloud Spanner Database.
   * @return databaseDialect
   */
  @javax.annotation.Nullable
  public DatabaseDialectEnum getDatabaseDialect() {
    return databaseDialect;
  }



  /**
   * Output only. The read-write region which contains the database&#39;s leader replicas. This is the same as the value of default_leader database option set using DatabaseAdmin.CreateDatabase or DatabaseAdmin.UpdateDatabaseDdl. If not explicitly set, this is empty.
   * @return defaultLeader
   */
  @javax.annotation.Nullable
  public String getDefaultLeader() {
    return defaultLeader;
  }



  /**
   * Output only. Earliest timestamp at which older versions of the data can be read. This value is continuously updated by Cloud Spanner and becomes stale the moment it is queried. If you are using this value to recover data, make sure to account for the time from the moment when the value is queried to the moment when you initiate the recovery.
   * @return earliestVersionTime
   */
  @javax.annotation.Nullable
  public String getEarliestVersionTime() {
    return earliestVersionTime;
  }



  public Database enableDropProtection(Boolean enableDropProtection) {
    this.enableDropProtection = enableDropProtection;
    return this;
  }

  /**
   * Whether drop protection is enabled for this database. Defaults to false, if not set. For more details, please see how to [prevent accidental database deletion](https://cloud.google.com/spanner/docs/prevent-database-deletion).
   * @return enableDropProtection
   */
  @javax.annotation.Nullable
  public Boolean getEnableDropProtection() {
    return enableDropProtection;
  }

  public void setEnableDropProtection(Boolean enableDropProtection) {
    this.enableDropProtection = enableDropProtection;
  }


  public Database encryptionConfig(EncryptionConfig encryptionConfig) {
    this.encryptionConfig = encryptionConfig;
    return this;
  }

  /**
   * Get encryptionConfig
   * @return encryptionConfig
   */
  @javax.annotation.Nullable
  public EncryptionConfig getEncryptionConfig() {
    return encryptionConfig;
  }

  public void setEncryptionConfig(EncryptionConfig encryptionConfig) {
    this.encryptionConfig = encryptionConfig;
  }


  /**
   * Output only. For databases that are using customer managed encryption, this field contains the encryption information for the database, such as all Cloud KMS key versions that are in use. The &#x60;encryption_status&#39; field inside of each &#x60;EncryptionInfo&#x60; is not populated. For databases that are using Google default or other types of encryption, this field is empty. This field is propagated lazily from the backend. There might be a delay from when a key version is being used and when it appears in this field.
   * @return encryptionInfo
   */
  @javax.annotation.Nullable
  public List<EncryptionInfo> getEncryptionInfo() {
    return encryptionInfo;
  }



  public Database name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Required. The name of the database. Values are of the form &#x60;projects//instances//databases/&#x60;, where &#x60;&#x60; is as specified in the &#x60;CREATE DATABASE&#x60; statement. This name can be passed to other API methods to identify the database.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  /**
   * Output only. If true, the database is being updated. If false, there are no ongoing update operations for the database.
   * @return reconciling
   */
  @javax.annotation.Nullable
  public Boolean getReconciling() {
    return reconciling;
  }



  public Database restoreInfo(RestoreInfo restoreInfo) {
    this.restoreInfo = restoreInfo;
    return this;
  }

  /**
   * Get restoreInfo
   * @return restoreInfo
   */
  @javax.annotation.Nullable
  public RestoreInfo getRestoreInfo() {
    return restoreInfo;
  }

  public void setRestoreInfo(RestoreInfo restoreInfo) {
    this.restoreInfo = restoreInfo;
  }


  /**
   * Output only. The current database state.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }



  /**
   * Output only. The period in which Cloud Spanner retains all versions of data for the database. This is the same as the value of version_retention_period database option set using UpdateDatabaseDdl. Defaults to 1 hour, if not set.
   * @return versionRetentionPeriod
   */
  @javax.annotation.Nullable
  public String getVersionRetentionPeriod() {
    return versionRetentionPeriod;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Database database = (Database) o;
    return Objects.equals(this.createTime, database.createTime) &&
        Objects.equals(this.databaseDialect, database.databaseDialect) &&
        Objects.equals(this.defaultLeader, database.defaultLeader) &&
        Objects.equals(this.earliestVersionTime, database.earliestVersionTime) &&
        Objects.equals(this.enableDropProtection, database.enableDropProtection) &&
        Objects.equals(this.encryptionConfig, database.encryptionConfig) &&
        Objects.equals(this.encryptionInfo, database.encryptionInfo) &&
        Objects.equals(this.name, database.name) &&
        Objects.equals(this.reconciling, database.reconciling) &&
        Objects.equals(this.restoreInfo, database.restoreInfo) &&
        Objects.equals(this.state, database.state) &&
        Objects.equals(this.versionRetentionPeriod, database.versionRetentionPeriod);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createTime, databaseDialect, defaultLeader, earliestVersionTime, enableDropProtection, encryptionConfig, encryptionInfo, name, reconciling, restoreInfo, state, versionRetentionPeriod);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Database {\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    databaseDialect: ").append(toIndentedString(databaseDialect)).append("\n");
    sb.append("    defaultLeader: ").append(toIndentedString(defaultLeader)).append("\n");
    sb.append("    earliestVersionTime: ").append(toIndentedString(earliestVersionTime)).append("\n");
    sb.append("    enableDropProtection: ").append(toIndentedString(enableDropProtection)).append("\n");
    sb.append("    encryptionConfig: ").append(toIndentedString(encryptionConfig)).append("\n");
    sb.append("    encryptionInfo: ").append(toIndentedString(encryptionInfo)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    reconciling: ").append(toIndentedString(reconciling)).append("\n");
    sb.append("    restoreInfo: ").append(toIndentedString(restoreInfo)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    versionRetentionPeriod: ").append(toIndentedString(versionRetentionPeriod)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("createTime");
    openapiFields.add("databaseDialect");
    openapiFields.add("defaultLeader");
    openapiFields.add("earliestVersionTime");
    openapiFields.add("enableDropProtection");
    openapiFields.add("encryptionConfig");
    openapiFields.add("encryptionInfo");
    openapiFields.add("name");
    openapiFields.add("reconciling");
    openapiFields.add("restoreInfo");
    openapiFields.add("state");
    openapiFields.add("versionRetentionPeriod");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Database
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Database.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Database is not found in the empty JSON string", Database.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Database.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Database` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("databaseDialect") != null && !jsonObj.get("databaseDialect").isJsonNull()) && !jsonObj.get("databaseDialect").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `databaseDialect` to be a primitive type in the JSON string but got `%s`", jsonObj.get("databaseDialect").toString()));
      }
      // validate the optional field `databaseDialect`
      if (jsonObj.get("databaseDialect") != null && !jsonObj.get("databaseDialect").isJsonNull()) {
        DatabaseDialectEnum.validateJsonElement(jsonObj.get("databaseDialect"));
      }
      if ((jsonObj.get("defaultLeader") != null && !jsonObj.get("defaultLeader").isJsonNull()) && !jsonObj.get("defaultLeader").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultLeader` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultLeader").toString()));
      }
      if ((jsonObj.get("earliestVersionTime") != null && !jsonObj.get("earliestVersionTime").isJsonNull()) && !jsonObj.get("earliestVersionTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `earliestVersionTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("earliestVersionTime").toString()));
      }
      // validate the optional field `encryptionConfig`
      if (jsonObj.get("encryptionConfig") != null && !jsonObj.get("encryptionConfig").isJsonNull()) {
        EncryptionConfig.validateJsonElement(jsonObj.get("encryptionConfig"));
      }
      if (jsonObj.get("encryptionInfo") != null && !jsonObj.get("encryptionInfo").isJsonNull()) {
        JsonArray jsonArrayencryptionInfo = jsonObj.getAsJsonArray("encryptionInfo");
        if (jsonArrayencryptionInfo != null) {
          // ensure the json data is an array
          if (!jsonObj.get("encryptionInfo").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `encryptionInfo` to be an array in the JSON string but got `%s`", jsonObj.get("encryptionInfo").toString()));
          }

          // validate the optional field `encryptionInfo` (array)
          for (int i = 0; i < jsonArrayencryptionInfo.size(); i++) {
            EncryptionInfo.validateJsonElement(jsonArrayencryptionInfo.get(i));
          };
        }
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `restoreInfo`
      if (jsonObj.get("restoreInfo") != null && !jsonObj.get("restoreInfo").isJsonNull()) {
        RestoreInfo.validateJsonElement(jsonObj.get("restoreInfo"));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("versionRetentionPeriod") != null && !jsonObj.get("versionRetentionPeriod").isJsonNull()) && !jsonObj.get("versionRetentionPeriod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `versionRetentionPeriod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("versionRetentionPeriod").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Database.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Database' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Database> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Database.class));

       return (TypeAdapter<T>) new TypeAdapter<Database>() {
           @Override
           public void write(JsonWriter out, Database value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Database read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Database given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Database
   * @throws IOException if the JSON string is invalid with respect to Database
   */
  public static Database fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Database.class);
  }

  /**
   * Convert an instance of Database to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

