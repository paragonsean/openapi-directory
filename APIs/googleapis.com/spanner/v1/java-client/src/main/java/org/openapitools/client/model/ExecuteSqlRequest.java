/*
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.DirectedReadOptions;
import org.openapitools.client.model.QueryOptions;
import org.openapitools.client.model.RequestOptions;
import org.openapitools.client.model.TransactionSelector;
import org.openapitools.client.model.Type;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The request for ExecuteSql and ExecuteStreamingSql.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:23.689684-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ExecuteSqlRequest {
  public static final String SERIALIZED_NAME_DATA_BOOST_ENABLED = "dataBoostEnabled";
  @SerializedName(SERIALIZED_NAME_DATA_BOOST_ENABLED)
  private Boolean dataBoostEnabled;

  public static final String SERIALIZED_NAME_DIRECTED_READ_OPTIONS = "directedReadOptions";
  @SerializedName(SERIALIZED_NAME_DIRECTED_READ_OPTIONS)
  private DirectedReadOptions directedReadOptions;

  public static final String SERIALIZED_NAME_PARAM_TYPES = "paramTypes";
  @SerializedName(SERIALIZED_NAME_PARAM_TYPES)
  private Map<String, Type> paramTypes = new HashMap<>();

  public static final String SERIALIZED_NAME_PARAMS = "params";
  @SerializedName(SERIALIZED_NAME_PARAMS)
  private Map<String, Object> params = new HashMap<>();

  public static final String SERIALIZED_NAME_PARTITION_TOKEN = "partitionToken";
  @SerializedName(SERIALIZED_NAME_PARTITION_TOKEN)
  private byte[] partitionToken;

  /**
   * Used to control the amount of debugging information returned in ResultSetStats. If partition_token is set, query_mode can only be set to QueryMode.NORMAL.
   */
  @JsonAdapter(QueryModeEnum.Adapter.class)
  public enum QueryModeEnum {
    NORMAL("NORMAL"),
    
    PLAN("PLAN"),
    
    PROFILE("PROFILE");

    private String value;

    QueryModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static QueryModeEnum fromValue(String value) {
      for (QueryModeEnum b : QueryModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<QueryModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final QueryModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public QueryModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return QueryModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      QueryModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_QUERY_MODE = "queryMode";
  @SerializedName(SERIALIZED_NAME_QUERY_MODE)
  private QueryModeEnum queryMode;

  public static final String SERIALIZED_NAME_QUERY_OPTIONS = "queryOptions";
  @SerializedName(SERIALIZED_NAME_QUERY_OPTIONS)
  private QueryOptions queryOptions;

  public static final String SERIALIZED_NAME_REQUEST_OPTIONS = "requestOptions";
  @SerializedName(SERIALIZED_NAME_REQUEST_OPTIONS)
  private RequestOptions requestOptions;

  public static final String SERIALIZED_NAME_RESUME_TOKEN = "resumeToken";
  @SerializedName(SERIALIZED_NAME_RESUME_TOKEN)
  private byte[] resumeToken;

  public static final String SERIALIZED_NAME_SEQNO = "seqno";
  @SerializedName(SERIALIZED_NAME_SEQNO)
  private String seqno;

  public static final String SERIALIZED_NAME_SQL = "sql";
  @SerializedName(SERIALIZED_NAME_SQL)
  private String sql;

  public static final String SERIALIZED_NAME_TRANSACTION = "transaction";
  @SerializedName(SERIALIZED_NAME_TRANSACTION)
  private TransactionSelector transaction;

  public ExecuteSqlRequest() {
  }

  public ExecuteSqlRequest dataBoostEnabled(Boolean dataBoostEnabled) {
    this.dataBoostEnabled = dataBoostEnabled;
    return this;
  }

  /**
   * If this is for a partitioned query and this field is set to &#x60;true&#x60;, the request is executed with Spanner Data Boost independent compute resources. If the field is set to &#x60;true&#x60; but the request does not set &#x60;partition_token&#x60;, the API returns an &#x60;INVALID_ARGUMENT&#x60; error.
   * @return dataBoostEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDataBoostEnabled() {
    return dataBoostEnabled;
  }

  public void setDataBoostEnabled(Boolean dataBoostEnabled) {
    this.dataBoostEnabled = dataBoostEnabled;
  }


  public ExecuteSqlRequest directedReadOptions(DirectedReadOptions directedReadOptions) {
    this.directedReadOptions = directedReadOptions;
    return this;
  }

  /**
   * Get directedReadOptions
   * @return directedReadOptions
   */
  @javax.annotation.Nullable
  public DirectedReadOptions getDirectedReadOptions() {
    return directedReadOptions;
  }

  public void setDirectedReadOptions(DirectedReadOptions directedReadOptions) {
    this.directedReadOptions = directedReadOptions;
  }


  public ExecuteSqlRequest paramTypes(Map<String, Type> paramTypes) {
    this.paramTypes = paramTypes;
    return this;
  }

  public ExecuteSqlRequest putParamTypesItem(String key, Type paramTypesItem) {
    if (this.paramTypes == null) {
      this.paramTypes = new HashMap<>();
    }
    this.paramTypes.put(key, paramTypesItem);
    return this;
  }

  /**
   * It is not always possible for Cloud Spanner to infer the right SQL type from a JSON value. For example, values of type &#x60;BYTES&#x60; and values of type &#x60;STRING&#x60; both appear in params as JSON strings. In these cases, &#x60;param_types&#x60; can be used to specify the exact SQL type for some or all of the SQL statement parameters. See the definition of Type for more information about SQL types.
   * @return paramTypes
   */
  @javax.annotation.Nullable
  public Map<String, Type> getParamTypes() {
    return paramTypes;
  }

  public void setParamTypes(Map<String, Type> paramTypes) {
    this.paramTypes = paramTypes;
  }


  public ExecuteSqlRequest params(Map<String, Object> params) {
    this.params = params;
    return this;
  }

  public ExecuteSqlRequest putParamsItem(String key, Object paramsItem) {
    if (this.params == null) {
      this.params = new HashMap<>();
    }
    this.params.put(key, paramsItem);
    return this;
  }

  /**
   * Parameter names and values that bind to placeholders in the SQL string. A parameter placeholder consists of the &#x60;@&#x60; character followed by the parameter name (for example, &#x60;@firstName&#x60;). Parameter names must conform to the naming requirements of identifiers as specified at https://cloud.google.com/spanner/docs/lexical#identifiers. Parameters can appear anywhere that a literal value is expected. The same parameter name can be used more than once, for example: &#x60;\&quot;WHERE id &gt; @msg_id AND id &lt; @msg_id + 100\&quot;&#x60; It is an error to execute a SQL statement with unbound parameters.
   * @return params
   */
  @javax.annotation.Nullable
  public Map<String, Object> getParams() {
    return params;
  }

  public void setParams(Map<String, Object> params) {
    this.params = params;
  }


  public ExecuteSqlRequest partitionToken(byte[] partitionToken) {
    this.partitionToken = partitionToken;
    return this;
  }

  /**
   * If present, results will be restricted to the specified partition previously created using PartitionQuery(). There must be an exact match for the values of fields common to this message and the PartitionQueryRequest message used to create this partition_token.
   * @return partitionToken
   */
  @javax.annotation.Nullable
  public byte[] getPartitionToken() {
    return partitionToken;
  }

  public void setPartitionToken(byte[] partitionToken) {
    this.partitionToken = partitionToken;
  }


  public ExecuteSqlRequest queryMode(QueryModeEnum queryMode) {
    this.queryMode = queryMode;
    return this;
  }

  /**
   * Used to control the amount of debugging information returned in ResultSetStats. If partition_token is set, query_mode can only be set to QueryMode.NORMAL.
   * @return queryMode
   */
  @javax.annotation.Nullable
  public QueryModeEnum getQueryMode() {
    return queryMode;
  }

  public void setQueryMode(QueryModeEnum queryMode) {
    this.queryMode = queryMode;
  }


  public ExecuteSqlRequest queryOptions(QueryOptions queryOptions) {
    this.queryOptions = queryOptions;
    return this;
  }

  /**
   * Get queryOptions
   * @return queryOptions
   */
  @javax.annotation.Nullable
  public QueryOptions getQueryOptions() {
    return queryOptions;
  }

  public void setQueryOptions(QueryOptions queryOptions) {
    this.queryOptions = queryOptions;
  }


  public ExecuteSqlRequest requestOptions(RequestOptions requestOptions) {
    this.requestOptions = requestOptions;
    return this;
  }

  /**
   * Get requestOptions
   * @return requestOptions
   */
  @javax.annotation.Nullable
  public RequestOptions getRequestOptions() {
    return requestOptions;
  }

  public void setRequestOptions(RequestOptions requestOptions) {
    this.requestOptions = requestOptions;
  }


  public ExecuteSqlRequest resumeToken(byte[] resumeToken) {
    this.resumeToken = resumeToken;
    return this;
  }

  /**
   * If this request is resuming a previously interrupted SQL statement execution, &#x60;resume_token&#x60; should be copied from the last PartialResultSet yielded before the interruption. Doing this enables the new SQL statement execution to resume where the last one left off. The rest of the request parameters must exactly match the request that yielded this token.
   * @return resumeToken
   */
  @javax.annotation.Nullable
  public byte[] getResumeToken() {
    return resumeToken;
  }

  public void setResumeToken(byte[] resumeToken) {
    this.resumeToken = resumeToken;
  }


  public ExecuteSqlRequest seqno(String seqno) {
    this.seqno = seqno;
    return this;
  }

  /**
   * A per-transaction sequence number used to identify this request. This field makes each request idempotent such that if the request is received multiple times, at most one will succeed. The sequence number must be monotonically increasing within the transaction. If a request arrives for the first time with an out-of-order sequence number, the transaction may be aborted. Replays of previously handled requests will yield the same response as the first execution. Required for DML statements. Ignored for queries.
   * @return seqno
   */
  @javax.annotation.Nullable
  public String getSeqno() {
    return seqno;
  }

  public void setSeqno(String seqno) {
    this.seqno = seqno;
  }


  public ExecuteSqlRequest sql(String sql) {
    this.sql = sql;
    return this;
  }

  /**
   * Required. The SQL string.
   * @return sql
   */
  @javax.annotation.Nullable
  public String getSql() {
    return sql;
  }

  public void setSql(String sql) {
    this.sql = sql;
  }


  public ExecuteSqlRequest transaction(TransactionSelector transaction) {
    this.transaction = transaction;
    return this;
  }

  /**
   * Get transaction
   * @return transaction
   */
  @javax.annotation.Nullable
  public TransactionSelector getTransaction() {
    return transaction;
  }

  public void setTransaction(TransactionSelector transaction) {
    this.transaction = transaction;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExecuteSqlRequest executeSqlRequest = (ExecuteSqlRequest) o;
    return Objects.equals(this.dataBoostEnabled, executeSqlRequest.dataBoostEnabled) &&
        Objects.equals(this.directedReadOptions, executeSqlRequest.directedReadOptions) &&
        Objects.equals(this.paramTypes, executeSqlRequest.paramTypes) &&
        Objects.equals(this.params, executeSqlRequest.params) &&
        Arrays.equals(this.partitionToken, executeSqlRequest.partitionToken) &&
        Objects.equals(this.queryMode, executeSqlRequest.queryMode) &&
        Objects.equals(this.queryOptions, executeSqlRequest.queryOptions) &&
        Objects.equals(this.requestOptions, executeSqlRequest.requestOptions) &&
        Arrays.equals(this.resumeToken, executeSqlRequest.resumeToken) &&
        Objects.equals(this.seqno, executeSqlRequest.seqno) &&
        Objects.equals(this.sql, executeSqlRequest.sql) &&
        Objects.equals(this.transaction, executeSqlRequest.transaction);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataBoostEnabled, directedReadOptions, paramTypes, params, Arrays.hashCode(partitionToken), queryMode, queryOptions, requestOptions, Arrays.hashCode(resumeToken), seqno, sql, transaction);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExecuteSqlRequest {\n");
    sb.append("    dataBoostEnabled: ").append(toIndentedString(dataBoostEnabled)).append("\n");
    sb.append("    directedReadOptions: ").append(toIndentedString(directedReadOptions)).append("\n");
    sb.append("    paramTypes: ").append(toIndentedString(paramTypes)).append("\n");
    sb.append("    params: ").append(toIndentedString(params)).append("\n");
    sb.append("    partitionToken: ").append(toIndentedString(partitionToken)).append("\n");
    sb.append("    queryMode: ").append(toIndentedString(queryMode)).append("\n");
    sb.append("    queryOptions: ").append(toIndentedString(queryOptions)).append("\n");
    sb.append("    requestOptions: ").append(toIndentedString(requestOptions)).append("\n");
    sb.append("    resumeToken: ").append(toIndentedString(resumeToken)).append("\n");
    sb.append("    seqno: ").append(toIndentedString(seqno)).append("\n");
    sb.append("    sql: ").append(toIndentedString(sql)).append("\n");
    sb.append("    transaction: ").append(toIndentedString(transaction)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dataBoostEnabled");
    openapiFields.add("directedReadOptions");
    openapiFields.add("paramTypes");
    openapiFields.add("params");
    openapiFields.add("partitionToken");
    openapiFields.add("queryMode");
    openapiFields.add("queryOptions");
    openapiFields.add("requestOptions");
    openapiFields.add("resumeToken");
    openapiFields.add("seqno");
    openapiFields.add("sql");
    openapiFields.add("transaction");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ExecuteSqlRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ExecuteSqlRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExecuteSqlRequest is not found in the empty JSON string", ExecuteSqlRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ExecuteSqlRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExecuteSqlRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `directedReadOptions`
      if (jsonObj.get("directedReadOptions") != null && !jsonObj.get("directedReadOptions").isJsonNull()) {
        DirectedReadOptions.validateJsonElement(jsonObj.get("directedReadOptions"));
      }
      if ((jsonObj.get("queryMode") != null && !jsonObj.get("queryMode").isJsonNull()) && !jsonObj.get("queryMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `queryMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("queryMode").toString()));
      }
      // validate the optional field `queryMode`
      if (jsonObj.get("queryMode") != null && !jsonObj.get("queryMode").isJsonNull()) {
        QueryModeEnum.validateJsonElement(jsonObj.get("queryMode"));
      }
      // validate the optional field `queryOptions`
      if (jsonObj.get("queryOptions") != null && !jsonObj.get("queryOptions").isJsonNull()) {
        QueryOptions.validateJsonElement(jsonObj.get("queryOptions"));
      }
      // validate the optional field `requestOptions`
      if (jsonObj.get("requestOptions") != null && !jsonObj.get("requestOptions").isJsonNull()) {
        RequestOptions.validateJsonElement(jsonObj.get("requestOptions"));
      }
      if ((jsonObj.get("seqno") != null && !jsonObj.get("seqno").isJsonNull()) && !jsonObj.get("seqno").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `seqno` to be a primitive type in the JSON string but got `%s`", jsonObj.get("seqno").toString()));
      }
      if ((jsonObj.get("sql") != null && !jsonObj.get("sql").isJsonNull()) && !jsonObj.get("sql").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sql` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sql").toString()));
      }
      // validate the optional field `transaction`
      if (jsonObj.get("transaction") != null && !jsonObj.get("transaction").isJsonNull()) {
        TransactionSelector.validateJsonElement(jsonObj.get("transaction"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExecuteSqlRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExecuteSqlRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExecuteSqlRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExecuteSqlRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ExecuteSqlRequest>() {
           @Override
           public void write(JsonWriter out, ExecuteSqlRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExecuteSqlRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ExecuteSqlRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ExecuteSqlRequest
   * @throws IOException if the JSON string is invalid with respect to ExecuteSqlRequest
   */
  public static ExecuteSqlRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExecuteSqlRequest.class);
  }

  /**
   * Convert an instance of ExecuteSqlRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

