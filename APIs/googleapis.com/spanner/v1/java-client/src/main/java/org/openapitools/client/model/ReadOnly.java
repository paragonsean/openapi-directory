/*
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Message type to initiate a read-only transaction.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:23.689684-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ReadOnly {
  public static final String SERIALIZED_NAME_EXACT_STALENESS = "exactStaleness";
  @SerializedName(SERIALIZED_NAME_EXACT_STALENESS)
  private String exactStaleness;

  public static final String SERIALIZED_NAME_MAX_STALENESS = "maxStaleness";
  @SerializedName(SERIALIZED_NAME_MAX_STALENESS)
  private String maxStaleness;

  public static final String SERIALIZED_NAME_MIN_READ_TIMESTAMP = "minReadTimestamp";
  @SerializedName(SERIALIZED_NAME_MIN_READ_TIMESTAMP)
  private String minReadTimestamp;

  public static final String SERIALIZED_NAME_READ_TIMESTAMP = "readTimestamp";
  @SerializedName(SERIALIZED_NAME_READ_TIMESTAMP)
  private String readTimestamp;

  public static final String SERIALIZED_NAME_RETURN_READ_TIMESTAMP = "returnReadTimestamp";
  @SerializedName(SERIALIZED_NAME_RETURN_READ_TIMESTAMP)
  private Boolean returnReadTimestamp;

  public static final String SERIALIZED_NAME_STRONG = "strong";
  @SerializedName(SERIALIZED_NAME_STRONG)
  private Boolean strong;

  public ReadOnly() {
  }

  public ReadOnly exactStaleness(String exactStaleness) {
    this.exactStaleness = exactStaleness;
    return this;
  }

  /**
   * Executes all reads at a timestamp that is &#x60;exact_staleness&#x60; old. The timestamp is chosen soon after the read is started. Guarantees that all writes that have committed more than the specified number of seconds ago are visible. Because Cloud Spanner chooses the exact timestamp, this mode works even if the client&#39;s local clock is substantially skewed from Cloud Spanner commit timestamps. Useful for reading at nearby replicas without the distributed timestamp negotiation overhead of &#x60;max_staleness&#x60;.
   * @return exactStaleness
   */
  @javax.annotation.Nullable
  public String getExactStaleness() {
    return exactStaleness;
  }

  public void setExactStaleness(String exactStaleness) {
    this.exactStaleness = exactStaleness;
  }


  public ReadOnly maxStaleness(String maxStaleness) {
    this.maxStaleness = maxStaleness;
    return this;
  }

  /**
   * Read data at a timestamp &gt;&#x3D; &#x60;NOW - max_staleness&#x60; seconds. Guarantees that all writes that have committed more than the specified number of seconds ago are visible. Because Cloud Spanner chooses the exact timestamp, this mode works even if the client&#39;s local clock is substantially skewed from Cloud Spanner commit timestamps. Useful for reading the freshest data available at a nearby replica, while bounding the possible staleness if the local replica has fallen behind. Note that this option can only be used in single-use transactions.
   * @return maxStaleness
   */
  @javax.annotation.Nullable
  public String getMaxStaleness() {
    return maxStaleness;
  }

  public void setMaxStaleness(String maxStaleness) {
    this.maxStaleness = maxStaleness;
  }


  public ReadOnly minReadTimestamp(String minReadTimestamp) {
    this.minReadTimestamp = minReadTimestamp;
    return this;
  }

  /**
   * Executes all reads at a timestamp &gt;&#x3D; &#x60;min_read_timestamp&#x60;. This is useful for requesting fresher data than some previous read, or data that is fresh enough to observe the effects of some previously committed transaction whose timestamp is known. Note that this option can only be used in single-use transactions. A timestamp in RFC3339 UTC \\\&quot;Zulu\\\&quot; format, accurate to nanoseconds. Example: &#x60;\&quot;2014-10-02T15:01:23.045123456Z\&quot;&#x60;.
   * @return minReadTimestamp
   */
  @javax.annotation.Nullable
  public String getMinReadTimestamp() {
    return minReadTimestamp;
  }

  public void setMinReadTimestamp(String minReadTimestamp) {
    this.minReadTimestamp = minReadTimestamp;
  }


  public ReadOnly readTimestamp(String readTimestamp) {
    this.readTimestamp = readTimestamp;
    return this;
  }

  /**
   * Executes all reads at the given timestamp. Unlike other modes, reads at a specific timestamp are repeatable; the same read at the same timestamp always returns the same data. If the timestamp is in the future, the read will block until the specified timestamp, modulo the read&#39;s deadline. Useful for large scale consistent reads such as mapreduces, or for coordinating many reads against a consistent snapshot of the data. A timestamp in RFC3339 UTC \\\&quot;Zulu\\\&quot; format, accurate to nanoseconds. Example: &#x60;\&quot;2014-10-02T15:01:23.045123456Z\&quot;&#x60;.
   * @return readTimestamp
   */
  @javax.annotation.Nullable
  public String getReadTimestamp() {
    return readTimestamp;
  }

  public void setReadTimestamp(String readTimestamp) {
    this.readTimestamp = readTimestamp;
  }


  public ReadOnly returnReadTimestamp(Boolean returnReadTimestamp) {
    this.returnReadTimestamp = returnReadTimestamp;
    return this;
  }

  /**
   * If true, the Cloud Spanner-selected read timestamp is included in the Transaction message that describes the transaction.
   * @return returnReadTimestamp
   */
  @javax.annotation.Nullable
  public Boolean getReturnReadTimestamp() {
    return returnReadTimestamp;
  }

  public void setReturnReadTimestamp(Boolean returnReadTimestamp) {
    this.returnReadTimestamp = returnReadTimestamp;
  }


  public ReadOnly strong(Boolean strong) {
    this.strong = strong;
    return this;
  }

  /**
   * Read at a timestamp where all previously committed transactions are visible.
   * @return strong
   */
  @javax.annotation.Nullable
  public Boolean getStrong() {
    return strong;
  }

  public void setStrong(Boolean strong) {
    this.strong = strong;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReadOnly readOnly = (ReadOnly) o;
    return Objects.equals(this.exactStaleness, readOnly.exactStaleness) &&
        Objects.equals(this.maxStaleness, readOnly.maxStaleness) &&
        Objects.equals(this.minReadTimestamp, readOnly.minReadTimestamp) &&
        Objects.equals(this.readTimestamp, readOnly.readTimestamp) &&
        Objects.equals(this.returnReadTimestamp, readOnly.returnReadTimestamp) &&
        Objects.equals(this.strong, readOnly.strong);
  }

  @Override
  public int hashCode() {
    return Objects.hash(exactStaleness, maxStaleness, minReadTimestamp, readTimestamp, returnReadTimestamp, strong);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReadOnly {\n");
    sb.append("    exactStaleness: ").append(toIndentedString(exactStaleness)).append("\n");
    sb.append("    maxStaleness: ").append(toIndentedString(maxStaleness)).append("\n");
    sb.append("    minReadTimestamp: ").append(toIndentedString(minReadTimestamp)).append("\n");
    sb.append("    readTimestamp: ").append(toIndentedString(readTimestamp)).append("\n");
    sb.append("    returnReadTimestamp: ").append(toIndentedString(returnReadTimestamp)).append("\n");
    sb.append("    strong: ").append(toIndentedString(strong)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("exactStaleness");
    openapiFields.add("maxStaleness");
    openapiFields.add("minReadTimestamp");
    openapiFields.add("readTimestamp");
    openapiFields.add("returnReadTimestamp");
    openapiFields.add("strong");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ReadOnly
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ReadOnly.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ReadOnly is not found in the empty JSON string", ReadOnly.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ReadOnly.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ReadOnly` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("exactStaleness") != null && !jsonObj.get("exactStaleness").isJsonNull()) && !jsonObj.get("exactStaleness").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `exactStaleness` to be a primitive type in the JSON string but got `%s`", jsonObj.get("exactStaleness").toString()));
      }
      if ((jsonObj.get("maxStaleness") != null && !jsonObj.get("maxStaleness").isJsonNull()) && !jsonObj.get("maxStaleness").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxStaleness` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxStaleness").toString()));
      }
      if ((jsonObj.get("minReadTimestamp") != null && !jsonObj.get("minReadTimestamp").isJsonNull()) && !jsonObj.get("minReadTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `minReadTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("minReadTimestamp").toString()));
      }
      if ((jsonObj.get("readTimestamp") != null && !jsonObj.get("readTimestamp").isJsonNull()) && !jsonObj.get("readTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `readTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("readTimestamp").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ReadOnly.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ReadOnly' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ReadOnly> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ReadOnly.class));

       return (TypeAdapter<T>) new TypeAdapter<ReadOnly>() {
           @Override
           public void write(JsonWriter out, ReadOnly value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ReadOnly read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ReadOnly given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ReadOnly
   * @throws IOException if the JSON string is invalid with respect to ReadOnly
   */
  public static ReadOnly fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ReadOnly.class);
  }

  /**
   * Convert an instance of ReadOnly to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

