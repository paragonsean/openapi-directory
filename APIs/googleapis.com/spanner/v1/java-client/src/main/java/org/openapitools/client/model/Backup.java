/*
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.EncryptionInfo;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A backup of a Cloud Spanner database.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:23.689684-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Backup {
  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_DATABASE = "database";
  @SerializedName(SERIALIZED_NAME_DATABASE)
  private String database;

  /**
   * Output only. The database dialect information for the backup.
   */
  @JsonAdapter(DatabaseDialectEnum.Adapter.class)
  public enum DatabaseDialectEnum {
    DATABASE_DIALECT_UNSPECIFIED("DATABASE_DIALECT_UNSPECIFIED"),
    
    GOOGLE_STANDARD_SQL("GOOGLE_STANDARD_SQL"),
    
    POSTGRESQL("POSTGRESQL");

    private String value;

    DatabaseDialectEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DatabaseDialectEnum fromValue(String value) {
      for (DatabaseDialectEnum b : DatabaseDialectEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DatabaseDialectEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DatabaseDialectEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DatabaseDialectEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DatabaseDialectEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DatabaseDialectEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATABASE_DIALECT = "databaseDialect";
  @SerializedName(SERIALIZED_NAME_DATABASE_DIALECT)
  private DatabaseDialectEnum databaseDialect;

  public static final String SERIALIZED_NAME_ENCRYPTION_INFO = "encryptionInfo";
  @SerializedName(SERIALIZED_NAME_ENCRYPTION_INFO)
  private EncryptionInfo encryptionInfo;

  public static final String SERIALIZED_NAME_EXPIRE_TIME = "expireTime";
  @SerializedName(SERIALIZED_NAME_EXPIRE_TIME)
  private String expireTime;

  public static final String SERIALIZED_NAME_MAX_EXPIRE_TIME = "maxExpireTime";
  @SerializedName(SERIALIZED_NAME_MAX_EXPIRE_TIME)
  private String maxExpireTime;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_REFERENCING_BACKUPS = "referencingBackups";
  @SerializedName(SERIALIZED_NAME_REFERENCING_BACKUPS)
  private List<String> referencingBackups = new ArrayList<>();

  public static final String SERIALIZED_NAME_REFERENCING_DATABASES = "referencingDatabases";
  @SerializedName(SERIALIZED_NAME_REFERENCING_DATABASES)
  private List<String> referencingDatabases = new ArrayList<>();

  public static final String SERIALIZED_NAME_SIZE_BYTES = "sizeBytes";
  @SerializedName(SERIALIZED_NAME_SIZE_BYTES)
  private String sizeBytes;

  /**
   * Output only. The current state of the backup.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    CREATING("CREATING"),
    
    READY("READY");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_VERSION_TIME = "versionTime";
  @SerializedName(SERIALIZED_NAME_VERSION_TIME)
  private String versionTime;

  public Backup() {
  }

  public Backup(
     String createTime, 
     DatabaseDialectEnum databaseDialect, 
     String maxExpireTime, 
     List<String> referencingBackups, 
     List<String> referencingDatabases, 
     String sizeBytes, 
     StateEnum state
  ) {
    this();
    this.createTime = createTime;
    this.databaseDialect = databaseDialect;
    this.maxExpireTime = maxExpireTime;
    this.referencingBackups = referencingBackups;
    this.referencingDatabases = referencingDatabases;
    this.sizeBytes = sizeBytes;
    this.state = state;
  }

  /**
   * Output only. The time the CreateBackup request is received. If the request does not specify &#x60;version_time&#x60;, the &#x60;version_time&#x60; of the backup will be equivalent to the &#x60;create_time&#x60;.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  public Backup database(String database) {
    this.database = database;
    return this;
  }

  /**
   * Required for the CreateBackup operation. Name of the database from which this backup was created. This needs to be in the same instance as the backup. Values are of the form &#x60;projects//instances//databases/&#x60;.
   * @return database
   */
  @javax.annotation.Nullable
  public String getDatabase() {
    return database;
  }

  public void setDatabase(String database) {
    this.database = database;
  }


  /**
   * Output only. The database dialect information for the backup.
   * @return databaseDialect
   */
  @javax.annotation.Nullable
  public DatabaseDialectEnum getDatabaseDialect() {
    return databaseDialect;
  }



  public Backup encryptionInfo(EncryptionInfo encryptionInfo) {
    this.encryptionInfo = encryptionInfo;
    return this;
  }

  /**
   * Get encryptionInfo
   * @return encryptionInfo
   */
  @javax.annotation.Nullable
  public EncryptionInfo getEncryptionInfo() {
    return encryptionInfo;
  }

  public void setEncryptionInfo(EncryptionInfo encryptionInfo) {
    this.encryptionInfo = encryptionInfo;
  }


  public Backup expireTime(String expireTime) {
    this.expireTime = expireTime;
    return this;
  }

  /**
   * Required for the CreateBackup operation. The expiration time of the backup, with microseconds granularity that must be at least 6 hours and at most 366 days from the time the CreateBackup request is processed. Once the &#x60;expire_time&#x60; has passed, the backup is eligible to be automatically deleted by Cloud Spanner to free the resources used by the backup.
   * @return expireTime
   */
  @javax.annotation.Nullable
  public String getExpireTime() {
    return expireTime;
  }

  public void setExpireTime(String expireTime) {
    this.expireTime = expireTime;
  }


  /**
   * Output only. The max allowed expiration time of the backup, with microseconds granularity. A backup&#39;s expiration time can be configured in multiple APIs: CreateBackup, UpdateBackup, CopyBackup. When updating or copying an existing backup, the expiration time specified must be less than &#x60;Backup.max_expire_time&#x60;.
   * @return maxExpireTime
   */
  @javax.annotation.Nullable
  public String getMaxExpireTime() {
    return maxExpireTime;
  }



  public Backup name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Output only for the CreateBackup operation. Required for the UpdateBackup operation. A globally unique identifier for the backup which cannot be changed. Values are of the form &#x60;projects//instances//backups/a-z*[a-z0-9]&#x60; The final segment of the name must be between 2 and 60 characters in length. The backup is stored in the location(s) specified in the instance configuration of the instance containing the backup, identified by the prefix of the backup name of the form &#x60;projects//instances/&#x60;.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  /**
   * Output only. The names of the destination backups being created by copying this source backup. The backup names are of the form &#x60;projects//instances//backups/&#x60;. Referencing backups may exist in different instances. The existence of any referencing backup prevents the backup from being deleted. When the copy operation is done (either successfully completed or cancelled or the destination backup is deleted), the reference to the backup is removed.
   * @return referencingBackups
   */
  @javax.annotation.Nullable
  public List<String> getReferencingBackups() {
    return referencingBackups;
  }



  /**
   * Output only. The names of the restored databases that reference the backup. The database names are of the form &#x60;projects//instances//databases/&#x60;. Referencing databases may exist in different instances. The existence of any referencing database prevents the backup from being deleted. When a restored database from the backup enters the &#x60;READY&#x60; state, the reference to the backup is removed.
   * @return referencingDatabases
   */
  @javax.annotation.Nullable
  public List<String> getReferencingDatabases() {
    return referencingDatabases;
  }



  /**
   * Output only. Size of the backup in bytes.
   * @return sizeBytes
   */
  @javax.annotation.Nullable
  public String getSizeBytes() {
    return sizeBytes;
  }



  /**
   * Output only. The current state of the backup.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }



  public Backup versionTime(String versionTime) {
    this.versionTime = versionTime;
    return this;
  }

  /**
   * The backup will contain an externally consistent copy of the database at the timestamp specified by &#x60;version_time&#x60;. If &#x60;version_time&#x60; is not specified, the system will set &#x60;version_time&#x60; to the &#x60;create_time&#x60; of the backup.
   * @return versionTime
   */
  @javax.annotation.Nullable
  public String getVersionTime() {
    return versionTime;
  }

  public void setVersionTime(String versionTime) {
    this.versionTime = versionTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Backup backup = (Backup) o;
    return Objects.equals(this.createTime, backup.createTime) &&
        Objects.equals(this.database, backup.database) &&
        Objects.equals(this.databaseDialect, backup.databaseDialect) &&
        Objects.equals(this.encryptionInfo, backup.encryptionInfo) &&
        Objects.equals(this.expireTime, backup.expireTime) &&
        Objects.equals(this.maxExpireTime, backup.maxExpireTime) &&
        Objects.equals(this.name, backup.name) &&
        Objects.equals(this.referencingBackups, backup.referencingBackups) &&
        Objects.equals(this.referencingDatabases, backup.referencingDatabases) &&
        Objects.equals(this.sizeBytes, backup.sizeBytes) &&
        Objects.equals(this.state, backup.state) &&
        Objects.equals(this.versionTime, backup.versionTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createTime, database, databaseDialect, encryptionInfo, expireTime, maxExpireTime, name, referencingBackups, referencingDatabases, sizeBytes, state, versionTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Backup {\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    database: ").append(toIndentedString(database)).append("\n");
    sb.append("    databaseDialect: ").append(toIndentedString(databaseDialect)).append("\n");
    sb.append("    encryptionInfo: ").append(toIndentedString(encryptionInfo)).append("\n");
    sb.append("    expireTime: ").append(toIndentedString(expireTime)).append("\n");
    sb.append("    maxExpireTime: ").append(toIndentedString(maxExpireTime)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    referencingBackups: ").append(toIndentedString(referencingBackups)).append("\n");
    sb.append("    referencingDatabases: ").append(toIndentedString(referencingDatabases)).append("\n");
    sb.append("    sizeBytes: ").append(toIndentedString(sizeBytes)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    versionTime: ").append(toIndentedString(versionTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("createTime");
    openapiFields.add("database");
    openapiFields.add("databaseDialect");
    openapiFields.add("encryptionInfo");
    openapiFields.add("expireTime");
    openapiFields.add("maxExpireTime");
    openapiFields.add("name");
    openapiFields.add("referencingBackups");
    openapiFields.add("referencingDatabases");
    openapiFields.add("sizeBytes");
    openapiFields.add("state");
    openapiFields.add("versionTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Backup
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Backup.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Backup is not found in the empty JSON string", Backup.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Backup.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Backup` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("database") != null && !jsonObj.get("database").isJsonNull()) && !jsonObj.get("database").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `database` to be a primitive type in the JSON string but got `%s`", jsonObj.get("database").toString()));
      }
      if ((jsonObj.get("databaseDialect") != null && !jsonObj.get("databaseDialect").isJsonNull()) && !jsonObj.get("databaseDialect").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `databaseDialect` to be a primitive type in the JSON string but got `%s`", jsonObj.get("databaseDialect").toString()));
      }
      // validate the optional field `databaseDialect`
      if (jsonObj.get("databaseDialect") != null && !jsonObj.get("databaseDialect").isJsonNull()) {
        DatabaseDialectEnum.validateJsonElement(jsonObj.get("databaseDialect"));
      }
      // validate the optional field `encryptionInfo`
      if (jsonObj.get("encryptionInfo") != null && !jsonObj.get("encryptionInfo").isJsonNull()) {
        EncryptionInfo.validateJsonElement(jsonObj.get("encryptionInfo"));
      }
      if ((jsonObj.get("expireTime") != null && !jsonObj.get("expireTime").isJsonNull()) && !jsonObj.get("expireTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expireTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expireTime").toString()));
      }
      if ((jsonObj.get("maxExpireTime") != null && !jsonObj.get("maxExpireTime").isJsonNull()) && !jsonObj.get("maxExpireTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxExpireTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxExpireTime").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("referencingBackups") != null && !jsonObj.get("referencingBackups").isJsonNull() && !jsonObj.get("referencingBackups").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `referencingBackups` to be an array in the JSON string but got `%s`", jsonObj.get("referencingBackups").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("referencingDatabases") != null && !jsonObj.get("referencingDatabases").isJsonNull() && !jsonObj.get("referencingDatabases").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `referencingDatabases` to be an array in the JSON string but got `%s`", jsonObj.get("referencingDatabases").toString()));
      }
      if ((jsonObj.get("sizeBytes") != null && !jsonObj.get("sizeBytes").isJsonNull()) && !jsonObj.get("sizeBytes").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sizeBytes` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sizeBytes").toString()));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("versionTime") != null && !jsonObj.get("versionTime").isJsonNull()) && !jsonObj.get("versionTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `versionTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("versionTime").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Backup.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Backup' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Backup> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Backup.class));

       return (TypeAdapter<T>) new TypeAdapter<Backup>() {
           @Override
           public void write(JsonWriter out, Backup value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Backup read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Backup given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Backup
   * @throws IOException if the JSON string is invalid with respect to Backup
   */
  public static Backup fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Backup.class);
  }

  /**
   * Convert an instance of Backup to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

