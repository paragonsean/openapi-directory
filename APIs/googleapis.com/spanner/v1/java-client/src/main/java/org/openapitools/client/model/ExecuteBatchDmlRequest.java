/*
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.RequestOptions;
import org.openapitools.client.model.Statement;
import org.openapitools.client.model.TransactionSelector;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The request for ExecuteBatchDml.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:23.689684-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ExecuteBatchDmlRequest {
  public static final String SERIALIZED_NAME_REQUEST_OPTIONS = "requestOptions";
  @SerializedName(SERIALIZED_NAME_REQUEST_OPTIONS)
  private RequestOptions requestOptions;

  public static final String SERIALIZED_NAME_SEQNO = "seqno";
  @SerializedName(SERIALIZED_NAME_SEQNO)
  private String seqno;

  public static final String SERIALIZED_NAME_STATEMENTS = "statements";
  @SerializedName(SERIALIZED_NAME_STATEMENTS)
  private List<Statement> statements = new ArrayList<>();

  public static final String SERIALIZED_NAME_TRANSACTION = "transaction";
  @SerializedName(SERIALIZED_NAME_TRANSACTION)
  private TransactionSelector transaction;

  public ExecuteBatchDmlRequest() {
  }

  public ExecuteBatchDmlRequest requestOptions(RequestOptions requestOptions) {
    this.requestOptions = requestOptions;
    return this;
  }

  /**
   * Get requestOptions
   * @return requestOptions
   */
  @javax.annotation.Nullable
  public RequestOptions getRequestOptions() {
    return requestOptions;
  }

  public void setRequestOptions(RequestOptions requestOptions) {
    this.requestOptions = requestOptions;
  }


  public ExecuteBatchDmlRequest seqno(String seqno) {
    this.seqno = seqno;
    return this;
  }

  /**
   * Required. A per-transaction sequence number used to identify this request. This field makes each request idempotent such that if the request is received multiple times, at most one will succeed. The sequence number must be monotonically increasing within the transaction. If a request arrives for the first time with an out-of-order sequence number, the transaction may be aborted. Replays of previously handled requests will yield the same response as the first execution.
   * @return seqno
   */
  @javax.annotation.Nullable
  public String getSeqno() {
    return seqno;
  }

  public void setSeqno(String seqno) {
    this.seqno = seqno;
  }


  public ExecuteBatchDmlRequest statements(List<Statement> statements) {
    this.statements = statements;
    return this;
  }

  public ExecuteBatchDmlRequest addStatementsItem(Statement statementsItem) {
    if (this.statements == null) {
      this.statements = new ArrayList<>();
    }
    this.statements.add(statementsItem);
    return this;
  }

  /**
   * Required. The list of statements to execute in this batch. Statements are executed serially, such that the effects of statement &#x60;i&#x60; are visible to statement &#x60;i+1&#x60;. Each statement must be a DML statement. Execution stops at the first failed statement; the remaining statements are not executed. Callers must provide at least one statement.
   * @return statements
   */
  @javax.annotation.Nullable
  public List<Statement> getStatements() {
    return statements;
  }

  public void setStatements(List<Statement> statements) {
    this.statements = statements;
  }


  public ExecuteBatchDmlRequest transaction(TransactionSelector transaction) {
    this.transaction = transaction;
    return this;
  }

  /**
   * Get transaction
   * @return transaction
   */
  @javax.annotation.Nullable
  public TransactionSelector getTransaction() {
    return transaction;
  }

  public void setTransaction(TransactionSelector transaction) {
    this.transaction = transaction;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExecuteBatchDmlRequest executeBatchDmlRequest = (ExecuteBatchDmlRequest) o;
    return Objects.equals(this.requestOptions, executeBatchDmlRequest.requestOptions) &&
        Objects.equals(this.seqno, executeBatchDmlRequest.seqno) &&
        Objects.equals(this.statements, executeBatchDmlRequest.statements) &&
        Objects.equals(this.transaction, executeBatchDmlRequest.transaction);
  }

  @Override
  public int hashCode() {
    return Objects.hash(requestOptions, seqno, statements, transaction);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExecuteBatchDmlRequest {\n");
    sb.append("    requestOptions: ").append(toIndentedString(requestOptions)).append("\n");
    sb.append("    seqno: ").append(toIndentedString(seqno)).append("\n");
    sb.append("    statements: ").append(toIndentedString(statements)).append("\n");
    sb.append("    transaction: ").append(toIndentedString(transaction)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("requestOptions");
    openapiFields.add("seqno");
    openapiFields.add("statements");
    openapiFields.add("transaction");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ExecuteBatchDmlRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ExecuteBatchDmlRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExecuteBatchDmlRequest is not found in the empty JSON string", ExecuteBatchDmlRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ExecuteBatchDmlRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExecuteBatchDmlRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `requestOptions`
      if (jsonObj.get("requestOptions") != null && !jsonObj.get("requestOptions").isJsonNull()) {
        RequestOptions.validateJsonElement(jsonObj.get("requestOptions"));
      }
      if ((jsonObj.get("seqno") != null && !jsonObj.get("seqno").isJsonNull()) && !jsonObj.get("seqno").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `seqno` to be a primitive type in the JSON string but got `%s`", jsonObj.get("seqno").toString()));
      }
      if (jsonObj.get("statements") != null && !jsonObj.get("statements").isJsonNull()) {
        JsonArray jsonArraystatements = jsonObj.getAsJsonArray("statements");
        if (jsonArraystatements != null) {
          // ensure the json data is an array
          if (!jsonObj.get("statements").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `statements` to be an array in the JSON string but got `%s`", jsonObj.get("statements").toString()));
          }

          // validate the optional field `statements` (array)
          for (int i = 0; i < jsonArraystatements.size(); i++) {
            Statement.validateJsonElement(jsonArraystatements.get(i));
          };
        }
      }
      // validate the optional field `transaction`
      if (jsonObj.get("transaction") != null && !jsonObj.get("transaction").isJsonNull()) {
        TransactionSelector.validateJsonElement(jsonObj.get("transaction"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExecuteBatchDmlRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExecuteBatchDmlRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExecuteBatchDmlRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExecuteBatchDmlRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ExecuteBatchDmlRequest>() {
           @Override
           public void write(JsonWriter out, ExecuteBatchDmlRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExecuteBatchDmlRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ExecuteBatchDmlRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ExecuteBatchDmlRequest
   * @throws IOException if the JSON string is invalid with respect to ExecuteBatchDmlRequest
   */
  public static ExecuteBatchDmlRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExecuteBatchDmlRequest.class);
  }

  /**
   * Convert an instance of ExecuteBatchDmlRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

