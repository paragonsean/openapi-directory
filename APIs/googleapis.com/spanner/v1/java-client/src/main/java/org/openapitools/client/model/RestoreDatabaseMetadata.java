/*
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.BackupInfo;
import org.openapitools.client.model.OperationProgress;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Metadata type for the long-running operation returned by RestoreDatabase.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:23.689684-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RestoreDatabaseMetadata {
  public static final String SERIALIZED_NAME_BACKUP_INFO = "backupInfo";
  @SerializedName(SERIALIZED_NAME_BACKUP_INFO)
  private BackupInfo backupInfo;

  public static final String SERIALIZED_NAME_CANCEL_TIME = "cancelTime";
  @SerializedName(SERIALIZED_NAME_CANCEL_TIME)
  private String cancelTime;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OPTIMIZE_DATABASE_OPERATION_NAME = "optimizeDatabaseOperationName";
  @SerializedName(SERIALIZED_NAME_OPTIMIZE_DATABASE_OPERATION_NAME)
  private String optimizeDatabaseOperationName;

  public static final String SERIALIZED_NAME_PROGRESS = "progress";
  @SerializedName(SERIALIZED_NAME_PROGRESS)
  private OperationProgress progress;

  /**
   * The type of the restore source.
   */
  @JsonAdapter(SourceTypeEnum.Adapter.class)
  public enum SourceTypeEnum {
    TYPE_UNSPECIFIED("TYPE_UNSPECIFIED"),
    
    BACKUP("BACKUP");

    private String value;

    SourceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SourceTypeEnum fromValue(String value) {
      for (SourceTypeEnum b : SourceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SourceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SourceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SourceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SourceTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SourceTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SOURCE_TYPE = "sourceType";
  @SerializedName(SERIALIZED_NAME_SOURCE_TYPE)
  private SourceTypeEnum sourceType;

  public RestoreDatabaseMetadata() {
  }

  public RestoreDatabaseMetadata backupInfo(BackupInfo backupInfo) {
    this.backupInfo = backupInfo;
    return this;
  }

  /**
   * Get backupInfo
   * @return backupInfo
   */
  @javax.annotation.Nullable
  public BackupInfo getBackupInfo() {
    return backupInfo;
  }

  public void setBackupInfo(BackupInfo backupInfo) {
    this.backupInfo = backupInfo;
  }


  public RestoreDatabaseMetadata cancelTime(String cancelTime) {
    this.cancelTime = cancelTime;
    return this;
  }

  /**
   * The time at which cancellation of this operation was received. Operations.CancelOperation starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to &#x60;Code.CANCELLED&#x60;.
   * @return cancelTime
   */
  @javax.annotation.Nullable
  public String getCancelTime() {
    return cancelTime;
  }

  public void setCancelTime(String cancelTime) {
    this.cancelTime = cancelTime;
  }


  public RestoreDatabaseMetadata name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of the database being created and restored to.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public RestoreDatabaseMetadata optimizeDatabaseOperationName(String optimizeDatabaseOperationName) {
    this.optimizeDatabaseOperationName = optimizeDatabaseOperationName;
    return this;
  }

  /**
   * If exists, the name of the long-running operation that will be used to track the post-restore optimization process to optimize the performance of the restored database, and remove the dependency on the restore source. The name is of the form &#x60;projects//instances//databases//operations/&#x60; where the is the name of database being created and restored to. The metadata type of the long-running operation is OptimizeRestoredDatabaseMetadata. This long-running operation will be automatically created by the system after the RestoreDatabase long-running operation completes successfully. This operation will not be created if the restore was not successful.
   * @return optimizeDatabaseOperationName
   */
  @javax.annotation.Nullable
  public String getOptimizeDatabaseOperationName() {
    return optimizeDatabaseOperationName;
  }

  public void setOptimizeDatabaseOperationName(String optimizeDatabaseOperationName) {
    this.optimizeDatabaseOperationName = optimizeDatabaseOperationName;
  }


  public RestoreDatabaseMetadata progress(OperationProgress progress) {
    this.progress = progress;
    return this;
  }

  /**
   * Get progress
   * @return progress
   */
  @javax.annotation.Nullable
  public OperationProgress getProgress() {
    return progress;
  }

  public void setProgress(OperationProgress progress) {
    this.progress = progress;
  }


  public RestoreDatabaseMetadata sourceType(SourceTypeEnum sourceType) {
    this.sourceType = sourceType;
    return this;
  }

  /**
   * The type of the restore source.
   * @return sourceType
   */
  @javax.annotation.Nullable
  public SourceTypeEnum getSourceType() {
    return sourceType;
  }

  public void setSourceType(SourceTypeEnum sourceType) {
    this.sourceType = sourceType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RestoreDatabaseMetadata restoreDatabaseMetadata = (RestoreDatabaseMetadata) o;
    return Objects.equals(this.backupInfo, restoreDatabaseMetadata.backupInfo) &&
        Objects.equals(this.cancelTime, restoreDatabaseMetadata.cancelTime) &&
        Objects.equals(this.name, restoreDatabaseMetadata.name) &&
        Objects.equals(this.optimizeDatabaseOperationName, restoreDatabaseMetadata.optimizeDatabaseOperationName) &&
        Objects.equals(this.progress, restoreDatabaseMetadata.progress) &&
        Objects.equals(this.sourceType, restoreDatabaseMetadata.sourceType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(backupInfo, cancelTime, name, optimizeDatabaseOperationName, progress, sourceType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RestoreDatabaseMetadata {\n");
    sb.append("    backupInfo: ").append(toIndentedString(backupInfo)).append("\n");
    sb.append("    cancelTime: ").append(toIndentedString(cancelTime)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    optimizeDatabaseOperationName: ").append(toIndentedString(optimizeDatabaseOperationName)).append("\n");
    sb.append("    progress: ").append(toIndentedString(progress)).append("\n");
    sb.append("    sourceType: ").append(toIndentedString(sourceType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("backupInfo");
    openapiFields.add("cancelTime");
    openapiFields.add("name");
    openapiFields.add("optimizeDatabaseOperationName");
    openapiFields.add("progress");
    openapiFields.add("sourceType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RestoreDatabaseMetadata
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RestoreDatabaseMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RestoreDatabaseMetadata is not found in the empty JSON string", RestoreDatabaseMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RestoreDatabaseMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RestoreDatabaseMetadata` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `backupInfo`
      if (jsonObj.get("backupInfo") != null && !jsonObj.get("backupInfo").isJsonNull()) {
        BackupInfo.validateJsonElement(jsonObj.get("backupInfo"));
      }
      if ((jsonObj.get("cancelTime") != null && !jsonObj.get("cancelTime").isJsonNull()) && !jsonObj.get("cancelTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cancelTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cancelTime").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("optimizeDatabaseOperationName") != null && !jsonObj.get("optimizeDatabaseOperationName").isJsonNull()) && !jsonObj.get("optimizeDatabaseOperationName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `optimizeDatabaseOperationName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("optimizeDatabaseOperationName").toString()));
      }
      // validate the optional field `progress`
      if (jsonObj.get("progress") != null && !jsonObj.get("progress").isJsonNull()) {
        OperationProgress.validateJsonElement(jsonObj.get("progress"));
      }
      if ((jsonObj.get("sourceType") != null && !jsonObj.get("sourceType").isJsonNull()) && !jsonObj.get("sourceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceType").toString()));
      }
      // validate the optional field `sourceType`
      if (jsonObj.get("sourceType") != null && !jsonObj.get("sourceType").isJsonNull()) {
        SourceTypeEnum.validateJsonElement(jsonObj.get("sourceType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RestoreDatabaseMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RestoreDatabaseMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RestoreDatabaseMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RestoreDatabaseMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<RestoreDatabaseMetadata>() {
           @Override
           public void write(JsonWriter out, RestoreDatabaseMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RestoreDatabaseMetadata read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RestoreDatabaseMetadata given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RestoreDatabaseMetadata
   * @throws IOException if the JSON string is invalid with respect to RestoreDatabaseMetadata
   */
  public static RestoreDatabaseMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RestoreDatabaseMetadata.class);
  }

  /**
   * Convert an instance of RestoreDatabaseMetadata to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

