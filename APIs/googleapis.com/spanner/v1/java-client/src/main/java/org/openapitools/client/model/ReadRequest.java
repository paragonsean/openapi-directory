/*
 * Cloud Spanner API
 * Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DirectedReadOptions;
import org.openapitools.client.model.KeySet;
import org.openapitools.client.model.RequestOptions;
import org.openapitools.client.model.TransactionSelector;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The request for Read and StreamingRead.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:23.689684-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ReadRequest {
  public static final String SERIALIZED_NAME_COLUMNS = "columns";
  @SerializedName(SERIALIZED_NAME_COLUMNS)
  private List<String> columns = new ArrayList<>();

  public static final String SERIALIZED_NAME_DATA_BOOST_ENABLED = "dataBoostEnabled";
  @SerializedName(SERIALIZED_NAME_DATA_BOOST_ENABLED)
  private Boolean dataBoostEnabled;

  public static final String SERIALIZED_NAME_DIRECTED_READ_OPTIONS = "directedReadOptions";
  @SerializedName(SERIALIZED_NAME_DIRECTED_READ_OPTIONS)
  private DirectedReadOptions directedReadOptions;

  public static final String SERIALIZED_NAME_INDEX = "index";
  @SerializedName(SERIALIZED_NAME_INDEX)
  private String index;

  public static final String SERIALIZED_NAME_KEY_SET = "keySet";
  @SerializedName(SERIALIZED_NAME_KEY_SET)
  private KeySet keySet;

  public static final String SERIALIZED_NAME_LIMIT = "limit";
  @SerializedName(SERIALIZED_NAME_LIMIT)
  private String limit;

  public static final String SERIALIZED_NAME_PARTITION_TOKEN = "partitionToken";
  @SerializedName(SERIALIZED_NAME_PARTITION_TOKEN)
  private byte[] partitionToken;

  public static final String SERIALIZED_NAME_REQUEST_OPTIONS = "requestOptions";
  @SerializedName(SERIALIZED_NAME_REQUEST_OPTIONS)
  private RequestOptions requestOptions;

  public static final String SERIALIZED_NAME_RESUME_TOKEN = "resumeToken";
  @SerializedName(SERIALIZED_NAME_RESUME_TOKEN)
  private byte[] resumeToken;

  public static final String SERIALIZED_NAME_TABLE = "table";
  @SerializedName(SERIALIZED_NAME_TABLE)
  private String table;

  public static final String SERIALIZED_NAME_TRANSACTION = "transaction";
  @SerializedName(SERIALIZED_NAME_TRANSACTION)
  private TransactionSelector transaction;

  public ReadRequest() {
  }

  public ReadRequest columns(List<String> columns) {
    this.columns = columns;
    return this;
  }

  public ReadRequest addColumnsItem(String columnsItem) {
    if (this.columns == null) {
      this.columns = new ArrayList<>();
    }
    this.columns.add(columnsItem);
    return this;
  }

  /**
   * Required. The columns of table to be returned for each row matching this request.
   * @return columns
   */
  @javax.annotation.Nullable
  public List<String> getColumns() {
    return columns;
  }

  public void setColumns(List<String> columns) {
    this.columns = columns;
  }


  public ReadRequest dataBoostEnabled(Boolean dataBoostEnabled) {
    this.dataBoostEnabled = dataBoostEnabled;
    return this;
  }

  /**
   * If this is for a partitioned read and this field is set to &#x60;true&#x60;, the request is executed with Spanner Data Boost independent compute resources. If the field is set to &#x60;true&#x60; but the request does not set &#x60;partition_token&#x60;, the API returns an &#x60;INVALID_ARGUMENT&#x60; error.
   * @return dataBoostEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDataBoostEnabled() {
    return dataBoostEnabled;
  }

  public void setDataBoostEnabled(Boolean dataBoostEnabled) {
    this.dataBoostEnabled = dataBoostEnabled;
  }


  public ReadRequest directedReadOptions(DirectedReadOptions directedReadOptions) {
    this.directedReadOptions = directedReadOptions;
    return this;
  }

  /**
   * Get directedReadOptions
   * @return directedReadOptions
   */
  @javax.annotation.Nullable
  public DirectedReadOptions getDirectedReadOptions() {
    return directedReadOptions;
  }

  public void setDirectedReadOptions(DirectedReadOptions directedReadOptions) {
    this.directedReadOptions = directedReadOptions;
  }


  public ReadRequest index(String index) {
    this.index = index;
    return this;
  }

  /**
   * If non-empty, the name of an index on table. This index is used instead of the table primary key when interpreting key_set and sorting result rows. See key_set for further information.
   * @return index
   */
  @javax.annotation.Nullable
  public String getIndex() {
    return index;
  }

  public void setIndex(String index) {
    this.index = index;
  }


  public ReadRequest keySet(KeySet keySet) {
    this.keySet = keySet;
    return this;
  }

  /**
   * Get keySet
   * @return keySet
   */
  @javax.annotation.Nullable
  public KeySet getKeySet() {
    return keySet;
  }

  public void setKeySet(KeySet keySet) {
    this.keySet = keySet;
  }


  public ReadRequest limit(String limit) {
    this.limit = limit;
    return this;
  }

  /**
   * If greater than zero, only the first &#x60;limit&#x60; rows are yielded. If &#x60;limit&#x60; is zero, the default is no limit. A limit cannot be specified if &#x60;partition_token&#x60; is set.
   * @return limit
   */
  @javax.annotation.Nullable
  public String getLimit() {
    return limit;
  }

  public void setLimit(String limit) {
    this.limit = limit;
  }


  public ReadRequest partitionToken(byte[] partitionToken) {
    this.partitionToken = partitionToken;
    return this;
  }

  /**
   * If present, results will be restricted to the specified partition previously created using PartitionRead(). There must be an exact match for the values of fields common to this message and the PartitionReadRequest message used to create this partition_token.
   * @return partitionToken
   */
  @javax.annotation.Nullable
  public byte[] getPartitionToken() {
    return partitionToken;
  }

  public void setPartitionToken(byte[] partitionToken) {
    this.partitionToken = partitionToken;
  }


  public ReadRequest requestOptions(RequestOptions requestOptions) {
    this.requestOptions = requestOptions;
    return this;
  }

  /**
   * Get requestOptions
   * @return requestOptions
   */
  @javax.annotation.Nullable
  public RequestOptions getRequestOptions() {
    return requestOptions;
  }

  public void setRequestOptions(RequestOptions requestOptions) {
    this.requestOptions = requestOptions;
  }


  public ReadRequest resumeToken(byte[] resumeToken) {
    this.resumeToken = resumeToken;
    return this;
  }

  /**
   * If this request is resuming a previously interrupted read, &#x60;resume_token&#x60; should be copied from the last PartialResultSet yielded before the interruption. Doing this enables the new read to resume where the last read left off. The rest of the request parameters must exactly match the request that yielded this token.
   * @return resumeToken
   */
  @javax.annotation.Nullable
  public byte[] getResumeToken() {
    return resumeToken;
  }

  public void setResumeToken(byte[] resumeToken) {
    this.resumeToken = resumeToken;
  }


  public ReadRequest table(String table) {
    this.table = table;
    return this;
  }

  /**
   * Required. The name of the table in the database to be read.
   * @return table
   */
  @javax.annotation.Nullable
  public String getTable() {
    return table;
  }

  public void setTable(String table) {
    this.table = table;
  }


  public ReadRequest transaction(TransactionSelector transaction) {
    this.transaction = transaction;
    return this;
  }

  /**
   * Get transaction
   * @return transaction
   */
  @javax.annotation.Nullable
  public TransactionSelector getTransaction() {
    return transaction;
  }

  public void setTransaction(TransactionSelector transaction) {
    this.transaction = transaction;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReadRequest readRequest = (ReadRequest) o;
    return Objects.equals(this.columns, readRequest.columns) &&
        Objects.equals(this.dataBoostEnabled, readRequest.dataBoostEnabled) &&
        Objects.equals(this.directedReadOptions, readRequest.directedReadOptions) &&
        Objects.equals(this.index, readRequest.index) &&
        Objects.equals(this.keySet, readRequest.keySet) &&
        Objects.equals(this.limit, readRequest.limit) &&
        Arrays.equals(this.partitionToken, readRequest.partitionToken) &&
        Objects.equals(this.requestOptions, readRequest.requestOptions) &&
        Arrays.equals(this.resumeToken, readRequest.resumeToken) &&
        Objects.equals(this.table, readRequest.table) &&
        Objects.equals(this.transaction, readRequest.transaction);
  }

  @Override
  public int hashCode() {
    return Objects.hash(columns, dataBoostEnabled, directedReadOptions, index, keySet, limit, Arrays.hashCode(partitionToken), requestOptions, Arrays.hashCode(resumeToken), table, transaction);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReadRequest {\n");
    sb.append("    columns: ").append(toIndentedString(columns)).append("\n");
    sb.append("    dataBoostEnabled: ").append(toIndentedString(dataBoostEnabled)).append("\n");
    sb.append("    directedReadOptions: ").append(toIndentedString(directedReadOptions)).append("\n");
    sb.append("    index: ").append(toIndentedString(index)).append("\n");
    sb.append("    keySet: ").append(toIndentedString(keySet)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    partitionToken: ").append(toIndentedString(partitionToken)).append("\n");
    sb.append("    requestOptions: ").append(toIndentedString(requestOptions)).append("\n");
    sb.append("    resumeToken: ").append(toIndentedString(resumeToken)).append("\n");
    sb.append("    table: ").append(toIndentedString(table)).append("\n");
    sb.append("    transaction: ").append(toIndentedString(transaction)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("columns");
    openapiFields.add("dataBoostEnabled");
    openapiFields.add("directedReadOptions");
    openapiFields.add("index");
    openapiFields.add("keySet");
    openapiFields.add("limit");
    openapiFields.add("partitionToken");
    openapiFields.add("requestOptions");
    openapiFields.add("resumeToken");
    openapiFields.add("table");
    openapiFields.add("transaction");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ReadRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ReadRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ReadRequest is not found in the empty JSON string", ReadRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ReadRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ReadRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("columns") != null && !jsonObj.get("columns").isJsonNull() && !jsonObj.get("columns").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `columns` to be an array in the JSON string but got `%s`", jsonObj.get("columns").toString()));
      }
      // validate the optional field `directedReadOptions`
      if (jsonObj.get("directedReadOptions") != null && !jsonObj.get("directedReadOptions").isJsonNull()) {
        DirectedReadOptions.validateJsonElement(jsonObj.get("directedReadOptions"));
      }
      if ((jsonObj.get("index") != null && !jsonObj.get("index").isJsonNull()) && !jsonObj.get("index").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `index` to be a primitive type in the JSON string but got `%s`", jsonObj.get("index").toString()));
      }
      // validate the optional field `keySet`
      if (jsonObj.get("keySet") != null && !jsonObj.get("keySet").isJsonNull()) {
        KeySet.validateJsonElement(jsonObj.get("keySet"));
      }
      if ((jsonObj.get("limit") != null && !jsonObj.get("limit").isJsonNull()) && !jsonObj.get("limit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `limit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("limit").toString()));
      }
      // validate the optional field `requestOptions`
      if (jsonObj.get("requestOptions") != null && !jsonObj.get("requestOptions").isJsonNull()) {
        RequestOptions.validateJsonElement(jsonObj.get("requestOptions"));
      }
      if ((jsonObj.get("table") != null && !jsonObj.get("table").isJsonNull()) && !jsonObj.get("table").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `table` to be a primitive type in the JSON string but got `%s`", jsonObj.get("table").toString()));
      }
      // validate the optional field `transaction`
      if (jsonObj.get("transaction") != null && !jsonObj.get("transaction").isJsonNull()) {
        TransactionSelector.validateJsonElement(jsonObj.get("transaction"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ReadRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ReadRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ReadRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ReadRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ReadRequest>() {
           @Override
           public void write(JsonWriter out, ReadRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ReadRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ReadRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ReadRequest
   * @throws IOException if the JSON string is invalid with respect to ReadRequest
   */
  public static ReadRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ReadRequest.class);
  }

  /**
   * Convert an instance of ReadRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

