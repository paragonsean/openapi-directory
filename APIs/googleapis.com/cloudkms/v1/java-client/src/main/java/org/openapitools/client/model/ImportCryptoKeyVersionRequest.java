/*
 * Cloud Key Management Service (KMS) API
 * Manages keys and performs cryptographic operations in a central cloud service, for direct use by other cloud resources and applications. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Request message for KeyManagementService.ImportCryptoKeyVersion.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:42:14.760057-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ImportCryptoKeyVersionRequest {
  /**
   * Required. The algorithm of the key being imported. This does not need to match the version_template of the CryptoKey this version imports into.
   */
  @JsonAdapter(AlgorithmEnum.Adapter.class)
  public enum AlgorithmEnum {
    CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED("CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED"),
    
    GOOGLE_SYMMETRIC_ENCRYPTION("GOOGLE_SYMMETRIC_ENCRYPTION"),
    
    AES_128_GCM("AES_128_GCM"),
    
    AES_256_GCM("AES_256_GCM"),
    
    AES_128_CBC("AES_128_CBC"),
    
    AES_256_CBC("AES_256_CBC"),
    
    AES_128_CTR("AES_128_CTR"),
    
    AES_256_CTR("AES_256_CTR"),
    
    RSA_SIGN_PSS_2048_SHA256("RSA_SIGN_PSS_2048_SHA256"),
    
    RSA_SIGN_PSS_3072_SHA256("RSA_SIGN_PSS_3072_SHA256"),
    
    RSA_SIGN_PSS_4096_SHA256("RSA_SIGN_PSS_4096_SHA256"),
    
    RSA_SIGN_PSS_4096_SHA512("RSA_SIGN_PSS_4096_SHA512"),
    
    RSA_SIGN_PKCS1_2048_SHA256("RSA_SIGN_PKCS1_2048_SHA256"),
    
    RSA_SIGN_PKCS1_3072_SHA256("RSA_SIGN_PKCS1_3072_SHA256"),
    
    RSA_SIGN_PKCS1_4096_SHA256("RSA_SIGN_PKCS1_4096_SHA256"),
    
    RSA_SIGN_PKCS1_4096_SHA512("RSA_SIGN_PKCS1_4096_SHA512"),
    
    RSA_SIGN_RAW_PKCS1_2048("RSA_SIGN_RAW_PKCS1_2048"),
    
    RSA_SIGN_RAW_PKCS1_3072("RSA_SIGN_RAW_PKCS1_3072"),
    
    RSA_SIGN_RAW_PKCS1_4096("RSA_SIGN_RAW_PKCS1_4096"),
    
    RSA_DECRYPT_OAEP_2048_SHA256("RSA_DECRYPT_OAEP_2048_SHA256"),
    
    RSA_DECRYPT_OAEP_3072_SHA256("RSA_DECRYPT_OAEP_3072_SHA256"),
    
    RSA_DECRYPT_OAEP_4096_SHA256("RSA_DECRYPT_OAEP_4096_SHA256"),
    
    RSA_DECRYPT_OAEP_4096_SHA512("RSA_DECRYPT_OAEP_4096_SHA512"),
    
    RSA_DECRYPT_OAEP_2048_SHA1("RSA_DECRYPT_OAEP_2048_SHA1"),
    
    RSA_DECRYPT_OAEP_3072_SHA1("RSA_DECRYPT_OAEP_3072_SHA1"),
    
    RSA_DECRYPT_OAEP_4096_SHA1("RSA_DECRYPT_OAEP_4096_SHA1"),
    
    EC_SIGN_P256_SHA256("EC_SIGN_P256_SHA256"),
    
    EC_SIGN_P384_SHA384("EC_SIGN_P384_SHA384"),
    
    EC_SIGN_SECP256_K1_SHA256("EC_SIGN_SECP256K1_SHA256"),
    
    HMAC_SHA256("HMAC_SHA256"),
    
    HMAC_SHA1("HMAC_SHA1"),
    
    HMAC_SHA384("HMAC_SHA384"),
    
    HMAC_SHA512("HMAC_SHA512"),
    
    HMAC_SHA224("HMAC_SHA224"),
    
    EXTERNAL_SYMMETRIC_ENCRYPTION("EXTERNAL_SYMMETRIC_ENCRYPTION");

    private String value;

    AlgorithmEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AlgorithmEnum fromValue(String value) {
      for (AlgorithmEnum b : AlgorithmEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AlgorithmEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AlgorithmEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AlgorithmEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AlgorithmEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AlgorithmEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ALGORITHM = "algorithm";
  @SerializedName(SERIALIZED_NAME_ALGORITHM)
  private AlgorithmEnum algorithm;

  public static final String SERIALIZED_NAME_CRYPTO_KEY_VERSION = "cryptoKeyVersion";
  @SerializedName(SERIALIZED_NAME_CRYPTO_KEY_VERSION)
  private String cryptoKeyVersion;

  public static final String SERIALIZED_NAME_IMPORT_JOB = "importJob";
  @SerializedName(SERIALIZED_NAME_IMPORT_JOB)
  private String importJob;

  public static final String SERIALIZED_NAME_RSA_AES_WRAPPED_KEY = "rsaAesWrappedKey";
  @SerializedName(SERIALIZED_NAME_RSA_AES_WRAPPED_KEY)
  private byte[] rsaAesWrappedKey;

  public static final String SERIALIZED_NAME_WRAPPED_KEY = "wrappedKey";
  @SerializedName(SERIALIZED_NAME_WRAPPED_KEY)
  private byte[] wrappedKey;

  public ImportCryptoKeyVersionRequest() {
  }

  public ImportCryptoKeyVersionRequest algorithm(AlgorithmEnum algorithm) {
    this.algorithm = algorithm;
    return this;
  }

  /**
   * Required. The algorithm of the key being imported. This does not need to match the version_template of the CryptoKey this version imports into.
   * @return algorithm
   */
  @javax.annotation.Nullable
  public AlgorithmEnum getAlgorithm() {
    return algorithm;
  }

  public void setAlgorithm(AlgorithmEnum algorithm) {
    this.algorithm = algorithm;
  }


  public ImportCryptoKeyVersionRequest cryptoKeyVersion(String cryptoKeyVersion) {
    this.cryptoKeyVersion = cryptoKeyVersion;
    return this;
  }

  /**
   * Optional. The optional name of an existing CryptoKeyVersion to target for an import operation. If this field is not present, a new CryptoKeyVersion containing the supplied key material is created. If this field is present, the supplied key material is imported into the existing CryptoKeyVersion. To import into an existing CryptoKeyVersion, the CryptoKeyVersion must be a child of ImportCryptoKeyVersionRequest.parent, have been previously created via ImportCryptoKeyVersion, and be in DESTROYED or IMPORT_FAILED state. The key material and algorithm must match the previous CryptoKeyVersion exactly if the CryptoKeyVersion has ever contained key material.
   * @return cryptoKeyVersion
   */
  @javax.annotation.Nullable
  public String getCryptoKeyVersion() {
    return cryptoKeyVersion;
  }

  public void setCryptoKeyVersion(String cryptoKeyVersion) {
    this.cryptoKeyVersion = cryptoKeyVersion;
  }


  public ImportCryptoKeyVersionRequest importJob(String importJob) {
    this.importJob = importJob;
    return this;
  }

  /**
   * Required. The name of the ImportJob that was used to wrap this key material.
   * @return importJob
   */
  @javax.annotation.Nullable
  public String getImportJob() {
    return importJob;
  }

  public void setImportJob(String importJob) {
    this.importJob = importJob;
  }


  public ImportCryptoKeyVersionRequest rsaAesWrappedKey(byte[] rsaAesWrappedKey) {
    this.rsaAesWrappedKey = rsaAesWrappedKey;
    return this;
  }

  /**
   * Optional. This field has the same meaning as wrapped_key. Prefer to use that field in new work. Either that field or this field (but not both) must be specified.
   * @return rsaAesWrappedKey
   */
  @javax.annotation.Nullable
  public byte[] getRsaAesWrappedKey() {
    return rsaAesWrappedKey;
  }

  public void setRsaAesWrappedKey(byte[] rsaAesWrappedKey) {
    this.rsaAesWrappedKey = rsaAesWrappedKey;
  }


  public ImportCryptoKeyVersionRequest wrappedKey(byte[] wrappedKey) {
    this.wrappedKey = wrappedKey;
    return this;
  }

  /**
   * Optional. The wrapped key material to import. Before wrapping, key material must be formatted. If importing symmetric key material, the expected key material format is plain bytes. If importing asymmetric key material, the expected key material format is PKCS#8-encoded DER (the PrivateKeyInfo structure from RFC 5208). When wrapping with import methods (RSA_OAEP_3072_SHA1_AES_256 or RSA_OAEP_4096_SHA1_AES_256 or RSA_OAEP_3072_SHA256_AES_256 or RSA_OAEP_4096_SHA256_AES_256), this field must contain the concatenation of: 1. An ephemeral AES-256 wrapping key wrapped with the public_key using RSAES-OAEP with SHA-1/SHA-256, MGF1 with SHA-1/SHA-256, and an empty label. 2. The formatted key to be imported, wrapped with the ephemeral AES-256 key using AES-KWP (RFC 5649). This format is the same as the format produced by PKCS#11 mechanism CKM_RSA_AES_KEY_WRAP. When wrapping with import methods (RSA_OAEP_3072_SHA256 or RSA_OAEP_4096_SHA256), this field must contain the formatted key to be imported, wrapped with the public_key using RSAES-OAEP with SHA-256, MGF1 with SHA-256, and an empty label.
   * @return wrappedKey
   */
  @javax.annotation.Nullable
  public byte[] getWrappedKey() {
    return wrappedKey;
  }

  public void setWrappedKey(byte[] wrappedKey) {
    this.wrappedKey = wrappedKey;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ImportCryptoKeyVersionRequest importCryptoKeyVersionRequest = (ImportCryptoKeyVersionRequest) o;
    return Objects.equals(this.algorithm, importCryptoKeyVersionRequest.algorithm) &&
        Objects.equals(this.cryptoKeyVersion, importCryptoKeyVersionRequest.cryptoKeyVersion) &&
        Objects.equals(this.importJob, importCryptoKeyVersionRequest.importJob) &&
        Arrays.equals(this.rsaAesWrappedKey, importCryptoKeyVersionRequest.rsaAesWrappedKey) &&
        Arrays.equals(this.wrappedKey, importCryptoKeyVersionRequest.wrappedKey);
  }

  @Override
  public int hashCode() {
    return Objects.hash(algorithm, cryptoKeyVersion, importJob, Arrays.hashCode(rsaAesWrappedKey), Arrays.hashCode(wrappedKey));
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ImportCryptoKeyVersionRequest {\n");
    sb.append("    algorithm: ").append(toIndentedString(algorithm)).append("\n");
    sb.append("    cryptoKeyVersion: ").append(toIndentedString(cryptoKeyVersion)).append("\n");
    sb.append("    importJob: ").append(toIndentedString(importJob)).append("\n");
    sb.append("    rsaAesWrappedKey: ").append(toIndentedString(rsaAesWrappedKey)).append("\n");
    sb.append("    wrappedKey: ").append(toIndentedString(wrappedKey)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("algorithm");
    openapiFields.add("cryptoKeyVersion");
    openapiFields.add("importJob");
    openapiFields.add("rsaAesWrappedKey");
    openapiFields.add("wrappedKey");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ImportCryptoKeyVersionRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ImportCryptoKeyVersionRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ImportCryptoKeyVersionRequest is not found in the empty JSON string", ImportCryptoKeyVersionRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ImportCryptoKeyVersionRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ImportCryptoKeyVersionRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("algorithm") != null && !jsonObj.get("algorithm").isJsonNull()) && !jsonObj.get("algorithm").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `algorithm` to be a primitive type in the JSON string but got `%s`", jsonObj.get("algorithm").toString()));
      }
      // validate the optional field `algorithm`
      if (jsonObj.get("algorithm") != null && !jsonObj.get("algorithm").isJsonNull()) {
        AlgorithmEnum.validateJsonElement(jsonObj.get("algorithm"));
      }
      if ((jsonObj.get("cryptoKeyVersion") != null && !jsonObj.get("cryptoKeyVersion").isJsonNull()) && !jsonObj.get("cryptoKeyVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cryptoKeyVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cryptoKeyVersion").toString()));
      }
      if ((jsonObj.get("importJob") != null && !jsonObj.get("importJob").isJsonNull()) && !jsonObj.get("importJob").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `importJob` to be a primitive type in the JSON string but got `%s`", jsonObj.get("importJob").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ImportCryptoKeyVersionRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ImportCryptoKeyVersionRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ImportCryptoKeyVersionRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ImportCryptoKeyVersionRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ImportCryptoKeyVersionRequest>() {
           @Override
           public void write(JsonWriter out, ImportCryptoKeyVersionRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ImportCryptoKeyVersionRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ImportCryptoKeyVersionRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ImportCryptoKeyVersionRequest
   * @throws IOException if the JSON string is invalid with respect to ImportCryptoKeyVersionRequest
   */
  public static ImportCryptoKeyVersionRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ImportCryptoKeyVersionRequest.class);
  }

  /**
   * Convert an instance of ImportCryptoKeyVersionRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

