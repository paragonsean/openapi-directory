/*
 * Cloud Key Management Service (KMS) API
 * Manages keys and performs cryptographic operations in a central cloud service, for direct use by other cloud resources and applications. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.CryptoKeyVersion;
import org.openapitools.client.model.CryptoKeyVersionTemplate;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A CryptoKey represents a logical key that can be used for cryptographic operations. A CryptoKey is made up of zero or more versions, which represent the actual key material used in cryptographic operations.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:42:14.760057-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CryptoKey {
  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_CRYPTO_KEY_BACKEND = "cryptoKeyBackend";
  @SerializedName(SERIALIZED_NAME_CRYPTO_KEY_BACKEND)
  private String cryptoKeyBackend;

  public static final String SERIALIZED_NAME_DESTROY_SCHEDULED_DURATION = "destroyScheduledDuration";
  @SerializedName(SERIALIZED_NAME_DESTROY_SCHEDULED_DURATION)
  private String destroyScheduledDuration;

  public static final String SERIALIZED_NAME_IMPORT_ONLY = "importOnly";
  @SerializedName(SERIALIZED_NAME_IMPORT_ONLY)
  private Boolean importOnly;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NEXT_ROTATION_TIME = "nextRotationTime";
  @SerializedName(SERIALIZED_NAME_NEXT_ROTATION_TIME)
  private String nextRotationTime;

  public static final String SERIALIZED_NAME_PRIMARY = "primary";
  @SerializedName(SERIALIZED_NAME_PRIMARY)
  private CryptoKeyVersion primary;

  /**
   * Immutable. The immutable purpose of this CryptoKey.
   */
  @JsonAdapter(PurposeEnum.Adapter.class)
  public enum PurposeEnum {
    CRYPTO_KEY_PURPOSE_UNSPECIFIED("CRYPTO_KEY_PURPOSE_UNSPECIFIED"),
    
    ENCRYPT_DECRYPT("ENCRYPT_DECRYPT"),
    
    ASYMMETRIC_SIGN("ASYMMETRIC_SIGN"),
    
    ASYMMETRIC_DECRYPT("ASYMMETRIC_DECRYPT"),
    
    RAW_ENCRYPT_DECRYPT("RAW_ENCRYPT_DECRYPT"),
    
    MAC("MAC");

    private String value;

    PurposeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PurposeEnum fromValue(String value) {
      for (PurposeEnum b : PurposeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PurposeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PurposeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PurposeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PurposeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PurposeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PURPOSE = "purpose";
  @SerializedName(SERIALIZED_NAME_PURPOSE)
  private PurposeEnum purpose;

  public static final String SERIALIZED_NAME_ROTATION_PERIOD = "rotationPeriod";
  @SerializedName(SERIALIZED_NAME_ROTATION_PERIOD)
  private String rotationPeriod;

  public static final String SERIALIZED_NAME_VERSION_TEMPLATE = "versionTemplate";
  @SerializedName(SERIALIZED_NAME_VERSION_TEMPLATE)
  private CryptoKeyVersionTemplate versionTemplate;

  public CryptoKey() {
  }

  public CryptoKey(
     String createTime, 
     String name
  ) {
    this();
    this.createTime = createTime;
    this.name = name;
  }

  /**
   * Output only. The time at which this CryptoKey was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  public CryptoKey cryptoKeyBackend(String cryptoKeyBackend) {
    this.cryptoKeyBackend = cryptoKeyBackend;
    return this;
  }

  /**
   * Immutable. The resource name of the backend environment where the key material for all CryptoKeyVersions associated with this CryptoKey reside and where all related cryptographic operations are performed. Only applicable if CryptoKeyVersions have a ProtectionLevel of EXTERNAL_VPC, with the resource name in the format &#x60;projects/_*_/locations/_*_/ekmConnections/_*&#x60;. Note, this list is non-exhaustive and may apply to additional ProtectionLevels in the future.
   * @return cryptoKeyBackend
   */
  @javax.annotation.Nullable
  public String getCryptoKeyBackend() {
    return cryptoKeyBackend;
  }

  public void setCryptoKeyBackend(String cryptoKeyBackend) {
    this.cryptoKeyBackend = cryptoKeyBackend;
  }


  public CryptoKey destroyScheduledDuration(String destroyScheduledDuration) {
    this.destroyScheduledDuration = destroyScheduledDuration;
    return this;
  }

  /**
   * Immutable. The period of time that versions of this key spend in the DESTROY_SCHEDULED state before transitioning to DESTROYED. If not specified at creation time, the default duration is 24 hours.
   * @return destroyScheduledDuration
   */
  @javax.annotation.Nullable
  public String getDestroyScheduledDuration() {
    return destroyScheduledDuration;
  }

  public void setDestroyScheduledDuration(String destroyScheduledDuration) {
    this.destroyScheduledDuration = destroyScheduledDuration;
  }


  public CryptoKey importOnly(Boolean importOnly) {
    this.importOnly = importOnly;
    return this;
  }

  /**
   * Immutable. Whether this key may contain imported versions only.
   * @return importOnly
   */
  @javax.annotation.Nullable
  public Boolean getImportOnly() {
    return importOnly;
  }

  public void setImportOnly(Boolean importOnly) {
    this.importOnly = importOnly;
  }


  public CryptoKey labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public CryptoKey putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels with user-defined metadata. For more information, see [Labeling Keys](https://cloud.google.com/kms/docs/labeling-keys).
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  /**
   * Output only. The resource name for this CryptoKey in the format &#x60;projects/_*_/locations/_*_/keyRings/_*_/cryptoKeys/_*&#x60;.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }



  public CryptoKey nextRotationTime(String nextRotationTime) {
    this.nextRotationTime = nextRotationTime;
    return this;
  }

  /**
   * At next_rotation_time, the Key Management Service will automatically: 1. Create a new version of this CryptoKey. 2. Mark the new version as primary. Key rotations performed manually via CreateCryptoKeyVersion and UpdateCryptoKeyPrimaryVersion do not affect next_rotation_time. Keys with purpose ENCRYPT_DECRYPT support automatic rotation. For other keys, this field must be omitted.
   * @return nextRotationTime
   */
  @javax.annotation.Nullable
  public String getNextRotationTime() {
    return nextRotationTime;
  }

  public void setNextRotationTime(String nextRotationTime) {
    this.nextRotationTime = nextRotationTime;
  }


  public CryptoKey primary(CryptoKeyVersion primary) {
    this.primary = primary;
    return this;
  }

  /**
   * Get primary
   * @return primary
   */
  @javax.annotation.Nullable
  public CryptoKeyVersion getPrimary() {
    return primary;
  }

  public void setPrimary(CryptoKeyVersion primary) {
    this.primary = primary;
  }


  public CryptoKey purpose(PurposeEnum purpose) {
    this.purpose = purpose;
    return this;
  }

  /**
   * Immutable. The immutable purpose of this CryptoKey.
   * @return purpose
   */
  @javax.annotation.Nullable
  public PurposeEnum getPurpose() {
    return purpose;
  }

  public void setPurpose(PurposeEnum purpose) {
    this.purpose = purpose;
  }


  public CryptoKey rotationPeriod(String rotationPeriod) {
    this.rotationPeriod = rotationPeriod;
    return this;
  }

  /**
   * next_rotation_time will be advanced by this period when the service automatically rotates a key. Must be at least 24 hours and at most 876,000 hours. If rotation_period is set, next_rotation_time must also be set. Keys with purpose ENCRYPT_DECRYPT support automatic rotation. For other keys, this field must be omitted.
   * @return rotationPeriod
   */
  @javax.annotation.Nullable
  public String getRotationPeriod() {
    return rotationPeriod;
  }

  public void setRotationPeriod(String rotationPeriod) {
    this.rotationPeriod = rotationPeriod;
  }


  public CryptoKey versionTemplate(CryptoKeyVersionTemplate versionTemplate) {
    this.versionTemplate = versionTemplate;
    return this;
  }

  /**
   * Get versionTemplate
   * @return versionTemplate
   */
  @javax.annotation.Nullable
  public CryptoKeyVersionTemplate getVersionTemplate() {
    return versionTemplate;
  }

  public void setVersionTemplate(CryptoKeyVersionTemplate versionTemplate) {
    this.versionTemplate = versionTemplate;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CryptoKey cryptoKey = (CryptoKey) o;
    return Objects.equals(this.createTime, cryptoKey.createTime) &&
        Objects.equals(this.cryptoKeyBackend, cryptoKey.cryptoKeyBackend) &&
        Objects.equals(this.destroyScheduledDuration, cryptoKey.destroyScheduledDuration) &&
        Objects.equals(this.importOnly, cryptoKey.importOnly) &&
        Objects.equals(this.labels, cryptoKey.labels) &&
        Objects.equals(this.name, cryptoKey.name) &&
        Objects.equals(this.nextRotationTime, cryptoKey.nextRotationTime) &&
        Objects.equals(this.primary, cryptoKey.primary) &&
        Objects.equals(this.purpose, cryptoKey.purpose) &&
        Objects.equals(this.rotationPeriod, cryptoKey.rotationPeriod) &&
        Objects.equals(this.versionTemplate, cryptoKey.versionTemplate);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createTime, cryptoKeyBackend, destroyScheduledDuration, importOnly, labels, name, nextRotationTime, primary, purpose, rotationPeriod, versionTemplate);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CryptoKey {\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    cryptoKeyBackend: ").append(toIndentedString(cryptoKeyBackend)).append("\n");
    sb.append("    destroyScheduledDuration: ").append(toIndentedString(destroyScheduledDuration)).append("\n");
    sb.append("    importOnly: ").append(toIndentedString(importOnly)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nextRotationTime: ").append(toIndentedString(nextRotationTime)).append("\n");
    sb.append("    primary: ").append(toIndentedString(primary)).append("\n");
    sb.append("    purpose: ").append(toIndentedString(purpose)).append("\n");
    sb.append("    rotationPeriod: ").append(toIndentedString(rotationPeriod)).append("\n");
    sb.append("    versionTemplate: ").append(toIndentedString(versionTemplate)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("createTime");
    openapiFields.add("cryptoKeyBackend");
    openapiFields.add("destroyScheduledDuration");
    openapiFields.add("importOnly");
    openapiFields.add("labels");
    openapiFields.add("name");
    openapiFields.add("nextRotationTime");
    openapiFields.add("primary");
    openapiFields.add("purpose");
    openapiFields.add("rotationPeriod");
    openapiFields.add("versionTemplate");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CryptoKey
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CryptoKey.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CryptoKey is not found in the empty JSON string", CryptoKey.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CryptoKey.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CryptoKey` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("cryptoKeyBackend") != null && !jsonObj.get("cryptoKeyBackend").isJsonNull()) && !jsonObj.get("cryptoKeyBackend").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cryptoKeyBackend` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cryptoKeyBackend").toString()));
      }
      if ((jsonObj.get("destroyScheduledDuration") != null && !jsonObj.get("destroyScheduledDuration").isJsonNull()) && !jsonObj.get("destroyScheduledDuration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destroyScheduledDuration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destroyScheduledDuration").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("nextRotationTime") != null && !jsonObj.get("nextRotationTime").isJsonNull()) && !jsonObj.get("nextRotationTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nextRotationTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nextRotationTime").toString()));
      }
      // validate the optional field `primary`
      if (jsonObj.get("primary") != null && !jsonObj.get("primary").isJsonNull()) {
        CryptoKeyVersion.validateJsonElement(jsonObj.get("primary"));
      }
      if ((jsonObj.get("purpose") != null && !jsonObj.get("purpose").isJsonNull()) && !jsonObj.get("purpose").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `purpose` to be a primitive type in the JSON string but got `%s`", jsonObj.get("purpose").toString()));
      }
      // validate the optional field `purpose`
      if (jsonObj.get("purpose") != null && !jsonObj.get("purpose").isJsonNull()) {
        PurposeEnum.validateJsonElement(jsonObj.get("purpose"));
      }
      if ((jsonObj.get("rotationPeriod") != null && !jsonObj.get("rotationPeriod").isJsonNull()) && !jsonObj.get("rotationPeriod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rotationPeriod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rotationPeriod").toString()));
      }
      // validate the optional field `versionTemplate`
      if (jsonObj.get("versionTemplate") != null && !jsonObj.get("versionTemplate").isJsonNull()) {
        CryptoKeyVersionTemplate.validateJsonElement(jsonObj.get("versionTemplate"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CryptoKey.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CryptoKey' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CryptoKey> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CryptoKey.class));

       return (TypeAdapter<T>) new TypeAdapter<CryptoKey>() {
           @Override
           public void write(JsonWriter out, CryptoKey value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CryptoKey read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CryptoKey given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CryptoKey
   * @throws IOException if the JSON string is invalid with respect to CryptoKey
   */
  public static CryptoKey fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CryptoKey.class);
  }

  /**
   * Convert an instance of CryptoKey to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

