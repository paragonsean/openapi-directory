/**
 * Cloud Key Management Service (KMS) API
 * Manages keys and performs cryptographic operations in a central cloud service, for direct use by other cloud resources and applications. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';

/**
 * The ImportCryptoKeyVersionRequest model module.
 * @module model/ImportCryptoKeyVersionRequest
 * @version v1
 */
class ImportCryptoKeyVersionRequest {
    /**
     * Constructs a new <code>ImportCryptoKeyVersionRequest</code>.
     * Request message for KeyManagementService.ImportCryptoKeyVersion.
     * @alias module:model/ImportCryptoKeyVersionRequest
     */
    constructor() { 
        
        ImportCryptoKeyVersionRequest.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>ImportCryptoKeyVersionRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/ImportCryptoKeyVersionRequest} obj Optional instance to populate.
     * @return {module:model/ImportCryptoKeyVersionRequest} The populated <code>ImportCryptoKeyVersionRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ImportCryptoKeyVersionRequest();

            if (data.hasOwnProperty('algorithm')) {
                obj['algorithm'] = ApiClient.convertToType(data['algorithm'], 'String');
            }
            if (data.hasOwnProperty('cryptoKeyVersion')) {
                obj['cryptoKeyVersion'] = ApiClient.convertToType(data['cryptoKeyVersion'], 'String');
            }
            if (data.hasOwnProperty('importJob')) {
                obj['importJob'] = ApiClient.convertToType(data['importJob'], 'String');
            }
            if (data.hasOwnProperty('rsaAesWrappedKey')) {
                obj['rsaAesWrappedKey'] = ApiClient.convertToType(data['rsaAesWrappedKey'], 'Blob');
            }
            if (data.hasOwnProperty('wrappedKey')) {
                obj['wrappedKey'] = ApiClient.convertToType(data['wrappedKey'], 'Blob');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>ImportCryptoKeyVersionRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>ImportCryptoKeyVersionRequest</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['algorithm'] && !(typeof data['algorithm'] === 'string' || data['algorithm'] instanceof String)) {
            throw new Error("Expected the field `algorithm` to be a primitive type in the JSON string but got " + data['algorithm']);
        }
        // ensure the json data is a string
        if (data['cryptoKeyVersion'] && !(typeof data['cryptoKeyVersion'] === 'string' || data['cryptoKeyVersion'] instanceof String)) {
            throw new Error("Expected the field `cryptoKeyVersion` to be a primitive type in the JSON string but got " + data['cryptoKeyVersion']);
        }
        // ensure the json data is a string
        if (data['importJob'] && !(typeof data['importJob'] === 'string' || data['importJob'] instanceof String)) {
            throw new Error("Expected the field `importJob` to be a primitive type in the JSON string but got " + data['importJob']);
        }

        return true;
    }


}



/**
 * Required. The algorithm of the key being imported. This does not need to match the version_template of the CryptoKey this version imports into.
 * @member {module:model/ImportCryptoKeyVersionRequest.AlgorithmEnum} algorithm
 */
ImportCryptoKeyVersionRequest.prototype['algorithm'] = undefined;

/**
 * Optional. The optional name of an existing CryptoKeyVersion to target for an import operation. If this field is not present, a new CryptoKeyVersion containing the supplied key material is created. If this field is present, the supplied key material is imported into the existing CryptoKeyVersion. To import into an existing CryptoKeyVersion, the CryptoKeyVersion must be a child of ImportCryptoKeyVersionRequest.parent, have been previously created via ImportCryptoKeyVersion, and be in DESTROYED or IMPORT_FAILED state. The key material and algorithm must match the previous CryptoKeyVersion exactly if the CryptoKeyVersion has ever contained key material.
 * @member {String} cryptoKeyVersion
 */
ImportCryptoKeyVersionRequest.prototype['cryptoKeyVersion'] = undefined;

/**
 * Required. The name of the ImportJob that was used to wrap this key material.
 * @member {String} importJob
 */
ImportCryptoKeyVersionRequest.prototype['importJob'] = undefined;

/**
 * Optional. This field has the same meaning as wrapped_key. Prefer to use that field in new work. Either that field or this field (but not both) must be specified.
 * @member {Blob} rsaAesWrappedKey
 */
ImportCryptoKeyVersionRequest.prototype['rsaAesWrappedKey'] = undefined;

/**
 * Optional. The wrapped key material to import. Before wrapping, key material must be formatted. If importing symmetric key material, the expected key material format is plain bytes. If importing asymmetric key material, the expected key material format is PKCS#8-encoded DER (the PrivateKeyInfo structure from RFC 5208). When wrapping with import methods (RSA_OAEP_3072_SHA1_AES_256 or RSA_OAEP_4096_SHA1_AES_256 or RSA_OAEP_3072_SHA256_AES_256 or RSA_OAEP_4096_SHA256_AES_256), this field must contain the concatenation of: 1. An ephemeral AES-256 wrapping key wrapped with the public_key using RSAES-OAEP with SHA-1/SHA-256, MGF1 with SHA-1/SHA-256, and an empty label. 2. The formatted key to be imported, wrapped with the ephemeral AES-256 key using AES-KWP (RFC 5649). This format is the same as the format produced by PKCS#11 mechanism CKM_RSA_AES_KEY_WRAP. When wrapping with import methods (RSA_OAEP_3072_SHA256 or RSA_OAEP_4096_SHA256), this field must contain the formatted key to be imported, wrapped with the public_key using RSAES-OAEP with SHA-256, MGF1 with SHA-256, and an empty label.
 * @member {Blob} wrappedKey
 */
ImportCryptoKeyVersionRequest.prototype['wrappedKey'] = undefined;





/**
 * Allowed values for the <code>algorithm</code> property.
 * @enum {String}
 * @readonly
 */
ImportCryptoKeyVersionRequest['AlgorithmEnum'] = {

    /**
     * value: "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED"
     * @const
     */
    "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED": "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED",

    /**
     * value: "GOOGLE_SYMMETRIC_ENCRYPTION"
     * @const
     */
    "GOOGLE_SYMMETRIC_ENCRYPTION": "GOOGLE_SYMMETRIC_ENCRYPTION",

    /**
     * value: "AES_128_GCM"
     * @const
     */
    "AES_128_GCM": "AES_128_GCM",

    /**
     * value: "AES_256_GCM"
     * @const
     */
    "AES_256_GCM": "AES_256_GCM",

    /**
     * value: "AES_128_CBC"
     * @const
     */
    "AES_128_CBC": "AES_128_CBC",

    /**
     * value: "AES_256_CBC"
     * @const
     */
    "AES_256_CBC": "AES_256_CBC",

    /**
     * value: "AES_128_CTR"
     * @const
     */
    "AES_128_CTR": "AES_128_CTR",

    /**
     * value: "AES_256_CTR"
     * @const
     */
    "AES_256_CTR": "AES_256_CTR",

    /**
     * value: "RSA_SIGN_PSS_2048_SHA256"
     * @const
     */
    "RSA_SIGN_PSS_2048_SHA256": "RSA_SIGN_PSS_2048_SHA256",

    /**
     * value: "RSA_SIGN_PSS_3072_SHA256"
     * @const
     */
    "RSA_SIGN_PSS_3072_SHA256": "RSA_SIGN_PSS_3072_SHA256",

    /**
     * value: "RSA_SIGN_PSS_4096_SHA256"
     * @const
     */
    "RSA_SIGN_PSS_4096_SHA256": "RSA_SIGN_PSS_4096_SHA256",

    /**
     * value: "RSA_SIGN_PSS_4096_SHA512"
     * @const
     */
    "RSA_SIGN_PSS_4096_SHA512": "RSA_SIGN_PSS_4096_SHA512",

    /**
     * value: "RSA_SIGN_PKCS1_2048_SHA256"
     * @const
     */
    "RSA_SIGN_PKCS1_2048_SHA256": "RSA_SIGN_PKCS1_2048_SHA256",

    /**
     * value: "RSA_SIGN_PKCS1_3072_SHA256"
     * @const
     */
    "RSA_SIGN_PKCS1_3072_SHA256": "RSA_SIGN_PKCS1_3072_SHA256",

    /**
     * value: "RSA_SIGN_PKCS1_4096_SHA256"
     * @const
     */
    "RSA_SIGN_PKCS1_4096_SHA256": "RSA_SIGN_PKCS1_4096_SHA256",

    /**
     * value: "RSA_SIGN_PKCS1_4096_SHA512"
     * @const
     */
    "RSA_SIGN_PKCS1_4096_SHA512": "RSA_SIGN_PKCS1_4096_SHA512",

    /**
     * value: "RSA_SIGN_RAW_PKCS1_2048"
     * @const
     */
    "RSA_SIGN_RAW_PKCS1_2048": "RSA_SIGN_RAW_PKCS1_2048",

    /**
     * value: "RSA_SIGN_RAW_PKCS1_3072"
     * @const
     */
    "RSA_SIGN_RAW_PKCS1_3072": "RSA_SIGN_RAW_PKCS1_3072",

    /**
     * value: "RSA_SIGN_RAW_PKCS1_4096"
     * @const
     */
    "RSA_SIGN_RAW_PKCS1_4096": "RSA_SIGN_RAW_PKCS1_4096",

    /**
     * value: "RSA_DECRYPT_OAEP_2048_SHA256"
     * @const
     */
    "RSA_DECRYPT_OAEP_2048_SHA256": "RSA_DECRYPT_OAEP_2048_SHA256",

    /**
     * value: "RSA_DECRYPT_OAEP_3072_SHA256"
     * @const
     */
    "RSA_DECRYPT_OAEP_3072_SHA256": "RSA_DECRYPT_OAEP_3072_SHA256",

    /**
     * value: "RSA_DECRYPT_OAEP_4096_SHA256"
     * @const
     */
    "RSA_DECRYPT_OAEP_4096_SHA256": "RSA_DECRYPT_OAEP_4096_SHA256",

    /**
     * value: "RSA_DECRYPT_OAEP_4096_SHA512"
     * @const
     */
    "RSA_DECRYPT_OAEP_4096_SHA512": "RSA_DECRYPT_OAEP_4096_SHA512",

    /**
     * value: "RSA_DECRYPT_OAEP_2048_SHA1"
     * @const
     */
    "RSA_DECRYPT_OAEP_2048_SHA1": "RSA_DECRYPT_OAEP_2048_SHA1",

    /**
     * value: "RSA_DECRYPT_OAEP_3072_SHA1"
     * @const
     */
    "RSA_DECRYPT_OAEP_3072_SHA1": "RSA_DECRYPT_OAEP_3072_SHA1",

    /**
     * value: "RSA_DECRYPT_OAEP_4096_SHA1"
     * @const
     */
    "RSA_DECRYPT_OAEP_4096_SHA1": "RSA_DECRYPT_OAEP_4096_SHA1",

    /**
     * value: "EC_SIGN_P256_SHA256"
     * @const
     */
    "EC_SIGN_P256_SHA256": "EC_SIGN_P256_SHA256",

    /**
     * value: "EC_SIGN_P384_SHA384"
     * @const
     */
    "EC_SIGN_P384_SHA384": "EC_SIGN_P384_SHA384",

    /**
     * value: "EC_SIGN_SECP256K1_SHA256"
     * @const
     */
    "EC_SIGN_SECP256K1_SHA256": "EC_SIGN_SECP256K1_SHA256",

    /**
     * value: "HMAC_SHA256"
     * @const
     */
    "HMAC_SHA256": "HMAC_SHA256",

    /**
     * value: "HMAC_SHA1"
     * @const
     */
    "HMAC_SHA1": "HMAC_SHA1",

    /**
     * value: "HMAC_SHA384"
     * @const
     */
    "HMAC_SHA384": "HMAC_SHA384",

    /**
     * value: "HMAC_SHA512"
     * @const
     */
    "HMAC_SHA512": "HMAC_SHA512",

    /**
     * value: "HMAC_SHA224"
     * @const
     */
    "HMAC_SHA224": "HMAC_SHA224",

    /**
     * value: "EXTERNAL_SYMMETRIC_ENCRYPTION"
     * @const
     */
    "EXTERNAL_SYMMETRIC_ENCRYPTION": "EXTERNAL_SYMMETRIC_ENCRYPTION"
};



export default ImportCryptoKeyVersionRequest;

