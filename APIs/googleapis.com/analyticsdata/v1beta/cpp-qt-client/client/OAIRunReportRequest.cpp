/**
 * Google Analytics Data API
 * Accesses report data in Google Analytics. Warning: Creating multiple Customer Applications, Accounts, or Projects to simulate or act as a single Customer Application, Account, or Project (respectively) or to circumvent Service-specific usage limits or quotas is a direct violation of Google Cloud Platform Terms of Service as well as Google APIs Terms of Service. These actions can result in immediate termination of your GCP project(s) without any warning. 
 *
 * The version of the OpenAPI document: v1beta
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIRunReportRequest.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIRunReportRequest::OAIRunReportRequest(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIRunReportRequest::OAIRunReportRequest() {
    this->initializeModel();
}

OAIRunReportRequest::~OAIRunReportRequest() {}

void OAIRunReportRequest::initializeModel() {

    m_cohort_spec_isSet = false;
    m_cohort_spec_isValid = false;

    m_currency_code_isSet = false;
    m_currency_code_isValid = false;

    m_date_ranges_isSet = false;
    m_date_ranges_isValid = false;

    m_dimension_filter_isSet = false;
    m_dimension_filter_isValid = false;

    m_dimensions_isSet = false;
    m_dimensions_isValid = false;

    m_keep_empty_rows_isSet = false;
    m_keep_empty_rows_isValid = false;

    m_limit_isSet = false;
    m_limit_isValid = false;

    m_metric_aggregations_isSet = false;
    m_metric_aggregations_isValid = false;

    m_metric_filter_isSet = false;
    m_metric_filter_isValid = false;

    m_metrics_isSet = false;
    m_metrics_isValid = false;

    m_offset_isSet = false;
    m_offset_isValid = false;

    m_order_bys_isSet = false;
    m_order_bys_isValid = false;

    m_property_isSet = false;
    m_property_isValid = false;

    m_return_property_quota_isSet = false;
    m_return_property_quota_isValid = false;
}

void OAIRunReportRequest::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIRunReportRequest::fromJsonObject(QJsonObject json) {

    m_cohort_spec_isValid = ::OpenAPI::fromJsonValue(m_cohort_spec, json[QString("cohortSpec")]);
    m_cohort_spec_isSet = !json[QString("cohortSpec")].isNull() && m_cohort_spec_isValid;

    m_currency_code_isValid = ::OpenAPI::fromJsonValue(m_currency_code, json[QString("currencyCode")]);
    m_currency_code_isSet = !json[QString("currencyCode")].isNull() && m_currency_code_isValid;

    m_date_ranges_isValid = ::OpenAPI::fromJsonValue(m_date_ranges, json[QString("dateRanges")]);
    m_date_ranges_isSet = !json[QString("dateRanges")].isNull() && m_date_ranges_isValid;

    m_dimension_filter_isValid = ::OpenAPI::fromJsonValue(m_dimension_filter, json[QString("dimensionFilter")]);
    m_dimension_filter_isSet = !json[QString("dimensionFilter")].isNull() && m_dimension_filter_isValid;

    m_dimensions_isValid = ::OpenAPI::fromJsonValue(m_dimensions, json[QString("dimensions")]);
    m_dimensions_isSet = !json[QString("dimensions")].isNull() && m_dimensions_isValid;

    m_keep_empty_rows_isValid = ::OpenAPI::fromJsonValue(m_keep_empty_rows, json[QString("keepEmptyRows")]);
    m_keep_empty_rows_isSet = !json[QString("keepEmptyRows")].isNull() && m_keep_empty_rows_isValid;

    m_limit_isValid = ::OpenAPI::fromJsonValue(m_limit, json[QString("limit")]);
    m_limit_isSet = !json[QString("limit")].isNull() && m_limit_isValid;

    m_metric_aggregations_isValid = ::OpenAPI::fromJsonValue(m_metric_aggregations, json[QString("metricAggregations")]);
    m_metric_aggregations_isSet = !json[QString("metricAggregations")].isNull() && m_metric_aggregations_isValid;

    m_metric_filter_isValid = ::OpenAPI::fromJsonValue(m_metric_filter, json[QString("metricFilter")]);
    m_metric_filter_isSet = !json[QString("metricFilter")].isNull() && m_metric_filter_isValid;

    m_metrics_isValid = ::OpenAPI::fromJsonValue(m_metrics, json[QString("metrics")]);
    m_metrics_isSet = !json[QString("metrics")].isNull() && m_metrics_isValid;

    m_offset_isValid = ::OpenAPI::fromJsonValue(m_offset, json[QString("offset")]);
    m_offset_isSet = !json[QString("offset")].isNull() && m_offset_isValid;

    m_order_bys_isValid = ::OpenAPI::fromJsonValue(m_order_bys, json[QString("orderBys")]);
    m_order_bys_isSet = !json[QString("orderBys")].isNull() && m_order_bys_isValid;

    m_property_isValid = ::OpenAPI::fromJsonValue(m_property, json[QString("property")]);
    m_property_isSet = !json[QString("property")].isNull() && m_property_isValid;

    m_return_property_quota_isValid = ::OpenAPI::fromJsonValue(m_return_property_quota, json[QString("returnPropertyQuota")]);
    m_return_property_quota_isSet = !json[QString("returnPropertyQuota")].isNull() && m_return_property_quota_isValid;
}

QString OAIRunReportRequest::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIRunReportRequest::asJsonObject() const {
    QJsonObject obj;
    if (m_cohort_spec.isSet()) {
        obj.insert(QString("cohortSpec"), ::OpenAPI::toJsonValue(m_cohort_spec));
    }
    if (m_currency_code_isSet) {
        obj.insert(QString("currencyCode"), ::OpenAPI::toJsonValue(m_currency_code));
    }
    if (m_date_ranges.size() > 0) {
        obj.insert(QString("dateRanges"), ::OpenAPI::toJsonValue(m_date_ranges));
    }
    if (m_dimension_filter.isSet()) {
        obj.insert(QString("dimensionFilter"), ::OpenAPI::toJsonValue(m_dimension_filter));
    }
    if (m_dimensions.size() > 0) {
        obj.insert(QString("dimensions"), ::OpenAPI::toJsonValue(m_dimensions));
    }
    if (m_keep_empty_rows_isSet) {
        obj.insert(QString("keepEmptyRows"), ::OpenAPI::toJsonValue(m_keep_empty_rows));
    }
    if (m_limit_isSet) {
        obj.insert(QString("limit"), ::OpenAPI::toJsonValue(m_limit));
    }
    if (m_metric_aggregations.size() > 0) {
        obj.insert(QString("metricAggregations"), ::OpenAPI::toJsonValue(m_metric_aggregations));
    }
    if (m_metric_filter.isSet()) {
        obj.insert(QString("metricFilter"), ::OpenAPI::toJsonValue(m_metric_filter));
    }
    if (m_metrics.size() > 0) {
        obj.insert(QString("metrics"), ::OpenAPI::toJsonValue(m_metrics));
    }
    if (m_offset_isSet) {
        obj.insert(QString("offset"), ::OpenAPI::toJsonValue(m_offset));
    }
    if (m_order_bys.size() > 0) {
        obj.insert(QString("orderBys"), ::OpenAPI::toJsonValue(m_order_bys));
    }
    if (m_property_isSet) {
        obj.insert(QString("property"), ::OpenAPI::toJsonValue(m_property));
    }
    if (m_return_property_quota_isSet) {
        obj.insert(QString("returnPropertyQuota"), ::OpenAPI::toJsonValue(m_return_property_quota));
    }
    return obj;
}

OAICohortSpec OAIRunReportRequest::getCohortSpec() const {
    return m_cohort_spec;
}
void OAIRunReportRequest::setCohortSpec(const OAICohortSpec &cohort_spec) {
    m_cohort_spec = cohort_spec;
    m_cohort_spec_isSet = true;
}

bool OAIRunReportRequest::is_cohort_spec_Set() const{
    return m_cohort_spec_isSet;
}

bool OAIRunReportRequest::is_cohort_spec_Valid() const{
    return m_cohort_spec_isValid;
}

QString OAIRunReportRequest::getCurrencyCode() const {
    return m_currency_code;
}
void OAIRunReportRequest::setCurrencyCode(const QString &currency_code) {
    m_currency_code = currency_code;
    m_currency_code_isSet = true;
}

bool OAIRunReportRequest::is_currency_code_Set() const{
    return m_currency_code_isSet;
}

bool OAIRunReportRequest::is_currency_code_Valid() const{
    return m_currency_code_isValid;
}

QList<OAIDateRange> OAIRunReportRequest::getDateRanges() const {
    return m_date_ranges;
}
void OAIRunReportRequest::setDateRanges(const QList<OAIDateRange> &date_ranges) {
    m_date_ranges = date_ranges;
    m_date_ranges_isSet = true;
}

bool OAIRunReportRequest::is_date_ranges_Set() const{
    return m_date_ranges_isSet;
}

bool OAIRunReportRequest::is_date_ranges_Valid() const{
    return m_date_ranges_isValid;
}

OAIFilterExpression OAIRunReportRequest::getDimensionFilter() const {
    return m_dimension_filter;
}
void OAIRunReportRequest::setDimensionFilter(const OAIFilterExpression &dimension_filter) {
    m_dimension_filter = dimension_filter;
    m_dimension_filter_isSet = true;
}

bool OAIRunReportRequest::is_dimension_filter_Set() const{
    return m_dimension_filter_isSet;
}

bool OAIRunReportRequest::is_dimension_filter_Valid() const{
    return m_dimension_filter_isValid;
}

QList<OAIDimension> OAIRunReportRequest::getDimensions() const {
    return m_dimensions;
}
void OAIRunReportRequest::setDimensions(const QList<OAIDimension> &dimensions) {
    m_dimensions = dimensions;
    m_dimensions_isSet = true;
}

bool OAIRunReportRequest::is_dimensions_Set() const{
    return m_dimensions_isSet;
}

bool OAIRunReportRequest::is_dimensions_Valid() const{
    return m_dimensions_isValid;
}

bool OAIRunReportRequest::isKeepEmptyRows() const {
    return m_keep_empty_rows;
}
void OAIRunReportRequest::setKeepEmptyRows(const bool &keep_empty_rows) {
    m_keep_empty_rows = keep_empty_rows;
    m_keep_empty_rows_isSet = true;
}

bool OAIRunReportRequest::is_keep_empty_rows_Set() const{
    return m_keep_empty_rows_isSet;
}

bool OAIRunReportRequest::is_keep_empty_rows_Valid() const{
    return m_keep_empty_rows_isValid;
}

QString OAIRunReportRequest::getLimit() const {
    return m_limit;
}
void OAIRunReportRequest::setLimit(const QString &limit) {
    m_limit = limit;
    m_limit_isSet = true;
}

bool OAIRunReportRequest::is_limit_Set() const{
    return m_limit_isSet;
}

bool OAIRunReportRequest::is_limit_Valid() const{
    return m_limit_isValid;
}

QList<QString> OAIRunReportRequest::getMetricAggregations() const {
    return m_metric_aggregations;
}
void OAIRunReportRequest::setMetricAggregations(const QList<QString> &metric_aggregations) {
    m_metric_aggregations = metric_aggregations;
    m_metric_aggregations_isSet = true;
}

bool OAIRunReportRequest::is_metric_aggregations_Set() const{
    return m_metric_aggregations_isSet;
}

bool OAIRunReportRequest::is_metric_aggregations_Valid() const{
    return m_metric_aggregations_isValid;
}

OAIFilterExpression OAIRunReportRequest::getMetricFilter() const {
    return m_metric_filter;
}
void OAIRunReportRequest::setMetricFilter(const OAIFilterExpression &metric_filter) {
    m_metric_filter = metric_filter;
    m_metric_filter_isSet = true;
}

bool OAIRunReportRequest::is_metric_filter_Set() const{
    return m_metric_filter_isSet;
}

bool OAIRunReportRequest::is_metric_filter_Valid() const{
    return m_metric_filter_isValid;
}

QList<OAIMetric> OAIRunReportRequest::getMetrics() const {
    return m_metrics;
}
void OAIRunReportRequest::setMetrics(const QList<OAIMetric> &metrics) {
    m_metrics = metrics;
    m_metrics_isSet = true;
}

bool OAIRunReportRequest::is_metrics_Set() const{
    return m_metrics_isSet;
}

bool OAIRunReportRequest::is_metrics_Valid() const{
    return m_metrics_isValid;
}

QString OAIRunReportRequest::getOffset() const {
    return m_offset;
}
void OAIRunReportRequest::setOffset(const QString &offset) {
    m_offset = offset;
    m_offset_isSet = true;
}

bool OAIRunReportRequest::is_offset_Set() const{
    return m_offset_isSet;
}

bool OAIRunReportRequest::is_offset_Valid() const{
    return m_offset_isValid;
}

QList<OAIOrderBy> OAIRunReportRequest::getOrderBys() const {
    return m_order_bys;
}
void OAIRunReportRequest::setOrderBys(const QList<OAIOrderBy> &order_bys) {
    m_order_bys = order_bys;
    m_order_bys_isSet = true;
}

bool OAIRunReportRequest::is_order_bys_Set() const{
    return m_order_bys_isSet;
}

bool OAIRunReportRequest::is_order_bys_Valid() const{
    return m_order_bys_isValid;
}

QString OAIRunReportRequest::getProperty() const {
    return m_property;
}
void OAIRunReportRequest::setProperty(const QString &property) {
    m_property = property;
    m_property_isSet = true;
}

bool OAIRunReportRequest::is_property_Set() const{
    return m_property_isSet;
}

bool OAIRunReportRequest::is_property_Valid() const{
    return m_property_isValid;
}

bool OAIRunReportRequest::isReturnPropertyQuota() const {
    return m_return_property_quota;
}
void OAIRunReportRequest::setReturnPropertyQuota(const bool &return_property_quota) {
    m_return_property_quota = return_property_quota;
    m_return_property_quota_isSet = true;
}

bool OAIRunReportRequest::is_return_property_quota_Set() const{
    return m_return_property_quota_isSet;
}

bool OAIRunReportRequest::is_return_property_quota_Valid() const{
    return m_return_property_quota_isValid;
}

bool OAIRunReportRequest::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_cohort_spec.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_currency_code_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_date_ranges.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_dimension_filter.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_dimensions.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_keep_empty_rows_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_aggregations.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_filter.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_metrics.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_offset_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_order_bys.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_property_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_return_property_quota_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIRunReportRequest::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
