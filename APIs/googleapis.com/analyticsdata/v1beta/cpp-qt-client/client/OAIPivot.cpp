/**
 * Google Analytics Data API
 * Accesses report data in Google Analytics. Warning: Creating multiple Customer Applications, Accounts, or Projects to simulate or act as a single Customer Application, Account, or Project (respectively) or to circumvent Service-specific usage limits or quotas is a direct violation of Google Cloud Platform Terms of Service as well as Google APIs Terms of Service. These actions can result in immediate termination of your GCP project(s) without any warning. 
 *
 * The version of the OpenAPI document: v1beta
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPivot.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPivot::OAIPivot(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPivot::OAIPivot() {
    this->initializeModel();
}

OAIPivot::~OAIPivot() {}

void OAIPivot::initializeModel() {

    m_field_names_isSet = false;
    m_field_names_isValid = false;

    m_limit_isSet = false;
    m_limit_isValid = false;

    m_metric_aggregations_isSet = false;
    m_metric_aggregations_isValid = false;

    m_offset_isSet = false;
    m_offset_isValid = false;

    m_order_bys_isSet = false;
    m_order_bys_isValid = false;
}

void OAIPivot::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPivot::fromJsonObject(QJsonObject json) {

    m_field_names_isValid = ::OpenAPI::fromJsonValue(m_field_names, json[QString("fieldNames")]);
    m_field_names_isSet = !json[QString("fieldNames")].isNull() && m_field_names_isValid;

    m_limit_isValid = ::OpenAPI::fromJsonValue(m_limit, json[QString("limit")]);
    m_limit_isSet = !json[QString("limit")].isNull() && m_limit_isValid;

    m_metric_aggregations_isValid = ::OpenAPI::fromJsonValue(m_metric_aggregations, json[QString("metricAggregations")]);
    m_metric_aggregations_isSet = !json[QString("metricAggregations")].isNull() && m_metric_aggregations_isValid;

    m_offset_isValid = ::OpenAPI::fromJsonValue(m_offset, json[QString("offset")]);
    m_offset_isSet = !json[QString("offset")].isNull() && m_offset_isValid;

    m_order_bys_isValid = ::OpenAPI::fromJsonValue(m_order_bys, json[QString("orderBys")]);
    m_order_bys_isSet = !json[QString("orderBys")].isNull() && m_order_bys_isValid;
}

QString OAIPivot::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPivot::asJsonObject() const {
    QJsonObject obj;
    if (m_field_names.size() > 0) {
        obj.insert(QString("fieldNames"), ::OpenAPI::toJsonValue(m_field_names));
    }
    if (m_limit_isSet) {
        obj.insert(QString("limit"), ::OpenAPI::toJsonValue(m_limit));
    }
    if (m_metric_aggregations.size() > 0) {
        obj.insert(QString("metricAggregations"), ::OpenAPI::toJsonValue(m_metric_aggregations));
    }
    if (m_offset_isSet) {
        obj.insert(QString("offset"), ::OpenAPI::toJsonValue(m_offset));
    }
    if (m_order_bys.size() > 0) {
        obj.insert(QString("orderBys"), ::OpenAPI::toJsonValue(m_order_bys));
    }
    return obj;
}

QList<QString> OAIPivot::getFieldNames() const {
    return m_field_names;
}
void OAIPivot::setFieldNames(const QList<QString> &field_names) {
    m_field_names = field_names;
    m_field_names_isSet = true;
}

bool OAIPivot::is_field_names_Set() const{
    return m_field_names_isSet;
}

bool OAIPivot::is_field_names_Valid() const{
    return m_field_names_isValid;
}

QString OAIPivot::getLimit() const {
    return m_limit;
}
void OAIPivot::setLimit(const QString &limit) {
    m_limit = limit;
    m_limit_isSet = true;
}

bool OAIPivot::is_limit_Set() const{
    return m_limit_isSet;
}

bool OAIPivot::is_limit_Valid() const{
    return m_limit_isValid;
}

QList<QString> OAIPivot::getMetricAggregations() const {
    return m_metric_aggregations;
}
void OAIPivot::setMetricAggregations(const QList<QString> &metric_aggregations) {
    m_metric_aggregations = metric_aggregations;
    m_metric_aggregations_isSet = true;
}

bool OAIPivot::is_metric_aggregations_Set() const{
    return m_metric_aggregations_isSet;
}

bool OAIPivot::is_metric_aggregations_Valid() const{
    return m_metric_aggregations_isValid;
}

QString OAIPivot::getOffset() const {
    return m_offset;
}
void OAIPivot::setOffset(const QString &offset) {
    m_offset = offset;
    m_offset_isSet = true;
}

bool OAIPivot::is_offset_Set() const{
    return m_offset_isSet;
}

bool OAIPivot::is_offset_Valid() const{
    return m_offset_isValid;
}

QList<OAIOrderBy> OAIPivot::getOrderBys() const {
    return m_order_bys;
}
void OAIPivot::setOrderBys(const QList<OAIOrderBy> &order_bys) {
    m_order_bys = order_bys;
    m_order_bys_isSet = true;
}

bool OAIPivot::is_order_bys_Set() const{
    return m_order_bys_isSet;
}

bool OAIPivot::is_order_bys_Valid() const{
    return m_order_bys_isValid;
}

bool OAIPivot::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_field_names.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_limit_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_metric_aggregations.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_offset_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_order_bys.size() > 0) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPivot::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
