/*
 * Google Analytics Data API
 * Accesses report data in Google Analytics. Warning: Creating multiple Customer Applications, Accounts, or Projects to simulate or act as a single Customer Application, Account, or Project (respectively) or to circumvent Service-specific usage limits or quotas is a direct violation of Google Cloud Platform Terms of Service as well as Google APIs Terms of Service. These actions can result in immediate termination of your GCP project(s) without any warning. 
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.CohortSpec;
import org.openapitools.client.model.DateRange;
import org.openapitools.client.model.Dimension;
import org.openapitools.client.model.FilterExpression;
import org.openapitools.client.model.Metric;
import org.openapitools.client.model.Pivot;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The request to generate a pivot report.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:54.521143-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RunPivotReportRequest {
  public static final String SERIALIZED_NAME_COHORT_SPEC = "cohortSpec";
  @SerializedName(SERIALIZED_NAME_COHORT_SPEC)
  private CohortSpec cohortSpec;

  public static final String SERIALIZED_NAME_CURRENCY_CODE = "currencyCode";
  @SerializedName(SERIALIZED_NAME_CURRENCY_CODE)
  private String currencyCode;

  public static final String SERIALIZED_NAME_DATE_RANGES = "dateRanges";
  @SerializedName(SERIALIZED_NAME_DATE_RANGES)
  private List<DateRange> dateRanges = new ArrayList<>();

  public static final String SERIALIZED_NAME_DIMENSION_FILTER = "dimensionFilter";
  @SerializedName(SERIALIZED_NAME_DIMENSION_FILTER)
  private FilterExpression dimensionFilter;

  public static final String SERIALIZED_NAME_DIMENSIONS = "dimensions";
  @SerializedName(SERIALIZED_NAME_DIMENSIONS)
  private List<Dimension> dimensions = new ArrayList<>();

  public static final String SERIALIZED_NAME_KEEP_EMPTY_ROWS = "keepEmptyRows";
  @SerializedName(SERIALIZED_NAME_KEEP_EMPTY_ROWS)
  private Boolean keepEmptyRows;

  public static final String SERIALIZED_NAME_METRIC_FILTER = "metricFilter";
  @SerializedName(SERIALIZED_NAME_METRIC_FILTER)
  private FilterExpression metricFilter;

  public static final String SERIALIZED_NAME_METRICS = "metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private List<Metric> metrics = new ArrayList<>();

  public static final String SERIALIZED_NAME_PIVOTS = "pivots";
  @SerializedName(SERIALIZED_NAME_PIVOTS)
  private List<Pivot> pivots = new ArrayList<>();

  public static final String SERIALIZED_NAME_PROPERTY = "property";
  @SerializedName(SERIALIZED_NAME_PROPERTY)
  private String property;

  public static final String SERIALIZED_NAME_RETURN_PROPERTY_QUOTA = "returnPropertyQuota";
  @SerializedName(SERIALIZED_NAME_RETURN_PROPERTY_QUOTA)
  private Boolean returnPropertyQuota;

  public RunPivotReportRequest() {
  }

  public RunPivotReportRequest cohortSpec(CohortSpec cohortSpec) {
    this.cohortSpec = cohortSpec;
    return this;
  }

  /**
   * Get cohortSpec
   * @return cohortSpec
   */
  @javax.annotation.Nullable
  public CohortSpec getCohortSpec() {
    return cohortSpec;
  }

  public void setCohortSpec(CohortSpec cohortSpec) {
    this.cohortSpec = cohortSpec;
  }


  public RunPivotReportRequest currencyCode(String currencyCode) {
    this.currencyCode = currencyCode;
    return this;
  }

  /**
   * A currency code in ISO4217 format, such as \&quot;AED\&quot;, \&quot;USD\&quot;, \&quot;JPY\&quot;. If the field is empty, the report uses the property&#39;s default currency.
   * @return currencyCode
   */
  @javax.annotation.Nullable
  public String getCurrencyCode() {
    return currencyCode;
  }

  public void setCurrencyCode(String currencyCode) {
    this.currencyCode = currencyCode;
  }


  public RunPivotReportRequest dateRanges(List<DateRange> dateRanges) {
    this.dateRanges = dateRanges;
    return this;
  }

  public RunPivotReportRequest addDateRangesItem(DateRange dateRangesItem) {
    if (this.dateRanges == null) {
      this.dateRanges = new ArrayList<>();
    }
    this.dateRanges.add(dateRangesItem);
    return this;
  }

  /**
   * The date range to retrieve event data for the report. If multiple date ranges are specified, event data from each date range is used in the report. A special dimension with field name \&quot;dateRange\&quot; can be included in a Pivot&#39;s field names; if included, the report compares between date ranges. In a cohort request, this &#x60;dateRanges&#x60; must be unspecified.
   * @return dateRanges
   */
  @javax.annotation.Nullable
  public List<DateRange> getDateRanges() {
    return dateRanges;
  }

  public void setDateRanges(List<DateRange> dateRanges) {
    this.dateRanges = dateRanges;
  }


  public RunPivotReportRequest dimensionFilter(FilterExpression dimensionFilter) {
    this.dimensionFilter = dimensionFilter;
    return this;
  }

  /**
   * Get dimensionFilter
   * @return dimensionFilter
   */
  @javax.annotation.Nullable
  public FilterExpression getDimensionFilter() {
    return dimensionFilter;
  }

  public void setDimensionFilter(FilterExpression dimensionFilter) {
    this.dimensionFilter = dimensionFilter;
  }


  public RunPivotReportRequest dimensions(List<Dimension> dimensions) {
    this.dimensions = dimensions;
    return this;
  }

  public RunPivotReportRequest addDimensionsItem(Dimension dimensionsItem) {
    if (this.dimensions == null) {
      this.dimensions = new ArrayList<>();
    }
    this.dimensions.add(dimensionsItem);
    return this;
  }

  /**
   * The dimensions requested. All defined dimensions must be used by one of the following: dimension_expression, dimension_filter, pivots, order_bys.
   * @return dimensions
   */
  @javax.annotation.Nullable
  public List<Dimension> getDimensions() {
    return dimensions;
  }

  public void setDimensions(List<Dimension> dimensions) {
    this.dimensions = dimensions;
  }


  public RunPivotReportRequest keepEmptyRows(Boolean keepEmptyRows) {
    this.keepEmptyRows = keepEmptyRows;
    return this;
  }

  /**
   * If false or unspecified, each row with all metrics equal to 0 will not be returned. If true, these rows will be returned if they are not separately removed by a filter. Regardless of this &#x60;keep_empty_rows&#x60; setting, only data recorded by the Google Analytics (GA4) property can be displayed in a report. For example if a property never logs a &#x60;purchase&#x60; event, then a query for the &#x60;eventName&#x60; dimension and &#x60;eventCount&#x60; metric will not have a row eventName: \&quot;purchase\&quot; and eventCount: 0.
   * @return keepEmptyRows
   */
  @javax.annotation.Nullable
  public Boolean getKeepEmptyRows() {
    return keepEmptyRows;
  }

  public void setKeepEmptyRows(Boolean keepEmptyRows) {
    this.keepEmptyRows = keepEmptyRows;
  }


  public RunPivotReportRequest metricFilter(FilterExpression metricFilter) {
    this.metricFilter = metricFilter;
    return this;
  }

  /**
   * Get metricFilter
   * @return metricFilter
   */
  @javax.annotation.Nullable
  public FilterExpression getMetricFilter() {
    return metricFilter;
  }

  public void setMetricFilter(FilterExpression metricFilter) {
    this.metricFilter = metricFilter;
  }


  public RunPivotReportRequest metrics(List<Metric> metrics) {
    this.metrics = metrics;
    return this;
  }

  public RunPivotReportRequest addMetricsItem(Metric metricsItem) {
    if (this.metrics == null) {
      this.metrics = new ArrayList<>();
    }
    this.metrics.add(metricsItem);
    return this;
  }

  /**
   * The metrics requested, at least one metric needs to be specified. All defined metrics must be used by one of the following: metric_expression, metric_filter, order_bys.
   * @return metrics
   */
  @javax.annotation.Nullable
  public List<Metric> getMetrics() {
    return metrics;
  }

  public void setMetrics(List<Metric> metrics) {
    this.metrics = metrics;
  }


  public RunPivotReportRequest pivots(List<Pivot> pivots) {
    this.pivots = pivots;
    return this;
  }

  public RunPivotReportRequest addPivotsItem(Pivot pivotsItem) {
    if (this.pivots == null) {
      this.pivots = new ArrayList<>();
    }
    this.pivots.add(pivotsItem);
    return this;
  }

  /**
   * Describes the visual format of the report&#39;s dimensions in columns or rows. The union of the fieldNames (dimension names) in all pivots must be a subset of dimension names defined in Dimensions. No two pivots can share a dimension. A dimension is only visible if it appears in a pivot.
   * @return pivots
   */
  @javax.annotation.Nullable
  public List<Pivot> getPivots() {
    return pivots;
  }

  public void setPivots(List<Pivot> pivots) {
    this.pivots = pivots;
  }


  public RunPivotReportRequest property(String property) {
    this.property = property;
    return this;
  }

  /**
   * A Google Analytics GA4 property identifier whose events are tracked. Specified in the URL path and not the body. To learn more, see [where to find your Property ID](https://developers.google.com/analytics/devguides/reporting/data/v1/property-id). Within a batch request, this property should either be unspecified or consistent with the batch-level property. Example: properties/1234
   * @return property
   */
  @javax.annotation.Nullable
  public String getProperty() {
    return property;
  }

  public void setProperty(String property) {
    this.property = property;
  }


  public RunPivotReportRequest returnPropertyQuota(Boolean returnPropertyQuota) {
    this.returnPropertyQuota = returnPropertyQuota;
    return this;
  }

  /**
   * Toggles whether to return the current state of this Analytics Property&#39;s quota. Quota is returned in [PropertyQuota](#PropertyQuota).
   * @return returnPropertyQuota
   */
  @javax.annotation.Nullable
  public Boolean getReturnPropertyQuota() {
    return returnPropertyQuota;
  }

  public void setReturnPropertyQuota(Boolean returnPropertyQuota) {
    this.returnPropertyQuota = returnPropertyQuota;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RunPivotReportRequest runPivotReportRequest = (RunPivotReportRequest) o;
    return Objects.equals(this.cohortSpec, runPivotReportRequest.cohortSpec) &&
        Objects.equals(this.currencyCode, runPivotReportRequest.currencyCode) &&
        Objects.equals(this.dateRanges, runPivotReportRequest.dateRanges) &&
        Objects.equals(this.dimensionFilter, runPivotReportRequest.dimensionFilter) &&
        Objects.equals(this.dimensions, runPivotReportRequest.dimensions) &&
        Objects.equals(this.keepEmptyRows, runPivotReportRequest.keepEmptyRows) &&
        Objects.equals(this.metricFilter, runPivotReportRequest.metricFilter) &&
        Objects.equals(this.metrics, runPivotReportRequest.metrics) &&
        Objects.equals(this.pivots, runPivotReportRequest.pivots) &&
        Objects.equals(this.property, runPivotReportRequest.property) &&
        Objects.equals(this.returnPropertyQuota, runPivotReportRequest.returnPropertyQuota);
  }

  @Override
  public int hashCode() {
    return Objects.hash(cohortSpec, currencyCode, dateRanges, dimensionFilter, dimensions, keepEmptyRows, metricFilter, metrics, pivots, property, returnPropertyQuota);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RunPivotReportRequest {\n");
    sb.append("    cohortSpec: ").append(toIndentedString(cohortSpec)).append("\n");
    sb.append("    currencyCode: ").append(toIndentedString(currencyCode)).append("\n");
    sb.append("    dateRanges: ").append(toIndentedString(dateRanges)).append("\n");
    sb.append("    dimensionFilter: ").append(toIndentedString(dimensionFilter)).append("\n");
    sb.append("    dimensions: ").append(toIndentedString(dimensions)).append("\n");
    sb.append("    keepEmptyRows: ").append(toIndentedString(keepEmptyRows)).append("\n");
    sb.append("    metricFilter: ").append(toIndentedString(metricFilter)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    pivots: ").append(toIndentedString(pivots)).append("\n");
    sb.append("    property: ").append(toIndentedString(property)).append("\n");
    sb.append("    returnPropertyQuota: ").append(toIndentedString(returnPropertyQuota)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("cohortSpec");
    openapiFields.add("currencyCode");
    openapiFields.add("dateRanges");
    openapiFields.add("dimensionFilter");
    openapiFields.add("dimensions");
    openapiFields.add("keepEmptyRows");
    openapiFields.add("metricFilter");
    openapiFields.add("metrics");
    openapiFields.add("pivots");
    openapiFields.add("property");
    openapiFields.add("returnPropertyQuota");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RunPivotReportRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RunPivotReportRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RunPivotReportRequest is not found in the empty JSON string", RunPivotReportRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RunPivotReportRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RunPivotReportRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `cohortSpec`
      if (jsonObj.get("cohortSpec") != null && !jsonObj.get("cohortSpec").isJsonNull()) {
        CohortSpec.validateJsonElement(jsonObj.get("cohortSpec"));
      }
      if ((jsonObj.get("currencyCode") != null && !jsonObj.get("currencyCode").isJsonNull()) && !jsonObj.get("currencyCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currencyCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currencyCode").toString()));
      }
      if (jsonObj.get("dateRanges") != null && !jsonObj.get("dateRanges").isJsonNull()) {
        JsonArray jsonArraydateRanges = jsonObj.getAsJsonArray("dateRanges");
        if (jsonArraydateRanges != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dateRanges").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dateRanges` to be an array in the JSON string but got `%s`", jsonObj.get("dateRanges").toString()));
          }

          // validate the optional field `dateRanges` (array)
          for (int i = 0; i < jsonArraydateRanges.size(); i++) {
            DateRange.validateJsonElement(jsonArraydateRanges.get(i));
          };
        }
      }
      // validate the optional field `dimensionFilter`
      if (jsonObj.get("dimensionFilter") != null && !jsonObj.get("dimensionFilter").isJsonNull()) {
        FilterExpression.validateJsonElement(jsonObj.get("dimensionFilter"));
      }
      if (jsonObj.get("dimensions") != null && !jsonObj.get("dimensions").isJsonNull()) {
        JsonArray jsonArraydimensions = jsonObj.getAsJsonArray("dimensions");
        if (jsonArraydimensions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dimensions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dimensions` to be an array in the JSON string but got `%s`", jsonObj.get("dimensions").toString()));
          }

          // validate the optional field `dimensions` (array)
          for (int i = 0; i < jsonArraydimensions.size(); i++) {
            Dimension.validateJsonElement(jsonArraydimensions.get(i));
          };
        }
      }
      // validate the optional field `metricFilter`
      if (jsonObj.get("metricFilter") != null && !jsonObj.get("metricFilter").isJsonNull()) {
        FilterExpression.validateJsonElement(jsonObj.get("metricFilter"));
      }
      if (jsonObj.get("metrics") != null && !jsonObj.get("metrics").isJsonNull()) {
        JsonArray jsonArraymetrics = jsonObj.getAsJsonArray("metrics");
        if (jsonArraymetrics != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metrics").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metrics` to be an array in the JSON string but got `%s`", jsonObj.get("metrics").toString()));
          }

          // validate the optional field `metrics` (array)
          for (int i = 0; i < jsonArraymetrics.size(); i++) {
            Metric.validateJsonElement(jsonArraymetrics.get(i));
          };
        }
      }
      if (jsonObj.get("pivots") != null && !jsonObj.get("pivots").isJsonNull()) {
        JsonArray jsonArraypivots = jsonObj.getAsJsonArray("pivots");
        if (jsonArraypivots != null) {
          // ensure the json data is an array
          if (!jsonObj.get("pivots").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `pivots` to be an array in the JSON string but got `%s`", jsonObj.get("pivots").toString()));
          }

          // validate the optional field `pivots` (array)
          for (int i = 0; i < jsonArraypivots.size(); i++) {
            Pivot.validateJsonElement(jsonArraypivots.get(i));
          };
        }
      }
      if ((jsonObj.get("property") != null && !jsonObj.get("property").isJsonNull()) && !jsonObj.get("property").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `property` to be a primitive type in the JSON string but got `%s`", jsonObj.get("property").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RunPivotReportRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RunPivotReportRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RunPivotReportRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RunPivotReportRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<RunPivotReportRequest>() {
           @Override
           public void write(JsonWriter out, RunPivotReportRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RunPivotReportRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RunPivotReportRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RunPivotReportRequest
   * @throws IOException if the JSON string is invalid with respect to RunPivotReportRequest
   */
  public static RunPivotReportRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RunPivotReportRequest.class);
  }

  /**
   * Convert an instance of RunPivotReportRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

