/*
 * Google Analytics Data API
 * Accesses report data in Google Analytics. Warning: Creating multiple Customer Applications, Accounts, or Projects to simulate or act as a single Customer Application, Account, or Project (respectively) or to circumvent Service-specific usage limits or quotas is a direct violation of Google Cloud Platform Terms of Service as well as Google APIs Terms of Service. These actions can result in immediate termination of your GCP project(s) without any warning. 
 *
 * The version of the OpenAPI document: v1beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DimensionHeader;
import org.openapitools.client.model.MetricHeader;
import org.openapitools.client.model.PropertyQuota;
import org.openapitools.client.model.Row;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The response realtime report table corresponding to a request.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:33:54.521143-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class RunRealtimeReportResponse {
  public static final String SERIALIZED_NAME_DIMENSION_HEADERS = "dimensionHeaders";
  @SerializedName(SERIALIZED_NAME_DIMENSION_HEADERS)
  private List<DimensionHeader> dimensionHeaders = new ArrayList<>();

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private String kind;

  public static final String SERIALIZED_NAME_MAXIMUMS = "maximums";
  @SerializedName(SERIALIZED_NAME_MAXIMUMS)
  private List<Row> maximums = new ArrayList<>();

  public static final String SERIALIZED_NAME_METRIC_HEADERS = "metricHeaders";
  @SerializedName(SERIALIZED_NAME_METRIC_HEADERS)
  private List<MetricHeader> metricHeaders = new ArrayList<>();

  public static final String SERIALIZED_NAME_MINIMUMS = "minimums";
  @SerializedName(SERIALIZED_NAME_MINIMUMS)
  private List<Row> minimums = new ArrayList<>();

  public static final String SERIALIZED_NAME_PROPERTY_QUOTA = "propertyQuota";
  @SerializedName(SERIALIZED_NAME_PROPERTY_QUOTA)
  private PropertyQuota propertyQuota;

  public static final String SERIALIZED_NAME_ROW_COUNT = "rowCount";
  @SerializedName(SERIALIZED_NAME_ROW_COUNT)
  private Integer rowCount;

  public static final String SERIALIZED_NAME_ROWS = "rows";
  @SerializedName(SERIALIZED_NAME_ROWS)
  private List<Row> rows = new ArrayList<>();

  public static final String SERIALIZED_NAME_TOTALS = "totals";
  @SerializedName(SERIALIZED_NAME_TOTALS)
  private List<Row> totals = new ArrayList<>();

  public RunRealtimeReportResponse() {
  }

  public RunRealtimeReportResponse dimensionHeaders(List<DimensionHeader> dimensionHeaders) {
    this.dimensionHeaders = dimensionHeaders;
    return this;
  }

  public RunRealtimeReportResponse addDimensionHeadersItem(DimensionHeader dimensionHeadersItem) {
    if (this.dimensionHeaders == null) {
      this.dimensionHeaders = new ArrayList<>();
    }
    this.dimensionHeaders.add(dimensionHeadersItem);
    return this;
  }

  /**
   * Describes dimension columns. The number of DimensionHeaders and ordering of DimensionHeaders matches the dimensions present in rows.
   * @return dimensionHeaders
   */
  @javax.annotation.Nullable
  public List<DimensionHeader> getDimensionHeaders() {
    return dimensionHeaders;
  }

  public void setDimensionHeaders(List<DimensionHeader> dimensionHeaders) {
    this.dimensionHeaders = dimensionHeaders;
  }


  public RunRealtimeReportResponse kind(String kind) {
    this.kind = kind;
    return this;
  }

  /**
   * Identifies what kind of resource this message is. This &#x60;kind&#x60; is always the fixed string \&quot;analyticsData#runRealtimeReport\&quot;. Useful to distinguish between response types in JSON.
   * @return kind
   */
  @javax.annotation.Nullable
  public String getKind() {
    return kind;
  }

  public void setKind(String kind) {
    this.kind = kind;
  }


  public RunRealtimeReportResponse maximums(List<Row> maximums) {
    this.maximums = maximums;
    return this;
  }

  public RunRealtimeReportResponse addMaximumsItem(Row maximumsItem) {
    if (this.maximums == null) {
      this.maximums = new ArrayList<>();
    }
    this.maximums.add(maximumsItem);
    return this;
  }

  /**
   * If requested, the maximum values of metrics.
   * @return maximums
   */
  @javax.annotation.Nullable
  public List<Row> getMaximums() {
    return maximums;
  }

  public void setMaximums(List<Row> maximums) {
    this.maximums = maximums;
  }


  public RunRealtimeReportResponse metricHeaders(List<MetricHeader> metricHeaders) {
    this.metricHeaders = metricHeaders;
    return this;
  }

  public RunRealtimeReportResponse addMetricHeadersItem(MetricHeader metricHeadersItem) {
    if (this.metricHeaders == null) {
      this.metricHeaders = new ArrayList<>();
    }
    this.metricHeaders.add(metricHeadersItem);
    return this;
  }

  /**
   * Describes metric columns. The number of MetricHeaders and ordering of MetricHeaders matches the metrics present in rows.
   * @return metricHeaders
   */
  @javax.annotation.Nullable
  public List<MetricHeader> getMetricHeaders() {
    return metricHeaders;
  }

  public void setMetricHeaders(List<MetricHeader> metricHeaders) {
    this.metricHeaders = metricHeaders;
  }


  public RunRealtimeReportResponse minimums(List<Row> minimums) {
    this.minimums = minimums;
    return this;
  }

  public RunRealtimeReportResponse addMinimumsItem(Row minimumsItem) {
    if (this.minimums == null) {
      this.minimums = new ArrayList<>();
    }
    this.minimums.add(minimumsItem);
    return this;
  }

  /**
   * If requested, the minimum values of metrics.
   * @return minimums
   */
  @javax.annotation.Nullable
  public List<Row> getMinimums() {
    return minimums;
  }

  public void setMinimums(List<Row> minimums) {
    this.minimums = minimums;
  }


  public RunRealtimeReportResponse propertyQuota(PropertyQuota propertyQuota) {
    this.propertyQuota = propertyQuota;
    return this;
  }

  /**
   * Get propertyQuota
   * @return propertyQuota
   */
  @javax.annotation.Nullable
  public PropertyQuota getPropertyQuota() {
    return propertyQuota;
  }

  public void setPropertyQuota(PropertyQuota propertyQuota) {
    this.propertyQuota = propertyQuota;
  }


  public RunRealtimeReportResponse rowCount(Integer rowCount) {
    this.rowCount = rowCount;
    return this;
  }

  /**
   * The total number of rows in the query result. &#x60;rowCount&#x60; is independent of the number of rows returned in the response and the &#x60;limit&#x60; request parameter. For example if a query returns 175 rows and includes &#x60;limit&#x60; of 50 in the API request, the response will contain &#x60;rowCount&#x60; of 175 but only 50 rows.
   * @return rowCount
   */
  @javax.annotation.Nullable
  public Integer getRowCount() {
    return rowCount;
  }

  public void setRowCount(Integer rowCount) {
    this.rowCount = rowCount;
  }


  public RunRealtimeReportResponse rows(List<Row> rows) {
    this.rows = rows;
    return this;
  }

  public RunRealtimeReportResponse addRowsItem(Row rowsItem) {
    if (this.rows == null) {
      this.rows = new ArrayList<>();
    }
    this.rows.add(rowsItem);
    return this;
  }

  /**
   * Rows of dimension value combinations and metric values in the report.
   * @return rows
   */
  @javax.annotation.Nullable
  public List<Row> getRows() {
    return rows;
  }

  public void setRows(List<Row> rows) {
    this.rows = rows;
  }


  public RunRealtimeReportResponse totals(List<Row> totals) {
    this.totals = totals;
    return this;
  }

  public RunRealtimeReportResponse addTotalsItem(Row totalsItem) {
    if (this.totals == null) {
      this.totals = new ArrayList<>();
    }
    this.totals.add(totalsItem);
    return this;
  }

  /**
   * If requested, the totaled values of metrics.
   * @return totals
   */
  @javax.annotation.Nullable
  public List<Row> getTotals() {
    return totals;
  }

  public void setTotals(List<Row> totals) {
    this.totals = totals;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RunRealtimeReportResponse runRealtimeReportResponse = (RunRealtimeReportResponse) o;
    return Objects.equals(this.dimensionHeaders, runRealtimeReportResponse.dimensionHeaders) &&
        Objects.equals(this.kind, runRealtimeReportResponse.kind) &&
        Objects.equals(this.maximums, runRealtimeReportResponse.maximums) &&
        Objects.equals(this.metricHeaders, runRealtimeReportResponse.metricHeaders) &&
        Objects.equals(this.minimums, runRealtimeReportResponse.minimums) &&
        Objects.equals(this.propertyQuota, runRealtimeReportResponse.propertyQuota) &&
        Objects.equals(this.rowCount, runRealtimeReportResponse.rowCount) &&
        Objects.equals(this.rows, runRealtimeReportResponse.rows) &&
        Objects.equals(this.totals, runRealtimeReportResponse.totals);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dimensionHeaders, kind, maximums, metricHeaders, minimums, propertyQuota, rowCount, rows, totals);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RunRealtimeReportResponse {\n");
    sb.append("    dimensionHeaders: ").append(toIndentedString(dimensionHeaders)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    maximums: ").append(toIndentedString(maximums)).append("\n");
    sb.append("    metricHeaders: ").append(toIndentedString(metricHeaders)).append("\n");
    sb.append("    minimums: ").append(toIndentedString(minimums)).append("\n");
    sb.append("    propertyQuota: ").append(toIndentedString(propertyQuota)).append("\n");
    sb.append("    rowCount: ").append(toIndentedString(rowCount)).append("\n");
    sb.append("    rows: ").append(toIndentedString(rows)).append("\n");
    sb.append("    totals: ").append(toIndentedString(totals)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dimensionHeaders");
    openapiFields.add("kind");
    openapiFields.add("maximums");
    openapiFields.add("metricHeaders");
    openapiFields.add("minimums");
    openapiFields.add("propertyQuota");
    openapiFields.add("rowCount");
    openapiFields.add("rows");
    openapiFields.add("totals");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to RunRealtimeReportResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RunRealtimeReportResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RunRealtimeReportResponse is not found in the empty JSON string", RunRealtimeReportResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RunRealtimeReportResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RunRealtimeReportResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("dimensionHeaders") != null && !jsonObj.get("dimensionHeaders").isJsonNull()) {
        JsonArray jsonArraydimensionHeaders = jsonObj.getAsJsonArray("dimensionHeaders");
        if (jsonArraydimensionHeaders != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dimensionHeaders").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dimensionHeaders` to be an array in the JSON string but got `%s`", jsonObj.get("dimensionHeaders").toString()));
          }

          // validate the optional field `dimensionHeaders` (array)
          for (int i = 0; i < jsonArraydimensionHeaders.size(); i++) {
            DimensionHeader.validateJsonElement(jsonArraydimensionHeaders.get(i));
          };
        }
      }
      if ((jsonObj.get("kind") != null && !jsonObj.get("kind").isJsonNull()) && !jsonObj.get("kind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kind").toString()));
      }
      if (jsonObj.get("maximums") != null && !jsonObj.get("maximums").isJsonNull()) {
        JsonArray jsonArraymaximums = jsonObj.getAsJsonArray("maximums");
        if (jsonArraymaximums != null) {
          // ensure the json data is an array
          if (!jsonObj.get("maximums").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `maximums` to be an array in the JSON string but got `%s`", jsonObj.get("maximums").toString()));
          }

          // validate the optional field `maximums` (array)
          for (int i = 0; i < jsonArraymaximums.size(); i++) {
            Row.validateJsonElement(jsonArraymaximums.get(i));
          };
        }
      }
      if (jsonObj.get("metricHeaders") != null && !jsonObj.get("metricHeaders").isJsonNull()) {
        JsonArray jsonArraymetricHeaders = jsonObj.getAsJsonArray("metricHeaders");
        if (jsonArraymetricHeaders != null) {
          // ensure the json data is an array
          if (!jsonObj.get("metricHeaders").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `metricHeaders` to be an array in the JSON string but got `%s`", jsonObj.get("metricHeaders").toString()));
          }

          // validate the optional field `metricHeaders` (array)
          for (int i = 0; i < jsonArraymetricHeaders.size(); i++) {
            MetricHeader.validateJsonElement(jsonArraymetricHeaders.get(i));
          };
        }
      }
      if (jsonObj.get("minimums") != null && !jsonObj.get("minimums").isJsonNull()) {
        JsonArray jsonArrayminimums = jsonObj.getAsJsonArray("minimums");
        if (jsonArrayminimums != null) {
          // ensure the json data is an array
          if (!jsonObj.get("minimums").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `minimums` to be an array in the JSON string but got `%s`", jsonObj.get("minimums").toString()));
          }

          // validate the optional field `minimums` (array)
          for (int i = 0; i < jsonArrayminimums.size(); i++) {
            Row.validateJsonElement(jsonArrayminimums.get(i));
          };
        }
      }
      // validate the optional field `propertyQuota`
      if (jsonObj.get("propertyQuota") != null && !jsonObj.get("propertyQuota").isJsonNull()) {
        PropertyQuota.validateJsonElement(jsonObj.get("propertyQuota"));
      }
      if (jsonObj.get("rows") != null && !jsonObj.get("rows").isJsonNull()) {
        JsonArray jsonArrayrows = jsonObj.getAsJsonArray("rows");
        if (jsonArrayrows != null) {
          // ensure the json data is an array
          if (!jsonObj.get("rows").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `rows` to be an array in the JSON string but got `%s`", jsonObj.get("rows").toString()));
          }

          // validate the optional field `rows` (array)
          for (int i = 0; i < jsonArrayrows.size(); i++) {
            Row.validateJsonElement(jsonArrayrows.get(i));
          };
        }
      }
      if (jsonObj.get("totals") != null && !jsonObj.get("totals").isJsonNull()) {
        JsonArray jsonArraytotals = jsonObj.getAsJsonArray("totals");
        if (jsonArraytotals != null) {
          // ensure the json data is an array
          if (!jsonObj.get("totals").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `totals` to be an array in the JSON string but got `%s`", jsonObj.get("totals").toString()));
          }

          // validate the optional field `totals` (array)
          for (int i = 0; i < jsonArraytotals.size(); i++) {
            Row.validateJsonElement(jsonArraytotals.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RunRealtimeReportResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RunRealtimeReportResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RunRealtimeReportResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RunRealtimeReportResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<RunRealtimeReportResponse>() {
           @Override
           public void write(JsonWriter out, RunRealtimeReportResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RunRealtimeReportResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of RunRealtimeReportResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of RunRealtimeReportResponse
   * @throws IOException if the JSON string is invalid with respect to RunRealtimeReportResponse
   */
  public static RunRealtimeReportResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RunRealtimeReportResponse.class);
  }

  /**
   * Convert an instance of RunRealtimeReportResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

