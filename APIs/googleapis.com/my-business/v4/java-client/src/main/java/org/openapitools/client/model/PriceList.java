/*
 * Google My Business API
 * The Google My Business API provides an interface for managing business location information on Google.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Label;
import org.openapitools.client.model.Section;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A list of item price information. Price lists are structured as one or more price lists, each containing one or more sections with one or more items. For example, food price lists may represent breakfast/lunch/dinner menus, with sections for burgers/steak/seafood.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:13.025173-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PriceList {
  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private List<Label> labels = new ArrayList<>();

  public static final String SERIALIZED_NAME_PRICE_LIST_ID = "priceListId";
  @SerializedName(SERIALIZED_NAME_PRICE_LIST_ID)
  private String priceListId;

  public static final String SERIALIZED_NAME_SECTIONS = "sections";
  @SerializedName(SERIALIZED_NAME_SECTIONS)
  private List<Section> sections = new ArrayList<>();

  public static final String SERIALIZED_NAME_SOURCE_URL = "sourceUrl";
  @SerializedName(SERIALIZED_NAME_SOURCE_URL)
  private String sourceUrl;

  public PriceList() {
  }

  public PriceList labels(List<Label> labels) {
    this.labels = labels;
    return this;
  }

  public PriceList addLabelsItem(Label labelsItem) {
    if (this.labels == null) {
      this.labels = new ArrayList<>();
    }
    this.labels.add(labelsItem);
    return this;
  }

  /**
   * Required. Language-tagged labels for the price list.
   * @return labels
   */
  @javax.annotation.Nullable
  public List<Label> getLabels() {
    return labels;
  }

  public void setLabels(List<Label> labels) {
    this.labels = labels;
  }


  public PriceList priceListId(String priceListId) {
    this.priceListId = priceListId;
    return this;
  }

  /**
   * Required. ID for the price list. Price list, section, and item IDs cannot be duplicated within this Location.
   * @return priceListId
   */
  @javax.annotation.Nullable
  public String getPriceListId() {
    return priceListId;
  }

  public void setPriceListId(String priceListId) {
    this.priceListId = priceListId;
  }


  public PriceList sections(List<Section> sections) {
    this.sections = sections;
    return this;
  }

  public PriceList addSectionsItem(Section sectionsItem) {
    if (this.sections == null) {
      this.sections = new ArrayList<>();
    }
    this.sections.add(sectionsItem);
    return this;
  }

  /**
   * Required. Sections for this price list. Each price list must contain at least one section.
   * @return sections
   */
  @javax.annotation.Nullable
  public List<Section> getSections() {
    return sections;
  }

  public void setSections(List<Section> sections) {
    this.sections = sections;
  }


  public PriceList sourceUrl(String sourceUrl) {
    this.sourceUrl = sourceUrl;
    return this;
  }

  /**
   * Optional source URL of where the price list was retrieved from. For example, this could be the URL of the page that was automatically scraped to populate the menu information.
   * @return sourceUrl
   */
  @javax.annotation.Nullable
  public String getSourceUrl() {
    return sourceUrl;
  }

  public void setSourceUrl(String sourceUrl) {
    this.sourceUrl = sourceUrl;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PriceList priceList = (PriceList) o;
    return Objects.equals(this.labels, priceList.labels) &&
        Objects.equals(this.priceListId, priceList.priceListId) &&
        Objects.equals(this.sections, priceList.sections) &&
        Objects.equals(this.sourceUrl, priceList.sourceUrl);
  }

  @Override
  public int hashCode() {
    return Objects.hash(labels, priceListId, sections, sourceUrl);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PriceList {\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    priceListId: ").append(toIndentedString(priceListId)).append("\n");
    sb.append("    sections: ").append(toIndentedString(sections)).append("\n");
    sb.append("    sourceUrl: ").append(toIndentedString(sourceUrl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("labels");
    openapiFields.add("priceListId");
    openapiFields.add("sections");
    openapiFields.add("sourceUrl");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PriceList
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PriceList.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PriceList is not found in the empty JSON string", PriceList.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PriceList.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PriceList` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("labels") != null && !jsonObj.get("labels").isJsonNull()) {
        JsonArray jsonArraylabels = jsonObj.getAsJsonArray("labels");
        if (jsonArraylabels != null) {
          // ensure the json data is an array
          if (!jsonObj.get("labels").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `labels` to be an array in the JSON string but got `%s`", jsonObj.get("labels").toString()));
          }

          // validate the optional field `labels` (array)
          for (int i = 0; i < jsonArraylabels.size(); i++) {
            Label.validateJsonElement(jsonArraylabels.get(i));
          };
        }
      }
      if ((jsonObj.get("priceListId") != null && !jsonObj.get("priceListId").isJsonNull()) && !jsonObj.get("priceListId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priceListId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priceListId").toString()));
      }
      if (jsonObj.get("sections") != null && !jsonObj.get("sections").isJsonNull()) {
        JsonArray jsonArraysections = jsonObj.getAsJsonArray("sections");
        if (jsonArraysections != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sections").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sections` to be an array in the JSON string but got `%s`", jsonObj.get("sections").toString()));
          }

          // validate the optional field `sections` (array)
          for (int i = 0; i < jsonArraysections.size(); i++) {
            Section.validateJsonElement(jsonArraysections.get(i));
          };
        }
      }
      if ((jsonObj.get("sourceUrl") != null && !jsonObj.get("sourceUrl").isJsonNull()) && !jsonObj.get("sourceUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceUrl").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PriceList.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PriceList' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PriceList> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PriceList.class));

       return (TypeAdapter<T>) new TypeAdapter<PriceList>() {
           @Override
           public void write(JsonWriter out, PriceList value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PriceList read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PriceList given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PriceList
   * @throws IOException if the JSON string is invalid with respect to PriceList
   */
  public static PriceList fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PriceList.class);
  }

  /**
   * Convert an instance of PriceList to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

