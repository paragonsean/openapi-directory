/*
 * Google My Business API
 * The Google My Business API provides an interface for managing business location information on Google.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AttributeValueMetadata;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Metadata for an attribute. Contains display information for the attribute, including a localized name and a heading for grouping related attributes together.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:13.025173-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class AttributeMetadata {
  public static final String SERIALIZED_NAME_ATTRIBUTE_ID = "attributeId";
  @SerializedName(SERIALIZED_NAME_ATTRIBUTE_ID)
  private String attributeId;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_GROUP_DISPLAY_NAME = "groupDisplayName";
  @SerializedName(SERIALIZED_NAME_GROUP_DISPLAY_NAME)
  private String groupDisplayName;

  public static final String SERIALIZED_NAME_IS_DEPRECATED = "isDeprecated";
  @SerializedName(SERIALIZED_NAME_IS_DEPRECATED)
  private Boolean isDeprecated;

  public static final String SERIALIZED_NAME_IS_REPEATABLE = "isRepeatable";
  @SerializedName(SERIALIZED_NAME_IS_REPEATABLE)
  private Boolean isRepeatable;

  public static final String SERIALIZED_NAME_VALUE_METADATA = "valueMetadata";
  @SerializedName(SERIALIZED_NAME_VALUE_METADATA)
  private List<AttributeValueMetadata> valueMetadata = new ArrayList<>();

  /**
   * The value type for the attribute. Values set and retrieved should be expected to be of this type.
   */
  @JsonAdapter(ValueTypeEnum.Adapter.class)
  public enum ValueTypeEnum {
    ATTRIBUTE_VALUE_TYPE_UNSPECIFIED("ATTRIBUTE_VALUE_TYPE_UNSPECIFIED"),
    
    BOOL("BOOL"),
    
    ENUM("ENUM"),
    
    URL("URL"),
    
    REPEATED_ENUM("REPEATED_ENUM");

    private String value;

    ValueTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ValueTypeEnum fromValue(String value) {
      for (ValueTypeEnum b : ValueTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ValueTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ValueTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ValueTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ValueTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ValueTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VALUE_TYPE = "valueType";
  @SerializedName(SERIALIZED_NAME_VALUE_TYPE)
  private ValueTypeEnum valueType;

  public AttributeMetadata() {
  }

  public AttributeMetadata attributeId(String attributeId) {
    this.attributeId = attributeId;
    return this;
  }

  /**
   * The ID of the attribute.
   * @return attributeId
   */
  @javax.annotation.Nullable
  public String getAttributeId() {
    return attributeId;
  }

  public void setAttributeId(String attributeId) {
    this.attributeId = attributeId;
  }


  public AttributeMetadata displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * The localized display name for the attribute, if available; otherwise, the English display name.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public AttributeMetadata groupDisplayName(String groupDisplayName) {
    this.groupDisplayName = groupDisplayName;
    return this;
  }

  /**
   * The localized display name of the group that contains this attribute, if available; otherwise, the English group name. Related attributes are collected into a group and should be displayed together under the heading given here.
   * @return groupDisplayName
   */
  @javax.annotation.Nullable
  public String getGroupDisplayName() {
    return groupDisplayName;
  }

  public void setGroupDisplayName(String groupDisplayName) {
    this.groupDisplayName = groupDisplayName;
  }


  public AttributeMetadata isDeprecated(Boolean isDeprecated) {
    this.isDeprecated = isDeprecated;
    return this;
  }

  /**
   * If true, the attribute is deprecated and should no longer be used. If deprecated, updating this attribute will not result in an error, but updates will not be saved. At some point after being deprecated, the attribute will be removed entirely and it will become an error.
   * @return isDeprecated
   */
  @javax.annotation.Nullable
  public Boolean getIsDeprecated() {
    return isDeprecated;
  }

  public void setIsDeprecated(Boolean isDeprecated) {
    this.isDeprecated = isDeprecated;
  }


  public AttributeMetadata isRepeatable(Boolean isRepeatable) {
    this.isRepeatable = isRepeatable;
    return this;
  }

  /**
   * If true, the attribute supports multiple values. If false, only a single value should be provided.
   * @return isRepeatable
   */
  @javax.annotation.Nullable
  public Boolean getIsRepeatable() {
    return isRepeatable;
  }

  public void setIsRepeatable(Boolean isRepeatable) {
    this.isRepeatable = isRepeatable;
  }


  public AttributeMetadata valueMetadata(List<AttributeValueMetadata> valueMetadata) {
    this.valueMetadata = valueMetadata;
    return this;
  }

  public AttributeMetadata addValueMetadataItem(AttributeValueMetadata valueMetadataItem) {
    if (this.valueMetadata == null) {
      this.valueMetadata = new ArrayList<>();
    }
    this.valueMetadata.add(valueMetadataItem);
    return this;
  }

  /**
   * For some types of attributes (for example, enums), a list of supported values and corresponding display names for those values is provided.
   * @return valueMetadata
   */
  @javax.annotation.Nullable
  public List<AttributeValueMetadata> getValueMetadata() {
    return valueMetadata;
  }

  public void setValueMetadata(List<AttributeValueMetadata> valueMetadata) {
    this.valueMetadata = valueMetadata;
  }


  public AttributeMetadata valueType(ValueTypeEnum valueType) {
    this.valueType = valueType;
    return this;
  }

  /**
   * The value type for the attribute. Values set and retrieved should be expected to be of this type.
   * @return valueType
   */
  @javax.annotation.Nullable
  public ValueTypeEnum getValueType() {
    return valueType;
  }

  public void setValueType(ValueTypeEnum valueType) {
    this.valueType = valueType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AttributeMetadata attributeMetadata = (AttributeMetadata) o;
    return Objects.equals(this.attributeId, attributeMetadata.attributeId) &&
        Objects.equals(this.displayName, attributeMetadata.displayName) &&
        Objects.equals(this.groupDisplayName, attributeMetadata.groupDisplayName) &&
        Objects.equals(this.isDeprecated, attributeMetadata.isDeprecated) &&
        Objects.equals(this.isRepeatable, attributeMetadata.isRepeatable) &&
        Objects.equals(this.valueMetadata, attributeMetadata.valueMetadata) &&
        Objects.equals(this.valueType, attributeMetadata.valueType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(attributeId, displayName, groupDisplayName, isDeprecated, isRepeatable, valueMetadata, valueType);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AttributeMetadata {\n");
    sb.append("    attributeId: ").append(toIndentedString(attributeId)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    groupDisplayName: ").append(toIndentedString(groupDisplayName)).append("\n");
    sb.append("    isDeprecated: ").append(toIndentedString(isDeprecated)).append("\n");
    sb.append("    isRepeatable: ").append(toIndentedString(isRepeatable)).append("\n");
    sb.append("    valueMetadata: ").append(toIndentedString(valueMetadata)).append("\n");
    sb.append("    valueType: ").append(toIndentedString(valueType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("attributeId");
    openapiFields.add("displayName");
    openapiFields.add("groupDisplayName");
    openapiFields.add("isDeprecated");
    openapiFields.add("isRepeatable");
    openapiFields.add("valueMetadata");
    openapiFields.add("valueType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AttributeMetadata
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AttributeMetadata.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in AttributeMetadata is not found in the empty JSON string", AttributeMetadata.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AttributeMetadata.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `AttributeMetadata` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("attributeId") != null && !jsonObj.get("attributeId").isJsonNull()) && !jsonObj.get("attributeId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `attributeId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("attributeId").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("groupDisplayName") != null && !jsonObj.get("groupDisplayName").isJsonNull()) && !jsonObj.get("groupDisplayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `groupDisplayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("groupDisplayName").toString()));
      }
      if (jsonObj.get("valueMetadata") != null && !jsonObj.get("valueMetadata").isJsonNull()) {
        JsonArray jsonArrayvalueMetadata = jsonObj.getAsJsonArray("valueMetadata");
        if (jsonArrayvalueMetadata != null) {
          // ensure the json data is an array
          if (!jsonObj.get("valueMetadata").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `valueMetadata` to be an array in the JSON string but got `%s`", jsonObj.get("valueMetadata").toString()));
          }

          // validate the optional field `valueMetadata` (array)
          for (int i = 0; i < jsonArrayvalueMetadata.size(); i++) {
            AttributeValueMetadata.validateJsonElement(jsonArrayvalueMetadata.get(i));
          };
        }
      }
      if ((jsonObj.get("valueType") != null && !jsonObj.get("valueType").isJsonNull()) && !jsonObj.get("valueType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `valueType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valueType").toString()));
      }
      // validate the optional field `valueType`
      if (jsonObj.get("valueType") != null && !jsonObj.get("valueType").isJsonNull()) {
        ValueTypeEnum.validateJsonElement(jsonObj.get("valueType"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AttributeMetadata.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AttributeMetadata' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AttributeMetadata> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AttributeMetadata.class));

       return (TypeAdapter<T>) new TypeAdapter<AttributeMetadata>() {
           @Override
           public void write(JsonWriter out, AttributeMetadata value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AttributeMetadata read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AttributeMetadata given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AttributeMetadata
   * @throws IOException if the JSON string is invalid with respect to AttributeMetadata
   */
  public static AttributeMetadata fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AttributeMetadata.class);
  }

  /**
   * Convert an instance of AttributeMetadata to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

