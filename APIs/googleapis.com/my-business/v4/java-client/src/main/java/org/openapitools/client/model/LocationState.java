/*
 * Google My Business API
 * The Google My Business API provides an interface for managing business location information on Google.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Contains a set of booleans that reflect the [state of a Location.](https://support.google.com/business/answer/3480862)
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:13.025173-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class LocationState {
  public static final String SERIALIZED_NAME_CAN_DELETE = "canDelete";
  @SerializedName(SERIALIZED_NAME_CAN_DELETE)
  private Boolean canDelete;

  public static final String SERIALIZED_NAME_CAN_HAVE_FOOD_MENUS = "canHaveFoodMenus";
  @SerializedName(SERIALIZED_NAME_CAN_HAVE_FOOD_MENUS)
  private Boolean canHaveFoodMenus;

  public static final String SERIALIZED_NAME_CAN_MODIFY_SERVICE_LIST = "canModifyServiceList";
  @SerializedName(SERIALIZED_NAME_CAN_MODIFY_SERVICE_LIST)
  private Boolean canModifyServiceList;

  public static final String SERIALIZED_NAME_CAN_OPERATE_HEALTH_DATA = "canOperateHealthData";
  @SerializedName(SERIALIZED_NAME_CAN_OPERATE_HEALTH_DATA)
  private Boolean canOperateHealthData;

  public static final String SERIALIZED_NAME_CAN_OPERATE_LODGING_DATA = "canOperateLodgingData";
  @SerializedName(SERIALIZED_NAME_CAN_OPERATE_LODGING_DATA)
  private Boolean canOperateLodgingData;

  public static final String SERIALIZED_NAME_CAN_UPDATE = "canUpdate";
  @SerializedName(SERIALIZED_NAME_CAN_UPDATE)
  private Boolean canUpdate;

  public static final String SERIALIZED_NAME_HAS_PENDING_EDITS = "hasPendingEdits";
  @SerializedName(SERIALIZED_NAME_HAS_PENDING_EDITS)
  private Boolean hasPendingEdits;

  public static final String SERIALIZED_NAME_HAS_PENDING_VERIFICATION = "hasPendingVerification";
  @SerializedName(SERIALIZED_NAME_HAS_PENDING_VERIFICATION)
  private Boolean hasPendingVerification;

  public static final String SERIALIZED_NAME_IS_DISABLED = "isDisabled";
  @SerializedName(SERIALIZED_NAME_IS_DISABLED)
  private Boolean isDisabled;

  public static final String SERIALIZED_NAME_IS_DISCONNECTED = "isDisconnected";
  @SerializedName(SERIALIZED_NAME_IS_DISCONNECTED)
  private Boolean isDisconnected;

  public static final String SERIALIZED_NAME_IS_DUPLICATE = "isDuplicate";
  @SerializedName(SERIALIZED_NAME_IS_DUPLICATE)
  private Boolean isDuplicate;

  public static final String SERIALIZED_NAME_IS_GOOGLE_UPDATED = "isGoogleUpdated";
  @SerializedName(SERIALIZED_NAME_IS_GOOGLE_UPDATED)
  private Boolean isGoogleUpdated;

  public static final String SERIALIZED_NAME_IS_LOCAL_POST_API_DISABLED = "isLocalPostApiDisabled";
  @SerializedName(SERIALIZED_NAME_IS_LOCAL_POST_API_DISABLED)
  private Boolean isLocalPostApiDisabled;

  public static final String SERIALIZED_NAME_IS_PENDING_REVIEW = "isPendingReview";
  @SerializedName(SERIALIZED_NAME_IS_PENDING_REVIEW)
  private Boolean isPendingReview;

  public static final String SERIALIZED_NAME_IS_PUBLISHED = "isPublished";
  @SerializedName(SERIALIZED_NAME_IS_PUBLISHED)
  private Boolean isPublished;

  public static final String SERIALIZED_NAME_IS_SUSPENDED = "isSuspended";
  @SerializedName(SERIALIZED_NAME_IS_SUSPENDED)
  private Boolean isSuspended;

  public static final String SERIALIZED_NAME_IS_VERIFIED = "isVerified";
  @SerializedName(SERIALIZED_NAME_IS_VERIFIED)
  private Boolean isVerified;

  public static final String SERIALIZED_NAME_NEEDS_REVERIFICATION = "needsReverification";
  @SerializedName(SERIALIZED_NAME_NEEDS_REVERIFICATION)
  private Boolean needsReverification;

  public LocationState() {
  }

  public LocationState(
     Boolean canHaveFoodMenus, 
     Boolean canModifyServiceList, 
     Boolean canOperateHealthData, 
     Boolean canOperateLodgingData
  ) {
    this();
    this.canHaveFoodMenus = canHaveFoodMenus;
    this.canModifyServiceList = canModifyServiceList;
    this.canOperateHealthData = canOperateHealthData;
    this.canOperateLodgingData = canOperateLodgingData;
  }

  public LocationState canDelete(Boolean canDelete) {
    this.canDelete = canDelete;
    return this;
  }

  /**
   * Output only. Indicates whether the location can be deleted using the Google My Business API.
   * @return canDelete
   */
  @javax.annotation.Nullable
  public Boolean getCanDelete() {
    return canDelete;
  }

  public void setCanDelete(Boolean canDelete) {
    this.canDelete = canDelete;
  }


  /**
   * Output only. Indicates if the listing is eligible for food menu.
   * @return canHaveFoodMenus
   */
  @javax.annotation.Nullable
  public Boolean getCanHaveFoodMenus() {
    return canHaveFoodMenus;
  }



  /**
   * Output only. Indicates if the listing can modify a ServiceList.
   * @return canModifyServiceList
   */
  @javax.annotation.Nullable
  public Boolean getCanModifyServiceList() {
    return canModifyServiceList;
  }



  /**
   * Output only. Indicates whether the location can operate on Health data.
   * @return canOperateHealthData
   */
  @javax.annotation.Nullable
  public Boolean getCanOperateHealthData() {
    return canOperateHealthData;
  }



  /**
   * Output only. Indicates whether the location can operate on Lodging data.
   * @return canOperateLodgingData
   */
  @javax.annotation.Nullable
  public Boolean getCanOperateLodgingData() {
    return canOperateLodgingData;
  }



  public LocationState canUpdate(Boolean canUpdate) {
    this.canUpdate = canUpdate;
    return this;
  }

  /**
   * Output only. Indicates whether the location can be updated.
   * @return canUpdate
   */
  @javax.annotation.Nullable
  public Boolean getCanUpdate() {
    return canUpdate;
  }

  public void setCanUpdate(Boolean canUpdate) {
    this.canUpdate = canUpdate;
  }


  public LocationState hasPendingEdits(Boolean hasPendingEdits) {
    this.hasPendingEdits = hasPendingEdits;
    return this;
  }

  /**
   * Output only. Indicates whether any of this Location&#39;s properties are in the edit pending state.
   * @return hasPendingEdits
   */
  @javax.annotation.Nullable
  public Boolean getHasPendingEdits() {
    return hasPendingEdits;
  }

  public void setHasPendingEdits(Boolean hasPendingEdits) {
    this.hasPendingEdits = hasPendingEdits;
  }


  public LocationState hasPendingVerification(Boolean hasPendingVerification) {
    this.hasPendingVerification = hasPendingVerification;
    return this;
  }

  /**
   * Output only. Indicates whether the location has pending verification requests.
   * @return hasPendingVerification
   */
  @javax.annotation.Nullable
  public Boolean getHasPendingVerification() {
    return hasPendingVerification;
  }

  public void setHasPendingVerification(Boolean hasPendingVerification) {
    this.hasPendingVerification = hasPendingVerification;
  }


  public LocationState isDisabled(Boolean isDisabled) {
    this.isDisabled = isDisabled;
    return this;
  }

  /**
   * Output only. Indicates whether the location is disabled.
   * @return isDisabled
   */
  @javax.annotation.Nullable
  public Boolean getIsDisabled() {
    return isDisabled;
  }

  public void setIsDisabled(Boolean isDisabled) {
    this.isDisabled = isDisabled;
  }


  public LocationState isDisconnected(Boolean isDisconnected) {
    this.isDisconnected = isDisconnected;
    return this;
  }

  /**
   * Output only. Indicates whether the location is disconnected from a place on Google Maps.
   * @return isDisconnected
   */
  @javax.annotation.Nullable
  public Boolean getIsDisconnected() {
    return isDisconnected;
  }

  public void setIsDisconnected(Boolean isDisconnected) {
    this.isDisconnected = isDisconnected;
  }


  public LocationState isDuplicate(Boolean isDuplicate) {
    this.isDuplicate = isDuplicate;
    return this;
  }

  /**
   * Output only. Indicates whether the location is a duplicate of another location.
   * @return isDuplicate
   */
  @javax.annotation.Nullable
  public Boolean getIsDuplicate() {
    return isDuplicate;
  }

  public void setIsDuplicate(Boolean isDuplicate) {
    this.isDuplicate = isDuplicate;
  }


  public LocationState isGoogleUpdated(Boolean isGoogleUpdated) {
    this.isGoogleUpdated = isGoogleUpdated;
    return this;
  }

  /**
   * Output only. Indicates whether the place ID associated with this location has updates.
   * @return isGoogleUpdated
   */
  @javax.annotation.Nullable
  public Boolean getIsGoogleUpdated() {
    return isGoogleUpdated;
  }

  public void setIsGoogleUpdated(Boolean isGoogleUpdated) {
    this.isGoogleUpdated = isGoogleUpdated;
  }


  public LocationState isLocalPostApiDisabled(Boolean isLocalPostApiDisabled) {
    this.isLocalPostApiDisabled = isLocalPostApiDisabled;
    return this;
  }

  /**
   * Output only. Indicates whether [accounts.locations.localPosts](/my-business/reference/rest/v4/accounts.locations.localPosts) is disabled for this location.
   * @return isLocalPostApiDisabled
   */
  @javax.annotation.Nullable
  public Boolean getIsLocalPostApiDisabled() {
    return isLocalPostApiDisabled;
  }

  public void setIsLocalPostApiDisabled(Boolean isLocalPostApiDisabled) {
    this.isLocalPostApiDisabled = isLocalPostApiDisabled;
  }


  public LocationState isPendingReview(Boolean isPendingReview) {
    this.isPendingReview = isPendingReview;
    return this;
  }

  /**
   * Output only. Indicates whether the review of the location is pending.
   * @return isPendingReview
   */
  @javax.annotation.Nullable
  public Boolean getIsPendingReview() {
    return isPendingReview;
  }

  public void setIsPendingReview(Boolean isPendingReview) {
    this.isPendingReview = isPendingReview;
  }


  public LocationState isPublished(Boolean isPublished) {
    this.isPublished = isPublished;
    return this;
  }

  /**
   * Output only. Indicates whether the location is published.
   * @return isPublished
   */
  @javax.annotation.Nullable
  public Boolean getIsPublished() {
    return isPublished;
  }

  public void setIsPublished(Boolean isPublished) {
    this.isPublished = isPublished;
  }


  public LocationState isSuspended(Boolean isSuspended) {
    this.isSuspended = isSuspended;
    return this;
  }

  /**
   * Output only. Indicates whether the location is suspended. Suspended locations are not visible to end users in Google products. If you believe this was a mistake, see the [help center article] (https://support.google.com/business/answer/4569145).
   * @return isSuspended
   */
  @javax.annotation.Nullable
  public Boolean getIsSuspended() {
    return isSuspended;
  }

  public void setIsSuspended(Boolean isSuspended) {
    this.isSuspended = isSuspended;
  }


  public LocationState isVerified(Boolean isVerified) {
    this.isVerified = isVerified;
    return this;
  }

  /**
   * Output only. Indicates whether the location is verified.
   * @return isVerified
   */
  @javax.annotation.Nullable
  public Boolean getIsVerified() {
    return isVerified;
  }

  public void setIsVerified(Boolean isVerified) {
    this.isVerified = isVerified;
  }


  public LocationState needsReverification(Boolean needsReverification) {
    this.needsReverification = needsReverification;
    return this;
  }

  /**
   * Output only. Indicates whether the location requires reverification.
   * @return needsReverification
   */
  @javax.annotation.Nullable
  public Boolean getNeedsReverification() {
    return needsReverification;
  }

  public void setNeedsReverification(Boolean needsReverification) {
    this.needsReverification = needsReverification;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LocationState locationState = (LocationState) o;
    return Objects.equals(this.canDelete, locationState.canDelete) &&
        Objects.equals(this.canHaveFoodMenus, locationState.canHaveFoodMenus) &&
        Objects.equals(this.canModifyServiceList, locationState.canModifyServiceList) &&
        Objects.equals(this.canOperateHealthData, locationState.canOperateHealthData) &&
        Objects.equals(this.canOperateLodgingData, locationState.canOperateLodgingData) &&
        Objects.equals(this.canUpdate, locationState.canUpdate) &&
        Objects.equals(this.hasPendingEdits, locationState.hasPendingEdits) &&
        Objects.equals(this.hasPendingVerification, locationState.hasPendingVerification) &&
        Objects.equals(this.isDisabled, locationState.isDisabled) &&
        Objects.equals(this.isDisconnected, locationState.isDisconnected) &&
        Objects.equals(this.isDuplicate, locationState.isDuplicate) &&
        Objects.equals(this.isGoogleUpdated, locationState.isGoogleUpdated) &&
        Objects.equals(this.isLocalPostApiDisabled, locationState.isLocalPostApiDisabled) &&
        Objects.equals(this.isPendingReview, locationState.isPendingReview) &&
        Objects.equals(this.isPublished, locationState.isPublished) &&
        Objects.equals(this.isSuspended, locationState.isSuspended) &&
        Objects.equals(this.isVerified, locationState.isVerified) &&
        Objects.equals(this.needsReverification, locationState.needsReverification);
  }

  @Override
  public int hashCode() {
    return Objects.hash(canDelete, canHaveFoodMenus, canModifyServiceList, canOperateHealthData, canOperateLodgingData, canUpdate, hasPendingEdits, hasPendingVerification, isDisabled, isDisconnected, isDuplicate, isGoogleUpdated, isLocalPostApiDisabled, isPendingReview, isPublished, isSuspended, isVerified, needsReverification);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LocationState {\n");
    sb.append("    canDelete: ").append(toIndentedString(canDelete)).append("\n");
    sb.append("    canHaveFoodMenus: ").append(toIndentedString(canHaveFoodMenus)).append("\n");
    sb.append("    canModifyServiceList: ").append(toIndentedString(canModifyServiceList)).append("\n");
    sb.append("    canOperateHealthData: ").append(toIndentedString(canOperateHealthData)).append("\n");
    sb.append("    canOperateLodgingData: ").append(toIndentedString(canOperateLodgingData)).append("\n");
    sb.append("    canUpdate: ").append(toIndentedString(canUpdate)).append("\n");
    sb.append("    hasPendingEdits: ").append(toIndentedString(hasPendingEdits)).append("\n");
    sb.append("    hasPendingVerification: ").append(toIndentedString(hasPendingVerification)).append("\n");
    sb.append("    isDisabled: ").append(toIndentedString(isDisabled)).append("\n");
    sb.append("    isDisconnected: ").append(toIndentedString(isDisconnected)).append("\n");
    sb.append("    isDuplicate: ").append(toIndentedString(isDuplicate)).append("\n");
    sb.append("    isGoogleUpdated: ").append(toIndentedString(isGoogleUpdated)).append("\n");
    sb.append("    isLocalPostApiDisabled: ").append(toIndentedString(isLocalPostApiDisabled)).append("\n");
    sb.append("    isPendingReview: ").append(toIndentedString(isPendingReview)).append("\n");
    sb.append("    isPublished: ").append(toIndentedString(isPublished)).append("\n");
    sb.append("    isSuspended: ").append(toIndentedString(isSuspended)).append("\n");
    sb.append("    isVerified: ").append(toIndentedString(isVerified)).append("\n");
    sb.append("    needsReverification: ").append(toIndentedString(needsReverification)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("canDelete");
    openapiFields.add("canHaveFoodMenus");
    openapiFields.add("canModifyServiceList");
    openapiFields.add("canOperateHealthData");
    openapiFields.add("canOperateLodgingData");
    openapiFields.add("canUpdate");
    openapiFields.add("hasPendingEdits");
    openapiFields.add("hasPendingVerification");
    openapiFields.add("isDisabled");
    openapiFields.add("isDisconnected");
    openapiFields.add("isDuplicate");
    openapiFields.add("isGoogleUpdated");
    openapiFields.add("isLocalPostApiDisabled");
    openapiFields.add("isPendingReview");
    openapiFields.add("isPublished");
    openapiFields.add("isSuspended");
    openapiFields.add("isVerified");
    openapiFields.add("needsReverification");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LocationState
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LocationState.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LocationState is not found in the empty JSON string", LocationState.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LocationState.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LocationState` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LocationState.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LocationState' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LocationState> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LocationState.class));

       return (TypeAdapter<T>) new TypeAdapter<LocationState>() {
           @Override
           public void write(JsonWriter out, LocationState value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LocationState read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LocationState given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LocationState
   * @throws IOException if the JSON string is invalid with respect to LocationState
   */
  public static LocationState fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LocationState.class);
  }

  /**
   * Convert an instance of LocationState to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

