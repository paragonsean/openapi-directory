/*
 * Google My Business API
 * The Google My Business API provides an interface for managing business location information on Google.
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * General factual information about the property&#39;s physical structure and important dates.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:37:13.025173-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Property {
  public static final String SERIALIZED_NAME_BUILT_YEAR = "builtYear";
  @SerializedName(SERIALIZED_NAME_BUILT_YEAR)
  private Integer builtYear;

  /**
   * Built year exception.
   */
  @JsonAdapter(BuiltYearExceptionEnum.Adapter.class)
  public enum BuiltYearExceptionEnum {
    EXCEPTION_UNSPECIFIED("EXCEPTION_UNSPECIFIED"),
    
    UNDER_CONSTRUCTION("UNDER_CONSTRUCTION"),
    
    DEPENDENT_ON_SEASON("DEPENDENT_ON_SEASON"),
    
    DEPENDENT_ON_DAY_OF_WEEK("DEPENDENT_ON_DAY_OF_WEEK");

    private String value;

    BuiltYearExceptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BuiltYearExceptionEnum fromValue(String value) {
      for (BuiltYearExceptionEnum b : BuiltYearExceptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BuiltYearExceptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BuiltYearExceptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BuiltYearExceptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BuiltYearExceptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BuiltYearExceptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BUILT_YEAR_EXCEPTION = "builtYearException";
  @SerializedName(SERIALIZED_NAME_BUILT_YEAR_EXCEPTION)
  private BuiltYearExceptionEnum builtYearException;

  public static final String SERIALIZED_NAME_FLOORS_COUNT = "floorsCount";
  @SerializedName(SERIALIZED_NAME_FLOORS_COUNT)
  private Integer floorsCount;

  /**
   * Floors count exception.
   */
  @JsonAdapter(FloorsCountExceptionEnum.Adapter.class)
  public enum FloorsCountExceptionEnum {
    EXCEPTION_UNSPECIFIED("EXCEPTION_UNSPECIFIED"),
    
    UNDER_CONSTRUCTION("UNDER_CONSTRUCTION"),
    
    DEPENDENT_ON_SEASON("DEPENDENT_ON_SEASON"),
    
    DEPENDENT_ON_DAY_OF_WEEK("DEPENDENT_ON_DAY_OF_WEEK");

    private String value;

    FloorsCountExceptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FloorsCountExceptionEnum fromValue(String value) {
      for (FloorsCountExceptionEnum b : FloorsCountExceptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FloorsCountExceptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FloorsCountExceptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FloorsCountExceptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FloorsCountExceptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FloorsCountExceptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FLOORS_COUNT_EXCEPTION = "floorsCountException";
  @SerializedName(SERIALIZED_NAME_FLOORS_COUNT_EXCEPTION)
  private FloorsCountExceptionEnum floorsCountException;

  public static final String SERIALIZED_NAME_LAST_RENOVATED_YEAR = "lastRenovatedYear";
  @SerializedName(SERIALIZED_NAME_LAST_RENOVATED_YEAR)
  private Integer lastRenovatedYear;

  /**
   * Last renovated year exception.
   */
  @JsonAdapter(LastRenovatedYearExceptionEnum.Adapter.class)
  public enum LastRenovatedYearExceptionEnum {
    EXCEPTION_UNSPECIFIED("EXCEPTION_UNSPECIFIED"),
    
    UNDER_CONSTRUCTION("UNDER_CONSTRUCTION"),
    
    DEPENDENT_ON_SEASON("DEPENDENT_ON_SEASON"),
    
    DEPENDENT_ON_DAY_OF_WEEK("DEPENDENT_ON_DAY_OF_WEEK");

    private String value;

    LastRenovatedYearExceptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LastRenovatedYearExceptionEnum fromValue(String value) {
      for (LastRenovatedYearExceptionEnum b : LastRenovatedYearExceptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LastRenovatedYearExceptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LastRenovatedYearExceptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LastRenovatedYearExceptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LastRenovatedYearExceptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      LastRenovatedYearExceptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_LAST_RENOVATED_YEAR_EXCEPTION = "lastRenovatedYearException";
  @SerializedName(SERIALIZED_NAME_LAST_RENOVATED_YEAR_EXCEPTION)
  private LastRenovatedYearExceptionEnum lastRenovatedYearException;

  public static final String SERIALIZED_NAME_ROOMS_COUNT = "roomsCount";
  @SerializedName(SERIALIZED_NAME_ROOMS_COUNT)
  private Integer roomsCount;

  /**
   * Rooms count exception.
   */
  @JsonAdapter(RoomsCountExceptionEnum.Adapter.class)
  public enum RoomsCountExceptionEnum {
    EXCEPTION_UNSPECIFIED("EXCEPTION_UNSPECIFIED"),
    
    UNDER_CONSTRUCTION("UNDER_CONSTRUCTION"),
    
    DEPENDENT_ON_SEASON("DEPENDENT_ON_SEASON"),
    
    DEPENDENT_ON_DAY_OF_WEEK("DEPENDENT_ON_DAY_OF_WEEK");

    private String value;

    RoomsCountExceptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RoomsCountExceptionEnum fromValue(String value) {
      for (RoomsCountExceptionEnum b : RoomsCountExceptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RoomsCountExceptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RoomsCountExceptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RoomsCountExceptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RoomsCountExceptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      RoomsCountExceptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ROOMS_COUNT_EXCEPTION = "roomsCountException";
  @SerializedName(SERIALIZED_NAME_ROOMS_COUNT_EXCEPTION)
  private RoomsCountExceptionEnum roomsCountException;

  public Property() {
  }

  public Property builtYear(Integer builtYear) {
    this.builtYear = builtYear;
    return this;
  }

  /**
   * Built year. The year that construction of the property was completed.
   * @return builtYear
   */
  @javax.annotation.Nullable
  public Integer getBuiltYear() {
    return builtYear;
  }

  public void setBuiltYear(Integer builtYear) {
    this.builtYear = builtYear;
  }


  public Property builtYearException(BuiltYearExceptionEnum builtYearException) {
    this.builtYearException = builtYearException;
    return this;
  }

  /**
   * Built year exception.
   * @return builtYearException
   */
  @javax.annotation.Nullable
  public BuiltYearExceptionEnum getBuiltYearException() {
    return builtYearException;
  }

  public void setBuiltYearException(BuiltYearExceptionEnum builtYearException) {
    this.builtYearException = builtYearException;
  }


  public Property floorsCount(Integer floorsCount) {
    this.floorsCount = floorsCount;
    return this;
  }

  /**
   * Floors count. The number of stories the building has from the ground floor to the top floor that are accessible to guests.
   * @return floorsCount
   */
  @javax.annotation.Nullable
  public Integer getFloorsCount() {
    return floorsCount;
  }

  public void setFloorsCount(Integer floorsCount) {
    this.floorsCount = floorsCount;
  }


  public Property floorsCountException(FloorsCountExceptionEnum floorsCountException) {
    this.floorsCountException = floorsCountException;
    return this;
  }

  /**
   * Floors count exception.
   * @return floorsCountException
   */
  @javax.annotation.Nullable
  public FloorsCountExceptionEnum getFloorsCountException() {
    return floorsCountException;
  }

  public void setFloorsCountException(FloorsCountExceptionEnum floorsCountException) {
    this.floorsCountException = floorsCountException;
  }


  public Property lastRenovatedYear(Integer lastRenovatedYear) {
    this.lastRenovatedYear = lastRenovatedYear;
    return this;
  }

  /**
   * Last renovated year. The year when the most recent renovation of the property was completed. Renovation may include all or any combination of the following: the units, the public spaces, the exterior, or the interior.
   * @return lastRenovatedYear
   */
  @javax.annotation.Nullable
  public Integer getLastRenovatedYear() {
    return lastRenovatedYear;
  }

  public void setLastRenovatedYear(Integer lastRenovatedYear) {
    this.lastRenovatedYear = lastRenovatedYear;
  }


  public Property lastRenovatedYearException(LastRenovatedYearExceptionEnum lastRenovatedYearException) {
    this.lastRenovatedYearException = lastRenovatedYearException;
    return this;
  }

  /**
   * Last renovated year exception.
   * @return lastRenovatedYearException
   */
  @javax.annotation.Nullable
  public LastRenovatedYearExceptionEnum getLastRenovatedYearException() {
    return lastRenovatedYearException;
  }

  public void setLastRenovatedYearException(LastRenovatedYearExceptionEnum lastRenovatedYearException) {
    this.lastRenovatedYearException = lastRenovatedYearException;
  }


  public Property roomsCount(Integer roomsCount) {
    this.roomsCount = roomsCount;
    return this;
  }

  /**
   * Rooms count. The total number of rooms and suites bookable by guests for an overnight stay. Does not include event space, public spaces, conference rooms, fitness rooms, business centers, spa, salon, restaurants/bars, or shops.
   * @return roomsCount
   */
  @javax.annotation.Nullable
  public Integer getRoomsCount() {
    return roomsCount;
  }

  public void setRoomsCount(Integer roomsCount) {
    this.roomsCount = roomsCount;
  }


  public Property roomsCountException(RoomsCountExceptionEnum roomsCountException) {
    this.roomsCountException = roomsCountException;
    return this;
  }

  /**
   * Rooms count exception.
   * @return roomsCountException
   */
  @javax.annotation.Nullable
  public RoomsCountExceptionEnum getRoomsCountException() {
    return roomsCountException;
  }

  public void setRoomsCountException(RoomsCountExceptionEnum roomsCountException) {
    this.roomsCountException = roomsCountException;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Property property = (Property) o;
    return Objects.equals(this.builtYear, property.builtYear) &&
        Objects.equals(this.builtYearException, property.builtYearException) &&
        Objects.equals(this.floorsCount, property.floorsCount) &&
        Objects.equals(this.floorsCountException, property.floorsCountException) &&
        Objects.equals(this.lastRenovatedYear, property.lastRenovatedYear) &&
        Objects.equals(this.lastRenovatedYearException, property.lastRenovatedYearException) &&
        Objects.equals(this.roomsCount, property.roomsCount) &&
        Objects.equals(this.roomsCountException, property.roomsCountException);
  }

  @Override
  public int hashCode() {
    return Objects.hash(builtYear, builtYearException, floorsCount, floorsCountException, lastRenovatedYear, lastRenovatedYearException, roomsCount, roomsCountException);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Property {\n");
    sb.append("    builtYear: ").append(toIndentedString(builtYear)).append("\n");
    sb.append("    builtYearException: ").append(toIndentedString(builtYearException)).append("\n");
    sb.append("    floorsCount: ").append(toIndentedString(floorsCount)).append("\n");
    sb.append("    floorsCountException: ").append(toIndentedString(floorsCountException)).append("\n");
    sb.append("    lastRenovatedYear: ").append(toIndentedString(lastRenovatedYear)).append("\n");
    sb.append("    lastRenovatedYearException: ").append(toIndentedString(lastRenovatedYearException)).append("\n");
    sb.append("    roomsCount: ").append(toIndentedString(roomsCount)).append("\n");
    sb.append("    roomsCountException: ").append(toIndentedString(roomsCountException)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("builtYear");
    openapiFields.add("builtYearException");
    openapiFields.add("floorsCount");
    openapiFields.add("floorsCountException");
    openapiFields.add("lastRenovatedYear");
    openapiFields.add("lastRenovatedYearException");
    openapiFields.add("roomsCount");
    openapiFields.add("roomsCountException");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Property
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Property.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Property is not found in the empty JSON string", Property.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Property.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Property` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("builtYearException") != null && !jsonObj.get("builtYearException").isJsonNull()) && !jsonObj.get("builtYearException").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `builtYearException` to be a primitive type in the JSON string but got `%s`", jsonObj.get("builtYearException").toString()));
      }
      // validate the optional field `builtYearException`
      if (jsonObj.get("builtYearException") != null && !jsonObj.get("builtYearException").isJsonNull()) {
        BuiltYearExceptionEnum.validateJsonElement(jsonObj.get("builtYearException"));
      }
      if ((jsonObj.get("floorsCountException") != null && !jsonObj.get("floorsCountException").isJsonNull()) && !jsonObj.get("floorsCountException").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `floorsCountException` to be a primitive type in the JSON string but got `%s`", jsonObj.get("floorsCountException").toString()));
      }
      // validate the optional field `floorsCountException`
      if (jsonObj.get("floorsCountException") != null && !jsonObj.get("floorsCountException").isJsonNull()) {
        FloorsCountExceptionEnum.validateJsonElement(jsonObj.get("floorsCountException"));
      }
      if ((jsonObj.get("lastRenovatedYearException") != null && !jsonObj.get("lastRenovatedYearException").isJsonNull()) && !jsonObj.get("lastRenovatedYearException").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastRenovatedYearException` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastRenovatedYearException").toString()));
      }
      // validate the optional field `lastRenovatedYearException`
      if (jsonObj.get("lastRenovatedYearException") != null && !jsonObj.get("lastRenovatedYearException").isJsonNull()) {
        LastRenovatedYearExceptionEnum.validateJsonElement(jsonObj.get("lastRenovatedYearException"));
      }
      if ((jsonObj.get("roomsCountException") != null && !jsonObj.get("roomsCountException").isJsonNull()) && !jsonObj.get("roomsCountException").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `roomsCountException` to be a primitive type in the JSON string but got `%s`", jsonObj.get("roomsCountException").toString()));
      }
      // validate the optional field `roomsCountException`
      if (jsonObj.get("roomsCountException") != null && !jsonObj.get("roomsCountException").isJsonNull()) {
        RoomsCountExceptionEnum.validateJsonElement(jsonObj.get("roomsCountException"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Property.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Property' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Property> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Property.class));

       return (TypeAdapter<T>) new TypeAdapter<Property>() {
           @Override
           public void write(JsonWriter out, Property value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Property read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Property given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Property
   * @throws IOException if the JSON string is invalid with respect to Property
   */
  public static Property fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Property.class);
  }

  /**
   * Convert an instance of Property to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

