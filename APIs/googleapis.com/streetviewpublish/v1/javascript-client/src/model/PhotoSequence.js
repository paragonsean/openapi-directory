/**
 * Street View Publish API
 * Publishes 360 photos to Google Maps, along with position, orientation, and connectivity metadata. Apps can offer an interface for positioning, connecting, and uploading user-generated Street View images. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import Imu from './Imu';
import LatLngBounds from './LatLngBounds';
import Photo from './Photo';
import Pose from './Pose';
import ProcessingFailureDetails from './ProcessingFailureDetails';
import UploadRef from './UploadRef';

/**
 * The PhotoSequence model module.
 * @module model/PhotoSequence
 * @version v1
 */
class PhotoSequence {
    /**
     * Constructs a new <code>PhotoSequence</code>.
     * A sequence of 360 photos along with metadata.
     * @alias module:model/PhotoSequence
     */
    constructor() { 
        
        PhotoSequence.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>PhotoSequence</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/PhotoSequence} obj Optional instance to populate.
     * @return {module:model/PhotoSequence} The populated <code>PhotoSequence</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new PhotoSequence();

            if (data.hasOwnProperty('captureTimeOverride')) {
                obj['captureTimeOverride'] = ApiClient.convertToType(data['captureTimeOverride'], 'String');
            }
            if (data.hasOwnProperty('distanceMeters')) {
                obj['distanceMeters'] = ApiClient.convertToType(data['distanceMeters'], 'Number');
            }
            if (data.hasOwnProperty('failureDetails')) {
                obj['failureDetails'] = ProcessingFailureDetails.constructFromObject(data['failureDetails']);
            }
            if (data.hasOwnProperty('failureReason')) {
                obj['failureReason'] = ApiClient.convertToType(data['failureReason'], 'String');
            }
            if (data.hasOwnProperty('filename')) {
                obj['filename'] = ApiClient.convertToType(data['filename'], 'String');
            }
            if (data.hasOwnProperty('gpsSource')) {
                obj['gpsSource'] = ApiClient.convertToType(data['gpsSource'], 'String');
            }
            if (data.hasOwnProperty('id')) {
                obj['id'] = ApiClient.convertToType(data['id'], 'String');
            }
            if (data.hasOwnProperty('imu')) {
                obj['imu'] = Imu.constructFromObject(data['imu']);
            }
            if (data.hasOwnProperty('photos')) {
                obj['photos'] = ApiClient.convertToType(data['photos'], [Photo]);
            }
            if (data.hasOwnProperty('processingState')) {
                obj['processingState'] = ApiClient.convertToType(data['processingState'], 'String');
            }
            if (data.hasOwnProperty('rawGpsTimeline')) {
                obj['rawGpsTimeline'] = ApiClient.convertToType(data['rawGpsTimeline'], [Pose]);
            }
            if (data.hasOwnProperty('sequenceBounds')) {
                obj['sequenceBounds'] = LatLngBounds.constructFromObject(data['sequenceBounds']);
            }
            if (data.hasOwnProperty('uploadReference')) {
                obj['uploadReference'] = UploadRef.constructFromObject(data['uploadReference']);
            }
            if (data.hasOwnProperty('uploadTime')) {
                obj['uploadTime'] = ApiClient.convertToType(data['uploadTime'], 'String');
            }
            if (data.hasOwnProperty('viewCount')) {
                obj['viewCount'] = ApiClient.convertToType(data['viewCount'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>PhotoSequence</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>PhotoSequence</code>.
     */
    static validateJSON(data) {
        // ensure the json data is a string
        if (data['captureTimeOverride'] && !(typeof data['captureTimeOverride'] === 'string' || data['captureTimeOverride'] instanceof String)) {
            throw new Error("Expected the field `captureTimeOverride` to be a primitive type in the JSON string but got " + data['captureTimeOverride']);
        }
        // validate the optional field `failureDetails`
        if (data['failureDetails']) { // data not null
          ProcessingFailureDetails.validateJSON(data['failureDetails']);
        }
        // ensure the json data is a string
        if (data['failureReason'] && !(typeof data['failureReason'] === 'string' || data['failureReason'] instanceof String)) {
            throw new Error("Expected the field `failureReason` to be a primitive type in the JSON string but got " + data['failureReason']);
        }
        // ensure the json data is a string
        if (data['filename'] && !(typeof data['filename'] === 'string' || data['filename'] instanceof String)) {
            throw new Error("Expected the field `filename` to be a primitive type in the JSON string but got " + data['filename']);
        }
        // ensure the json data is a string
        if (data['gpsSource'] && !(typeof data['gpsSource'] === 'string' || data['gpsSource'] instanceof String)) {
            throw new Error("Expected the field `gpsSource` to be a primitive type in the JSON string but got " + data['gpsSource']);
        }
        // ensure the json data is a string
        if (data['id'] && !(typeof data['id'] === 'string' || data['id'] instanceof String)) {
            throw new Error("Expected the field `id` to be a primitive type in the JSON string but got " + data['id']);
        }
        // validate the optional field `imu`
        if (data['imu']) { // data not null
          Imu.validateJSON(data['imu']);
        }
        if (data['photos']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['photos'])) {
                throw new Error("Expected the field `photos` to be an array in the JSON data but got " + data['photos']);
            }
            // validate the optional field `photos` (array)
            for (const item of data['photos']) {
                Photo.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['processingState'] && !(typeof data['processingState'] === 'string' || data['processingState'] instanceof String)) {
            throw new Error("Expected the field `processingState` to be a primitive type in the JSON string but got " + data['processingState']);
        }
        if (data['rawGpsTimeline']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['rawGpsTimeline'])) {
                throw new Error("Expected the field `rawGpsTimeline` to be an array in the JSON data but got " + data['rawGpsTimeline']);
            }
            // validate the optional field `rawGpsTimeline` (array)
            for (const item of data['rawGpsTimeline']) {
                Pose.validateJSON(item);
            };
        }
        // validate the optional field `sequenceBounds`
        if (data['sequenceBounds']) { // data not null
          LatLngBounds.validateJSON(data['sequenceBounds']);
        }
        // validate the optional field `uploadReference`
        if (data['uploadReference']) { // data not null
          UploadRef.validateJSON(data['uploadReference']);
        }
        // ensure the json data is a string
        if (data['uploadTime'] && !(typeof data['uploadTime'] === 'string' || data['uploadTime'] instanceof String)) {
            throw new Error("Expected the field `uploadTime` to be a primitive type in the JSON string but got " + data['uploadTime']);
        }
        // ensure the json data is a string
        if (data['viewCount'] && !(typeof data['viewCount'] === 'string' || data['viewCount'] instanceof String)) {
            throw new Error("Expected the field `viewCount` to be a primitive type in the JSON string but got " + data['viewCount']);
        }

        return true;
    }


}



/**
 * Optional. Absolute time when the photo sequence starts to be captured. If the photo sequence is a video, this is the start time of the video. If this field is populated in input, it overrides the capture time in the video or XDM file.
 * @member {String} captureTimeOverride
 */
PhotoSequence.prototype['captureTimeOverride'] = undefined;

/**
 * Output only. The computed distance of the photo sequence in meters.
 * @member {Number} distanceMeters
 */
PhotoSequence.prototype['distanceMeters'] = undefined;

/**
 * @member {module:model/ProcessingFailureDetails} failureDetails
 */
PhotoSequence.prototype['failureDetails'] = undefined;

/**
 * Output only. If this sequence has processing_state = FAILED, this will contain the reason why it failed. If the processing_state is any other value, this field will be unset.
 * @member {module:model/PhotoSequence.FailureReasonEnum} failureReason
 */
PhotoSequence.prototype['failureReason'] = undefined;

/**
 * Output only. The filename of the upload. Does not include the directory path. Only available if the sequence was uploaded on a platform that provides the filename.
 * @member {String} filename
 */
PhotoSequence.prototype['filename'] = undefined;

/**
 * Input only. If both raw_gps_timeline and the Camera Motion Metadata Track (CAMM) contain GPS measurements, indicate which takes precedence.
 * @member {module:model/PhotoSequence.GpsSourceEnum} gpsSource
 */
PhotoSequence.prototype['gpsSource'] = undefined;

/**
 * Output only. Unique identifier for the photo sequence. This also acts as a long running operation ID if uploading is performed asynchronously.
 * @member {String} id
 */
PhotoSequence.prototype['id'] = undefined;

/**
 * @member {module:model/Imu} imu
 */
PhotoSequence.prototype['imu'] = undefined;

/**
 * Output only. Photos with increasing timestamps.
 * @member {Array.<module:model/Photo>} photos
 */
PhotoSequence.prototype['photos'] = undefined;

/**
 * Output only. The processing state of this sequence.
 * @member {module:model/PhotoSequence.ProcessingStateEnum} processingState
 */
PhotoSequence.prototype['processingState'] = undefined;

/**
 * Input only. Raw GPS measurements with increasing timestamps from the device that aren't time synced with each photo. These raw measurements will be used to infer the pose of each frame. Required in input when InputType is VIDEO and raw GPS measurements are not in Camera Motion Metadata Track (CAMM). User can indicate which takes precedence using gps_source if raw GPS measurements are provided in both raw_gps_timeline and Camera Motion Metadata Track (CAMM).
 * @member {Array.<module:model/Pose>} rawGpsTimeline
 */
PhotoSequence.prototype['rawGpsTimeline'] = undefined;

/**
 * @member {module:model/LatLngBounds} sequenceBounds
 */
PhotoSequence.prototype['sequenceBounds'] = undefined;

/**
 * @member {module:model/UploadRef} uploadReference
 */
PhotoSequence.prototype['uploadReference'] = undefined;

/**
 * Output only. The time this photo sequence was created in uSV Store service.
 * @member {String} uploadTime
 */
PhotoSequence.prototype['uploadTime'] = undefined;

/**
 * Output only. The total number of views that all the published images in this PhotoSequence have received.
 * @member {String} viewCount
 */
PhotoSequence.prototype['viewCount'] = undefined;





/**
 * Allowed values for the <code>failureReason</code> property.
 * @enum {String}
 * @readonly
 */
PhotoSequence['FailureReasonEnum'] = {

    /**
     * value: "PROCESSING_FAILURE_REASON_UNSPECIFIED"
     * @const
     */
    "PROCESSING_FAILURE_REASON_UNSPECIFIED": "PROCESSING_FAILURE_REASON_UNSPECIFIED",

    /**
     * value: "LOW_RESOLUTION"
     * @const
     */
    "LOW_RESOLUTION": "LOW_RESOLUTION",

    /**
     * value: "DUPLICATE"
     * @const
     */
    "DUPLICATE": "DUPLICATE",

    /**
     * value: "INSUFFICIENT_GPS"
     * @const
     */
    "INSUFFICIENT_GPS": "INSUFFICIENT_GPS",

    /**
     * value: "NO_OVERLAP_GPS"
     * @const
     */
    "NO_OVERLAP_GPS": "NO_OVERLAP_GPS",

    /**
     * value: "INVALID_GPS"
     * @const
     */
    "INVALID_GPS": "INVALID_GPS",

    /**
     * value: "FAILED_TO_REFINE_POSITIONS"
     * @const
     */
    "FAILED_TO_REFINE_POSITIONS": "FAILED_TO_REFINE_POSITIONS",

    /**
     * value: "TAKEDOWN"
     * @const
     */
    "TAKEDOWN": "TAKEDOWN",

    /**
     * value: "CORRUPT_VIDEO"
     * @const
     */
    "CORRUPT_VIDEO": "CORRUPT_VIDEO",

    /**
     * value: "INTERNAL"
     * @const
     */
    "INTERNAL": "INTERNAL",

    /**
     * value: "INVALID_VIDEO_FORMAT"
     * @const
     */
    "INVALID_VIDEO_FORMAT": "INVALID_VIDEO_FORMAT",

    /**
     * value: "INVALID_VIDEO_DIMENSIONS"
     * @const
     */
    "INVALID_VIDEO_DIMENSIONS": "INVALID_VIDEO_DIMENSIONS",

    /**
     * value: "INVALID_CAPTURE_TIME"
     * @const
     */
    "INVALID_CAPTURE_TIME": "INVALID_CAPTURE_TIME",

    /**
     * value: "GPS_DATA_GAP"
     * @const
     */
    "GPS_DATA_GAP": "GPS_DATA_GAP",

    /**
     * value: "JUMPY_GPS"
     * @const
     */
    "JUMPY_GPS": "JUMPY_GPS",

    /**
     * value: "INVALID_IMU"
     * @const
     */
    "INVALID_IMU": "INVALID_IMU",

    /**
     * value: "INSUFFICIENT_IMU"
     * @const
     */
    "INSUFFICIENT_IMU": "INSUFFICIENT_IMU",

    /**
     * value: "INSUFFICIENT_OVERLAP_TIME_SERIES"
     * @const
     */
    "INSUFFICIENT_OVERLAP_TIME_SERIES": "INSUFFICIENT_OVERLAP_TIME_SERIES",

    /**
     * value: "IMU_DATA_GAP"
     * @const
     */
    "IMU_DATA_GAP": "IMU_DATA_GAP",

    /**
     * value: "UNSUPPORTED_CAMERA"
     * @const
     */
    "UNSUPPORTED_CAMERA": "UNSUPPORTED_CAMERA",

    /**
     * value: "NOT_OUTDOORS"
     * @const
     */
    "NOT_OUTDOORS": "NOT_OUTDOORS",

    /**
     * value: "INSUFFICIENT_VIDEO_FRAMES"
     * @const
     */
    "INSUFFICIENT_VIDEO_FRAMES": "INSUFFICIENT_VIDEO_FRAMES",

    /**
     * value: "INSUFFICIENT_MOVEMENT"
     * @const
     */
    "INSUFFICIENT_MOVEMENT": "INSUFFICIENT_MOVEMENT",

    /**
     * value: "MAST_DOWN"
     * @const
     */
    "MAST_DOWN": "MAST_DOWN",

    /**
     * value: "CAMERA_COVERED"
     * @const
     */
    "CAMERA_COVERED": "CAMERA_COVERED"
};


/**
 * Allowed values for the <code>gpsSource</code> property.
 * @enum {String}
 * @readonly
 */
PhotoSequence['GpsSourceEnum'] = {

    /**
     * value: "PHOTO_SEQUENCE"
     * @const
     */
    "PHOTO_SEQUENCE": "PHOTO_SEQUENCE",

    /**
     * value: "CAMERA_MOTION_METADATA_TRACK"
     * @const
     */
    "CAMERA_MOTION_METADATA_TRACK": "CAMERA_MOTION_METADATA_TRACK"
};


/**
 * Allowed values for the <code>processingState</code> property.
 * @enum {String}
 * @readonly
 */
PhotoSequence['ProcessingStateEnum'] = {

    /**
     * value: "PROCESSING_STATE_UNSPECIFIED"
     * @const
     */
    "PROCESSING_STATE_UNSPECIFIED": "PROCESSING_STATE_UNSPECIFIED",

    /**
     * value: "PENDING"
     * @const
     */
    "PENDING": "PENDING",

    /**
     * value: "PROCESSING"
     * @const
     */
    "PROCESSING": "PROCESSING",

    /**
     * value: "PROCESSED"
     * @const
     */
    "PROCESSED": "PROCESSED",

    /**
     * value: "FAILED"
     * @const
     */
    "FAILED": "FAILED"
};



export default PhotoSequence;

