/**
 * Street View Publish API
 * Publishes 360 photos to Google Maps, along with position, orientation, and connectivity metadata. Apps can offer an interface for positioning, connecting, and uploading user-generated Street View images. 
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPose.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPose::OAIPose(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPose::OAIPose() {
    this->initializeModel();
}

OAIPose::~OAIPose() {}

void OAIPose::initializeModel() {

    m_accuracy_meters_isSet = false;
    m_accuracy_meters_isValid = false;

    m_altitude_isSet = false;
    m_altitude_isValid = false;

    m_gps_record_timestamp_unix_epoch_isSet = false;
    m_gps_record_timestamp_unix_epoch_isValid = false;

    m_heading_isSet = false;
    m_heading_isValid = false;

    m_lat_lng_pair_isSet = false;
    m_lat_lng_pair_isValid = false;

    m_level_isSet = false;
    m_level_isValid = false;

    m_pitch_isSet = false;
    m_pitch_isValid = false;

    m_roll_isSet = false;
    m_roll_isValid = false;
}

void OAIPose::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPose::fromJsonObject(QJsonObject json) {

    m_accuracy_meters_isValid = ::OpenAPI::fromJsonValue(m_accuracy_meters, json[QString("accuracyMeters")]);
    m_accuracy_meters_isSet = !json[QString("accuracyMeters")].isNull() && m_accuracy_meters_isValid;

    m_altitude_isValid = ::OpenAPI::fromJsonValue(m_altitude, json[QString("altitude")]);
    m_altitude_isSet = !json[QString("altitude")].isNull() && m_altitude_isValid;

    m_gps_record_timestamp_unix_epoch_isValid = ::OpenAPI::fromJsonValue(m_gps_record_timestamp_unix_epoch, json[QString("gpsRecordTimestampUnixEpoch")]);
    m_gps_record_timestamp_unix_epoch_isSet = !json[QString("gpsRecordTimestampUnixEpoch")].isNull() && m_gps_record_timestamp_unix_epoch_isValid;

    m_heading_isValid = ::OpenAPI::fromJsonValue(m_heading, json[QString("heading")]);
    m_heading_isSet = !json[QString("heading")].isNull() && m_heading_isValid;

    m_lat_lng_pair_isValid = ::OpenAPI::fromJsonValue(m_lat_lng_pair, json[QString("latLngPair")]);
    m_lat_lng_pair_isSet = !json[QString("latLngPair")].isNull() && m_lat_lng_pair_isValid;

    m_level_isValid = ::OpenAPI::fromJsonValue(m_level, json[QString("level")]);
    m_level_isSet = !json[QString("level")].isNull() && m_level_isValid;

    m_pitch_isValid = ::OpenAPI::fromJsonValue(m_pitch, json[QString("pitch")]);
    m_pitch_isSet = !json[QString("pitch")].isNull() && m_pitch_isValid;

    m_roll_isValid = ::OpenAPI::fromJsonValue(m_roll, json[QString("roll")]);
    m_roll_isSet = !json[QString("roll")].isNull() && m_roll_isValid;
}

QString OAIPose::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPose::asJsonObject() const {
    QJsonObject obj;
    if (m_accuracy_meters_isSet) {
        obj.insert(QString("accuracyMeters"), ::OpenAPI::toJsonValue(m_accuracy_meters));
    }
    if (m_altitude_isSet) {
        obj.insert(QString("altitude"), ::OpenAPI::toJsonValue(m_altitude));
    }
    if (m_gps_record_timestamp_unix_epoch_isSet) {
        obj.insert(QString("gpsRecordTimestampUnixEpoch"), ::OpenAPI::toJsonValue(m_gps_record_timestamp_unix_epoch));
    }
    if (m_heading_isSet) {
        obj.insert(QString("heading"), ::OpenAPI::toJsonValue(m_heading));
    }
    if (m_lat_lng_pair.isSet()) {
        obj.insert(QString("latLngPair"), ::OpenAPI::toJsonValue(m_lat_lng_pair));
    }
    if (m_level.isSet()) {
        obj.insert(QString("level"), ::OpenAPI::toJsonValue(m_level));
    }
    if (m_pitch_isSet) {
        obj.insert(QString("pitch"), ::OpenAPI::toJsonValue(m_pitch));
    }
    if (m_roll_isSet) {
        obj.insert(QString("roll"), ::OpenAPI::toJsonValue(m_roll));
    }
    return obj;
}

float OAIPose::getAccuracyMeters() const {
    return m_accuracy_meters;
}
void OAIPose::setAccuracyMeters(const float &accuracy_meters) {
    m_accuracy_meters = accuracy_meters;
    m_accuracy_meters_isSet = true;
}

bool OAIPose::is_accuracy_meters_Set() const{
    return m_accuracy_meters_isSet;
}

bool OAIPose::is_accuracy_meters_Valid() const{
    return m_accuracy_meters_isValid;
}

double OAIPose::getAltitude() const {
    return m_altitude;
}
void OAIPose::setAltitude(const double &altitude) {
    m_altitude = altitude;
    m_altitude_isSet = true;
}

bool OAIPose::is_altitude_Set() const{
    return m_altitude_isSet;
}

bool OAIPose::is_altitude_Valid() const{
    return m_altitude_isValid;
}

QString OAIPose::getGpsRecordTimestampUnixEpoch() const {
    return m_gps_record_timestamp_unix_epoch;
}
void OAIPose::setGpsRecordTimestampUnixEpoch(const QString &gps_record_timestamp_unix_epoch) {
    m_gps_record_timestamp_unix_epoch = gps_record_timestamp_unix_epoch;
    m_gps_record_timestamp_unix_epoch_isSet = true;
}

bool OAIPose::is_gps_record_timestamp_unix_epoch_Set() const{
    return m_gps_record_timestamp_unix_epoch_isSet;
}

bool OAIPose::is_gps_record_timestamp_unix_epoch_Valid() const{
    return m_gps_record_timestamp_unix_epoch_isValid;
}

double OAIPose::getHeading() const {
    return m_heading;
}
void OAIPose::setHeading(const double &heading) {
    m_heading = heading;
    m_heading_isSet = true;
}

bool OAIPose::is_heading_Set() const{
    return m_heading_isSet;
}

bool OAIPose::is_heading_Valid() const{
    return m_heading_isValid;
}

OAILatLng OAIPose::getLatLngPair() const {
    return m_lat_lng_pair;
}
void OAIPose::setLatLngPair(const OAILatLng &lat_lng_pair) {
    m_lat_lng_pair = lat_lng_pair;
    m_lat_lng_pair_isSet = true;
}

bool OAIPose::is_lat_lng_pair_Set() const{
    return m_lat_lng_pair_isSet;
}

bool OAIPose::is_lat_lng_pair_Valid() const{
    return m_lat_lng_pair_isValid;
}

OAILevel OAIPose::getLevel() const {
    return m_level;
}
void OAIPose::setLevel(const OAILevel &level) {
    m_level = level;
    m_level_isSet = true;
}

bool OAIPose::is_level_Set() const{
    return m_level_isSet;
}

bool OAIPose::is_level_Valid() const{
    return m_level_isValid;
}

double OAIPose::getPitch() const {
    return m_pitch;
}
void OAIPose::setPitch(const double &pitch) {
    m_pitch = pitch;
    m_pitch_isSet = true;
}

bool OAIPose::is_pitch_Set() const{
    return m_pitch_isSet;
}

bool OAIPose::is_pitch_Valid() const{
    return m_pitch_isValid;
}

double OAIPose::getRoll() const {
    return m_roll;
}
void OAIPose::setRoll(const double &roll) {
    m_roll = roll;
    m_roll_isSet = true;
}

bool OAIPose::is_roll_Set() const{
    return m_roll_isSet;
}

bool OAIPose::is_roll_Valid() const{
    return m_roll_isValid;
}

bool OAIPose::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_accuracy_meters_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_altitude_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gps_record_timestamp_unix_epoch_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_heading_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_lat_lng_pair.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_level.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_pitch_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_roll_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPose::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
