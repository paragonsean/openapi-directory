/**
 * Street View Publish API
 * Publishes 360 photos to Google Maps, along with position, orientation, and connectivity metadata. Apps can offer an interface for positioning, connecting, and uploading user-generated Street View images. 
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIPhotoSequence.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIPhotoSequence::OAIPhotoSequence(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIPhotoSequence::OAIPhotoSequence() {
    this->initializeModel();
}

OAIPhotoSequence::~OAIPhotoSequence() {}

void OAIPhotoSequence::initializeModel() {

    m_capture_time_override_isSet = false;
    m_capture_time_override_isValid = false;

    m_distance_meters_isSet = false;
    m_distance_meters_isValid = false;

    m_failure_details_isSet = false;
    m_failure_details_isValid = false;

    m_failure_reason_isSet = false;
    m_failure_reason_isValid = false;

    m_filename_isSet = false;
    m_filename_isValid = false;

    m_gps_source_isSet = false;
    m_gps_source_isValid = false;

    m_id_isSet = false;
    m_id_isValid = false;

    m_imu_isSet = false;
    m_imu_isValid = false;

    m_photos_isSet = false;
    m_photos_isValid = false;

    m_processing_state_isSet = false;
    m_processing_state_isValid = false;

    m_raw_gps_timeline_isSet = false;
    m_raw_gps_timeline_isValid = false;

    m_sequence_bounds_isSet = false;
    m_sequence_bounds_isValid = false;

    m_upload_reference_isSet = false;
    m_upload_reference_isValid = false;

    m_upload_time_isSet = false;
    m_upload_time_isValid = false;

    m_view_count_isSet = false;
    m_view_count_isValid = false;
}

void OAIPhotoSequence::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIPhotoSequence::fromJsonObject(QJsonObject json) {

    m_capture_time_override_isValid = ::OpenAPI::fromJsonValue(m_capture_time_override, json[QString("captureTimeOverride")]);
    m_capture_time_override_isSet = !json[QString("captureTimeOverride")].isNull() && m_capture_time_override_isValid;

    m_distance_meters_isValid = ::OpenAPI::fromJsonValue(m_distance_meters, json[QString("distanceMeters")]);
    m_distance_meters_isSet = !json[QString("distanceMeters")].isNull() && m_distance_meters_isValid;

    m_failure_details_isValid = ::OpenAPI::fromJsonValue(m_failure_details, json[QString("failureDetails")]);
    m_failure_details_isSet = !json[QString("failureDetails")].isNull() && m_failure_details_isValid;

    m_failure_reason_isValid = ::OpenAPI::fromJsonValue(m_failure_reason, json[QString("failureReason")]);
    m_failure_reason_isSet = !json[QString("failureReason")].isNull() && m_failure_reason_isValid;

    m_filename_isValid = ::OpenAPI::fromJsonValue(m_filename, json[QString("filename")]);
    m_filename_isSet = !json[QString("filename")].isNull() && m_filename_isValid;

    m_gps_source_isValid = ::OpenAPI::fromJsonValue(m_gps_source, json[QString("gpsSource")]);
    m_gps_source_isSet = !json[QString("gpsSource")].isNull() && m_gps_source_isValid;

    m_id_isValid = ::OpenAPI::fromJsonValue(m_id, json[QString("id")]);
    m_id_isSet = !json[QString("id")].isNull() && m_id_isValid;

    m_imu_isValid = ::OpenAPI::fromJsonValue(m_imu, json[QString("imu")]);
    m_imu_isSet = !json[QString("imu")].isNull() && m_imu_isValid;

    m_photos_isValid = ::OpenAPI::fromJsonValue(m_photos, json[QString("photos")]);
    m_photos_isSet = !json[QString("photos")].isNull() && m_photos_isValid;

    m_processing_state_isValid = ::OpenAPI::fromJsonValue(m_processing_state, json[QString("processingState")]);
    m_processing_state_isSet = !json[QString("processingState")].isNull() && m_processing_state_isValid;

    m_raw_gps_timeline_isValid = ::OpenAPI::fromJsonValue(m_raw_gps_timeline, json[QString("rawGpsTimeline")]);
    m_raw_gps_timeline_isSet = !json[QString("rawGpsTimeline")].isNull() && m_raw_gps_timeline_isValid;

    m_sequence_bounds_isValid = ::OpenAPI::fromJsonValue(m_sequence_bounds, json[QString("sequenceBounds")]);
    m_sequence_bounds_isSet = !json[QString("sequenceBounds")].isNull() && m_sequence_bounds_isValid;

    m_upload_reference_isValid = ::OpenAPI::fromJsonValue(m_upload_reference, json[QString("uploadReference")]);
    m_upload_reference_isSet = !json[QString("uploadReference")].isNull() && m_upload_reference_isValid;

    m_upload_time_isValid = ::OpenAPI::fromJsonValue(m_upload_time, json[QString("uploadTime")]);
    m_upload_time_isSet = !json[QString("uploadTime")].isNull() && m_upload_time_isValid;

    m_view_count_isValid = ::OpenAPI::fromJsonValue(m_view_count, json[QString("viewCount")]);
    m_view_count_isSet = !json[QString("viewCount")].isNull() && m_view_count_isValid;
}

QString OAIPhotoSequence::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIPhotoSequence::asJsonObject() const {
    QJsonObject obj;
    if (m_capture_time_override_isSet) {
        obj.insert(QString("captureTimeOverride"), ::OpenAPI::toJsonValue(m_capture_time_override));
    }
    if (m_distance_meters_isSet) {
        obj.insert(QString("distanceMeters"), ::OpenAPI::toJsonValue(m_distance_meters));
    }
    if (m_failure_details.isSet()) {
        obj.insert(QString("failureDetails"), ::OpenAPI::toJsonValue(m_failure_details));
    }
    if (m_failure_reason_isSet) {
        obj.insert(QString("failureReason"), ::OpenAPI::toJsonValue(m_failure_reason));
    }
    if (m_filename_isSet) {
        obj.insert(QString("filename"), ::OpenAPI::toJsonValue(m_filename));
    }
    if (m_gps_source_isSet) {
        obj.insert(QString("gpsSource"), ::OpenAPI::toJsonValue(m_gps_source));
    }
    if (m_id_isSet) {
        obj.insert(QString("id"), ::OpenAPI::toJsonValue(m_id));
    }
    if (m_imu.isSet()) {
        obj.insert(QString("imu"), ::OpenAPI::toJsonValue(m_imu));
    }
    if (m_photos.size() > 0) {
        obj.insert(QString("photos"), ::OpenAPI::toJsonValue(m_photos));
    }
    if (m_processing_state_isSet) {
        obj.insert(QString("processingState"), ::OpenAPI::toJsonValue(m_processing_state));
    }
    if (m_raw_gps_timeline.size() > 0) {
        obj.insert(QString("rawGpsTimeline"), ::OpenAPI::toJsonValue(m_raw_gps_timeline));
    }
    if (m_sequence_bounds.isSet()) {
        obj.insert(QString("sequenceBounds"), ::OpenAPI::toJsonValue(m_sequence_bounds));
    }
    if (m_upload_reference.isSet()) {
        obj.insert(QString("uploadReference"), ::OpenAPI::toJsonValue(m_upload_reference));
    }
    if (m_upload_time_isSet) {
        obj.insert(QString("uploadTime"), ::OpenAPI::toJsonValue(m_upload_time));
    }
    if (m_view_count_isSet) {
        obj.insert(QString("viewCount"), ::OpenAPI::toJsonValue(m_view_count));
    }
    return obj;
}

QString OAIPhotoSequence::getCaptureTimeOverride() const {
    return m_capture_time_override;
}
void OAIPhotoSequence::setCaptureTimeOverride(const QString &capture_time_override) {
    m_capture_time_override = capture_time_override;
    m_capture_time_override_isSet = true;
}

bool OAIPhotoSequence::is_capture_time_override_Set() const{
    return m_capture_time_override_isSet;
}

bool OAIPhotoSequence::is_capture_time_override_Valid() const{
    return m_capture_time_override_isValid;
}

double OAIPhotoSequence::getDistanceMeters() const {
    return m_distance_meters;
}
void OAIPhotoSequence::setDistanceMeters(const double &distance_meters) {
    m_distance_meters = distance_meters;
    m_distance_meters_isSet = true;
}

bool OAIPhotoSequence::is_distance_meters_Set() const{
    return m_distance_meters_isSet;
}

bool OAIPhotoSequence::is_distance_meters_Valid() const{
    return m_distance_meters_isValid;
}

OAIProcessingFailureDetails OAIPhotoSequence::getFailureDetails() const {
    return m_failure_details;
}
void OAIPhotoSequence::setFailureDetails(const OAIProcessingFailureDetails &failure_details) {
    m_failure_details = failure_details;
    m_failure_details_isSet = true;
}

bool OAIPhotoSequence::is_failure_details_Set() const{
    return m_failure_details_isSet;
}

bool OAIPhotoSequence::is_failure_details_Valid() const{
    return m_failure_details_isValid;
}

QString OAIPhotoSequence::getFailureReason() const {
    return m_failure_reason;
}
void OAIPhotoSequence::setFailureReason(const QString &failure_reason) {
    m_failure_reason = failure_reason;
    m_failure_reason_isSet = true;
}

bool OAIPhotoSequence::is_failure_reason_Set() const{
    return m_failure_reason_isSet;
}

bool OAIPhotoSequence::is_failure_reason_Valid() const{
    return m_failure_reason_isValid;
}

QString OAIPhotoSequence::getFilename() const {
    return m_filename;
}
void OAIPhotoSequence::setFilename(const QString &filename) {
    m_filename = filename;
    m_filename_isSet = true;
}

bool OAIPhotoSequence::is_filename_Set() const{
    return m_filename_isSet;
}

bool OAIPhotoSequence::is_filename_Valid() const{
    return m_filename_isValid;
}

QString OAIPhotoSequence::getGpsSource() const {
    return m_gps_source;
}
void OAIPhotoSequence::setGpsSource(const QString &gps_source) {
    m_gps_source = gps_source;
    m_gps_source_isSet = true;
}

bool OAIPhotoSequence::is_gps_source_Set() const{
    return m_gps_source_isSet;
}

bool OAIPhotoSequence::is_gps_source_Valid() const{
    return m_gps_source_isValid;
}

QString OAIPhotoSequence::getId() const {
    return m_id;
}
void OAIPhotoSequence::setId(const QString &id) {
    m_id = id;
    m_id_isSet = true;
}

bool OAIPhotoSequence::is_id_Set() const{
    return m_id_isSet;
}

bool OAIPhotoSequence::is_id_Valid() const{
    return m_id_isValid;
}

OAIImu OAIPhotoSequence::getImu() const {
    return m_imu;
}
void OAIPhotoSequence::setImu(const OAIImu &imu) {
    m_imu = imu;
    m_imu_isSet = true;
}

bool OAIPhotoSequence::is_imu_Set() const{
    return m_imu_isSet;
}

bool OAIPhotoSequence::is_imu_Valid() const{
    return m_imu_isValid;
}

QList<OAIPhoto> OAIPhotoSequence::getPhotos() const {
    return m_photos;
}
void OAIPhotoSequence::setPhotos(const QList<OAIPhoto> &photos) {
    m_photos = photos;
    m_photos_isSet = true;
}

bool OAIPhotoSequence::is_photos_Set() const{
    return m_photos_isSet;
}

bool OAIPhotoSequence::is_photos_Valid() const{
    return m_photos_isValid;
}

QString OAIPhotoSequence::getProcessingState() const {
    return m_processing_state;
}
void OAIPhotoSequence::setProcessingState(const QString &processing_state) {
    m_processing_state = processing_state;
    m_processing_state_isSet = true;
}

bool OAIPhotoSequence::is_processing_state_Set() const{
    return m_processing_state_isSet;
}

bool OAIPhotoSequence::is_processing_state_Valid() const{
    return m_processing_state_isValid;
}

QList<OAIPose> OAIPhotoSequence::getRawGpsTimeline() const {
    return m_raw_gps_timeline;
}
void OAIPhotoSequence::setRawGpsTimeline(const QList<OAIPose> &raw_gps_timeline) {
    m_raw_gps_timeline = raw_gps_timeline;
    m_raw_gps_timeline_isSet = true;
}

bool OAIPhotoSequence::is_raw_gps_timeline_Set() const{
    return m_raw_gps_timeline_isSet;
}

bool OAIPhotoSequence::is_raw_gps_timeline_Valid() const{
    return m_raw_gps_timeline_isValid;
}

OAILatLngBounds OAIPhotoSequence::getSequenceBounds() const {
    return m_sequence_bounds;
}
void OAIPhotoSequence::setSequenceBounds(const OAILatLngBounds &sequence_bounds) {
    m_sequence_bounds = sequence_bounds;
    m_sequence_bounds_isSet = true;
}

bool OAIPhotoSequence::is_sequence_bounds_Set() const{
    return m_sequence_bounds_isSet;
}

bool OAIPhotoSequence::is_sequence_bounds_Valid() const{
    return m_sequence_bounds_isValid;
}

OAIUploadRef OAIPhotoSequence::getUploadReference() const {
    return m_upload_reference;
}
void OAIPhotoSequence::setUploadReference(const OAIUploadRef &upload_reference) {
    m_upload_reference = upload_reference;
    m_upload_reference_isSet = true;
}

bool OAIPhotoSequence::is_upload_reference_Set() const{
    return m_upload_reference_isSet;
}

bool OAIPhotoSequence::is_upload_reference_Valid() const{
    return m_upload_reference_isValid;
}

QString OAIPhotoSequence::getUploadTime() const {
    return m_upload_time;
}
void OAIPhotoSequence::setUploadTime(const QString &upload_time) {
    m_upload_time = upload_time;
    m_upload_time_isSet = true;
}

bool OAIPhotoSequence::is_upload_time_Set() const{
    return m_upload_time_isSet;
}

bool OAIPhotoSequence::is_upload_time_Valid() const{
    return m_upload_time_isValid;
}

QString OAIPhotoSequence::getViewCount() const {
    return m_view_count;
}
void OAIPhotoSequence::setViewCount(const QString &view_count) {
    m_view_count = view_count;
    m_view_count_isSet = true;
}

bool OAIPhotoSequence::is_view_count_Set() const{
    return m_view_count_isSet;
}

bool OAIPhotoSequence::is_view_count_Valid() const{
    return m_view_count_isValid;
}

bool OAIPhotoSequence::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (m_capture_time_override_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_distance_meters_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_failure_details.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_failure_reason_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_filename_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_gps_source_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_id_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_imu.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_photos.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_processing_state_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_raw_gps_timeline.size() > 0) {
            isObjectUpdated = true;
            break;
        }

        if (m_sequence_bounds.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_upload_reference.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_upload_time_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_view_count_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIPhotoSequence::isValid() const {
    // only required properties are required for the object to be considered valid
    return true;
}

} // namespace OpenAPI
