/*
 * Street View Publish API
 * Publishes 360 photos to Google Maps, along with position, orientation, and connectivity metadata. Apps can offer an interface for positioning, connecting, and uploading user-generated Street View images. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.Imu;
import org.openapitools.client.model.LatLngBounds;
import org.openapitools.client.model.Photo;
import org.openapitools.client.model.Pose;
import org.openapitools.client.model.ProcessingFailureDetails;
import org.openapitools.client.model.UploadRef;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A sequence of 360 photos along with metadata.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:41.091890-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class PhotoSequence {
  public static final String SERIALIZED_NAME_CAPTURE_TIME_OVERRIDE = "captureTimeOverride";
  @SerializedName(SERIALIZED_NAME_CAPTURE_TIME_OVERRIDE)
  private String captureTimeOverride;

  public static final String SERIALIZED_NAME_DISTANCE_METERS = "distanceMeters";
  @SerializedName(SERIALIZED_NAME_DISTANCE_METERS)
  private Double distanceMeters;

  public static final String SERIALIZED_NAME_FAILURE_DETAILS = "failureDetails";
  @SerializedName(SERIALIZED_NAME_FAILURE_DETAILS)
  private ProcessingFailureDetails failureDetails;

  /**
   * Output only. If this sequence has processing_state &#x3D; FAILED, this will contain the reason why it failed. If the processing_state is any other value, this field will be unset.
   */
  @JsonAdapter(FailureReasonEnum.Adapter.class)
  public enum FailureReasonEnum {
    PROCESSING_FAILURE_REASON_UNSPECIFIED("PROCESSING_FAILURE_REASON_UNSPECIFIED"),
    
    LOW_RESOLUTION("LOW_RESOLUTION"),
    
    DUPLICATE("DUPLICATE"),
    
    INSUFFICIENT_GPS("INSUFFICIENT_GPS"),
    
    NO_OVERLAP_GPS("NO_OVERLAP_GPS"),
    
    INVALID_GPS("INVALID_GPS"),
    
    FAILED_TO_REFINE_POSITIONS("FAILED_TO_REFINE_POSITIONS"),
    
    TAKEDOWN("TAKEDOWN"),
    
    CORRUPT_VIDEO("CORRUPT_VIDEO"),
    
    INTERNAL("INTERNAL"),
    
    INVALID_VIDEO_FORMAT("INVALID_VIDEO_FORMAT"),
    
    INVALID_VIDEO_DIMENSIONS("INVALID_VIDEO_DIMENSIONS"),
    
    INVALID_CAPTURE_TIME("INVALID_CAPTURE_TIME"),
    
    GPS_DATA_GAP("GPS_DATA_GAP"),
    
    JUMPY_GPS("JUMPY_GPS"),
    
    INVALID_IMU("INVALID_IMU"),
    
    INSUFFICIENT_IMU("INSUFFICIENT_IMU"),
    
    INSUFFICIENT_OVERLAP_TIME_SERIES("INSUFFICIENT_OVERLAP_TIME_SERIES"),
    
    IMU_DATA_GAP("IMU_DATA_GAP"),
    
    UNSUPPORTED_CAMERA("UNSUPPORTED_CAMERA"),
    
    NOT_OUTDOORS("NOT_OUTDOORS"),
    
    INSUFFICIENT_VIDEO_FRAMES("INSUFFICIENT_VIDEO_FRAMES"),
    
    INSUFFICIENT_MOVEMENT("INSUFFICIENT_MOVEMENT"),
    
    MAST_DOWN("MAST_DOWN"),
    
    CAMERA_COVERED("CAMERA_COVERED");

    private String value;

    FailureReasonEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FailureReasonEnum fromValue(String value) {
      for (FailureReasonEnum b : FailureReasonEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FailureReasonEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FailureReasonEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FailureReasonEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FailureReasonEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FailureReasonEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FAILURE_REASON = "failureReason";
  @SerializedName(SERIALIZED_NAME_FAILURE_REASON)
  private FailureReasonEnum failureReason;

  public static final String SERIALIZED_NAME_FILENAME = "filename";
  @SerializedName(SERIALIZED_NAME_FILENAME)
  private String filename;

  /**
   * Input only. If both raw_gps_timeline and the Camera Motion Metadata Track (CAMM) contain GPS measurements, indicate which takes precedence.
   */
  @JsonAdapter(GpsSourceEnum.Adapter.class)
  public enum GpsSourceEnum {
    PHOTO_SEQUENCE("PHOTO_SEQUENCE"),
    
    CAMERA_MOTION_METADATA_TRACK("CAMERA_MOTION_METADATA_TRACK");

    private String value;

    GpsSourceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static GpsSourceEnum fromValue(String value) {
      for (GpsSourceEnum b : GpsSourceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<GpsSourceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final GpsSourceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public GpsSourceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return GpsSourceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      GpsSourceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_GPS_SOURCE = "gpsSource";
  @SerializedName(SERIALIZED_NAME_GPS_SOURCE)
  private GpsSourceEnum gpsSource;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_IMU = "imu";
  @SerializedName(SERIALIZED_NAME_IMU)
  private Imu imu;

  public static final String SERIALIZED_NAME_PHOTOS = "photos";
  @SerializedName(SERIALIZED_NAME_PHOTOS)
  private List<Photo> photos = new ArrayList<>();

  /**
   * Output only. The processing state of this sequence.
   */
  @JsonAdapter(ProcessingStateEnum.Adapter.class)
  public enum ProcessingStateEnum {
    PROCESSING_STATE_UNSPECIFIED("PROCESSING_STATE_UNSPECIFIED"),
    
    PENDING("PENDING"),
    
    PROCESSING("PROCESSING"),
    
    PROCESSED("PROCESSED"),
    
    FAILED("FAILED");

    private String value;

    ProcessingStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProcessingStateEnum fromValue(String value) {
      for (ProcessingStateEnum b : ProcessingStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProcessingStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProcessingStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProcessingStateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProcessingStateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProcessingStateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PROCESSING_STATE = "processingState";
  @SerializedName(SERIALIZED_NAME_PROCESSING_STATE)
  private ProcessingStateEnum processingState;

  public static final String SERIALIZED_NAME_RAW_GPS_TIMELINE = "rawGpsTimeline";
  @SerializedName(SERIALIZED_NAME_RAW_GPS_TIMELINE)
  private List<Pose> rawGpsTimeline = new ArrayList<>();

  public static final String SERIALIZED_NAME_SEQUENCE_BOUNDS = "sequenceBounds";
  @SerializedName(SERIALIZED_NAME_SEQUENCE_BOUNDS)
  private LatLngBounds sequenceBounds;

  public static final String SERIALIZED_NAME_UPLOAD_REFERENCE = "uploadReference";
  @SerializedName(SERIALIZED_NAME_UPLOAD_REFERENCE)
  private UploadRef uploadReference;

  public static final String SERIALIZED_NAME_UPLOAD_TIME = "uploadTime";
  @SerializedName(SERIALIZED_NAME_UPLOAD_TIME)
  private String uploadTime;

  public static final String SERIALIZED_NAME_VIEW_COUNT = "viewCount";
  @SerializedName(SERIALIZED_NAME_VIEW_COUNT)
  private String viewCount;

  public PhotoSequence() {
  }

  public PhotoSequence(
     Double distanceMeters, 
     FailureReasonEnum failureReason, 
     String filename, 
     String id, 
     List<Photo> photos, 
     ProcessingStateEnum processingState, 
     String uploadTime, 
     String viewCount
  ) {
    this();
    this.distanceMeters = distanceMeters;
    this.failureReason = failureReason;
    this.filename = filename;
    this.id = id;
    this.photos = photos;
    this.processingState = processingState;
    this.uploadTime = uploadTime;
    this.viewCount = viewCount;
  }

  public PhotoSequence captureTimeOverride(String captureTimeOverride) {
    this.captureTimeOverride = captureTimeOverride;
    return this;
  }

  /**
   * Optional. Absolute time when the photo sequence starts to be captured. If the photo sequence is a video, this is the start time of the video. If this field is populated in input, it overrides the capture time in the video or XDM file.
   * @return captureTimeOverride
   */
  @javax.annotation.Nullable
  public String getCaptureTimeOverride() {
    return captureTimeOverride;
  }

  public void setCaptureTimeOverride(String captureTimeOverride) {
    this.captureTimeOverride = captureTimeOverride;
  }


  /**
   * Output only. The computed distance of the photo sequence in meters.
   * @return distanceMeters
   */
  @javax.annotation.Nullable
  public Double getDistanceMeters() {
    return distanceMeters;
  }



  public PhotoSequence failureDetails(ProcessingFailureDetails failureDetails) {
    this.failureDetails = failureDetails;
    return this;
  }

  /**
   * Get failureDetails
   * @return failureDetails
   */
  @javax.annotation.Nullable
  public ProcessingFailureDetails getFailureDetails() {
    return failureDetails;
  }

  public void setFailureDetails(ProcessingFailureDetails failureDetails) {
    this.failureDetails = failureDetails;
  }


  /**
   * Output only. If this sequence has processing_state &#x3D; FAILED, this will contain the reason why it failed. If the processing_state is any other value, this field will be unset.
   * @return failureReason
   */
  @javax.annotation.Nullable
  public FailureReasonEnum getFailureReason() {
    return failureReason;
  }



  /**
   * Output only. The filename of the upload. Does not include the directory path. Only available if the sequence was uploaded on a platform that provides the filename.
   * @return filename
   */
  @javax.annotation.Nullable
  public String getFilename() {
    return filename;
  }



  public PhotoSequence gpsSource(GpsSourceEnum gpsSource) {
    this.gpsSource = gpsSource;
    return this;
  }

  /**
   * Input only. If both raw_gps_timeline and the Camera Motion Metadata Track (CAMM) contain GPS measurements, indicate which takes precedence.
   * @return gpsSource
   */
  @javax.annotation.Nullable
  public GpsSourceEnum getGpsSource() {
    return gpsSource;
  }

  public void setGpsSource(GpsSourceEnum gpsSource) {
    this.gpsSource = gpsSource;
  }


  /**
   * Output only. Unique identifier for the photo sequence. This also acts as a long running operation ID if uploading is performed asynchronously.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public PhotoSequence imu(Imu imu) {
    this.imu = imu;
    return this;
  }

  /**
   * Get imu
   * @return imu
   */
  @javax.annotation.Nullable
  public Imu getImu() {
    return imu;
  }

  public void setImu(Imu imu) {
    this.imu = imu;
  }


  /**
   * Output only. Photos with increasing timestamps.
   * @return photos
   */
  @javax.annotation.Nullable
  public List<Photo> getPhotos() {
    return photos;
  }



  /**
   * Output only. The processing state of this sequence.
   * @return processingState
   */
  @javax.annotation.Nullable
  public ProcessingStateEnum getProcessingState() {
    return processingState;
  }



  public PhotoSequence rawGpsTimeline(List<Pose> rawGpsTimeline) {
    this.rawGpsTimeline = rawGpsTimeline;
    return this;
  }

  public PhotoSequence addRawGpsTimelineItem(Pose rawGpsTimelineItem) {
    if (this.rawGpsTimeline == null) {
      this.rawGpsTimeline = new ArrayList<>();
    }
    this.rawGpsTimeline.add(rawGpsTimelineItem);
    return this;
  }

  /**
   * Input only. Raw GPS measurements with increasing timestamps from the device that aren&#39;t time synced with each photo. These raw measurements will be used to infer the pose of each frame. Required in input when InputType is VIDEO and raw GPS measurements are not in Camera Motion Metadata Track (CAMM). User can indicate which takes precedence using gps_source if raw GPS measurements are provided in both raw_gps_timeline and Camera Motion Metadata Track (CAMM).
   * @return rawGpsTimeline
   */
  @javax.annotation.Nullable
  public List<Pose> getRawGpsTimeline() {
    return rawGpsTimeline;
  }

  public void setRawGpsTimeline(List<Pose> rawGpsTimeline) {
    this.rawGpsTimeline = rawGpsTimeline;
  }


  public PhotoSequence sequenceBounds(LatLngBounds sequenceBounds) {
    this.sequenceBounds = sequenceBounds;
    return this;
  }

  /**
   * Get sequenceBounds
   * @return sequenceBounds
   */
  @javax.annotation.Nullable
  public LatLngBounds getSequenceBounds() {
    return sequenceBounds;
  }

  public void setSequenceBounds(LatLngBounds sequenceBounds) {
    this.sequenceBounds = sequenceBounds;
  }


  public PhotoSequence uploadReference(UploadRef uploadReference) {
    this.uploadReference = uploadReference;
    return this;
  }

  /**
   * Get uploadReference
   * @return uploadReference
   */
  @javax.annotation.Nullable
  public UploadRef getUploadReference() {
    return uploadReference;
  }

  public void setUploadReference(UploadRef uploadReference) {
    this.uploadReference = uploadReference;
  }


  /**
   * Output only. The time this photo sequence was created in uSV Store service.
   * @return uploadTime
   */
  @javax.annotation.Nullable
  public String getUploadTime() {
    return uploadTime;
  }



  /**
   * Output only. The total number of views that all the published images in this PhotoSequence have received.
   * @return viewCount
   */
  @javax.annotation.Nullable
  public String getViewCount() {
    return viewCount;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PhotoSequence photoSequence = (PhotoSequence) o;
    return Objects.equals(this.captureTimeOverride, photoSequence.captureTimeOverride) &&
        Objects.equals(this.distanceMeters, photoSequence.distanceMeters) &&
        Objects.equals(this.failureDetails, photoSequence.failureDetails) &&
        Objects.equals(this.failureReason, photoSequence.failureReason) &&
        Objects.equals(this.filename, photoSequence.filename) &&
        Objects.equals(this.gpsSource, photoSequence.gpsSource) &&
        Objects.equals(this.id, photoSequence.id) &&
        Objects.equals(this.imu, photoSequence.imu) &&
        Objects.equals(this.photos, photoSequence.photos) &&
        Objects.equals(this.processingState, photoSequence.processingState) &&
        Objects.equals(this.rawGpsTimeline, photoSequence.rawGpsTimeline) &&
        Objects.equals(this.sequenceBounds, photoSequence.sequenceBounds) &&
        Objects.equals(this.uploadReference, photoSequence.uploadReference) &&
        Objects.equals(this.uploadTime, photoSequence.uploadTime) &&
        Objects.equals(this.viewCount, photoSequence.viewCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(captureTimeOverride, distanceMeters, failureDetails, failureReason, filename, gpsSource, id, imu, photos, processingState, rawGpsTimeline, sequenceBounds, uploadReference, uploadTime, viewCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PhotoSequence {\n");
    sb.append("    captureTimeOverride: ").append(toIndentedString(captureTimeOverride)).append("\n");
    sb.append("    distanceMeters: ").append(toIndentedString(distanceMeters)).append("\n");
    sb.append("    failureDetails: ").append(toIndentedString(failureDetails)).append("\n");
    sb.append("    failureReason: ").append(toIndentedString(failureReason)).append("\n");
    sb.append("    filename: ").append(toIndentedString(filename)).append("\n");
    sb.append("    gpsSource: ").append(toIndentedString(gpsSource)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    imu: ").append(toIndentedString(imu)).append("\n");
    sb.append("    photos: ").append(toIndentedString(photos)).append("\n");
    sb.append("    processingState: ").append(toIndentedString(processingState)).append("\n");
    sb.append("    rawGpsTimeline: ").append(toIndentedString(rawGpsTimeline)).append("\n");
    sb.append("    sequenceBounds: ").append(toIndentedString(sequenceBounds)).append("\n");
    sb.append("    uploadReference: ").append(toIndentedString(uploadReference)).append("\n");
    sb.append("    uploadTime: ").append(toIndentedString(uploadTime)).append("\n");
    sb.append("    viewCount: ").append(toIndentedString(viewCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("captureTimeOverride");
    openapiFields.add("distanceMeters");
    openapiFields.add("failureDetails");
    openapiFields.add("failureReason");
    openapiFields.add("filename");
    openapiFields.add("gpsSource");
    openapiFields.add("id");
    openapiFields.add("imu");
    openapiFields.add("photos");
    openapiFields.add("processingState");
    openapiFields.add("rawGpsTimeline");
    openapiFields.add("sequenceBounds");
    openapiFields.add("uploadReference");
    openapiFields.add("uploadTime");
    openapiFields.add("viewCount");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PhotoSequence
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PhotoSequence.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PhotoSequence is not found in the empty JSON string", PhotoSequence.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PhotoSequence.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PhotoSequence` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("captureTimeOverride") != null && !jsonObj.get("captureTimeOverride").isJsonNull()) && !jsonObj.get("captureTimeOverride").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `captureTimeOverride` to be a primitive type in the JSON string but got `%s`", jsonObj.get("captureTimeOverride").toString()));
      }
      // validate the optional field `failureDetails`
      if (jsonObj.get("failureDetails") != null && !jsonObj.get("failureDetails").isJsonNull()) {
        ProcessingFailureDetails.validateJsonElement(jsonObj.get("failureDetails"));
      }
      if ((jsonObj.get("failureReason") != null && !jsonObj.get("failureReason").isJsonNull()) && !jsonObj.get("failureReason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `failureReason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("failureReason").toString()));
      }
      // validate the optional field `failureReason`
      if (jsonObj.get("failureReason") != null && !jsonObj.get("failureReason").isJsonNull()) {
        FailureReasonEnum.validateJsonElement(jsonObj.get("failureReason"));
      }
      if ((jsonObj.get("filename") != null && !jsonObj.get("filename").isJsonNull()) && !jsonObj.get("filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filename").toString()));
      }
      if ((jsonObj.get("gpsSource") != null && !jsonObj.get("gpsSource").isJsonNull()) && !jsonObj.get("gpsSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `gpsSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("gpsSource").toString()));
      }
      // validate the optional field `gpsSource`
      if (jsonObj.get("gpsSource") != null && !jsonObj.get("gpsSource").isJsonNull()) {
        GpsSourceEnum.validateJsonElement(jsonObj.get("gpsSource"));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `imu`
      if (jsonObj.get("imu") != null && !jsonObj.get("imu").isJsonNull()) {
        Imu.validateJsonElement(jsonObj.get("imu"));
      }
      if (jsonObj.get("photos") != null && !jsonObj.get("photos").isJsonNull()) {
        JsonArray jsonArrayphotos = jsonObj.getAsJsonArray("photos");
        if (jsonArrayphotos != null) {
          // ensure the json data is an array
          if (!jsonObj.get("photos").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `photos` to be an array in the JSON string but got `%s`", jsonObj.get("photos").toString()));
          }

          // validate the optional field `photos` (array)
          for (int i = 0; i < jsonArrayphotos.size(); i++) {
            Photo.validateJsonElement(jsonArrayphotos.get(i));
          };
        }
      }
      if ((jsonObj.get("processingState") != null && !jsonObj.get("processingState").isJsonNull()) && !jsonObj.get("processingState").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `processingState` to be a primitive type in the JSON string but got `%s`", jsonObj.get("processingState").toString()));
      }
      // validate the optional field `processingState`
      if (jsonObj.get("processingState") != null && !jsonObj.get("processingState").isJsonNull()) {
        ProcessingStateEnum.validateJsonElement(jsonObj.get("processingState"));
      }
      if (jsonObj.get("rawGpsTimeline") != null && !jsonObj.get("rawGpsTimeline").isJsonNull()) {
        JsonArray jsonArrayrawGpsTimeline = jsonObj.getAsJsonArray("rawGpsTimeline");
        if (jsonArrayrawGpsTimeline != null) {
          // ensure the json data is an array
          if (!jsonObj.get("rawGpsTimeline").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `rawGpsTimeline` to be an array in the JSON string but got `%s`", jsonObj.get("rawGpsTimeline").toString()));
          }

          // validate the optional field `rawGpsTimeline` (array)
          for (int i = 0; i < jsonArrayrawGpsTimeline.size(); i++) {
            Pose.validateJsonElement(jsonArrayrawGpsTimeline.get(i));
          };
        }
      }
      // validate the optional field `sequenceBounds`
      if (jsonObj.get("sequenceBounds") != null && !jsonObj.get("sequenceBounds").isJsonNull()) {
        LatLngBounds.validateJsonElement(jsonObj.get("sequenceBounds"));
      }
      // validate the optional field `uploadReference`
      if (jsonObj.get("uploadReference") != null && !jsonObj.get("uploadReference").isJsonNull()) {
        UploadRef.validateJsonElement(jsonObj.get("uploadReference"));
      }
      if ((jsonObj.get("uploadTime") != null && !jsonObj.get("uploadTime").isJsonNull()) && !jsonObj.get("uploadTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uploadTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uploadTime").toString()));
      }
      if ((jsonObj.get("viewCount") != null && !jsonObj.get("viewCount").isJsonNull()) && !jsonObj.get("viewCount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `viewCount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("viewCount").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PhotoSequence.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PhotoSequence' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PhotoSequence> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PhotoSequence.class));

       return (TypeAdapter<T>) new TypeAdapter<PhotoSequence>() {
           @Override
           public void write(JsonWriter out, PhotoSequence value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PhotoSequence read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PhotoSequence given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PhotoSequence
   * @throws IOException if the JSON string is invalid with respect to PhotoSequence
   */
  public static PhotoSequence fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PhotoSequence.class);
  }

  /**
   * Convert an instance of PhotoSequence to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

