/*
 * Street View Publish API
 * Publishes 360 photos to Google Maps, along with position, orientation, and connectivity metadata. Apps can offer an interface for positioning, connecting, and uploading user-generated Street View images. 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.GpsDataGapFailureDetails;
import org.openapitools.client.model.ImuDataGapFailureDetails;
import org.openapitools.client.model.InsufficientGpsFailureDetails;
import org.openapitools.client.model.NoOverlapGpsFailureDetails;
import org.openapitools.client.model.NotOutdoorsFailureDetails;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Additional details to accompany the ProcessingFailureReason enum. This message is always expected to be used in conjunction with ProcessingFailureReason, and the oneof value set in this message should match the FailureReason.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:46:41.091890-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ProcessingFailureDetails {
  public static final String SERIALIZED_NAME_GPS_DATA_GAP_DETAILS = "gpsDataGapDetails";
  @SerializedName(SERIALIZED_NAME_GPS_DATA_GAP_DETAILS)
  private GpsDataGapFailureDetails gpsDataGapDetails;

  public static final String SERIALIZED_NAME_IMU_DATA_GAP_DETAILS = "imuDataGapDetails";
  @SerializedName(SERIALIZED_NAME_IMU_DATA_GAP_DETAILS)
  private ImuDataGapFailureDetails imuDataGapDetails;

  public static final String SERIALIZED_NAME_INSUFFICIENT_GPS_DETAILS = "insufficientGpsDetails";
  @SerializedName(SERIALIZED_NAME_INSUFFICIENT_GPS_DETAILS)
  private InsufficientGpsFailureDetails insufficientGpsDetails;

  public static final String SERIALIZED_NAME_NO_OVERLAP_GPS_DETAILS = "noOverlapGpsDetails";
  @SerializedName(SERIALIZED_NAME_NO_OVERLAP_GPS_DETAILS)
  private NoOverlapGpsFailureDetails noOverlapGpsDetails;

  public static final String SERIALIZED_NAME_NOT_OUTDOORS_DETAILS = "notOutdoorsDetails";
  @SerializedName(SERIALIZED_NAME_NOT_OUTDOORS_DETAILS)
  private NotOutdoorsFailureDetails notOutdoorsDetails;

  public ProcessingFailureDetails() {
  }

  public ProcessingFailureDetails gpsDataGapDetails(GpsDataGapFailureDetails gpsDataGapDetails) {
    this.gpsDataGapDetails = gpsDataGapDetails;
    return this;
  }

  /**
   * Get gpsDataGapDetails
   * @return gpsDataGapDetails
   */
  @javax.annotation.Nullable
  public GpsDataGapFailureDetails getGpsDataGapDetails() {
    return gpsDataGapDetails;
  }

  public void setGpsDataGapDetails(GpsDataGapFailureDetails gpsDataGapDetails) {
    this.gpsDataGapDetails = gpsDataGapDetails;
  }


  public ProcessingFailureDetails imuDataGapDetails(ImuDataGapFailureDetails imuDataGapDetails) {
    this.imuDataGapDetails = imuDataGapDetails;
    return this;
  }

  /**
   * Get imuDataGapDetails
   * @return imuDataGapDetails
   */
  @javax.annotation.Nullable
  public ImuDataGapFailureDetails getImuDataGapDetails() {
    return imuDataGapDetails;
  }

  public void setImuDataGapDetails(ImuDataGapFailureDetails imuDataGapDetails) {
    this.imuDataGapDetails = imuDataGapDetails;
  }


  public ProcessingFailureDetails insufficientGpsDetails(InsufficientGpsFailureDetails insufficientGpsDetails) {
    this.insufficientGpsDetails = insufficientGpsDetails;
    return this;
  }

  /**
   * Get insufficientGpsDetails
   * @return insufficientGpsDetails
   */
  @javax.annotation.Nullable
  public InsufficientGpsFailureDetails getInsufficientGpsDetails() {
    return insufficientGpsDetails;
  }

  public void setInsufficientGpsDetails(InsufficientGpsFailureDetails insufficientGpsDetails) {
    this.insufficientGpsDetails = insufficientGpsDetails;
  }


  public ProcessingFailureDetails noOverlapGpsDetails(NoOverlapGpsFailureDetails noOverlapGpsDetails) {
    this.noOverlapGpsDetails = noOverlapGpsDetails;
    return this;
  }

  /**
   * Get noOverlapGpsDetails
   * @return noOverlapGpsDetails
   */
  @javax.annotation.Nullable
  public NoOverlapGpsFailureDetails getNoOverlapGpsDetails() {
    return noOverlapGpsDetails;
  }

  public void setNoOverlapGpsDetails(NoOverlapGpsFailureDetails noOverlapGpsDetails) {
    this.noOverlapGpsDetails = noOverlapGpsDetails;
  }


  public ProcessingFailureDetails notOutdoorsDetails(NotOutdoorsFailureDetails notOutdoorsDetails) {
    this.notOutdoorsDetails = notOutdoorsDetails;
    return this;
  }

  /**
   * Get notOutdoorsDetails
   * @return notOutdoorsDetails
   */
  @javax.annotation.Nullable
  public NotOutdoorsFailureDetails getNotOutdoorsDetails() {
    return notOutdoorsDetails;
  }

  public void setNotOutdoorsDetails(NotOutdoorsFailureDetails notOutdoorsDetails) {
    this.notOutdoorsDetails = notOutdoorsDetails;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ProcessingFailureDetails processingFailureDetails = (ProcessingFailureDetails) o;
    return Objects.equals(this.gpsDataGapDetails, processingFailureDetails.gpsDataGapDetails) &&
        Objects.equals(this.imuDataGapDetails, processingFailureDetails.imuDataGapDetails) &&
        Objects.equals(this.insufficientGpsDetails, processingFailureDetails.insufficientGpsDetails) &&
        Objects.equals(this.noOverlapGpsDetails, processingFailureDetails.noOverlapGpsDetails) &&
        Objects.equals(this.notOutdoorsDetails, processingFailureDetails.notOutdoorsDetails);
  }

  @Override
  public int hashCode() {
    return Objects.hash(gpsDataGapDetails, imuDataGapDetails, insufficientGpsDetails, noOverlapGpsDetails, notOutdoorsDetails);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ProcessingFailureDetails {\n");
    sb.append("    gpsDataGapDetails: ").append(toIndentedString(gpsDataGapDetails)).append("\n");
    sb.append("    imuDataGapDetails: ").append(toIndentedString(imuDataGapDetails)).append("\n");
    sb.append("    insufficientGpsDetails: ").append(toIndentedString(insufficientGpsDetails)).append("\n");
    sb.append("    noOverlapGpsDetails: ").append(toIndentedString(noOverlapGpsDetails)).append("\n");
    sb.append("    notOutdoorsDetails: ").append(toIndentedString(notOutdoorsDetails)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("gpsDataGapDetails");
    openapiFields.add("imuDataGapDetails");
    openapiFields.add("insufficientGpsDetails");
    openapiFields.add("noOverlapGpsDetails");
    openapiFields.add("notOutdoorsDetails");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ProcessingFailureDetails
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ProcessingFailureDetails.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ProcessingFailureDetails is not found in the empty JSON string", ProcessingFailureDetails.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ProcessingFailureDetails.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ProcessingFailureDetails` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `gpsDataGapDetails`
      if (jsonObj.get("gpsDataGapDetails") != null && !jsonObj.get("gpsDataGapDetails").isJsonNull()) {
        GpsDataGapFailureDetails.validateJsonElement(jsonObj.get("gpsDataGapDetails"));
      }
      // validate the optional field `imuDataGapDetails`
      if (jsonObj.get("imuDataGapDetails") != null && !jsonObj.get("imuDataGapDetails").isJsonNull()) {
        ImuDataGapFailureDetails.validateJsonElement(jsonObj.get("imuDataGapDetails"));
      }
      // validate the optional field `insufficientGpsDetails`
      if (jsonObj.get("insufficientGpsDetails") != null && !jsonObj.get("insufficientGpsDetails").isJsonNull()) {
        InsufficientGpsFailureDetails.validateJsonElement(jsonObj.get("insufficientGpsDetails"));
      }
      // validate the optional field `noOverlapGpsDetails`
      if (jsonObj.get("noOverlapGpsDetails") != null && !jsonObj.get("noOverlapGpsDetails").isJsonNull()) {
        NoOverlapGpsFailureDetails.validateJsonElement(jsonObj.get("noOverlapGpsDetails"));
      }
      // validate the optional field `notOutdoorsDetails`
      if (jsonObj.get("notOutdoorsDetails") != null && !jsonObj.get("notOutdoorsDetails").isJsonNull()) {
        NotOutdoorsFailureDetails.validateJsonElement(jsonObj.get("notOutdoorsDetails"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ProcessingFailureDetails.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ProcessingFailureDetails' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ProcessingFailureDetails> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ProcessingFailureDetails.class));

       return (TypeAdapter<T>) new TypeAdapter<ProcessingFailureDetails>() {
           @Override
           public void write(JsonWriter out, ProcessingFailureDetails value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ProcessingFailureDetails read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ProcessingFailureDetails given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ProcessingFailureDetails
   * @throws IOException if the JSON string is invalid with respect to ProcessingFailureDetails
   */
  public static ProcessingFailureDetails fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ProcessingFailureDetails.class);
  }

  /**
   * Convert an instance of ProcessingFailureDetails to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

