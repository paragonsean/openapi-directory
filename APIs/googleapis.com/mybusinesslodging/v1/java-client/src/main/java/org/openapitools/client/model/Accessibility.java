/*
 * My Business Lodging API
 * The My Business Lodging API enables managing lodging business information on Google. Note - If you have a quota of 0 after enabling the API, please request for GBP API access.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Physical adaptations made to the property in consideration of varying levels of human physical ability.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:19.182361-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Accessibility {
  public static final String SERIALIZED_NAME_MOBILITY_ACCESSIBLE = "mobilityAccessible";
  @SerializedName(SERIALIZED_NAME_MOBILITY_ACCESSIBLE)
  private Boolean mobilityAccessible;

  public static final String SERIALIZED_NAME_MOBILITY_ACCESSIBLE_ELEVATOR = "mobilityAccessibleElevator";
  @SerializedName(SERIALIZED_NAME_MOBILITY_ACCESSIBLE_ELEVATOR)
  private Boolean mobilityAccessibleElevator;

  /**
   * Mobility accessible elevator exception.
   */
  @JsonAdapter(MobilityAccessibleElevatorExceptionEnum.Adapter.class)
  public enum MobilityAccessibleElevatorExceptionEnum {
    EXCEPTION_UNSPECIFIED("EXCEPTION_UNSPECIFIED"),
    
    UNDER_CONSTRUCTION("UNDER_CONSTRUCTION"),
    
    DEPENDENT_ON_SEASON("DEPENDENT_ON_SEASON"),
    
    DEPENDENT_ON_DAY_OF_WEEK("DEPENDENT_ON_DAY_OF_WEEK");

    private String value;

    MobilityAccessibleElevatorExceptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MobilityAccessibleElevatorExceptionEnum fromValue(String value) {
      for (MobilityAccessibleElevatorExceptionEnum b : MobilityAccessibleElevatorExceptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MobilityAccessibleElevatorExceptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MobilityAccessibleElevatorExceptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MobilityAccessibleElevatorExceptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MobilityAccessibleElevatorExceptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MobilityAccessibleElevatorExceptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MOBILITY_ACCESSIBLE_ELEVATOR_EXCEPTION = "mobilityAccessibleElevatorException";
  @SerializedName(SERIALIZED_NAME_MOBILITY_ACCESSIBLE_ELEVATOR_EXCEPTION)
  private MobilityAccessibleElevatorExceptionEnum mobilityAccessibleElevatorException;

  /**
   * Mobility accessible exception.
   */
  @JsonAdapter(MobilityAccessibleExceptionEnum.Adapter.class)
  public enum MobilityAccessibleExceptionEnum {
    EXCEPTION_UNSPECIFIED("EXCEPTION_UNSPECIFIED"),
    
    UNDER_CONSTRUCTION("UNDER_CONSTRUCTION"),
    
    DEPENDENT_ON_SEASON("DEPENDENT_ON_SEASON"),
    
    DEPENDENT_ON_DAY_OF_WEEK("DEPENDENT_ON_DAY_OF_WEEK");

    private String value;

    MobilityAccessibleExceptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MobilityAccessibleExceptionEnum fromValue(String value) {
      for (MobilityAccessibleExceptionEnum b : MobilityAccessibleExceptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MobilityAccessibleExceptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MobilityAccessibleExceptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MobilityAccessibleExceptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MobilityAccessibleExceptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MobilityAccessibleExceptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MOBILITY_ACCESSIBLE_EXCEPTION = "mobilityAccessibleException";
  @SerializedName(SERIALIZED_NAME_MOBILITY_ACCESSIBLE_EXCEPTION)
  private MobilityAccessibleExceptionEnum mobilityAccessibleException;

  public static final String SERIALIZED_NAME_MOBILITY_ACCESSIBLE_PARKING = "mobilityAccessibleParking";
  @SerializedName(SERIALIZED_NAME_MOBILITY_ACCESSIBLE_PARKING)
  private Boolean mobilityAccessibleParking;

  /**
   * Mobility accessible parking exception.
   */
  @JsonAdapter(MobilityAccessibleParkingExceptionEnum.Adapter.class)
  public enum MobilityAccessibleParkingExceptionEnum {
    EXCEPTION_UNSPECIFIED("EXCEPTION_UNSPECIFIED"),
    
    UNDER_CONSTRUCTION("UNDER_CONSTRUCTION"),
    
    DEPENDENT_ON_SEASON("DEPENDENT_ON_SEASON"),
    
    DEPENDENT_ON_DAY_OF_WEEK("DEPENDENT_ON_DAY_OF_WEEK");

    private String value;

    MobilityAccessibleParkingExceptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MobilityAccessibleParkingExceptionEnum fromValue(String value) {
      for (MobilityAccessibleParkingExceptionEnum b : MobilityAccessibleParkingExceptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MobilityAccessibleParkingExceptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MobilityAccessibleParkingExceptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MobilityAccessibleParkingExceptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MobilityAccessibleParkingExceptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MobilityAccessibleParkingExceptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MOBILITY_ACCESSIBLE_PARKING_EXCEPTION = "mobilityAccessibleParkingException";
  @SerializedName(SERIALIZED_NAME_MOBILITY_ACCESSIBLE_PARKING_EXCEPTION)
  private MobilityAccessibleParkingExceptionEnum mobilityAccessibleParkingException;

  public static final String SERIALIZED_NAME_MOBILITY_ACCESSIBLE_POOL = "mobilityAccessiblePool";
  @SerializedName(SERIALIZED_NAME_MOBILITY_ACCESSIBLE_POOL)
  private Boolean mobilityAccessiblePool;

  /**
   * Mobility accessible pool exception.
   */
  @JsonAdapter(MobilityAccessiblePoolExceptionEnum.Adapter.class)
  public enum MobilityAccessiblePoolExceptionEnum {
    EXCEPTION_UNSPECIFIED("EXCEPTION_UNSPECIFIED"),
    
    UNDER_CONSTRUCTION("UNDER_CONSTRUCTION"),
    
    DEPENDENT_ON_SEASON("DEPENDENT_ON_SEASON"),
    
    DEPENDENT_ON_DAY_OF_WEEK("DEPENDENT_ON_DAY_OF_WEEK");

    private String value;

    MobilityAccessiblePoolExceptionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MobilityAccessiblePoolExceptionEnum fromValue(String value) {
      for (MobilityAccessiblePoolExceptionEnum b : MobilityAccessiblePoolExceptionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MobilityAccessiblePoolExceptionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MobilityAccessiblePoolExceptionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MobilityAccessiblePoolExceptionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MobilityAccessiblePoolExceptionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MobilityAccessiblePoolExceptionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MOBILITY_ACCESSIBLE_POOL_EXCEPTION = "mobilityAccessiblePoolException";
  @SerializedName(SERIALIZED_NAME_MOBILITY_ACCESSIBLE_POOL_EXCEPTION)
  private MobilityAccessiblePoolExceptionEnum mobilityAccessiblePoolException;

  public Accessibility() {
  }

  public Accessibility mobilityAccessible(Boolean mobilityAccessible) {
    this.mobilityAccessible = mobilityAccessible;
    return this;
  }

  /**
   * Mobility accessible. Throughout the property there are physical adaptations to ease the stay of a person in a wheelchair, such as auto-opening doors, wide elevators, wide bathrooms or ramps.
   * @return mobilityAccessible
   */
  @javax.annotation.Nullable
  public Boolean getMobilityAccessible() {
    return mobilityAccessible;
  }

  public void setMobilityAccessible(Boolean mobilityAccessible) {
    this.mobilityAccessible = mobilityAccessible;
  }


  public Accessibility mobilityAccessibleElevator(Boolean mobilityAccessibleElevator) {
    this.mobilityAccessibleElevator = mobilityAccessibleElevator;
    return this;
  }

  /**
   * Mobility accessible elevator. A lift that transports people from one level to another and is built to accommodate a wheelchair-using passenger owing to the width of its doors and placement of call buttons.
   * @return mobilityAccessibleElevator
   */
  @javax.annotation.Nullable
  public Boolean getMobilityAccessibleElevator() {
    return mobilityAccessibleElevator;
  }

  public void setMobilityAccessibleElevator(Boolean mobilityAccessibleElevator) {
    this.mobilityAccessibleElevator = mobilityAccessibleElevator;
  }


  public Accessibility mobilityAccessibleElevatorException(MobilityAccessibleElevatorExceptionEnum mobilityAccessibleElevatorException) {
    this.mobilityAccessibleElevatorException = mobilityAccessibleElevatorException;
    return this;
  }

  /**
   * Mobility accessible elevator exception.
   * @return mobilityAccessibleElevatorException
   */
  @javax.annotation.Nullable
  public MobilityAccessibleElevatorExceptionEnum getMobilityAccessibleElevatorException() {
    return mobilityAccessibleElevatorException;
  }

  public void setMobilityAccessibleElevatorException(MobilityAccessibleElevatorExceptionEnum mobilityAccessibleElevatorException) {
    this.mobilityAccessibleElevatorException = mobilityAccessibleElevatorException;
  }


  public Accessibility mobilityAccessibleException(MobilityAccessibleExceptionEnum mobilityAccessibleException) {
    this.mobilityAccessibleException = mobilityAccessibleException;
    return this;
  }

  /**
   * Mobility accessible exception.
   * @return mobilityAccessibleException
   */
  @javax.annotation.Nullable
  public MobilityAccessibleExceptionEnum getMobilityAccessibleException() {
    return mobilityAccessibleException;
  }

  public void setMobilityAccessibleException(MobilityAccessibleExceptionEnum mobilityAccessibleException) {
    this.mobilityAccessibleException = mobilityAccessibleException;
  }


  public Accessibility mobilityAccessibleParking(Boolean mobilityAccessibleParking) {
    this.mobilityAccessibleParking = mobilityAccessibleParking;
    return this;
  }

  /**
   * Mobility accessible parking. The presence of a marked, designated area of prescribed size in which only registered, labeled vehicles transporting a person with physical challenges may park.
   * @return mobilityAccessibleParking
   */
  @javax.annotation.Nullable
  public Boolean getMobilityAccessibleParking() {
    return mobilityAccessibleParking;
  }

  public void setMobilityAccessibleParking(Boolean mobilityAccessibleParking) {
    this.mobilityAccessibleParking = mobilityAccessibleParking;
  }


  public Accessibility mobilityAccessibleParkingException(MobilityAccessibleParkingExceptionEnum mobilityAccessibleParkingException) {
    this.mobilityAccessibleParkingException = mobilityAccessibleParkingException;
    return this;
  }

  /**
   * Mobility accessible parking exception.
   * @return mobilityAccessibleParkingException
   */
  @javax.annotation.Nullable
  public MobilityAccessibleParkingExceptionEnum getMobilityAccessibleParkingException() {
    return mobilityAccessibleParkingException;
  }

  public void setMobilityAccessibleParkingException(MobilityAccessibleParkingExceptionEnum mobilityAccessibleParkingException) {
    this.mobilityAccessibleParkingException = mobilityAccessibleParkingException;
  }


  public Accessibility mobilityAccessiblePool(Boolean mobilityAccessiblePool) {
    this.mobilityAccessiblePool = mobilityAccessiblePool;
    return this;
  }

  /**
   * Mobility accessible pool. A swimming pool equipped with a mechanical chair that can be lowered and raised for the purpose of moving physically challenged guests into and out of the pool. May be powered by electricity or water. Also known as pool lift.
   * @return mobilityAccessiblePool
   */
  @javax.annotation.Nullable
  public Boolean getMobilityAccessiblePool() {
    return mobilityAccessiblePool;
  }

  public void setMobilityAccessiblePool(Boolean mobilityAccessiblePool) {
    this.mobilityAccessiblePool = mobilityAccessiblePool;
  }


  public Accessibility mobilityAccessiblePoolException(MobilityAccessiblePoolExceptionEnum mobilityAccessiblePoolException) {
    this.mobilityAccessiblePoolException = mobilityAccessiblePoolException;
    return this;
  }

  /**
   * Mobility accessible pool exception.
   * @return mobilityAccessiblePoolException
   */
  @javax.annotation.Nullable
  public MobilityAccessiblePoolExceptionEnum getMobilityAccessiblePoolException() {
    return mobilityAccessiblePoolException;
  }

  public void setMobilityAccessiblePoolException(MobilityAccessiblePoolExceptionEnum mobilityAccessiblePoolException) {
    this.mobilityAccessiblePoolException = mobilityAccessiblePoolException;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Accessibility accessibility = (Accessibility) o;
    return Objects.equals(this.mobilityAccessible, accessibility.mobilityAccessible) &&
        Objects.equals(this.mobilityAccessibleElevator, accessibility.mobilityAccessibleElevator) &&
        Objects.equals(this.mobilityAccessibleElevatorException, accessibility.mobilityAccessibleElevatorException) &&
        Objects.equals(this.mobilityAccessibleException, accessibility.mobilityAccessibleException) &&
        Objects.equals(this.mobilityAccessibleParking, accessibility.mobilityAccessibleParking) &&
        Objects.equals(this.mobilityAccessibleParkingException, accessibility.mobilityAccessibleParkingException) &&
        Objects.equals(this.mobilityAccessiblePool, accessibility.mobilityAccessiblePool) &&
        Objects.equals(this.mobilityAccessiblePoolException, accessibility.mobilityAccessiblePoolException);
  }

  @Override
  public int hashCode() {
    return Objects.hash(mobilityAccessible, mobilityAccessibleElevator, mobilityAccessibleElevatorException, mobilityAccessibleException, mobilityAccessibleParking, mobilityAccessibleParkingException, mobilityAccessiblePool, mobilityAccessiblePoolException);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Accessibility {\n");
    sb.append("    mobilityAccessible: ").append(toIndentedString(mobilityAccessible)).append("\n");
    sb.append("    mobilityAccessibleElevator: ").append(toIndentedString(mobilityAccessibleElevator)).append("\n");
    sb.append("    mobilityAccessibleElevatorException: ").append(toIndentedString(mobilityAccessibleElevatorException)).append("\n");
    sb.append("    mobilityAccessibleException: ").append(toIndentedString(mobilityAccessibleException)).append("\n");
    sb.append("    mobilityAccessibleParking: ").append(toIndentedString(mobilityAccessibleParking)).append("\n");
    sb.append("    mobilityAccessibleParkingException: ").append(toIndentedString(mobilityAccessibleParkingException)).append("\n");
    sb.append("    mobilityAccessiblePool: ").append(toIndentedString(mobilityAccessiblePool)).append("\n");
    sb.append("    mobilityAccessiblePoolException: ").append(toIndentedString(mobilityAccessiblePoolException)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("mobilityAccessible");
    openapiFields.add("mobilityAccessibleElevator");
    openapiFields.add("mobilityAccessibleElevatorException");
    openapiFields.add("mobilityAccessibleException");
    openapiFields.add("mobilityAccessibleParking");
    openapiFields.add("mobilityAccessibleParkingException");
    openapiFields.add("mobilityAccessiblePool");
    openapiFields.add("mobilityAccessiblePoolException");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Accessibility
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Accessibility.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Accessibility is not found in the empty JSON string", Accessibility.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Accessibility.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Accessibility` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("mobilityAccessibleElevatorException") != null && !jsonObj.get("mobilityAccessibleElevatorException").isJsonNull()) && !jsonObj.get("mobilityAccessibleElevatorException").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mobilityAccessibleElevatorException` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mobilityAccessibleElevatorException").toString()));
      }
      // validate the optional field `mobilityAccessibleElevatorException`
      if (jsonObj.get("mobilityAccessibleElevatorException") != null && !jsonObj.get("mobilityAccessibleElevatorException").isJsonNull()) {
        MobilityAccessibleElevatorExceptionEnum.validateJsonElement(jsonObj.get("mobilityAccessibleElevatorException"));
      }
      if ((jsonObj.get("mobilityAccessibleException") != null && !jsonObj.get("mobilityAccessibleException").isJsonNull()) && !jsonObj.get("mobilityAccessibleException").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mobilityAccessibleException` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mobilityAccessibleException").toString()));
      }
      // validate the optional field `mobilityAccessibleException`
      if (jsonObj.get("mobilityAccessibleException") != null && !jsonObj.get("mobilityAccessibleException").isJsonNull()) {
        MobilityAccessibleExceptionEnum.validateJsonElement(jsonObj.get("mobilityAccessibleException"));
      }
      if ((jsonObj.get("mobilityAccessibleParkingException") != null && !jsonObj.get("mobilityAccessibleParkingException").isJsonNull()) && !jsonObj.get("mobilityAccessibleParkingException").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mobilityAccessibleParkingException` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mobilityAccessibleParkingException").toString()));
      }
      // validate the optional field `mobilityAccessibleParkingException`
      if (jsonObj.get("mobilityAccessibleParkingException") != null && !jsonObj.get("mobilityAccessibleParkingException").isJsonNull()) {
        MobilityAccessibleParkingExceptionEnum.validateJsonElement(jsonObj.get("mobilityAccessibleParkingException"));
      }
      if ((jsonObj.get("mobilityAccessiblePoolException") != null && !jsonObj.get("mobilityAccessiblePoolException").isJsonNull()) && !jsonObj.get("mobilityAccessiblePoolException").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mobilityAccessiblePoolException` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mobilityAccessiblePoolException").toString()));
      }
      // validate the optional field `mobilityAccessiblePoolException`
      if (jsonObj.get("mobilityAccessiblePoolException") != null && !jsonObj.get("mobilityAccessiblePoolException").isJsonNull()) {
        MobilityAccessiblePoolExceptionEnum.validateJsonElement(jsonObj.get("mobilityAccessiblePoolException"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Accessibility.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Accessibility' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Accessibility> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Accessibility.class));

       return (TypeAdapter<T>) new TypeAdapter<Accessibility>() {
           @Override
           public void write(JsonWriter out, Accessibility value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Accessibility read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Accessibility given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Accessibility
   * @throws IOException if the JSON string is invalid with respect to Accessibility
   */
  public static Accessibility fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Accessibility.class);
  }

  /**
   * Convert an instance of Accessibility to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

