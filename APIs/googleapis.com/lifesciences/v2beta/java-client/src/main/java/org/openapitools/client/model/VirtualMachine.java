/*
 * Cloud Life Sciences API
 * Cloud Life Sciences is a suite of services and tools for managing, processing, and transforming life sciences data.
 *
 * The version of the OpenAPI document: v2beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.Accelerator;
import org.openapitools.client.model.Disk;
import org.openapitools.client.model.Network;
import org.openapitools.client.model.ServiceAccount;
import org.openapitools.client.model.Volume;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Carries information about a Compute Engine VM resource.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:22.659576-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VirtualMachine {
  public static final String SERIALIZED_NAME_ACCELERATORS = "accelerators";
  @SerializedName(SERIALIZED_NAME_ACCELERATORS)
  private List<Accelerator> accelerators = new ArrayList<>();

  public static final String SERIALIZED_NAME_BOOT_DISK_SIZE_GB = "bootDiskSizeGb";
  @SerializedName(SERIALIZED_NAME_BOOT_DISK_SIZE_GB)
  private Integer bootDiskSizeGb;

  public static final String SERIALIZED_NAME_BOOT_IMAGE = "bootImage";
  @SerializedName(SERIALIZED_NAME_BOOT_IMAGE)
  private String bootImage;

  public static final String SERIALIZED_NAME_CPU_PLATFORM = "cpuPlatform";
  @SerializedName(SERIALIZED_NAME_CPU_PLATFORM)
  private String cpuPlatform;

  public static final String SERIALIZED_NAME_DISKS = "disks";
  @SerializedName(SERIALIZED_NAME_DISKS)
  private List<Disk> disks = new ArrayList<>();

  public static final String SERIALIZED_NAME_DOCKER_CACHE_IMAGES = "dockerCacheImages";
  @SerializedName(SERIALIZED_NAME_DOCKER_CACHE_IMAGES)
  private List<String> dockerCacheImages = new ArrayList<>();

  public static final String SERIALIZED_NAME_ENABLE_STACKDRIVER_MONITORING = "enableStackdriverMonitoring";
  @SerializedName(SERIALIZED_NAME_ENABLE_STACKDRIVER_MONITORING)
  private Boolean enableStackdriverMonitoring;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MACHINE_TYPE = "machineType";
  @SerializedName(SERIALIZED_NAME_MACHINE_TYPE)
  private String machineType;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private Network network;

  public static final String SERIALIZED_NAME_NVIDIA_DRIVER_VERSION = "nvidiaDriverVersion";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_NVIDIA_DRIVER_VERSION)
  private String nvidiaDriverVersion;

  public static final String SERIALIZED_NAME_PREEMPTIBLE = "preemptible";
  @SerializedName(SERIALIZED_NAME_PREEMPTIBLE)
  private Boolean preemptible;

  public static final String SERIALIZED_NAME_RESERVATION = "reservation";
  @SerializedName(SERIALIZED_NAME_RESERVATION)
  private String reservation;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT = "serviceAccount";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT)
  private ServiceAccount serviceAccount;

  public static final String SERIALIZED_NAME_VOLUMES = "volumes";
  @SerializedName(SERIALIZED_NAME_VOLUMES)
  private List<Volume> volumes = new ArrayList<>();

  public VirtualMachine() {
  }

  public VirtualMachine accelerators(List<Accelerator> accelerators) {
    this.accelerators = accelerators;
    return this;
  }

  public VirtualMachine addAcceleratorsItem(Accelerator acceleratorsItem) {
    if (this.accelerators == null) {
      this.accelerators = new ArrayList<>();
    }
    this.accelerators.add(acceleratorsItem);
    return this;
  }

  /**
   * The list of accelerators to attach to the VM.
   * @return accelerators
   */
  @javax.annotation.Nullable
  public List<Accelerator> getAccelerators() {
    return accelerators;
  }

  public void setAccelerators(List<Accelerator> accelerators) {
    this.accelerators = accelerators;
  }


  public VirtualMachine bootDiskSizeGb(Integer bootDiskSizeGb) {
    this.bootDiskSizeGb = bootDiskSizeGb;
    return this;
  }

  /**
   * The size of the boot disk, in GB. The boot disk must be large enough to accommodate all of the Docker images from each action in the pipeline at the same time. If not specified, a small but reasonable default value is used.
   * @return bootDiskSizeGb
   */
  @javax.annotation.Nullable
  public Integer getBootDiskSizeGb() {
    return bootDiskSizeGb;
  }

  public void setBootDiskSizeGb(Integer bootDiskSizeGb) {
    this.bootDiskSizeGb = bootDiskSizeGb;
  }


  public VirtualMachine bootImage(String bootImage) {
    this.bootImage = bootImage;
    return this;
  }

  /**
   * The host operating system image to use. Currently, only Container-Optimized OS images can be used. The default value is &#x60;projects/cos-cloud/global/images/family/cos-stable&#x60;, which selects the latest stable release of Container-Optimized OS. This option is provided to allow testing against the beta release of the operating system to ensure that the new version does not interact negatively with production pipelines. To test a pipeline against the beta release of Container-Optimized OS, use the value &#x60;projects/cos-cloud/global/images/family/cos-beta&#x60;.
   * @return bootImage
   */
  @javax.annotation.Nullable
  public String getBootImage() {
    return bootImage;
  }

  public void setBootImage(String bootImage) {
    this.bootImage = bootImage;
  }


  public VirtualMachine cpuPlatform(String cpuPlatform) {
    this.cpuPlatform = cpuPlatform;
    return this;
  }

  /**
   * The CPU platform to request. An instance based on a newer platform can be allocated, but never one with fewer capabilities. The value of this parameter must be a valid Compute Engine CPU platform name (such as \&quot;Intel Skylake\&quot;). This parameter is only useful for carefully optimized work loads where the CPU platform has a significant impact. For more information about the effect of this parameter, see https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
   * @return cpuPlatform
   */
  @javax.annotation.Nullable
  public String getCpuPlatform() {
    return cpuPlatform;
  }

  public void setCpuPlatform(String cpuPlatform) {
    this.cpuPlatform = cpuPlatform;
  }


  public VirtualMachine disks(List<Disk> disks) {
    this.disks = disks;
    return this;
  }

  public VirtualMachine addDisksItem(Disk disksItem) {
    if (this.disks == null) {
      this.disks = new ArrayList<>();
    }
    this.disks.add(disksItem);
    return this;
  }

  /**
   * The list of disks to create and attach to the VM. Specify either the &#x60;volumes[]&#x60; field or the &#x60;disks[]&#x60; field, but not both.
   * @return disks
   */
  @javax.annotation.Nullable
  public List<Disk> getDisks() {
    return disks;
  }

  public void setDisks(List<Disk> disks) {
    this.disks = disks;
  }


  public VirtualMachine dockerCacheImages(List<String> dockerCacheImages) {
    this.dockerCacheImages = dockerCacheImages;
    return this;
  }

  public VirtualMachine addDockerCacheImagesItem(String dockerCacheImagesItem) {
    if (this.dockerCacheImages == null) {
      this.dockerCacheImages = new ArrayList<>();
    }
    this.dockerCacheImages.add(dockerCacheImagesItem);
    return this;
  }

  /**
   * The Compute Engine Disk Images to use as a Docker cache. The disks will be mounted into the Docker folder in a way that the images present in the cache will not need to be pulled. The digests of the cached images must match those of the tags used or the latest version will still be pulled. The root directory of the ext4 image must contain &#x60;image&#x60; and &#x60;overlay2&#x60; directories copied from the Docker directory of a VM where the desired Docker images have already been pulled. Any images pulled that are not cached will be stored on the first cache disk instead of the boot disk. Only a single image is supported.
   * @return dockerCacheImages
   */
  @javax.annotation.Nullable
  public List<String> getDockerCacheImages() {
    return dockerCacheImages;
  }

  public void setDockerCacheImages(List<String> dockerCacheImages) {
    this.dockerCacheImages = dockerCacheImages;
  }


  public VirtualMachine enableStackdriverMonitoring(Boolean enableStackdriverMonitoring) {
    this.enableStackdriverMonitoring = enableStackdriverMonitoring;
    return this;
  }

  /**
   * Whether Stackdriver monitoring should be enabled on the VM.
   * @return enableStackdriverMonitoring
   */
  @javax.annotation.Nullable
  public Boolean getEnableStackdriverMonitoring() {
    return enableStackdriverMonitoring;
  }

  public void setEnableStackdriverMonitoring(Boolean enableStackdriverMonitoring) {
    this.enableStackdriverMonitoring = enableStackdriverMonitoring;
  }


  public VirtualMachine labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public VirtualMachine putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Optional set of labels to apply to the VM and any attached disk resources. These labels must adhere to the [name and value restrictions](https://cloud.google.com/compute/docs/labeling-resources) on VM labels imposed by Compute Engine. Labels keys with the prefix &#39;google-&#39; are reserved for use by Google. Labels applied at creation time to the VM. Applied on a best-effort basis to attached disk resources shortly after VM creation.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public VirtualMachine machineType(String machineType) {
    this.machineType = machineType;
    return this;
  }

  /**
   * Required. The machine type of the virtual machine to create. Must be the short name of a standard machine type (such as \&quot;n1-standard-1\&quot;) or a custom machine type (such as \&quot;custom-1-4096\&quot;, where \&quot;1\&quot; indicates the number of vCPUs and \&quot;4096\&quot; indicates the memory in MB). See [Creating an instance with a custom machine type](https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#create) for more specifications on creating a custom machine type.
   * @return machineType
   */
  @javax.annotation.Nullable
  public String getMachineType() {
    return machineType;
  }

  public void setMachineType(String machineType) {
    this.machineType = machineType;
  }


  public VirtualMachine network(Network network) {
    this.network = network;
    return this;
  }

  /**
   * Get network
   * @return network
   */
  @javax.annotation.Nullable
  public Network getNetwork() {
    return network;
  }

  public void setNetwork(Network network) {
    this.network = network;
  }


  @Deprecated
  public VirtualMachine nvidiaDriverVersion(String nvidiaDriverVersion) {
    this.nvidiaDriverVersion = nvidiaDriverVersion;
    return this;
  }

  /**
   * The NVIDIA driver version to use when attaching an NVIDIA GPU accelerator. The version specified here must be compatible with the GPU libraries contained in the container being executed, and must be one of the drivers hosted in the &#x60;nvidia-drivers-us-public&#x60; bucket on Google Cloud Storage.
   * @return nvidiaDriverVersion
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public String getNvidiaDriverVersion() {
    return nvidiaDriverVersion;
  }

  @Deprecated
  public void setNvidiaDriverVersion(String nvidiaDriverVersion) {
    this.nvidiaDriverVersion = nvidiaDriverVersion;
  }


  public VirtualMachine preemptible(Boolean preemptible) {
    this.preemptible = preemptible;
    return this;
  }

  /**
   * If true, allocate a preemptible VM.
   * @return preemptible
   */
  @javax.annotation.Nullable
  public Boolean getPreemptible() {
    return preemptible;
  }

  public void setPreemptible(Boolean preemptible) {
    this.preemptible = preemptible;
  }


  public VirtualMachine reservation(String reservation) {
    this.reservation = reservation;
    return this;
  }

  /**
   * If specified, the VM will only be allocated inside the matching reservation. It will fail if the VM parameters don&#39;t match the reservation.
   * @return reservation
   */
  @javax.annotation.Nullable
  public String getReservation() {
    return reservation;
  }

  public void setReservation(String reservation) {
    this.reservation = reservation;
  }


  public VirtualMachine serviceAccount(ServiceAccount serviceAccount) {
    this.serviceAccount = serviceAccount;
    return this;
  }

  /**
   * Get serviceAccount
   * @return serviceAccount
   */
  @javax.annotation.Nullable
  public ServiceAccount getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(ServiceAccount serviceAccount) {
    this.serviceAccount = serviceAccount;
  }


  public VirtualMachine volumes(List<Volume> volumes) {
    this.volumes = volumes;
    return this;
  }

  public VirtualMachine addVolumesItem(Volume volumesItem) {
    if (this.volumes == null) {
      this.volumes = new ArrayList<>();
    }
    this.volumes.add(volumesItem);
    return this;
  }

  /**
   * The list of disks and other storage to create or attach to the VM. Specify either the &#x60;volumes[]&#x60; field or the &#x60;disks[]&#x60; field, but not both.
   * @return volumes
   */
  @javax.annotation.Nullable
  public List<Volume> getVolumes() {
    return volumes;
  }

  public void setVolumes(List<Volume> volumes) {
    this.volumes = volumes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VirtualMachine virtualMachine = (VirtualMachine) o;
    return Objects.equals(this.accelerators, virtualMachine.accelerators) &&
        Objects.equals(this.bootDiskSizeGb, virtualMachine.bootDiskSizeGb) &&
        Objects.equals(this.bootImage, virtualMachine.bootImage) &&
        Objects.equals(this.cpuPlatform, virtualMachine.cpuPlatform) &&
        Objects.equals(this.disks, virtualMachine.disks) &&
        Objects.equals(this.dockerCacheImages, virtualMachine.dockerCacheImages) &&
        Objects.equals(this.enableStackdriverMonitoring, virtualMachine.enableStackdriverMonitoring) &&
        Objects.equals(this.labels, virtualMachine.labels) &&
        Objects.equals(this.machineType, virtualMachine.machineType) &&
        Objects.equals(this.network, virtualMachine.network) &&
        Objects.equals(this.nvidiaDriverVersion, virtualMachine.nvidiaDriverVersion) &&
        Objects.equals(this.preemptible, virtualMachine.preemptible) &&
        Objects.equals(this.reservation, virtualMachine.reservation) &&
        Objects.equals(this.serviceAccount, virtualMachine.serviceAccount) &&
        Objects.equals(this.volumes, virtualMachine.volumes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accelerators, bootDiskSizeGb, bootImage, cpuPlatform, disks, dockerCacheImages, enableStackdriverMonitoring, labels, machineType, network, nvidiaDriverVersion, preemptible, reservation, serviceAccount, volumes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VirtualMachine {\n");
    sb.append("    accelerators: ").append(toIndentedString(accelerators)).append("\n");
    sb.append("    bootDiskSizeGb: ").append(toIndentedString(bootDiskSizeGb)).append("\n");
    sb.append("    bootImage: ").append(toIndentedString(bootImage)).append("\n");
    sb.append("    cpuPlatform: ").append(toIndentedString(cpuPlatform)).append("\n");
    sb.append("    disks: ").append(toIndentedString(disks)).append("\n");
    sb.append("    dockerCacheImages: ").append(toIndentedString(dockerCacheImages)).append("\n");
    sb.append("    enableStackdriverMonitoring: ").append(toIndentedString(enableStackdriverMonitoring)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    machineType: ").append(toIndentedString(machineType)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    nvidiaDriverVersion: ").append(toIndentedString(nvidiaDriverVersion)).append("\n");
    sb.append("    preemptible: ").append(toIndentedString(preemptible)).append("\n");
    sb.append("    reservation: ").append(toIndentedString(reservation)).append("\n");
    sb.append("    serviceAccount: ").append(toIndentedString(serviceAccount)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accelerators");
    openapiFields.add("bootDiskSizeGb");
    openapiFields.add("bootImage");
    openapiFields.add("cpuPlatform");
    openapiFields.add("disks");
    openapiFields.add("dockerCacheImages");
    openapiFields.add("enableStackdriverMonitoring");
    openapiFields.add("labels");
    openapiFields.add("machineType");
    openapiFields.add("network");
    openapiFields.add("nvidiaDriverVersion");
    openapiFields.add("preemptible");
    openapiFields.add("reservation");
    openapiFields.add("serviceAccount");
    openapiFields.add("volumes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VirtualMachine
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VirtualMachine.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VirtualMachine is not found in the empty JSON string", VirtualMachine.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VirtualMachine.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VirtualMachine` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("accelerators") != null && !jsonObj.get("accelerators").isJsonNull()) {
        JsonArray jsonArrayaccelerators = jsonObj.getAsJsonArray("accelerators");
        if (jsonArrayaccelerators != null) {
          // ensure the json data is an array
          if (!jsonObj.get("accelerators").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `accelerators` to be an array in the JSON string but got `%s`", jsonObj.get("accelerators").toString()));
          }

          // validate the optional field `accelerators` (array)
          for (int i = 0; i < jsonArrayaccelerators.size(); i++) {
            Accelerator.validateJsonElement(jsonArrayaccelerators.get(i));
          };
        }
      }
      if ((jsonObj.get("bootImage") != null && !jsonObj.get("bootImage").isJsonNull()) && !jsonObj.get("bootImage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bootImage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bootImage").toString()));
      }
      if ((jsonObj.get("cpuPlatform") != null && !jsonObj.get("cpuPlatform").isJsonNull()) && !jsonObj.get("cpuPlatform").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cpuPlatform` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cpuPlatform").toString()));
      }
      if (jsonObj.get("disks") != null && !jsonObj.get("disks").isJsonNull()) {
        JsonArray jsonArraydisks = jsonObj.getAsJsonArray("disks");
        if (jsonArraydisks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("disks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `disks` to be an array in the JSON string but got `%s`", jsonObj.get("disks").toString()));
          }

          // validate the optional field `disks` (array)
          for (int i = 0; i < jsonArraydisks.size(); i++) {
            Disk.validateJsonElement(jsonArraydisks.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("dockerCacheImages") != null && !jsonObj.get("dockerCacheImages").isJsonNull() && !jsonObj.get("dockerCacheImages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `dockerCacheImages` to be an array in the JSON string but got `%s`", jsonObj.get("dockerCacheImages").toString()));
      }
      if ((jsonObj.get("machineType") != null && !jsonObj.get("machineType").isJsonNull()) && !jsonObj.get("machineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `machineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("machineType").toString()));
      }
      // validate the optional field `network`
      if (jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) {
        Network.validateJsonElement(jsonObj.get("network"));
      }
      if ((jsonObj.get("nvidiaDriverVersion") != null && !jsonObj.get("nvidiaDriverVersion").isJsonNull()) && !jsonObj.get("nvidiaDriverVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nvidiaDriverVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nvidiaDriverVersion").toString()));
      }
      if ((jsonObj.get("reservation") != null && !jsonObj.get("reservation").isJsonNull()) && !jsonObj.get("reservation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reservation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reservation").toString()));
      }
      // validate the optional field `serviceAccount`
      if (jsonObj.get("serviceAccount") != null && !jsonObj.get("serviceAccount").isJsonNull()) {
        ServiceAccount.validateJsonElement(jsonObj.get("serviceAccount"));
      }
      if (jsonObj.get("volumes") != null && !jsonObj.get("volumes").isJsonNull()) {
        JsonArray jsonArrayvolumes = jsonObj.getAsJsonArray("volumes");
        if (jsonArrayvolumes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("volumes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `volumes` to be an array in the JSON string but got `%s`", jsonObj.get("volumes").toString()));
          }

          // validate the optional field `volumes` (array)
          for (int i = 0; i < jsonArrayvolumes.size(); i++) {
            Volume.validateJsonElement(jsonArrayvolumes.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VirtualMachine.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VirtualMachine' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VirtualMachine> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VirtualMachine.class));

       return (TypeAdapter<T>) new TypeAdapter<VirtualMachine>() {
           @Override
           public void write(JsonWriter out, VirtualMachine value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VirtualMachine read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VirtualMachine given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VirtualMachine
   * @throws IOException if the JSON string is invalid with respect to VirtualMachine
   */
  public static VirtualMachine fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VirtualMachine.class);
  }

  /**
   * Convert an instance of VirtualMachine to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

