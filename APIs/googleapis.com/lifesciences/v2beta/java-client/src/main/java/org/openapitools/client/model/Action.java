/*
 * Cloud Life Sciences API
 * Cloud Life Sciences is a suite of services and tools for managing, processing, and transforming life sciences data.
 *
 * The version of the OpenAPI document: v2beta
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.Mount;
import org.openapitools.client.model.Secret;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Specifies a single action that runs a Docker container.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:40:22.659576-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class Action {
  public static final String SERIALIZED_NAME_ALWAYS_RUN = "alwaysRun";
  @SerializedName(SERIALIZED_NAME_ALWAYS_RUN)
  private Boolean alwaysRun;

  public static final String SERIALIZED_NAME_BLOCK_EXTERNAL_NETWORK = "blockExternalNetwork";
  @SerializedName(SERIALIZED_NAME_BLOCK_EXTERNAL_NETWORK)
  private Boolean blockExternalNetwork;

  public static final String SERIALIZED_NAME_COMMANDS = "commands";
  @SerializedName(SERIALIZED_NAME_COMMANDS)
  private List<String> commands = new ArrayList<>();

  public static final String SERIALIZED_NAME_CONTAINER_NAME = "containerName";
  @SerializedName(SERIALIZED_NAME_CONTAINER_NAME)
  private String containerName;

  public static final String SERIALIZED_NAME_CREDENTIALS = "credentials";
  @SerializedName(SERIALIZED_NAME_CREDENTIALS)
  private Secret credentials;

  public static final String SERIALIZED_NAME_DISABLE_IMAGE_PREFETCH = "disableImagePrefetch";
  @SerializedName(SERIALIZED_NAME_DISABLE_IMAGE_PREFETCH)
  private Boolean disableImagePrefetch;

  public static final String SERIALIZED_NAME_DISABLE_STANDARD_ERROR_CAPTURE = "disableStandardErrorCapture";
  @SerializedName(SERIALIZED_NAME_DISABLE_STANDARD_ERROR_CAPTURE)
  private Boolean disableStandardErrorCapture;

  public static final String SERIALIZED_NAME_ENABLE_FUSE = "enableFuse";
  @SerializedName(SERIALIZED_NAME_ENABLE_FUSE)
  private Boolean enableFuse;

  public static final String SERIALIZED_NAME_ENCRYPTED_ENVIRONMENT = "encryptedEnvironment";
  @SerializedName(SERIALIZED_NAME_ENCRYPTED_ENVIRONMENT)
  private Secret encryptedEnvironment;

  public static final String SERIALIZED_NAME_ENTRYPOINT = "entrypoint";
  @SerializedName(SERIALIZED_NAME_ENTRYPOINT)
  private String entrypoint;

  public static final String SERIALIZED_NAME_ENVIRONMENT = "environment";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT)
  private Map<String, String> environment = new HashMap<>();

  public static final String SERIALIZED_NAME_IGNORE_EXIT_STATUS = "ignoreExitStatus";
  @SerializedName(SERIALIZED_NAME_IGNORE_EXIT_STATUS)
  private Boolean ignoreExitStatus;

  public static final String SERIALIZED_NAME_IMAGE_URI = "imageUri";
  @SerializedName(SERIALIZED_NAME_IMAGE_URI)
  private String imageUri;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MOUNTS = "mounts";
  @SerializedName(SERIALIZED_NAME_MOUNTS)
  private List<Mount> mounts = new ArrayList<>();

  public static final String SERIALIZED_NAME_PID_NAMESPACE = "pidNamespace";
  @SerializedName(SERIALIZED_NAME_PID_NAMESPACE)
  private String pidNamespace;

  public static final String SERIALIZED_NAME_PORT_MAPPINGS = "portMappings";
  @SerializedName(SERIALIZED_NAME_PORT_MAPPINGS)
  private Map<String, Integer> portMappings = new HashMap<>();

  public static final String SERIALIZED_NAME_PUBLISH_EXPOSED_PORTS = "publishExposedPorts";
  @SerializedName(SERIALIZED_NAME_PUBLISH_EXPOSED_PORTS)
  private Boolean publishExposedPorts;

  public static final String SERIALIZED_NAME_RUN_IN_BACKGROUND = "runInBackground";
  @SerializedName(SERIALIZED_NAME_RUN_IN_BACKGROUND)
  private Boolean runInBackground;

  public static final String SERIALIZED_NAME_TIMEOUT = "timeout";
  @SerializedName(SERIALIZED_NAME_TIMEOUT)
  private String timeout;

  public Action() {
  }

  public Action alwaysRun(Boolean alwaysRun) {
    this.alwaysRun = alwaysRun;
    return this;
  }

  /**
   * By default, after an action fails, no further actions are run. This flag indicates that this action must be run even if the pipeline has already failed. This is useful for actions that copy output files off of the VM or for debugging. Note that no actions will be run if image prefetching fails.
   * @return alwaysRun
   */
  @javax.annotation.Nullable
  public Boolean getAlwaysRun() {
    return alwaysRun;
  }

  public void setAlwaysRun(Boolean alwaysRun) {
    this.alwaysRun = alwaysRun;
  }


  public Action blockExternalNetwork(Boolean blockExternalNetwork) {
    this.blockExternalNetwork = blockExternalNetwork;
    return this;
  }

  /**
   * Prevents the container from accessing the external network.
   * @return blockExternalNetwork
   */
  @javax.annotation.Nullable
  public Boolean getBlockExternalNetwork() {
    return blockExternalNetwork;
  }

  public void setBlockExternalNetwork(Boolean blockExternalNetwork) {
    this.blockExternalNetwork = blockExternalNetwork;
  }


  public Action commands(List<String> commands) {
    this.commands = commands;
    return this;
  }

  public Action addCommandsItem(String commandsItem) {
    if (this.commands == null) {
      this.commands = new ArrayList<>();
    }
    this.commands.add(commandsItem);
    return this;
  }

  /**
   * If specified, overrides the &#x60;CMD&#x60; specified in the container. If the container also has an &#x60;ENTRYPOINT&#x60; the values are used as entrypoint arguments. Otherwise, they are used as a command and arguments to run inside the container.
   * @return commands
   */
  @javax.annotation.Nullable
  public List<String> getCommands() {
    return commands;
  }

  public void setCommands(List<String> commands) {
    this.commands = commands;
  }


  public Action containerName(String containerName) {
    this.containerName = containerName;
    return this;
  }

  /**
   * An optional name for the container. The container hostname will be set to this name, making it useful for inter-container communication. The name must contain only upper and lowercase alphanumeric characters and hyphens and cannot start with a hyphen.
   * @return containerName
   */
  @javax.annotation.Nullable
  public String getContainerName() {
    return containerName;
  }

  public void setContainerName(String containerName) {
    this.containerName = containerName;
  }


  public Action credentials(Secret credentials) {
    this.credentials = credentials;
    return this;
  }

  /**
   * Get credentials
   * @return credentials
   */
  @javax.annotation.Nullable
  public Secret getCredentials() {
    return credentials;
  }

  public void setCredentials(Secret credentials) {
    this.credentials = credentials;
  }


  public Action disableImagePrefetch(Boolean disableImagePrefetch) {
    this.disableImagePrefetch = disableImagePrefetch;
    return this;
  }

  /**
   * All container images are typically downloaded before any actions are executed. This helps prevent typos in URIs or issues like lack of disk space from wasting large amounts of compute resources. If set, this flag prevents the worker from downloading the image until just before the action is executed.
   * @return disableImagePrefetch
   */
  @javax.annotation.Nullable
  public Boolean getDisableImagePrefetch() {
    return disableImagePrefetch;
  }

  public void setDisableImagePrefetch(Boolean disableImagePrefetch) {
    this.disableImagePrefetch = disableImagePrefetch;
  }


  public Action disableStandardErrorCapture(Boolean disableStandardErrorCapture) {
    this.disableStandardErrorCapture = disableStandardErrorCapture;
    return this;
  }

  /**
   * A small portion of the container&#39;s standard error stream is typically captured and returned inside the &#x60;ContainerStoppedEvent&#x60;. Setting this flag disables this functionality.
   * @return disableStandardErrorCapture
   */
  @javax.annotation.Nullable
  public Boolean getDisableStandardErrorCapture() {
    return disableStandardErrorCapture;
  }

  public void setDisableStandardErrorCapture(Boolean disableStandardErrorCapture) {
    this.disableStandardErrorCapture = disableStandardErrorCapture;
  }


  public Action enableFuse(Boolean enableFuse) {
    this.enableFuse = enableFuse;
    return this;
  }

  /**
   * Enable access to the FUSE device for this action. Filesystems can then be mounted into disks shared with other actions. The other actions do not need the &#x60;enable_fuse&#x60; flag to access the mounted filesystem. This has the effect of causing the container to be executed with &#x60;CAP_SYS_ADMIN&#x60; and exposes &#x60;/dev/fuse&#x60; to the container, so use it only for containers you trust.
   * @return enableFuse
   */
  @javax.annotation.Nullable
  public Boolean getEnableFuse() {
    return enableFuse;
  }

  public void setEnableFuse(Boolean enableFuse) {
    this.enableFuse = enableFuse;
  }


  public Action encryptedEnvironment(Secret encryptedEnvironment) {
    this.encryptedEnvironment = encryptedEnvironment;
    return this;
  }

  /**
   * Get encryptedEnvironment
   * @return encryptedEnvironment
   */
  @javax.annotation.Nullable
  public Secret getEncryptedEnvironment() {
    return encryptedEnvironment;
  }

  public void setEncryptedEnvironment(Secret encryptedEnvironment) {
    this.encryptedEnvironment = encryptedEnvironment;
  }


  public Action entrypoint(String entrypoint) {
    this.entrypoint = entrypoint;
    return this;
  }

  /**
   * If specified, overrides the &#x60;ENTRYPOINT&#x60; specified in the container.
   * @return entrypoint
   */
  @javax.annotation.Nullable
  public String getEntrypoint() {
    return entrypoint;
  }

  public void setEntrypoint(String entrypoint) {
    this.entrypoint = entrypoint;
  }


  public Action environment(Map<String, String> environment) {
    this.environment = environment;
    return this;
  }

  public Action putEnvironmentItem(String key, String environmentItem) {
    if (this.environment == null) {
      this.environment = new HashMap<>();
    }
    this.environment.put(key, environmentItem);
    return this;
  }

  /**
   * The environment to pass into the container. This environment is merged with values specified in the google.cloud.lifesciences.v2beta.Pipeline message, overwriting any duplicate values. In addition to the values passed here, a few other values are automatically injected into the environment. These cannot be hidden or overwritten. &#x60;GOOGLE_PIPELINE_FAILED&#x60; will be set to \&quot;1\&quot; if the pipeline failed because an action has exited with a non-zero status (and did not have the &#x60;IGNORE_EXIT_STATUS&#x60; flag set). This can be used to determine if additional debug or logging actions should execute. &#x60;GOOGLE_LAST_EXIT_STATUS&#x60; will be set to the exit status of the last non-background action that executed. This can be used by workflow engine authors to determine whether an individual action has succeeded or failed.
   * @return environment
   */
  @javax.annotation.Nullable
  public Map<String, String> getEnvironment() {
    return environment;
  }

  public void setEnvironment(Map<String, String> environment) {
    this.environment = environment;
  }


  public Action ignoreExitStatus(Boolean ignoreExitStatus) {
    this.ignoreExitStatus = ignoreExitStatus;
    return this;
  }

  /**
   * Normally, a non-zero exit status causes the pipeline to fail. This flag allows execution of other actions to continue instead.
   * @return ignoreExitStatus
   */
  @javax.annotation.Nullable
  public Boolean getIgnoreExitStatus() {
    return ignoreExitStatus;
  }

  public void setIgnoreExitStatus(Boolean ignoreExitStatus) {
    this.ignoreExitStatus = ignoreExitStatus;
  }


  public Action imageUri(String imageUri) {
    this.imageUri = imageUri;
    return this;
  }

  /**
   * Required. The URI to pull the container image from. Note that all images referenced by actions in the pipeline are pulled before the first action runs. If multiple actions reference the same image, it is only pulled once, ensuring that the same image is used for all actions in a single pipeline. The image URI can be either a complete host and image specification (e.g., quay.io/biocontainers/samtools), a library and image name (e.g., google/cloud-sdk) or a bare image name (&#39;bash&#39;) to pull from the default library. No schema is required in any of these cases. If the specified image is not public, the service account specified for the Virtual Machine must have access to pull the images from GCR, or appropriate credentials must be specified in the google.cloud.lifesciences.v2beta.Action.credentials field.
   * @return imageUri
   */
  @javax.annotation.Nullable
  public String getImageUri() {
    return imageUri;
  }

  public void setImageUri(String imageUri) {
    this.imageUri = imageUri;
  }


  public Action labels(Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Action putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Labels to associate with the action. This field is provided to assist workflow engine authors in identifying actions (for example, to indicate what sort of action they perform, such as localization or debugging). They are returned in the operation metadata, but are otherwise ignored.
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public Action mounts(List<Mount> mounts) {
    this.mounts = mounts;
    return this;
  }

  public Action addMountsItem(Mount mountsItem) {
    if (this.mounts == null) {
      this.mounts = new ArrayList<>();
    }
    this.mounts.add(mountsItem);
    return this;
  }

  /**
   * A list of mounts to make available to the action. In addition to the values specified here, every action has a special virtual disk mounted under &#x60;/google&#x60; that contains log files and other operational components. - /google/logs All logs written during the pipeline execution. - /google/logs/output The combined standard output and standard error of all actions run as part of the pipeline execution. - /google/logs/action/_*_/stdout The complete contents of each individual action&#39;s standard output. - /google/logs/action/_*_/stderr The complete contents of each individual action&#39;s standard error output. 
   * @return mounts
   */
  @javax.annotation.Nullable
  public List<Mount> getMounts() {
    return mounts;
  }

  public void setMounts(List<Mount> mounts) {
    this.mounts = mounts;
  }


  public Action pidNamespace(String pidNamespace) {
    this.pidNamespace = pidNamespace;
    return this;
  }

  /**
   * An optional identifier for a PID namespace to run the action inside. Multiple actions should use the same string to share a namespace. If unspecified, a separate isolated namespace is used.
   * @return pidNamespace
   */
  @javax.annotation.Nullable
  public String getPidNamespace() {
    return pidNamespace;
  }

  public void setPidNamespace(String pidNamespace) {
    this.pidNamespace = pidNamespace;
  }


  public Action portMappings(Map<String, Integer> portMappings) {
    this.portMappings = portMappings;
    return this;
  }

  public Action putPortMappingsItem(String key, Integer portMappingsItem) {
    if (this.portMappings == null) {
      this.portMappings = new HashMap<>();
    }
    this.portMappings.put(key, portMappingsItem);
    return this;
  }

  /**
   * A map of containers to host port mappings for this container. If the container already specifies exposed ports, use the &#x60;PUBLISH_EXPOSED_PORTS&#x60; flag instead. The host port number must be less than 65536. If it is zero, an unused random port is assigned. To determine the resulting port number, consult the &#x60;ContainerStartedEvent&#x60; in the operation metadata.
   * @return portMappings
   */
  @javax.annotation.Nullable
  public Map<String, Integer> getPortMappings() {
    return portMappings;
  }

  public void setPortMappings(Map<String, Integer> portMappings) {
    this.portMappings = portMappings;
  }


  public Action publishExposedPorts(Boolean publishExposedPorts) {
    this.publishExposedPorts = publishExposedPorts;
    return this;
  }

  /**
   * Exposes all ports specified by &#x60;EXPOSE&#x60; statements in the container. To discover the host side port numbers, consult the &#x60;ACTION_STARTED&#x60; event in the operation metadata.
   * @return publishExposedPorts
   */
  @javax.annotation.Nullable
  public Boolean getPublishExposedPorts() {
    return publishExposedPorts;
  }

  public void setPublishExposedPorts(Boolean publishExposedPorts) {
    this.publishExposedPorts = publishExposedPorts;
  }


  public Action runInBackground(Boolean runInBackground) {
    this.runInBackground = runInBackground;
    return this;
  }

  /**
   * This flag allows an action to continue running in the background while executing subsequent actions. This is useful to provide services to other actions (or to provide debugging support tools like SSH servers).
   * @return runInBackground
   */
  @javax.annotation.Nullable
  public Boolean getRunInBackground() {
    return runInBackground;
  }

  public void setRunInBackground(Boolean runInBackground) {
    this.runInBackground = runInBackground;
  }


  public Action timeout(String timeout) {
    this.timeout = timeout;
    return this;
  }

  /**
   * The maximum amount of time to give the action to complete. If the action fails to complete before the timeout, it will be terminated and the exit status will be non-zero. The pipeline will continue or terminate based on the rules defined by the &#x60;ALWAYS_RUN&#x60; and &#x60;IGNORE_EXIT_STATUS&#x60; flags.
   * @return timeout
   */
  @javax.annotation.Nullable
  public String getTimeout() {
    return timeout;
  }

  public void setTimeout(String timeout) {
    this.timeout = timeout;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Action action = (Action) o;
    return Objects.equals(this.alwaysRun, action.alwaysRun) &&
        Objects.equals(this.blockExternalNetwork, action.blockExternalNetwork) &&
        Objects.equals(this.commands, action.commands) &&
        Objects.equals(this.containerName, action.containerName) &&
        Objects.equals(this.credentials, action.credentials) &&
        Objects.equals(this.disableImagePrefetch, action.disableImagePrefetch) &&
        Objects.equals(this.disableStandardErrorCapture, action.disableStandardErrorCapture) &&
        Objects.equals(this.enableFuse, action.enableFuse) &&
        Objects.equals(this.encryptedEnvironment, action.encryptedEnvironment) &&
        Objects.equals(this.entrypoint, action.entrypoint) &&
        Objects.equals(this.environment, action.environment) &&
        Objects.equals(this.ignoreExitStatus, action.ignoreExitStatus) &&
        Objects.equals(this.imageUri, action.imageUri) &&
        Objects.equals(this.labels, action.labels) &&
        Objects.equals(this.mounts, action.mounts) &&
        Objects.equals(this.pidNamespace, action.pidNamespace) &&
        Objects.equals(this.portMappings, action.portMappings) &&
        Objects.equals(this.publishExposedPorts, action.publishExposedPorts) &&
        Objects.equals(this.runInBackground, action.runInBackground) &&
        Objects.equals(this.timeout, action.timeout);
  }

  @Override
  public int hashCode() {
    return Objects.hash(alwaysRun, blockExternalNetwork, commands, containerName, credentials, disableImagePrefetch, disableStandardErrorCapture, enableFuse, encryptedEnvironment, entrypoint, environment, ignoreExitStatus, imageUri, labels, mounts, pidNamespace, portMappings, publishExposedPorts, runInBackground, timeout);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Action {\n");
    sb.append("    alwaysRun: ").append(toIndentedString(alwaysRun)).append("\n");
    sb.append("    blockExternalNetwork: ").append(toIndentedString(blockExternalNetwork)).append("\n");
    sb.append("    commands: ").append(toIndentedString(commands)).append("\n");
    sb.append("    containerName: ").append(toIndentedString(containerName)).append("\n");
    sb.append("    credentials: ").append(toIndentedString(credentials)).append("\n");
    sb.append("    disableImagePrefetch: ").append(toIndentedString(disableImagePrefetch)).append("\n");
    sb.append("    disableStandardErrorCapture: ").append(toIndentedString(disableStandardErrorCapture)).append("\n");
    sb.append("    enableFuse: ").append(toIndentedString(enableFuse)).append("\n");
    sb.append("    encryptedEnvironment: ").append(toIndentedString(encryptedEnvironment)).append("\n");
    sb.append("    entrypoint: ").append(toIndentedString(entrypoint)).append("\n");
    sb.append("    environment: ").append(toIndentedString(environment)).append("\n");
    sb.append("    ignoreExitStatus: ").append(toIndentedString(ignoreExitStatus)).append("\n");
    sb.append("    imageUri: ").append(toIndentedString(imageUri)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    mounts: ").append(toIndentedString(mounts)).append("\n");
    sb.append("    pidNamespace: ").append(toIndentedString(pidNamespace)).append("\n");
    sb.append("    portMappings: ").append(toIndentedString(portMappings)).append("\n");
    sb.append("    publishExposedPorts: ").append(toIndentedString(publishExposedPorts)).append("\n");
    sb.append("    runInBackground: ").append(toIndentedString(runInBackground)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("alwaysRun");
    openapiFields.add("blockExternalNetwork");
    openapiFields.add("commands");
    openapiFields.add("containerName");
    openapiFields.add("credentials");
    openapiFields.add("disableImagePrefetch");
    openapiFields.add("disableStandardErrorCapture");
    openapiFields.add("enableFuse");
    openapiFields.add("encryptedEnvironment");
    openapiFields.add("entrypoint");
    openapiFields.add("environment");
    openapiFields.add("ignoreExitStatus");
    openapiFields.add("imageUri");
    openapiFields.add("labels");
    openapiFields.add("mounts");
    openapiFields.add("pidNamespace");
    openapiFields.add("portMappings");
    openapiFields.add("publishExposedPorts");
    openapiFields.add("runInBackground");
    openapiFields.add("timeout");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Action
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Action.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Action is not found in the empty JSON string", Action.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Action.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Action` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("commands") != null && !jsonObj.get("commands").isJsonNull() && !jsonObj.get("commands").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `commands` to be an array in the JSON string but got `%s`", jsonObj.get("commands").toString()));
      }
      if ((jsonObj.get("containerName") != null && !jsonObj.get("containerName").isJsonNull()) && !jsonObj.get("containerName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `containerName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("containerName").toString()));
      }
      // validate the optional field `credentials`
      if (jsonObj.get("credentials") != null && !jsonObj.get("credentials").isJsonNull()) {
        Secret.validateJsonElement(jsonObj.get("credentials"));
      }
      // validate the optional field `encryptedEnvironment`
      if (jsonObj.get("encryptedEnvironment") != null && !jsonObj.get("encryptedEnvironment").isJsonNull()) {
        Secret.validateJsonElement(jsonObj.get("encryptedEnvironment"));
      }
      if ((jsonObj.get("entrypoint") != null && !jsonObj.get("entrypoint").isJsonNull()) && !jsonObj.get("entrypoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entrypoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entrypoint").toString()));
      }
      if ((jsonObj.get("imageUri") != null && !jsonObj.get("imageUri").isJsonNull()) && !jsonObj.get("imageUri").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `imageUri` to be a primitive type in the JSON string but got `%s`", jsonObj.get("imageUri").toString()));
      }
      if (jsonObj.get("mounts") != null && !jsonObj.get("mounts").isJsonNull()) {
        JsonArray jsonArraymounts = jsonObj.getAsJsonArray("mounts");
        if (jsonArraymounts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("mounts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `mounts` to be an array in the JSON string but got `%s`", jsonObj.get("mounts").toString()));
          }

          // validate the optional field `mounts` (array)
          for (int i = 0; i < jsonArraymounts.size(); i++) {
            Mount.validateJsonElement(jsonArraymounts.get(i));
          };
        }
      }
      if ((jsonObj.get("pidNamespace") != null && !jsonObj.get("pidNamespace").isJsonNull()) && !jsonObj.get("pidNamespace").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `pidNamespace` to be a primitive type in the JSON string but got `%s`", jsonObj.get("pidNamespace").toString()));
      }
      if ((jsonObj.get("timeout") != null && !jsonObj.get("timeout").isJsonNull()) && !jsonObj.get("timeout").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timeout` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timeout").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Action.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Action' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Action> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Action.class));

       return (TypeAdapter<T>) new TypeAdapter<Action>() {
           @Override
           public void write(JsonWriter out, Action value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Action read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Action given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Action
   * @throws IOException if the JSON string is invalid with respect to Action
   */
  public static Action fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Action.class);
  }

  /**
   * Convert an instance of Action to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

