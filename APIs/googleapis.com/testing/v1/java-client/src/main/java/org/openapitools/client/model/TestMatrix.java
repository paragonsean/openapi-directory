/*
 * Cloud Testing API
 * Allows developers to run automated tests for their mobile applications on Google infrastructure.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ClientInfo;
import org.openapitools.client.model.EnvironmentMatrix;
import org.openapitools.client.model.MatrixErrorDetail;
import org.openapitools.client.model.ResultStorage;
import org.openapitools.client.model.TestExecution;
import org.openapitools.client.model.TestSpecification;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * TestMatrix captures all details about a test. It contains the environment configuration, test specification, test executions and overall state and outcome.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:42:25.957019-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class TestMatrix {
  public static final String SERIALIZED_NAME_CLIENT_INFO = "clientInfo";
  @SerializedName(SERIALIZED_NAME_CLIENT_INFO)
  private ClientInfo clientInfo;

  public static final String SERIALIZED_NAME_ENVIRONMENT_MATRIX = "environmentMatrix";
  @SerializedName(SERIALIZED_NAME_ENVIRONMENT_MATRIX)
  private EnvironmentMatrix environmentMatrix;

  public static final String SERIALIZED_NAME_EXTENDED_INVALID_MATRIX_DETAILS = "extendedInvalidMatrixDetails";
  @SerializedName(SERIALIZED_NAME_EXTENDED_INVALID_MATRIX_DETAILS)
  private List<MatrixErrorDetail> extendedInvalidMatrixDetails = new ArrayList<>();

  public static final String SERIALIZED_NAME_FAIL_FAST = "failFast";
  @SerializedName(SERIALIZED_NAME_FAIL_FAST)
  private Boolean failFast;

  public static final String SERIALIZED_NAME_FLAKY_TEST_ATTEMPTS = "flakyTestAttempts";
  @SerializedName(SERIALIZED_NAME_FLAKY_TEST_ATTEMPTS)
  private Integer flakyTestAttempts;

  /**
   * Output only. Describes why the matrix is considered invalid. Only useful for matrices in the INVALID state.
   */
  @JsonAdapter(InvalidMatrixDetailsEnum.Adapter.class)
  public enum InvalidMatrixDetailsEnum {
    INVALID_MATRIX_DETAILS_UNSPECIFIED("INVALID_MATRIX_DETAILS_UNSPECIFIED"),
    
    DETAILS_UNAVAILABLE("DETAILS_UNAVAILABLE"),
    
    MALFORMED_APK("MALFORMED_APK"),
    
    MALFORMED_TEST_APK("MALFORMED_TEST_APK"),
    
    NO_MANIFEST("NO_MANIFEST"),
    
    NO_PACKAGE_NAME("NO_PACKAGE_NAME"),
    
    INVALID_PACKAGE_NAME("INVALID_PACKAGE_NAME"),
    
    TEST_SAME_AS_APP("TEST_SAME_AS_APP"),
    
    NO_INSTRUMENTATION("NO_INSTRUMENTATION"),
    
    NO_SIGNATURE("NO_SIGNATURE"),
    
    INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE("INSTRUMENTATION_ORCHESTRATOR_INCOMPATIBLE"),
    
    NO_TEST_RUNNER_CLASS("NO_TEST_RUNNER_CLASS"),
    
    NO_LAUNCHER_ACTIVITY("NO_LAUNCHER_ACTIVITY"),
    
    FORBIDDEN_PERMISSIONS("FORBIDDEN_PERMISSIONS"),
    
    INVALID_ROBO_DIRECTIVES("INVALID_ROBO_DIRECTIVES"),
    
    INVALID_RESOURCE_NAME("INVALID_RESOURCE_NAME"),
    
    INVALID_DIRECTIVE_ACTION("INVALID_DIRECTIVE_ACTION"),
    
    TEST_LOOP_INTENT_FILTER_NOT_FOUND("TEST_LOOP_INTENT_FILTER_NOT_FOUND"),
    
    SCENARIO_LABEL_NOT_DECLARED("SCENARIO_LABEL_NOT_DECLARED"),
    
    SCENARIO_LABEL_MALFORMED("SCENARIO_LABEL_MALFORMED"),
    
    SCENARIO_NOT_DECLARED("SCENARIO_NOT_DECLARED"),
    
    DEVICE_ADMIN_RECEIVER("DEVICE_ADMIN_RECEIVER"),
    
    MALFORMED_XC_TEST_ZIP("MALFORMED_XC_TEST_ZIP"),
    
    BUILT_FOR_IOS_SIMULATOR("BUILT_FOR_IOS_SIMULATOR"),
    
    NO_TESTS_IN_XC_TEST_ZIP("NO_TESTS_IN_XC_TEST_ZIP"),
    
    USE_DESTINATION_ARTIFACTS("USE_DESTINATION_ARTIFACTS"),
    
    TEST_NOT_APP_HOSTED("TEST_NOT_APP_HOSTED"),
    
    PLIST_CANNOT_BE_PARSED("PLIST_CANNOT_BE_PARSED"),
    
    TEST_ONLY_APK("TEST_ONLY_APK"),
    
    MALFORMED_IPA("MALFORMED_IPA"),
    
    MISSING_URL_SCHEME("MISSING_URL_SCHEME"),
    
    MALFORMED_APP_BUNDLE("MALFORMED_APP_BUNDLE"),
    
    NO_CODE_APK("NO_CODE_APK"),
    
    INVALID_INPUT_APK("INVALID_INPUT_APK"),
    
    INVALID_APK_PREVIEW_SDK("INVALID_APK_PREVIEW_SDK"),
    
    MATRIX_TOO_LARGE("MATRIX_TOO_LARGE"),
    
    TEST_QUOTA_EXCEEDED("TEST_QUOTA_EXCEEDED"),
    
    SERVICE_NOT_ACTIVATED("SERVICE_NOT_ACTIVATED"),
    
    UNKNOWN_PERMISSION_ERROR("UNKNOWN_PERMISSION_ERROR");

    private String value;

    InvalidMatrixDetailsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static InvalidMatrixDetailsEnum fromValue(String value) {
      for (InvalidMatrixDetailsEnum b : InvalidMatrixDetailsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<InvalidMatrixDetailsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InvalidMatrixDetailsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public InvalidMatrixDetailsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return InvalidMatrixDetailsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      InvalidMatrixDetailsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_INVALID_MATRIX_DETAILS = "invalidMatrixDetails";
  @SerializedName(SERIALIZED_NAME_INVALID_MATRIX_DETAILS)
  private InvalidMatrixDetailsEnum invalidMatrixDetails;

  /**
   * Output Only. The overall outcome of the test. Only set when the test matrix state is FINISHED.
   */
  @JsonAdapter(OutcomeSummaryEnum.Adapter.class)
  public enum OutcomeSummaryEnum {
    OUTCOME_SUMMARY_UNSPECIFIED("OUTCOME_SUMMARY_UNSPECIFIED"),
    
    SUCCESS("SUCCESS"),
    
    FAILURE("FAILURE"),
    
    INCONCLUSIVE("INCONCLUSIVE"),
    
    SKIPPED("SKIPPED");

    private String value;

    OutcomeSummaryEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OutcomeSummaryEnum fromValue(String value) {
      for (OutcomeSummaryEnum b : OutcomeSummaryEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<OutcomeSummaryEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OutcomeSummaryEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OutcomeSummaryEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return OutcomeSummaryEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      OutcomeSummaryEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_OUTCOME_SUMMARY = "outcomeSummary";
  @SerializedName(SERIALIZED_NAME_OUTCOME_SUMMARY)
  private OutcomeSummaryEnum outcomeSummary;

  public static final String SERIALIZED_NAME_PROJECT_ID = "projectId";
  @SerializedName(SERIALIZED_NAME_PROJECT_ID)
  private String projectId;

  public static final String SERIALIZED_NAME_RESULT_STORAGE = "resultStorage";
  @SerializedName(SERIALIZED_NAME_RESULT_STORAGE)
  private ResultStorage resultStorage;

  /**
   * Output only. Indicates the current progress of the test matrix.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    TEST_STATE_UNSPECIFIED("TEST_STATE_UNSPECIFIED"),
    
    VALIDATING("VALIDATING"),
    
    PENDING("PENDING"),
    
    RUNNING("RUNNING"),
    
    FINISHED("FINISHED"),
    
    ERROR("ERROR"),
    
    UNSUPPORTED_ENVIRONMENT("UNSUPPORTED_ENVIRONMENT"),
    
    INCOMPATIBLE_ENVIRONMENT("INCOMPATIBLE_ENVIRONMENT"),
    
    INCOMPATIBLE_ARCHITECTURE("INCOMPATIBLE_ARCHITECTURE"),
    
    CANCELLED("CANCELLED"),
    
    INVALID("INVALID");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private StateEnum state;

  public static final String SERIALIZED_NAME_TEST_EXECUTIONS = "testExecutions";
  @SerializedName(SERIALIZED_NAME_TEST_EXECUTIONS)
  private List<TestExecution> testExecutions = new ArrayList<>();

  public static final String SERIALIZED_NAME_TEST_MATRIX_ID = "testMatrixId";
  @SerializedName(SERIALIZED_NAME_TEST_MATRIX_ID)
  private String testMatrixId;

  public static final String SERIALIZED_NAME_TEST_SPECIFICATION = "testSpecification";
  @SerializedName(SERIALIZED_NAME_TEST_SPECIFICATION)
  private TestSpecification testSpecification;

  public static final String SERIALIZED_NAME_TIMESTAMP = "timestamp";
  @SerializedName(SERIALIZED_NAME_TIMESTAMP)
  private String timestamp;

  public TestMatrix() {
  }

  public TestMatrix(
     List<MatrixErrorDetail> extendedInvalidMatrixDetails
  ) {
    this();
    this.extendedInvalidMatrixDetails = extendedInvalidMatrixDetails;
  }

  public TestMatrix clientInfo(ClientInfo clientInfo) {
    this.clientInfo = clientInfo;
    return this;
  }

  /**
   * Get clientInfo
   * @return clientInfo
   */
  @javax.annotation.Nullable
  public ClientInfo getClientInfo() {
    return clientInfo;
  }

  public void setClientInfo(ClientInfo clientInfo) {
    this.clientInfo = clientInfo;
  }


  public TestMatrix environmentMatrix(EnvironmentMatrix environmentMatrix) {
    this.environmentMatrix = environmentMatrix;
    return this;
  }

  /**
   * Get environmentMatrix
   * @return environmentMatrix
   */
  @javax.annotation.Nullable
  public EnvironmentMatrix getEnvironmentMatrix() {
    return environmentMatrix;
  }

  public void setEnvironmentMatrix(EnvironmentMatrix environmentMatrix) {
    this.environmentMatrix = environmentMatrix;
  }


  /**
   * Output only. Details about why a matrix was deemed invalid. If multiple checks can be safely performed, they will be reported but no assumptions should be made about the length of this list.
   * @return extendedInvalidMatrixDetails
   */
  @javax.annotation.Nullable
  public List<MatrixErrorDetail> getExtendedInvalidMatrixDetails() {
    return extendedInvalidMatrixDetails;
  }



  public TestMatrix failFast(Boolean failFast) {
    this.failFast = failFast;
    return this;
  }

  /**
   * If true, only a single attempt at most will be made to run each execution/shard in the matrix. Flaky test attempts are not affected. Normally, 2 or more attempts are made if a potential infrastructure issue is detected. This feature is for latency sensitive workloads. The incidence of execution failures may be significantly greater for fail-fast matrices and support is more limited because of that expectation.
   * @return failFast
   */
  @javax.annotation.Nullable
  public Boolean getFailFast() {
    return failFast;
  }

  public void setFailFast(Boolean failFast) {
    this.failFast = failFast;
  }


  public TestMatrix flakyTestAttempts(Integer flakyTestAttempts) {
    this.flakyTestAttempts = flakyTestAttempts;
    return this;
  }

  /**
   * The number of times a TestExecution should be re-attempted if one or more of its test cases fail for any reason. The maximum number of reruns allowed is 10. Default is 0, which implies no reruns.
   * @return flakyTestAttempts
   */
  @javax.annotation.Nullable
  public Integer getFlakyTestAttempts() {
    return flakyTestAttempts;
  }

  public void setFlakyTestAttempts(Integer flakyTestAttempts) {
    this.flakyTestAttempts = flakyTestAttempts;
  }


  public TestMatrix invalidMatrixDetails(InvalidMatrixDetailsEnum invalidMatrixDetails) {
    this.invalidMatrixDetails = invalidMatrixDetails;
    return this;
  }

  /**
   * Output only. Describes why the matrix is considered invalid. Only useful for matrices in the INVALID state.
   * @return invalidMatrixDetails
   */
  @javax.annotation.Nullable
  public InvalidMatrixDetailsEnum getInvalidMatrixDetails() {
    return invalidMatrixDetails;
  }

  public void setInvalidMatrixDetails(InvalidMatrixDetailsEnum invalidMatrixDetails) {
    this.invalidMatrixDetails = invalidMatrixDetails;
  }


  public TestMatrix outcomeSummary(OutcomeSummaryEnum outcomeSummary) {
    this.outcomeSummary = outcomeSummary;
    return this;
  }

  /**
   * Output Only. The overall outcome of the test. Only set when the test matrix state is FINISHED.
   * @return outcomeSummary
   */
  @javax.annotation.Nullable
  public OutcomeSummaryEnum getOutcomeSummary() {
    return outcomeSummary;
  }

  public void setOutcomeSummary(OutcomeSummaryEnum outcomeSummary) {
    this.outcomeSummary = outcomeSummary;
  }


  public TestMatrix projectId(String projectId) {
    this.projectId = projectId;
    return this;
  }

  /**
   * The cloud project that owns the test matrix.
   * @return projectId
   */
  @javax.annotation.Nullable
  public String getProjectId() {
    return projectId;
  }

  public void setProjectId(String projectId) {
    this.projectId = projectId;
  }


  public TestMatrix resultStorage(ResultStorage resultStorage) {
    this.resultStorage = resultStorage;
    return this;
  }

  /**
   * Get resultStorage
   * @return resultStorage
   */
  @javax.annotation.Nullable
  public ResultStorage getResultStorage() {
    return resultStorage;
  }

  public void setResultStorage(ResultStorage resultStorage) {
    this.resultStorage = resultStorage;
  }


  public TestMatrix state(StateEnum state) {
    this.state = state;
    return this;
  }

  /**
   * Output only. Indicates the current progress of the test matrix.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }

  public void setState(StateEnum state) {
    this.state = state;
  }


  public TestMatrix testExecutions(List<TestExecution> testExecutions) {
    this.testExecutions = testExecutions;
    return this;
  }

  public TestMatrix addTestExecutionsItem(TestExecution testExecutionsItem) {
    if (this.testExecutions == null) {
      this.testExecutions = new ArrayList<>();
    }
    this.testExecutions.add(testExecutionsItem);
    return this;
  }

  /**
   * Output only. The list of test executions that the service creates for this matrix.
   * @return testExecutions
   */
  @javax.annotation.Nullable
  public List<TestExecution> getTestExecutions() {
    return testExecutions;
  }

  public void setTestExecutions(List<TestExecution> testExecutions) {
    this.testExecutions = testExecutions;
  }


  public TestMatrix testMatrixId(String testMatrixId) {
    this.testMatrixId = testMatrixId;
    return this;
  }

  /**
   * Output only. Unique id set by the service.
   * @return testMatrixId
   */
  @javax.annotation.Nullable
  public String getTestMatrixId() {
    return testMatrixId;
  }

  public void setTestMatrixId(String testMatrixId) {
    this.testMatrixId = testMatrixId;
  }


  public TestMatrix testSpecification(TestSpecification testSpecification) {
    this.testSpecification = testSpecification;
    return this;
  }

  /**
   * Get testSpecification
   * @return testSpecification
   */
  @javax.annotation.Nullable
  public TestSpecification getTestSpecification() {
    return testSpecification;
  }

  public void setTestSpecification(TestSpecification testSpecification) {
    this.testSpecification = testSpecification;
  }


  public TestMatrix timestamp(String timestamp) {
    this.timestamp = timestamp;
    return this;
  }

  /**
   * Output only. The time this test matrix was initially created.
   * @return timestamp
   */
  @javax.annotation.Nullable
  public String getTimestamp() {
    return timestamp;
  }

  public void setTimestamp(String timestamp) {
    this.timestamp = timestamp;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestMatrix testMatrix = (TestMatrix) o;
    return Objects.equals(this.clientInfo, testMatrix.clientInfo) &&
        Objects.equals(this.environmentMatrix, testMatrix.environmentMatrix) &&
        Objects.equals(this.extendedInvalidMatrixDetails, testMatrix.extendedInvalidMatrixDetails) &&
        Objects.equals(this.failFast, testMatrix.failFast) &&
        Objects.equals(this.flakyTestAttempts, testMatrix.flakyTestAttempts) &&
        Objects.equals(this.invalidMatrixDetails, testMatrix.invalidMatrixDetails) &&
        Objects.equals(this.outcomeSummary, testMatrix.outcomeSummary) &&
        Objects.equals(this.projectId, testMatrix.projectId) &&
        Objects.equals(this.resultStorage, testMatrix.resultStorage) &&
        Objects.equals(this.state, testMatrix.state) &&
        Objects.equals(this.testExecutions, testMatrix.testExecutions) &&
        Objects.equals(this.testMatrixId, testMatrix.testMatrixId) &&
        Objects.equals(this.testSpecification, testMatrix.testSpecification) &&
        Objects.equals(this.timestamp, testMatrix.timestamp);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientInfo, environmentMatrix, extendedInvalidMatrixDetails, failFast, flakyTestAttempts, invalidMatrixDetails, outcomeSummary, projectId, resultStorage, state, testExecutions, testMatrixId, testSpecification, timestamp);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestMatrix {\n");
    sb.append("    clientInfo: ").append(toIndentedString(clientInfo)).append("\n");
    sb.append("    environmentMatrix: ").append(toIndentedString(environmentMatrix)).append("\n");
    sb.append("    extendedInvalidMatrixDetails: ").append(toIndentedString(extendedInvalidMatrixDetails)).append("\n");
    sb.append("    failFast: ").append(toIndentedString(failFast)).append("\n");
    sb.append("    flakyTestAttempts: ").append(toIndentedString(flakyTestAttempts)).append("\n");
    sb.append("    invalidMatrixDetails: ").append(toIndentedString(invalidMatrixDetails)).append("\n");
    sb.append("    outcomeSummary: ").append(toIndentedString(outcomeSummary)).append("\n");
    sb.append("    projectId: ").append(toIndentedString(projectId)).append("\n");
    sb.append("    resultStorage: ").append(toIndentedString(resultStorage)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    testExecutions: ").append(toIndentedString(testExecutions)).append("\n");
    sb.append("    testMatrixId: ").append(toIndentedString(testMatrixId)).append("\n");
    sb.append("    testSpecification: ").append(toIndentedString(testSpecification)).append("\n");
    sb.append("    timestamp: ").append(toIndentedString(timestamp)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("clientInfo");
    openapiFields.add("environmentMatrix");
    openapiFields.add("extendedInvalidMatrixDetails");
    openapiFields.add("failFast");
    openapiFields.add("flakyTestAttempts");
    openapiFields.add("invalidMatrixDetails");
    openapiFields.add("outcomeSummary");
    openapiFields.add("projectId");
    openapiFields.add("resultStorage");
    openapiFields.add("state");
    openapiFields.add("testExecutions");
    openapiFields.add("testMatrixId");
    openapiFields.add("testSpecification");
    openapiFields.add("timestamp");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TestMatrix
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TestMatrix.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestMatrix is not found in the empty JSON string", TestMatrix.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TestMatrix.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TestMatrix` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `clientInfo`
      if (jsonObj.get("clientInfo") != null && !jsonObj.get("clientInfo").isJsonNull()) {
        ClientInfo.validateJsonElement(jsonObj.get("clientInfo"));
      }
      // validate the optional field `environmentMatrix`
      if (jsonObj.get("environmentMatrix") != null && !jsonObj.get("environmentMatrix").isJsonNull()) {
        EnvironmentMatrix.validateJsonElement(jsonObj.get("environmentMatrix"));
      }
      if (jsonObj.get("extendedInvalidMatrixDetails") != null && !jsonObj.get("extendedInvalidMatrixDetails").isJsonNull()) {
        JsonArray jsonArrayextendedInvalidMatrixDetails = jsonObj.getAsJsonArray("extendedInvalidMatrixDetails");
        if (jsonArrayextendedInvalidMatrixDetails != null) {
          // ensure the json data is an array
          if (!jsonObj.get("extendedInvalidMatrixDetails").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `extendedInvalidMatrixDetails` to be an array in the JSON string but got `%s`", jsonObj.get("extendedInvalidMatrixDetails").toString()));
          }

          // validate the optional field `extendedInvalidMatrixDetails` (array)
          for (int i = 0; i < jsonArrayextendedInvalidMatrixDetails.size(); i++) {
            MatrixErrorDetail.validateJsonElement(jsonArrayextendedInvalidMatrixDetails.get(i));
          };
        }
      }
      if ((jsonObj.get("invalidMatrixDetails") != null && !jsonObj.get("invalidMatrixDetails").isJsonNull()) && !jsonObj.get("invalidMatrixDetails").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `invalidMatrixDetails` to be a primitive type in the JSON string but got `%s`", jsonObj.get("invalidMatrixDetails").toString()));
      }
      // validate the optional field `invalidMatrixDetails`
      if (jsonObj.get("invalidMatrixDetails") != null && !jsonObj.get("invalidMatrixDetails").isJsonNull()) {
        InvalidMatrixDetailsEnum.validateJsonElement(jsonObj.get("invalidMatrixDetails"));
      }
      if ((jsonObj.get("outcomeSummary") != null && !jsonObj.get("outcomeSummary").isJsonNull()) && !jsonObj.get("outcomeSummary").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outcomeSummary` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outcomeSummary").toString()));
      }
      // validate the optional field `outcomeSummary`
      if (jsonObj.get("outcomeSummary") != null && !jsonObj.get("outcomeSummary").isJsonNull()) {
        OutcomeSummaryEnum.validateJsonElement(jsonObj.get("outcomeSummary"));
      }
      if ((jsonObj.get("projectId") != null && !jsonObj.get("projectId").isJsonNull()) && !jsonObj.get("projectId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `projectId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("projectId").toString()));
      }
      // validate the optional field `resultStorage`
      if (jsonObj.get("resultStorage") != null && !jsonObj.get("resultStorage").isJsonNull()) {
        ResultStorage.validateJsonElement(jsonObj.get("resultStorage"));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if (jsonObj.get("testExecutions") != null && !jsonObj.get("testExecutions").isJsonNull()) {
        JsonArray jsonArraytestExecutions = jsonObj.getAsJsonArray("testExecutions");
        if (jsonArraytestExecutions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("testExecutions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `testExecutions` to be an array in the JSON string but got `%s`", jsonObj.get("testExecutions").toString()));
          }

          // validate the optional field `testExecutions` (array)
          for (int i = 0; i < jsonArraytestExecutions.size(); i++) {
            TestExecution.validateJsonElement(jsonArraytestExecutions.get(i));
          };
        }
      }
      if ((jsonObj.get("testMatrixId") != null && !jsonObj.get("testMatrixId").isJsonNull()) && !jsonObj.get("testMatrixId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `testMatrixId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("testMatrixId").toString()));
      }
      // validate the optional field `testSpecification`
      if (jsonObj.get("testSpecification") != null && !jsonObj.get("testSpecification").isJsonNull()) {
        TestSpecification.validateJsonElement(jsonObj.get("testSpecification"));
      }
      if ((jsonObj.get("timestamp") != null && !jsonObj.get("timestamp").isJsonNull()) && !jsonObj.get("timestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `timestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("timestamp").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestMatrix.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestMatrix' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestMatrix> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestMatrix.class));

       return (TypeAdapter<T>) new TypeAdapter<TestMatrix>() {
           @Override
           public void write(JsonWriter out, TestMatrix value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestMatrix read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TestMatrix given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TestMatrix
   * @throws IOException if the JSON string is invalid with respect to TestMatrix
   */
  public static TestMatrix fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestMatrix.class);
  }

  /**
   * Convert an instance of TestMatrix to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

