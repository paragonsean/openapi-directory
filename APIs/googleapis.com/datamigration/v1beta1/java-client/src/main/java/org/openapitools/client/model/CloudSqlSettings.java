/*
 * Database Migration API
 * Manage Cloud Database Migration Service resources on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1beta1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.SqlIpConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Settings for creating a Cloud SQL database instance.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:43.025180-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class CloudSqlSettings {
  /**
   * The activation policy specifies when the instance is activated; it is applicable only when the instance state is &#39;RUNNABLE&#39;. Valid values: &#39;ALWAYS&#39;: The instance is on, and remains so even in the absence of connection requests. &#x60;NEVER&#x60;: The instance is off; it is not activated, even if a connection request arrives.
   */
  @JsonAdapter(ActivationPolicyEnum.Adapter.class)
  public enum ActivationPolicyEnum {
    SQL_ACTIVATION_POLICY_UNSPECIFIED("SQL_ACTIVATION_POLICY_UNSPECIFIED"),
    
    ALWAYS("ALWAYS"),
    
    NEVER("NEVER");

    private String value;

    ActivationPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ActivationPolicyEnum fromValue(String value) {
      for (ActivationPolicyEnum b : ActivationPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ActivationPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ActivationPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ActivationPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ActivationPolicyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ActivationPolicyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ACTIVATION_POLICY = "activationPolicy";
  @SerializedName(SERIALIZED_NAME_ACTIVATION_POLICY)
  private ActivationPolicyEnum activationPolicy;

  public static final String SERIALIZED_NAME_AUTO_STORAGE_INCREASE = "autoStorageIncrease";
  @SerializedName(SERIALIZED_NAME_AUTO_STORAGE_INCREASE)
  private Boolean autoStorageIncrease;

  public static final String SERIALIZED_NAME_DATA_DISK_SIZE_GB = "dataDiskSizeGb";
  @SerializedName(SERIALIZED_NAME_DATA_DISK_SIZE_GB)
  private String dataDiskSizeGb;

  /**
   * The type of storage: &#x60;PD_SSD&#x60; (default) or &#x60;PD_HDD&#x60;.
   */
  @JsonAdapter(DataDiskTypeEnum.Adapter.class)
  public enum DataDiskTypeEnum {
    SQL_DATA_DISK_TYPE_UNSPECIFIED("SQL_DATA_DISK_TYPE_UNSPECIFIED"),
    
    PD_SSD("PD_SSD"),
    
    PD_HDD("PD_HDD");

    private String value;

    DataDiskTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataDiskTypeEnum fromValue(String value) {
      for (DataDiskTypeEnum b : DataDiskTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DataDiskTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataDiskTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataDiskTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataDiskTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DataDiskTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATA_DISK_TYPE = "dataDiskType";
  @SerializedName(SERIALIZED_NAME_DATA_DISK_TYPE)
  private DataDiskTypeEnum dataDiskType;

  public static final String SERIALIZED_NAME_DATABASE_FLAGS = "databaseFlags";
  @SerializedName(SERIALIZED_NAME_DATABASE_FLAGS)
  private Map<String, String> databaseFlags = new HashMap<>();

  /**
   * The database engine type and version.
   */
  @JsonAdapter(DatabaseVersionEnum.Adapter.class)
  public enum DatabaseVersionEnum {
    SQL_DATABASE_VERSION_UNSPECIFIED("SQL_DATABASE_VERSION_UNSPECIFIED"),
    
    MYSQL_5_6("MYSQL_5_6"),
    
    MYSQL_5_7("MYSQL_5_7"),
    
    MYSQL_8_0("MYSQL_8_0");

    private String value;

    DatabaseVersionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DatabaseVersionEnum fromValue(String value) {
      for (DatabaseVersionEnum b : DatabaseVersionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DatabaseVersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DatabaseVersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DatabaseVersionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DatabaseVersionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DatabaseVersionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATABASE_VERSION = "databaseVersion";
  @SerializedName(SERIALIZED_NAME_DATABASE_VERSION)
  private DatabaseVersionEnum databaseVersion;

  public static final String SERIALIZED_NAME_IP_CONFIG = "ipConfig";
  @SerializedName(SERIALIZED_NAME_IP_CONFIG)
  private SqlIpConfig ipConfig;

  public static final String SERIALIZED_NAME_ROOT_PASSWORD = "rootPassword";
  @SerializedName(SERIALIZED_NAME_ROOT_PASSWORD)
  private String rootPassword;

  public static final String SERIALIZED_NAME_ROOT_PASSWORD_SET = "rootPasswordSet";
  @SerializedName(SERIALIZED_NAME_ROOT_PASSWORD_SET)
  private Boolean rootPasswordSet;

  public static final String SERIALIZED_NAME_SOURCE_ID = "sourceId";
  @SerializedName(SERIALIZED_NAME_SOURCE_ID)
  private String sourceId;

  public static final String SERIALIZED_NAME_STORAGE_AUTO_RESIZE_LIMIT = "storageAutoResizeLimit";
  @SerializedName(SERIALIZED_NAME_STORAGE_AUTO_RESIZE_LIMIT)
  private String storageAutoResizeLimit;

  public static final String SERIALIZED_NAME_TIER = "tier";
  @SerializedName(SERIALIZED_NAME_TIER)
  private String tier;

  public static final String SERIALIZED_NAME_USER_LABELS = "userLabels";
  @SerializedName(SERIALIZED_NAME_USER_LABELS)
  private Map<String, String> userLabels = new HashMap<>();

  public static final String SERIALIZED_NAME_ZONE = "zone";
  @SerializedName(SERIALIZED_NAME_ZONE)
  private String zone;

  public CloudSqlSettings() {
  }

  public CloudSqlSettings(
     Boolean rootPasswordSet
  ) {
    this();
    this.rootPasswordSet = rootPasswordSet;
  }

  public CloudSqlSettings activationPolicy(ActivationPolicyEnum activationPolicy) {
    this.activationPolicy = activationPolicy;
    return this;
  }

  /**
   * The activation policy specifies when the instance is activated; it is applicable only when the instance state is &#39;RUNNABLE&#39;. Valid values: &#39;ALWAYS&#39;: The instance is on, and remains so even in the absence of connection requests. &#x60;NEVER&#x60;: The instance is off; it is not activated, even if a connection request arrives.
   * @return activationPolicy
   */
  @javax.annotation.Nullable
  public ActivationPolicyEnum getActivationPolicy() {
    return activationPolicy;
  }

  public void setActivationPolicy(ActivationPolicyEnum activationPolicy) {
    this.activationPolicy = activationPolicy;
  }


  public CloudSqlSettings autoStorageIncrease(Boolean autoStorageIncrease) {
    this.autoStorageIncrease = autoStorageIncrease;
    return this;
  }

  /**
   * [default: ON] If you enable this setting, Cloud SQL checks your available storage every 30 seconds. If the available storage falls below a threshold size, Cloud SQL automatically adds additional storage capacity. If the available storage repeatedly falls below the threshold size, Cloud SQL continues to add storage until it reaches the maximum of 30 TB.
   * @return autoStorageIncrease
   */
  @javax.annotation.Nullable
  public Boolean getAutoStorageIncrease() {
    return autoStorageIncrease;
  }

  public void setAutoStorageIncrease(Boolean autoStorageIncrease) {
    this.autoStorageIncrease = autoStorageIncrease;
  }


  public CloudSqlSettings dataDiskSizeGb(String dataDiskSizeGb) {
    this.dataDiskSizeGb = dataDiskSizeGb;
    return this;
  }

  /**
   * The storage capacity available to the database, in GB. The minimum (and default) size is 10GB.
   * @return dataDiskSizeGb
   */
  @javax.annotation.Nullable
  public String getDataDiskSizeGb() {
    return dataDiskSizeGb;
  }

  public void setDataDiskSizeGb(String dataDiskSizeGb) {
    this.dataDiskSizeGb = dataDiskSizeGb;
  }


  public CloudSqlSettings dataDiskType(DataDiskTypeEnum dataDiskType) {
    this.dataDiskType = dataDiskType;
    return this;
  }

  /**
   * The type of storage: &#x60;PD_SSD&#x60; (default) or &#x60;PD_HDD&#x60;.
   * @return dataDiskType
   */
  @javax.annotation.Nullable
  public DataDiskTypeEnum getDataDiskType() {
    return dataDiskType;
  }

  public void setDataDiskType(DataDiskTypeEnum dataDiskType) {
    this.dataDiskType = dataDiskType;
  }


  public CloudSqlSettings databaseFlags(Map<String, String> databaseFlags) {
    this.databaseFlags = databaseFlags;
    return this;
  }

  public CloudSqlSettings putDatabaseFlagsItem(String key, String databaseFlagsItem) {
    if (this.databaseFlags == null) {
      this.databaseFlags = new HashMap<>();
    }
    this.databaseFlags.put(key, databaseFlagsItem);
    return this;
  }

  /**
   * The database flags passed to the Cloud SQL instance at startup. An object containing a list of \&quot;key\&quot;: value pairs. Example: { \&quot;name\&quot;: \&quot;wrench\&quot;, \&quot;mass\&quot;: \&quot;1.3kg\&quot;, \&quot;count\&quot;: \&quot;3\&quot; }.
   * @return databaseFlags
   */
  @javax.annotation.Nullable
  public Map<String, String> getDatabaseFlags() {
    return databaseFlags;
  }

  public void setDatabaseFlags(Map<String, String> databaseFlags) {
    this.databaseFlags = databaseFlags;
  }


  public CloudSqlSettings databaseVersion(DatabaseVersionEnum databaseVersion) {
    this.databaseVersion = databaseVersion;
    return this;
  }

  /**
   * The database engine type and version.
   * @return databaseVersion
   */
  @javax.annotation.Nullable
  public DatabaseVersionEnum getDatabaseVersion() {
    return databaseVersion;
  }

  public void setDatabaseVersion(DatabaseVersionEnum databaseVersion) {
    this.databaseVersion = databaseVersion;
  }


  public CloudSqlSettings ipConfig(SqlIpConfig ipConfig) {
    this.ipConfig = ipConfig;
    return this;
  }

  /**
   * Get ipConfig
   * @return ipConfig
   */
  @javax.annotation.Nullable
  public SqlIpConfig getIpConfig() {
    return ipConfig;
  }

  public void setIpConfig(SqlIpConfig ipConfig) {
    this.ipConfig = ipConfig;
  }


  public CloudSqlSettings rootPassword(String rootPassword) {
    this.rootPassword = rootPassword;
    return this;
  }

  /**
   * Input only. Initial root password.
   * @return rootPassword
   */
  @javax.annotation.Nullable
  public String getRootPassword() {
    return rootPassword;
  }

  public void setRootPassword(String rootPassword) {
    this.rootPassword = rootPassword;
  }


  /**
   * Output only. Indicates If this connection profile root password is stored.
   * @return rootPasswordSet
   */
  @javax.annotation.Nullable
  public Boolean getRootPasswordSet() {
    return rootPasswordSet;
  }



  public CloudSqlSettings sourceId(String sourceId) {
    this.sourceId = sourceId;
    return this;
  }

  /**
   * The Database Migration Service source connection profile ID, in the format: &#x60;projects/my_project_name/locations/us-central1/connectionProfiles/connection_profile_ID&#x60;
   * @return sourceId
   */
  @javax.annotation.Nullable
  public String getSourceId() {
    return sourceId;
  }

  public void setSourceId(String sourceId) {
    this.sourceId = sourceId;
  }


  public CloudSqlSettings storageAutoResizeLimit(String storageAutoResizeLimit) {
    this.storageAutoResizeLimit = storageAutoResizeLimit;
    return this;
  }

  /**
   * The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.
   * @return storageAutoResizeLimit
   */
  @javax.annotation.Nullable
  public String getStorageAutoResizeLimit() {
    return storageAutoResizeLimit;
  }

  public void setStorageAutoResizeLimit(String storageAutoResizeLimit) {
    this.storageAutoResizeLimit = storageAutoResizeLimit;
  }


  public CloudSqlSettings tier(String tier) {
    this.tier = tier;
    return this;
  }

  /**
   * The tier (or machine type) for this instance, for example: &#x60;db-n1-standard-1&#x60; (MySQL instances). For more information, see [Cloud SQL Instance Settings](https://cloud.google.com/sql/docs/mysql/instance-settings).
   * @return tier
   */
  @javax.annotation.Nullable
  public String getTier() {
    return tier;
  }

  public void setTier(String tier) {
    this.tier = tier;
  }


  public CloudSqlSettings userLabels(Map<String, String> userLabels) {
    this.userLabels = userLabels;
    return this;
  }

  public CloudSqlSettings putUserLabelsItem(String key, String userLabelsItem) {
    if (this.userLabels == null) {
      this.userLabels = new HashMap<>();
    }
    this.userLabels.put(key, userLabelsItem);
    return this;
  }

  /**
   * The resource labels for a Cloud SQL instance to use to annotate any related underlying resources such as Compute Engine VMs. An object containing a list of \&quot;key\&quot;: \&quot;value\&quot; pairs. Example: &#x60;{ \&quot;name\&quot;: \&quot;wrench\&quot;, \&quot;mass\&quot;: \&quot;18kg\&quot;, \&quot;count\&quot;: \&quot;3\&quot; }&#x60;.
   * @return userLabels
   */
  @javax.annotation.Nullable
  public Map<String, String> getUserLabels() {
    return userLabels;
  }

  public void setUserLabels(Map<String, String> userLabels) {
    this.userLabels = userLabels;
  }


  public CloudSqlSettings zone(String zone) {
    this.zone = zone;
    return this;
  }

  /**
   * The Google Cloud Platform zone where your Cloud SQL database instance is located.
   * @return zone
   */
  @javax.annotation.Nullable
  public String getZone() {
    return zone;
  }

  public void setZone(String zone) {
    this.zone = zone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CloudSqlSettings cloudSqlSettings = (CloudSqlSettings) o;
    return Objects.equals(this.activationPolicy, cloudSqlSettings.activationPolicy) &&
        Objects.equals(this.autoStorageIncrease, cloudSqlSettings.autoStorageIncrease) &&
        Objects.equals(this.dataDiskSizeGb, cloudSqlSettings.dataDiskSizeGb) &&
        Objects.equals(this.dataDiskType, cloudSqlSettings.dataDiskType) &&
        Objects.equals(this.databaseFlags, cloudSqlSettings.databaseFlags) &&
        Objects.equals(this.databaseVersion, cloudSqlSettings.databaseVersion) &&
        Objects.equals(this.ipConfig, cloudSqlSettings.ipConfig) &&
        Objects.equals(this.rootPassword, cloudSqlSettings.rootPassword) &&
        Objects.equals(this.rootPasswordSet, cloudSqlSettings.rootPasswordSet) &&
        Objects.equals(this.sourceId, cloudSqlSettings.sourceId) &&
        Objects.equals(this.storageAutoResizeLimit, cloudSqlSettings.storageAutoResizeLimit) &&
        Objects.equals(this.tier, cloudSqlSettings.tier) &&
        Objects.equals(this.userLabels, cloudSqlSettings.userLabels) &&
        Objects.equals(this.zone, cloudSqlSettings.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activationPolicy, autoStorageIncrease, dataDiskSizeGb, dataDiskType, databaseFlags, databaseVersion, ipConfig, rootPassword, rootPasswordSet, sourceId, storageAutoResizeLimit, tier, userLabels, zone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CloudSqlSettings {\n");
    sb.append("    activationPolicy: ").append(toIndentedString(activationPolicy)).append("\n");
    sb.append("    autoStorageIncrease: ").append(toIndentedString(autoStorageIncrease)).append("\n");
    sb.append("    dataDiskSizeGb: ").append(toIndentedString(dataDiskSizeGb)).append("\n");
    sb.append("    dataDiskType: ").append(toIndentedString(dataDiskType)).append("\n");
    sb.append("    databaseFlags: ").append(toIndentedString(databaseFlags)).append("\n");
    sb.append("    databaseVersion: ").append(toIndentedString(databaseVersion)).append("\n");
    sb.append("    ipConfig: ").append(toIndentedString(ipConfig)).append("\n");
    sb.append("    rootPassword: ").append(toIndentedString(rootPassword)).append("\n");
    sb.append("    rootPasswordSet: ").append(toIndentedString(rootPasswordSet)).append("\n");
    sb.append("    sourceId: ").append(toIndentedString(sourceId)).append("\n");
    sb.append("    storageAutoResizeLimit: ").append(toIndentedString(storageAutoResizeLimit)).append("\n");
    sb.append("    tier: ").append(toIndentedString(tier)).append("\n");
    sb.append("    userLabels: ").append(toIndentedString(userLabels)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("activationPolicy");
    openapiFields.add("autoStorageIncrease");
    openapiFields.add("dataDiskSizeGb");
    openapiFields.add("dataDiskType");
    openapiFields.add("databaseFlags");
    openapiFields.add("databaseVersion");
    openapiFields.add("ipConfig");
    openapiFields.add("rootPassword");
    openapiFields.add("rootPasswordSet");
    openapiFields.add("sourceId");
    openapiFields.add("storageAutoResizeLimit");
    openapiFields.add("tier");
    openapiFields.add("userLabels");
    openapiFields.add("zone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CloudSqlSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CloudSqlSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CloudSqlSettings is not found in the empty JSON string", CloudSqlSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CloudSqlSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CloudSqlSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("activationPolicy") != null && !jsonObj.get("activationPolicy").isJsonNull()) && !jsonObj.get("activationPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `activationPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("activationPolicy").toString()));
      }
      // validate the optional field `activationPolicy`
      if (jsonObj.get("activationPolicy") != null && !jsonObj.get("activationPolicy").isJsonNull()) {
        ActivationPolicyEnum.validateJsonElement(jsonObj.get("activationPolicy"));
      }
      if ((jsonObj.get("dataDiskSizeGb") != null && !jsonObj.get("dataDiskSizeGb").isJsonNull()) && !jsonObj.get("dataDiskSizeGb").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataDiskSizeGb` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataDiskSizeGb").toString()));
      }
      if ((jsonObj.get("dataDiskType") != null && !jsonObj.get("dataDiskType").isJsonNull()) && !jsonObj.get("dataDiskType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataDiskType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataDiskType").toString()));
      }
      // validate the optional field `dataDiskType`
      if (jsonObj.get("dataDiskType") != null && !jsonObj.get("dataDiskType").isJsonNull()) {
        DataDiskTypeEnum.validateJsonElement(jsonObj.get("dataDiskType"));
      }
      if ((jsonObj.get("databaseVersion") != null && !jsonObj.get("databaseVersion").isJsonNull()) && !jsonObj.get("databaseVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `databaseVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("databaseVersion").toString()));
      }
      // validate the optional field `databaseVersion`
      if (jsonObj.get("databaseVersion") != null && !jsonObj.get("databaseVersion").isJsonNull()) {
        DatabaseVersionEnum.validateJsonElement(jsonObj.get("databaseVersion"));
      }
      // validate the optional field `ipConfig`
      if (jsonObj.get("ipConfig") != null && !jsonObj.get("ipConfig").isJsonNull()) {
        SqlIpConfig.validateJsonElement(jsonObj.get("ipConfig"));
      }
      if ((jsonObj.get("rootPassword") != null && !jsonObj.get("rootPassword").isJsonNull()) && !jsonObj.get("rootPassword").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rootPassword` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rootPassword").toString()));
      }
      if ((jsonObj.get("sourceId") != null && !jsonObj.get("sourceId").isJsonNull()) && !jsonObj.get("sourceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceId").toString()));
      }
      if ((jsonObj.get("storageAutoResizeLimit") != null && !jsonObj.get("storageAutoResizeLimit").isJsonNull()) && !jsonObj.get("storageAutoResizeLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `storageAutoResizeLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("storageAutoResizeLimit").toString()));
      }
      if ((jsonObj.get("tier") != null && !jsonObj.get("tier").isJsonNull()) && !jsonObj.get("tier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tier").toString()));
      }
      if ((jsonObj.get("zone") != null && !jsonObj.get("zone").isJsonNull()) && !jsonObj.get("zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CloudSqlSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CloudSqlSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CloudSqlSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CloudSqlSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<CloudSqlSettings>() {
           @Override
           public void write(JsonWriter out, CloudSqlSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CloudSqlSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CloudSqlSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CloudSqlSettings
   * @throws IOException if the JSON string is invalid with respect to CloudSqlSettings
   */
  public static CloudSqlSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CloudSqlSettings.class);
  }

  /**
   * Convert an instance of CloudSqlSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

