/*
 * Database Migration API
 * Manage Cloud Database Migration Service resources on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.SourceNumericFilter;
import org.openapitools.client.model.SourceTextFilter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Options to configure rule type MultiColumnDatatypeChange. The rule is used to change the data type and associated properties of multiple columns at once. The rule filter field can refer to one or more entities. The rule scope can be one of:Column. This rule requires additional filters to be specified beyond the basic rule filter field, which is the source data type, but the rule supports additional filtering capabilities such as the minimum and maximum field length. All additional filters which are specified are required to be met in order for the rule to be applied (logical AND between the fields).
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:48.568084-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MultiColumnDatatypeChange {
  public static final String SERIALIZED_NAME_CUSTOM_FEATURES = "customFeatures";
  @SerializedName(SERIALIZED_NAME_CUSTOM_FEATURES)
  private Map<String, Object> customFeatures = new HashMap<>();

  public static final String SERIALIZED_NAME_NEW_DATA_TYPE = "newDataType";
  @SerializedName(SERIALIZED_NAME_NEW_DATA_TYPE)
  private String newDataType;

  public static final String SERIALIZED_NAME_OVERRIDE_FRACTIONAL_SECONDS_PRECISION = "overrideFractionalSecondsPrecision";
  @SerializedName(SERIALIZED_NAME_OVERRIDE_FRACTIONAL_SECONDS_PRECISION)
  private Integer overrideFractionalSecondsPrecision;

  public static final String SERIALIZED_NAME_OVERRIDE_LENGTH = "overrideLength";
  @SerializedName(SERIALIZED_NAME_OVERRIDE_LENGTH)
  private String overrideLength;

  public static final String SERIALIZED_NAME_OVERRIDE_PRECISION = "overridePrecision";
  @SerializedName(SERIALIZED_NAME_OVERRIDE_PRECISION)
  private Integer overridePrecision;

  public static final String SERIALIZED_NAME_OVERRIDE_SCALE = "overrideScale";
  @SerializedName(SERIALIZED_NAME_OVERRIDE_SCALE)
  private Integer overrideScale;

  public static final String SERIALIZED_NAME_SOURCE_DATA_TYPE_FILTER = "sourceDataTypeFilter";
  @SerializedName(SERIALIZED_NAME_SOURCE_DATA_TYPE_FILTER)
  private String sourceDataTypeFilter;

  public static final String SERIALIZED_NAME_SOURCE_NUMERIC_FILTER = "sourceNumericFilter";
  @SerializedName(SERIALIZED_NAME_SOURCE_NUMERIC_FILTER)
  private SourceNumericFilter sourceNumericFilter;

  public static final String SERIALIZED_NAME_SOURCE_TEXT_FILTER = "sourceTextFilter";
  @SerializedName(SERIALIZED_NAME_SOURCE_TEXT_FILTER)
  private SourceTextFilter sourceTextFilter;

  public MultiColumnDatatypeChange() {
  }

  public MultiColumnDatatypeChange customFeatures(Map<String, Object> customFeatures) {
    this.customFeatures = customFeatures;
    return this;
  }

  public MultiColumnDatatypeChange putCustomFeaturesItem(String key, Object customFeaturesItem) {
    if (this.customFeatures == null) {
      this.customFeatures = new HashMap<>();
    }
    this.customFeatures.put(key, customFeaturesItem);
    return this;
  }

  /**
   * Optional. Custom engine specific features.
   * @return customFeatures
   */
  @javax.annotation.Nullable
  public Map<String, Object> getCustomFeatures() {
    return customFeatures;
  }

  public void setCustomFeatures(Map<String, Object> customFeatures) {
    this.customFeatures = customFeatures;
  }


  public MultiColumnDatatypeChange newDataType(String newDataType) {
    this.newDataType = newDataType;
    return this;
  }

  /**
   * Required. New data type.
   * @return newDataType
   */
  @javax.annotation.Nullable
  public String getNewDataType() {
    return newDataType;
  }

  public void setNewDataType(String newDataType) {
    this.newDataType = newDataType;
  }


  public MultiColumnDatatypeChange overrideFractionalSecondsPrecision(Integer overrideFractionalSecondsPrecision) {
    this.overrideFractionalSecondsPrecision = overrideFractionalSecondsPrecision;
    return this;
  }

  /**
   * Optional. Column fractional seconds precision - used only for timestamp based datatypes - if not specified and relevant uses the source column fractional seconds precision.
   * @return overrideFractionalSecondsPrecision
   */
  @javax.annotation.Nullable
  public Integer getOverrideFractionalSecondsPrecision() {
    return overrideFractionalSecondsPrecision;
  }

  public void setOverrideFractionalSecondsPrecision(Integer overrideFractionalSecondsPrecision) {
    this.overrideFractionalSecondsPrecision = overrideFractionalSecondsPrecision;
  }


  public MultiColumnDatatypeChange overrideLength(String overrideLength) {
    this.overrideLength = overrideLength;
    return this;
  }

  /**
   * Optional. Column length - e.g. varchar (50) - if not specified and relevant uses the source column length.
   * @return overrideLength
   */
  @javax.annotation.Nullable
  public String getOverrideLength() {
    return overrideLength;
  }

  public void setOverrideLength(String overrideLength) {
    this.overrideLength = overrideLength;
  }


  public MultiColumnDatatypeChange overridePrecision(Integer overridePrecision) {
    this.overridePrecision = overridePrecision;
    return this;
  }

  /**
   * Optional. Column precision - when relevant - if not specified and relevant uses the source column precision.
   * @return overridePrecision
   */
  @javax.annotation.Nullable
  public Integer getOverridePrecision() {
    return overridePrecision;
  }

  public void setOverridePrecision(Integer overridePrecision) {
    this.overridePrecision = overridePrecision;
  }


  public MultiColumnDatatypeChange overrideScale(Integer overrideScale) {
    this.overrideScale = overrideScale;
    return this;
  }

  /**
   * Optional. Column scale - when relevant - if not specified and relevant uses the source column scale.
   * @return overrideScale
   */
  @javax.annotation.Nullable
  public Integer getOverrideScale() {
    return overrideScale;
  }

  public void setOverrideScale(Integer overrideScale) {
    this.overrideScale = overrideScale;
  }


  public MultiColumnDatatypeChange sourceDataTypeFilter(String sourceDataTypeFilter) {
    this.sourceDataTypeFilter = sourceDataTypeFilter;
    return this;
  }

  /**
   * Required. Filter on source data type.
   * @return sourceDataTypeFilter
   */
  @javax.annotation.Nullable
  public String getSourceDataTypeFilter() {
    return sourceDataTypeFilter;
  }

  public void setSourceDataTypeFilter(String sourceDataTypeFilter) {
    this.sourceDataTypeFilter = sourceDataTypeFilter;
  }


  public MultiColumnDatatypeChange sourceNumericFilter(SourceNumericFilter sourceNumericFilter) {
    this.sourceNumericFilter = sourceNumericFilter;
    return this;
  }

  /**
   * Get sourceNumericFilter
   * @return sourceNumericFilter
   */
  @javax.annotation.Nullable
  public SourceNumericFilter getSourceNumericFilter() {
    return sourceNumericFilter;
  }

  public void setSourceNumericFilter(SourceNumericFilter sourceNumericFilter) {
    this.sourceNumericFilter = sourceNumericFilter;
  }


  public MultiColumnDatatypeChange sourceTextFilter(SourceTextFilter sourceTextFilter) {
    this.sourceTextFilter = sourceTextFilter;
    return this;
  }

  /**
   * Get sourceTextFilter
   * @return sourceTextFilter
   */
  @javax.annotation.Nullable
  public SourceTextFilter getSourceTextFilter() {
    return sourceTextFilter;
  }

  public void setSourceTextFilter(SourceTextFilter sourceTextFilter) {
    this.sourceTextFilter = sourceTextFilter;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MultiColumnDatatypeChange multiColumnDatatypeChange = (MultiColumnDatatypeChange) o;
    return Objects.equals(this.customFeatures, multiColumnDatatypeChange.customFeatures) &&
        Objects.equals(this.newDataType, multiColumnDatatypeChange.newDataType) &&
        Objects.equals(this.overrideFractionalSecondsPrecision, multiColumnDatatypeChange.overrideFractionalSecondsPrecision) &&
        Objects.equals(this.overrideLength, multiColumnDatatypeChange.overrideLength) &&
        Objects.equals(this.overridePrecision, multiColumnDatatypeChange.overridePrecision) &&
        Objects.equals(this.overrideScale, multiColumnDatatypeChange.overrideScale) &&
        Objects.equals(this.sourceDataTypeFilter, multiColumnDatatypeChange.sourceDataTypeFilter) &&
        Objects.equals(this.sourceNumericFilter, multiColumnDatatypeChange.sourceNumericFilter) &&
        Objects.equals(this.sourceTextFilter, multiColumnDatatypeChange.sourceTextFilter);
  }

  @Override
  public int hashCode() {
    return Objects.hash(customFeatures, newDataType, overrideFractionalSecondsPrecision, overrideLength, overridePrecision, overrideScale, sourceDataTypeFilter, sourceNumericFilter, sourceTextFilter);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MultiColumnDatatypeChange {\n");
    sb.append("    customFeatures: ").append(toIndentedString(customFeatures)).append("\n");
    sb.append("    newDataType: ").append(toIndentedString(newDataType)).append("\n");
    sb.append("    overrideFractionalSecondsPrecision: ").append(toIndentedString(overrideFractionalSecondsPrecision)).append("\n");
    sb.append("    overrideLength: ").append(toIndentedString(overrideLength)).append("\n");
    sb.append("    overridePrecision: ").append(toIndentedString(overridePrecision)).append("\n");
    sb.append("    overrideScale: ").append(toIndentedString(overrideScale)).append("\n");
    sb.append("    sourceDataTypeFilter: ").append(toIndentedString(sourceDataTypeFilter)).append("\n");
    sb.append("    sourceNumericFilter: ").append(toIndentedString(sourceNumericFilter)).append("\n");
    sb.append("    sourceTextFilter: ").append(toIndentedString(sourceTextFilter)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("customFeatures");
    openapiFields.add("newDataType");
    openapiFields.add("overrideFractionalSecondsPrecision");
    openapiFields.add("overrideLength");
    openapiFields.add("overridePrecision");
    openapiFields.add("overrideScale");
    openapiFields.add("sourceDataTypeFilter");
    openapiFields.add("sourceNumericFilter");
    openapiFields.add("sourceTextFilter");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MultiColumnDatatypeChange
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MultiColumnDatatypeChange.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MultiColumnDatatypeChange is not found in the empty JSON string", MultiColumnDatatypeChange.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MultiColumnDatatypeChange.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MultiColumnDatatypeChange` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("newDataType") != null && !jsonObj.get("newDataType").isJsonNull()) && !jsonObj.get("newDataType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `newDataType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("newDataType").toString()));
      }
      if ((jsonObj.get("overrideLength") != null && !jsonObj.get("overrideLength").isJsonNull()) && !jsonObj.get("overrideLength").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `overrideLength` to be a primitive type in the JSON string but got `%s`", jsonObj.get("overrideLength").toString()));
      }
      if ((jsonObj.get("sourceDataTypeFilter") != null && !jsonObj.get("sourceDataTypeFilter").isJsonNull()) && !jsonObj.get("sourceDataTypeFilter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceDataTypeFilter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceDataTypeFilter").toString()));
      }
      // validate the optional field `sourceNumericFilter`
      if (jsonObj.get("sourceNumericFilter") != null && !jsonObj.get("sourceNumericFilter").isJsonNull()) {
        SourceNumericFilter.validateJsonElement(jsonObj.get("sourceNumericFilter"));
      }
      // validate the optional field `sourceTextFilter`
      if (jsonObj.get("sourceTextFilter") != null && !jsonObj.get("sourceTextFilter").isJsonNull()) {
        SourceTextFilter.validateJsonElement(jsonObj.get("sourceTextFilter"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MultiColumnDatatypeChange.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MultiColumnDatatypeChange' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MultiColumnDatatypeChange> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MultiColumnDatatypeChange.class));

       return (TypeAdapter<T>) new TypeAdapter<MultiColumnDatatypeChange>() {
           @Override
           public void write(JsonWriter out, MultiColumnDatatypeChange value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MultiColumnDatatypeChange read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MultiColumnDatatypeChange given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MultiColumnDatatypeChange
   * @throws IOException if the JSON string is invalid with respect to MultiColumnDatatypeChange
   */
  public static MultiColumnDatatypeChange fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MultiColumnDatatypeChange.class);
  }

  /**
   * Convert an instance of MultiColumnDatatypeChange to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

