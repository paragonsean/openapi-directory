/*
 * Database Migration API
 * Manage Cloud Database Migration Service resources on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.ApplyHash;
import org.openapitools.client.model.AssignSpecificValue;
import org.openapitools.client.model.DoubleComparisonFilter;
import org.openapitools.client.model.IntComparisonFilter;
import org.openapitools.client.model.RoundToScale;
import org.openapitools.client.model.ValueListFilter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Description of data transformation during migration as part of the ConditionalColumnSetValue.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:48.568084-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ValueTransformation {
  public static final String SERIALIZED_NAME_APPLY_HASH = "applyHash";
  @SerializedName(SERIALIZED_NAME_APPLY_HASH)
  private ApplyHash applyHash;

  public static final String SERIALIZED_NAME_ASSIGN_MAX_VALUE = "assignMaxValue";
  @SerializedName(SERIALIZED_NAME_ASSIGN_MAX_VALUE)
  private Object assignMaxValue;

  public static final String SERIALIZED_NAME_ASSIGN_MIN_VALUE = "assignMinValue";
  @SerializedName(SERIALIZED_NAME_ASSIGN_MIN_VALUE)
  private Object assignMinValue;

  public static final String SERIALIZED_NAME_ASSIGN_NULL = "assignNull";
  @SerializedName(SERIALIZED_NAME_ASSIGN_NULL)
  private Object assignNull;

  public static final String SERIALIZED_NAME_ASSIGN_SPECIFIC_VALUE = "assignSpecificValue";
  @SerializedName(SERIALIZED_NAME_ASSIGN_SPECIFIC_VALUE)
  private AssignSpecificValue assignSpecificValue;

  public static final String SERIALIZED_NAME_DOUBLE_COMPARISON = "doubleComparison";
  @SerializedName(SERIALIZED_NAME_DOUBLE_COMPARISON)
  private DoubleComparisonFilter doubleComparison;

  public static final String SERIALIZED_NAME_INT_COMPARISON = "intComparison";
  @SerializedName(SERIALIZED_NAME_INT_COMPARISON)
  private IntComparisonFilter intComparison;

  public static final String SERIALIZED_NAME_IS_NULL = "isNull";
  @SerializedName(SERIALIZED_NAME_IS_NULL)
  private Object isNull;

  public static final String SERIALIZED_NAME_ROUND_SCALE = "roundScale";
  @SerializedName(SERIALIZED_NAME_ROUND_SCALE)
  private RoundToScale roundScale;

  public static final String SERIALIZED_NAME_VALUE_LIST = "valueList";
  @SerializedName(SERIALIZED_NAME_VALUE_LIST)
  private ValueListFilter valueList;

  public ValueTransformation() {
  }

  public ValueTransformation applyHash(ApplyHash applyHash) {
    this.applyHash = applyHash;
    return this;
  }

  /**
   * Get applyHash
   * @return applyHash
   */
  @javax.annotation.Nullable
  public ApplyHash getApplyHash() {
    return applyHash;
  }

  public void setApplyHash(ApplyHash applyHash) {
    this.applyHash = applyHash;
  }


  public ValueTransformation assignMaxValue(Object assignMaxValue) {
    this.assignMaxValue = assignMaxValue;
    return this;
  }

  /**
   * A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
   * @return assignMaxValue
   */
  @javax.annotation.Nullable
  public Object getAssignMaxValue() {
    return assignMaxValue;
  }

  public void setAssignMaxValue(Object assignMaxValue) {
    this.assignMaxValue = assignMaxValue;
  }


  public ValueTransformation assignMinValue(Object assignMinValue) {
    this.assignMinValue = assignMinValue;
    return this;
  }

  /**
   * A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
   * @return assignMinValue
   */
  @javax.annotation.Nullable
  public Object getAssignMinValue() {
    return assignMinValue;
  }

  public void setAssignMinValue(Object assignMinValue) {
    this.assignMinValue = assignMinValue;
  }


  public ValueTransformation assignNull(Object assignNull) {
    this.assignNull = assignNull;
    return this;
  }

  /**
   * A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
   * @return assignNull
   */
  @javax.annotation.Nullable
  public Object getAssignNull() {
    return assignNull;
  }

  public void setAssignNull(Object assignNull) {
    this.assignNull = assignNull;
  }


  public ValueTransformation assignSpecificValue(AssignSpecificValue assignSpecificValue) {
    this.assignSpecificValue = assignSpecificValue;
    return this;
  }

  /**
   * Get assignSpecificValue
   * @return assignSpecificValue
   */
  @javax.annotation.Nullable
  public AssignSpecificValue getAssignSpecificValue() {
    return assignSpecificValue;
  }

  public void setAssignSpecificValue(AssignSpecificValue assignSpecificValue) {
    this.assignSpecificValue = assignSpecificValue;
  }


  public ValueTransformation doubleComparison(DoubleComparisonFilter doubleComparison) {
    this.doubleComparison = doubleComparison;
    return this;
  }

  /**
   * Get doubleComparison
   * @return doubleComparison
   */
  @javax.annotation.Nullable
  public DoubleComparisonFilter getDoubleComparison() {
    return doubleComparison;
  }

  public void setDoubleComparison(DoubleComparisonFilter doubleComparison) {
    this.doubleComparison = doubleComparison;
  }


  public ValueTransformation intComparison(IntComparisonFilter intComparison) {
    this.intComparison = intComparison;
    return this;
  }

  /**
   * Get intComparison
   * @return intComparison
   */
  @javax.annotation.Nullable
  public IntComparisonFilter getIntComparison() {
    return intComparison;
  }

  public void setIntComparison(IntComparisonFilter intComparison) {
    this.intComparison = intComparison;
  }


  public ValueTransformation isNull(Object isNull) {
    this.isNull = isNull;
    return this;
  }

  /**
   * A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
   * @return isNull
   */
  @javax.annotation.Nullable
  public Object getIsNull() {
    return isNull;
  }

  public void setIsNull(Object isNull) {
    this.isNull = isNull;
  }


  public ValueTransformation roundScale(RoundToScale roundScale) {
    this.roundScale = roundScale;
    return this;
  }

  /**
   * Get roundScale
   * @return roundScale
   */
  @javax.annotation.Nullable
  public RoundToScale getRoundScale() {
    return roundScale;
  }

  public void setRoundScale(RoundToScale roundScale) {
    this.roundScale = roundScale;
  }


  public ValueTransformation valueList(ValueListFilter valueList) {
    this.valueList = valueList;
    return this;
  }

  /**
   * Get valueList
   * @return valueList
   */
  @javax.annotation.Nullable
  public ValueListFilter getValueList() {
    return valueList;
  }

  public void setValueList(ValueListFilter valueList) {
    this.valueList = valueList;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ValueTransformation valueTransformation = (ValueTransformation) o;
    return Objects.equals(this.applyHash, valueTransformation.applyHash) &&
        Objects.equals(this.assignMaxValue, valueTransformation.assignMaxValue) &&
        Objects.equals(this.assignMinValue, valueTransformation.assignMinValue) &&
        Objects.equals(this.assignNull, valueTransformation.assignNull) &&
        Objects.equals(this.assignSpecificValue, valueTransformation.assignSpecificValue) &&
        Objects.equals(this.doubleComparison, valueTransformation.doubleComparison) &&
        Objects.equals(this.intComparison, valueTransformation.intComparison) &&
        Objects.equals(this.isNull, valueTransformation.isNull) &&
        Objects.equals(this.roundScale, valueTransformation.roundScale) &&
        Objects.equals(this.valueList, valueTransformation.valueList);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applyHash, assignMaxValue, assignMinValue, assignNull, assignSpecificValue, doubleComparison, intComparison, isNull, roundScale, valueList);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ValueTransformation {\n");
    sb.append("    applyHash: ").append(toIndentedString(applyHash)).append("\n");
    sb.append("    assignMaxValue: ").append(toIndentedString(assignMaxValue)).append("\n");
    sb.append("    assignMinValue: ").append(toIndentedString(assignMinValue)).append("\n");
    sb.append("    assignNull: ").append(toIndentedString(assignNull)).append("\n");
    sb.append("    assignSpecificValue: ").append(toIndentedString(assignSpecificValue)).append("\n");
    sb.append("    doubleComparison: ").append(toIndentedString(doubleComparison)).append("\n");
    sb.append("    intComparison: ").append(toIndentedString(intComparison)).append("\n");
    sb.append("    isNull: ").append(toIndentedString(isNull)).append("\n");
    sb.append("    roundScale: ").append(toIndentedString(roundScale)).append("\n");
    sb.append("    valueList: ").append(toIndentedString(valueList)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("applyHash");
    openapiFields.add("assignMaxValue");
    openapiFields.add("assignMinValue");
    openapiFields.add("assignNull");
    openapiFields.add("assignSpecificValue");
    openapiFields.add("doubleComparison");
    openapiFields.add("intComparison");
    openapiFields.add("isNull");
    openapiFields.add("roundScale");
    openapiFields.add("valueList");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ValueTransformation
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ValueTransformation.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ValueTransformation is not found in the empty JSON string", ValueTransformation.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ValueTransformation.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ValueTransformation` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `applyHash`
      if (jsonObj.get("applyHash") != null && !jsonObj.get("applyHash").isJsonNull()) {
        ApplyHash.validateJsonElement(jsonObj.get("applyHash"));
      }
      // validate the optional field `assignSpecificValue`
      if (jsonObj.get("assignSpecificValue") != null && !jsonObj.get("assignSpecificValue").isJsonNull()) {
        AssignSpecificValue.validateJsonElement(jsonObj.get("assignSpecificValue"));
      }
      // validate the optional field `doubleComparison`
      if (jsonObj.get("doubleComparison") != null && !jsonObj.get("doubleComparison").isJsonNull()) {
        DoubleComparisonFilter.validateJsonElement(jsonObj.get("doubleComparison"));
      }
      // validate the optional field `intComparison`
      if (jsonObj.get("intComparison") != null && !jsonObj.get("intComparison").isJsonNull()) {
        IntComparisonFilter.validateJsonElement(jsonObj.get("intComparison"));
      }
      // validate the optional field `roundScale`
      if (jsonObj.get("roundScale") != null && !jsonObj.get("roundScale").isJsonNull()) {
        RoundToScale.validateJsonElement(jsonObj.get("roundScale"));
      }
      // validate the optional field `valueList`
      if (jsonObj.get("valueList") != null && !jsonObj.get("valueList").isJsonNull()) {
        ValueListFilter.validateJsonElement(jsonObj.get("valueList"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ValueTransformation.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ValueTransformation' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ValueTransformation> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ValueTransformation.class));

       return (TypeAdapter<T>) new TypeAdapter<ValueTransformation>() {
           @Override
           public void write(JsonWriter out, ValueTransformation value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ValueTransformation read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ValueTransformation given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ValueTransformation
   * @throws IOException if the JSON string is invalid with respect to ValueTransformation
   */
  public static ValueTransformation fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ValueTransformation.class);
  }

  /**
   * Convert an instance of ValueTransformation to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

