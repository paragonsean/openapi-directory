/*
 * Service Usage API
 * Enables services that service consumers want to use on Google Cloud Platform, lists the available or enabled services, or disables services that service consumers no longer use.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * &#x60;QuotaLimit&#x60; defines a specific limit that applies over a specified duration for a limit type. There can be at most one limit for a duration and limit type combination defined within a &#x60;QuotaGroup&#x60;.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:34:50.247624-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class QuotaLimit {
  public static final String SERIALIZED_NAME_DEFAULT_LIMIT = "defaultLimit";
  @SerializedName(SERIALIZED_NAME_DEFAULT_LIMIT)
  private String defaultLimit;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_DURATION = "duration";
  @SerializedName(SERIALIZED_NAME_DURATION)
  private String duration;

  public static final String SERIALIZED_NAME_FREE_TIER = "freeTier";
  @SerializedName(SERIALIZED_NAME_FREE_TIER)
  private String freeTier;

  public static final String SERIALIZED_NAME_MAX_LIMIT = "maxLimit";
  @SerializedName(SERIALIZED_NAME_MAX_LIMIT)
  private String maxLimit;

  public static final String SERIALIZED_NAME_METRIC = "metric";
  @SerializedName(SERIALIZED_NAME_METRIC)
  private String metric;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_UNIT = "unit";
  @SerializedName(SERIALIZED_NAME_UNIT)
  private String unit;

  public static final String SERIALIZED_NAME_VALUES = "values";
  @SerializedName(SERIALIZED_NAME_VALUES)
  private Map<String, String> values = new HashMap<>();

  public QuotaLimit() {
  }

  public QuotaLimit defaultLimit(String defaultLimit) {
    this.defaultLimit = defaultLimit;
    return this;
  }

  /**
   * Default number of tokens that can be consumed during the specified duration. This is the number of tokens assigned when a client application developer activates the service for his/her project. Specifying a value of 0 will block all requests. This can be used if you are provisioning quota to selected consumers and blocking others. Similarly, a value of -1 will indicate an unlimited quota. No other negative values are allowed. Used by group-based quotas only.
   * @return defaultLimit
   */
  @javax.annotation.Nullable
  public String getDefaultLimit() {
    return defaultLimit;
  }

  public void setDefaultLimit(String defaultLimit) {
    this.defaultLimit = defaultLimit;
  }


  public QuotaLimit description(String description) {
    this.description = description;
    return this;
  }

  /**
   * Optional. User-visible, extended description for this quota limit. Should be used only when more context is needed to understand this limit than provided by the limit&#39;s display name (see: &#x60;display_name&#x60;).
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public QuotaLimit displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * User-visible display name for this limit. Optional. If not set, the UI will provide a default display name based on the quota configuration. This field can be used to override the default display name generated from the configuration.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public QuotaLimit duration(String duration) {
    this.duration = duration;
    return this;
  }

  /**
   * Duration of this limit in textual notation. Must be \&quot;100s\&quot; or \&quot;1d\&quot;. Used by group-based quotas only.
   * @return duration
   */
  @javax.annotation.Nullable
  public String getDuration() {
    return duration;
  }

  public void setDuration(String duration) {
    this.duration = duration;
  }


  public QuotaLimit freeTier(String freeTier) {
    this.freeTier = freeTier;
    return this;
  }

  /**
   * Free tier value displayed in the Developers Console for this limit. The free tier is the number of tokens that will be subtracted from the billed amount when billing is enabled. This field can only be set on a limit with duration \&quot;1d\&quot;, in a billable group; it is invalid on any other limit. If this field is not set, it defaults to 0, indicating that there is no free tier for this service. Used by group-based quotas only.
   * @return freeTier
   */
  @javax.annotation.Nullable
  public String getFreeTier() {
    return freeTier;
  }

  public void setFreeTier(String freeTier) {
    this.freeTier = freeTier;
  }


  public QuotaLimit maxLimit(String maxLimit) {
    this.maxLimit = maxLimit;
    return this;
  }

  /**
   * Maximum number of tokens that can be consumed during the specified duration. Client application developers can override the default limit up to this maximum. If specified, this value cannot be set to a value less than the default limit. If not specified, it is set to the default limit. To allow clients to apply overrides with no upper bound, set this to -1, indicating unlimited maximum quota. Used by group-based quotas only.
   * @return maxLimit
   */
  @javax.annotation.Nullable
  public String getMaxLimit() {
    return maxLimit;
  }

  public void setMaxLimit(String maxLimit) {
    this.maxLimit = maxLimit;
  }


  public QuotaLimit metric(String metric) {
    this.metric = metric;
    return this;
  }

  /**
   * The name of the metric this quota limit applies to. The quota limits with the same metric will be checked together during runtime. The metric must be defined within the service config.
   * @return metric
   */
  @javax.annotation.Nullable
  public String getMetric() {
    return metric;
  }

  public void setMetric(String metric) {
    this.metric = metric;
  }


  public QuotaLimit name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of the quota limit. The name must be provided, and it must be unique within the service. The name can only include alphanumeric characters as well as &#39;-&#39;. The maximum length of the limit name is 64 characters.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public QuotaLimit unit(String unit) {
    this.unit = unit;
    return this;
  }

  /**
   * Specify the unit of the quota limit. It uses the same syntax as Metric.unit. The supported unit kinds are determined by the quota backend system. Here are some examples: * \&quot;1/min/{project}\&quot; for quota per minute per project. Note: the order of unit components is insignificant. The \&quot;1\&quot; at the beginning is required to follow the metric unit syntax.
   * @return unit
   */
  @javax.annotation.Nullable
  public String getUnit() {
    return unit;
  }

  public void setUnit(String unit) {
    this.unit = unit;
  }


  public QuotaLimit values(Map<String, String> values) {
    this.values = values;
    return this;
  }

  public QuotaLimit putValuesItem(String key, String valuesItem) {
    if (this.values == null) {
      this.values = new HashMap<>();
    }
    this.values.put(key, valuesItem);
    return this;
  }

  /**
   * Tiered limit values. You must specify this as a key:value pair, with an integer value that is the maximum number of requests allowed for the specified unit. Currently only STANDARD is supported.
   * @return values
   */
  @javax.annotation.Nullable
  public Map<String, String> getValues() {
    return values;
  }

  public void setValues(Map<String, String> values) {
    this.values = values;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    QuotaLimit quotaLimit = (QuotaLimit) o;
    return Objects.equals(this.defaultLimit, quotaLimit.defaultLimit) &&
        Objects.equals(this.description, quotaLimit.description) &&
        Objects.equals(this.displayName, quotaLimit.displayName) &&
        Objects.equals(this.duration, quotaLimit.duration) &&
        Objects.equals(this.freeTier, quotaLimit.freeTier) &&
        Objects.equals(this.maxLimit, quotaLimit.maxLimit) &&
        Objects.equals(this.metric, quotaLimit.metric) &&
        Objects.equals(this.name, quotaLimit.name) &&
        Objects.equals(this.unit, quotaLimit.unit) &&
        Objects.equals(this.values, quotaLimit.values);
  }

  @Override
  public int hashCode() {
    return Objects.hash(defaultLimit, description, displayName, duration, freeTier, maxLimit, metric, name, unit, values);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class QuotaLimit {\n");
    sb.append("    defaultLimit: ").append(toIndentedString(defaultLimit)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
    sb.append("    freeTier: ").append(toIndentedString(freeTier)).append("\n");
    sb.append("    maxLimit: ").append(toIndentedString(maxLimit)).append("\n");
    sb.append("    metric: ").append(toIndentedString(metric)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    unit: ").append(toIndentedString(unit)).append("\n");
    sb.append("    values: ").append(toIndentedString(values)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("defaultLimit");
    openapiFields.add("description");
    openapiFields.add("displayName");
    openapiFields.add("duration");
    openapiFields.add("freeTier");
    openapiFields.add("maxLimit");
    openapiFields.add("metric");
    openapiFields.add("name");
    openapiFields.add("unit");
    openapiFields.add("values");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to QuotaLimit
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!QuotaLimit.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in QuotaLimit is not found in the empty JSON string", QuotaLimit.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!QuotaLimit.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `QuotaLimit` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("defaultLimit") != null && !jsonObj.get("defaultLimit").isJsonNull()) && !jsonObj.get("defaultLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `defaultLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("defaultLimit").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("duration") != null && !jsonObj.get("duration").isJsonNull()) && !jsonObj.get("duration").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `duration` to be a primitive type in the JSON string but got `%s`", jsonObj.get("duration").toString()));
      }
      if ((jsonObj.get("freeTier") != null && !jsonObj.get("freeTier").isJsonNull()) && !jsonObj.get("freeTier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `freeTier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("freeTier").toString()));
      }
      if ((jsonObj.get("maxLimit") != null && !jsonObj.get("maxLimit").isJsonNull()) && !jsonObj.get("maxLimit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `maxLimit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("maxLimit").toString()));
      }
      if ((jsonObj.get("metric") != null && !jsonObj.get("metric").isJsonNull()) && !jsonObj.get("metric").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `metric` to be a primitive type in the JSON string but got `%s`", jsonObj.get("metric").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("unit") != null && !jsonObj.get("unit").isJsonNull()) && !jsonObj.get("unit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `unit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("unit").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!QuotaLimit.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'QuotaLimit' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<QuotaLimit> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(QuotaLimit.class));

       return (TypeAdapter<T>) new TypeAdapter<QuotaLimit>() {
           @Override
           public void write(JsonWriter out, QuotaLimit value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public QuotaLimit read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of QuotaLimit given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of QuotaLimit
   * @throws IOException if the JSON string is invalid with respect to QuotaLimit
   */
  public static QuotaLimit fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, QuotaLimit.class);
  }

  /**
   * Convert an instance of QuotaLimit to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

