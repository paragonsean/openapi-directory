# coding: utf-8

from datetime import date, datetime

from typing import List, Dict, Type

from openapi_server.models.base_model import Model
from openapi_server.models.method import Method
from openapi_server.models.mixin import Mixin
from openapi_server.models.option import Option
from openapi_server.models.source_context import SourceContext
from openapi_server import util


class Api(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, methods: List[Method]=None, mixins: List[Mixin]=None, name: str=None, options: List[Option]=None, source_context: SourceContext=None, syntax: str=None, version: str=None):
        """Api - a model defined in OpenAPI

        :param methods: The methods of this Api.
        :param mixins: The mixins of this Api.
        :param name: The name of this Api.
        :param options: The options of this Api.
        :param source_context: The source_context of this Api.
        :param syntax: The syntax of this Api.
        :param version: The version of this Api.
        """
        self.openapi_types = {
            'methods': List[Method],
            'mixins': List[Mixin],
            'name': str,
            'options': List[Option],
            'source_context': SourceContext,
            'syntax': str,
            'version': str
        }

        self.attribute_map = {
            'methods': 'methods',
            'mixins': 'mixins',
            'name': 'name',
            'options': 'options',
            'source_context': 'sourceContext',
            'syntax': 'syntax',
            'version': 'version'
        }

        self._methods = methods
        self._mixins = mixins
        self._name = name
        self._options = options
        self._source_context = source_context
        self._syntax = syntax
        self._version = version

    @classmethod
    def from_dict(cls, dikt: dict) -> 'Api':
        """Returns the dict as a model

        :param dikt: A dict.
        :return: The Api of this Api.
        """
        return util.deserialize_model(dikt, cls)

    @property
    def methods(self):
        """Gets the methods of this Api.

        The methods of this interface, in unspecified order.

        :return: The methods of this Api.
        :rtype: List[Method]
        """
        return self._methods

    @methods.setter
    def methods(self, methods):
        """Sets the methods of this Api.

        The methods of this interface, in unspecified order.

        :param methods: The methods of this Api.
        :type methods: List[Method]
        """

        self._methods = methods

    @property
    def mixins(self):
        """Gets the mixins of this Api.

        Included interfaces. See Mixin.

        :return: The mixins of this Api.
        :rtype: List[Mixin]
        """
        return self._mixins

    @mixins.setter
    def mixins(self, mixins):
        """Sets the mixins of this Api.

        Included interfaces. See Mixin.

        :param mixins: The mixins of this Api.
        :type mixins: List[Mixin]
        """

        self._mixins = mixins

    @property
    def name(self):
        """Gets the name of this Api.

        The fully qualified name of this interface, including package name followed by the interface's simple name.

        :return: The name of this Api.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Api.

        The fully qualified name of this interface, including package name followed by the interface's simple name.

        :param name: The name of this Api.
        :type name: str
        """

        self._name = name

    @property
    def options(self):
        """Gets the options of this Api.

        Any metadata attached to the interface.

        :return: The options of this Api.
        :rtype: List[Option]
        """
        return self._options

    @options.setter
    def options(self, options):
        """Sets the options of this Api.

        Any metadata attached to the interface.

        :param options: The options of this Api.
        :type options: List[Option]
        """

        self._options = options

    @property
    def source_context(self):
        """Gets the source_context of this Api.


        :return: The source_context of this Api.
        :rtype: SourceContext
        """
        return self._source_context

    @source_context.setter
    def source_context(self, source_context):
        """Sets the source_context of this Api.


        :param source_context: The source_context of this Api.
        :type source_context: SourceContext
        """

        self._source_context = source_context

    @property
    def syntax(self):
        """Gets the syntax of this Api.

        The source syntax of the service.

        :return: The syntax of this Api.
        :rtype: str
        """
        return self._syntax

    @syntax.setter
    def syntax(self, syntax):
        """Sets the syntax of this Api.

        The source syntax of the service.

        :param syntax: The syntax of this Api.
        :type syntax: str
        """
        allowed_values = ["SYNTAX_PROTO2", "SYNTAX_PROTO3", "SYNTAX_EDITIONS"]  # noqa: E501
        if syntax not in allowed_values:
            raise ValueError(
                "Invalid value for `syntax` ({0}), must be one of {1}"
                .format(syntax, allowed_values)
            )

        self._syntax = syntax

    @property
    def version(self):
        """Gets the version of this Api.

        A version string for this interface. If specified, must have the form `major-version.minor-version`, as in `1.10`. If the minor version is omitted, it defaults to zero. If the entire version field is empty, the major version is derived from the package name, as outlined below. If the field is not empty, the version in the package name will be verified to be consistent with what is provided here. The versioning schema uses [semantic versioning](http://semver.org) where the major version number indicates a breaking change and the minor version an additive, non-breaking change. Both version numbers are signals to users what to expect from different versions, and should be carefully chosen based on the product plan. The major version is also reflected in the package name of the interface, which must end in `v`, as in `google.feature.v1`. For major versions 0 and 1, the suffix can be omitted. Zero major versions must only be used for experimental, non-GA interfaces. 

        :return: The version of this Api.
        :rtype: str
        """
        return self._version

    @version.setter
    def version(self, version):
        """Sets the version of this Api.

        A version string for this interface. If specified, must have the form `major-version.minor-version`, as in `1.10`. If the minor version is omitted, it defaults to zero. If the entire version field is empty, the major version is derived from the package name, as outlined below. If the field is not empty, the version in the package name will be verified to be consistent with what is provided here. The versioning schema uses [semantic versioning](http://semver.org) where the major version number indicates a breaking change and the minor version an additive, non-breaking change. Both version numbers are signals to users what to expect from different versions, and should be carefully chosen based on the product plan. The major version is also reflected in the package name of the interface, which must end in `v`, as in `google.feature.v1`. For major versions 0 and 1, the suffix can be omitted. Zero major versions must only be used for experimental, non-GA interfaces. 

        :param version: The version of this Api.
        :type version: str
        """

        self._version = version
