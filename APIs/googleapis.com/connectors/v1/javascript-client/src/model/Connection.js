/**
 * Connectors API
 * Enables users to create and manage connections to Google Cloud services and third-party business applications using the Connectors interface.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import AuthConfig from './AuthConfig';
import ConfigVariable from './ConfigVariable';
import ConnectionStatus from './ConnectionStatus';
import ConnectorVersionInfraConfig from './ConnectorVersionInfraConfig';
import ConnectorsLogConfig from './ConnectorsLogConfig';
import DestinationConfig from './DestinationConfig';
import EventingConfig from './EventingConfig';
import EventingRuntimeData from './EventingRuntimeData';
import LockConfig from './LockConfig';
import NodeConfig from './NodeConfig';
import SslConfig from './SslConfig';

/**
 * The Connection model module.
 * @module model/Connection
 * @version v1
 */
class Connection {
    /**
     * Constructs a new <code>Connection</code>.
     * Connection represents an instance of connector.
     * @alias module:model/Connection
     */
    constructor() { 
        
        Connection.initialize(this);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj) { 
    }

    /**
     * Constructs a <code>Connection</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/Connection} obj Optional instance to populate.
     * @return {module:model/Connection} The populated <code>Connection</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new Connection();

            if (data.hasOwnProperty('authConfig')) {
                obj['authConfig'] = AuthConfig.constructFromObject(data['authConfig']);
            }
            if (data.hasOwnProperty('configVariables')) {
                obj['configVariables'] = ApiClient.convertToType(data['configVariables'], [ConfigVariable]);
            }
            if (data.hasOwnProperty('connectionRevision')) {
                obj['connectionRevision'] = ApiClient.convertToType(data['connectionRevision'], 'String');
            }
            if (data.hasOwnProperty('connectorVersion')) {
                obj['connectorVersion'] = ApiClient.convertToType(data['connectorVersion'], 'String');
            }
            if (data.hasOwnProperty('connectorVersionInfraConfig')) {
                obj['connectorVersionInfraConfig'] = ConnectorVersionInfraConfig.constructFromObject(data['connectorVersionInfraConfig']);
            }
            if (data.hasOwnProperty('connectorVersionLaunchStage')) {
                obj['connectorVersionLaunchStage'] = ApiClient.convertToType(data['connectorVersionLaunchStage'], 'String');
            }
            if (data.hasOwnProperty('createTime')) {
                obj['createTime'] = ApiClient.convertToType(data['createTime'], 'String');
            }
            if (data.hasOwnProperty('description')) {
                obj['description'] = ApiClient.convertToType(data['description'], 'String');
            }
            if (data.hasOwnProperty('destinationConfigs')) {
                obj['destinationConfigs'] = ApiClient.convertToType(data['destinationConfigs'], [DestinationConfig]);
            }
            if (data.hasOwnProperty('envoyImageLocation')) {
                obj['envoyImageLocation'] = ApiClient.convertToType(data['envoyImageLocation'], 'String');
            }
            if (data.hasOwnProperty('eventingConfig')) {
                obj['eventingConfig'] = EventingConfig.constructFromObject(data['eventingConfig']);
            }
            if (data.hasOwnProperty('eventingEnablementType')) {
                obj['eventingEnablementType'] = ApiClient.convertToType(data['eventingEnablementType'], 'String');
            }
            if (data.hasOwnProperty('eventingRuntimeData')) {
                obj['eventingRuntimeData'] = EventingRuntimeData.constructFromObject(data['eventingRuntimeData']);
            }
            if (data.hasOwnProperty('imageLocation')) {
                obj['imageLocation'] = ApiClient.convertToType(data['imageLocation'], 'String');
            }
            if (data.hasOwnProperty('isTrustedTester')) {
                obj['isTrustedTester'] = ApiClient.convertToType(data['isTrustedTester'], 'Boolean');
            }
            if (data.hasOwnProperty('labels')) {
                obj['labels'] = ApiClient.convertToType(data['labels'], {'String': 'String'});
            }
            if (data.hasOwnProperty('lockConfig')) {
                obj['lockConfig'] = LockConfig.constructFromObject(data['lockConfig']);
            }
            if (data.hasOwnProperty('logConfig')) {
                obj['logConfig'] = ConnectorsLogConfig.constructFromObject(data['logConfig']);
            }
            if (data.hasOwnProperty('name')) {
                obj['name'] = ApiClient.convertToType(data['name'], 'String');
            }
            if (data.hasOwnProperty('nodeConfig')) {
                obj['nodeConfig'] = NodeConfig.constructFromObject(data['nodeConfig']);
            }
            if (data.hasOwnProperty('serviceAccount')) {
                obj['serviceAccount'] = ApiClient.convertToType(data['serviceAccount'], 'String');
            }
            if (data.hasOwnProperty('serviceDirectory')) {
                obj['serviceDirectory'] = ApiClient.convertToType(data['serviceDirectory'], 'String');
            }
            if (data.hasOwnProperty('sslConfig')) {
                obj['sslConfig'] = SslConfig.constructFromObject(data['sslConfig']);
            }
            if (data.hasOwnProperty('status')) {
                obj['status'] = ConnectionStatus.constructFromObject(data['status']);
            }
            if (data.hasOwnProperty('subscriptionType')) {
                obj['subscriptionType'] = ApiClient.convertToType(data['subscriptionType'], 'String');
            }
            if (data.hasOwnProperty('suspended')) {
                obj['suspended'] = ApiClient.convertToType(data['suspended'], 'Boolean');
            }
            if (data.hasOwnProperty('updateTime')) {
                obj['updateTime'] = ApiClient.convertToType(data['updateTime'], 'String');
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>Connection</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>Connection</code>.
     */
    static validateJSON(data) {
        // validate the optional field `authConfig`
        if (data['authConfig']) { // data not null
          AuthConfig.validateJSON(data['authConfig']);
        }
        if (data['configVariables']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['configVariables'])) {
                throw new Error("Expected the field `configVariables` to be an array in the JSON data but got " + data['configVariables']);
            }
            // validate the optional field `configVariables` (array)
            for (const item of data['configVariables']) {
                ConfigVariable.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['connectionRevision'] && !(typeof data['connectionRevision'] === 'string' || data['connectionRevision'] instanceof String)) {
            throw new Error("Expected the field `connectionRevision` to be a primitive type in the JSON string but got " + data['connectionRevision']);
        }
        // ensure the json data is a string
        if (data['connectorVersion'] && !(typeof data['connectorVersion'] === 'string' || data['connectorVersion'] instanceof String)) {
            throw new Error("Expected the field `connectorVersion` to be a primitive type in the JSON string but got " + data['connectorVersion']);
        }
        // validate the optional field `connectorVersionInfraConfig`
        if (data['connectorVersionInfraConfig']) { // data not null
          ConnectorVersionInfraConfig.validateJSON(data['connectorVersionInfraConfig']);
        }
        // ensure the json data is a string
        if (data['connectorVersionLaunchStage'] && !(typeof data['connectorVersionLaunchStage'] === 'string' || data['connectorVersionLaunchStage'] instanceof String)) {
            throw new Error("Expected the field `connectorVersionLaunchStage` to be a primitive type in the JSON string but got " + data['connectorVersionLaunchStage']);
        }
        // ensure the json data is a string
        if (data['createTime'] && !(typeof data['createTime'] === 'string' || data['createTime'] instanceof String)) {
            throw new Error("Expected the field `createTime` to be a primitive type in the JSON string but got " + data['createTime']);
        }
        // ensure the json data is a string
        if (data['description'] && !(typeof data['description'] === 'string' || data['description'] instanceof String)) {
            throw new Error("Expected the field `description` to be a primitive type in the JSON string but got " + data['description']);
        }
        if (data['destinationConfigs']) { // data not null
            // ensure the json data is an array
            if (!Array.isArray(data['destinationConfigs'])) {
                throw new Error("Expected the field `destinationConfigs` to be an array in the JSON data but got " + data['destinationConfigs']);
            }
            // validate the optional field `destinationConfigs` (array)
            for (const item of data['destinationConfigs']) {
                DestinationConfig.validateJSON(item);
            };
        }
        // ensure the json data is a string
        if (data['envoyImageLocation'] && !(typeof data['envoyImageLocation'] === 'string' || data['envoyImageLocation'] instanceof String)) {
            throw new Error("Expected the field `envoyImageLocation` to be a primitive type in the JSON string but got " + data['envoyImageLocation']);
        }
        // validate the optional field `eventingConfig`
        if (data['eventingConfig']) { // data not null
          EventingConfig.validateJSON(data['eventingConfig']);
        }
        // ensure the json data is a string
        if (data['eventingEnablementType'] && !(typeof data['eventingEnablementType'] === 'string' || data['eventingEnablementType'] instanceof String)) {
            throw new Error("Expected the field `eventingEnablementType` to be a primitive type in the JSON string but got " + data['eventingEnablementType']);
        }
        // validate the optional field `eventingRuntimeData`
        if (data['eventingRuntimeData']) { // data not null
          EventingRuntimeData.validateJSON(data['eventingRuntimeData']);
        }
        // ensure the json data is a string
        if (data['imageLocation'] && !(typeof data['imageLocation'] === 'string' || data['imageLocation'] instanceof String)) {
            throw new Error("Expected the field `imageLocation` to be a primitive type in the JSON string but got " + data['imageLocation']);
        }
        // validate the optional field `lockConfig`
        if (data['lockConfig']) { // data not null
          LockConfig.validateJSON(data['lockConfig']);
        }
        // validate the optional field `logConfig`
        if (data['logConfig']) { // data not null
          ConnectorsLogConfig.validateJSON(data['logConfig']);
        }
        // ensure the json data is a string
        if (data['name'] && !(typeof data['name'] === 'string' || data['name'] instanceof String)) {
            throw new Error("Expected the field `name` to be a primitive type in the JSON string but got " + data['name']);
        }
        // validate the optional field `nodeConfig`
        if (data['nodeConfig']) { // data not null
          NodeConfig.validateJSON(data['nodeConfig']);
        }
        // ensure the json data is a string
        if (data['serviceAccount'] && !(typeof data['serviceAccount'] === 'string' || data['serviceAccount'] instanceof String)) {
            throw new Error("Expected the field `serviceAccount` to be a primitive type in the JSON string but got " + data['serviceAccount']);
        }
        // ensure the json data is a string
        if (data['serviceDirectory'] && !(typeof data['serviceDirectory'] === 'string' || data['serviceDirectory'] instanceof String)) {
            throw new Error("Expected the field `serviceDirectory` to be a primitive type in the JSON string but got " + data['serviceDirectory']);
        }
        // validate the optional field `sslConfig`
        if (data['sslConfig']) { // data not null
          SslConfig.validateJSON(data['sslConfig']);
        }
        // validate the optional field `status`
        if (data['status']) { // data not null
          ConnectionStatus.validateJSON(data['status']);
        }
        // ensure the json data is a string
        if (data['subscriptionType'] && !(typeof data['subscriptionType'] === 'string' || data['subscriptionType'] instanceof String)) {
            throw new Error("Expected the field `subscriptionType` to be a primitive type in the JSON string but got " + data['subscriptionType']);
        }
        // ensure the json data is a string
        if (data['updateTime'] && !(typeof data['updateTime'] === 'string' || data['updateTime'] instanceof String)) {
            throw new Error("Expected the field `updateTime` to be a primitive type in the JSON string but got " + data['updateTime']);
        }

        return true;
    }


}



/**
 * @member {module:model/AuthConfig} authConfig
 */
Connection.prototype['authConfig'] = undefined;

/**
 * Optional. Configuration for configuring the connection with an external system.
 * @member {Array.<module:model/ConfigVariable>} configVariables
 */
Connection.prototype['configVariables'] = undefined;

/**
 * Output only. Connection revision. This field is only updated when the connection is created or updated by User.
 * @member {String} connectionRevision
 */
Connection.prototype['connectionRevision'] = undefined;

/**
 * Required. Connector version on which the connection is created. The format is: projects/_*_/locations/_*_/providers/_*_/connectors/_*_/versions/_* Only global location is supported for ConnectorVersion resource.
 * @member {String} connectorVersion
 */
Connection.prototype['connectorVersion'] = undefined;

/**
 * @member {module:model/ConnectorVersionInfraConfig} connectorVersionInfraConfig
 */
Connection.prototype['connectorVersionInfraConfig'] = undefined;

/**
 * Output only. Flag to mark the version indicating the launch stage.
 * @member {module:model/Connection.ConnectorVersionLaunchStageEnum} connectorVersionLaunchStage
 */
Connection.prototype['connectorVersionLaunchStage'] = undefined;

/**
 * Output only. Created time.
 * @member {String} createTime
 */
Connection.prototype['createTime'] = undefined;

/**
 * Optional. Description of the resource.
 * @member {String} description
 */
Connection.prototype['description'] = undefined;

/**
 * Optional. Configuration of the Connector's destination. Only accepted for Connectors that accepts user defined destination(s).
 * @member {Array.<module:model/DestinationConfig>} destinationConfigs
 */
Connection.prototype['destinationConfigs'] = undefined;

/**
 * Output only. GCR location where the envoy image is stored. formatted like: gcr.io/{bucketName}/{imageName}
 * @member {String} envoyImageLocation
 */
Connection.prototype['envoyImageLocation'] = undefined;

/**
 * @member {module:model/EventingConfig} eventingConfig
 */
Connection.prototype['eventingConfig'] = undefined;

/**
 * Optional. Eventing enablement type. Will be nil if eventing is not enabled.
 * @member {module:model/Connection.EventingEnablementTypeEnum} eventingEnablementType
 */
Connection.prototype['eventingEnablementType'] = undefined;

/**
 * @member {module:model/EventingRuntimeData} eventingRuntimeData
 */
Connection.prototype['eventingRuntimeData'] = undefined;

/**
 * Output only. GCR location where the runtime image is stored. formatted like: gcr.io/{bucketName}/{imageName}
 * @member {String} imageLocation
 */
Connection.prototype['imageLocation'] = undefined;

/**
 * Output only. Is trusted tester program enabled for the project.
 * @member {Boolean} isTrustedTester
 */
Connection.prototype['isTrustedTester'] = undefined;

/**
 * Optional. Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
 * @member {Object.<String, String>} labels
 */
Connection.prototype['labels'] = undefined;

/**
 * @member {module:model/LockConfig} lockConfig
 */
Connection.prototype['lockConfig'] = undefined;

/**
 * @member {module:model/ConnectorsLogConfig} logConfig
 */
Connection.prototype['logConfig'] = undefined;

/**
 * Output only. Resource name of the Connection. Format: projects/{project}/locations/{location}/connections/{connection}
 * @member {String} name
 */
Connection.prototype['name'] = undefined;

/**
 * @member {module:model/NodeConfig} nodeConfig
 */
Connection.prototype['nodeConfig'] = undefined;

/**
 * Optional. Service account needed for runtime plane to access Google Cloud resources.
 * @member {String} serviceAccount
 */
Connection.prototype['serviceAccount'] = undefined;

/**
 * Output only. The name of the Service Directory service name. Used for Private Harpoon to resolve the ILB address. e.g. \"projects/cloud-connectors-e2e-testing/locations/us-central1/namespaces/istio-system/services/istio-ingressgateway-connectors\"
 * @member {String} serviceDirectory
 */
Connection.prototype['serviceDirectory'] = undefined;

/**
 * @member {module:model/SslConfig} sslConfig
 */
Connection.prototype['sslConfig'] = undefined;

/**
 * @member {module:model/ConnectionStatus} status
 */
Connection.prototype['status'] = undefined;

/**
 * Output only. This subscription type enum states the subscription type of the project.
 * @member {module:model/Connection.SubscriptionTypeEnum} subscriptionType
 */
Connection.prototype['subscriptionType'] = undefined;

/**
 * Optional. Suspended indicates if a user has suspended a connection or not.
 * @member {Boolean} suspended
 */
Connection.prototype['suspended'] = undefined;

/**
 * Output only. Updated time.
 * @member {String} updateTime
 */
Connection.prototype['updateTime'] = undefined;





/**
 * Allowed values for the <code>connectorVersionLaunchStage</code> property.
 * @enum {String}
 * @readonly
 */
Connection['ConnectorVersionLaunchStageEnum'] = {

    /**
     * value: "LAUNCH_STAGE_UNSPECIFIED"
     * @const
     */
    "LAUNCH_STAGE_UNSPECIFIED": "LAUNCH_STAGE_UNSPECIFIED",

    /**
     * value: "PREVIEW"
     * @const
     */
    "PREVIEW": "PREVIEW",

    /**
     * value: "GA"
     * @const
     */
    "GA": "GA",

    /**
     * value: "DEPRECATED"
     * @const
     */
    "DEPRECATED": "DEPRECATED",

    /**
     * value: "PRIVATE_PREVIEW"
     * @const
     */
    "PRIVATE_PREVIEW": "PRIVATE_PREVIEW"
};


/**
 * Allowed values for the <code>eventingEnablementType</code> property.
 * @enum {String}
 * @readonly
 */
Connection['EventingEnablementTypeEnum'] = {

    /**
     * value: "EVENTING_ENABLEMENT_TYPE_UNSPECIFIED"
     * @const
     */
    "EVENTING_ENABLEMENT_TYPE_UNSPECIFIED": "EVENTING_ENABLEMENT_TYPE_UNSPECIFIED",

    /**
     * value: "EVENTING_AND_CONNECTION"
     * @const
     */
    "EVENTING_AND_CONNECTION": "EVENTING_AND_CONNECTION",

    /**
     * value: "ONLY_EVENTING"
     * @const
     */
    "ONLY_EVENTING": "ONLY_EVENTING"
};


/**
 * Allowed values for the <code>subscriptionType</code> property.
 * @enum {String}
 * @readonly
 */
Connection['SubscriptionTypeEnum'] = {

    /**
     * value: "SUBSCRIPTION_TYPE_UNSPECIFIED"
     * @const
     */
    "SUBSCRIPTION_TYPE_UNSPECIFIED": "SUBSCRIPTION_TYPE_UNSPECIFIED",

    /**
     * value: "PAY_G"
     * @const
     */
    "PAY_G": "PAY_G",

    /**
     * value: "PAID"
     * @const
     */
    "PAID": "PAID"
};



export default Connection;

