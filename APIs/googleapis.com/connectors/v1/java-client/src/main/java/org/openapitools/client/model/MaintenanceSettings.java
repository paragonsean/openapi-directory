/*
 * Connectors API
 * Enables users to create and manage connections to Google Cloud services and third-party business applications using the Connectors interface.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.client.model.MaintenancePolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Maintenance settings associated with instance. Allows service producers and end users to assign settings that controls maintenance on this instance.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:44:50.207857-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class MaintenanceSettings {
  public static final String SERIALIZED_NAME_EXCLUDE = "exclude";
  @SerializedName(SERIALIZED_NAME_EXCLUDE)
  private Boolean exclude;

  public static final String SERIALIZED_NAME_IS_ROLLBACK = "isRollback";
  @SerializedName(SERIALIZED_NAME_IS_ROLLBACK)
  private Boolean isRollback;

  public static final String SERIALIZED_NAME_MAINTENANCE_POLICIES = "maintenancePolicies";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_POLICIES)
  private Map<String, MaintenancePolicy> maintenancePolicies = new HashMap<>();

  public MaintenanceSettings() {
  }

  public MaintenanceSettings exclude(Boolean exclude) {
    this.exclude = exclude;
    return this;
  }

  /**
   * Optional. Exclude instance from maintenance. When true, rollout service will not attempt maintenance on the instance. Rollout service will include the instance in reported rollout progress as not attempted.
   * @return exclude
   */
  @javax.annotation.Nullable
  public Boolean getExclude() {
    return exclude;
  }

  public void setExclude(Boolean exclude) {
    this.exclude = exclude;
  }


  public MaintenanceSettings isRollback(Boolean isRollback) {
    this.isRollback = isRollback;
    return this;
  }

  /**
   * Optional. If the update call is triggered from rollback, set the value as true.
   * @return isRollback
   */
  @javax.annotation.Nullable
  public Boolean getIsRollback() {
    return isRollback;
  }

  public void setIsRollback(Boolean isRollback) {
    this.isRollback = isRollback;
  }


  public MaintenanceSettings maintenancePolicies(Map<String, MaintenancePolicy> maintenancePolicies) {
    this.maintenancePolicies = maintenancePolicies;
    return this;
  }

  public MaintenanceSettings putMaintenancePoliciesItem(String key, MaintenancePolicy maintenancePoliciesItem) {
    if (this.maintenancePolicies == null) {
      this.maintenancePolicies = new HashMap<>();
    }
    this.maintenancePolicies.put(key, maintenancePoliciesItem);
    return this;
  }

  /**
   * Optional. The MaintenancePolicies that have been attached to the instance. The key must be of the type name of the oneof policy name defined in MaintenancePolicy, and the embedded policy must define the same policy type. For details, please refer to go/mr-user-guide. Should not be set if maintenance_policy_names is set. If only the name is needed, then only populate MaintenancePolicy.name.
   * @return maintenancePolicies
   */
  @javax.annotation.Nullable
  public Map<String, MaintenancePolicy> getMaintenancePolicies() {
    return maintenancePolicies;
  }

  public void setMaintenancePolicies(Map<String, MaintenancePolicy> maintenancePolicies) {
    this.maintenancePolicies = maintenancePolicies;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MaintenanceSettings maintenanceSettings = (MaintenanceSettings) o;
    return Objects.equals(this.exclude, maintenanceSettings.exclude) &&
        Objects.equals(this.isRollback, maintenanceSettings.isRollback) &&
        Objects.equals(this.maintenancePolicies, maintenanceSettings.maintenancePolicies);
  }

  @Override
  public int hashCode() {
    return Objects.hash(exclude, isRollback, maintenancePolicies);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MaintenanceSettings {\n");
    sb.append("    exclude: ").append(toIndentedString(exclude)).append("\n");
    sb.append("    isRollback: ").append(toIndentedString(isRollback)).append("\n");
    sb.append("    maintenancePolicies: ").append(toIndentedString(maintenancePolicies)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("exclude");
    openapiFields.add("isRollback");
    openapiFields.add("maintenancePolicies");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to MaintenanceSettings
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MaintenanceSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MaintenanceSettings is not found in the empty JSON string", MaintenanceSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!MaintenanceSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MaintenanceSettings` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MaintenanceSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MaintenanceSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MaintenanceSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MaintenanceSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<MaintenanceSettings>() {
           @Override
           public void write(JsonWriter out, MaintenanceSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MaintenanceSettings read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of MaintenanceSettings given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of MaintenanceSettings
   * @throws IOException if the JSON string is invalid with respect to MaintenanceSettings
   */
  public static MaintenanceSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MaintenanceSettings.class);
  }

  /**
   * Convert an instance of MaintenanceSettings to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

