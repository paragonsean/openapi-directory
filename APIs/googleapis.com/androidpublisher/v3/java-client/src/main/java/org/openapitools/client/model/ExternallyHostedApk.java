/*
 * Google Play Android Developer API
 * Lets Android application developers access their Google Play accounts. At a high level, the expected workflow is to \"insert\" an Edit, make changes as necessary, and then \"commit\" it. 
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.UsesPermission;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Defines an APK available for this application that is hosted externally and not uploaded to Google Play. This function is only available to organizations using Managed Play whose application is configured to restrict distribution to the organizations.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:32.125268-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class ExternallyHostedApk {
  public static final String SERIALIZED_NAME_APPLICATION_LABEL = "applicationLabel";
  @SerializedName(SERIALIZED_NAME_APPLICATION_LABEL)
  private String applicationLabel;

  public static final String SERIALIZED_NAME_CERTIFICATE_BASE64S = "certificateBase64s";
  @SerializedName(SERIALIZED_NAME_CERTIFICATE_BASE64S)
  private List<String> certificateBase64s = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXTERNALLY_HOSTED_URL = "externallyHostedUrl";
  @SerializedName(SERIALIZED_NAME_EXTERNALLY_HOSTED_URL)
  private String externallyHostedUrl;

  public static final String SERIALIZED_NAME_FILE_SHA1_BASE64 = "fileSha1Base64";
  @SerializedName(SERIALIZED_NAME_FILE_SHA1_BASE64)
  private String fileSha1Base64;

  public static final String SERIALIZED_NAME_FILE_SHA256_BASE64 = "fileSha256Base64";
  @SerializedName(SERIALIZED_NAME_FILE_SHA256_BASE64)
  private String fileSha256Base64;

  public static final String SERIALIZED_NAME_FILE_SIZE = "fileSize";
  @SerializedName(SERIALIZED_NAME_FILE_SIZE)
  private String fileSize;

  public static final String SERIALIZED_NAME_ICON_BASE64 = "iconBase64";
  @SerializedName(SERIALIZED_NAME_ICON_BASE64)
  private String iconBase64;

  public static final String SERIALIZED_NAME_MAXIMUM_SDK = "maximumSdk";
  @SerializedName(SERIALIZED_NAME_MAXIMUM_SDK)
  private Integer maximumSdk;

  public static final String SERIALIZED_NAME_MINIMUM_SDK = "minimumSdk";
  @SerializedName(SERIALIZED_NAME_MINIMUM_SDK)
  private Integer minimumSdk;

  public static final String SERIALIZED_NAME_NATIVE_CODES = "nativeCodes";
  @SerializedName(SERIALIZED_NAME_NATIVE_CODES)
  private List<String> nativeCodes = new ArrayList<>();

  public static final String SERIALIZED_NAME_PACKAGE_NAME = "packageName";
  @SerializedName(SERIALIZED_NAME_PACKAGE_NAME)
  private String packageName;

  public static final String SERIALIZED_NAME_USES_FEATURES = "usesFeatures";
  @SerializedName(SERIALIZED_NAME_USES_FEATURES)
  private List<String> usesFeatures = new ArrayList<>();

  public static final String SERIALIZED_NAME_USES_PERMISSIONS = "usesPermissions";
  @SerializedName(SERIALIZED_NAME_USES_PERMISSIONS)
  private List<UsesPermission> usesPermissions = new ArrayList<>();

  public static final String SERIALIZED_NAME_VERSION_CODE = "versionCode";
  @SerializedName(SERIALIZED_NAME_VERSION_CODE)
  private Integer versionCode;

  public static final String SERIALIZED_NAME_VERSION_NAME = "versionName";
  @SerializedName(SERIALIZED_NAME_VERSION_NAME)
  private String versionName;

  public ExternallyHostedApk() {
  }

  public ExternallyHostedApk applicationLabel(String applicationLabel) {
    this.applicationLabel = applicationLabel;
    return this;
  }

  /**
   * The application label.
   * @return applicationLabel
   */
  @javax.annotation.Nullable
  public String getApplicationLabel() {
    return applicationLabel;
  }

  public void setApplicationLabel(String applicationLabel) {
    this.applicationLabel = applicationLabel;
  }


  public ExternallyHostedApk certificateBase64s(List<String> certificateBase64s) {
    this.certificateBase64s = certificateBase64s;
    return this;
  }

  public ExternallyHostedApk addCertificateBase64sItem(String certificateBase64sItem) {
    if (this.certificateBase64s == null) {
      this.certificateBase64s = new ArrayList<>();
    }
    this.certificateBase64s.add(certificateBase64sItem);
    return this;
  }

  /**
   * A certificate (or array of certificates if a certificate-chain is used) used to sign this APK, represented as a base64 encoded byte array.
   * @return certificateBase64s
   */
  @javax.annotation.Nullable
  public List<String> getCertificateBase64s() {
    return certificateBase64s;
  }

  public void setCertificateBase64s(List<String> certificateBase64s) {
    this.certificateBase64s = certificateBase64s;
  }


  public ExternallyHostedApk externallyHostedUrl(String externallyHostedUrl) {
    this.externallyHostedUrl = externallyHostedUrl;
    return this;
  }

  /**
   * The URL at which the APK is hosted. This must be an https URL.
   * @return externallyHostedUrl
   */
  @javax.annotation.Nullable
  public String getExternallyHostedUrl() {
    return externallyHostedUrl;
  }

  public void setExternallyHostedUrl(String externallyHostedUrl) {
    this.externallyHostedUrl = externallyHostedUrl;
  }


  public ExternallyHostedApk fileSha1Base64(String fileSha1Base64) {
    this.fileSha1Base64 = fileSha1Base64;
    return this;
  }

  /**
   * The sha1 checksum of this APK, represented as a base64 encoded byte array.
   * @return fileSha1Base64
   */
  @javax.annotation.Nullable
  public String getFileSha1Base64() {
    return fileSha1Base64;
  }

  public void setFileSha1Base64(String fileSha1Base64) {
    this.fileSha1Base64 = fileSha1Base64;
  }


  public ExternallyHostedApk fileSha256Base64(String fileSha256Base64) {
    this.fileSha256Base64 = fileSha256Base64;
    return this;
  }

  /**
   * The sha256 checksum of this APK, represented as a base64 encoded byte array.
   * @return fileSha256Base64
   */
  @javax.annotation.Nullable
  public String getFileSha256Base64() {
    return fileSha256Base64;
  }

  public void setFileSha256Base64(String fileSha256Base64) {
    this.fileSha256Base64 = fileSha256Base64;
  }


  public ExternallyHostedApk fileSize(String fileSize) {
    this.fileSize = fileSize;
    return this;
  }

  /**
   * The file size in bytes of this APK.
   * @return fileSize
   */
  @javax.annotation.Nullable
  public String getFileSize() {
    return fileSize;
  }

  public void setFileSize(String fileSize) {
    this.fileSize = fileSize;
  }


  public ExternallyHostedApk iconBase64(String iconBase64) {
    this.iconBase64 = iconBase64;
    return this;
  }

  /**
   * The icon image from the APK, as a base64 encoded byte array.
   * @return iconBase64
   */
  @javax.annotation.Nullable
  public String getIconBase64() {
    return iconBase64;
  }

  public void setIconBase64(String iconBase64) {
    this.iconBase64 = iconBase64;
  }


  public ExternallyHostedApk maximumSdk(Integer maximumSdk) {
    this.maximumSdk = maximumSdk;
    return this;
  }

  /**
   * The maximum SDK supported by this APK (optional).
   * @return maximumSdk
   */
  @javax.annotation.Nullable
  public Integer getMaximumSdk() {
    return maximumSdk;
  }

  public void setMaximumSdk(Integer maximumSdk) {
    this.maximumSdk = maximumSdk;
  }


  public ExternallyHostedApk minimumSdk(Integer minimumSdk) {
    this.minimumSdk = minimumSdk;
    return this;
  }

  /**
   * The minimum SDK targeted by this APK.
   * @return minimumSdk
   */
  @javax.annotation.Nullable
  public Integer getMinimumSdk() {
    return minimumSdk;
  }

  public void setMinimumSdk(Integer minimumSdk) {
    this.minimumSdk = minimumSdk;
  }


  public ExternallyHostedApk nativeCodes(List<String> nativeCodes) {
    this.nativeCodes = nativeCodes;
    return this;
  }

  public ExternallyHostedApk addNativeCodesItem(String nativeCodesItem) {
    if (this.nativeCodes == null) {
      this.nativeCodes = new ArrayList<>();
    }
    this.nativeCodes.add(nativeCodesItem);
    return this;
  }

  /**
   * The native code environments supported by this APK (optional).
   * @return nativeCodes
   */
  @javax.annotation.Nullable
  public List<String> getNativeCodes() {
    return nativeCodes;
  }

  public void setNativeCodes(List<String> nativeCodes) {
    this.nativeCodes = nativeCodes;
  }


  public ExternallyHostedApk packageName(String packageName) {
    this.packageName = packageName;
    return this;
  }

  /**
   * The package name.
   * @return packageName
   */
  @javax.annotation.Nullable
  public String getPackageName() {
    return packageName;
  }

  public void setPackageName(String packageName) {
    this.packageName = packageName;
  }


  public ExternallyHostedApk usesFeatures(List<String> usesFeatures) {
    this.usesFeatures = usesFeatures;
    return this;
  }

  public ExternallyHostedApk addUsesFeaturesItem(String usesFeaturesItem) {
    if (this.usesFeatures == null) {
      this.usesFeatures = new ArrayList<>();
    }
    this.usesFeatures.add(usesFeaturesItem);
    return this;
  }

  /**
   * The features required by this APK (optional).
   * @return usesFeatures
   */
  @javax.annotation.Nullable
  public List<String> getUsesFeatures() {
    return usesFeatures;
  }

  public void setUsesFeatures(List<String> usesFeatures) {
    this.usesFeatures = usesFeatures;
  }


  public ExternallyHostedApk usesPermissions(List<UsesPermission> usesPermissions) {
    this.usesPermissions = usesPermissions;
    return this;
  }

  public ExternallyHostedApk addUsesPermissionsItem(UsesPermission usesPermissionsItem) {
    if (this.usesPermissions == null) {
      this.usesPermissions = new ArrayList<>();
    }
    this.usesPermissions.add(usesPermissionsItem);
    return this;
  }

  /**
   * The permissions requested by this APK.
   * @return usesPermissions
   */
  @javax.annotation.Nullable
  public List<UsesPermission> getUsesPermissions() {
    return usesPermissions;
  }

  public void setUsesPermissions(List<UsesPermission> usesPermissions) {
    this.usesPermissions = usesPermissions;
  }


  public ExternallyHostedApk versionCode(Integer versionCode) {
    this.versionCode = versionCode;
    return this;
  }

  /**
   * The version code of this APK.
   * @return versionCode
   */
  @javax.annotation.Nullable
  public Integer getVersionCode() {
    return versionCode;
  }

  public void setVersionCode(Integer versionCode) {
    this.versionCode = versionCode;
  }


  public ExternallyHostedApk versionName(String versionName) {
    this.versionName = versionName;
    return this;
  }

  /**
   * The version name of this APK.
   * @return versionName
   */
  @javax.annotation.Nullable
  public String getVersionName() {
    return versionName;
  }

  public void setVersionName(String versionName) {
    this.versionName = versionName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExternallyHostedApk externallyHostedApk = (ExternallyHostedApk) o;
    return Objects.equals(this.applicationLabel, externallyHostedApk.applicationLabel) &&
        Objects.equals(this.certificateBase64s, externallyHostedApk.certificateBase64s) &&
        Objects.equals(this.externallyHostedUrl, externallyHostedApk.externallyHostedUrl) &&
        Objects.equals(this.fileSha1Base64, externallyHostedApk.fileSha1Base64) &&
        Objects.equals(this.fileSha256Base64, externallyHostedApk.fileSha256Base64) &&
        Objects.equals(this.fileSize, externallyHostedApk.fileSize) &&
        Objects.equals(this.iconBase64, externallyHostedApk.iconBase64) &&
        Objects.equals(this.maximumSdk, externallyHostedApk.maximumSdk) &&
        Objects.equals(this.minimumSdk, externallyHostedApk.minimumSdk) &&
        Objects.equals(this.nativeCodes, externallyHostedApk.nativeCodes) &&
        Objects.equals(this.packageName, externallyHostedApk.packageName) &&
        Objects.equals(this.usesFeatures, externallyHostedApk.usesFeatures) &&
        Objects.equals(this.usesPermissions, externallyHostedApk.usesPermissions) &&
        Objects.equals(this.versionCode, externallyHostedApk.versionCode) &&
        Objects.equals(this.versionName, externallyHostedApk.versionName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicationLabel, certificateBase64s, externallyHostedUrl, fileSha1Base64, fileSha256Base64, fileSize, iconBase64, maximumSdk, minimumSdk, nativeCodes, packageName, usesFeatures, usesPermissions, versionCode, versionName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExternallyHostedApk {\n");
    sb.append("    applicationLabel: ").append(toIndentedString(applicationLabel)).append("\n");
    sb.append("    certificateBase64s: ").append(toIndentedString(certificateBase64s)).append("\n");
    sb.append("    externallyHostedUrl: ").append(toIndentedString(externallyHostedUrl)).append("\n");
    sb.append("    fileSha1Base64: ").append(toIndentedString(fileSha1Base64)).append("\n");
    sb.append("    fileSha256Base64: ").append(toIndentedString(fileSha256Base64)).append("\n");
    sb.append("    fileSize: ").append(toIndentedString(fileSize)).append("\n");
    sb.append("    iconBase64: ").append(toIndentedString(iconBase64)).append("\n");
    sb.append("    maximumSdk: ").append(toIndentedString(maximumSdk)).append("\n");
    sb.append("    minimumSdk: ").append(toIndentedString(minimumSdk)).append("\n");
    sb.append("    nativeCodes: ").append(toIndentedString(nativeCodes)).append("\n");
    sb.append("    packageName: ").append(toIndentedString(packageName)).append("\n");
    sb.append("    usesFeatures: ").append(toIndentedString(usesFeatures)).append("\n");
    sb.append("    usesPermissions: ").append(toIndentedString(usesPermissions)).append("\n");
    sb.append("    versionCode: ").append(toIndentedString(versionCode)).append("\n");
    sb.append("    versionName: ").append(toIndentedString(versionName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("applicationLabel");
    openapiFields.add("certificateBase64s");
    openapiFields.add("externallyHostedUrl");
    openapiFields.add("fileSha1Base64");
    openapiFields.add("fileSha256Base64");
    openapiFields.add("fileSize");
    openapiFields.add("iconBase64");
    openapiFields.add("maximumSdk");
    openapiFields.add("minimumSdk");
    openapiFields.add("nativeCodes");
    openapiFields.add("packageName");
    openapiFields.add("usesFeatures");
    openapiFields.add("usesPermissions");
    openapiFields.add("versionCode");
    openapiFields.add("versionName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ExternallyHostedApk
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ExternallyHostedApk.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExternallyHostedApk is not found in the empty JSON string", ExternallyHostedApk.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ExternallyHostedApk.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExternallyHostedApk` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("applicationLabel") != null && !jsonObj.get("applicationLabel").isJsonNull()) && !jsonObj.get("applicationLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `applicationLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("applicationLabel").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("certificateBase64s") != null && !jsonObj.get("certificateBase64s").isJsonNull() && !jsonObj.get("certificateBase64s").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `certificateBase64s` to be an array in the JSON string but got `%s`", jsonObj.get("certificateBase64s").toString()));
      }
      if ((jsonObj.get("externallyHostedUrl") != null && !jsonObj.get("externallyHostedUrl").isJsonNull()) && !jsonObj.get("externallyHostedUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `externallyHostedUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("externallyHostedUrl").toString()));
      }
      if ((jsonObj.get("fileSha1Base64") != null && !jsonObj.get("fileSha1Base64").isJsonNull()) && !jsonObj.get("fileSha1Base64").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileSha1Base64` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileSha1Base64").toString()));
      }
      if ((jsonObj.get("fileSha256Base64") != null && !jsonObj.get("fileSha256Base64").isJsonNull()) && !jsonObj.get("fileSha256Base64").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileSha256Base64` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileSha256Base64").toString()));
      }
      if ((jsonObj.get("fileSize") != null && !jsonObj.get("fileSize").isJsonNull()) && !jsonObj.get("fileSize").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fileSize` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fileSize").toString()));
      }
      if ((jsonObj.get("iconBase64") != null && !jsonObj.get("iconBase64").isJsonNull()) && !jsonObj.get("iconBase64").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `iconBase64` to be a primitive type in the JSON string but got `%s`", jsonObj.get("iconBase64").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("nativeCodes") != null && !jsonObj.get("nativeCodes").isJsonNull() && !jsonObj.get("nativeCodes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `nativeCodes` to be an array in the JSON string but got `%s`", jsonObj.get("nativeCodes").toString()));
      }
      if ((jsonObj.get("packageName") != null && !jsonObj.get("packageName").isJsonNull()) && !jsonObj.get("packageName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `packageName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("packageName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("usesFeatures") != null && !jsonObj.get("usesFeatures").isJsonNull() && !jsonObj.get("usesFeatures").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `usesFeatures` to be an array in the JSON string but got `%s`", jsonObj.get("usesFeatures").toString()));
      }
      if (jsonObj.get("usesPermissions") != null && !jsonObj.get("usesPermissions").isJsonNull()) {
        JsonArray jsonArrayusesPermissions = jsonObj.getAsJsonArray("usesPermissions");
        if (jsonArrayusesPermissions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("usesPermissions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `usesPermissions` to be an array in the JSON string but got `%s`", jsonObj.get("usesPermissions").toString()));
          }

          // validate the optional field `usesPermissions` (array)
          for (int i = 0; i < jsonArrayusesPermissions.size(); i++) {
            UsesPermission.validateJsonElement(jsonArrayusesPermissions.get(i));
          };
        }
      }
      if ((jsonObj.get("versionName") != null && !jsonObj.get("versionName").isJsonNull()) && !jsonObj.get("versionName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `versionName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("versionName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExternallyHostedApk.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExternallyHostedApk' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExternallyHostedApk> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExternallyHostedApk.class));

       return (TypeAdapter<T>) new TypeAdapter<ExternallyHostedApk>() {
           @Override
           public void write(JsonWriter out, ExternallyHostedApk value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExternallyHostedApk read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ExternallyHostedApk given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ExternallyHostedApk
   * @throws IOException if the JSON string is invalid with respect to ExternallyHostedApk
   */
  public static ExternallyHostedApk fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExternallyHostedApk.class);
  }

  /**
   * Convert an instance of ExternallyHostedApk to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

