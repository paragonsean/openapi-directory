/*
 * Google Play Android Developer API
 * Lets Android application developers access their Google Play accounts. At a high level, the expected workflow is to \"insert\" an Edit, make changes as necessary, and then \"commit\" it. 
 *
 * The version of the OpenAPI document: v3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.AbiTargeting;
import org.openapitools.client.model.MultiAbiTargeting;
import org.openapitools.client.model.ScreenDensityTargeting;
import org.openapitools.client.model.SdkVersionTargeting;
import org.openapitools.client.model.TextureCompressionFormatTargeting;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Targeting on the level of variants.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-10-12T11:48:32.125268-04:00[America/New_York]", comments = "Generator version: 7.9.0")
public class VariantTargeting {
  public static final String SERIALIZED_NAME_ABI_TARGETING = "abiTargeting";
  @SerializedName(SERIALIZED_NAME_ABI_TARGETING)
  private AbiTargeting abiTargeting;

  public static final String SERIALIZED_NAME_MULTI_ABI_TARGETING = "multiAbiTargeting";
  @SerializedName(SERIALIZED_NAME_MULTI_ABI_TARGETING)
  private MultiAbiTargeting multiAbiTargeting;

  public static final String SERIALIZED_NAME_SCREEN_DENSITY_TARGETING = "screenDensityTargeting";
  @SerializedName(SERIALIZED_NAME_SCREEN_DENSITY_TARGETING)
  private ScreenDensityTargeting screenDensityTargeting;

  public static final String SERIALIZED_NAME_SDK_VERSION_TARGETING = "sdkVersionTargeting";
  @SerializedName(SERIALIZED_NAME_SDK_VERSION_TARGETING)
  private SdkVersionTargeting sdkVersionTargeting;

  public static final String SERIALIZED_NAME_TEXTURE_COMPRESSION_FORMAT_TARGETING = "textureCompressionFormatTargeting";
  @SerializedName(SERIALIZED_NAME_TEXTURE_COMPRESSION_FORMAT_TARGETING)
  private TextureCompressionFormatTargeting textureCompressionFormatTargeting;

  public VariantTargeting() {
  }

  public VariantTargeting abiTargeting(AbiTargeting abiTargeting) {
    this.abiTargeting = abiTargeting;
    return this;
  }

  /**
   * Get abiTargeting
   * @return abiTargeting
   */
  @javax.annotation.Nullable
  public AbiTargeting getAbiTargeting() {
    return abiTargeting;
  }

  public void setAbiTargeting(AbiTargeting abiTargeting) {
    this.abiTargeting = abiTargeting;
  }


  public VariantTargeting multiAbiTargeting(MultiAbiTargeting multiAbiTargeting) {
    this.multiAbiTargeting = multiAbiTargeting;
    return this;
  }

  /**
   * Get multiAbiTargeting
   * @return multiAbiTargeting
   */
  @javax.annotation.Nullable
  public MultiAbiTargeting getMultiAbiTargeting() {
    return multiAbiTargeting;
  }

  public void setMultiAbiTargeting(MultiAbiTargeting multiAbiTargeting) {
    this.multiAbiTargeting = multiAbiTargeting;
  }


  public VariantTargeting screenDensityTargeting(ScreenDensityTargeting screenDensityTargeting) {
    this.screenDensityTargeting = screenDensityTargeting;
    return this;
  }

  /**
   * Get screenDensityTargeting
   * @return screenDensityTargeting
   */
  @javax.annotation.Nullable
  public ScreenDensityTargeting getScreenDensityTargeting() {
    return screenDensityTargeting;
  }

  public void setScreenDensityTargeting(ScreenDensityTargeting screenDensityTargeting) {
    this.screenDensityTargeting = screenDensityTargeting;
  }


  public VariantTargeting sdkVersionTargeting(SdkVersionTargeting sdkVersionTargeting) {
    this.sdkVersionTargeting = sdkVersionTargeting;
    return this;
  }

  /**
   * Get sdkVersionTargeting
   * @return sdkVersionTargeting
   */
  @javax.annotation.Nullable
  public SdkVersionTargeting getSdkVersionTargeting() {
    return sdkVersionTargeting;
  }

  public void setSdkVersionTargeting(SdkVersionTargeting sdkVersionTargeting) {
    this.sdkVersionTargeting = sdkVersionTargeting;
  }


  public VariantTargeting textureCompressionFormatTargeting(TextureCompressionFormatTargeting textureCompressionFormatTargeting) {
    this.textureCompressionFormatTargeting = textureCompressionFormatTargeting;
    return this;
  }

  /**
   * Get textureCompressionFormatTargeting
   * @return textureCompressionFormatTargeting
   */
  @javax.annotation.Nullable
  public TextureCompressionFormatTargeting getTextureCompressionFormatTargeting() {
    return textureCompressionFormatTargeting;
  }

  public void setTextureCompressionFormatTargeting(TextureCompressionFormatTargeting textureCompressionFormatTargeting) {
    this.textureCompressionFormatTargeting = textureCompressionFormatTargeting;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VariantTargeting variantTargeting = (VariantTargeting) o;
    return Objects.equals(this.abiTargeting, variantTargeting.abiTargeting) &&
        Objects.equals(this.multiAbiTargeting, variantTargeting.multiAbiTargeting) &&
        Objects.equals(this.screenDensityTargeting, variantTargeting.screenDensityTargeting) &&
        Objects.equals(this.sdkVersionTargeting, variantTargeting.sdkVersionTargeting) &&
        Objects.equals(this.textureCompressionFormatTargeting, variantTargeting.textureCompressionFormatTargeting);
  }

  @Override
  public int hashCode() {
    return Objects.hash(abiTargeting, multiAbiTargeting, screenDensityTargeting, sdkVersionTargeting, textureCompressionFormatTargeting);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VariantTargeting {\n");
    sb.append("    abiTargeting: ").append(toIndentedString(abiTargeting)).append("\n");
    sb.append("    multiAbiTargeting: ").append(toIndentedString(multiAbiTargeting)).append("\n");
    sb.append("    screenDensityTargeting: ").append(toIndentedString(screenDensityTargeting)).append("\n");
    sb.append("    sdkVersionTargeting: ").append(toIndentedString(sdkVersionTargeting)).append("\n");
    sb.append("    textureCompressionFormatTargeting: ").append(toIndentedString(textureCompressionFormatTargeting)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("abiTargeting");
    openapiFields.add("multiAbiTargeting");
    openapiFields.add("screenDensityTargeting");
    openapiFields.add("sdkVersionTargeting");
    openapiFields.add("textureCompressionFormatTargeting");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VariantTargeting
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VariantTargeting.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VariantTargeting is not found in the empty JSON string", VariantTargeting.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VariantTargeting.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VariantTargeting` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `abiTargeting`
      if (jsonObj.get("abiTargeting") != null && !jsonObj.get("abiTargeting").isJsonNull()) {
        AbiTargeting.validateJsonElement(jsonObj.get("abiTargeting"));
      }
      // validate the optional field `multiAbiTargeting`
      if (jsonObj.get("multiAbiTargeting") != null && !jsonObj.get("multiAbiTargeting").isJsonNull()) {
        MultiAbiTargeting.validateJsonElement(jsonObj.get("multiAbiTargeting"));
      }
      // validate the optional field `screenDensityTargeting`
      if (jsonObj.get("screenDensityTargeting") != null && !jsonObj.get("screenDensityTargeting").isJsonNull()) {
        ScreenDensityTargeting.validateJsonElement(jsonObj.get("screenDensityTargeting"));
      }
      // validate the optional field `sdkVersionTargeting`
      if (jsonObj.get("sdkVersionTargeting") != null && !jsonObj.get("sdkVersionTargeting").isJsonNull()) {
        SdkVersionTargeting.validateJsonElement(jsonObj.get("sdkVersionTargeting"));
      }
      // validate the optional field `textureCompressionFormatTargeting`
      if (jsonObj.get("textureCompressionFormatTargeting") != null && !jsonObj.get("textureCompressionFormatTargeting").isJsonNull()) {
        TextureCompressionFormatTargeting.validateJsonElement(jsonObj.get("textureCompressionFormatTargeting"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VariantTargeting.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VariantTargeting' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VariantTargeting> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VariantTargeting.class));

       return (TypeAdapter<T>) new TypeAdapter<VariantTargeting>() {
           @Override
           public void write(JsonWriter out, VariantTargeting value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VariantTargeting read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VariantTargeting given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VariantTargeting
   * @throws IOException if the JSON string is invalid with respect to VariantTargeting
   */
  public static VariantTargeting fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VariantTargeting.class);
  }

  /**
   * Convert an instance of VariantTargeting to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

